begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_checksum.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/fm/fs/zfs.h>
end_include

begin_comment
comment|/*  * Virtual device vector for RAID-Z.  *  * This vdev supports both single and double parity. For single parity, we  * use a simple XOR of all the data columns. For double parity, we use both  * the simple XOR as well as a technique described in "The mathematics of  * RAID-6" by H. Peter Anvin. This technique defines a Galois field, GF(2^8),  * over the integers expressable in a single byte. Briefly, the operations on  * the field are defined as follows:  *  *   o addition (+) is represented by a bitwise XOR  *   o subtraction (-) is therefore identical to addition: A + B = A - B  *   o multiplication of A by 2 is defined by the following bitwise expression:  *	(A * 2)_7 = A_6  *	(A * 2)_6 = A_5  *	(A * 2)_5 = A_4  *	(A * 2)_4 = A_3 + A_7  *	(A * 2)_3 = A_2 + A_7  *	(A * 2)_2 = A_1 + A_7  *	(A * 2)_1 = A_0  *	(A * 2)_0 = A_7  *  * In C, multiplying by 2 is therefore ((a<< 1) ^ ((a& 0x80) ? 0x1d : 0)).  *  * Observe that any number in the field (except for 0) can be expressed as a  * power of 2 -- a generator for the field. We store a table of the powers of  * 2 and logs base 2 for quick look ups, and exploit the fact that A * B can  * be rewritten as 2^(log_2(A) + log_2(B)) (where '+' is normal addition rather  * than field addition). The inverse of a field element A (A^-1) is A^254.  *  * The two parity columns, P and Q, over several data columns, D_0, ... D_n-1,  * can be expressed by field operations:  *  *	P = D_0 + D_1 + ... + D_n-2 + D_n-1  *	Q = 2^n-1 * D_0 + 2^n-2 * D_1 + ... + 2^1 * D_n-2 + 2^0 * D_n-1  *	  = ((...((D_0) * 2 + D_1) * 2 + ...) * 2 + D_n-2) * 2 + D_n-1  *  * See the reconstruction code below for how P and Q can used individually or  * in concert to recover missing data columns.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|raidz_col
block|{
name|uint64_t
name|rc_devidx
decl_stmt|;
comment|/* child device index for I/O */
name|uint64_t
name|rc_offset
decl_stmt|;
comment|/* device offset */
name|uint64_t
name|rc_size
decl_stmt|;
comment|/* I/O size */
name|void
modifier|*
name|rc_data
decl_stmt|;
comment|/* I/O data */
name|int
name|rc_error
decl_stmt|;
comment|/* I/O error for this device */
name|uint8_t
name|rc_tried
decl_stmt|;
comment|/* Did we attempt this I/O column? */
name|uint8_t
name|rc_skipped
decl_stmt|;
comment|/* Did we skip this I/O column? */
block|}
name|raidz_col_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|raidz_map
block|{
name|uint64_t
name|rm_cols
decl_stmt|;
comment|/* Column count */
name|uint64_t
name|rm_bigcols
decl_stmt|;
comment|/* Number of oversized columns */
name|uint64_t
name|rm_asize
decl_stmt|;
comment|/* Actual total I/O size */
name|uint64_t
name|rm_missingdata
decl_stmt|;
comment|/* Count of missing data devices */
name|uint64_t
name|rm_missingparity
decl_stmt|;
comment|/* Count of missing parity devices */
name|uint64_t
name|rm_firstdatacol
decl_stmt|;
comment|/* First data column/parity count */
name|raidz_col_t
name|rm_col
index|[
literal|1
index|]
decl_stmt|;
comment|/* Flexible array of I/O columns */
block|}
name|raidz_map_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|VDEV_RAIDZ_P
value|0
end_define

begin_define
define|#
directive|define
name|VDEV_RAIDZ_Q
value|1
end_define

begin_define
define|#
directive|define
name|VDEV_RAIDZ_MAXPARITY
value|2
end_define

begin_define
define|#
directive|define
name|VDEV_RAIDZ_MUL_2
parameter_list|(
name|a
parameter_list|)
value|(((a)<< 1) ^ (((a)& 0x80) ? 0x1d : 0))
end_define

begin_comment
comment|/*  * These two tables represent powers and logs of 2 in the Galois field defined  * above. These values were computed by repeatedly multiplying by 2 as above.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|vdev_raidz_pow2
index|[
literal|256
index|]
init|=
block|{
literal|0x01
block|,
literal|0x02
block|,
literal|0x04
block|,
literal|0x08
block|,
literal|0x10
block|,
literal|0x20
block|,
literal|0x40
block|,
literal|0x80
block|,
literal|0x1d
block|,
literal|0x3a
block|,
literal|0x74
block|,
literal|0xe8
block|,
literal|0xcd
block|,
literal|0x87
block|,
literal|0x13
block|,
literal|0x26
block|,
literal|0x4c
block|,
literal|0x98
block|,
literal|0x2d
block|,
literal|0x5a
block|,
literal|0xb4
block|,
literal|0x75
block|,
literal|0xea
block|,
literal|0xc9
block|,
literal|0x8f
block|,
literal|0x03
block|,
literal|0x06
block|,
literal|0x0c
block|,
literal|0x18
block|,
literal|0x30
block|,
literal|0x60
block|,
literal|0xc0
block|,
literal|0x9d
block|,
literal|0x27
block|,
literal|0x4e
block|,
literal|0x9c
block|,
literal|0x25
block|,
literal|0x4a
block|,
literal|0x94
block|,
literal|0x35
block|,
literal|0x6a
block|,
literal|0xd4
block|,
literal|0xb5
block|,
literal|0x77
block|,
literal|0xee
block|,
literal|0xc1
block|,
literal|0x9f
block|,
literal|0x23
block|,
literal|0x46
block|,
literal|0x8c
block|,
literal|0x05
block|,
literal|0x0a
block|,
literal|0x14
block|,
literal|0x28
block|,
literal|0x50
block|,
literal|0xa0
block|,
literal|0x5d
block|,
literal|0xba
block|,
literal|0x69
block|,
literal|0xd2
block|,
literal|0xb9
block|,
literal|0x6f
block|,
literal|0xde
block|,
literal|0xa1
block|,
literal|0x5f
block|,
literal|0xbe
block|,
literal|0x61
block|,
literal|0xc2
block|,
literal|0x99
block|,
literal|0x2f
block|,
literal|0x5e
block|,
literal|0xbc
block|,
literal|0x65
block|,
literal|0xca
block|,
literal|0x89
block|,
literal|0x0f
block|,
literal|0x1e
block|,
literal|0x3c
block|,
literal|0x78
block|,
literal|0xf0
block|,
literal|0xfd
block|,
literal|0xe7
block|,
literal|0xd3
block|,
literal|0xbb
block|,
literal|0x6b
block|,
literal|0xd6
block|,
literal|0xb1
block|,
literal|0x7f
block|,
literal|0xfe
block|,
literal|0xe1
block|,
literal|0xdf
block|,
literal|0xa3
block|,
literal|0x5b
block|,
literal|0xb6
block|,
literal|0x71
block|,
literal|0xe2
block|,
literal|0xd9
block|,
literal|0xaf
block|,
literal|0x43
block|,
literal|0x86
block|,
literal|0x11
block|,
literal|0x22
block|,
literal|0x44
block|,
literal|0x88
block|,
literal|0x0d
block|,
literal|0x1a
block|,
literal|0x34
block|,
literal|0x68
block|,
literal|0xd0
block|,
literal|0xbd
block|,
literal|0x67
block|,
literal|0xce
block|,
literal|0x81
block|,
literal|0x1f
block|,
literal|0x3e
block|,
literal|0x7c
block|,
literal|0xf8
block|,
literal|0xed
block|,
literal|0xc7
block|,
literal|0x93
block|,
literal|0x3b
block|,
literal|0x76
block|,
literal|0xec
block|,
literal|0xc5
block|,
literal|0x97
block|,
literal|0x33
block|,
literal|0x66
block|,
literal|0xcc
block|,
literal|0x85
block|,
literal|0x17
block|,
literal|0x2e
block|,
literal|0x5c
block|,
literal|0xb8
block|,
literal|0x6d
block|,
literal|0xda
block|,
literal|0xa9
block|,
literal|0x4f
block|,
literal|0x9e
block|,
literal|0x21
block|,
literal|0x42
block|,
literal|0x84
block|,
literal|0x15
block|,
literal|0x2a
block|,
literal|0x54
block|,
literal|0xa8
block|,
literal|0x4d
block|,
literal|0x9a
block|,
literal|0x29
block|,
literal|0x52
block|,
literal|0xa4
block|,
literal|0x55
block|,
literal|0xaa
block|,
literal|0x49
block|,
literal|0x92
block|,
literal|0x39
block|,
literal|0x72
block|,
literal|0xe4
block|,
literal|0xd5
block|,
literal|0xb7
block|,
literal|0x73
block|,
literal|0xe6
block|,
literal|0xd1
block|,
literal|0xbf
block|,
literal|0x63
block|,
literal|0xc6
block|,
literal|0x91
block|,
literal|0x3f
block|,
literal|0x7e
block|,
literal|0xfc
block|,
literal|0xe5
block|,
literal|0xd7
block|,
literal|0xb3
block|,
literal|0x7b
block|,
literal|0xf6
block|,
literal|0xf1
block|,
literal|0xff
block|,
literal|0xe3
block|,
literal|0xdb
block|,
literal|0xab
block|,
literal|0x4b
block|,
literal|0x96
block|,
literal|0x31
block|,
literal|0x62
block|,
literal|0xc4
block|,
literal|0x95
block|,
literal|0x37
block|,
literal|0x6e
block|,
literal|0xdc
block|,
literal|0xa5
block|,
literal|0x57
block|,
literal|0xae
block|,
literal|0x41
block|,
literal|0x82
block|,
literal|0x19
block|,
literal|0x32
block|,
literal|0x64
block|,
literal|0xc8
block|,
literal|0x8d
block|,
literal|0x07
block|,
literal|0x0e
block|,
literal|0x1c
block|,
literal|0x38
block|,
literal|0x70
block|,
literal|0xe0
block|,
literal|0xdd
block|,
literal|0xa7
block|,
literal|0x53
block|,
literal|0xa6
block|,
literal|0x51
block|,
literal|0xa2
block|,
literal|0x59
block|,
literal|0xb2
block|,
literal|0x79
block|,
literal|0xf2
block|,
literal|0xf9
block|,
literal|0xef
block|,
literal|0xc3
block|,
literal|0x9b
block|,
literal|0x2b
block|,
literal|0x56
block|,
literal|0xac
block|,
literal|0x45
block|,
literal|0x8a
block|,
literal|0x09
block|,
literal|0x12
block|,
literal|0x24
block|,
literal|0x48
block|,
literal|0x90
block|,
literal|0x3d
block|,
literal|0x7a
block|,
literal|0xf4
block|,
literal|0xf5
block|,
literal|0xf7
block|,
literal|0xf3
block|,
literal|0xfb
block|,
literal|0xeb
block|,
literal|0xcb
block|,
literal|0x8b
block|,
literal|0x0b
block|,
literal|0x16
block|,
literal|0x2c
block|,
literal|0x58
block|,
literal|0xb0
block|,
literal|0x7d
block|,
literal|0xfa
block|,
literal|0xe9
block|,
literal|0xcf
block|,
literal|0x83
block|,
literal|0x1b
block|,
literal|0x36
block|,
literal|0x6c
block|,
literal|0xd8
block|,
literal|0xad
block|,
literal|0x47
block|,
literal|0x8e
block|,
literal|0x01
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|vdev_raidz_log2
index|[
literal|256
index|]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x19
block|,
literal|0x02
block|,
literal|0x32
block|,
literal|0x1a
block|,
literal|0xc6
block|,
literal|0x03
block|,
literal|0xdf
block|,
literal|0x33
block|,
literal|0xee
block|,
literal|0x1b
block|,
literal|0x68
block|,
literal|0xc7
block|,
literal|0x4b
block|,
literal|0x04
block|,
literal|0x64
block|,
literal|0xe0
block|,
literal|0x0e
block|,
literal|0x34
block|,
literal|0x8d
block|,
literal|0xef
block|,
literal|0x81
block|,
literal|0x1c
block|,
literal|0xc1
block|,
literal|0x69
block|,
literal|0xf8
block|,
literal|0xc8
block|,
literal|0x08
block|,
literal|0x4c
block|,
literal|0x71
block|,
literal|0x05
block|,
literal|0x8a
block|,
literal|0x65
block|,
literal|0x2f
block|,
literal|0xe1
block|,
literal|0x24
block|,
literal|0x0f
block|,
literal|0x21
block|,
literal|0x35
block|,
literal|0x93
block|,
literal|0x8e
block|,
literal|0xda
block|,
literal|0xf0
block|,
literal|0x12
block|,
literal|0x82
block|,
literal|0x45
block|,
literal|0x1d
block|,
literal|0xb5
block|,
literal|0xc2
block|,
literal|0x7d
block|,
literal|0x6a
block|,
literal|0x27
block|,
literal|0xf9
block|,
literal|0xb9
block|,
literal|0xc9
block|,
literal|0x9a
block|,
literal|0x09
block|,
literal|0x78
block|,
literal|0x4d
block|,
literal|0xe4
block|,
literal|0x72
block|,
literal|0xa6
block|,
literal|0x06
block|,
literal|0xbf
block|,
literal|0x8b
block|,
literal|0x62
block|,
literal|0x66
block|,
literal|0xdd
block|,
literal|0x30
block|,
literal|0xfd
block|,
literal|0xe2
block|,
literal|0x98
block|,
literal|0x25
block|,
literal|0xb3
block|,
literal|0x10
block|,
literal|0x91
block|,
literal|0x22
block|,
literal|0x88
block|,
literal|0x36
block|,
literal|0xd0
block|,
literal|0x94
block|,
literal|0xce
block|,
literal|0x8f
block|,
literal|0x96
block|,
literal|0xdb
block|,
literal|0xbd
block|,
literal|0xf1
block|,
literal|0xd2
block|,
literal|0x13
block|,
literal|0x5c
block|,
literal|0x83
block|,
literal|0x38
block|,
literal|0x46
block|,
literal|0x40
block|,
literal|0x1e
block|,
literal|0x42
block|,
literal|0xb6
block|,
literal|0xa3
block|,
literal|0xc3
block|,
literal|0x48
block|,
literal|0x7e
block|,
literal|0x6e
block|,
literal|0x6b
block|,
literal|0x3a
block|,
literal|0x28
block|,
literal|0x54
block|,
literal|0xfa
block|,
literal|0x85
block|,
literal|0xba
block|,
literal|0x3d
block|,
literal|0xca
block|,
literal|0x5e
block|,
literal|0x9b
block|,
literal|0x9f
block|,
literal|0x0a
block|,
literal|0x15
block|,
literal|0x79
block|,
literal|0x2b
block|,
literal|0x4e
block|,
literal|0xd4
block|,
literal|0xe5
block|,
literal|0xac
block|,
literal|0x73
block|,
literal|0xf3
block|,
literal|0xa7
block|,
literal|0x57
block|,
literal|0x07
block|,
literal|0x70
block|,
literal|0xc0
block|,
literal|0xf7
block|,
literal|0x8c
block|,
literal|0x80
block|,
literal|0x63
block|,
literal|0x0d
block|,
literal|0x67
block|,
literal|0x4a
block|,
literal|0xde
block|,
literal|0xed
block|,
literal|0x31
block|,
literal|0xc5
block|,
literal|0xfe
block|,
literal|0x18
block|,
literal|0xe3
block|,
literal|0xa5
block|,
literal|0x99
block|,
literal|0x77
block|,
literal|0x26
block|,
literal|0xb8
block|,
literal|0xb4
block|,
literal|0x7c
block|,
literal|0x11
block|,
literal|0x44
block|,
literal|0x92
block|,
literal|0xd9
block|,
literal|0x23
block|,
literal|0x20
block|,
literal|0x89
block|,
literal|0x2e
block|,
literal|0x37
block|,
literal|0x3f
block|,
literal|0xd1
block|,
literal|0x5b
block|,
literal|0x95
block|,
literal|0xbc
block|,
literal|0xcf
block|,
literal|0xcd
block|,
literal|0x90
block|,
literal|0x87
block|,
literal|0x97
block|,
literal|0xb2
block|,
literal|0xdc
block|,
literal|0xfc
block|,
literal|0xbe
block|,
literal|0x61
block|,
literal|0xf2
block|,
literal|0x56
block|,
literal|0xd3
block|,
literal|0xab
block|,
literal|0x14
block|,
literal|0x2a
block|,
literal|0x5d
block|,
literal|0x9e
block|,
literal|0x84
block|,
literal|0x3c
block|,
literal|0x39
block|,
literal|0x53
block|,
literal|0x47
block|,
literal|0x6d
block|,
literal|0x41
block|,
literal|0xa2
block|,
literal|0x1f
block|,
literal|0x2d
block|,
literal|0x43
block|,
literal|0xd8
block|,
literal|0xb7
block|,
literal|0x7b
block|,
literal|0xa4
block|,
literal|0x76
block|,
literal|0xc4
block|,
literal|0x17
block|,
literal|0x49
block|,
literal|0xec
block|,
literal|0x7f
block|,
literal|0x0c
block|,
literal|0x6f
block|,
literal|0xf6
block|,
literal|0x6c
block|,
literal|0xa1
block|,
literal|0x3b
block|,
literal|0x52
block|,
literal|0x29
block|,
literal|0x9d
block|,
literal|0x55
block|,
literal|0xaa
block|,
literal|0xfb
block|,
literal|0x60
block|,
literal|0x86
block|,
literal|0xb1
block|,
literal|0xbb
block|,
literal|0xcc
block|,
literal|0x3e
block|,
literal|0x5a
block|,
literal|0xcb
block|,
literal|0x59
block|,
literal|0x5f
block|,
literal|0xb0
block|,
literal|0x9c
block|,
literal|0xa9
block|,
literal|0xa0
block|,
literal|0x51
block|,
literal|0x0b
block|,
literal|0xf5
block|,
literal|0x16
block|,
literal|0xeb
block|,
literal|0x7a
block|,
literal|0x75
block|,
literal|0x2c
block|,
literal|0xd7
block|,
literal|0x4f
block|,
literal|0xae
block|,
literal|0xd5
block|,
literal|0xe9
block|,
literal|0xe6
block|,
literal|0xe7
block|,
literal|0xad
block|,
literal|0xe8
block|,
literal|0x74
block|,
literal|0xd6
block|,
literal|0xf4
block|,
literal|0xea
block|,
literal|0xa8
block|,
literal|0x50
block|,
literal|0x58
block|,
literal|0xaf
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Multiply a given number by 2 raised to the given power.  */
end_comment

begin_function
specifier|static
name|uint8_t
name|vdev_raidz_exp2
parameter_list|(
name|uint_t
name|a
parameter_list|,
name|int
name|exp
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ASSERT
argument_list|(
name|exp
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vdev_raidz_log2
index|[
name|a
index|]
operator|>
literal|0
operator|||
name|a
operator|==
literal|1
argument_list|)
expr_stmt|;
name|exp
operator|+=
name|vdev_raidz_log2
index|[
name|a
index|]
expr_stmt|;
if|if
condition|(
name|exp
operator|>
literal|255
condition|)
name|exp
operator|-=
literal|255
expr_stmt|;
return|return
operator|(
name|vdev_raidz_pow2
index|[
name|exp
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_map_free
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|raidz_map_t
modifier|*
name|rm
init|=
name|zio
operator|->
name|io_vsd
decl_stmt|;
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_firstdatacol
condition|;
name|c
operator|++
control|)
name|zio_buf_free
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_data
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|rm
argument_list|,
name|offsetof
argument_list|(
name|raidz_map_t
argument_list|,
name|rm_col
index|[
name|rm
operator|->
name|rm_cols
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|raidz_map_t
modifier|*
name|vdev_raidz_map_alloc
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|uint64_t
name|unit_shift
parameter_list|,
name|uint64_t
name|dcols
parameter_list|,
name|uint64_t
name|nparity
parameter_list|)
block|{
name|raidz_map_t
modifier|*
name|rm
decl_stmt|;
name|uint64_t
name|b
init|=
name|zio
operator|->
name|io_offset
operator|>>
name|unit_shift
decl_stmt|;
name|uint64_t
name|s
init|=
name|zio
operator|->
name|io_size
operator|>>
name|unit_shift
decl_stmt|;
name|uint64_t
name|f
init|=
name|b
operator|%
name|dcols
decl_stmt|;
name|uint64_t
name|o
init|=
operator|(
name|b
operator|/
name|dcols
operator|)
operator|<<
name|unit_shift
decl_stmt|;
name|uint64_t
name|q
decl_stmt|,
name|r
decl_stmt|,
name|c
decl_stmt|,
name|bc
decl_stmt|,
name|col
decl_stmt|,
name|acols
decl_stmt|,
name|coff
decl_stmt|,
name|devidx
decl_stmt|;
name|q
operator|=
name|s
operator|/
operator|(
name|dcols
operator|-
name|nparity
operator|)
expr_stmt|;
name|r
operator|=
name|s
operator|-
name|q
operator|*
operator|(
name|dcols
operator|-
name|nparity
operator|)
expr_stmt|;
name|bc
operator|=
operator|(
name|r
operator|==
literal|0
condition|?
literal|0
else|:
name|r
operator|+
name|nparity
operator|)
expr_stmt|;
name|acols
operator|=
operator|(
name|q
operator|==
literal|0
condition|?
name|bc
else|:
name|dcols
operator|)
expr_stmt|;
name|rm
operator|=
name|kmem_alloc
argument_list|(
name|offsetof
argument_list|(
name|raidz_map_t
argument_list|,
name|rm_col
index|[
name|acols
index|]
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|rm
operator|->
name|rm_cols
operator|=
name|acols
expr_stmt|;
name|rm
operator|->
name|rm_bigcols
operator|=
name|bc
expr_stmt|;
name|rm
operator|->
name|rm_asize
operator|=
literal|0
expr_stmt|;
name|rm
operator|->
name|rm_missingdata
operator|=
literal|0
expr_stmt|;
name|rm
operator|->
name|rm_missingparity
operator|=
literal|0
expr_stmt|;
name|rm
operator|->
name|rm_firstdatacol
operator|=
name|nparity
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|acols
condition|;
name|c
operator|++
control|)
block|{
name|col
operator|=
name|f
operator|+
name|c
expr_stmt|;
name|coff
operator|=
name|o
expr_stmt|;
if|if
condition|(
name|col
operator|>=
name|dcols
condition|)
block|{
name|col
operator|-=
name|dcols
expr_stmt|;
name|coff
operator|+=
literal|1ULL
operator|<<
name|unit_shift
expr_stmt|;
block|}
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_devidx
operator|=
name|col
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_offset
operator|=
name|coff
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
operator|=
operator|(
name|q
operator|+
operator|(
name|c
operator|<
name|bc
operator|)
operator|)
operator|<<
name|unit_shift
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_data
operator|=
name|NULL
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_error
operator|=
literal|0
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_tried
operator|=
literal|0
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_skipped
operator|=
literal|0
expr_stmt|;
name|rm
operator|->
name|rm_asize
operator|+=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
expr_stmt|;
block|}
name|rm
operator|->
name|rm_asize
operator|=
name|roundup
argument_list|(
name|rm
operator|->
name|rm_asize
argument_list|,
operator|(
name|nparity
operator|+
literal|1
operator|)
operator|<<
name|unit_shift
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_firstdatacol
condition|;
name|c
operator|++
control|)
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_data
operator|=
name|zio_buf_alloc
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_data
operator|=
name|zio
operator|->
name|io_data
expr_stmt|;
for|for
control|(
name|c
operator|=
name|c
operator|+
literal|1
init|;
name|c
operator|<
name|acols
condition|;
name|c
operator|++
control|)
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_data
operator|=
operator|(
name|char
operator|*
operator|)
name|rm
operator|->
name|rm_col
index|[
name|c
operator|-
literal|1
index|]
operator|.
name|rc_data
operator|+
name|rm
operator|->
name|rm_col
index|[
name|c
operator|-
literal|1
index|]
operator|.
name|rc_size
expr_stmt|;
comment|/* 	 * If all data stored spans all columns, there's a danger that parity 	 * will always be on the same device and, since parity isn't read 	 * during normal operation, that that device's I/O bandwidth won't be 	 * used effectively. We therefore switch the parity every 1MB. 	 * 	 * ... at least that was, ostensibly, the theory. As a practical 	 * matter unless we juggle the parity between all devices evenly, we 	 * won't see any benefit. Further, occasional writes that aren't a 	 * multiple of the LCM of the number of children and the minimum 	 * stripe width are sufficient to avoid pessimal behavior. 	 * Unfortunately, this decision created an implicit on-disk format 	 * requirement that we need to support for all eternity, but only 	 * for single-parity RAID-Z. 	 */
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_cols
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_col
index|[
literal|0
index|]
operator|.
name|rc_size
operator|==
name|rm
operator|->
name|rm_col
index|[
literal|1
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rm
operator|->
name|rm_firstdatacol
operator|==
literal|1
operator|&&
operator|(
name|zio
operator|->
name|io_offset
operator|&
operator|(
literal|1ULL
operator|<<
literal|20
operator|)
operator|)
condition|)
block|{
name|devidx
operator|=
name|rm
operator|->
name|rm_col
index|[
literal|0
index|]
operator|.
name|rc_devidx
expr_stmt|;
name|o
operator|=
name|rm
operator|->
name|rm_col
index|[
literal|0
index|]
operator|.
name|rc_offset
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
literal|0
index|]
operator|.
name|rc_devidx
operator|=
name|rm
operator|->
name|rm_col
index|[
literal|1
index|]
operator|.
name|rc_devidx
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
literal|0
index|]
operator|.
name|rc_offset
operator|=
name|rm
operator|->
name|rm_col
index|[
literal|1
index|]
operator|.
name|rc_offset
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
literal|1
index|]
operator|.
name|rc_devidx
operator|=
name|devidx
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
literal|1
index|]
operator|.
name|rc_offset
operator|=
name|o
expr_stmt|;
block|}
name|zio
operator|->
name|io_vsd
operator|=
name|rm
expr_stmt|;
name|zio
operator|->
name|io_vsd_free
operator|=
name|vdev_raidz_map_free
expr_stmt|;
return|return
operator|(
name|rm
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_generate_parity_p
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|)
block|{
name|uint64_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|src
decl_stmt|,
name|pcount
decl_stmt|,
name|ccount
decl_stmt|,
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
name|pcount
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|src
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_data
expr_stmt|;
name|p
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_data
expr_stmt|;
name|ccount
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
name|ASSERT
argument_list|(
name|ccount
operator|==
name|pcount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ccount
condition|;
name|i
operator|++
operator|,
name|p
operator|++
operator|,
name|src
operator|++
control|)
block|{
operator|*
name|p
operator|=
operator|*
name|src
expr_stmt|;
block|}
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|ccount
operator|<=
name|pcount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ccount
condition|;
name|i
operator|++
operator|,
name|p
operator|++
operator|,
name|src
operator|++
control|)
block|{
operator|*
name|p
operator|^=
operator|*
name|src
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_generate_parity_pq
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|)
block|{
name|uint64_t
modifier|*
name|q
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|src
decl_stmt|,
name|pcount
decl_stmt|,
name|ccount
decl_stmt|,
name|mask
decl_stmt|,
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
name|pcount
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_size
operator|==
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|src
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_data
expr_stmt|;
name|p
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_data
expr_stmt|;
name|q
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_data
expr_stmt|;
name|ccount
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
name|ASSERT
argument_list|(
name|ccount
operator|==
name|pcount
operator|||
name|ccount
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ccount
condition|;
name|i
operator|++
operator|,
name|p
operator|++
operator|,
name|q
operator|++
operator|,
name|src
operator|++
control|)
block|{
operator|*
name|q
operator|=
operator|*
name|src
expr_stmt|;
operator|*
name|p
operator|=
operator|*
name|src
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|pcount
condition|;
name|i
operator|++
operator|,
name|p
operator|++
operator|,
name|q
operator|++
operator|,
name|src
operator|++
control|)
block|{
operator|*
name|q
operator|=
literal|0
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|ccount
operator|<=
name|pcount
argument_list|)
expr_stmt|;
comment|/* 			 * Rather than multiplying each byte individually (as 			 * described above), we are able to handle 8 at once 			 * by generating a mask based on the high bit in each 			 * byte and using that to conditionally XOR in 0x1d. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ccount
condition|;
name|i
operator|++
operator|,
name|p
operator|++
operator|,
name|q
operator|++
operator|,
name|src
operator|++
control|)
block|{
name|mask
operator|=
operator|*
name|q
operator|&
literal|0x8080808080808080ULL
expr_stmt|;
name|mask
operator|=
operator|(
name|mask
operator|<<
literal|1
operator|)
operator|-
operator|(
name|mask
operator|>>
literal|7
operator|)
expr_stmt|;
operator|*
name|q
operator|=
operator|(
operator|(
operator|*
name|q
operator|<<
literal|1
operator|)
operator|&
literal|0xfefefefefefefefeULL
operator|)
operator|^
operator|(
name|mask
operator|&
literal|0x1d1d1d1d1d1d1d1dULL
operator|)
expr_stmt|;
operator|*
name|q
operator|^=
operator|*
name|src
expr_stmt|;
operator|*
name|p
operator|^=
operator|*
name|src
expr_stmt|;
block|}
comment|/* 			 * Treat short columns as though they are full of 0s. 			 */
for|for
control|(
init|;
name|i
operator|<
name|pcount
condition|;
name|i
operator|++
operator|,
name|q
operator|++
control|)
block|{
name|mask
operator|=
operator|*
name|q
operator|&
literal|0x8080808080808080ULL
expr_stmt|;
name|mask
operator|=
operator|(
name|mask
operator|<<
literal|1
operator|)
operator|-
operator|(
name|mask
operator|>>
literal|7
operator|)
expr_stmt|;
operator|*
name|q
operator|=
operator|(
operator|(
operator|*
name|q
operator|<<
literal|1
operator|)
operator|&
literal|0xfefefefefefefefeULL
operator|)
operator|^
operator|(
name|mask
operator|&
literal|0x1d1d1d1d1d1d1d1dULL
operator|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_reconstruct_p
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|,
name|int
name|x
parameter_list|)
block|{
name|uint64_t
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src
decl_stmt|,
name|xcount
decl_stmt|,
name|ccount
decl_stmt|,
name|count
decl_stmt|,
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
name|xcount
operator|=
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|xcount
operator|<=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|xcount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|src
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_data
expr_stmt|;
name|dst
operator|=
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xcount
condition|;
name|i
operator|++
operator|,
name|dst
operator|++
operator|,
name|src
operator|++
control|)
block|{
operator|*
name|dst
operator|=
operator|*
name|src
expr_stmt|;
block|}
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|src
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_data
expr_stmt|;
name|dst
operator|=
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_data
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|x
condition|)
continue|continue;
name|ccount
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|count
operator|=
name|MIN
argument_list|(
name|ccount
argument_list|,
name|xcount
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|dst
operator|++
operator|,
name|src
operator|++
control|)
block|{
operator|*
name|dst
operator|^=
operator|*
name|src
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_reconstruct_q
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|,
name|int
name|x
parameter_list|)
block|{
name|uint64_t
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src
decl_stmt|,
name|xcount
decl_stmt|,
name|ccount
decl_stmt|,
name|count
decl_stmt|,
name|mask
decl_stmt|,
name|i
decl_stmt|;
name|uint8_t
modifier|*
name|b
decl_stmt|;
name|int
name|c
decl_stmt|,
name|j
decl_stmt|,
name|exp
decl_stmt|;
name|xcount
operator|=
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|xcount
operator|<=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|src
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_data
expr_stmt|;
name|dst
operator|=
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_data
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|x
condition|)
name|ccount
operator|=
literal|0
expr_stmt|;
else|else
name|ccount
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|count
operator|=
name|MIN
argument_list|(
name|ccount
argument_list|,
name|xcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|dst
operator|++
operator|,
name|src
operator|++
control|)
block|{
operator|*
name|dst
operator|=
operator|*
name|src
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|xcount
condition|;
name|i
operator|++
operator|,
name|dst
operator|++
control|)
block|{
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * For an explanation of this, see the comment in 			 * vdev_raidz_generate_parity_pq() above. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|dst
operator|++
operator|,
name|src
operator|++
control|)
block|{
name|mask
operator|=
operator|*
name|dst
operator|&
literal|0x8080808080808080ULL
expr_stmt|;
name|mask
operator|=
operator|(
name|mask
operator|<<
literal|1
operator|)
operator|-
operator|(
name|mask
operator|>>
literal|7
operator|)
expr_stmt|;
operator|*
name|dst
operator|=
operator|(
operator|(
operator|*
name|dst
operator|<<
literal|1
operator|)
operator|&
literal|0xfefefefefefefefeULL
operator|)
operator|^
operator|(
name|mask
operator|&
literal|0x1d1d1d1d1d1d1d1dULL
operator|)
expr_stmt|;
operator|*
name|dst
operator|^=
operator|*
name|src
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|xcount
condition|;
name|i
operator|++
operator|,
name|dst
operator|++
control|)
block|{
name|mask
operator|=
operator|*
name|dst
operator|&
literal|0x8080808080808080ULL
expr_stmt|;
name|mask
operator|=
operator|(
name|mask
operator|<<
literal|1
operator|)
operator|-
operator|(
name|mask
operator|>>
literal|7
operator|)
expr_stmt|;
operator|*
name|dst
operator|=
operator|(
operator|(
operator|*
name|dst
operator|<<
literal|1
operator|)
operator|&
literal|0xfefefefefefefefeULL
operator|)
operator|^
operator|(
name|mask
operator|&
literal|0x1d1d1d1d1d1d1d1dULL
operator|)
expr_stmt|;
block|}
block|}
block|}
name|src
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_data
expr_stmt|;
name|dst
operator|=
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_data
expr_stmt|;
name|exp
operator|=
literal|255
operator|-
operator|(
name|rm
operator|->
name|rm_cols
operator|-
literal|1
operator|-
name|x
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xcount
condition|;
name|i
operator|++
operator|,
name|dst
operator|++
operator|,
name|src
operator|++
control|)
block|{
operator|*
name|dst
operator|^=
operator|*
name|src
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|b
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|dst
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
operator|,
name|b
operator|++
control|)
block|{
operator|*
name|b
operator|=
name|vdev_raidz_exp2
argument_list|(
operator|*
name|b
argument_list|,
name|exp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_reconstruct_pq
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|y
parameter_list|)
block|{
name|uint8_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|pxy
decl_stmt|,
modifier|*
name|qxy
decl_stmt|,
modifier|*
name|xd
decl_stmt|,
modifier|*
name|yd
decl_stmt|,
name|tmp
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|,
name|aexp
decl_stmt|,
name|bexp
decl_stmt|;
name|void
modifier|*
name|pdata
decl_stmt|,
modifier|*
name|qdata
decl_stmt|;
name|uint64_t
name|xsize
decl_stmt|,
name|ysize
decl_stmt|,
name|i
decl_stmt|;
name|ASSERT
argument_list|(
name|x
operator|<
name|y
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|x
operator|>=
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|y
operator|<
name|rm
operator|->
name|rm_cols
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
operator|>=
name|rm
operator|->
name|rm_col
index|[
name|y
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
comment|/* 	 * Move the parity data aside -- we're going to compute parity as 	 * though columns x and y were full of zeros -- Pxy and Qxy. We want to 	 * reuse the parity generation mechanism without trashing the actual 	 * parity so we make those columns appear to be full of zeros by 	 * setting their lengths to zero. 	 */
name|pdata
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_data
expr_stmt|;
name|qdata
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_data
expr_stmt|;
name|xsize
operator|=
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
expr_stmt|;
name|ysize
operator|=
name|rm
operator|->
name|rm_col
index|[
name|y
index|]
operator|.
name|rc_size
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_data
operator|=
name|zio_buf_alloc
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_data
operator|=
name|zio_buf_alloc
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
operator|=
literal|0
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|y
index|]
operator|.
name|rc_size
operator|=
literal|0
expr_stmt|;
name|vdev_raidz_generate_parity_pq
argument_list|(
name|rm
argument_list|)
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
operator|=
name|xsize
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|y
index|]
operator|.
name|rc_size
operator|=
name|ysize
expr_stmt|;
name|p
operator|=
name|pdata
expr_stmt|;
name|q
operator|=
name|qdata
expr_stmt|;
name|pxy
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_data
expr_stmt|;
name|qxy
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_data
expr_stmt|;
name|xd
operator|=
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_data
expr_stmt|;
name|yd
operator|=
name|rm
operator|->
name|rm_col
index|[
name|y
index|]
operator|.
name|rc_data
expr_stmt|;
comment|/* 	 * We now have: 	 *	Pxy = P + D_x + D_y 	 *	Qxy = Q + 2^(ndevs - 1 - x) * D_x + 2^(ndevs - 1 - y) * D_y 	 * 	 * We can then solve for D_x: 	 *	D_x = A * (P + Pxy) + B * (Q + Qxy) 	 * where 	 *	A = 2^(x - y) * (2^(x - y) + 1)^-1 	 *	B = 2^(ndevs - 1 - x) * (2^(x - y) + 1)^-1 	 * 	 * With D_x in hand, we can easily solve for D_y: 	 *	D_y = P + Pxy + D_x 	 */
name|a
operator|=
name|vdev_raidz_pow2
index|[
literal|255
operator|+
name|x
operator|-
name|y
index|]
expr_stmt|;
name|b
operator|=
name|vdev_raidz_pow2
index|[
literal|255
operator|-
operator|(
name|rm
operator|->
name|rm_cols
operator|-
literal|1
operator|-
name|x
operator|)
index|]
expr_stmt|;
name|tmp
operator|=
literal|255
operator|-
name|vdev_raidz_log2
index|[
name|a
operator|^
literal|1
index|]
expr_stmt|;
name|aexp
operator|=
name|vdev_raidz_log2
index|[
name|vdev_raidz_exp2
argument_list|(
name|a
argument_list|,
name|tmp
argument_list|)
index|]
expr_stmt|;
name|bexp
operator|=
name|vdev_raidz_log2
index|[
name|vdev_raidz_exp2
argument_list|(
name|b
argument_list|,
name|tmp
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|xsize
condition|;
name|i
operator|++
operator|,
name|p
operator|++
operator|,
name|q
operator|++
operator|,
name|pxy
operator|++
operator|,
name|qxy
operator|++
operator|,
name|xd
operator|++
operator|,
name|yd
operator|++
control|)
block|{
operator|*
name|xd
operator|=
name|vdev_raidz_exp2
argument_list|(
operator|*
name|p
operator|^
operator|*
name|pxy
argument_list|,
name|aexp
argument_list|)
operator|^
name|vdev_raidz_exp2
argument_list|(
operator|*
name|q
operator|^
operator|*
name|qxy
argument_list|,
name|bexp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|ysize
condition|)
operator|*
name|yd
operator|=
operator|*
name|p
operator|^
operator|*
name|pxy
operator|^
operator|*
name|xd
expr_stmt|;
block|}
name|zio_buf_free
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_data
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_data
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
comment|/* 	 * Restore the saved parity data. 	 */
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_data
operator|=
name|pdata
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_data
operator|=
name|qdata
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_raidz_open
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
modifier|*
name|asize
parameter_list|,
name|uint64_t
modifier|*
name|ashift
parameter_list|)
block|{
name|vdev_t
modifier|*
name|cvd
decl_stmt|;
name|uint64_t
name|nparity
init|=
name|vd
operator|->
name|vdev_nparity
decl_stmt|;
name|int
name|c
decl_stmt|,
name|error
decl_stmt|;
name|int
name|lasterror
init|=
literal|0
decl_stmt|;
name|int
name|numerrors
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|nparity
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nparity
operator|>
name|VDEV_RAIDZ_MAXPARITY
operator|||
name|vd
operator|->
name|vdev_children
operator|<
name|nparity
operator|+
literal|1
condition|)
block|{
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|VDEV_AUX_BAD_LABEL
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|cvd
operator|=
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|vdev_open
argument_list|(
name|cvd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|lasterror
operator|=
name|error
expr_stmt|;
name|numerrors
operator|++
expr_stmt|;
continue|continue;
block|}
operator|*
name|asize
operator|=
name|MIN
argument_list|(
operator|*
name|asize
operator|-
literal|1
argument_list|,
name|cvd
operator|->
name|vdev_asize
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|ashift
operator|=
name|MAX
argument_list|(
operator|*
name|ashift
argument_list|,
name|cvd
operator|->
name|vdev_ashift
argument_list|)
expr_stmt|;
block|}
operator|*
name|asize
operator|*=
name|vd
operator|->
name|vdev_children
expr_stmt|;
if|if
condition|(
name|numerrors
operator|>
name|nparity
condition|)
block|{
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|VDEV_AUX_NO_REPLICAS
expr_stmt|;
return|return
operator|(
name|lasterror
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_close
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_close
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|vdev_raidz_asize
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|psize
parameter_list|)
block|{
name|uint64_t
name|asize
decl_stmt|;
name|uint64_t
name|ashift
init|=
name|vd
operator|->
name|vdev_top
operator|->
name|vdev_ashift
decl_stmt|;
name|uint64_t
name|cols
init|=
name|vd
operator|->
name|vdev_children
decl_stmt|;
name|uint64_t
name|nparity
init|=
name|vd
operator|->
name|vdev_nparity
decl_stmt|;
name|asize
operator|=
operator|(
operator|(
name|psize
operator|-
literal|1
operator|)
operator|>>
name|ashift
operator|)
operator|+
literal|1
expr_stmt|;
name|asize
operator|+=
name|nparity
operator|*
operator|(
operator|(
name|asize
operator|+
name|cols
operator|-
name|nparity
operator|-
literal|1
operator|)
operator|/
operator|(
name|cols
operator|-
name|nparity
operator|)
operator|)
expr_stmt|;
name|asize
operator|=
name|roundup
argument_list|(
name|asize
argument_list|,
name|nparity
operator|+
literal|1
argument_list|)
operator|<<
name|ashift
expr_stmt|;
return|return
operator|(
name|asize
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_child_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|raidz_col_t
modifier|*
name|rc
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|rc
operator|->
name|rc_error
operator|=
name|zio
operator|->
name|io_error
expr_stmt|;
name|rc
operator|->
name|rc_tried
operator|=
literal|1
expr_stmt|;
name|rc
operator|->
name|rc_skipped
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_raidz_io_start
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
decl_stmt|;
name|vdev_t
modifier|*
name|tvd
init|=
name|vd
operator|->
name|vdev_top
decl_stmt|;
name|vdev_t
modifier|*
name|cvd
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|raidz_map_t
modifier|*
name|rm
decl_stmt|;
name|raidz_col_t
modifier|*
name|rc
decl_stmt|;
name|int
name|c
decl_stmt|;
name|rm
operator|=
name|vdev_raidz_map_alloc
argument_list|(
name|zio
argument_list|,
name|tvd
operator|->
name|vdev_ashift
argument_list|,
name|vd
operator|->
name|vdev_children
argument_list|,
name|vd
operator|->
name|vdev_nparity
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|rm
operator|->
name|rm_asize
argument_list|,
operator|==
argument_list|,
name|vdev_psize_to_asize
argument_list|(
name|vd
argument_list|,
name|zio
operator|->
name|io_size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
condition|)
block|{
comment|/* 		 * Generate RAID parity in the first virtual columns. 		 */
if|if
condition|(
name|rm
operator|->
name|rm_firstdatacol
operator|==
literal|1
condition|)
name|vdev_raidz_generate_parity_p
argument_list|(
name|rm
argument_list|)
expr_stmt|;
else|else
name|vdev_raidz_generate_parity_pq
argument_list|(
name|rm
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
name|cvd
operator|=
name|vd
operator|->
name|vdev_child
index|[
name|rc
operator|->
name|rc_devidx
index|]
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_vdev_child_io
argument_list|(
name|zio
argument_list|,
name|NULL
argument_list|,
name|cvd
argument_list|,
name|rc
operator|->
name|rc_offset
argument_list|,
name|rc
operator|->
name|rc_data
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|,
name|zio
operator|->
name|io_type
argument_list|,
name|zio
operator|->
name|io_priority
argument_list|,
literal|0
argument_list|,
name|vdev_raidz_child_done
argument_list|,
name|rc
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
argument_list|)
expr_stmt|;
comment|/* 	 * Iterate over the columns in reverse order so that we hit the parity 	 * last -- any errors along the way will force us to read the parity 	 * data. 	 */
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_cols
operator|-
literal|1
init|;
name|c
operator|>=
literal|0
condition|;
name|c
operator|--
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
name|cvd
operator|=
name|vd
operator|->
name|vdev_child
index|[
name|rc
operator|->
name|rc_devidx
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|vdev_readable
argument_list|(
name|cvd
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|>=
name|rm
operator|->
name|rm_firstdatacol
condition|)
name|rm
operator|->
name|rm_missingdata
operator|++
expr_stmt|;
else|else
name|rm
operator|->
name|rm_missingparity
operator|++
expr_stmt|;
name|rc
operator|->
name|rc_error
operator|=
name|ENXIO
expr_stmt|;
name|rc
operator|->
name|rc_tried
operator|=
literal|1
expr_stmt|;
comment|/* don't even try */
name|rc
operator|->
name|rc_skipped
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|vdev_dtl_contains
argument_list|(
operator|&
name|cvd
operator|->
name|vdev_dtl_map
argument_list|,
name|bp
operator|->
name|blk_birth
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|>=
name|rm
operator|->
name|rm_firstdatacol
condition|)
name|rm
operator|->
name|rm_missingdata
operator|++
expr_stmt|;
else|else
name|rm
operator|->
name|rm_missingparity
operator|++
expr_stmt|;
name|rc
operator|->
name|rc_error
operator|=
name|ESTALE
expr_stmt|;
name|rc
operator|->
name|rc_skipped
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|>=
name|rm
operator|->
name|rm_firstdatacol
operator|||
name|rm
operator|->
name|rm_missingdata
operator|>
literal|0
operator|||
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_SCRUB
operator|)
condition|)
block|{
name|zio_nowait
argument_list|(
name|zio_vdev_child_io
argument_list|(
name|zio
argument_list|,
name|NULL
argument_list|,
name|cvd
argument_list|,
name|rc
operator|->
name|rc_offset
argument_list|,
name|rc
operator|->
name|rc_data
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|,
name|zio
operator|->
name|io_type
argument_list|,
name|zio
operator|->
name|io_priority
argument_list|,
literal|0
argument_list|,
name|vdev_raidz_child_done
argument_list|,
name|rc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Report a checksum error for a child of a RAID-Z device.  */
end_comment

begin_function
specifier|static
name|void
name|raidz_checksum_error
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|raidz_col_t
modifier|*
name|rc
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
operator|->
name|vdev_child
index|[
name|rc
operator|->
name|rc_devidx
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_SPECULATIVE
operator|)
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_checksum_errors
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_SPECULATIVE
operator|)
condition|)
name|zfs_ereport_post
argument_list|(
name|FM_EREPORT_ZFS_CHECKSUM
argument_list|,
name|zio
operator|->
name|io_spa
argument_list|,
name|vd
argument_list|,
name|zio
argument_list|,
name|rc
operator|->
name|rc_offset
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate the parity from the data columns. If we tried and were able to  * read the parity without error, verify that the generated parity matches the  * data we read. If it doesn't, we fire off a checksum error. Return the  * number such failures.  */
end_comment

begin_function
specifier|static
name|int
name|raidz_parity_verify
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|raidz_map_t
modifier|*
name|rm
parameter_list|)
block|{
name|void
modifier|*
name|orig
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
name|int
name|c
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|raidz_col_t
modifier|*
name|rc
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_firstdatacol
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|rc
operator|->
name|rc_tried
operator|||
name|rc
operator|->
name|rc_error
operator|!=
literal|0
condition|)
continue|continue;
name|orig
index|[
name|c
index|]
operator|=
name|zio_buf_alloc
argument_list|(
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|rc
operator|->
name|rc_data
argument_list|,
name|orig
index|[
name|c
index|]
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rm
operator|->
name|rm_firstdatacol
operator|==
literal|1
condition|)
name|vdev_raidz_generate_parity_p
argument_list|(
name|rm
argument_list|)
expr_stmt|;
else|else
name|vdev_raidz_generate_parity_pq
argument_list|(
name|rm
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_firstdatacol
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|rc
operator|->
name|rc_tried
operator|||
name|rc
operator|->
name|rc_error
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|bcmp
argument_list|(
name|orig
index|[
name|c
index|]
argument_list|,
name|rc
operator|->
name|rc_data
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|raidz_checksum_error
argument_list|(
name|zio
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc
operator|->
name|rc_error
operator|=
name|ECKSUM
expr_stmt|;
name|ret
operator|++
expr_stmt|;
block|}
name|zio_buf_free
argument_list|(
name|orig
index|[
name|c
index|]
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|uint64_t
name|raidz_corrected_p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|raidz_corrected_q
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|raidz_corrected_pq
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|vdev_raidz_worst_error
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
name|error
operator|=
name|zio_worst_error
argument_list|(
name|error
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_io_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
decl_stmt|;
name|vdev_t
modifier|*
name|cvd
decl_stmt|;
name|raidz_map_t
modifier|*
name|rm
init|=
name|zio
operator|->
name|io_vsd
decl_stmt|;
name|raidz_col_t
modifier|*
name|rc
decl_stmt|,
modifier|*
name|rc1
decl_stmt|;
name|int
name|unexpected_errors
init|=
literal|0
decl_stmt|;
name|int
name|parity_errors
init|=
literal|0
decl_stmt|;
name|int
name|parity_untried
init|=
literal|0
decl_stmt|;
name|int
name|data_errors
init|=
literal|0
decl_stmt|;
name|int
name|total_errors
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|,
name|c
decl_stmt|,
name|c1
decl_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXX need to add code to enforce this */
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_missingparity
operator|<=
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_missingdata
operator|<=
name|rm
operator|->
name|rm_cols
operator|-
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_error
condition|)
block|{
name|ASSERT
argument_list|(
name|rc
operator|->
name|rc_error
operator|!=
name|ECKSUM
argument_list|)
expr_stmt|;
comment|/* child has no bp */
if|if
condition|(
name|c
operator|<
name|rm
operator|->
name|rm_firstdatacol
condition|)
name|parity_errors
operator|++
expr_stmt|;
else|else
name|data_errors
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|rc
operator|->
name|rc_skipped
condition|)
name|unexpected_errors
operator|++
expr_stmt|;
name|total_errors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
name|rm
operator|->
name|rm_firstdatacol
operator|&&
operator|!
name|rc
operator|->
name|rc_tried
condition|)
block|{
name|parity_untried
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
condition|)
block|{
comment|/* 		 * XXX -- for now, treat partial writes as a success. 		 * (If we couldn't write enough columns to reconstruct 		 * the data, the I/O failed.  Otherwise, good enough.) 		 * 		 * Now that we support write reallocation, it would be better 		 * to treat partial failure as real failure unless there are 		 * no non-degraded top-level vdevs left, and not update DTLs 		 * if we intend to reallocate. 		 */
comment|/* XXPOLICY */
if|if
condition|(
name|total_errors
operator|>
name|rm
operator|->
name|rm_firstdatacol
condition|)
name|zio
operator|->
name|io_error
operator|=
name|vdev_raidz_worst_error
argument_list|(
name|rm
argument_list|)
expr_stmt|;
return|return;
block|}
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
argument_list|)
expr_stmt|;
comment|/* 	 * There are three potential phases for a read: 	 *	1. produce valid data from the columns read 	 *	2. read all disks and try again 	 *	3. perform combinatorial reconstruction 	 * 	 * Each phase is progressively both more expensive and less likely to 	 * occur. If we encounter more errors than we can repair or all phases 	 * fail, we have no choice but to return an error. 	 */
comment|/* 	 * If the number of errors we saw was correctable -- less than or equal 	 * to the number of parity disks read -- attempt to produce data that 	 * has a valid checksum. Naturally, this case applies in the absence of 	 * any errors. 	 */
if|if
condition|(
name|total_errors
operator|<=
name|rm
operator|->
name|rm_firstdatacol
operator|-
name|parity_untried
condition|)
block|{
switch|switch
condition|(
name|data_errors
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|zio_checksum_error
argument_list|(
name|zio
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * If we read parity information (unnecessarily 				 * as it happens since no reconstruction was 				 * needed) regenerate and verify the parity. 				 * We also regenerate parity when resilvering 				 * so we can write it out to the failed device 				 * later. 				 */
if|if
condition|(
name|parity_errors
operator|+
name|parity_untried
operator|<
name|rm
operator|->
name|rm_firstdatacol
operator|||
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_RESILVER
operator|)
condition|)
block|{
name|n
operator|=
name|raidz_parity_verify
argument_list|(
name|zio
argument_list|,
name|rm
argument_list|)
expr_stmt|;
name|unexpected_errors
operator|+=
name|n
expr_stmt|;
name|ASSERT
argument_list|(
name|parity_errors
operator|+
name|n
operator|<=
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
break|break;
case|case
literal|1
case|:
comment|/* 			 * We either attempt to read all the parity columns or 			 * none of them. If we didn't try to read parity, we 			 * wouldn't be here in the correctable case. There must 			 * also have been fewer parity errors than parity 			 * columns or, again, we wouldn't be in this code path. 			 */
name|ASSERT
argument_list|(
name|parity_untried
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|parity_errors
operator|<
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
comment|/* 			 * Find the column that reported the error. 			 */
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_error
operator|!=
literal|0
condition|)
break|break;
block|}
name|ASSERT
argument_list|(
name|c
operator|!=
name|rm
operator|->
name|rm_cols
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|rc
operator|->
name|rc_skipped
operator|||
name|rc
operator|->
name|rc_error
operator|==
name|ENXIO
operator|||
name|rc
operator|->
name|rc_error
operator|==
name|ESTALE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_error
operator|==
literal|0
condition|)
block|{
name|vdev_raidz_reconstruct_p
argument_list|(
name|rm
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_firstdatacol
operator|>
literal|1
argument_list|)
expr_stmt|;
name|vdev_raidz_reconstruct_q
argument_list|(
name|rm
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zio_checksum_error
argument_list|(
name|zio
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_error
operator|==
literal|0
condition|)
name|atomic_inc_64
argument_list|(
operator|&
name|raidz_corrected_p
argument_list|)
expr_stmt|;
else|else
name|atomic_inc_64
argument_list|(
operator|&
name|raidz_corrected_q
argument_list|)
expr_stmt|;
comment|/* 				 * If there's more than one parity disk that 				 * was successfully read, confirm that the 				 * other parity disk produced the correct data. 				 * This routine is suboptimal in that it 				 * regenerates both the parity we wish to test 				 * as well as the parity we just used to 				 * perform the reconstruction, but this should 				 * be a relatively uncommon case, and can be 				 * optimized if it becomes a problem. 				 * We also regenerate parity when resilvering 				 * so we can write it out to the failed device 				 * later. 				 */
if|if
condition|(
name|parity_errors
operator|<
name|rm
operator|->
name|rm_firstdatacol
operator|-
literal|1
operator|||
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_RESILVER
operator|)
condition|)
block|{
name|n
operator|=
name|raidz_parity_verify
argument_list|(
name|zio
argument_list|,
name|rm
argument_list|)
expr_stmt|;
name|unexpected_errors
operator|+=
name|n
expr_stmt|;
name|ASSERT
argument_list|(
name|parity_errors
operator|+
name|n
operator|<=
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
break|break;
case|case
literal|2
case|:
comment|/* 			 * Two data column errors require double parity. 			 */
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_firstdatacol
operator|==
literal|2
argument_list|)
expr_stmt|;
comment|/* 			 * Find the two columns that reported errors. 			 */
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_error
operator|!=
literal|0
condition|)
break|break;
block|}
name|ASSERT
argument_list|(
name|c
operator|!=
name|rm
operator|->
name|rm_cols
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|rc
operator|->
name|rc_skipped
operator|||
name|rc
operator|->
name|rc_error
operator|==
name|ENXIO
operator|||
name|rc
operator|->
name|rc_error
operator|==
name|ESTALE
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|c
operator|++
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_error
operator|!=
literal|0
condition|)
break|break;
block|}
name|ASSERT
argument_list|(
name|c
operator|!=
name|rm
operator|->
name|rm_cols
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|rc
operator|->
name|rc_skipped
operator|||
name|rc
operator|->
name|rc_error
operator|==
name|ENXIO
operator|||
name|rc
operator|->
name|rc_error
operator|==
name|ESTALE
argument_list|)
expr_stmt|;
name|vdev_raidz_reconstruct_pq
argument_list|(
name|rm
argument_list|,
name|c1
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_checksum_error
argument_list|(
name|zio
argument_list|)
operator|==
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|raidz_corrected_pq
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
break|break;
default|default:
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_firstdatacol
operator|<=
literal|2
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * This isn't a typical situation -- either we got a read error or 	 * a child silently returned bad data. Read every block so we can 	 * try again with as much data and parity as we can track down. If 	 * we've already been through once before, all children will be marked 	 * as tried so we'll proceed to combinatorial reconstruction. 	 */
name|unexpected_errors
operator|=
literal|1
expr_stmt|;
name|rm
operator|->
name|rm_missingdata
operator|=
literal|0
expr_stmt|;
name|rm
operator|->
name|rm_missingparity
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_tried
condition|)
continue|continue;
name|zio_vdev_io_redone
argument_list|(
name|zio
argument_list|)
expr_stmt|;
do|do
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_tried
condition|)
continue|continue;
name|zio_nowait
argument_list|(
name|zio_vdev_child_io
argument_list|(
name|zio
argument_list|,
name|NULL
argument_list|,
name|vd
operator|->
name|vdev_child
index|[
name|rc
operator|->
name|rc_devidx
index|]
argument_list|,
name|rc
operator|->
name|rc_offset
argument_list|,
name|rc
operator|->
name|rc_data
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|,
name|zio
operator|->
name|io_type
argument_list|,
name|zio
operator|->
name|io_priority
argument_list|,
literal|0
argument_list|,
name|vdev_raidz_child_done
argument_list|,
name|rc
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|)
do|;
return|return;
block|}
comment|/* 	 * At this point we've attempted to reconstruct the data given the 	 * errors we detected, and we've attempted to read all columns. There 	 * must, therefore, be one or more additional problems -- silent errors 	 * resulting in invalid data rather than explicit I/O errors resulting 	 * in absent data. Before we attempt combinatorial reconstruction make 	 * sure we have a chance of coming up with the right answer. 	 */
if|if
condition|(
name|total_errors
operator|>=
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
name|zio
operator|->
name|io_error
operator|=
name|vdev_raidz_worst_error
argument_list|(
name|rm
argument_list|)
expr_stmt|;
comment|/* 		 * If there were exactly as many device errors as parity 		 * columns, yet we couldn't reconstruct the data, then at 		 * least one device must have returned bad data silently. 		 */
if|if
condition|(
name|total_errors
operator|==
name|rm
operator|->
name|rm_firstdatacol
condition|)
name|zio
operator|->
name|io_error
operator|=
name|zio_worst_error
argument_list|(
name|zio
operator|->
name|io_error
argument_list|,
name|ECKSUM
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_error
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Attempt to reconstruct the data from parity P. 		 */
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|void
modifier|*
name|orig
decl_stmt|;
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
name|orig
operator|=
name|zio_buf_alloc
argument_list|(
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|rc
operator|->
name|rc_data
argument_list|,
name|orig
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|vdev_raidz_reconstruct_p
argument_list|(
name|rm
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_checksum_error
argument_list|(
name|zio
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zio_buf_free
argument_list|(
name|orig
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|atomic_inc_64
argument_list|(
operator|&
name|raidz_corrected_p
argument_list|)
expr_stmt|;
comment|/* 				 * If this child didn't know that it returned 				 * bad data, inform it. 				 */
if|if
condition|(
name|rc
operator|->
name|rc_tried
operator|&&
name|rc
operator|->
name|rc_error
operator|==
literal|0
condition|)
name|raidz_checksum_error
argument_list|(
name|zio
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc
operator|->
name|rc_error
operator|=
name|ECKSUM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|bcopy
argument_list|(
name|orig
argument_list|,
name|rc
operator|->
name|rc_data
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|orig
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rm
operator|->
name|rm_firstdatacol
operator|>
literal|1
operator|&&
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_error
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Attempt to reconstruct the data from parity Q. 		 */
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|void
modifier|*
name|orig
decl_stmt|;
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
name|orig
operator|=
name|zio_buf_alloc
argument_list|(
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|rc
operator|->
name|rc_data
argument_list|,
name|orig
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|vdev_raidz_reconstruct_q
argument_list|(
name|rm
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_checksum_error
argument_list|(
name|zio
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zio_buf_free
argument_list|(
name|orig
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|atomic_inc_64
argument_list|(
operator|&
name|raidz_corrected_q
argument_list|)
expr_stmt|;
comment|/* 				 * If this child didn't know that it returned 				 * bad data, inform it. 				 */
if|if
condition|(
name|rc
operator|->
name|rc_tried
operator|&&
name|rc
operator|->
name|rc_error
operator|==
literal|0
condition|)
name|raidz_checksum_error
argument_list|(
name|zio
argument_list|,
name|rc
argument_list|)
expr_stmt|;
name|rc
operator|->
name|rc_error
operator|=
name|ECKSUM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|bcopy
argument_list|(
name|orig
argument_list|,
name|rc
operator|->
name|rc_data
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|orig
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rm
operator|->
name|rm_firstdatacol
operator|>
literal|1
operator|&&
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_error
operator|==
literal|0
operator|&&
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_error
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Attempt to reconstruct the data from both P and Q. 		 */
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
operator|-
literal|1
condition|;
name|c
operator|++
control|)
block|{
name|void
modifier|*
name|orig
decl_stmt|,
modifier|*
name|orig1
decl_stmt|;
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
name|orig
operator|=
name|zio_buf_alloc
argument_list|(
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|rc
operator|->
name|rc_data
argument_list|,
name|orig
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
for|for
control|(
name|c1
operator|=
name|c
operator|+
literal|1
init|;
name|c1
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c1
operator|++
control|)
block|{
name|rc1
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c1
index|]
expr_stmt|;
name|orig1
operator|=
name|zio_buf_alloc
argument_list|(
name|rc1
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|rc1
operator|->
name|rc_data
argument_list|,
name|orig1
argument_list|,
name|rc1
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|vdev_raidz_reconstruct_pq
argument_list|(
name|rm
argument_list|,
name|c
argument_list|,
name|c1
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_checksum_error
argument_list|(
name|zio
argument_list|)
operator|==
literal|0
condition|)
block|{
name|zio_buf_free
argument_list|(
name|orig
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|orig1
argument_list|,
name|rc1
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|atomic_inc_64
argument_list|(
operator|&
name|raidz_corrected_pq
argument_list|)
expr_stmt|;
comment|/* 					 * If these children didn't know they 					 * returned bad data, inform them. 					 */
if|if
condition|(
name|rc
operator|->
name|rc_tried
operator|&&
name|rc
operator|->
name|rc_error
operator|==
literal|0
condition|)
name|raidz_checksum_error
argument_list|(
name|zio
argument_list|,
name|rc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc1
operator|->
name|rc_tried
operator|&&
name|rc1
operator|->
name|rc_error
operator|==
literal|0
condition|)
name|raidz_checksum_error
argument_list|(
name|zio
argument_list|,
name|rc1
argument_list|)
expr_stmt|;
name|rc
operator|->
name|rc_error
operator|=
name|ECKSUM
expr_stmt|;
name|rc1
operator|->
name|rc_error
operator|=
name|ECKSUM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|bcopy
argument_list|(
name|orig1
argument_list|,
name|rc1
operator|->
name|rc_data
argument_list|,
name|rc1
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|orig1
argument_list|,
name|rc1
operator|->
name|rc_size
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|orig
argument_list|,
name|rc
operator|->
name|rc_data
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|orig
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * All combinations failed to checksum. Generate checksum ereports for 	 * all children. 	 */
name|zio
operator|->
name|io_error
operator|=
name|ECKSUM
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_SPECULATIVE
operator|)
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
name|zfs_ereport_post
argument_list|(
name|FM_EREPORT_ZFS_CHECKSUM
argument_list|,
name|zio
operator|->
name|io_spa
argument_list|,
name|vd
operator|->
name|vdev_child
index|[
name|rc
operator|->
name|rc_devidx
index|]
argument_list|,
name|zio
argument_list|,
name|rc
operator|->
name|rc_offset
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
block|}
block|}
name|done
label|:
name|zio_checksum_verified
argument_list|(
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
operator|&&
operator|(
name|spa_mode
operator|&
name|FWRITE
operator|)
operator|&&
operator|(
name|unexpected_errors
operator|||
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_RESILVER
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Use the good data we have in hand to repair damaged children. 		 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
name|cvd
operator|=
name|vd
operator|->
name|vdev_child
index|[
name|rc
operator|->
name|rc_devidx
index|]
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_error
operator|==
literal|0
condition|)
continue|continue;
name|zio_nowait
argument_list|(
name|zio_vdev_child_io
argument_list|(
name|zio
argument_list|,
name|NULL
argument_list|,
name|cvd
argument_list|,
name|rc
operator|->
name|rc_offset
argument_list|,
name|rc
operator|->
name|rc_data
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|,
name|ZIO_TYPE_WRITE
argument_list|,
name|zio
operator|->
name|io_priority
argument_list|,
name|ZIO_FLAG_IO_REPAIR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_state_change
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|int
name|faulted
parameter_list|,
name|int
name|degraded
parameter_list|)
block|{
if|if
condition|(
name|faulted
operator|>
name|vd
operator|->
name|vdev_nparity
condition|)
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_NO_REPLICAS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|degraded
operator|+
name|faulted
operator|!=
literal|0
condition|)
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_DEGRADED
argument_list|,
name|VDEV_AUX_NONE
argument_list|)
expr_stmt|;
else|else
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_HEALTHY
argument_list|,
name|VDEV_AUX_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|vdev_ops_t
name|vdev_raidz_ops
init|=
block|{
name|vdev_raidz_open
block|,
name|vdev_raidz_close
block|,
name|vdev_raidz_asize
block|,
name|vdev_raidz_io_start
block|,
name|vdev_raidz_io_done
block|,
name|vdev_raidz_state_change
block|,
name|VDEV_TYPE_RAIDZ
block|,
comment|/* name of this vdev type */
name|B_FALSE
comment|/* not a leaf vdev */
block|}
decl_stmt|;
end_decl_stmt

end_unit

