begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2010, Oracle and/or its affiliates. All rights reserved.  * Portions Copyright 2011 iXsystems, Inc  * Copyright (c) 2013, 2016 by Delphix. All rights reserved.  * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/sa.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/sa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_comment
comment|/*  * ZFS System attributes:  *  * A generic mechanism to allow for arbitrary attributes  * to be stored in a dnode.  The data will be stored in the bonus buffer of  * the dnode and if necessary a special "spill" block will be used to handle  * overflow situations.  The spill block will be sized to fit the data  * from 512 - 128K.  When a spill block is used the BP (blkptr_t) for the  * spill block is stored at the end of the current bonus buffer.  Any  * attributes that would be in the way of the blkptr_t will be relocated  * into the spill block.  *  * Attribute registration:  *  * Stored persistently on a per dataset basis  * a mapping between attribute "string" names and their actual attribute  * numeric values, length, and byteswap function.  The names are only used  * during registration.  All  attributes are known by their unique attribute  * id value.  If an attribute can have a variable size then the value  * 0 will be used to indicate this.  *  * Attribute Layout:  *  * Attribute layouts are a way to compactly store multiple attributes, but  * without taking the overhead associated with managing each attribute  * individually.  Since you will typically have the same set of attributes  * stored in the same order a single table will be used to represent that  * layout.  The ZPL for example will usually have only about 10 different  * layouts (regular files, device files, symlinks,  * regular files + scanstamp, files/dir with extended attributes, and then  * you have the possibility of all of those minus ACL, because it would  * be kicked out into the spill block)  *  * Layouts are simply an array of the attributes and their  * ordering i.e. [0, 1, 4, 5, 2]  *  * Each distinct layout is given a unique layout number and that is whats  * stored in the header at the beginning of the SA data buffer.  *  * A layout only covers a single dbuf (bonus or spill).  If a set of  * attributes is split up between the bonus buffer and a spill buffer then  * two different layouts will be used.  This allows us to byteswap the  * spill without looking at the bonus buffer and keeps the on disk format of  * the bonus and spill buffer the same.  *  * Adding a single attribute will cause the entire set of attributes to  * be rewritten and could result in a new layout number being constructed  * as part of the rewrite if no such layout exists for the new set of  * attribues.  The new attribute will be appended to the end of the already  * existing attributes.  *  * Both the attribute registration and attribute layout information are  * stored in normal ZAP attributes.  Their should be a small number of  * known layouts and the set of attributes is assumed to typically be quite  * small.  *  * The registered attributes and layout "table" information is maintained  * in core and a special "sa_os_t" is attached to the objset_t.  *  * A special interface is provided to allow for quickly applying  * a large set of attributes at once.  sa_replace_all_by_template() is  * used to set an array of attributes.  This is used by the ZPL when  * creating a brand new file.  The template that is passed into the function  * specifies the attribute, size for variable length attributes, location of  * data and special "data locator" function if the data isn't in a contiguous  * location.  *  * Byteswap implications:  *  * Since the SA attributes are not entirely self describing we can't do  * the normal byteswap processing.  The special ZAP layout attribute and  * attribute registration attributes define the byteswap function and the  * size of the attributes, unless it is variable sized.  * The normal ZFS byteswapping infrastructure assumes you don't need  * to read any objects in order to do the necessary byteswapping.  Whereas  * SA attributes can only be properly byteswapped if the dataset is opened  * and the layout/attribute ZAP attributes are available.  Because of this  * the SA attributes will be byteswapped when they are first accessed by  * the SA code that will read the SA data.  */
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
name|sa_iterfunc_t
function_decl|)
parameter_list|(
name|void
modifier|*
name|hdr
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|sa_attr_type_t
parameter_list|,
name|uint16_t
name|length
parameter_list|,
name|int
name|length_idx
parameter_list|,
name|boolean_t
parameter_list|,
name|void
modifier|*
name|userp
parameter_list|)
function_decl|;
end_typedef

begin_function_decl
specifier|static
name|int
name|sa_build_index
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|sa_buf_type_t
name|buftype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sa_idx_tab_hold
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|sa_idx_tab_t
modifier|*
name|idx_tab
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|sa_find_idx_tab
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|dmu_object_type_t
name|bonustype
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sa_idx_tab_rele
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sa_copy_data
parameter_list|(
name|sa_data_locator_t
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|start
parameter_list|,
name|void
modifier|*
name|target
parameter_list|,
name|int
name|buflen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sa_modify_attrs
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|sa_attr_type_t
name|newattr
parameter_list|,
name|sa_data_op_t
name|action
parameter_list|,
name|sa_data_locator_t
modifier|*
name|locator
parameter_list|,
name|void
modifier|*
name|datastart
parameter_list|,
name|uint16_t
name|buflen
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|arc_byteswap_func_t
modifier|*
name|sa_bswap_table
index|[]
init|=
block|{
name|byteswap_uint64_array
block|,
name|byteswap_uint32_array
block|,
name|byteswap_uint16_array
block|,
name|byteswap_uint8_array
block|,
name|zfs_acl_byteswap
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SA_COPY_DATA
parameter_list|(
name|f
parameter_list|,
name|s
parameter_list|,
name|t
parameter_list|,
name|l
parameter_list|)
define|\
value|{ \ 		if (f == NULL) { \ 			if (l == 8) { \ 				*(uint64_t *)t = *(uint64_t *)s; \ 			} else if (l == 16) { \ 				*(uint64_t *)t = *(uint64_t *)s; \ 				*(uint64_t *)((uintptr_t)t + 8) = \ 				    *(uint64_t *)((uintptr_t)s + 8); \ 			} else { \ 				bcopy(s, t, l); \ 			} \ 		} else \ 			sa_copy_data(f, s, t, l); \ 	}
end_define

begin_comment
comment|/*  * This table is fixed and cannot be changed.  Its purpose is to  * allow the SA code to work with both old/new ZPL file systems.  * It contains the list of legacy attributes.  These attributes aren't  * stored in the "attribute" registry zap objects, since older ZPL file systems  * won't have the registry.  Only objsets of type ZFS_TYPE_FILESYSTEM will  * use this static table.  */
end_comment

begin_decl_stmt
name|sa_attr_reg_t
name|sa_legacy_attrs
index|[]
init|=
block|{
block|{
literal|"ZPL_ATIME"
block|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
literal|2
block|,
name|SA_UINT64_ARRAY
block|,
literal|0
block|}
block|,
block|{
literal|"ZPL_MTIME"
block|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
literal|2
block|,
name|SA_UINT64_ARRAY
block|,
literal|1
block|}
block|,
block|{
literal|"ZPL_CTIME"
block|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
literal|2
block|,
name|SA_UINT64_ARRAY
block|,
literal|2
block|}
block|,
block|{
literal|"ZPL_CRTIME"
block|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
literal|2
block|,
name|SA_UINT64_ARRAY
block|,
literal|3
block|}
block|,
block|{
literal|"ZPL_GEN"
block|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
block|,
name|SA_UINT64_ARRAY
block|,
literal|4
block|}
block|,
block|{
literal|"ZPL_MODE"
block|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
block|,
name|SA_UINT64_ARRAY
block|,
literal|5
block|}
block|,
block|{
literal|"ZPL_SIZE"
block|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
block|,
name|SA_UINT64_ARRAY
block|,
literal|6
block|}
block|,
block|{
literal|"ZPL_PARENT"
block|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
block|,
name|SA_UINT64_ARRAY
block|,
literal|7
block|}
block|,
block|{
literal|"ZPL_LINKS"
block|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
block|,
name|SA_UINT64_ARRAY
block|,
literal|8
block|}
block|,
block|{
literal|"ZPL_XATTR"
block|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
block|,
name|SA_UINT64_ARRAY
block|,
literal|9
block|}
block|,
block|{
literal|"ZPL_RDEV"
block|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
block|,
name|SA_UINT64_ARRAY
block|,
literal|10
block|}
block|,
block|{
literal|"ZPL_FLAGS"
block|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
block|,
name|SA_UINT64_ARRAY
block|,
literal|11
block|}
block|,
block|{
literal|"ZPL_UID"
block|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
block|,
name|SA_UINT64_ARRAY
block|,
literal|12
block|}
block|,
block|{
literal|"ZPL_GID"
block|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
block|,
name|SA_UINT64_ARRAY
block|,
literal|13
block|}
block|,
block|{
literal|"ZPL_PAD"
block|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
literal|4
block|,
name|SA_UINT64_ARRAY
block|,
literal|14
block|}
block|,
block|{
literal|"ZPL_ZNODE_ACL"
block|,
literal|88
block|,
name|SA_UINT8_ARRAY
block|,
literal|15
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is only used for objects of type DMU_OT_ZNODE  */
end_comment

begin_decl_stmt
name|sa_attr_type_t
name|sa_legacy_zpl_layout
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Special dummy layout used for buffers with no attributes.  */
end_comment

begin_decl_stmt
name|sa_attr_type_t
name|sa_dummy_zpl_layout
index|[]
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sa_legacy_attr_count
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kmem_cache_t
modifier|*
name|sa_cache
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|sa_cache_constructor
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|,
name|int
name|kmflag
parameter_list|)
block|{
name|sa_handle_t
modifier|*
name|hdl
init|=
name|buf
decl_stmt|;
name|mutex_init
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|sa_cache_destructor
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|sa_handle_t
modifier|*
name|hdl
init|=
name|buf
decl_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sa_cache_init
parameter_list|(
name|void
parameter_list|)
block|{
name|sa_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"sa_cache"
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_handle_t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|sa_cache_constructor
argument_list|,
name|sa_cache_destructor
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sa_cache_fini
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|sa_cache
condition|)
name|kmem_cache_destroy
argument_list|(
name|sa_cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|layout_num_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
specifier|const
name|sa_lot_t
modifier|*
name|node1
init|=
name|arg1
decl_stmt|;
specifier|const
name|sa_lot_t
modifier|*
name|node2
init|=
name|arg2
decl_stmt|;
if|if
condition|(
name|node1
operator|->
name|lot_num
operator|>
name|node2
operator|->
name|lot_num
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|node1
operator|->
name|lot_num
operator|<
name|node2
operator|->
name|lot_num
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|layout_hash_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
specifier|const
name|sa_lot_t
modifier|*
name|node1
init|=
name|arg1
decl_stmt|;
specifier|const
name|sa_lot_t
modifier|*
name|node2
init|=
name|arg2
decl_stmt|;
if|if
condition|(
name|node1
operator|->
name|lot_hash
operator|>
name|node2
operator|->
name|lot_hash
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|node1
operator|->
name|lot_hash
operator|<
name|node2
operator|->
name|lot_hash
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|node1
operator|->
name|lot_instance
operator|>
name|node2
operator|->
name|lot_instance
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|node1
operator|->
name|lot_instance
operator|<
name|node2
operator|->
name|lot_instance
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|sa_layout_equal
parameter_list|(
name|sa_lot_t
modifier|*
name|tbf
parameter_list|,
name|sa_attr_type_t
modifier|*
name|attrs
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|count
operator|!=
name|tbf
operator|->
name|lot_attr_count
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|attrs
index|[
name|i
index|]
operator|!=
name|tbf
operator|->
name|lot_attrs
index|[
name|i
index|]
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SA_ATTR_HASH
parameter_list|(
name|attr
parameter_list|)
value|(zfs_crc64_table[(-1ULL ^ attr)& 0xFF])
end_define

begin_function
specifier|static
name|uint64_t
name|sa_layout_info_hash
parameter_list|(
name|sa_attr_type_t
modifier|*
name|attrs
parameter_list|,
name|int
name|attr_count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint64_t
name|crc
init|=
operator|-
literal|1ULL
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|attr_count
condition|;
name|i
operator|++
control|)
name|crc
operator|^=
name|SA_ATTR_HASH
argument_list|(
name|attrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|crc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sa_get_spill
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|hdl
operator|->
name|sa_spill
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|rc
operator|=
name|dmu_spill_hold_existing
argument_list|(
name|hdl
operator|->
name|sa_bonus
argument_list|,
name|NULL
argument_list|,
operator|&
name|hdl
operator|->
name|sa_spill
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|VERIFY
argument_list|(
literal|0
operator|==
name|sa_build_index
argument_list|(
name|hdl
argument_list|,
name|SA_SPILL
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rc
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Main attribute lookup/update function  * returns 0 for success or non zero for failures  *  * Operates on bulk array, first failure will abort further processing  */
end_comment

begin_function
name|int
name|sa_attr_op
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|sa_bulk_attr_t
modifier|*
name|bulk
parameter_list|,
name|int
name|count
parameter_list|,
name|sa_data_op_t
name|data_op
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|sa_os_t
modifier|*
name|sa
init|=
name|hdl
operator|->
name|sa_os
operator|->
name|os_sa
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|sa_buf_type_t
name|buftypes
decl_stmt|;
name|buftypes
operator|=
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|count
operator|>
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|count
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|bulk
index|[
name|i
index|]
operator|.
name|sa_attr
operator|<=
name|hdl
operator|->
name|sa_os
operator|->
name|os_sa
operator|->
name|sa_num_attrs
argument_list|)
expr_stmt|;
name|bulk
index|[
name|i
index|]
operator|.
name|sa_addr
operator|=
name|NULL
expr_stmt|;
comment|/* First check the bonus buffer */
if|if
condition|(
name|hdl
operator|->
name|sa_bonus_tab
operator|&&
name|TOC_ATTR_PRESENT
argument_list|(
name|hdl
operator|->
name|sa_bonus_tab
operator|->
name|sa_idx_tab
index|[
name|bulk
index|[
name|i
index|]
operator|.
name|sa_attr
index|]
argument_list|)
condition|)
block|{
name|SA_ATTR_INFO
argument_list|(
name|sa
argument_list|,
name|hdl
operator|->
name|sa_bonus_tab
argument_list|,
name|SA_GET_HDR
argument_list|(
name|hdl
argument_list|,
name|SA_BONUS
argument_list|)
argument_list|,
name|bulk
index|[
name|i
index|]
operator|.
name|sa_attr
argument_list|,
name|bulk
index|[
name|i
index|]
argument_list|,
name|SA_BONUS
argument_list|,
name|hdl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|&&
operator|!
operator|(
name|buftypes
operator|&
name|SA_BONUS
operator|)
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|hdl
operator|->
name|sa_bonus
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|buftypes
operator||=
name|SA_BONUS
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bulk
index|[
name|i
index|]
operator|.
name|sa_addr
operator|==
name|NULL
operator|&&
operator|(
operator|(
name|error
operator|=
name|sa_get_spill
argument_list|(
name|hdl
argument_list|)
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|TOC_ATTR_PRESENT
argument_list|(
name|hdl
operator|->
name|sa_spill_tab
operator|->
name|sa_idx_tab
index|[
name|bulk
index|[
name|i
index|]
operator|.
name|sa_attr
index|]
argument_list|)
condition|)
block|{
name|SA_ATTR_INFO
argument_list|(
name|sa
argument_list|,
name|hdl
operator|->
name|sa_spill_tab
argument_list|,
name|SA_GET_HDR
argument_list|(
name|hdl
argument_list|,
name|SA_SPILL
argument_list|)
argument_list|,
name|bulk
index|[
name|i
index|]
operator|.
name|sa_attr
argument_list|,
name|bulk
index|[
name|i
index|]
argument_list|,
name|SA_SPILL
argument_list|,
name|hdl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|&&
operator|!
operator|(
name|buftypes
operator|&
name|SA_SPILL
operator|)
operator|&&
name|bulk
index|[
name|i
index|]
operator|.
name|sa_size
operator|==
name|bulk
index|[
name|i
index|]
operator|.
name|sa_length
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|hdl
operator|->
name|sa_spill
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|buftypes
operator||=
name|SA_SPILL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
block|{
return|return
operator|(
operator|(
name|error
operator|==
name|ECKSUM
operator|)
condition|?
name|EIO
else|:
name|error
operator|)
return|;
block|}
switch|switch
condition|(
name|data_op
condition|)
block|{
case|case
name|SA_LOOKUP
case|:
if|if
condition|(
name|bulk
index|[
name|i
index|]
operator|.
name|sa_addr
operator|==
name|NULL
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
if|if
condition|(
name|bulk
index|[
name|i
index|]
operator|.
name|sa_data
condition|)
block|{
name|SA_COPY_DATA
argument_list|(
name|bulk
index|[
name|i
index|]
operator|.
name|sa_data_func
argument_list|,
name|bulk
index|[
name|i
index|]
operator|.
name|sa_addr
argument_list|,
name|bulk
index|[
name|i
index|]
operator|.
name|sa_data
argument_list|,
name|bulk
index|[
name|i
index|]
operator|.
name|sa_size
argument_list|)
expr_stmt|;
block|}
continue|continue;
case|case
name|SA_UPDATE
case|:
comment|/* existing rewrite of attr */
if|if
condition|(
name|bulk
index|[
name|i
index|]
operator|.
name|sa_addr
operator|&&
name|bulk
index|[
name|i
index|]
operator|.
name|sa_size
operator|==
name|bulk
index|[
name|i
index|]
operator|.
name|sa_length
condition|)
block|{
name|SA_COPY_DATA
argument_list|(
name|bulk
index|[
name|i
index|]
operator|.
name|sa_data_func
argument_list|,
name|bulk
index|[
name|i
index|]
operator|.
name|sa_data
argument_list|,
name|bulk
index|[
name|i
index|]
operator|.
name|sa_addr
argument_list|,
name|bulk
index|[
name|i
index|]
operator|.
name|sa_length
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|bulk
index|[
name|i
index|]
operator|.
name|sa_addr
condition|)
block|{
comment|/* attr size change */
name|error
operator|=
name|sa_modify_attrs
argument_list|(
name|hdl
argument_list|,
name|bulk
index|[
name|i
index|]
operator|.
name|sa_attr
argument_list|,
name|SA_REPLACE
argument_list|,
name|bulk
index|[
name|i
index|]
operator|.
name|sa_data_func
argument_list|,
name|bulk
index|[
name|i
index|]
operator|.
name|sa_data
argument_list|,
name|bulk
index|[
name|i
index|]
operator|.
name|sa_length
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* adding new attribute */
name|error
operator|=
name|sa_modify_attrs
argument_list|(
name|hdl
argument_list|,
name|bulk
index|[
name|i
index|]
operator|.
name|sa_attr
argument_list|,
name|SA_ADD
argument_list|,
name|bulk
index|[
name|i
index|]
operator|.
name|sa_data_func
argument_list|,
name|bulk
index|[
name|i
index|]
operator|.
name|sa_data
argument_list|,
name|bulk
index|[
name|i
index|]
operator|.
name|sa_length
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
break|break;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|sa_lot_t
modifier|*
name|sa_add_layout_entry
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|sa_attr_type_t
modifier|*
name|attrs
parameter_list|,
name|int
name|attr_count
parameter_list|,
name|uint64_t
name|lot_num
parameter_list|,
name|uint64_t
name|hash
parameter_list|,
name|boolean_t
name|zapadd
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|sa_os_t
modifier|*
name|sa
init|=
name|os
operator|->
name|os_sa
decl_stmt|;
name|sa_lot_t
modifier|*
name|tb
decl_stmt|,
modifier|*
name|findtb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|avl_index_t
name|loc
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|sa
operator|->
name|sa_lock
argument_list|)
argument_list|)
expr_stmt|;
name|tb
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sa_lot_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|tb
operator|->
name|lot_attr_count
operator|=
name|attr_count
expr_stmt|;
name|tb
operator|->
name|lot_attrs
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sa_attr_type_t
argument_list|)
operator|*
name|attr_count
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|attrs
argument_list|,
name|tb
operator|->
name|lot_attrs
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_attr_type_t
argument_list|)
operator|*
name|attr_count
argument_list|)
expr_stmt|;
name|tb
operator|->
name|lot_num
operator|=
name|lot_num
expr_stmt|;
name|tb
operator|->
name|lot_hash
operator|=
name|hash
expr_stmt|;
name|tb
operator|->
name|lot_instance
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|zapadd
condition|)
block|{
name|char
name|attr_name
index|[
literal|8
index|]
decl_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_layout_attr_obj
operator|==
literal|0
condition|)
block|{
name|sa
operator|->
name|sa_layout_attr_obj
operator|=
name|zap_create_link
argument_list|(
name|os
argument_list|,
name|DMU_OT_SA_ATTR_LAYOUTS
argument_list|,
name|sa
operator|->
name|sa_master_obj
argument_list|,
name|SA_LAYOUTS
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|attr_name
argument_list|,
sizeof|sizeof
argument_list|(
name|attr_name
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|lot_num
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_update
argument_list|(
name|os
argument_list|,
name|os
operator|->
name|os_sa
operator|->
name|sa_layout_attr_obj
argument_list|,
name|attr_name
argument_list|,
literal|2
argument_list|,
name|attr_count
argument_list|,
name|attrs
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|list_create
argument_list|(
operator|&
name|tb
operator|->
name|lot_idx_tab
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_idx_tab_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|sa_idx_tab_t
argument_list|,
name|sa_next
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|attr_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sa
operator|->
name|sa_attr_table
index|[
name|tb
operator|->
name|lot_attrs
index|[
name|i
index|]
index|]
operator|.
name|sa_length
operator|==
literal|0
condition|)
name|tb
operator|->
name|lot_var_sizes
operator|++
expr_stmt|;
block|}
name|avl_add
argument_list|(
operator|&
name|sa
operator|->
name|sa_layout_num_tree
argument_list|,
name|tb
argument_list|)
expr_stmt|;
comment|/* verify we don't have a hash collision */
if|if
condition|(
operator|(
name|findtb
operator|=
name|avl_find
argument_list|(
operator|&
name|sa
operator|->
name|sa_layout_hash_tree
argument_list|,
name|tb
argument_list|,
operator|&
name|loc
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
name|findtb
operator|&&
name|findtb
operator|->
name|lot_hash
operator|==
name|hash
condition|;
name|findtb
operator|=
name|AVL_NEXT
argument_list|(
operator|&
name|sa
operator|->
name|sa_layout_hash_tree
argument_list|,
name|findtb
argument_list|)
control|)
block|{
if|if
condition|(
name|findtb
operator|->
name|lot_instance
operator|!=
name|tb
operator|->
name|lot_instance
condition|)
break|break;
name|tb
operator|->
name|lot_instance
operator|++
expr_stmt|;
block|}
block|}
name|avl_add
argument_list|(
operator|&
name|sa
operator|->
name|sa_layout_hash_tree
argument_list|,
name|tb
argument_list|)
expr_stmt|;
return|return
operator|(
name|tb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sa_find_layout
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|hash
parameter_list|,
name|sa_attr_type_t
modifier|*
name|attrs
parameter_list|,
name|int
name|count
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|sa_lot_t
modifier|*
modifier|*
name|lot
parameter_list|)
block|{
name|sa_lot_t
modifier|*
name|tb
decl_stmt|,
name|tbsearch
decl_stmt|;
name|avl_index_t
name|loc
decl_stmt|;
name|sa_os_t
modifier|*
name|sa
init|=
name|os
operator|->
name|os_sa
decl_stmt|;
name|boolean_t
name|found
init|=
name|B_FALSE
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|sa
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
name|tbsearch
operator|.
name|lot_hash
operator|=
name|hash
expr_stmt|;
name|tbsearch
operator|.
name|lot_instance
operator|=
literal|0
expr_stmt|;
name|tb
operator|=
name|avl_find
argument_list|(
operator|&
name|sa
operator|->
name|sa_layout_hash_tree
argument_list|,
operator|&
name|tbsearch
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
condition|)
block|{
for|for
control|(
init|;
name|tb
operator|&&
name|tb
operator|->
name|lot_hash
operator|==
name|hash
condition|;
name|tb
operator|=
name|AVL_NEXT
argument_list|(
operator|&
name|sa
operator|->
name|sa_layout_hash_tree
argument_list|,
name|tb
argument_list|)
control|)
block|{
if|if
condition|(
name|sa_layout_equal
argument_list|(
name|tb
argument_list|,
name|attrs
argument_list|,
name|count
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
name|B_TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|tb
operator|=
name|sa_add_layout_entry
argument_list|(
name|os
argument_list|,
name|attrs
argument_list|,
name|count
argument_list|,
name|avl_numnodes
argument_list|(
operator|&
name|sa
operator|->
name|sa_layout_num_tree
argument_list|)
argument_list|,
name|hash
argument_list|,
name|B_TRUE
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|sa
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
operator|*
name|lot
operator|=
name|tb
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sa_resize_spill
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|uint32_t
name|size
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint32_t
name|blocksize
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|blocksize
operator|=
name|SPA_MINBLOCKSIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|>
name|SPA_OLD_MAXBLOCKSIZE
condition|)
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EFBIG
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|blocksize
operator|=
name|P2ROUNDUP_TYPED
argument_list|(
name|size
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|,
name|uint32_t
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|dbuf_spill_set_blksz
argument_list|(
name|hdl
operator|->
name|sa_spill
argument_list|,
name|blocksize
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sa_copy_data
parameter_list|(
name|sa_data_locator_t
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|datastart
parameter_list|,
name|void
modifier|*
name|target
parameter_list|,
name|int
name|buflen
parameter_list|)
block|{
if|if
condition|(
name|func
operator|==
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|datastart
argument_list|,
name|target
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|boolean_t
name|start
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|void
modifier|*
name|dataptr
decl_stmt|;
name|void
modifier|*
name|saptr
init|=
name|target
decl_stmt|;
name|uint32_t
name|length
decl_stmt|;
name|start
operator|=
name|B_TRUE
expr_stmt|;
name|bytes
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bytes
operator|<
name|buflen
condition|)
block|{
name|func
argument_list|(
operator|&
name|dataptr
argument_list|,
operator|&
name|length
argument_list|,
name|buflen
argument_list|,
name|start
argument_list|,
name|datastart
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|dataptr
argument_list|,
name|saptr
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|saptr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|saptr
operator|+
name|length
operator|)
expr_stmt|;
name|bytes
operator|+=
name|length
expr_stmt|;
name|start
operator|=
name|B_FALSE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Determine several different sizes  * first the sa header size  * the number of bytes to be stored  * if spill would occur the index in the attribute array is returned  *  * the boolean will_spill will be set when spilling is necessary.  It  * is only set when the buftype is SA_BONUS  */
end_comment

begin_function
specifier|static
name|int
name|sa_find_sizes
parameter_list|(
name|sa_os_t
modifier|*
name|sa
parameter_list|,
name|sa_bulk_attr_t
modifier|*
name|attr_desc
parameter_list|,
name|int
name|attr_count
parameter_list|,
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|sa_buf_type_t
name|buftype
parameter_list|,
name|int
modifier|*
name|index
parameter_list|,
name|int
modifier|*
name|total
parameter_list|,
name|boolean_t
modifier|*
name|will_spill
parameter_list|)
block|{
name|int
name|var_size
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|full_space
decl_stmt|;
name|int
name|hdrsize
decl_stmt|;
name|int
name|extra_hdrsize
decl_stmt|;
if|if
condition|(
name|buftype
operator|==
name|SA_BONUS
operator|&&
name|sa
operator|->
name|sa_force_spill
condition|)
block|{
operator|*
name|total
operator|=
literal|0
expr_stmt|;
operator|*
name|index
operator|=
literal|0
expr_stmt|;
operator|*
name|will_spill
operator|=
name|B_TRUE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|index
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|total
operator|=
literal|0
expr_stmt|;
operator|*
name|will_spill
operator|=
name|B_FALSE
expr_stmt|;
name|extra_hdrsize
operator|=
literal|0
expr_stmt|;
name|hdrsize
operator|=
operator|(
name|SA_BONUSTYPE_FROM_DB
argument_list|(
name|db
argument_list|)
operator|==
name|DMU_OT_ZNODE
operator|)
condition|?
literal|0
else|:
sizeof|sizeof
argument_list|(
name|sa_hdr_phys_t
argument_list|)
expr_stmt|;
name|full_space
operator|=
operator|(
name|buftype
operator|==
name|SA_BONUS
operator|)
condition|?
name|DN_MAX_BONUSLEN
else|:
name|db
operator|->
name|db_size
expr_stmt|;
name|ASSERT
argument_list|(
name|IS_P2ALIGNED
argument_list|(
name|full_space
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|attr_count
condition|;
name|i
operator|++
control|)
block|{
name|boolean_t
name|is_var_sz
decl_stmt|;
operator|*
name|total
operator|=
name|P2ROUNDUP
argument_list|(
operator|*
name|total
argument_list|,
literal|8
argument_list|)
expr_stmt|;
operator|*
name|total
operator|+=
name|attr_desc
index|[
name|i
index|]
operator|.
name|sa_length
expr_stmt|;
if|if
condition|(
operator|*
name|will_spill
condition|)
continue|continue;
name|is_var_sz
operator|=
operator|(
name|SA_REGISTERED_LEN
argument_list|(
name|sa
argument_list|,
name|attr_desc
index|[
name|i
index|]
operator|.
name|sa_attr
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|is_var_sz
condition|)
block|{
name|var_size
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|is_var_sz
operator|&&
name|var_size
operator|>
literal|1
condition|)
block|{
comment|/* 			 * Don't worry that the spill block might overflow. 			 * It will be resized if needed in sa_build_layouts(). 			 */
if|if
condition|(
name|buftype
operator|==
name|SA_SPILL
operator|||
name|P2ROUNDUP
argument_list|(
name|hdrsize
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|,
literal|8
argument_list|)
operator|+
operator|*
name|total
operator|<
name|full_space
condition|)
block|{
comment|/* 				 * Account for header space used by array of 				 * optional sizes of variable-length attributes. 				 * Record the extra header size in case this 				 * increase needs to be reversed due to 				 * spill-over. 				 */
name|hdrsize
operator|+=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|index
operator|!=
operator|-
literal|1
condition|)
name|extra_hdrsize
operator|+=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|buftype
operator|==
name|SA_BONUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|index
operator|==
operator|-
literal|1
condition|)
operator|*
name|index
operator|=
name|i
expr_stmt|;
operator|*
name|will_spill
operator|=
name|B_TRUE
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 		 * find index of where spill *could* occur. 		 * Then continue to count of remainder attribute 		 * space.  The sum is used later for sizing bonus 		 * and spill buffer. 		 */
if|if
condition|(
name|buftype
operator|==
name|SA_BONUS
operator|&&
operator|*
name|index
operator|==
operator|-
literal|1
operator|&&
operator|(
operator|*
name|total
operator|+
name|P2ROUNDUP
argument_list|(
name|hdrsize
argument_list|,
literal|8
argument_list|)
operator|)
operator|>
operator|(
name|full_space
operator|-
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
operator|)
condition|)
block|{
operator|*
name|index
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|total
operator|+
name|P2ROUNDUP
argument_list|(
name|hdrsize
argument_list|,
literal|8
argument_list|)
operator|)
operator|>
name|full_space
operator|&&
name|buftype
operator|==
name|SA_BONUS
condition|)
operator|*
name|will_spill
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|will_spill
condition|)
name|hdrsize
operator|-=
name|extra_hdrsize
expr_stmt|;
name|hdrsize
operator|=
name|P2ROUNDUP
argument_list|(
name|hdrsize
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return
operator|(
name|hdrsize
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BUF_SPACE_NEEDED
parameter_list|(
name|total
parameter_list|,
name|header
parameter_list|)
value|(total + header)
end_define

begin_comment
comment|/*  * Find layout that corresponds to ordering of attributes  * If not found a new layout number is created and added to  * persistent layout tables.  */
end_comment

begin_function
specifier|static
name|int
name|sa_build_layouts
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|sa_bulk_attr_t
modifier|*
name|attr_desc
parameter_list|,
name|int
name|attr_count
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|sa_os_t
modifier|*
name|sa
init|=
name|hdl
operator|->
name|sa_os
operator|->
name|os_sa
decl_stmt|;
name|uint64_t
name|hash
decl_stmt|;
name|sa_buf_type_t
name|buftype
decl_stmt|;
name|sa_hdr_phys_t
modifier|*
name|sahdr
decl_stmt|;
name|void
modifier|*
name|data_start
decl_stmt|;
name|int
name|buf_space
decl_stmt|;
name|sa_attr_type_t
modifier|*
name|attrs
decl_stmt|,
modifier|*
name|attrs_start
decl_stmt|;
name|int
name|i
decl_stmt|,
name|lot_count
decl_stmt|;
name|int
name|hdrsize
decl_stmt|;
name|int
name|spillhdrsize
init|=
literal|0
decl_stmt|;
name|int
name|used
decl_stmt|;
name|dmu_object_type_t
name|bonustype
decl_stmt|;
name|sa_lot_t
modifier|*
name|lot
decl_stmt|;
name|int
name|len_idx
decl_stmt|;
name|int
name|spill_used
decl_stmt|;
name|boolean_t
name|spilling
decl_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|hdl
operator|->
name|sa_bonus
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|bonustype
operator|=
name|SA_BONUSTYPE_FROM_DB
argument_list|(
name|hdl
operator|->
name|sa_bonus
argument_list|)
expr_stmt|;
comment|/* first determine bonus header size and sum of all attributes */
name|hdrsize
operator|=
name|sa_find_sizes
argument_list|(
name|sa
argument_list|,
name|attr_desc
argument_list|,
name|attr_count
argument_list|,
name|hdl
operator|->
name|sa_bonus
argument_list|,
name|SA_BONUS
argument_list|,
operator|&
name|i
argument_list|,
operator|&
name|used
argument_list|,
operator|&
name|spilling
argument_list|)
expr_stmt|;
if|if
condition|(
name|used
operator|>
name|SPA_OLD_MAXBLOCKSIZE
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EFBIG
argument_list|)
operator|)
return|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_set_bonus
argument_list|(
name|hdl
operator|->
name|sa_bonus
argument_list|,
name|spilling
condition|?
name|MIN
argument_list|(
name|DN_MAX_BONUSLEN
operator|-
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
argument_list|,
name|used
operator|+
name|hdrsize
argument_list|)
else|:
name|used
operator|+
name|hdrsize
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|bonustype
operator|==
name|DMU_OT_ZNODE
operator|&&
name|spilling
operator|==
literal|0
operator|)
operator|||
name|bonustype
operator|==
name|DMU_OT_SA
argument_list|)
expr_stmt|;
comment|/* setup and size spill buffer when needed */
if|if
condition|(
name|spilling
condition|)
block|{
name|boolean_t
name|dummy
decl_stmt|;
if|if
condition|(
name|hdl
operator|->
name|sa_spill
operator|==
name|NULL
condition|)
block|{
name|VERIFY
argument_list|(
name|dmu_spill_hold_by_bonus
argument_list|(
name|hdl
operator|->
name|sa_bonus
argument_list|,
name|NULL
argument_list|,
operator|&
name|hdl
operator|->
name|sa_spill
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|dmu_buf_will_dirty
argument_list|(
name|hdl
operator|->
name|sa_spill
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|spillhdrsize
operator|=
name|sa_find_sizes
argument_list|(
name|sa
argument_list|,
operator|&
name|attr_desc
index|[
name|i
index|]
argument_list|,
name|attr_count
operator|-
name|i
argument_list|,
name|hdl
operator|->
name|sa_spill
argument_list|,
name|SA_SPILL
argument_list|,
operator|&
name|i
argument_list|,
operator|&
name|spill_used
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
name|spill_used
operator|>
name|SPA_OLD_MAXBLOCKSIZE
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EFBIG
argument_list|)
operator|)
return|;
name|buf_space
operator|=
name|hdl
operator|->
name|sa_spill
operator|->
name|db_size
operator|-
name|spillhdrsize
expr_stmt|;
if|if
condition|(
name|BUF_SPACE_NEEDED
argument_list|(
name|spill_used
argument_list|,
name|spillhdrsize
argument_list|)
operator|>
name|hdl
operator|->
name|sa_spill
operator|->
name|db_size
condition|)
name|VERIFY
argument_list|(
literal|0
operator|==
name|sa_resize_spill
argument_list|(
name|hdl
argument_list|,
name|BUF_SPACE_NEEDED
argument_list|(
name|spill_used
argument_list|,
name|spillhdrsize
argument_list|)
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* setup starting pointers to lay down data */
name|data_start
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|hdl
operator|->
name|sa_bonus
operator|->
name|db_data
operator|+
name|hdrsize
operator|)
expr_stmt|;
name|sahdr
operator|=
operator|(
name|sa_hdr_phys_t
operator|*
operator|)
name|hdl
operator|->
name|sa_bonus
operator|->
name|db_data
expr_stmt|;
name|buftype
operator|=
name|SA_BONUS
expr_stmt|;
if|if
condition|(
name|spilling
condition|)
name|buf_space
operator|=
operator|(
name|sa
operator|->
name|sa_force_spill
operator|)
condition|?
literal|0
else|:
name|SA_BLKPTR_SPACE
operator|-
name|hdrsize
expr_stmt|;
else|else
name|buf_space
operator|=
name|hdl
operator|->
name|sa_bonus
operator|->
name|db_size
operator|-
name|hdrsize
expr_stmt|;
name|attrs_start
operator|=
name|attrs
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sa_attr_type_t
argument_list|)
operator|*
name|attr_count
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|lot_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|len_idx
operator|=
literal|0
operator|,
name|hash
operator|=
operator|-
literal|1ULL
init|;
name|i
operator|!=
name|attr_count
condition|;
name|i
operator|++
control|)
block|{
name|uint16_t
name|length
decl_stmt|;
name|ASSERT
argument_list|(
name|IS_P2ALIGNED
argument_list|(
name|data_start
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|IS_P2ALIGNED
argument_list|(
name|buf_space
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|attrs
index|[
name|i
index|]
operator|=
name|attr_desc
index|[
name|i
index|]
operator|.
name|sa_attr
expr_stmt|;
name|length
operator|=
name|SA_REGISTERED_LEN
argument_list|(
name|sa
argument_list|,
name|attrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
name|length
operator|=
name|attr_desc
index|[
name|i
index|]
operator|.
name|sa_length
expr_stmt|;
else|else
name|VERIFY
argument_list|(
name|length
operator|==
name|attr_desc
index|[
name|i
index|]
operator|.
name|sa_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf_space
operator|<
name|length
condition|)
block|{
comment|/* switch to spill buffer */
name|VERIFY
argument_list|(
name|spilling
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|bonustype
operator|==
name|DMU_OT_SA
argument_list|)
expr_stmt|;
if|if
condition|(
name|buftype
operator|==
name|SA_BONUS
operator|&&
operator|!
name|sa
operator|->
name|sa_force_spill
condition|)
block|{
name|sa_find_layout
argument_list|(
name|hdl
operator|->
name|sa_os
argument_list|,
name|hash
argument_list|,
name|attrs_start
argument_list|,
name|lot_count
argument_list|,
name|tx
argument_list|,
operator|&
name|lot
argument_list|)
expr_stmt|;
name|SA_SET_HDR
argument_list|(
name|sahdr
argument_list|,
name|lot
operator|->
name|lot_num
argument_list|,
name|hdrsize
argument_list|)
expr_stmt|;
block|}
name|buftype
operator|=
name|SA_SPILL
expr_stmt|;
name|hash
operator|=
operator|-
literal|1ULL
expr_stmt|;
name|len_idx
operator|=
literal|0
expr_stmt|;
name|sahdr
operator|=
operator|(
name|sa_hdr_phys_t
operator|*
operator|)
name|hdl
operator|->
name|sa_spill
operator|->
name|db_data
expr_stmt|;
name|sahdr
operator|->
name|sa_magic
operator|=
name|SA_MAGIC
expr_stmt|;
name|data_start
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|sahdr
operator|+
name|spillhdrsize
operator|)
expr_stmt|;
name|attrs_start
operator|=
operator|&
name|attrs
index|[
name|i
index|]
expr_stmt|;
name|buf_space
operator|=
name|hdl
operator|->
name|sa_spill
operator|->
name|db_size
operator|-
name|spillhdrsize
expr_stmt|;
name|lot_count
operator|=
literal|0
expr_stmt|;
block|}
name|hash
operator|^=
name|SA_ATTR_HASH
argument_list|(
name|attrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|attr_desc
index|[
name|i
index|]
operator|.
name|sa_addr
operator|=
name|data_start
expr_stmt|;
name|attr_desc
index|[
name|i
index|]
operator|.
name|sa_size
operator|=
name|length
expr_stmt|;
name|SA_COPY_DATA
argument_list|(
name|attr_desc
index|[
name|i
index|]
operator|.
name|sa_data_func
argument_list|,
name|attr_desc
index|[
name|i
index|]
operator|.
name|sa_data
argument_list|,
name|data_start
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_attr_table
index|[
name|attrs
index|[
name|i
index|]
index|]
operator|.
name|sa_length
operator|==
literal|0
condition|)
block|{
name|sahdr
operator|->
name|sa_lengths
index|[
name|len_idx
operator|++
index|]
operator|=
name|length
expr_stmt|;
block|}
name|VERIFY
argument_list|(
operator|(
name|uintptr_t
operator|)
name|data_start
operator|%
literal|8
operator|==
literal|0
argument_list|)
expr_stmt|;
name|data_start
operator|=
operator|(
name|void
operator|*
operator|)
name|P2ROUNDUP
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|data_start
operator|+
name|length
operator|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|buf_space
operator|-=
name|P2ROUNDUP
argument_list|(
name|length
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|lot_count
operator|++
expr_stmt|;
block|}
name|sa_find_layout
argument_list|(
name|hdl
operator|->
name|sa_os
argument_list|,
name|hash
argument_list|,
name|attrs_start
argument_list|,
name|lot_count
argument_list|,
name|tx
argument_list|,
operator|&
name|lot
argument_list|)
expr_stmt|;
comment|/* 	 * Verify that old znodes always have layout number 0. 	 * Must be DMU_OT_SA for arbitrary layouts 	 */
name|VERIFY
argument_list|(
operator|(
name|bonustype
operator|==
name|DMU_OT_ZNODE
operator|&&
name|lot
operator|->
name|lot_num
operator|==
literal|0
operator|)
operator|||
operator|(
name|bonustype
operator|==
name|DMU_OT_SA
operator|&&
name|lot
operator|->
name|lot_num
operator|>
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bonustype
operator|==
name|DMU_OT_SA
condition|)
block|{
name|SA_SET_HDR
argument_list|(
name|sahdr
argument_list|,
name|lot
operator|->
name|lot_num
argument_list|,
name|buftype
operator|==
name|SA_BONUS
condition|?
name|hdrsize
else|:
name|spillhdrsize
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|attrs
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_attr_type_t
argument_list|)
operator|*
name|attr_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdl
operator|->
name|sa_bonus_tab
condition|)
block|{
name|sa_idx_tab_rele
argument_list|(
name|hdl
operator|->
name|sa_os
argument_list|,
name|hdl
operator|->
name|sa_bonus_tab
argument_list|)
expr_stmt|;
name|hdl
operator|->
name|sa_bonus_tab
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sa
operator|->
name|sa_force_spill
condition|)
name|VERIFY
argument_list|(
literal|0
operator|==
name|sa_build_index
argument_list|(
name|hdl
argument_list|,
name|SA_BONUS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdl
operator|->
name|sa_spill
condition|)
block|{
name|sa_idx_tab_rele
argument_list|(
name|hdl
operator|->
name|sa_os
argument_list|,
name|hdl
operator|->
name|sa_spill_tab
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|spilling
condition|)
block|{
comment|/* 			 * remove spill block that is no longer needed. 			 */
name|dmu_buf_rele
argument_list|(
name|hdl
operator|->
name|sa_spill
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|hdl
operator|->
name|sa_spill
operator|=
name|NULL
expr_stmt|;
name|hdl
operator|->
name|sa_spill_tab
operator|=
name|NULL
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_rm_spill
argument_list|(
name|hdl
operator|->
name|sa_os
argument_list|,
name|sa_handle_object
argument_list|(
name|hdl
argument_list|)
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|sa_build_index
argument_list|(
name|hdl
argument_list|,
name|SA_SPILL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sa_free_attr_table
parameter_list|(
name|sa_os_t
modifier|*
name|sa
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_attr_table
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|sa
operator|->
name|sa_num_attrs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sa
operator|->
name|sa_attr_table
index|[
name|i
index|]
operator|.
name|sa_name
condition|)
name|kmem_free
argument_list|(
name|sa
operator|->
name|sa_attr_table
index|[
name|i
index|]
operator|.
name|sa_name
argument_list|,
name|strlen
argument_list|(
name|sa
operator|->
name|sa_attr_table
index|[
name|i
index|]
operator|.
name|sa_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|sa
operator|->
name|sa_attr_table
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_attr_table_t
argument_list|)
operator|*
name|sa
operator|->
name|sa_num_attrs
argument_list|)
expr_stmt|;
name|sa
operator|->
name|sa_attr_table
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sa_attr_table_setup
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|sa_attr_reg_t
modifier|*
name|reg_attrs
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|sa_os_t
modifier|*
name|sa
init|=
name|os
operator|->
name|os_sa
decl_stmt|;
name|uint64_t
name|sa_attr_count
init|=
literal|0
decl_stmt|;
name|uint64_t
name|sa_reg_count
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint64_t
name|attr_value
decl_stmt|;
name|sa_attr_table_t
modifier|*
name|tb
decl_stmt|;
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
name|int
name|registered_count
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|dmu_objset_type_t
name|ostype
init|=
name|dmu_objset_type
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|sa
operator|->
name|sa_user_table
operator|=
name|kmem_zalloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|sa_attr_type_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|sa
operator|->
name|sa_user_table_sz
operator|=
name|count
operator|*
sizeof|sizeof
argument_list|(
name|sa_attr_type_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_reg_attr_obj
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|zap_count
argument_list|(
name|os
argument_list|,
name|sa
operator|->
name|sa_reg_attr_obj
argument_list|,
operator|&
name|sa_attr_count
argument_list|)
expr_stmt|;
comment|/* 		 * Make sure we retrieved a count and that it isn't zero 		 */
if|if
condition|(
name|error
operator|||
operator|(
name|error
operator|==
literal|0
operator|&&
name|sa_attr_count
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|bail
goto|;
block|}
name|sa_reg_count
operator|=
name|sa_attr_count
expr_stmt|;
block|}
if|if
condition|(
name|ostype
operator|==
name|DMU_OST_ZFS
operator|&&
name|sa_attr_count
operator|==
literal|0
condition|)
name|sa_attr_count
operator|+=
name|sa_legacy_attr_count
expr_stmt|;
comment|/* Allocate attribute numbers for attributes that aren't registered */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|count
condition|;
name|i
operator|++
control|)
block|{
name|boolean_t
name|found
init|=
name|B_FALSE
decl_stmt|;
name|int
name|j
decl_stmt|;
if|if
condition|(
name|ostype
operator|==
name|DMU_OST_ZFS
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|!=
name|sa_legacy_attr_count
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|reg_attrs
index|[
name|i
index|]
operator|.
name|sa_name
argument_list|,
name|sa_legacy_attrs
index|[
name|j
index|]
operator|.
name|sa_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sa
operator|->
name|sa_user_table
index|[
name|i
index|]
operator|=
name|sa_legacy_attrs
index|[
name|j
index|]
operator|.
name|sa_attr
expr_stmt|;
name|found
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|found
condition|)
continue|continue;
if|if
condition|(
name|sa
operator|->
name|sa_reg_attr_obj
condition|)
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|sa
operator|->
name|sa_reg_attr_obj
argument_list|,
name|reg_attrs
index|[
name|i
index|]
operator|.
name|sa_name
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|attr_value
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|ENOENT
case|:
name|sa
operator|->
name|sa_user_table
index|[
name|i
index|]
operator|=
operator|(
name|sa_attr_type_t
operator|)
name|sa_attr_count
expr_stmt|;
name|sa_attr_count
operator|++
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|sa
operator|->
name|sa_user_table
index|[
name|i
index|]
operator|=
name|ATTR_NUM
argument_list|(
name|attr_value
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|bail
goto|;
block|}
block|}
name|sa
operator|->
name|sa_num_attrs
operator|=
name|sa_attr_count
expr_stmt|;
name|tb
operator|=
name|sa
operator|->
name|sa_attr_table
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sa_attr_table_t
argument_list|)
operator|*
name|sa_attr_count
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * Attribute table is constructed from requested attribute list, 	 * previously foreign registered attributes, and also the legacy 	 * ZPL set of attributes. 	 */
if|if
condition|(
name|sa
operator|->
name|sa_reg_attr_obj
condition|)
block|{
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|os
argument_list|,
name|sa
operator|->
name|sa_reg_attr_obj
argument_list|)
init|;
operator|(
name|error
operator|=
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|uint64_t
name|value
decl_stmt|;
name|value
operator|=
name|za
operator|.
name|za_first_integer
expr_stmt|;
name|registered_count
operator|++
expr_stmt|;
name|tb
index|[
name|ATTR_NUM
argument_list|(
name|value
argument_list|)
index|]
operator|.
name|sa_attr
operator|=
name|ATTR_NUM
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|tb
index|[
name|ATTR_NUM
argument_list|(
name|value
argument_list|)
index|]
operator|.
name|sa_length
operator|=
name|ATTR_LENGTH
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|tb
index|[
name|ATTR_NUM
argument_list|(
name|value
argument_list|)
index|]
operator|.
name|sa_byteswap
operator|=
name|ATTR_BSWAP
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|tb
index|[
name|ATTR_NUM
argument_list|(
name|value
argument_list|)
index|]
operator|.
name|sa_registered
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|tb
index|[
name|ATTR_NUM
argument_list|(
name|value
argument_list|)
index|]
operator|.
name|sa_name
condition|)
block|{
continue|continue;
block|}
name|tb
index|[
name|ATTR_NUM
argument_list|(
name|value
argument_list|)
index|]
operator|.
name|sa_name
operator|=
name|kmem_zalloc
argument_list|(
name|strlen
argument_list|(
name|za
operator|.
name|za_name
argument_list|)
operator|+
literal|1
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|tb
index|[
name|ATTR_NUM
argument_list|(
name|value
argument_list|)
index|]
operator|.
name|sa_name
argument_list|,
name|za
operator|.
name|za_name
argument_list|,
name|strlen
argument_list|(
name|za
operator|.
name|za_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
comment|/* 		 * Make sure we processed the correct number of registered 		 * attributes 		 */
if|if
condition|(
name|registered_count
operator|!=
name|sa_reg_count
condition|)
block|{
name|ASSERT
argument_list|(
name|error
operator|!=
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|bail
goto|;
block|}
block|}
if|if
condition|(
name|ostype
operator|==
name|DMU_OST_ZFS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|sa_legacy_attr_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tb
index|[
name|i
index|]
operator|.
name|sa_name
condition|)
continue|continue;
name|tb
index|[
name|i
index|]
operator|.
name|sa_attr
operator|=
name|sa_legacy_attrs
index|[
name|i
index|]
operator|.
name|sa_attr
expr_stmt|;
name|tb
index|[
name|i
index|]
operator|.
name|sa_length
operator|=
name|sa_legacy_attrs
index|[
name|i
index|]
operator|.
name|sa_length
expr_stmt|;
name|tb
index|[
name|i
index|]
operator|.
name|sa_byteswap
operator|=
name|sa_legacy_attrs
index|[
name|i
index|]
operator|.
name|sa_byteswap
expr_stmt|;
name|tb
index|[
name|i
index|]
operator|.
name|sa_registered
operator|=
name|B_FALSE
expr_stmt|;
name|tb
index|[
name|i
index|]
operator|.
name|sa_name
operator|=
name|kmem_zalloc
argument_list|(
name|strlen
argument_list|(
name|sa_legacy_attrs
index|[
name|i
index|]
operator|.
name|sa_name
argument_list|)
operator|+
literal|1
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|tb
index|[
name|i
index|]
operator|.
name|sa_name
argument_list|,
name|sa_legacy_attrs
index|[
name|i
index|]
operator|.
name|sa_name
argument_list|,
name|strlen
argument_list|(
name|sa_legacy_attrs
index|[
name|i
index|]
operator|.
name|sa_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|count
condition|;
name|i
operator|++
control|)
block|{
name|sa_attr_type_t
name|attr_id
decl_stmt|;
name|attr_id
operator|=
name|sa
operator|->
name|sa_user_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|tb
index|[
name|attr_id
index|]
operator|.
name|sa_name
condition|)
continue|continue;
name|tb
index|[
name|attr_id
index|]
operator|.
name|sa_length
operator|=
name|reg_attrs
index|[
name|i
index|]
operator|.
name|sa_length
expr_stmt|;
name|tb
index|[
name|attr_id
index|]
operator|.
name|sa_byteswap
operator|=
name|reg_attrs
index|[
name|i
index|]
operator|.
name|sa_byteswap
expr_stmt|;
name|tb
index|[
name|attr_id
index|]
operator|.
name|sa_attr
operator|=
name|attr_id
expr_stmt|;
name|tb
index|[
name|attr_id
index|]
operator|.
name|sa_name
operator|=
name|kmem_zalloc
argument_list|(
name|strlen
argument_list|(
name|reg_attrs
index|[
name|i
index|]
operator|.
name|sa_name
argument_list|)
operator|+
literal|1
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|tb
index|[
name|attr_id
index|]
operator|.
name|sa_name
argument_list|,
name|reg_attrs
index|[
name|i
index|]
operator|.
name|sa_name
argument_list|,
name|strlen
argument_list|(
name|reg_attrs
index|[
name|i
index|]
operator|.
name|sa_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|sa
operator|->
name|sa_need_attr_registration
operator|=
operator|(
name|sa_attr_count
operator|!=
name|registered_count
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bail
label|:
name|kmem_free
argument_list|(
name|sa
operator|->
name|sa_user_table
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|sa_attr_type_t
argument_list|)
argument_list|)
expr_stmt|;
name|sa
operator|->
name|sa_user_table
operator|=
name|NULL
expr_stmt|;
name|sa_free_attr_table
argument_list|(
name|sa
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|error
operator|!=
literal|0
operator|)
condition|?
name|error
else|:
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sa_setup
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|sa_obj
parameter_list|,
name|sa_attr_reg_t
modifier|*
name|reg_attrs
parameter_list|,
name|int
name|count
parameter_list|,
name|sa_attr_type_t
modifier|*
modifier|*
name|user_table
parameter_list|)
block|{
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
name|sa_os_t
modifier|*
name|sa
decl_stmt|;
name|dmu_objset_type_t
name|ostype
init|=
name|dmu_objset_type
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|sa_attr_type_t
modifier|*
name|tb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|os
operator|->
name|os_user_ptr_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|os_sa
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|os
operator|->
name|os_sa
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_user_ptr_lock
argument_list|)
expr_stmt|;
name|tb
operator|=
name|os
operator|->
name|os_sa
operator|->
name|sa_user_table
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_sa
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
operator|*
name|user_table
operator|=
name|tb
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sa
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sa_os_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|sa
operator|->
name|sa_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sa
operator|->
name|sa_master_obj
operator|=
name|sa_obj
expr_stmt|;
name|os
operator|->
name|os_sa
operator|=
name|sa
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|sa
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_user_ptr_lock
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|sa
operator|->
name|sa_layout_num_tree
argument_list|,
name|layout_num_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_lot_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|sa_lot_t
argument_list|,
name|lot_num_node
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|sa
operator|->
name|sa_layout_hash_tree
argument_list|,
name|layout_hash_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_lot_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|sa_lot_t
argument_list|,
name|lot_hash_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa_obj
condition|)
block|{
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|sa_obj
argument_list|,
name|SA_LAYOUTS
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|sa
operator|->
name|sa_layout_attr_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
goto|goto
name|fail
goto|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|sa_obj
argument_list|,
name|SA_REGISTRY
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|sa
operator|->
name|sa_reg_attr_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|sa_attr_table_setup
argument_list|(
name|os
argument_list|,
name|reg_attrs
argument_list|,
name|count
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|sa
operator|->
name|sa_layout_attr_obj
operator|!=
literal|0
condition|)
block|{
name|uint64_t
name|layout_count
decl_stmt|;
name|error
operator|=
name|zap_count
argument_list|(
name|os
argument_list|,
name|sa
operator|->
name|sa_layout_attr_obj
argument_list|,
operator|&
name|layout_count
argument_list|)
expr_stmt|;
comment|/* 		 * Layout number count should be> 0 		 */
if|if
condition|(
name|error
operator|||
operator|(
name|error
operator|==
literal|0
operator|&&
name|layout_count
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|os
argument_list|,
name|sa
operator|->
name|sa_layout_attr_obj
argument_list|)
init|;
operator|(
name|error
operator|=
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|sa_attr_type_t
modifier|*
name|lot_attrs
decl_stmt|;
name|uint64_t
name|lot_num
decl_stmt|;
name|lot_attrs
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sa_attr_type_t
argument_list|)
operator|*
name|za
operator|.
name|za_num_integers
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
operator|(
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|sa
operator|->
name|sa_layout_attr_obj
argument_list|,
name|za
operator|.
name|za_name
argument_list|,
literal|2
argument_list|,
name|za
operator|.
name|za_num_integers
argument_list|,
name|lot_attrs
argument_list|)
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|lot_attrs
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_attr_type_t
argument_list|)
operator|*
name|za
operator|.
name|za_num_integers
argument_list|)
expr_stmt|;
break|break;
block|}
name|VERIFY
argument_list|(
name|ddi_strtoull
argument_list|(
name|za
operator|.
name|za_name
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|*
operator|)
operator|&
name|lot_num
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sa_add_layout_entry
argument_list|(
name|os
argument_list|,
name|lot_attrs
argument_list|,
name|za
operator|.
name|za_num_integers
argument_list|,
name|lot_num
argument_list|,
name|sa_layout_info_hash
argument_list|(
name|lot_attrs
argument_list|,
name|za
operator|.
name|za_num_integers
argument_list|)
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|lot_attrs
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_attr_type_t
argument_list|)
operator|*
name|za
operator|.
name|za_num_integers
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
comment|/* 		 * Make sure layout count matches number of entries added 		 * to AVL tree 		 */
if|if
condition|(
name|avl_numnodes
argument_list|(
operator|&
name|sa
operator|->
name|sa_layout_num_tree
argument_list|)
operator|!=
name|layout_count
condition|)
block|{
name|ASSERT
argument_list|(
name|error
operator|!=
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
comment|/* Add special layout number for old ZNODES */
if|if
condition|(
name|ostype
operator|==
name|DMU_OST_ZFS
condition|)
block|{
operator|(
name|void
operator|)
name|sa_add_layout_entry
argument_list|(
name|os
argument_list|,
name|sa_legacy_zpl_layout
argument_list|,
name|sa_legacy_attr_count
argument_list|,
literal|0
argument_list|,
name|sa_layout_info_hash
argument_list|(
name|sa_legacy_zpl_layout
argument_list|,
name|sa_legacy_attr_count
argument_list|)
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sa_add_layout_entry
argument_list|(
name|os
argument_list|,
name|sa_dummy_zpl_layout
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
operator|*
name|user_table
operator|=
name|os
operator|->
name|os_sa
operator|->
name|sa_user_table
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|sa
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|os
operator|->
name|os_sa
operator|=
name|NULL
expr_stmt|;
name|sa_free_attr_table
argument_list|(
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_user_table
condition|)
name|kmem_free
argument_list|(
name|sa
operator|->
name|sa_user_table
argument_list|,
name|sa
operator|->
name|sa_user_table_sz
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|sa
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|sa
operator|->
name|sa_layout_hash_tree
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|sa
operator|->
name|sa_layout_num_tree
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|sa
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|sa
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_os_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|error
operator|==
name|ECKSUM
operator|)
condition|?
name|EIO
else|:
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sa_tear_down
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
name|sa_os_t
modifier|*
name|sa
init|=
name|os
operator|->
name|os_sa
decl_stmt|;
name|sa_lot_t
modifier|*
name|layout
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
name|kmem_free
argument_list|(
name|sa
operator|->
name|sa_user_table
argument_list|,
name|sa
operator|->
name|sa_user_table_sz
argument_list|)
expr_stmt|;
comment|/* Free up attr table */
name|sa_free_attr_table
argument_list|(
name|sa
argument_list|)
expr_stmt|;
name|cookie
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|layout
operator|=
name|avl_destroy_nodes
argument_list|(
operator|&
name|sa
operator|->
name|sa_layout_hash_tree
argument_list|,
operator|&
name|cookie
argument_list|)
condition|)
block|{
name|sa_idx_tab_t
modifier|*
name|tab
decl_stmt|;
while|while
condition|(
name|tab
operator|=
name|list_head
argument_list|(
operator|&
name|layout
operator|->
name|lot_idx_tab
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|tab
operator|->
name|sa_refcount
argument_list|)
argument_list|)
expr_stmt|;
name|sa_idx_tab_rele
argument_list|(
name|os
argument_list|,
name|tab
argument_list|)
expr_stmt|;
block|}
block|}
name|cookie
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|layout
operator|=
name|avl_destroy_nodes
argument_list|(
operator|&
name|sa
operator|->
name|sa_layout_num_tree
argument_list|,
operator|&
name|cookie
argument_list|)
condition|)
block|{
name|kmem_free
argument_list|(
name|layout
operator|->
name|lot_attrs
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_attr_type_t
argument_list|)
operator|*
name|layout
operator|->
name|lot_attr_count
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|layout
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_lot_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|avl_destroy
argument_list|(
operator|&
name|sa
operator|->
name|sa_layout_hash_tree
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|sa
operator|->
name|sa_layout_num_tree
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|sa
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|sa
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_os_t
argument_list|)
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_sa
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sa_build_idx_tab
parameter_list|(
name|void
modifier|*
name|hdr
parameter_list|,
name|void
modifier|*
name|attr_addr
parameter_list|,
name|sa_attr_type_t
name|attr
parameter_list|,
name|uint16_t
name|length
parameter_list|,
name|int
name|length_idx
parameter_list|,
name|boolean_t
name|var_length
parameter_list|,
name|void
modifier|*
name|userp
parameter_list|)
block|{
name|sa_idx_tab_t
modifier|*
name|idx_tab
init|=
name|userp
decl_stmt|;
if|if
condition|(
name|var_length
condition|)
block|{
name|ASSERT
argument_list|(
name|idx_tab
operator|->
name|sa_variable_lengths
argument_list|)
expr_stmt|;
name|idx_tab
operator|->
name|sa_variable_lengths
index|[
name|length_idx
index|]
operator|=
name|length
expr_stmt|;
block|}
name|TOC_ATTR_ENCODE
argument_list|(
name|idx_tab
operator|->
name|sa_idx_tab
index|[
name|attr
index|]
argument_list|,
name|length_idx
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|uintptr_t
operator|)
name|attr_addr
operator|-
operator|(
name|uintptr_t
operator|)
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sa_attr_iter
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|sa_hdr_phys_t
modifier|*
name|hdr
parameter_list|,
name|dmu_object_type_t
name|type
parameter_list|,
name|sa_iterfunc_t
name|func
parameter_list|,
name|sa_lot_t
modifier|*
name|tab
parameter_list|,
name|void
modifier|*
name|userp
parameter_list|)
block|{
name|void
modifier|*
name|data_start
decl_stmt|;
name|sa_lot_t
modifier|*
name|tb
init|=
name|tab
decl_stmt|;
name|sa_lot_t
name|search
decl_stmt|;
name|avl_index_t
name|loc
decl_stmt|;
name|sa_os_t
modifier|*
name|sa
init|=
name|os
operator|->
name|os_sa
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint16_t
modifier|*
name|length_start
init|=
name|NULL
decl_stmt|;
name|uint8_t
name|length_idx
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tab
operator|==
name|NULL
condition|)
block|{
name|search
operator|.
name|lot_num
operator|=
name|SA_LAYOUT_NUM
argument_list|(
name|hdr
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|tb
operator|=
name|avl_find
argument_list|(
operator|&
name|sa
operator|->
name|sa_layout_num_tree
argument_list|,
operator|&
name|search
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IS_SA_BONUSTYPE
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|data_start
operator|=
operator|(
name|void
operator|*
operator|)
name|P2ROUNDUP
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|hdr
operator|+
name|offsetof
argument_list|(
name|sa_hdr_phys_t
argument_list|,
name|sa_lengths
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|*
name|tb
operator|->
name|lot_var_sizes
operator|)
operator|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|length_start
operator|=
name|hdr
operator|->
name|sa_lengths
expr_stmt|;
block|}
else|else
block|{
name|data_start
operator|=
name|hdr
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|tb
operator|->
name|lot_attr_count
condition|;
name|i
operator|++
control|)
block|{
name|int
name|attr_length
decl_stmt|,
name|reg_length
decl_stmt|;
name|uint8_t
name|idx_len
decl_stmt|;
name|reg_length
operator|=
name|sa
operator|->
name|sa_attr_table
index|[
name|tb
operator|->
name|lot_attrs
index|[
name|i
index|]
index|]
operator|.
name|sa_length
expr_stmt|;
if|if
condition|(
name|reg_length
condition|)
block|{
name|attr_length
operator|=
name|reg_length
expr_stmt|;
name|idx_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|attr_length
operator|=
name|length_start
index|[
name|length_idx
index|]
expr_stmt|;
name|idx_len
operator|=
name|length_idx
operator|++
expr_stmt|;
block|}
name|func
argument_list|(
name|hdr
argument_list|,
name|data_start
argument_list|,
name|tb
operator|->
name|lot_attrs
index|[
name|i
index|]
argument_list|,
name|attr_length
argument_list|,
name|idx_len
argument_list|,
name|reg_length
operator|==
literal|0
condition|?
name|B_TRUE
else|:
name|B_FALSE
argument_list|,
name|userp
argument_list|)
expr_stmt|;
name|data_start
operator|=
operator|(
name|void
operator|*
operator|)
name|P2ROUNDUP
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|data_start
operator|+
name|attr_length
operator|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|sa_byteswap_cb
parameter_list|(
name|void
modifier|*
name|hdr
parameter_list|,
name|void
modifier|*
name|attr_addr
parameter_list|,
name|sa_attr_type_t
name|attr
parameter_list|,
name|uint16_t
name|length
parameter_list|,
name|int
name|length_idx
parameter_list|,
name|boolean_t
name|variable_length
parameter_list|,
name|void
modifier|*
name|userp
parameter_list|)
block|{
name|sa_handle_t
modifier|*
name|hdl
init|=
name|userp
decl_stmt|;
name|sa_os_t
modifier|*
name|sa
init|=
name|hdl
operator|->
name|sa_os
operator|->
name|os_sa
decl_stmt|;
name|sa_bswap_table
index|[
name|sa
operator|->
name|sa_attr_table
index|[
name|attr
index|]
operator|.
name|sa_byteswap
index|]
operator|(
name|attr_addr
operator|,
name|length
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sa_byteswap
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|sa_buf_type_t
name|buftype
parameter_list|)
block|{
name|sa_hdr_phys_t
modifier|*
name|sa_hdr_phys
init|=
name|SA_GET_HDR
argument_list|(
name|hdl
argument_list|,
name|buftype
argument_list|)
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|db
decl_stmt|;
name|sa_os_t
modifier|*
name|sa
init|=
name|hdl
operator|->
name|sa_os
operator|->
name|os_sa
decl_stmt|;
name|int
name|num_lengths
init|=
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|sa
operator|->
name|sa_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa_hdr_phys
operator|->
name|sa_magic
operator|==
name|SA_MAGIC
condition|)
return|return;
name|db
operator|=
name|SA_GET_DB
argument_list|(
name|hdl
argument_list|,
name|buftype
argument_list|)
expr_stmt|;
if|if
condition|(
name|buftype
operator|==
name|SA_SPILL
condition|)
block|{
name|arc_release
argument_list|(
name|db
operator|->
name|db_buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|arc_buf_thaw
argument_list|(
name|db
operator|->
name|db_buf
argument_list|)
expr_stmt|;
block|}
name|sa_hdr_phys
operator|->
name|sa_magic
operator|=
name|BSWAP_32
argument_list|(
name|sa_hdr_phys
operator|->
name|sa_magic
argument_list|)
expr_stmt|;
name|sa_hdr_phys
operator|->
name|sa_layout_info
operator|=
name|BSWAP_16
argument_list|(
name|sa_hdr_phys
operator|->
name|sa_layout_info
argument_list|)
expr_stmt|;
comment|/* 	 * Determine number of variable lenghts in header 	 * The standard 8 byte header has one for free and a 	 * 16 byte header would have 4 + 1; 	 */
if|if
condition|(
name|SA_HDR_SIZE
argument_list|(
name|sa_hdr_phys
argument_list|)
operator|>
literal|8
condition|)
name|num_lengths
operator|+=
operator|(
name|SA_HDR_SIZE
argument_list|(
name|sa_hdr_phys
argument_list|)
operator|-
literal|8
operator|)
operator|>>
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|num_lengths
condition|;
name|i
operator|++
control|)
name|sa_hdr_phys
operator|->
name|sa_lengths
index|[
name|i
index|]
operator|=
name|BSWAP_16
argument_list|(
name|sa_hdr_phys
operator|->
name|sa_lengths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sa_attr_iter
argument_list|(
name|hdl
operator|->
name|sa_os
argument_list|,
name|sa_hdr_phys
argument_list|,
name|DMU_OT_SA
argument_list|,
name|sa_byteswap_cb
argument_list|,
name|NULL
argument_list|,
name|hdl
argument_list|)
expr_stmt|;
if|if
condition|(
name|buftype
operator|==
name|SA_SPILL
condition|)
name|arc_buf_freeze
argument_list|(
operator|(
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|hdl
operator|->
name|sa_spill
operator|)
operator|->
name|db_buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sa_build_index
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|sa_buf_type_t
name|buftype
parameter_list|)
block|{
name|sa_hdr_phys_t
modifier|*
name|sa_hdr_phys
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|db
init|=
name|SA_GET_DB
argument_list|(
name|hdl
argument_list|,
name|buftype
argument_list|)
decl_stmt|;
name|dmu_object_type_t
name|bonustype
init|=
name|SA_BONUSTYPE_FROM_DB
argument_list|(
name|db
argument_list|)
decl_stmt|;
name|sa_os_t
modifier|*
name|sa
init|=
name|hdl
operator|->
name|sa_os
operator|->
name|os_sa
decl_stmt|;
name|sa_idx_tab_t
modifier|*
name|idx_tab
decl_stmt|;
name|sa_hdr_phys
operator|=
name|SA_GET_HDR
argument_list|(
name|hdl
argument_list|,
name|buftype
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|sa
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
comment|/* Do we need to byteswap? */
comment|/* only check if not old znode */
if|if
condition|(
name|IS_SA_BONUSTYPE
argument_list|(
name|bonustype
argument_list|)
operator|&&
name|sa_hdr_phys
operator|->
name|sa_magic
operator|!=
name|SA_MAGIC
operator|&&
name|sa_hdr_phys
operator|->
name|sa_magic
operator|!=
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|BSWAP_32
argument_list|(
name|sa_hdr_phys
operator|->
name|sa_magic
argument_list|)
operator|==
name|SA_MAGIC
argument_list|)
expr_stmt|;
name|sa_byteswap
argument_list|(
name|hdl
argument_list|,
name|buftype
argument_list|)
expr_stmt|;
block|}
name|idx_tab
operator|=
name|sa_find_idx_tab
argument_list|(
name|hdl
operator|->
name|sa_os
argument_list|,
name|bonustype
argument_list|,
name|sa_hdr_phys
argument_list|)
expr_stmt|;
if|if
condition|(
name|buftype
operator|==
name|SA_BONUS
condition|)
name|hdl
operator|->
name|sa_bonus_tab
operator|=
name|idx_tab
expr_stmt|;
else|else
name|hdl
operator|->
name|sa_spill_tab
operator|=
name|idx_tab
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|sa
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|sa_evict_sync
parameter_list|(
name|void
modifier|*
name|dbu
parameter_list|)
block|{
name|panic
argument_list|(
literal|"evicting sa dbuf\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sa_idx_tab_rele
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|sa_os_t
modifier|*
name|sa
init|=
name|os
operator|->
name|os_sa
decl_stmt|;
name|sa_idx_tab_t
modifier|*
name|idx_tab
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|idx_tab
operator|==
name|NULL
condition|)
return|return;
name|mutex_enter
argument_list|(
operator|&
name|sa
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|refcount_remove
argument_list|(
operator|&
name|idx_tab
operator|->
name|sa_refcount
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|idx_tab
operator|->
name|sa_layout
operator|->
name|lot_idx_tab
argument_list|,
name|idx_tab
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx_tab
operator|->
name|sa_variable_lengths
condition|)
name|kmem_free
argument_list|(
name|idx_tab
operator|->
name|sa_variable_lengths
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|*
name|idx_tab
operator|->
name|sa_layout
operator|->
name|lot_var_sizes
argument_list|)
expr_stmt|;
name|refcount_destroy
argument_list|(
operator|&
name|idx_tab
operator|->
name|sa_refcount
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|idx_tab
operator|->
name|sa_idx_tab
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|sa
operator|->
name|sa_num_attrs
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|idx_tab
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_idx_tab_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|sa
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sa_idx_tab_hold
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|sa_idx_tab_t
modifier|*
name|idx_tab
parameter_list|)
block|{
name|sa_os_t
modifier|*
name|sa
init|=
name|os
operator|->
name|os_sa
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|sa
operator|->
name|sa_lock
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refcount_add
argument_list|(
operator|&
name|idx_tab
operator|->
name|sa_refcount
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sa_handle_destroy
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
name|db
init|=
name|hdl
operator|->
name|sa_bonus
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_buf_remove_user
argument_list|(
name|db
argument_list|,
operator|&
name|hdl
operator|->
name|sa_dbu
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdl
operator|->
name|sa_bonus_tab
condition|)
name|sa_idx_tab_rele
argument_list|(
name|hdl
operator|->
name|sa_os
argument_list|,
name|hdl
operator|->
name|sa_bonus_tab
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdl
operator|->
name|sa_spill_tab
condition|)
name|sa_idx_tab_rele
argument_list|(
name|hdl
operator|->
name|sa_os
argument_list|,
name|hdl
operator|->
name|sa_spill_tab
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|hdl
operator|->
name|sa_bonus
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdl
operator|->
name|sa_spill
condition|)
name|dmu_buf_rele
argument_list|(
operator|(
name|dmu_buf_t
operator|*
operator|)
name|hdl
operator|->
name|sa_spill
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|sa_cache
argument_list|,
name|hdl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sa_handle_get_from_db
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|userp
parameter_list|,
name|sa_handle_type_t
name|hdl_type
parameter_list|,
name|sa_handle_t
modifier|*
modifier|*
name|handlepp
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|sa_handle_t
modifier|*
name|handle
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|ZFS_DEBUG
name|dmu_object_info_from_db
argument_list|(
name|db
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|doi
operator|.
name|doi_bonus_type
operator|==
name|DMU_OT_SA
operator|||
name|doi
operator|.
name|doi_bonus_type
operator|==
name|DMU_OT_ZNODE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* find handle, if it exists */
comment|/* if one doesn't exist then create a new one, and initialize it */
if|if
condition|(
name|hdl_type
operator|==
name|SA_HDL_SHARED
condition|)
name|handle
operator|=
name|dmu_buf_get_user
argument_list|(
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
block|{
name|sa_handle_t
modifier|*
name|winner
init|=
name|NULL
decl_stmt|;
name|handle
operator|=
name|kmem_cache_alloc
argument_list|(
name|sa_cache
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|handle
operator|->
name|sa_dbu
operator|.
name|dbu_evict_func_sync
operator|=
name|NULL
expr_stmt|;
name|handle
operator|->
name|sa_dbu
operator|.
name|dbu_evict_func_async
operator|=
name|NULL
expr_stmt|;
name|handle
operator|->
name|sa_userp
operator|=
name|userp
expr_stmt|;
name|handle
operator|->
name|sa_bonus
operator|=
name|db
expr_stmt|;
name|handle
operator|->
name|sa_os
operator|=
name|os
expr_stmt|;
name|handle
operator|->
name|sa_spill
operator|=
name|NULL
expr_stmt|;
name|handle
operator|->
name|sa_bonus_tab
operator|=
name|NULL
expr_stmt|;
name|handle
operator|->
name|sa_spill_tab
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|sa_build_index
argument_list|(
name|handle
argument_list|,
name|SA_BONUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdl_type
operator|==
name|SA_HDL_SHARED
condition|)
block|{
name|dmu_buf_init_user
argument_list|(
operator|&
name|handle
operator|->
name|sa_dbu
argument_list|,
name|sa_evict_sync
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|winner
operator|=
name|dmu_buf_set_user_ie
argument_list|(
name|db
argument_list|,
operator|&
name|handle
operator|->
name|sa_dbu
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|winner
operator|!=
name|NULL
condition|)
block|{
name|kmem_cache_free
argument_list|(
name|sa_cache
argument_list|,
name|handle
argument_list|)
expr_stmt|;
name|handle
operator|=
name|winner
expr_stmt|;
block|}
block|}
operator|*
name|handlepp
operator|=
name|handle
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sa_handle_get
parameter_list|(
name|objset_t
modifier|*
name|objset
parameter_list|,
name|uint64_t
name|objid
parameter_list|,
name|void
modifier|*
name|userp
parameter_list|,
name|sa_handle_type_t
name|hdl_type
parameter_list|,
name|sa_handle_t
modifier|*
modifier|*
name|handlepp
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|dmu_bonus_hold
argument_list|(
name|objset
argument_list|,
name|objid
argument_list|,
name|NULL
argument_list|,
operator|&
name|db
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|sa_handle_get_from_db
argument_list|(
name|objset
argument_list|,
name|db
argument_list|,
name|userp
argument_list|,
name|hdl_type
argument_list|,
name|handlepp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sa_buf_hold
parameter_list|(
name|objset_t
modifier|*
name|objset
parameter_list|,
name|uint64_t
name|obj_num
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
name|db
parameter_list|)
block|{
return|return
operator|(
name|dmu_bonus_hold
argument_list|(
name|objset
argument_list|,
name|obj_num
argument_list|,
name|tag
argument_list|,
name|db
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sa_buf_rele
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sa_lookup_impl
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|sa_bulk_attr_t
modifier|*
name|bulk
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|sa_attr_op
argument_list|(
name|hdl
argument_list|,
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_LOOKUP
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sa_lookup
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|sa_attr_type_t
name|attr
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|uint32_t
name|buflen
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|sa_bulk_attr_t
name|bulk
decl_stmt|;
name|bulk
operator|.
name|sa_attr
operator|=
name|attr
expr_stmt|;
name|bulk
operator|.
name|sa_data
operator|=
name|buf
expr_stmt|;
name|bulk
operator|.
name|sa_length
operator|=
name|buflen
expr_stmt|;
name|bulk
operator|.
name|sa_data_func
operator|=
name|NULL
expr_stmt|;
name|ASSERT
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|sa_lookup_impl
argument_list|(
name|hdl
argument_list|,
operator|&
name|bulk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_function
name|int
name|sa_lookup_uio
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|sa_attr_type_t
name|attr
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|sa_bulk_attr_t
name|bulk
decl_stmt|;
name|bulk
operator|.
name|sa_data
operator|=
name|NULL
expr_stmt|;
name|bulk
operator|.
name|sa_attr
operator|=
name|attr
expr_stmt|;
name|bulk
operator|.
name|sa_data_func
operator|=
name|NULL
expr_stmt|;
name|ASSERT
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sa_attr_op
argument_list|(
name|hdl
argument_list|,
operator|&
name|bulk
argument_list|,
literal|1
argument_list|,
name|SA_LOOKUP
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|void
operator|*
operator|)
name|bulk
operator|.
name|sa_addr
argument_list|,
name|MIN
argument_list|(
name|bulk
operator|.
name|sa_size
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
modifier|*
name|sa_find_idx_tab
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|dmu_object_type_t
name|bonustype
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|sa_idx_tab_t
modifier|*
name|idx_tab
decl_stmt|;
name|sa_hdr_phys_t
modifier|*
name|hdr
init|=
operator|(
name|sa_hdr_phys_t
operator|*
operator|)
name|data
decl_stmt|;
name|sa_os_t
modifier|*
name|sa
init|=
name|os
operator|->
name|os_sa
decl_stmt|;
name|sa_lot_t
modifier|*
name|tb
decl_stmt|,
name|search
decl_stmt|;
name|avl_index_t
name|loc
decl_stmt|;
comment|/* 	 * Deterimine layout number.  If SA node and header == 0 then 	 * force the index table to the dummy "1" empty layout. 	 * 	 * The layout number would only be zero for a newly created file 	 * that has not added any attributes yet, or with crypto enabled which 	 * doesn't write any attributes to the bonus buffer. 	 */
name|search
operator|.
name|lot_num
operator|=
name|SA_LAYOUT_NUM
argument_list|(
name|hdr
argument_list|,
name|bonustype
argument_list|)
expr_stmt|;
name|tb
operator|=
name|avl_find
argument_list|(
operator|&
name|sa
operator|->
name|sa_layout_num_tree
argument_list|,
operator|&
name|search
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
comment|/* Verify header size is consistent with layout information */
name|ASSERT
argument_list|(
name|tb
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|IS_SA_BONUSTYPE
argument_list|(
name|bonustype
argument_list|)
operator|&&
name|SA_HDR_SIZE_MATCH_LAYOUT
argument_list|(
name|hdr
argument_list|,
name|tb
argument_list|)
operator|||
operator|!
name|IS_SA_BONUSTYPE
argument_list|(
name|bonustype
argument_list|)
operator|||
operator|(
name|IS_SA_BONUSTYPE
argument_list|(
name|bonustype
argument_list|)
operator|&&
name|hdr
operator|->
name|sa_layout_info
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * See if any of the already existing TOC entries can be reused? 	 */
for|for
control|(
name|idx_tab
operator|=
name|list_head
argument_list|(
operator|&
name|tb
operator|->
name|lot_idx_tab
argument_list|)
init|;
name|idx_tab
condition|;
name|idx_tab
operator|=
name|list_next
argument_list|(
operator|&
name|tb
operator|->
name|lot_idx_tab
argument_list|,
name|idx_tab
argument_list|)
control|)
block|{
name|boolean_t
name|valid_idx
init|=
name|B_TRUE
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|tb
operator|->
name|lot_var_sizes
operator|!=
literal|0
operator|&&
name|idx_tab
operator|->
name|sa_variable_lengths
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|tb
operator|->
name|lot_var_sizes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hdr
operator|->
name|sa_lengths
index|[
name|i
index|]
operator|!=
name|idx_tab
operator|->
name|sa_variable_lengths
index|[
name|i
index|]
condition|)
block|{
name|valid_idx
operator|=
name|B_FALSE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|valid_idx
condition|)
block|{
name|sa_idx_tab_hold
argument_list|(
name|os
argument_list|,
name|idx_tab
argument_list|)
expr_stmt|;
return|return
operator|(
name|idx_tab
operator|)
return|;
block|}
block|}
comment|/* No such luck, create a new entry */
name|idx_tab
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sa_idx_tab_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|idx_tab
operator|->
name|sa_idx_tab
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
name|sa
operator|->
name|sa_num_attrs
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|idx_tab
operator|->
name|sa_layout
operator|=
name|tb
expr_stmt|;
name|refcount_create
argument_list|(
operator|&
name|idx_tab
operator|->
name|sa_refcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
operator|->
name|lot_var_sizes
condition|)
name|idx_tab
operator|->
name|sa_variable_lengths
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|*
name|tb
operator|->
name|lot_var_sizes
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|sa_attr_iter
argument_list|(
name|os
argument_list|,
name|hdr
argument_list|,
name|bonustype
argument_list|,
name|sa_build_idx_tab
argument_list|,
name|tb
argument_list|,
name|idx_tab
argument_list|)
expr_stmt|;
name|sa_idx_tab_hold
argument_list|(
name|os
argument_list|,
name|idx_tab
argument_list|)
expr_stmt|;
comment|/* one hold for consumer */
name|sa_idx_tab_hold
argument_list|(
name|os
argument_list|,
name|idx_tab
argument_list|)
expr_stmt|;
comment|/* one for layout */
name|list_insert_tail
argument_list|(
operator|&
name|tb
operator|->
name|lot_idx_tab
argument_list|,
name|idx_tab
argument_list|)
expr_stmt|;
return|return
operator|(
name|idx_tab
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sa_default_locator
parameter_list|(
name|void
modifier|*
modifier|*
name|dataptr
parameter_list|,
name|uint32_t
modifier|*
name|len
parameter_list|,
name|uint32_t
name|total_len
parameter_list|,
name|boolean_t
name|start
parameter_list|,
name|void
modifier|*
name|userdata
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|start
argument_list|)
expr_stmt|;
operator|*
name|dataptr
operator|=
name|userdata
expr_stmt|;
operator|*
name|len
operator|=
name|total_len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sa_attr_register_sync
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|uint64_t
name|attr_value
init|=
literal|0
decl_stmt|;
name|sa_os_t
modifier|*
name|sa
init|=
name|hdl
operator|->
name|sa_os
operator|->
name|os_sa
decl_stmt|;
name|sa_attr_table_t
modifier|*
name|tb
init|=
name|sa
operator|->
name|sa_attr_table
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|sa
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sa
operator|->
name|sa_need_attr_registration
operator|||
name|sa
operator|->
name|sa_master_obj
operator|==
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|sa
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sa
operator|->
name|sa_reg_attr_obj
operator|==
literal|0
condition|)
block|{
name|sa
operator|->
name|sa_reg_attr_obj
operator|=
name|zap_create_link
argument_list|(
name|hdl
operator|->
name|sa_os
argument_list|,
name|DMU_OT_SA_ATTR_REGISTRATION
argument_list|,
name|sa
operator|->
name|sa_master_obj
argument_list|,
name|SA_REGISTRY
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|sa
operator|->
name|sa_num_attrs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sa
operator|->
name|sa_attr_table
index|[
name|i
index|]
operator|.
name|sa_registered
condition|)
continue|continue;
name|ATTR_ENCODE
argument_list|(
name|attr_value
argument_list|,
name|tb
index|[
name|i
index|]
operator|.
name|sa_attr
argument_list|,
name|tb
index|[
name|i
index|]
operator|.
name|sa_length
argument_list|,
name|tb
index|[
name|i
index|]
operator|.
name|sa_byteswap
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_update
argument_list|(
name|hdl
operator|->
name|sa_os
argument_list|,
name|sa
operator|->
name|sa_reg_attr_obj
argument_list|,
name|tb
index|[
name|i
index|]
operator|.
name|sa_name
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|attr_value
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|tb
index|[
name|i
index|]
operator|.
name|sa_registered
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|sa
operator|->
name|sa_need_attr_registration
operator|=
name|B_FALSE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|sa
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Replace all attributes with attributes specified in template.  * If dnode had a spill buffer then those attributes will be  * also be replaced, possibly with just an empty spill block  *  * This interface is intended to only be used for bulk adding of  * attributes for a new file.  It will also be used by the ZPL  * when converting and old formatted znode to native SA support.  */
end_comment

begin_function
name|int
name|sa_replace_all_by_template_locked
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|sa_bulk_attr_t
modifier|*
name|attr_desc
parameter_list|,
name|int
name|attr_count
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|sa_os_t
modifier|*
name|sa
init|=
name|hdl
operator|->
name|sa_os
operator|->
name|os_sa
decl_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_need_attr_registration
condition|)
name|sa_attr_register_sync
argument_list|(
name|hdl
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|sa_build_layouts
argument_list|(
name|hdl
argument_list|,
name|attr_desc
argument_list|,
name|attr_count
argument_list|,
name|tx
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sa_replace_all_by_template
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|sa_bulk_attr_t
modifier|*
name|attr_desc
parameter_list|,
name|int
name|attr_count
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|sa_replace_all_by_template_locked
argument_list|(
name|hdl
argument_list|,
name|attr_desc
argument_list|,
name|attr_count
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add/remove a single attribute or replace a variable-sized attribute value  * with a value of a different size, and then rewrite the entire set  * of attributes.  * Same-length attribute value replacement (including fixed-length attributes)  * is handled more efficiently by the upper layers.  */
end_comment

begin_function
specifier|static
name|int
name|sa_modify_attrs
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|sa_attr_type_t
name|newattr
parameter_list|,
name|sa_data_op_t
name|action
parameter_list|,
name|sa_data_locator_t
modifier|*
name|locator
parameter_list|,
name|void
modifier|*
name|datastart
parameter_list|,
name|uint16_t
name|buflen
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|sa_os_t
modifier|*
name|sa
init|=
name|hdl
operator|->
name|sa_os
operator|->
name|os_sa
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|db
init|=
operator|(
name|dmu_buf_impl_t
operator|*
operator|)
name|hdl
operator|->
name|sa_bonus
decl_stmt|;
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|sa_bulk_attr_t
modifier|*
name|attr_desc
decl_stmt|;
name|void
modifier|*
name|old_data
index|[
literal|2
index|]
decl_stmt|;
name|int
name|bonus_attr_count
init|=
literal|0
decl_stmt|;
name|int
name|bonus_data_size
init|=
literal|0
decl_stmt|;
name|int
name|spill_data_size
init|=
literal|0
decl_stmt|;
name|int
name|spill_attr_count
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint16_t
name|length
decl_stmt|,
name|reg_length
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|length_idx
decl_stmt|;
name|sa_hdr_phys_t
modifier|*
name|hdr
decl_stmt|;
name|sa_idx_tab_t
modifier|*
name|idx_tab
decl_stmt|;
name|int
name|attr_count
decl_stmt|;
name|int
name|count
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First make of copy of the old data */
name|DB_DNODE_ENTER
argument_list|(
name|db
argument_list|)
expr_stmt|;
name|dn
operator|=
name|DB_DNODE
argument_list|(
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_bonuslen
operator|!=
literal|0
condition|)
block|{
name|bonus_data_size
operator|=
name|hdl
operator|->
name|sa_bonus
operator|->
name|db_size
expr_stmt|;
name|old_data
index|[
literal|0
index|]
operator|=
name|kmem_alloc
argument_list|(
name|bonus_data_size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hdl
operator|->
name|sa_bonus
operator|->
name|db_data
argument_list|,
name|old_data
index|[
literal|0
index|]
argument_list|,
name|hdl
operator|->
name|sa_bonus
operator|->
name|db_size
argument_list|)
expr_stmt|;
name|bonus_attr_count
operator|=
name|hdl
operator|->
name|sa_bonus_tab
operator|->
name|sa_layout
operator|->
name|lot_attr_count
expr_stmt|;
block|}
else|else
block|{
name|old_data
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|DB_DNODE_EXIT
argument_list|(
name|db
argument_list|)
expr_stmt|;
comment|/* Bring spill buffer online if it isn't currently */
if|if
condition|(
operator|(
name|error
operator|=
name|sa_get_spill
argument_list|(
name|hdl
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|spill_data_size
operator|=
name|hdl
operator|->
name|sa_spill
operator|->
name|db_size
expr_stmt|;
name|old_data
index|[
literal|1
index|]
operator|=
name|kmem_alloc
argument_list|(
name|spill_data_size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|hdl
operator|->
name|sa_spill
operator|->
name|db_data
argument_list|,
name|old_data
index|[
literal|1
index|]
argument_list|,
name|hdl
operator|->
name|sa_spill
operator|->
name|db_size
argument_list|)
expr_stmt|;
name|spill_attr_count
operator|=
name|hdl
operator|->
name|sa_spill_tab
operator|->
name|sa_layout
operator|->
name|lot_attr_count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
block|{
if|if
condition|(
name|old_data
index|[
literal|0
index|]
condition|)
name|kmem_free
argument_list|(
name|old_data
index|[
literal|0
index|]
argument_list|,
name|bonus_data_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
name|old_data
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* build descriptor of all attributes */
name|attr_count
operator|=
name|bonus_attr_count
operator|+
name|spill_attr_count
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|SA_ADD
condition|)
name|attr_count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|action
operator|==
name|SA_REMOVE
condition|)
name|attr_count
operator|--
expr_stmt|;
name|attr_desc
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sa_bulk_attr_t
argument_list|)
operator|*
name|attr_count
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * loop through bonus and spill buffer if it exists, and 	 * build up new attr_descriptor to reset the attributes 	 */
name|k
operator|=
name|j
operator|=
literal|0
expr_stmt|;
name|count
operator|=
name|bonus_attr_count
expr_stmt|;
name|hdr
operator|=
name|SA_GET_HDR
argument_list|(
name|hdl
argument_list|,
name|SA_BONUS
argument_list|)
expr_stmt|;
name|idx_tab
operator|=
name|SA_IDX_TAB_GET
argument_list|(
name|hdl
argument_list|,
name|SA_BONUS
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|k
operator|!=
literal|2
condition|;
name|k
operator|++
control|)
block|{
comment|/* 		 * Iterate over each attribute in layout.  Fetch the 		 * size of variable-length attributes needing rewrite 		 * from sa_lengths[]. 		 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|length_idx
operator|=
literal|0
init|;
name|i
operator|!=
name|count
condition|;
name|i
operator|++
control|)
block|{
name|sa_attr_type_t
name|attr
decl_stmt|;
name|attr
operator|=
name|idx_tab
operator|->
name|sa_layout
operator|->
name|lot_attrs
index|[
name|i
index|]
expr_stmt|;
name|reg_length
operator|=
name|SA_REGISTERED_LEN
argument_list|(
name|sa
argument_list|,
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_length
operator|==
literal|0
condition|)
block|{
name|length
operator|=
name|hdr
operator|->
name|sa_lengths
index|[
name|length_idx
index|]
expr_stmt|;
name|length_idx
operator|++
expr_stmt|;
block|}
else|else
block|{
name|length
operator|=
name|reg_length
expr_stmt|;
block|}
if|if
condition|(
name|attr
operator|==
name|newattr
condition|)
block|{
comment|/* 				 * There is nothing to do for SA_REMOVE, 				 * so it is just skipped. 				 */
if|if
condition|(
name|action
operator|==
name|SA_REMOVE
condition|)
continue|continue;
comment|/* 				 * Duplicate attributes are not allowed, so the 				 * action can not be SA_ADD here. 				 */
name|ASSERT3S
argument_list|(
name|action
argument_list|,
operator|==
argument_list|,
name|SA_REPLACE
argument_list|)
expr_stmt|;
comment|/* 				 * Only a variable-sized attribute can be 				 * replaced here, and its size must be changing. 				 */
name|ASSERT3U
argument_list|(
name|reg_length
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|length
argument_list|,
operator|!=
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|attr_desc
argument_list|,
name|j
argument_list|,
name|attr
argument_list|,
name|locator
argument_list|,
name|datastart
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SA_ADD_BULK_ATTR
argument_list|(
name|attr_desc
argument_list|,
name|j
argument_list|,
name|attr
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|TOC_OFF
argument_list|(
name|idx_tab
operator|->
name|sa_idx_tab
index|[
name|attr
index|]
argument_list|)
operator|+
operator|(
name|uintptr_t
operator|)
name|old_data
index|[
name|k
index|]
operator|)
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|k
operator|==
literal|0
operator|&&
name|hdl
operator|->
name|sa_spill
condition|)
block|{
name|hdr
operator|=
name|SA_GET_HDR
argument_list|(
name|hdl
argument_list|,
name|SA_SPILL
argument_list|)
expr_stmt|;
name|idx_tab
operator|=
name|SA_IDX_TAB_GET
argument_list|(
name|hdl
argument_list|,
name|SA_SPILL
argument_list|)
expr_stmt|;
name|count
operator|=
name|spill_attr_count
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
if|if
condition|(
name|action
operator|==
name|SA_ADD
condition|)
block|{
name|reg_length
operator|=
name|SA_REGISTERED_LEN
argument_list|(
name|sa
argument_list|,
name|newattr
argument_list|)
expr_stmt|;
name|IMPLY
argument_list|(
name|reg_length
operator|!=
literal|0
argument_list|,
name|reg_length
operator|==
name|buflen
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|attr_desc
argument_list|,
name|j
argument_list|,
name|newattr
argument_list|,
name|locator
argument_list|,
name|datastart
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|j
argument_list|,
operator|==
argument_list|,
name|attr_count
argument_list|)
expr_stmt|;
name|error
operator|=
name|sa_build_layouts
argument_list|(
name|hdl
argument_list|,
name|attr_desc
argument_list|,
name|attr_count
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_data
index|[
literal|0
index|]
condition|)
name|kmem_free
argument_list|(
name|old_data
index|[
literal|0
index|]
argument_list|,
name|bonus_data_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_data
index|[
literal|1
index|]
condition|)
name|kmem_free
argument_list|(
name|old_data
index|[
literal|1
index|]
argument_list|,
name|spill_data_size
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|attr_desc
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_bulk_attr_t
argument_list|)
operator|*
name|attr_count
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sa_bulk_update_impl
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|sa_bulk_attr_t
modifier|*
name|bulk
parameter_list|,
name|int
name|count
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|sa_os_t
modifier|*
name|sa
init|=
name|hdl
operator|->
name|sa_os
operator|->
name|os_sa
decl_stmt|;
name|dmu_object_type_t
name|bonustype
decl_stmt|;
name|bonustype
operator|=
name|SA_BONUSTYPE_FROM_DB
argument_list|(
name|SA_GET_DB
argument_list|(
name|hdl
argument_list|,
name|SA_BONUS
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* sync out registration table if necessary */
if|if
condition|(
name|sa
operator|->
name|sa_need_attr_registration
condition|)
name|sa_attr_register_sync
argument_list|(
name|hdl
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|error
operator|=
name|sa_attr_op
argument_list|(
name|hdl
argument_list|,
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_UPDATE
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|!
name|IS_SA_BONUSTYPE
argument_list|(
name|bonustype
argument_list|)
operator|&&
name|sa
operator|->
name|sa_update_cb
condition|)
name|sa
operator|->
name|sa_update_cb
argument_list|(
name|hdl
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * update or add new attribute  */
end_comment

begin_function
name|int
name|sa_update
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|sa_attr_type_t
name|type
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|uint32_t
name|buflen
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|sa_bulk_attr_t
name|bulk
decl_stmt|;
name|bulk
operator|.
name|sa_attr
operator|=
name|type
expr_stmt|;
name|bulk
operator|.
name|sa_data_func
operator|=
name|NULL
expr_stmt|;
name|bulk
operator|.
name|sa_length
operator|=
name|buflen
expr_stmt|;
name|bulk
operator|.
name|sa_data
operator|=
name|buf
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|sa_bulk_update_impl
argument_list|(
name|hdl
argument_list|,
operator|&
name|bulk
argument_list|,
literal|1
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sa_update_from_cb
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|sa_attr_type_t
name|attr
parameter_list|,
name|uint32_t
name|buflen
parameter_list|,
name|sa_data_locator_t
modifier|*
name|locator
parameter_list|,
name|void
modifier|*
name|userdata
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|sa_bulk_attr_t
name|bulk
decl_stmt|;
name|bulk
operator|.
name|sa_attr
operator|=
name|attr
expr_stmt|;
name|bulk
operator|.
name|sa_data
operator|=
name|userdata
expr_stmt|;
name|bulk
operator|.
name|sa_data_func
operator|=
name|locator
expr_stmt|;
name|bulk
operator|.
name|sa_length
operator|=
name|buflen
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|sa_bulk_update_impl
argument_list|(
name|hdl
argument_list|,
operator|&
name|bulk
argument_list|,
literal|1
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return size of an attribute  */
end_comment

begin_function
name|int
name|sa_size
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|sa_attr_type_t
name|attr
parameter_list|,
name|int
modifier|*
name|size
parameter_list|)
block|{
name|sa_bulk_attr_t
name|bulk
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bulk
operator|.
name|sa_data
operator|=
name|NULL
expr_stmt|;
name|bulk
operator|.
name|sa_attr
operator|=
name|attr
expr_stmt|;
name|bulk
operator|.
name|sa_data_func
operator|=
name|NULL
expr_stmt|;
name|ASSERT
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sa_attr_op
argument_list|(
name|hdl
argument_list|,
operator|&
name|bulk
argument_list|,
literal|1
argument_list|,
name|SA_LOOKUP
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|size
operator|=
name|bulk
operator|.
name|sa_size
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sa_bulk_lookup_locked
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|sa_bulk_attr_t
modifier|*
name|attrs
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|sa_lookup_impl
argument_list|(
name|hdl
argument_list|,
name|attrs
argument_list|,
name|count
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sa_bulk_lookup
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|sa_bulk_attr_t
modifier|*
name|attrs
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|sa_bulk_lookup_locked
argument_list|(
name|hdl
argument_list|,
name|attrs
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sa_bulk_update
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|sa_bulk_attr_t
modifier|*
name|attrs
parameter_list|,
name|int
name|count
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|sa_bulk_update_impl
argument_list|(
name|hdl
argument_list|,
name|attrs
argument_list|,
name|count
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sa_remove
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|sa_attr_type_t
name|attr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|sa_modify_attrs
argument_list|(
name|hdl
argument_list|,
name|attr
argument_list|,
name|SA_REMOVE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sa_object_info
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|dmu_object_info_t
modifier|*
name|doi
parameter_list|)
block|{
name|dmu_object_info_from_db
argument_list|(
operator|(
name|dmu_buf_t
operator|*
operator|)
name|hdl
operator|->
name|sa_bonus
argument_list|,
name|doi
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sa_object_size
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|uint32_t
modifier|*
name|blksize
parameter_list|,
name|u_longlong_t
modifier|*
name|nblocks
parameter_list|)
block|{
name|dmu_object_size_from_db
argument_list|(
operator|(
name|dmu_buf_t
operator|*
operator|)
name|hdl
operator|->
name|sa_bonus
argument_list|,
name|blksize
argument_list|,
name|nblocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sa_set_userp
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|hdl
operator|->
name|sa_userp
operator|=
name|ptr
expr_stmt|;
block|}
end_function

begin_function
name|dmu_buf_t
modifier|*
name|sa_get_db
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|)
block|{
return|return
operator|(
operator|(
name|dmu_buf_t
operator|*
operator|)
name|hdl
operator|->
name|sa_bonus
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|sa_get_userdata
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|)
block|{
return|return
operator|(
name|hdl
operator|->
name|sa_userp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sa_register_update_callback_locked
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|sa_update_cb_t
modifier|*
name|func
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|os
operator|->
name|os_sa
operator|->
name|sa_lock
argument_list|)
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_sa
operator|->
name|sa_update_cb
operator|=
name|func
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sa_register_update_callback
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|sa_update_cb_t
modifier|*
name|func
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|os
operator|->
name|os_sa
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
name|sa_register_update_callback_locked
argument_list|(
name|os
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_sa
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|sa_handle_object
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|)
block|{
return|return
operator|(
name|hdl
operator|->
name|sa_bonus
operator|->
name|db_object
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|sa_enabled
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
return|return
operator|(
name|os
operator|->
name|os_sa
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sa_set_sa_object
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|sa_object
parameter_list|)
block|{
name|sa_os_t
modifier|*
name|sa
init|=
name|os
operator|->
name|os_sa
decl_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_master_obj
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|sa
operator|->
name|sa_master_obj
operator|=
name|sa_object
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sa_hdrsize
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|sa_hdr_phys_t
modifier|*
name|hdr
init|=
name|arg
decl_stmt|;
return|return
operator|(
name|SA_HDR_SIZE
argument_list|(
name|hdr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sa_handle_lock
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sa_handle_unlock
parameter_list|(
name|sa_handle_t
modifier|*
name|hdl
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|hdl
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|hdl
operator|->
name|sa_lock
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

