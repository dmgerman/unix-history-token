begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2012, 2016 by Delphix. All rights reserved.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_ZAP_H
end_ifndef

begin_define
define|#
directive|define
name|_SYS_ZAP_H
end_define

begin_comment
comment|/*  * ZAP - ZFS Attribute Processor  *  * The ZAP is a module which sits on top of the DMU (Data Management  * Unit) and implements a higher-level storage primitive using DMU  * objects.  Its primary consumer is the ZPL (ZFS Posix Layer).  *  * A "zapobj" is a DMU object which the ZAP uses to stores attributes.  * Users should use only zap routines to access a zapobj - they should  * not access the DMU object directly using DMU routines.  *  * The attributes stored in a zapobj are name-value pairs.  The name is  * a zero-terminated string of up to ZAP_MAXNAMELEN bytes (including  * terminating NULL).  The value is an array of integers, which may be  * 1, 2, 4, or 8 bytes long.  The total space used by the array (number  * of integers * integer length) can be up to ZAP_MAXVALUELEN bytes.  * Note that an 8-byte integer value can be used to store the location  * (object number) of another dmu object (which may be itself a zapobj).  * Note that you can use a zero-length attribute to store a single bit  * of information - the attribute is present or not.  *  * The ZAP routines are thread-safe.  However, you must observe the  * DMU's restriction that a transaction may not be operated on  * concurrently.  *  * Any of the routines that return an int may return an I/O error (EIO  * or ECHECKSUM).  *  *  * Implementation / Performance Notes:  *  * The ZAP is intended to operate most efficiently on attributes with  * short (49 bytes or less) names and single 8-byte values, for which  * the microzap will be used.  The ZAP should be efficient enough so  * that the user does not need to cache these attributes.  *  * The ZAP's locking scheme makes its routines thread-safe.  Operations  * on different zapobjs will be processed concurrently.  Operations on  * the same zapobj which only read data will be processed concurrently.  * Operations on the same zapobj which modify data will be processed  * concurrently when there are many attributes in the zapobj (because  * the ZAP uses per-block locking - more than 128 * (number of cpus)  * small attributes will suffice).  */
end_comment

begin_comment
comment|/*  * We're using zero-terminated byte strings (ie. ASCII or UTF-8 C  * strings) for the names of attributes, rather than a byte string  * bounded by an explicit length.  If some day we want to support names  * in character sets which have embedded zeros (eg. UTF-16, UTF-32),  * we'll have to add routines for using length-bounded strings.  */
end_comment

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/*  * Specifies matching criteria for ZAP lookups.  */
typedef|typedef
enum|enum
name|matchtype
block|{
comment|/* Only find an exact match (non-normalized) */
name|MT_EXACT
block|,
comment|/* 	 * If there is an exact match, find that, otherwise find the 	 * first normalized match. 	 */
name|MT_BEST
block|,
comment|/* 	 * Find the "first" normalized (case and Unicode form) match; 	 * the designated "first" match will not change as long as the 	 * set of entries with this normalization doesn't change. 	 */
name|MT_FIRST
block|}
name|matchtype_t
typedef|;
typedef|typedef
enum|enum
name|zap_flags
block|{
comment|/* Use 64-bit hash value (serialized cursors will always use 64-bits) */
name|ZAP_FLAG_HASH64
init|=
literal|1
operator|<<
literal|0
block|,
comment|/* Key is binary, not string (zap_add_uint64() can be used) */
name|ZAP_FLAG_UINT64_KEY
init|=
literal|1
operator|<<
literal|1
block|,
comment|/* 	 * First word of key (which must be an array of uint64) is 	 * already randomly distributed. 	 */
name|ZAP_FLAG_PRE_HASHED_KEY
init|=
literal|1
operator|<<
literal|2
block|, }
name|zap_flags_t
typedef|;
comment|/*  * Create a new zapobj with no attributes and return its object number.  * MT_EXACT will cause the zap object to only support MT_EXACT lookups,  * otherwise any matchtype can be used for lookups.  *  * normflags specifies what normalization will be done.  values are:  * 0: no normalization (legacy on-disk format, supports MT_EXACT matching  *     only)  * U8_TEXTPREP_TOLOWER: case normalization will be performed.  *     MT_FIRST/MT_BEST matching will find entries that match without  *     regard to case (eg. looking for "foo" can find an entry "Foo").  * Eventually, other flags will permit unicode normalization as well.  */
name|uint64_t
name|zap_create
parameter_list|(
name|objset_t
modifier|*
name|ds
parameter_list|,
name|dmu_object_type_t
name|ot
parameter_list|,
name|dmu_object_type_t
name|bonustype
parameter_list|,
name|int
name|bonuslen
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|uint64_t
name|zap_create_norm
parameter_list|(
name|objset_t
modifier|*
name|ds
parameter_list|,
name|int
name|normflags
parameter_list|,
name|dmu_object_type_t
name|ot
parameter_list|,
name|dmu_object_type_t
name|bonustype
parameter_list|,
name|int
name|bonuslen
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|uint64_t
name|zap_create_flags
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|int
name|normflags
parameter_list|,
name|zap_flags_t
name|flags
parameter_list|,
name|dmu_object_type_t
name|ot
parameter_list|,
name|int
name|leaf_blockshift
parameter_list|,
name|int
name|indirect_blockshift
parameter_list|,
name|dmu_object_type_t
name|bonustype
parameter_list|,
name|int
name|bonuslen
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|uint64_t
name|zap_create_link
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|dmu_object_type_t
name|ot
parameter_list|,
name|uint64_t
name|parent_obj
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/*  * Initialize an already-allocated object.  */
name|void
name|mzap_create_impl
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|int
name|normflags
parameter_list|,
name|zap_flags_t
name|flags
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/*  * Create a new zapobj with no attributes from the given (unallocated)  * object number.  */
name|int
name|zap_create_claim
parameter_list|(
name|objset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|dmu_object_type_t
name|ot
parameter_list|,
name|dmu_object_type_t
name|bonustype
parameter_list|,
name|int
name|bonuslen
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|zap_create_claim_norm
parameter_list|(
name|objset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|int
name|normflags
parameter_list|,
name|dmu_object_type_t
name|ot
parameter_list|,
name|dmu_object_type_t
name|bonustype
parameter_list|,
name|int
name|bonuslen
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/*  * The zapobj passed in must be a valid ZAP object for all of the  * following routines.  */
comment|/*  * Destroy this zapobj and all its attributes.  *  * Frees the object number using dmu_object_free.  */
name|int
name|zap_destroy
parameter_list|(
name|objset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/*  * Manipulate attributes.  *  * 'integer_size' is in bytes, and must be 1, 2, 4, or 8.  */
comment|/*  * Retrieve the contents of the attribute with the given name.  *  * If the requested attribute does not exist, the call will fail and  * return ENOENT.  *  * If 'integer_size' is smaller than the attribute's integer size, the  * call will fail and return EINVAL.  *  * If 'integer_size' is equal to or larger than the attribute's integer  * size, the call will succeed and return 0.  *  * When converting to a larger integer size, the integers will be treated as  * unsigned (ie. no sign-extension will be performed).  *  * 'num_integers' is the length (in integers) of 'buf'.  *  * If the attribute is longer than the buffer, as many integers as will  * fit will be transferred to 'buf'.  If the entire attribute was not  * transferred, the call will return EOVERFLOW.  */
name|int
name|zap_lookup
parameter_list|(
name|objset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
function_decl|;
comment|/*  * If rn_len is nonzero, realname will be set to the name of the found  * entry (which may be different from the requested name if matchtype is  * not MT_EXACT).  *  * If normalization_conflictp is not NULL, it will be set if there is  * another name with the same case/unicode normalized form.  */
name|int
name|zap_lookup_norm
parameter_list|(
name|objset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|matchtype_t
name|mt
parameter_list|,
name|char
modifier|*
name|realname
parameter_list|,
name|int
name|rn_len
parameter_list|,
name|boolean_t
modifier|*
name|normalization_conflictp
parameter_list|)
function_decl|;
name|int
name|zap_lookup_uint64
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
specifier|const
name|uint64_t
modifier|*
name|key
parameter_list|,
name|int
name|key_numints
parameter_list|,
name|uint64_t
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
function_decl|;
name|int
name|zap_contains
parameter_list|(
name|objset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
name|int
name|zap_prefetch_uint64
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
specifier|const
name|uint64_t
modifier|*
name|key
parameter_list|,
name|int
name|key_numints
parameter_list|)
function_decl|;
name|int
name|zap_lookup_by_dnode
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
function_decl|;
name|int
name|zap_lookup_norm_by_dnode
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|matchtype_t
name|mt
parameter_list|,
name|char
modifier|*
name|realname
parameter_list|,
name|int
name|rn_len
parameter_list|,
name|boolean_t
modifier|*
name|ncp
parameter_list|)
function_decl|;
name|int
name|zap_count_write_by_dnode
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|add
parameter_list|,
name|refcount_t
modifier|*
name|towrite
parameter_list|,
name|refcount_t
modifier|*
name|tooverwrite
parameter_list|)
function_decl|;
comment|/*  * Create an attribute with the given name and value.  *  * If an attribute with the given name already exists, the call will  * fail and return EEXIST.  */
name|int
name|zap_add
parameter_list|(
name|objset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|int
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|,
specifier|const
name|void
modifier|*
name|val
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|zap_add_uint64
parameter_list|(
name|objset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
specifier|const
name|uint64_t
modifier|*
name|key
parameter_list|,
name|int
name|key_numints
parameter_list|,
name|int
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|,
specifier|const
name|void
modifier|*
name|val
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/*  * Set the attribute with the given name to the given value.  If an  * attribute with the given name does not exist, it will be created.  If  * an attribute with the given name already exists, the previous value  * will be overwritten.  The integer_size may be different from the  * existing attribute's integer size, in which case the attribute's  * integer size will be updated to the new value.  */
name|int
name|zap_update
parameter_list|(
name|objset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|,
specifier|const
name|void
modifier|*
name|val
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|zap_update_uint64
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
specifier|const
name|uint64_t
modifier|*
name|key
parameter_list|,
name|int
name|key_numints
parameter_list|,
name|int
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|,
specifier|const
name|void
modifier|*
name|val
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/*  * Get the length (in integers) and the integer size of the specified  * attribute.  *  * If the requested attribute does not exist, the call will fail and  * return ENOENT.  */
name|int
name|zap_length
parameter_list|(
name|objset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
modifier|*
name|integer_size
parameter_list|,
name|uint64_t
modifier|*
name|num_integers
parameter_list|)
function_decl|;
name|int
name|zap_length_uint64
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
specifier|const
name|uint64_t
modifier|*
name|key
parameter_list|,
name|int
name|key_numints
parameter_list|,
name|uint64_t
modifier|*
name|integer_size
parameter_list|,
name|uint64_t
modifier|*
name|num_integers
parameter_list|)
function_decl|;
comment|/*  * Remove the specified attribute.  *  * If the specified attribute does not exist, the call will fail and  * return ENOENT.  */
name|int
name|zap_remove
parameter_list|(
name|objset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|zap_remove_norm
parameter_list|(
name|objset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|matchtype_t
name|mt
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|zap_remove_uint64
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
specifier|const
name|uint64_t
modifier|*
name|key
parameter_list|,
name|int
name|key_numints
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/*  * Returns (in *count) the number of attributes in the specified zap  * object.  */
name|int
name|zap_count
parameter_list|(
name|objset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
name|uint64_t
modifier|*
name|count
parameter_list|)
function_decl|;
comment|/*  * Returns (in name) the name of the entry whose (value& mask)  * (za_first_integer) is value, or ENOENT if not found.  The string  * pointed to by name must be at least 256 bytes long.  If mask==0, the  * match must be exact (ie, same as mask=-1ULL).  */
name|int
name|zap_value_search
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
name|uint64_t
name|value
parameter_list|,
name|uint64_t
name|mask
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
comment|/*  * Transfer all the entries from fromobj into intoobj.  Only works on  * int_size=8 num_integers=1 values.  Fails if there are any duplicated  * entries.  */
name|int
name|zap_join
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|fromobj
parameter_list|,
name|uint64_t
name|intoobj
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/* Same as zap_join, but set the values to 'value'. */
name|int
name|zap_join_key
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|fromobj
parameter_list|,
name|uint64_t
name|intoobj
parameter_list|,
name|uint64_t
name|value
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/* Same as zap_join, but add together any duplicated entries. */
name|int
name|zap_join_increment
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|fromobj
parameter_list|,
name|uint64_t
name|intoobj
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/*  * Manipulate entries where the name + value are the "same" (the name is  * a stringified version of the value).  */
name|int
name|zap_add_int
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|uint64_t
name|value
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|zap_remove_int
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|uint64_t
name|value
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|zap_lookup_int
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|uint64_t
name|value
parameter_list|)
function_decl|;
name|int
name|zap_increment_int
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|uint64_t
name|key
parameter_list|,
name|int64_t
name|delta
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/* Here the key is an int and the value is a different int. */
name|int
name|zap_add_int_key
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|uint64_t
name|key
parameter_list|,
name|uint64_t
name|value
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|zap_update_int_key
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|uint64_t
name|key
parameter_list|,
name|uint64_t
name|value
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|zap_lookup_int_key
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|uint64_t
name|key
parameter_list|,
name|uint64_t
modifier|*
name|valuep
parameter_list|)
function_decl|;
name|int
name|zap_increment
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int64_t
name|delta
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
struct_decl|struct
name|zap
struct_decl|;
struct_decl|struct
name|zap_leaf
struct_decl|;
typedef|typedef
struct|struct
name|zap_cursor
block|{
comment|/* This structure is opaque! */
name|objset_t
modifier|*
name|zc_objset
decl_stmt|;
name|struct
name|zap
modifier|*
name|zc_zap
decl_stmt|;
name|struct
name|zap_leaf
modifier|*
name|zc_leaf
decl_stmt|;
name|uint64_t
name|zc_zapobj
decl_stmt|;
name|uint64_t
name|zc_serialized
decl_stmt|;
name|uint64_t
name|zc_hash
decl_stmt|;
name|uint32_t
name|zc_cd
decl_stmt|;
block|}
name|zap_cursor_t
typedef|;
typedef|typedef
struct|struct
block|{
name|int
name|za_integer_length
decl_stmt|;
comment|/* 	 * za_normalization_conflict will be set if there are additional 	 * entries with this normalized form (eg, "foo" and "Foo"). 	 */
name|boolean_t
name|za_normalization_conflict
decl_stmt|;
name|uint64_t
name|za_num_integers
decl_stmt|;
name|uint64_t
name|za_first_integer
decl_stmt|;
comment|/* no sign extension for<8byte ints */
name|char
name|za_name
index|[
name|ZAP_MAXNAMELEN
index|]
decl_stmt|;
block|}
name|zap_attribute_t
typedef|;
comment|/*  * The interface for listing all the attributes of a zapobj can be  * thought of as cursor moving down a list of the attributes one by  * one.  The cookie returned by the zap_cursor_serialize routine is  * persistent across system calls (and across reboot, even).  */
comment|/*  * Initialize a zap cursor, pointing to the "first" attribute of the  * zapobj.  You must _fini the cursor when you are done with it.  */
name|void
name|zap_cursor_init
parameter_list|(
name|zap_cursor_t
modifier|*
name|zc
parameter_list|,
name|objset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|)
function_decl|;
name|void
name|zap_cursor_fini
parameter_list|(
name|zap_cursor_t
modifier|*
name|zc
parameter_list|)
function_decl|;
comment|/*  * Get the attribute currently pointed to by the cursor.  Returns  * ENOENT if at the end of the attributes.  */
name|int
name|zap_cursor_retrieve
parameter_list|(
name|zap_cursor_t
modifier|*
name|zc
parameter_list|,
name|zap_attribute_t
modifier|*
name|za
parameter_list|)
function_decl|;
comment|/*  * Advance the cursor to the next attribute.  */
name|void
name|zap_cursor_advance
parameter_list|(
name|zap_cursor_t
modifier|*
name|zc
parameter_list|)
function_decl|;
comment|/*  * Get a persistent cookie pointing to the current position of the zap  * cursor.  The low 4 bits in the cookie are always zero, and thus can  * be used as to differentiate a serialized cookie from a different type  * of value.  The cookie will be less than 2^32 as long as there are  * fewer than 2^22 (4.2 million) entries in the zap object.  */
name|uint64_t
name|zap_cursor_serialize
parameter_list|(
name|zap_cursor_t
modifier|*
name|zc
parameter_list|)
function_decl|;
comment|/*  * Advance the cursor to the attribute having the given key.  */
name|int
name|zap_cursor_move_to_key
parameter_list|(
name|zap_cursor_t
modifier|*
name|zc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|matchtype_t
name|mt
parameter_list|)
function_decl|;
comment|/*  * Initialize a zap cursor pointing to the position recorded by  * zap_cursor_serialize (in the "serialized" argument).  You can also  * use a "serialized" argument of 0 to start at the beginning of the  * zapobj (ie.  zap_cursor_init_serialized(..., 0) is equivalent to  * zap_cursor_init(...).)  */
name|void
name|zap_cursor_init_serialized
parameter_list|(
name|zap_cursor_t
modifier|*
name|zc
parameter_list|,
name|objset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
name|uint64_t
name|serialized
parameter_list|)
function_decl|;
define|#
directive|define
name|ZAP_HISTOGRAM_SIZE
value|10
typedef|typedef
struct|struct
name|zap_stats
block|{
comment|/* 	 * Size of the pointer table (in number of entries). 	 * This is always a power of 2, or zero if it's a microzap. 	 * In general, it should be considerably greater than zs_num_leafs. 	 */
name|uint64_t
name|zs_ptrtbl_len
decl_stmt|;
name|uint64_t
name|zs_blocksize
decl_stmt|;
comment|/* size of zap blocks */
comment|/* 	 * The number of blocks used.  Note that some blocks may be 	 * wasted because old ptrtbl's and large name/value blocks are 	 * not reused.  (Although their space is reclaimed, we don't 	 * reuse those offsets in the object.) 	 */
name|uint64_t
name|zs_num_blocks
decl_stmt|;
comment|/* 	 * Pointer table values from zap_ptrtbl in the zap_phys_t 	 */
name|uint64_t
name|zs_ptrtbl_nextblk
decl_stmt|;
comment|/* next (larger) copy start block */
name|uint64_t
name|zs_ptrtbl_blks_copied
decl_stmt|;
comment|/* number source blocks copied */
name|uint64_t
name|zs_ptrtbl_zt_blk
decl_stmt|;
comment|/* starting block number */
name|uint64_t
name|zs_ptrtbl_zt_numblks
decl_stmt|;
comment|/* number of blocks */
name|uint64_t
name|zs_ptrtbl_zt_shift
decl_stmt|;
comment|/* bits to index it */
comment|/* 	 * Values of the other members of the zap_phys_t 	 */
name|uint64_t
name|zs_block_type
decl_stmt|;
comment|/* ZBT_HEADER */
name|uint64_t
name|zs_magic
decl_stmt|;
comment|/* ZAP_MAGIC */
name|uint64_t
name|zs_num_leafs
decl_stmt|;
comment|/* The number of leaf blocks */
name|uint64_t
name|zs_num_entries
decl_stmt|;
comment|/* The number of zap entries */
name|uint64_t
name|zs_salt
decl_stmt|;
comment|/* salt to stir into hash function */
comment|/* 	 * Histograms.  For all histograms, the last index 	 * (ZAP_HISTOGRAM_SIZE-1) includes any values which are greater 	 * than what can be represented.  For example 	 * zs_leafs_with_n5_entries[ZAP_HISTOGRAM_SIZE-1] is the number 	 * of leafs with more than 45 entries. 	 */
comment|/* 	 * zs_leafs_with_n_pointers[n] is the number of leafs with 	 * 2^n pointers to it. 	 */
name|uint64_t
name|zs_leafs_with_2n_pointers
index|[
name|ZAP_HISTOGRAM_SIZE
index|]
decl_stmt|;
comment|/* 	 * zs_leafs_with_n_entries[n] is the number of leafs with 	 * [n*5, (n+1)*5) entries.  In the current implementation, there 	 * can be at most 55 entries in any block, but there may be 	 * fewer if the name or value is large, or the block is not 	 * completely full. 	 */
name|uint64_t
name|zs_blocks_with_n5_entries
index|[
name|ZAP_HISTOGRAM_SIZE
index|]
decl_stmt|;
comment|/* 	 * zs_leafs_n_tenths_full[n] is the number of leafs whose 	 * fullness is in the range [n/10, (n+1)/10). 	 */
name|uint64_t
name|zs_blocks_n_tenths_full
index|[
name|ZAP_HISTOGRAM_SIZE
index|]
decl_stmt|;
comment|/* 	 * zs_entries_using_n_chunks[n] is the number of entries which 	 * consume n 24-byte chunks.  (Note, large names/values only use 	 * one chunk, but contribute to zs_num_blocks_large.) 	 */
name|uint64_t
name|zs_entries_using_n_chunks
index|[
name|ZAP_HISTOGRAM_SIZE
index|]
decl_stmt|;
comment|/* 	 * zs_buckets_with_n_entries[n] is the number of buckets (each 	 * leaf has 64 buckets) with n entries. 	 * zs_buckets_with_n_entries[1] should be very close to 	 * zs_num_entries. 	 */
name|uint64_t
name|zs_buckets_with_n_entries
index|[
name|ZAP_HISTOGRAM_SIZE
index|]
decl_stmt|;
block|}
name|zap_stats_t
typedef|;
comment|/*  * Get statistics about a ZAP object.  Note: you need to be aware of the  * internal implementation of the ZAP to correctly interpret some of the  * statistics.  This interface shouldn't be relied on unless you really  * know what you're doing.  */
name|int
name|zap_get_stats
parameter_list|(
name|objset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
name|zapobj
parameter_list|,
name|zap_stats_t
modifier|*
name|zs
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _SYS_ZAP_H */
end_comment

end_unit

