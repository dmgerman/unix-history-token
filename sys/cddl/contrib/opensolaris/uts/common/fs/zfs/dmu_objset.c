begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2012, 2016 by Delphix. All rights reserved.  * Copyright (c) 2013 by Saso Kiselkov. All rights reserved.  * Copyright (c) 2013, Joyent, Inc. All rights reserved.  * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.  * Copyright (c) 2015, STRATO AG, Inc. All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  * Copyright 2017 Nexenta Systems, Inc.  */
end_comment

begin_comment
comment|/* Portions Copyright 2010 Robert Milkowski */
end_comment

begin_include
include|#
directive|include
file|<sys/cred.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_synctask.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_deleg.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/dbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/zvol.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sa.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_onexit.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_destroy.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev.h>
end_include

begin_comment
comment|/*  * Needed to close a window in dnode_move() that allows the objset to be freed  * before it can be safely accessed.  */
end_comment

begin_decl_stmt
name|krwlock_t
name|os_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Tunable to overwrite the maximum number of threads for the parallization  * of dmu_objset_find_dp, needed to speed up the import of pools with many  * datasets.  * Default is 4 times the number of leaf vdevs.  */
end_comment

begin_decl_stmt
name|int
name|dmu_find_threads
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Backfill lower metadnode objects after this many have been freed.  * Backfilling negatively impacts object creation rates, so only do it  * if there are enough holes to fill.  */
end_comment

begin_decl_stmt
name|int
name|dmu_rescan_dnode_threshold
init|=
literal|131072
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|dmu_objset_find_dp_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|dmu_objset_init
parameter_list|(
name|void
parameter_list|)
block|{
name|rw_init
argument_list|(
operator|&
name|os_lock
argument_list|,
name|NULL
argument_list|,
name|RW_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmu_objset_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|rw_destroy
argument_list|(
operator|&
name|os_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|spa_t
modifier|*
name|dmu_objset_spa
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
return|return
operator|(
name|os
operator|->
name|os_spa
operator|)
return|;
block|}
end_function

begin_function
name|zilog_t
modifier|*
name|dmu_objset_zil
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
return|return
operator|(
name|os
operator|->
name|os_zil
operator|)
return|;
block|}
end_function

begin_function
name|dsl_pool_t
modifier|*
name|dmu_objset_pool
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
if|if
condition|(
operator|(
name|ds
operator|=
name|os
operator|->
name|os_dsl_dataset
operator|)
operator|!=
name|NULL
operator|&&
name|ds
operator|->
name|ds_dir
condition|)
return|return
operator|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|)
return|;
else|else
return|return
operator|(
name|spa_get_dsl
argument_list|(
name|os
operator|->
name|os_spa
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|dsl_dataset_t
modifier|*
name|dmu_objset_ds
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
return|return
operator|(
name|os
operator|->
name|os_dsl_dataset
operator|)
return|;
block|}
end_function

begin_function
name|dmu_objset_type_t
name|dmu_objset_type
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
return|return
operator|(
name|os
operator|->
name|os_phys
operator|->
name|os_type
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmu_objset_name
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|dsl_dataset_name
argument_list|(
name|os
operator|->
name|os_dsl_dataset
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|dmu_objset_id
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|os
operator|->
name|os_dsl_dataset
decl_stmt|;
return|return
operator|(
name|ds
condition|?
name|ds
operator|->
name|ds_object
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|zfs_sync_type_t
name|dmu_objset_syncprop
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
return|return
operator|(
name|os
operator|->
name|os_sync
operator|)
return|;
block|}
end_function

begin_function
name|zfs_logbias_op_t
name|dmu_objset_logbias
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
return|return
operator|(
name|os
operator|->
name|os_logbias
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|checksum_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|arg
decl_stmt|;
comment|/* 	 * Inheritance should have been done by now. 	 */
name|ASSERT
argument_list|(
name|newval
operator|!=
name|ZIO_CHECKSUM_INHERIT
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_checksum
operator|=
name|zio_checksum_select
argument_list|(
name|newval
argument_list|,
name|ZIO_CHECKSUM_ON_VALUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|compression_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|arg
decl_stmt|;
comment|/* 	 * Inheritance and range checking should have been done by now. 	 */
name|ASSERT
argument_list|(
name|newval
operator|!=
name|ZIO_COMPRESS_INHERIT
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_compress
operator|=
name|zio_compress_select
argument_list|(
name|os
operator|->
name|os_spa
argument_list|,
name|newval
argument_list|,
name|ZIO_COMPRESS_ON
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|copies_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|arg
decl_stmt|;
comment|/* 	 * Inheritance and range checking should have been done by now. 	 */
name|ASSERT
argument_list|(
name|newval
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|newval
operator|<=
name|spa_max_replication
argument_list|(
name|os
operator|->
name|os_spa
argument_list|)
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_copies
operator|=
name|newval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dedup_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|arg
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|os
operator|->
name|os_spa
decl_stmt|;
name|enum
name|zio_checksum
name|checksum
decl_stmt|;
comment|/* 	 * Inheritance should have been done by now. 	 */
name|ASSERT
argument_list|(
name|newval
operator|!=
name|ZIO_CHECKSUM_INHERIT
argument_list|)
expr_stmt|;
name|checksum
operator|=
name|zio_checksum_dedup_select
argument_list|(
name|spa
argument_list|,
name|newval
argument_list|,
name|ZIO_CHECKSUM_OFF
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_dedup_checksum
operator|=
name|checksum
operator|&
name|ZIO_CHECKSUM_MASK
expr_stmt|;
name|os
operator|->
name|os_dedup_verify
operator|=
operator|!
operator|!
operator|(
name|checksum
operator|&
name|ZIO_CHECKSUM_VERIFY
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|primary_cache_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|arg
decl_stmt|;
comment|/* 	 * Inheritance and range checking should have been done by now. 	 */
name|ASSERT
argument_list|(
name|newval
operator|==
name|ZFS_CACHE_ALL
operator|||
name|newval
operator|==
name|ZFS_CACHE_NONE
operator|||
name|newval
operator|==
name|ZFS_CACHE_METADATA
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_primary_cache
operator|=
name|newval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|secondary_cache_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|arg
decl_stmt|;
comment|/* 	 * Inheritance and range checking should have been done by now. 	 */
name|ASSERT
argument_list|(
name|newval
operator|==
name|ZFS_CACHE_ALL
operator|||
name|newval
operator|==
name|ZFS_CACHE_NONE
operator|||
name|newval
operator|==
name|ZFS_CACHE_METADATA
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_secondary_cache
operator|=
name|newval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sync_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|arg
decl_stmt|;
comment|/* 	 * Inheritance and range checking should have been done by now. 	 */
name|ASSERT
argument_list|(
name|newval
operator|==
name|ZFS_SYNC_STANDARD
operator|||
name|newval
operator|==
name|ZFS_SYNC_ALWAYS
operator|||
name|newval
operator|==
name|ZFS_SYNC_DISABLED
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_sync
operator|=
name|newval
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|os_zil
condition|)
name|zil_set_sync
argument_list|(
name|os
operator|->
name|os_zil
argument_list|,
name|newval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|redundant_metadata_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|arg
decl_stmt|;
comment|/* 	 * Inheritance and range checking should have been done by now. 	 */
name|ASSERT
argument_list|(
name|newval
operator|==
name|ZFS_REDUNDANT_METADATA_ALL
operator|||
name|newval
operator|==
name|ZFS_REDUNDANT_METADATA_MOST
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_redundant_metadata
operator|=
name|newval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|logbias_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|arg
decl_stmt|;
name|ASSERT
argument_list|(
name|newval
operator|==
name|ZFS_LOGBIAS_LATENCY
operator|||
name|newval
operator|==
name|ZFS_LOGBIAS_THROUGHPUT
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_logbias
operator|=
name|newval
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|os_zil
condition|)
name|zil_set_logbias
argument_list|(
name|os
operator|->
name|os_zil
argument_list|,
name|newval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|recordsize_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|arg
decl_stmt|;
name|os
operator|->
name|os_recordsize
operator|=
name|newval
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmu_objset_byteswap
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|objset_phys_t
modifier|*
name|osp
init|=
name|buf
decl_stmt|;
name|ASSERT
argument_list|(
name|size
operator|==
name|OBJSET_OLD_PHYS_SIZE
operator|||
name|size
operator|==
sizeof|sizeof
argument_list|(
name|objset_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|dnode_byteswap
argument_list|(
operator|&
name|osp
operator|->
name|os_meta_dnode
argument_list|)
expr_stmt|;
name|byteswap_uint64_array
argument_list|(
operator|&
name|osp
operator|->
name|os_zil_header
argument_list|,
sizeof|sizeof
argument_list|(
name|zil_header_t
argument_list|)
argument_list|)
expr_stmt|;
name|osp
operator|->
name|os_type
operator|=
name|BSWAP_64
argument_list|(
name|osp
operator|->
name|os_type
argument_list|)
expr_stmt|;
name|osp
operator|->
name|os_flags
operator|=
name|BSWAP_64
argument_list|(
name|osp
operator|->
name|os_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
sizeof|sizeof
argument_list|(
name|objset_phys_t
argument_list|)
condition|)
block|{
name|dnode_byteswap
argument_list|(
operator|&
name|osp
operator|->
name|os_userused_dnode
argument_list|)
expr_stmt|;
name|dnode_byteswap
argument_list|(
operator|&
name|osp
operator|->
name|os_groupused_dnode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|dmu_objset_open_impl
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|objset_t
modifier|*
modifier|*
name|osp
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|==
name|NULL
operator|||
name|MUTEX_HELD
argument_list|(
operator|&
name|ds
operator|->
name|ds_opening_lock
argument_list|)
argument_list|)
expr_stmt|;
name|os
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|objset_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_dsl_dataset
operator|=
name|ds
expr_stmt|;
name|os
operator|->
name|os_spa
operator|=
name|spa
expr_stmt|;
name|os
operator|->
name|os_rootbp
operator|=
name|bp
expr_stmt|;
if|if
condition|(
operator|!
name|BP_IS_HOLE
argument_list|(
name|os
operator|->
name|os_rootbp
argument_list|)
condition|)
block|{
name|arc_flags_t
name|aflags
init|=
name|ARC_FLAG_WAIT
decl_stmt|;
name|zbookmark_phys_t
name|zb
decl_stmt|;
name|SET_BOOKMARK
argument_list|(
operator|&
name|zb
argument_list|,
name|ds
condition|?
name|ds
operator|->
name|ds_object
else|:
name|DMU_META_OBJSET
argument_list|,
name|ZB_ROOT_OBJECT
argument_list|,
name|ZB_ROOT_LEVEL
argument_list|,
name|ZB_ROOT_BLKID
argument_list|)
expr_stmt|;
if|if
condition|(
name|DMU_OS_IS_L2CACHEABLE
argument_list|(
name|os
argument_list|)
condition|)
name|aflags
operator||=
name|ARC_FLAG_L2CACHE
expr_stmt|;
name|dprintf_bp
argument_list|(
name|os
operator|->
name|os_rootbp
argument_list|,
literal|"reading %s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|err
operator|=
name|arc_read
argument_list|(
name|NULL
argument_list|,
name|spa
argument_list|,
name|os
operator|->
name|os_rootbp
argument_list|,
name|arc_getbuf_func
argument_list|,
operator|&
name|os
operator|->
name|os_phys_buf
argument_list|,
name|ZIO_PRIORITY_SYNC_READ
argument_list|,
name|ZIO_FLAG_CANFAIL
argument_list|,
operator|&
name|aflags
argument_list|,
operator|&
name|zb
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|os
argument_list|,
sizeof|sizeof
argument_list|(
name|objset_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* convert checksum errors into IO errors */
if|if
condition|(
name|err
operator|==
name|ECKSUM
condition|)
name|err
operator|=
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* Increase the blocksize if we are permitted. */
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|SPA_VERSION_USERSPACE
operator|&&
name|arc_buf_size
argument_list|(
name|os
operator|->
name|os_phys_buf
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|objset_phys_t
argument_list|)
condition|)
block|{
name|arc_buf_t
modifier|*
name|buf
init|=
name|arc_alloc_buf
argument_list|(
name|spa
argument_list|,
operator|&
name|os
operator|->
name|os_phys_buf
argument_list|,
name|ARC_BUFC_METADATA
argument_list|,
sizeof|sizeof
argument_list|(
name|objset_phys_t
argument_list|)
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
name|buf
operator|->
name|b_data
argument_list|,
sizeof|sizeof
argument_list|(
name|objset_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|os
operator|->
name|os_phys_buf
operator|->
name|b_data
argument_list|,
name|buf
operator|->
name|b_data
argument_list|,
name|arc_buf_size
argument_list|(
name|os
operator|->
name|os_phys_buf
argument_list|)
argument_list|)
expr_stmt|;
name|arc_buf_destroy
argument_list|(
name|os
operator|->
name|os_phys_buf
argument_list|,
operator|&
name|os
operator|->
name|os_phys_buf
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_phys_buf
operator|=
name|buf
expr_stmt|;
block|}
name|os
operator|->
name|os_phys
operator|=
name|os
operator|->
name|os_phys_buf
operator|->
name|b_data
expr_stmt|;
name|os
operator|->
name|os_flags
operator|=
name|os
operator|->
name|os_phys
operator|->
name|os_flags
expr_stmt|;
block|}
else|else
block|{
name|int
name|size
init|=
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|SPA_VERSION_USERSPACE
condition|?
sizeof|sizeof
argument_list|(
name|objset_phys_t
argument_list|)
else|:
name|OBJSET_OLD_PHYS_SIZE
decl_stmt|;
name|os
operator|->
name|os_phys_buf
operator|=
name|arc_alloc_buf
argument_list|(
name|spa
argument_list|,
operator|&
name|os
operator|->
name|os_phys_buf
argument_list|,
name|ARC_BUFC_METADATA
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_phys
operator|=
name|os
operator|->
name|os_phys_buf
operator|->
name|b_data
expr_stmt|;
name|bzero
argument_list|(
name|os
operator|->
name|os_phys
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Note: the changed_cb will be called once before the register 	 * func returns, thus changing the checksum/compression from the 	 * default (fletcher2/off).  Snapshots don't need to know about 	 * checksum/compression/copies. 	 */
if|if
condition|(
name|ds
operator|!=
name|NULL
condition|)
block|{
name|boolean_t
name|needlock
init|=
name|B_FALSE
decl_stmt|;
comment|/* 		 * Note: it's valid to open the objset if the dataset is 		 * long-held, in which case the pool_config lock will not 		 * be held. 		 */
if|if
condition|(
operator|!
name|dsl_pool_config_held
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|)
condition|)
block|{
name|needlock
operator|=
name|B_TRUE
expr_stmt|;
name|dsl_pool_config_enter
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_PRIMARYCACHE
argument_list|)
argument_list|,
name|primary_cache_changed_cb
argument_list|,
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_SECONDARYCACHE
argument_list|)
argument_list|,
name|secondary_cache_changed_cb
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ds
operator|->
name|ds_is_snapshot
condition|)
block|{
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CHECKSUM
argument_list|)
argument_list|,
name|checksum_changed_cb
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_COMPRESSION
argument_list|)
argument_list|,
name|compression_changed_cb
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_COPIES
argument_list|)
argument_list|,
name|copies_changed_cb
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_DEDUP
argument_list|)
argument_list|,
name|dedup_changed_cb
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_LOGBIAS
argument_list|)
argument_list|,
name|logbias_changed_cb
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_SYNC
argument_list|)
argument_list|,
name|sync_changed_cb
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REDUNDANT_METADATA
argument_list|)
argument_list|,
name|redundant_metadata_changed_cb
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_RECORDSIZE
argument_list|)
argument_list|,
name|recordsize_changed_cb
argument_list|,
name|os
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|needlock
condition|)
name|dsl_pool_config_exit
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|arc_buf_destroy
argument_list|(
name|os
operator|->
name|os_phys_buf
argument_list|,
operator|&
name|os
operator|->
name|os_phys_buf
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|os
argument_list|,
sizeof|sizeof
argument_list|(
name|objset_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* It's the meta-objset. */
name|os
operator|->
name|os_checksum
operator|=
name|ZIO_CHECKSUM_FLETCHER_4
expr_stmt|;
name|os
operator|->
name|os_compress
operator|=
name|ZIO_COMPRESS_ON
expr_stmt|;
name|os
operator|->
name|os_copies
operator|=
name|spa_max_replication
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_dedup_checksum
operator|=
name|ZIO_CHECKSUM_OFF
expr_stmt|;
name|os
operator|->
name|os_dedup_verify
operator|=
name|B_FALSE
expr_stmt|;
name|os
operator|->
name|os_logbias
operator|=
name|ZFS_LOGBIAS_LATENCY
expr_stmt|;
name|os
operator|->
name|os_sync
operator|=
name|ZFS_SYNC_STANDARD
expr_stmt|;
name|os
operator|->
name|os_primary_cache
operator|=
name|ZFS_CACHE_ALL
expr_stmt|;
name|os
operator|->
name|os_secondary_cache
operator|=
name|ZFS_CACHE_ALL
expr_stmt|;
block|}
if|if
condition|(
name|ds
operator|==
name|NULL
operator|||
operator|!
name|ds
operator|->
name|ds_is_snapshot
condition|)
name|os
operator|->
name|os_zil_header
operator|=
name|os
operator|->
name|os_phys
operator|->
name|os_zil_header
expr_stmt|;
name|os
operator|->
name|os_zil
operator|=
name|zil_alloc
argument_list|(
name|os
argument_list|,
operator|&
name|os
operator|->
name|os_zil_header
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|list_create
argument_list|(
operator|&
name|os
operator|->
name|os_dirty_dnodes
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dnode_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dnode_t
argument_list|,
name|dn_dirty_link
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|os
operator|->
name|os_free_dnodes
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dnode_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dnode_t
argument_list|,
name|dn_dirty_link
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|list_create
argument_list|(
operator|&
name|os
operator|->
name|os_dnodes
argument_list|,
sizeof|sizeof
argument_list|(
name|dnode_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dnode_t
argument_list|,
name|dn_link
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|os
operator|->
name|os_downgraded_dbufs
argument_list|,
sizeof|sizeof
argument_list|(
name|dmu_buf_impl_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dmu_buf_impl_t
argument_list|,
name|db_link
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|os
operator|->
name|os_obj_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|os
operator|->
name|os_user_ptr_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dnode_special_open
argument_list|(
name|os
argument_list|,
operator|&
name|os
operator|->
name|os_phys
operator|->
name|os_meta_dnode
argument_list|,
name|DMU_META_DNODE_OBJECT
argument_list|,
operator|&
name|os
operator|->
name|os_meta_dnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|arc_buf_size
argument_list|(
name|os
operator|->
name|os_phys_buf
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|objset_phys_t
argument_list|)
condition|)
block|{
name|dnode_special_open
argument_list|(
name|os
argument_list|,
operator|&
name|os
operator|->
name|os_phys
operator|->
name|os_userused_dnode
argument_list|,
name|DMU_USERUSED_OBJECT
argument_list|,
operator|&
name|os
operator|->
name|os_userused_dnode
argument_list|)
expr_stmt|;
name|dnode_special_open
argument_list|(
name|os
argument_list|,
operator|&
name|os
operator|->
name|os_phys
operator|->
name|os_groupused_dnode
argument_list|,
name|DMU_GROUPUSED_OBJECT
argument_list|,
operator|&
name|os
operator|->
name|os_groupused_dnode
argument_list|)
expr_stmt|;
block|}
operator|*
name|osp
operator|=
name|os
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_objset_from_ds
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|objset_t
modifier|*
modifier|*
name|osp
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* 	 * We shouldn't be doing anything with dsl_dataset_t's unless the 	 * pool_config lock is held, or the dataset is long-held. 	 */
name|ASSERT
argument_list|(
name|dsl_pool_config_held
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|)
operator|||
name|dsl_dataset_long_held
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_opening_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_objset
operator|==
name|NULL
condition|)
block|{
name|objset_t
modifier|*
name|os
decl_stmt|;
name|rrw_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_bp_rwlock
argument_list|,
name|RW_READER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_objset_open_impl
argument_list|(
name|dsl_dataset_get_spa
argument_list|(
name|ds
argument_list|)
argument_list|,
name|ds
argument_list|,
name|dsl_dataset_get_blkptr
argument_list|(
name|ds
argument_list|)
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
name|rrw_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_bp_rwlock
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_objset
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_objset
operator|=
name|os
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|osp
operator|=
name|ds
operator|->
name|ds_objset
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_opening_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Holds the pool while the objset is held.  Therefore only one objset  * can be held at a time.  */
end_comment

begin_function
name|int
name|dmu_objset_hold
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|objset_t
modifier|*
modifier|*
name|osp
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dsl_pool_hold
argument_list|(
name|name
argument_list|,
name|tag
argument_list|,
operator|&
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|name
argument_list|,
name|tag
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|dsl_pool_rele
argument_list|(
name|dp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|err
operator|=
name|dmu_objset_from_ds
argument_list|(
name|ds
argument_list|,
name|osp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|dsl_pool_rele
argument_list|(
name|dp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmu_objset_own_impl
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|dmu_objset_type_t
name|type
parameter_list|,
name|boolean_t
name|readonly
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|objset_t
modifier|*
modifier|*
name|osp
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dmu_objset_from_ds
argument_list|(
name|ds
argument_list|,
name|osp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|dsl_dataset_disown
argument_list|(
name|ds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|DMU_OST_ANY
operator|&&
name|type
operator|!=
operator|(
operator|*
name|osp
operator|)
operator|->
name|os_phys
operator|->
name|os_type
condition|)
block|{
name|dsl_dataset_disown
argument_list|(
name|ds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|readonly
operator|&&
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
block|{
name|dsl_dataset_disown
argument_list|(
name|ds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EROFS
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * dsl_pool must not be held when this is called.  * Upon successful return, there will be a longhold on the dataset,  * and the dsl_pool will not be held.  */
end_comment

begin_function
name|int
name|dmu_objset_own
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|dmu_objset_type_t
name|type
parameter_list|,
name|boolean_t
name|readonly
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|objset_t
modifier|*
modifier|*
name|osp
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dsl_pool_hold
argument_list|(
name|name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|dsl_dataset_own
argument_list|(
name|dp
argument_list|,
name|name
argument_list|,
name|tag
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|dsl_pool_rele
argument_list|(
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|err
operator|=
name|dmu_objset_own_impl
argument_list|(
name|ds
argument_list|,
name|type
argument_list|,
name|readonly
argument_list|,
name|tag
argument_list|,
name|osp
argument_list|)
expr_stmt|;
name|dsl_pool_rele
argument_list|(
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_objset_own_obj
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|dmu_objset_type_t
name|type
parameter_list|,
name|boolean_t
name|readonly
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|objset_t
modifier|*
modifier|*
name|osp
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dsl_dataset_own_obj
argument_list|(
name|dp
argument_list|,
name|obj
argument_list|,
name|tag
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
return|return
operator|(
name|dmu_objset_own_impl
argument_list|(
name|ds
argument_list|,
name|type
argument_list|,
name|readonly
argument_list|,
name|tag
argument_list|,
name|osp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmu_objset_rele
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|dsl_dataset_rele
argument_list|(
name|os
operator|->
name|os_dsl_dataset
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|dsl_pool_rele
argument_list|(
name|dp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When we are called, os MUST refer to an objset associated with a dataset  * that is owned by 'tag'; that is, is held and long held by 'tag' and ds_owner  * == tag.  We will then release and reacquire ownership of the dataset while  * holding the pool config_rwlock to avoid intervening namespace or ownership  * changes may occur.  *  * This exists solely to accommodate zfs_ioc_userspace_upgrade()'s desire to  * release the hold on its dataset and acquire a new one on the dataset of the  * same name so that it can be partially torn down and reconstructed.  */
end_comment

begin_function
name|void
name|dmu_objset_refresh_ownership
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|,
modifier|*
name|newds
decl_stmt|;
name|char
name|name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|ds
operator|=
name|os
operator|->
name|os_dsl_dataset
expr_stmt|;
name|VERIFY3P
argument_list|(
name|ds
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|VERIFY3P
argument_list|(
name|ds
operator|->
name|ds_owner
argument_list|,
operator|==
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dsl_dataset_long_held
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_name
argument_list|(
name|ds
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dp
operator|=
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dsl_pool_config_enter
argument_list|(
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_own
argument_list|(
name|dp
argument_list|,
name|name
argument_list|,
name|tag
argument_list|,
operator|&
name|newds
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3P
argument_list|(
name|newds
argument_list|,
operator|==
argument_list|,
name|os
operator|->
name|os_dsl_dataset
argument_list|)
expr_stmt|;
name|dsl_pool_config_exit
argument_list|(
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmu_objset_disown
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|dsl_dataset_disown
argument_list|(
name|os
operator|->
name|os_dsl_dataset
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmu_objset_evict_dbufs
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
name|dnode_t
name|dn_marker
decl_stmt|;
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
name|dn
operator|=
name|list_head
argument_list|(
operator|&
name|os
operator|->
name|os_dnodes
argument_list|)
expr_stmt|;
while|while
condition|(
name|dn
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Skip dnodes without holds.  We have to do this dance 		 * because dnode_add_ref() only works if there is already a 		 * hold.  If the dnode has no holds, then it has no dbufs. 		 */
if|if
condition|(
name|dnode_add_ref
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
condition|)
block|{
name|list_insert_after
argument_list|(
operator|&
name|os
operator|->
name|os_dnodes
argument_list|,
name|dn
argument_list|,
operator|&
name|dn_marker
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
name|dnode_evict_dbufs
argument_list|(
name|dn
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
name|dn
operator|=
name|list_next
argument_list|(
operator|&
name|os
operator|->
name|os_dnodes
argument_list|,
operator|&
name|dn_marker
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|os
operator|->
name|os_dnodes
argument_list|,
operator|&
name|dn_marker
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dn
operator|=
name|list_next
argument_list|(
operator|&
name|os
operator|->
name|os_dnodes
argument_list|,
name|dn
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|DMU_USERUSED_DNODE
argument_list|(
name|os
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|dnode_evict_dbufs
argument_list|(
name|DMU_GROUPUSED_DNODE
argument_list|(
name|os
argument_list|)
argument_list|)
expr_stmt|;
name|dnode_evict_dbufs
argument_list|(
name|DMU_USERUSED_DNODE
argument_list|(
name|os
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dnode_evict_dbufs
argument_list|(
name|DMU_META_DNODE
argument_list|(
name|os
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Objset eviction processing is split into into two pieces.  * The first marks the objset as evicting, evicts any dbufs that  * have a refcount of zero, and then queues up the objset for the  * second phase of eviction.  Once os->os_dnodes has been cleared by  * dnode_buf_pageout()->dnode_destroy(), the second phase is executed.  * The second phase closes the special dnodes, dequeues the objset from  * the list of those undergoing eviction, and finally frees the objset.  *  * NOTE: Due to asynchronous eviction processing (invocation of  *       dnode_buf_pageout()), it is possible for the meta dnode for the  *       objset to have no holds even though os->os_dnodes is not empty.  */
end_comment

begin_function
name|void
name|dmu_objset_evict
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|os
operator|->
name|os_dsl_dataset
decl_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|TXG_SIZE
condition|;
name|t
operator|++
control|)
name|ASSERT
argument_list|(
operator|!
name|dmu_objset_is_dirty
argument_list|(
name|os
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
condition|)
name|dsl_prop_unregister_all
argument_list|(
name|ds
argument_list|,
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|os_sa
condition|)
name|sa_tear_down
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_objset_evict_dbufs
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
name|spa_evicting_os_register
argument_list|(
name|os
operator|->
name|os_spa
argument_list|,
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_is_empty
argument_list|(
operator|&
name|os
operator|->
name|os_dnodes
argument_list|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
name|dmu_objset_evict_done
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dmu_objset_evict_done
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
name|ASSERT3P
argument_list|(
name|list_head
argument_list|(
operator|&
name|os
operator|->
name|os_dnodes
argument_list|)
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dnode_special_close
argument_list|(
operator|&
name|os
operator|->
name|os_meta_dnode
argument_list|)
expr_stmt|;
if|if
condition|(
name|DMU_USERUSED_DNODE
argument_list|(
name|os
argument_list|)
condition|)
block|{
name|dnode_special_close
argument_list|(
operator|&
name|os
operator|->
name|os_userused_dnode
argument_list|)
expr_stmt|;
name|dnode_special_close
argument_list|(
operator|&
name|os
operator|->
name|os_groupused_dnode
argument_list|)
expr_stmt|;
block|}
name|zil_free
argument_list|(
name|os
operator|->
name|os_zil
argument_list|)
expr_stmt|;
name|arc_buf_destroy
argument_list|(
name|os
operator|->
name|os_phys_buf
argument_list|,
operator|&
name|os
operator|->
name|os_phys_buf
argument_list|)
expr_stmt|;
comment|/* 	 * This is a barrier to prevent the objset from going away in 	 * dnode_move() until we can safely ensure that the objset is still in 	 * use. We consider the objset valid before the barrier and invalid 	 * after the barrier. 	 */
name|rw_enter
argument_list|(
operator|&
name|os_lock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|os_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|os
operator|->
name|os_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|os
operator|->
name|os_obj_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|os
operator|->
name|os_user_ptr_lock
argument_list|)
expr_stmt|;
name|spa_evicting_os_deregister
argument_list|(
name|os
operator|->
name|os_spa
argument_list|,
name|os
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|os
argument_list|,
sizeof|sizeof
argument_list|(
name|objset_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|timestruc_t
name|dmu_objset_snap_cmtime
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
return|return
operator|(
name|dsl_dir_snap_cmtime
argument_list|(
name|os
operator|->
name|os_dsl_dataset
operator|->
name|ds_dir
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* called from dsl for meta-objset */
end_comment

begin_function
name|objset_t
modifier|*
name|dmu_objset_create_impl
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|dmu_objset_type_t
name|type
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
decl_stmt|;
name|dnode_t
modifier|*
name|mdn
decl_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|!=
name|NULL
condition|)
name|VERIFY0
argument_list|(
name|dmu_objset_from_ds
argument_list|(
name|ds
argument_list|,
operator|&
name|os
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|VERIFY0
argument_list|(
name|dmu_objset_open_impl
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|bp
argument_list|,
operator|&
name|os
argument_list|)
argument_list|)
expr_stmt|;
name|mdn
operator|=
name|DMU_META_DNODE
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dnode_allocate
argument_list|(
name|mdn
argument_list|,
name|DMU_OT_DNODE
argument_list|,
literal|1
operator|<<
name|DNODE_BLOCK_SHIFT
argument_list|,
name|DN_MAX_INDBLKSHIFT
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * We don't want to have to increase the meta-dnode's nlevels 	 * later, because then we could do it in quescing context while 	 * we are also accessing it in open context. 	 * 	 * This precaution is not necessary for the MOS (ds == NULL), 	 * because the MOS is only updated in syncing context. 	 * This is most fortunate: the MOS is the only objset that 	 * needs to be synced multiple times as spa_sync() iterates 	 * to convergence, so minimizing its dn_nlevels matters. 	 */
if|if
condition|(
name|ds
operator|!=
name|NULL
condition|)
block|{
name|int
name|levels
init|=
literal|1
decl_stmt|;
comment|/* 		 * Determine the number of levels necessary for the meta-dnode 		 * to contain DN_MAX_OBJECT dnodes.  Note that in order to 		 * ensure that we do not overflow 64 bits, there has to be 		 * a nlevels that gives us a number of blocks> DN_MAX_OBJECT 		 * but< 2^64.  Therefore, 		 * (mdn->dn_indblkshift - SPA_BLKPTRSHIFT) (10) must be 		 * less than (64 - log2(DN_MAX_OBJECT)) (16). 		 */
while|while
condition|(
operator|(
name|uint64_t
operator|)
name|mdn
operator|->
name|dn_nblkptr
operator|<<
operator|(
name|mdn
operator|->
name|dn_datablkshift
operator|-
name|DNODE_SHIFT
operator|+
operator|(
name|levels
operator|-
literal|1
operator|)
operator|*
operator|(
name|mdn
operator|->
name|dn_indblkshift
operator|-
name|SPA_BLKPTRSHIFT
operator|)
operator|)
operator|<
name|DN_MAX_OBJECT
condition|)
name|levels
operator|++
expr_stmt|;
name|mdn
operator|->
name|dn_next_nlevels
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|=
name|mdn
operator|->
name|dn_nlevels
operator|=
name|levels
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|type
operator|!=
name|DMU_OST_NONE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|type
operator|!=
name|DMU_OST_ANY
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|type
operator|<
name|DMU_OST_NUMTYPES
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_phys
operator|->
name|os_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|dmu_objset_userused_enabled
argument_list|(
name|os
argument_list|)
condition|)
block|{
name|os
operator|->
name|os_phys
operator|->
name|os_flags
operator||=
name|OBJSET_FLAG_USERACCOUNTING_COMPLETE
expr_stmt|;
name|os
operator|->
name|os_flags
operator|=
name|os
operator|->
name|os_phys
operator|->
name|os_flags
expr_stmt|;
block|}
name|dsl_dataset_dirty
argument_list|(
name|ds
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|os
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|dmu_objset_create_arg
block|{
specifier|const
name|char
modifier|*
name|doca_name
decl_stmt|;
name|cred_t
modifier|*
name|doca_cred
decl_stmt|;
name|void
function_decl|(
modifier|*
name|doca_userfunc
function_decl|)
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|void
modifier|*
name|doca_userarg
decl_stmt|;
name|dmu_objset_type_t
name|doca_type
decl_stmt|;
name|uint64_t
name|doca_flags
decl_stmt|;
block|}
name|dmu_objset_create_arg_t
typedef|;
end_typedef

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dmu_objset_create_check
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_objset_create_arg_t
modifier|*
name|doca
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|dsl_dir_t
modifier|*
name|pdd
decl_stmt|;
specifier|const
name|char
modifier|*
name|tail
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|doca
operator|->
name|doca_name
argument_list|,
literal|'@'
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|strlen
argument_list|(
name|doca
operator|->
name|doca_name
argument_list|)
operator|>=
name|ZFS_MAX_DATASET_NAME_LEN
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENAMETOOLONG
argument_list|)
operator|)
return|;
name|error
operator|=
name|dsl_dir_hold
argument_list|(
name|dp
argument_list|,
name|doca
operator|->
name|doca_name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|pdd
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
block|{
name|dsl_dir_rele
argument_list|(
name|pdd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
block|}
name|error
operator|=
name|dsl_fs_ss_limit_check
argument_list|(
name|pdd
argument_list|,
literal|1
argument_list|,
name|ZFS_PROP_FILESYSTEM_LIMIT
argument_list|,
name|NULL
argument_list|,
name|doca
operator|->
name|doca_cred
argument_list|)
expr_stmt|;
name|dsl_dir_rele
argument_list|(
name|pdd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmu_objset_create_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_objset_create_arg_t
modifier|*
name|doca
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|dsl_dir_t
modifier|*
name|pdd
decl_stmt|;
specifier|const
name|char
modifier|*
name|tail
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|uint64_t
name|obj
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dir_hold
argument_list|(
name|dp
argument_list|,
name|doca
operator|->
name|doca_name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|pdd
argument_list|,
operator|&
name|tail
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|=
name|dsl_dataset_create_sync
argument_list|(
name|pdd
argument_list|,
name|tail
argument_list|,
name|NULL
argument_list|,
name|doca
operator|->
name|doca_flags
argument_list|,
name|doca
operator|->
name|doca_cred
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold_obj
argument_list|(
name|pdd
operator|->
name|dd_pool
argument_list|,
name|obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|rrw_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_bp_rwlock
argument_list|,
name|RW_READER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|bp
operator|=
name|dsl_dataset_get_blkptr
argument_list|(
name|ds
argument_list|)
expr_stmt|;
name|os
operator|=
name|dmu_objset_create_impl
argument_list|(
name|pdd
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|,
name|ds
argument_list|,
name|bp
argument_list|,
name|doca
operator|->
name|doca_type
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|rrw_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_bp_rwlock
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|doca
operator|->
name|doca_userfunc
operator|!=
name|NULL
condition|)
block|{
name|doca
operator|->
name|doca_userfunc
argument_list|(
name|os
argument_list|,
name|doca
operator|->
name|doca_userarg
argument_list|,
name|doca
operator|->
name|doca_cred
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|spa_history_log_internal_ds
argument_list|(
name|ds
argument_list|,
literal|"create"
argument_list|,
name|tx
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dsl_dir_rele
argument_list|(
name|pdd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dmu_objset_create
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|dmu_objset_type_t
name|type
parameter_list|,
name|uint64_t
name|flags
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dmu_objset_create_arg_t
name|doca
decl_stmt|;
name|doca
operator|.
name|doca_name
operator|=
name|name
expr_stmt|;
name|doca
operator|.
name|doca_cred
operator|=
name|CRED
argument_list|()
expr_stmt|;
name|doca
operator|.
name|doca_flags
operator|=
name|flags
expr_stmt|;
name|doca
operator|.
name|doca_userfunc
operator|=
name|func
expr_stmt|;
name|doca
operator|.
name|doca_userarg
operator|=
name|arg
expr_stmt|;
name|doca
operator|.
name|doca_type
operator|=
name|type
expr_stmt|;
return|return
operator|(
name|dsl_sync_task
argument_list|(
name|name
argument_list|,
name|dmu_objset_create_check
argument_list|,
name|dmu_objset_create_sync
argument_list|,
operator|&
name|doca
argument_list|,
literal|5
argument_list|,
name|ZFS_SPACE_CHECK_NORMAL
argument_list|)
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|dmu_objset_clone_arg
block|{
specifier|const
name|char
modifier|*
name|doca_clone
decl_stmt|;
specifier|const
name|char
modifier|*
name|doca_origin
decl_stmt|;
name|cred_t
modifier|*
name|doca_cred
decl_stmt|;
block|}
name|dmu_objset_clone_arg_t
typedef|;
end_typedef

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dmu_objset_clone_check
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_objset_clone_arg_t
modifier|*
name|doca
init|=
name|arg
decl_stmt|;
name|dsl_dir_t
modifier|*
name|pdd
decl_stmt|;
specifier|const
name|char
modifier|*
name|tail
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|origin
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|doca
operator|->
name|doca_clone
argument_list|,
literal|'@'
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|strlen
argument_list|(
name|doca
operator|->
name|doca_clone
argument_list|)
operator|>=
name|ZFS_MAX_DATASET_NAME_LEN
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENAMETOOLONG
argument_list|)
operator|)
return|;
name|error
operator|=
name|dsl_dir_hold
argument_list|(
name|dp
argument_list|,
name|doca
operator|->
name|doca_clone
argument_list|,
name|FTAG
argument_list|,
operator|&
name|pdd
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
block|{
name|dsl_dir_rele
argument_list|(
name|pdd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
block|}
name|error
operator|=
name|dsl_fs_ss_limit_check
argument_list|(
name|pdd
argument_list|,
literal|1
argument_list|,
name|ZFS_PROP_FILESYSTEM_LIMIT
argument_list|,
name|NULL
argument_list|,
name|doca
operator|->
name|doca_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dsl_dir_rele
argument_list|(
name|pdd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EDQUOT
argument_list|)
operator|)
return|;
block|}
name|dsl_dir_rele
argument_list|(
name|pdd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|doca
operator|->
name|doca_origin
argument_list|,
name|FTAG
argument_list|,
operator|&
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* You can only clone snapshots, not the head datasets. */
if|if
condition|(
operator|!
name|origin
operator|->
name|ds_is_snapshot
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|origin
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|dsl_dataset_rele
argument_list|(
name|origin
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmu_objset_clone_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dmu_objset_clone_arg_t
modifier|*
name|doca
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|dsl_dir_t
modifier|*
name|pdd
decl_stmt|;
specifier|const
name|char
modifier|*
name|tail
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|origin
decl_stmt|,
modifier|*
name|ds
decl_stmt|;
name|uint64_t
name|obj
decl_stmt|;
name|char
name|namebuf
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dir_hold
argument_list|(
name|dp
argument_list|,
name|doca
operator|->
name|doca_clone
argument_list|,
name|FTAG
argument_list|,
operator|&
name|pdd
argument_list|,
operator|&
name|tail
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|doca
operator|->
name|doca_origin
argument_list|,
name|FTAG
argument_list|,
operator|&
name|origin
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|=
name|dsl_dataset_create_sync
argument_list|(
name|pdd
argument_list|,
name|tail
argument_list|,
name|origin
argument_list|,
literal|0
argument_list|,
name|doca
operator|->
name|doca_cred
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold_obj
argument_list|(
name|pdd
operator|->
name|dd_pool
argument_list|,
name|obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_name
argument_list|(
name|origin
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
name|spa_history_log_internal_ds
argument_list|(
name|ds
argument_list|,
literal|"clone"
argument_list|,
name|tx
argument_list|,
literal|"origin=%s (%llu)"
argument_list|,
name|namebuf
argument_list|,
name|origin
operator|->
name|ds_object
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|origin
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dsl_dir_rele
argument_list|(
name|pdd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dmu_objset_clone
parameter_list|(
specifier|const
name|char
modifier|*
name|clone
parameter_list|,
specifier|const
name|char
modifier|*
name|origin
parameter_list|)
block|{
name|dmu_objset_clone_arg_t
name|doca
decl_stmt|;
name|doca
operator|.
name|doca_clone
operator|=
name|clone
expr_stmt|;
name|doca
operator|.
name|doca_origin
operator|=
name|origin
expr_stmt|;
name|doca
operator|.
name|doca_cred
operator|=
name|CRED
argument_list|()
expr_stmt|;
return|return
operator|(
name|dsl_sync_task
argument_list|(
name|clone
argument_list|,
name|dmu_objset_clone_check
argument_list|,
name|dmu_objset_clone_sync
argument_list|,
operator|&
name|doca
argument_list|,
literal|5
argument_list|,
name|ZFS_SPACE_CHECK_NORMAL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_objset_snapshot_one
parameter_list|(
specifier|const
name|char
modifier|*
name|fsname
parameter_list|,
specifier|const
name|char
modifier|*
name|snapname
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|longsnap
init|=
name|kmem_asprintf
argument_list|(
literal|"%s@%s"
argument_list|,
name|fsname
argument_list|,
name|snapname
argument_list|)
decl_stmt|;
name|nvlist_t
modifier|*
name|snaps
init|=
name|fnvlist_alloc
argument_list|()
decl_stmt|;
name|fnvlist_add_boolean
argument_list|(
name|snaps
argument_list|,
name|longsnap
argument_list|)
expr_stmt|;
name|strfree
argument_list|(
name|longsnap
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_dataset_snapshot
argument_list|(
name|snaps
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|snaps
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmu_objset_sync_dnodes
parameter_list|(
name|list_t
modifier|*
name|list
parameter_list|,
name|list_t
modifier|*
name|newlist
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
while|while
condition|(
name|dn
operator|=
name|list_head
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_object
operator|!=
name|DMU_META_DNODE_OBJECT
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_dbuf
operator|->
name|db_data_pending
argument_list|)
expr_stmt|;
comment|/* 		 * Initialize dn_zio outside dnode_sync() because the 		 * meta-dnode needs to set it ouside dnode_sync(). 		 */
name|dn
operator|->
name|dn_zio
operator|=
name|dn
operator|->
name|dn_dbuf
operator|->
name|db_data_pending
operator|->
name|dr_zio
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_zio
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dn
operator|->
name|dn_nlevels
argument_list|,
operator|<=
argument_list|,
name|DN_MAX_LEVELS
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
name|list
argument_list|,
name|dn
argument_list|)
expr_stmt|;
if|if
condition|(
name|newlist
condition|)
block|{
operator|(
name|void
operator|)
name|dnode_add_ref
argument_list|(
name|dn
argument_list|,
name|newlist
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
name|newlist
argument_list|,
name|dn
argument_list|)
expr_stmt|;
block|}
name|dnode_sync
argument_list|(
name|dn
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dmu_objset_write_ready
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|arc_buf_t
modifier|*
name|abuf
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|arg
decl_stmt|;
name|dnode_phys_t
modifier|*
name|dnp
init|=
operator|&
name|os
operator|->
name|os_phys
operator|->
name|os_meta_dnode
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|BP_IS_EMBEDDED
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
argument_list|,
operator|==
argument_list|,
name|DMU_OT_OBJSET
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|BP_GET_LEVEL
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Update rootbp fill count: it should be the number of objects 	 * allocated in the object set (not counting the "special" 	 * objects that are stored in the objset_phys_t -- the meta 	 * dnode and user/group accounting objects). 	 */
name|bp
operator|->
name|blk_fill
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|dnp
operator|->
name|dn_nblkptr
condition|;
name|i
operator|++
control|)
name|bp
operator|->
name|blk_fill
operator|+=
name|BP_GET_FILL
argument_list|(
operator|&
name|dnp
operator|->
name|dn_blkptr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|os_dsl_dataset
operator|!=
name|NULL
condition|)
name|rrw_enter
argument_list|(
operator|&
name|os
operator|->
name|os_dsl_dataset
operator|->
name|ds_bp_rwlock
argument_list|,
name|RW_WRITER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
operator|*
name|os
operator|->
name|os_rootbp
operator|=
operator|*
name|bp
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|os_dsl_dataset
operator|!=
name|NULL
condition|)
name|rrw_exit
argument_list|(
operator|&
name|os
operator|->
name|os_dsl_dataset
operator|->
name|ds_bp_rwlock
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dmu_objset_write_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|arc_buf_t
modifier|*
name|abuf
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|blkptr_t
modifier|*
name|bp_orig
init|=
operator|&
name|zio
operator|->
name|io_bp_orig
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_IO_REWRITE
condition|)
block|{
name|ASSERT
argument_list|(
name|BP_EQUAL
argument_list|(
name|bp
argument_list|,
name|bp_orig
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|os
operator|->
name|os_dsl_dataset
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
init|=
name|os
operator|->
name|os_synctx
decl_stmt|;
operator|(
name|void
operator|)
name|dsl_dataset_block_kill
argument_list|(
name|ds
argument_list|,
name|bp_orig
argument_list|,
name|tx
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|dsl_dataset_block_born
argument_list|(
name|ds
argument_list|,
name|bp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|bp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* called from dsl */
end_comment

begin_function
name|void
name|dmu_objset_sync
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|zio_t
modifier|*
name|pio
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|txgoff
decl_stmt|;
name|zbookmark_phys_t
name|zb
decl_stmt|;
name|zio_prop_t
name|zp
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|list_t
modifier|*
name|list
decl_stmt|;
name|list_t
modifier|*
name|newlist
init|=
name|NULL
decl_stmt|;
name|dbuf_dirty_record_t
modifier|*
name|dr
decl_stmt|;
name|blkptr_t
modifier|*
name|blkptr_copy
init|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|os
operator|->
name|os_rootbp
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
operator|*
name|blkptr_copy
operator|=
operator|*
name|os
operator|->
name|os_rootbp
expr_stmt|;
name|dprintf_ds
argument_list|(
name|os
operator|->
name|os_dsl_dataset
argument_list|,
literal|"txg=%llu\n"
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX the write_done callback should really give us the tx... */
name|os
operator|->
name|os_synctx
operator|=
name|tx
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|os_dsl_dataset
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * This is the MOS.  If we have upgraded, 		 * spa_max_replication() could change, so reset 		 * os_copies here. 		 */
name|os
operator|->
name|os_copies
operator|=
name|spa_max_replication
argument_list|(
name|os
operator|->
name|os_spa
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create the root block IO 	 */
name|SET_BOOKMARK
argument_list|(
operator|&
name|zb
argument_list|,
name|os
operator|->
name|os_dsl_dataset
condition|?
name|os
operator|->
name|os_dsl_dataset
operator|->
name|ds_object
else|:
name|DMU_META_OBJSET
argument_list|,
name|ZB_ROOT_OBJECT
argument_list|,
name|ZB_ROOT_LEVEL
argument_list|,
name|ZB_ROOT_BLKID
argument_list|)
expr_stmt|;
name|arc_release
argument_list|(
name|os
operator|->
name|os_phys_buf
argument_list|,
operator|&
name|os
operator|->
name|os_phys_buf
argument_list|)
expr_stmt|;
name|dmu_write_policy
argument_list|(
name|os
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ZIO_COMPRESS_INHERIT
argument_list|,
operator|&
name|zp
argument_list|)
expr_stmt|;
name|zio
operator|=
name|arc_write
argument_list|(
name|pio
argument_list|,
name|os
operator|->
name|os_spa
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|,
name|blkptr_copy
argument_list|,
name|os
operator|->
name|os_phys_buf
argument_list|,
name|DMU_OS_IS_L2CACHEABLE
argument_list|(
name|os
argument_list|)
argument_list|,
operator|&
name|zp
argument_list|,
name|dmu_objset_write_ready
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|dmu_objset_write_done
argument_list|,
name|os
argument_list|,
name|ZIO_PRIORITY_ASYNC_WRITE
argument_list|,
name|ZIO_FLAG_MUSTSUCCEED
argument_list|,
operator|&
name|zb
argument_list|)
expr_stmt|;
comment|/* 	 * Sync special dnodes - the parent IO for the sync is the root block 	 */
name|DMU_META_DNODE
argument_list|(
name|os
argument_list|)
operator|->
name|dn_zio
operator|=
name|zio
expr_stmt|;
name|dnode_sync
argument_list|(
name|DMU_META_DNODE
argument_list|(
name|os
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_phys
operator|->
name|os_flags
operator|=
name|os
operator|->
name|os_flags
expr_stmt|;
if|if
condition|(
name|DMU_USERUSED_DNODE
argument_list|(
name|os
argument_list|)
operator|&&
name|DMU_USERUSED_DNODE
argument_list|(
name|os
argument_list|)
operator|->
name|dn_type
operator|!=
name|DMU_OT_NONE
condition|)
block|{
name|DMU_USERUSED_DNODE
argument_list|(
name|os
argument_list|)
operator|->
name|dn_zio
operator|=
name|zio
expr_stmt|;
name|dnode_sync
argument_list|(
name|DMU_USERUSED_DNODE
argument_list|(
name|os
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|DMU_GROUPUSED_DNODE
argument_list|(
name|os
argument_list|)
operator|->
name|dn_zio
operator|=
name|zio
expr_stmt|;
name|dnode_sync
argument_list|(
name|DMU_GROUPUSED_DNODE
argument_list|(
name|os
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|txgoff
operator|=
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
expr_stmt|;
if|if
condition|(
name|dmu_objset_userused_enabled
argument_list|(
name|os
argument_list|)
condition|)
block|{
name|newlist
operator|=
operator|&
name|os
operator|->
name|os_synced_dnodes
expr_stmt|;
comment|/* 		 * We must create the list here because it uses the 		 * dn_dirty_link[] of this txg. 		 */
name|list_create
argument_list|(
name|newlist
argument_list|,
sizeof|sizeof
argument_list|(
name|dnode_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dnode_t
argument_list|,
name|dn_dirty_link
index|[
name|txgoff
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dmu_objset_sync_dnodes
argument_list|(
operator|&
name|os
operator|->
name|os_free_dnodes
index|[
name|txgoff
index|]
argument_list|,
name|newlist
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_objset_sync_dnodes
argument_list|(
operator|&
name|os
operator|->
name|os_dirty_dnodes
index|[
name|txgoff
index|]
argument_list|,
name|newlist
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|list
operator|=
operator|&
name|DMU_META_DNODE
argument_list|(
name|os
argument_list|)
operator|->
name|dn_dirty_records
index|[
name|txgoff
index|]
expr_stmt|;
while|while
condition|(
name|dr
operator|=
name|list_head
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|ASSERT0
argument_list|(
name|dr
operator|->
name|dr_dbuf
operator|->
name|db_level
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
name|list
argument_list|,
name|dr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
operator|->
name|dr_zio
condition|)
name|zio_nowait
argument_list|(
name|dr
operator|->
name|dr_zio
argument_list|)
expr_stmt|;
block|}
comment|/* Enable dnode backfill if enough objects have been freed. */
if|if
condition|(
name|os
operator|->
name|os_freed_dnodes
operator|>=
name|dmu_rescan_dnode_threshold
condition|)
block|{
name|os
operator|->
name|os_rescan_dnodes
operator|=
name|B_TRUE
expr_stmt|;
name|os
operator|->
name|os_freed_dnodes
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Free intent log blocks up to this tx. 	 */
name|zil_sync
argument_list|(
name|os
operator|->
name|os_zil
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_phys
operator|->
name|os_zil_header
operator|=
name|os
operator|->
name|os_zil_header
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|dmu_objset_is_dirty
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
return|return
operator|(
operator|!
name|list_is_empty
argument_list|(
operator|&
name|os
operator|->
name|os_dirty_dnodes
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|)
operator|||
operator|!
name|list_is_empty
argument_list|(
operator|&
name|os
operator|->
name|os_free_dnodes
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|objset_used_cb_t
modifier|*
name|used_cbs
index|[
name|DMU_OST_NUMTYPES
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|dmu_objset_register_type
parameter_list|(
name|dmu_objset_type_t
name|ost
parameter_list|,
name|objset_used_cb_t
modifier|*
name|cb
parameter_list|)
block|{
name|used_cbs
index|[
name|ost
index|]
operator|=
name|cb
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|dmu_objset_userused_enabled
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
return|return
operator|(
name|spa_version
argument_list|(
name|os
operator|->
name|os_spa
argument_list|)
operator|>=
name|SPA_VERSION_USERSPACE
operator|&&
name|used_cbs
index|[
name|os
operator|->
name|os_phys
operator|->
name|os_type
index|]
operator|!=
name|NULL
operator|&&
name|DMU_USERUSED_DNODE
argument_list|(
name|os
argument_list|)
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|userquota_node
block|{
name|uint64_t
name|uqn_id
decl_stmt|;
name|int64_t
name|uqn_delta
decl_stmt|;
name|avl_node_t
name|uqn_node
decl_stmt|;
block|}
name|userquota_node_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|userquota_cache
block|{
name|avl_tree_t
name|uqc_user_deltas
decl_stmt|;
name|avl_tree_t
name|uqc_group_deltas
decl_stmt|;
block|}
name|userquota_cache_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|userquota_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|l
parameter_list|,
specifier|const
name|void
modifier|*
name|r
parameter_list|)
block|{
specifier|const
name|userquota_node_t
modifier|*
name|luqn
init|=
name|l
decl_stmt|;
specifier|const
name|userquota_node_t
modifier|*
name|ruqn
init|=
name|r
decl_stmt|;
if|if
condition|(
name|luqn
operator|->
name|uqn_id
operator|<
name|ruqn
operator|->
name|uqn_id
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|luqn
operator|->
name|uqn_id
operator|>
name|ruqn
operator|->
name|uqn_id
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_userquota_cacheflush
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|userquota_cache_t
modifier|*
name|cache
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|void
modifier|*
name|cookie
decl_stmt|;
name|userquota_node_t
modifier|*
name|uqn
decl_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|cookie
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|uqn
operator|=
name|avl_destroy_nodes
argument_list|(
operator|&
name|cache
operator|->
name|uqc_user_deltas
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|VERIFY0
argument_list|(
name|zap_increment_int
argument_list|(
name|os
argument_list|,
name|DMU_USERUSED_OBJECT
argument_list|,
name|uqn
operator|->
name|uqn_id
argument_list|,
name|uqn
operator|->
name|uqn_delta
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|uqn
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|uqn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|avl_destroy
argument_list|(
operator|&
name|cache
operator|->
name|uqc_user_deltas
argument_list|)
expr_stmt|;
name|cookie
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|uqn
operator|=
name|avl_destroy_nodes
argument_list|(
operator|&
name|cache
operator|->
name|uqc_group_deltas
argument_list|,
operator|&
name|cookie
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|VERIFY0
argument_list|(
name|zap_increment_int
argument_list|(
name|os
argument_list|,
name|DMU_GROUPUSED_OBJECT
argument_list|,
name|uqn
operator|->
name|uqn_id
argument_list|,
name|uqn
operator|->
name|uqn_delta
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|uqn
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|uqn
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|avl_destroy
argument_list|(
operator|&
name|cache
operator|->
name|uqc_group_deltas
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|userquota_update_cache
parameter_list|(
name|avl_tree_t
modifier|*
name|avl
parameter_list|,
name|uint64_t
name|id
parameter_list|,
name|int64_t
name|delta
parameter_list|)
block|{
name|userquota_node_t
name|search
init|=
block|{
operator|.
name|uqn_id
operator|=
name|id
block|}
decl_stmt|;
name|avl_index_t
name|idx
decl_stmt|;
name|userquota_node_t
modifier|*
name|uqn
init|=
name|avl_find
argument_list|(
name|avl
argument_list|,
operator|&
name|search
argument_list|,
operator|&
name|idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|uqn
operator|==
name|NULL
condition|)
block|{
name|uqn
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|uqn
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|uqn
operator|->
name|uqn_id
operator|=
name|id
expr_stmt|;
name|avl_insert
argument_list|(
name|avl
argument_list|,
name|uqn
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
name|uqn
operator|->
name|uqn_delta
operator|+=
name|delta
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_userquota_update
parameter_list|(
name|userquota_cache_t
modifier|*
name|cache
parameter_list|,
name|uint64_t
name|used
parameter_list|,
name|uint64_t
name|flags
parameter_list|,
name|uint64_t
name|user
parameter_list|,
name|uint64_t
name|group
parameter_list|,
name|boolean_t
name|subtract
parameter_list|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|DNODE_FLAG_USERUSED_ACCOUNTED
operator|)
condition|)
block|{
name|int64_t
name|delta
init|=
name|DNODE_SIZE
operator|+
name|used
decl_stmt|;
if|if
condition|(
name|subtract
condition|)
name|delta
operator|=
operator|-
name|delta
expr_stmt|;
name|userquota_update_cache
argument_list|(
operator|&
name|cache
operator|->
name|uqc_user_deltas
argument_list|,
name|user
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|userquota_update_cache
argument_list|(
operator|&
name|cache
operator|->
name|uqc_group_deltas
argument_list|,
name|group
argument_list|,
name|delta
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dmu_objset_do_userquota_updates
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|list_t
modifier|*
name|list
init|=
operator|&
name|os
operator|->
name|os_synced_dnodes
decl_stmt|;
name|userquota_cache_t
name|cache
init|=
block|{
literal|0
block|}
decl_stmt|;
name|ASSERT
argument_list|(
name|list_head
argument_list|(
name|list
argument_list|)
operator|==
name|NULL
operator|||
name|dmu_objset_userused_enabled
argument_list|(
name|os
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|cache
operator|.
name|uqc_user_deltas
argument_list|,
name|userquota_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|userquota_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|userquota_node_t
argument_list|,
name|uqn_node
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|cache
operator|.
name|uqc_group_deltas
argument_list|,
name|userquota_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|userquota_node_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|userquota_node_t
argument_list|,
name|uqn_node
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|dn
operator|=
name|list_head
argument_list|(
name|list
argument_list|)
condition|)
block|{
name|int
name|flags
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|DMU_OBJECT_IS_SPECIAL
argument_list|(
name|dn
operator|->
name|dn_object
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dn
operator|->
name|dn_phys
operator|->
name|dn_type
operator|==
name|DMU_OT_NONE
operator|||
name|dn
operator|->
name|dn_phys
operator|->
name|dn_flags
operator|&
name|DNODE_FLAG_USERUSED_ACCOUNTED
argument_list|)
expr_stmt|;
comment|/* Allocate the user/groupused objects if necessary. */
if|if
condition|(
name|DMU_USERUSED_DNODE
argument_list|(
name|os
argument_list|)
operator|->
name|dn_type
operator|==
name|DMU_OT_NONE
condition|)
block|{
name|VERIFY0
argument_list|(
name|zap_create_claim
argument_list|(
name|os
argument_list|,
name|DMU_USERUSED_OBJECT
argument_list|,
name|DMU_OT_USERGROUP_USED
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_create_claim
argument_list|(
name|os
argument_list|,
name|DMU_GROUPUSED_OBJECT
argument_list|,
name|DMU_OT_USERGROUP_USED
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|flags
operator|=
name|dn
operator|->
name|dn_id_flags
expr_stmt|;
name|ASSERT
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DN_ID_OLD_EXIST
condition|)
block|{
name|do_userquota_update
argument_list|(
operator|&
name|cache
argument_list|,
name|dn
operator|->
name|dn_oldused
argument_list|,
name|dn
operator|->
name|dn_oldflags
argument_list|,
name|dn
operator|->
name|dn_olduid
argument_list|,
name|dn
operator|->
name|dn_oldgid
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|DN_ID_NEW_EXIST
condition|)
block|{
name|do_userquota_update
argument_list|(
operator|&
name|cache
argument_list|,
name|DN_USED_BYTES
argument_list|(
name|dn
operator|->
name|dn_phys
argument_list|)
argument_list|,
name|dn
operator|->
name|dn_phys
operator|->
name|dn_flags
argument_list|,
name|dn
operator|->
name|dn_newuid
argument_list|,
name|dn
operator|->
name|dn_newgid
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_oldused
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_oldflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_id_flags
operator|&
name|DN_ID_NEW_EXIST
condition|)
block|{
name|dn
operator|->
name|dn_olduid
operator|=
name|dn
operator|->
name|dn_newuid
expr_stmt|;
name|dn
operator|->
name|dn_oldgid
operator|=
name|dn
operator|->
name|dn_newgid
expr_stmt|;
name|dn
operator|->
name|dn_id_flags
operator||=
name|DN_ID_OLD_EXIST
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_bonuslen
operator|==
literal|0
condition|)
name|dn
operator|->
name|dn_id_flags
operator||=
name|DN_ID_CHKED_SPILL
expr_stmt|;
else|else
name|dn
operator|->
name|dn_id_flags
operator||=
name|DN_ID_CHKED_BONUS
expr_stmt|;
block|}
name|dn
operator|->
name|dn_id_flags
operator|&=
operator|~
operator|(
name|DN_ID_NEW_EXIST
operator|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
name|list
argument_list|,
name|dn
argument_list|)
expr_stmt|;
name|dnode_rele
argument_list|(
name|dn
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|do_userquota_cacheflush
argument_list|(
name|os
argument_list|,
operator|&
name|cache
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns a pointer to data to find uid/gid from  *  * If a dirty record for transaction group that is syncing can't  * be found then NULL is returned.  In the NULL case it is assumed  * the uid/gid aren't changing.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|dmu_objset_userquota_find_data
parameter_list|(
name|dmu_buf_impl_t
modifier|*
name|db
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dbuf_dirty_record_t
modifier|*
name|dr
decl_stmt|,
modifier|*
modifier|*
name|drp
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
if|if
condition|(
name|db
operator|->
name|db_dirtycnt
operator|==
literal|0
condition|)
return|return
operator|(
name|db
operator|->
name|db
operator|.
name|db_data
operator|)
return|;
comment|/* Nothing is changing */
for|for
control|(
name|drp
operator|=
operator|&
name|db
operator|->
name|db_last_dirty
init|;
operator|(
name|dr
operator|=
operator|*
name|drp
operator|)
operator|!=
name|NULL
condition|;
name|drp
operator|=
operator|&
name|dr
operator|->
name|dr_next
control|)
if|if
condition|(
name|dr
operator|->
name|dr_txg
operator|==
name|tx
operator|->
name|tx_txg
condition|)
break|break;
if|if
condition|(
name|dr
operator|==
name|NULL
condition|)
block|{
name|data
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|dnode_t
modifier|*
name|dn
decl_stmt|;
name|DB_DNODE_ENTER
argument_list|(
name|dr
operator|->
name|dr_dbuf
argument_list|)
expr_stmt|;
name|dn
operator|=
name|DB_DNODE
argument_list|(
name|dr
operator|->
name|dr_dbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dn
operator|->
name|dn_bonuslen
operator|==
literal|0
operator|&&
name|dr
operator|->
name|dr_dbuf
operator|->
name|db_blkid
operator|==
name|DMU_SPILL_BLKID
condition|)
name|data
operator|=
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_data
operator|->
name|b_data
expr_stmt|;
else|else
name|data
operator|=
name|dr
operator|->
name|dt
operator|.
name|dl
operator|.
name|dr_data
expr_stmt|;
name|DB_DNODE_EXIT
argument_list|(
name|dr
operator|->
name|dr_dbuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmu_objset_userquota_get_ids
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|boolean_t
name|before
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|dn
operator|->
name|dn_objset
decl_stmt|;
name|void
modifier|*
name|data
init|=
name|NULL
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
name|uint64_t
modifier|*
name|user
init|=
name|NULL
decl_stmt|;
name|uint64_t
modifier|*
name|group
init|=
name|NULL
decl_stmt|;
name|int
name|flags
init|=
name|dn
operator|->
name|dn_id_flags
decl_stmt|;
name|int
name|error
decl_stmt|;
name|boolean_t
name|have_spill
init|=
name|B_FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|dmu_objset_userused_enabled
argument_list|(
name|dn
operator|->
name|dn_objset
argument_list|)
condition|)
return|return;
if|if
condition|(
name|before
operator|&&
operator|(
name|flags
operator|&
operator|(
name|DN_ID_CHKED_BONUS
operator||
name|DN_ID_OLD_EXIST
operator||
name|DN_ID_CHKED_SPILL
operator|)
operator|)
condition|)
return|return;
if|if
condition|(
name|before
operator|&&
name|dn
operator|->
name|dn_bonuslen
operator|!=
literal|0
condition|)
name|data
operator|=
name|DN_BONUS
argument_list|(
name|dn
operator|->
name|dn_phys
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|before
operator|&&
name|dn
operator|->
name|dn_bonuslen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|dn
operator|->
name|dn_bonus
condition|)
block|{
name|db
operator|=
name|dn
operator|->
name|dn_bonus
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
name|data
operator|=
name|dmu_objset_userquota_find_data
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|data
operator|=
name|DN_BONUS
argument_list|(
name|dn
operator|->
name|dn_phys
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dn
operator|->
name|dn_bonuslen
operator|==
literal|0
operator|&&
name|dn
operator|->
name|dn_bonustype
operator|==
name|DMU_OT_SA
condition|)
block|{
name|int
name|rf
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|dn
operator|->
name|dn_struct_rwlock
argument_list|)
condition|)
name|rf
operator||=
name|DB_RF_HAVESTRUCT
expr_stmt|;
name|error
operator|=
name|dmu_spill_hold_by_dnode
argument_list|(
name|dn
argument_list|,
name|rf
operator||
name|DB_RF_MUST_SUCCEED
argument_list|,
name|FTAG
argument_list|,
operator|(
name|dmu_buf_t
operator|*
operator|*
operator|)
operator|&
name|db
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|before
operator|)
condition|?
name|db
operator|->
name|db
operator|.
name|db_data
else|:
name|dmu_objset_userquota_find_data
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|have_spill
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
name|dn
operator|->
name|dn_id_flags
operator||=
name|DN_ID_CHKED_BONUS
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|before
condition|)
block|{
name|ASSERT
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|user
operator|=
operator|&
name|dn
operator|->
name|dn_olduid
expr_stmt|;
name|group
operator|=
operator|&
name|dn
operator|->
name|dn_oldgid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|data
condition|)
block|{
name|user
operator|=
operator|&
name|dn
operator|->
name|dn_newuid
expr_stmt|;
name|group
operator|=
operator|&
name|dn
operator|->
name|dn_newgid
expr_stmt|;
block|}
comment|/* 	 * Must always call the callback in case the object 	 * type has changed and that type isn't an object type to track 	 */
name|error
operator|=
name|used_cbs
index|[
name|os
operator|->
name|os_phys
operator|->
name|os_type
index|]
operator|(
name|dn
operator|->
name|dn_bonustype
operator|,
name|data
operator|,
name|user
operator|,
name|group
operator|)
expr_stmt|;
comment|/* 	 * Preserve existing uid/gid when the callback can't determine 	 * what the new uid/gid are and the callback returned EEXIST. 	 * The EEXIST error tells us to just use the existing uid/gid. 	 * If we don't know what the old values are then just assign 	 * them to 0, since that is a new file  being created. 	 */
if|if
condition|(
operator|!
name|before
operator|&&
name|data
operator|==
name|NULL
operator|&&
name|error
operator|==
name|EEXIST
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|DN_ID_OLD_EXIST
condition|)
block|{
name|dn
operator|->
name|dn_newuid
operator|=
name|dn
operator|->
name|dn_olduid
expr_stmt|;
name|dn
operator|->
name|dn_newgid
operator|=
name|dn
operator|->
name|dn_oldgid
expr_stmt|;
block|}
else|else
block|{
name|dn
operator|->
name|dn_newuid
operator|=
literal|0
expr_stmt|;
name|dn
operator|->
name|dn_newgid
operator|=
literal|0
expr_stmt|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|db
condition|)
name|mutex_exit
argument_list|(
operator|&
name|db
operator|->
name|db_mtx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|before
condition|)
name|dn
operator|->
name|dn_id_flags
operator||=
name|DN_ID_OLD_EXIST
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|!
name|before
condition|)
name|dn
operator|->
name|dn_id_flags
operator||=
name|DN_ID_NEW_EXIST
expr_stmt|;
if|if
condition|(
name|have_spill
condition|)
block|{
name|dn
operator|->
name|dn_id_flags
operator||=
name|DN_ID_CHKED_SPILL
expr_stmt|;
block|}
else|else
block|{
name|dn
operator|->
name|dn_id_flags
operator||=
name|DN_ID_CHKED_BONUS
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|dn
operator|->
name|dn_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_spill
condition|)
name|dmu_buf_rele
argument_list|(
operator|(
name|dmu_buf_t
operator|*
operator|)
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|dmu_objset_userspace_present
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
return|return
operator|(
name|os
operator|->
name|os_phys
operator|->
name|os_flags
operator|&
name|OBJSET_FLAG_USERACCOUNTING_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_objset_userspace_upgrade
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
name|uint64_t
name|obj
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dmu_objset_userspace_present
argument_list|(
name|os
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|dmu_objset_userused_enabled
argument_list|(
name|os
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
if|if
condition|(
name|dmu_objset_is_snapshot
argument_list|(
name|os
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
comment|/* 	 * We simply need to mark every object dirty, so that it will be 	 * synced out and now accounted.  If this is called 	 * concurrently, or if we already did some work before crashing, 	 * that's fine, since we track each object's accounted state 	 * independently. 	 */
for|for
control|(
name|obj
operator|=
literal|0
init|;
name|err
operator|==
literal|0
condition|;
name|err
operator|=
name|dmu_object_next
argument_list|(
name|os
argument_list|,
operator|&
name|obj
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
control|)
block|{
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|int
name|objerr
decl_stmt|;
if|if
condition|(
name|issig
argument_list|(
name|JUSTLOOKING
argument_list|)
operator|&&
name|issig
argument_list|(
name|FORREAL
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINTR
argument_list|)
operator|)
return|;
name|objerr
operator|=
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|objerr
operator|!=
literal|0
condition|)
continue|continue;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|objerr
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|objerr
operator|!=
literal|0
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
name|os
operator|->
name|os_flags
operator||=
name|OBJSET_FLAG_USERACCOUNTING_COMPLETE
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmu_objset_space
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
modifier|*
name|refdbytesp
parameter_list|,
name|uint64_t
modifier|*
name|availbytesp
parameter_list|,
name|uint64_t
modifier|*
name|usedobjsp
parameter_list|,
name|uint64_t
modifier|*
name|availobjsp
parameter_list|)
block|{
name|dsl_dataset_space
argument_list|(
name|os
operator|->
name|os_dsl_dataset
argument_list|,
name|refdbytesp
argument_list|,
name|availbytesp
argument_list|,
name|usedobjsp
argument_list|,
name|availobjsp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|dmu_objset_fsid_guid
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
return|return
operator|(
name|dsl_dataset_fsid_guid
argument_list|(
name|os
operator|->
name|os_dsl_dataset
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmu_objset_fast_stat
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|dmu_objset_stats_t
modifier|*
name|stat
parameter_list|)
block|{
name|stat
operator|->
name|dds_type
operator|=
name|os
operator|->
name|os_phys
operator|->
name|os_type
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|os_dsl_dataset
condition|)
name|dsl_dataset_fast_stat
argument_list|(
name|os
operator|->
name|os_dsl_dataset
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dmu_objset_stats
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|os
operator|->
name|os_dsl_dataset
operator|||
name|os
operator|->
name|os_phys
operator|->
name|os_type
operator|==
name|DMU_OST_META
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|->
name|os_dsl_dataset
operator|!=
name|NULL
condition|)
name|dsl_dataset_stats
argument_list|(
name|os
operator|->
name|os_dsl_dataset
argument_list|,
name|nv
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_TYPE
argument_list|,
name|os
operator|->
name|os_phys
operator|->
name|os_type
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_USERACCOUNTING
argument_list|,
name|dmu_objset_userspace_present
argument_list|(
name|os
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dmu_objset_is_snapshot
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
if|if
condition|(
name|os
operator|->
name|os_dsl_dataset
operator|!=
name|NULL
condition|)
return|return
operator|(
name|os
operator|->
name|os_dsl_dataset
operator|->
name|ds_is_snapshot
operator|)
return|;
else|else
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_snapshot_realname
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|real
parameter_list|,
name|int
name|maxlen
parameter_list|,
name|boolean_t
modifier|*
name|conflict
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|os
operator|->
name|os_dsl_dataset
decl_stmt|;
name|uint64_t
name|ignored
decl_stmt|;
if|if
condition|(
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_snapnames_zapobj
operator|==
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
return|return
operator|(
name|zap_lookup_norm
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|name
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|ignored
argument_list|,
name|MT_NORMALIZE
argument_list|,
name|real
argument_list|,
name|maxlen
argument_list|,
name|conflict
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_snapshot_list_next
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|int
name|namelen
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
modifier|*
name|idp
parameter_list|,
name|uint64_t
modifier|*
name|offp
parameter_list|,
name|boolean_t
modifier|*
name|case_conflict
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|os
operator|->
name|os_dsl_dataset
decl_stmt|;
name|zap_cursor_t
name|cursor
decl_stmt|;
name|zap_attribute_t
name|attr
decl_stmt|;
name|ASSERT
argument_list|(
name|dsl_pool_config_held
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_snapnames_zapobj
operator|==
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
name|zap_cursor_init_serialized
argument_list|(
operator|&
name|cursor
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_snapnames_zapobj
argument_list|,
operator|*
name|offp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zap_cursor_retrieve
argument_list|(
operator|&
name|cursor
argument_list|,
operator|&
name|attr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zap_cursor_fini
argument_list|(
operator|&
name|cursor
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|attr
operator|.
name|za_name
argument_list|)
operator|+
literal|1
operator|>
name|namelen
condition|)
block|{
name|zap_cursor_fini
argument_list|(
operator|&
name|cursor
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENAMETOOLONG
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|attr
operator|.
name|za_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
condition|)
operator|*
name|idp
operator|=
name|attr
operator|.
name|za_first_integer
expr_stmt|;
if|if
condition|(
name|case_conflict
condition|)
operator|*
name|case_conflict
operator|=
name|attr
operator|.
name|za_normalization_conflict
expr_stmt|;
name|zap_cursor_advance
argument_list|(
operator|&
name|cursor
argument_list|)
expr_stmt|;
operator|*
name|offp
operator|=
name|zap_cursor_serialize
argument_list|(
operator|&
name|cursor
argument_list|)
expr_stmt|;
name|zap_cursor_fini
argument_list|(
operator|&
name|cursor
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dmu_dir_list_next
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|int
name|namelen
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
modifier|*
name|idp
parameter_list|,
name|uint64_t
modifier|*
name|offp
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
init|=
name|os
operator|->
name|os_dsl_dataset
operator|->
name|ds_dir
decl_stmt|;
name|zap_cursor_t
name|cursor
decl_stmt|;
name|zap_attribute_t
name|attr
decl_stmt|;
comment|/* there is no next dir on a snapshot! */
if|if
condition|(
name|os
operator|->
name|os_dsl_dataset
operator|->
name|ds_object
operator|!=
name|dsl_dir_phys
argument_list|(
name|dd
argument_list|)
operator|->
name|dd_head_dataset_obj
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
name|zap_cursor_init_serialized
argument_list|(
operator|&
name|cursor
argument_list|,
name|dd
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
argument_list|,
name|dsl_dir_phys
argument_list|(
name|dd
argument_list|)
operator|->
name|dd_child_dir_zapobj
argument_list|,
operator|*
name|offp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zap_cursor_retrieve
argument_list|(
operator|&
name|cursor
argument_list|,
operator|&
name|attr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zap_cursor_fini
argument_list|(
operator|&
name|cursor
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|attr
operator|.
name|za_name
argument_list|)
operator|+
literal|1
operator|>
name|namelen
condition|)
block|{
name|zap_cursor_fini
argument_list|(
operator|&
name|cursor
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENAMETOOLONG
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
name|attr
operator|.
name|za_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|idp
condition|)
operator|*
name|idp
operator|=
name|attr
operator|.
name|za_first_integer
expr_stmt|;
name|zap_cursor_advance
argument_list|(
operator|&
name|cursor
argument_list|)
expr_stmt|;
operator|*
name|offp
operator|=
name|zap_cursor_serialize
argument_list|(
operator|&
name|cursor
argument_list|)
expr_stmt|;
name|zap_cursor_fini
argument_list|(
operator|&
name|cursor
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|dmu_objset_find_ctx
block|{
name|taskq_t
modifier|*
name|dc_tq
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dc_dp
decl_stmt|;
name|uint64_t
name|dc_ddobj
decl_stmt|;
name|char
modifier|*
name|dc_ddname
decl_stmt|;
comment|/* last component of ddobj's name */
name|int
function_decl|(
modifier|*
name|dc_func
function_decl|)
parameter_list|(
name|dsl_pool_t
modifier|*
parameter_list|,
name|dsl_dataset_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|dc_arg
decl_stmt|;
name|int
name|dc_flags
decl_stmt|;
name|kmutex_t
modifier|*
name|dc_error_lock
decl_stmt|;
name|int
modifier|*
name|dc_error
decl_stmt|;
block|}
name|dmu_objset_find_ctx_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|dmu_objset_find_dp_impl
parameter_list|(
name|dmu_objset_find_ctx_t
modifier|*
name|dcp
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dcp
operator|->
name|dc_dp
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
modifier|*
name|attr
decl_stmt|;
name|uint64_t
name|thisobj
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* don't process if there already was an error */
if|if
condition|(
operator|*
name|dcp
operator|->
name|dc_error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Note: passing the name (dc_ddname) here is optional, but it 	 * improves performance because we don't need to call 	 * zap_value_search() to determine the name. 	 */
name|err
operator|=
name|dsl_dir_hold_obj
argument_list|(
name|dp
argument_list|,
name|dcp
operator|->
name|dc_ddobj
argument_list|,
name|dcp
operator|->
name|dc_ddname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* Don't visit hidden ($MOS& $ORIGIN) objsets. */
if|if
condition|(
name|dd
operator|->
name|dd_myname
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
block|{
name|dsl_dir_rele
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|thisobj
operator|=
name|dsl_dir_phys
argument_list|(
name|dd
argument_list|)
operator|->
name|dd_head_dataset_obj
expr_stmt|;
name|attr
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zap_attribute_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * Iterate over all children. 	 */
if|if
condition|(
name|dcp
operator|->
name|dc_flags
operator|&
name|DS_FIND_CHILDREN
condition|)
block|{
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dsl_dir_phys
argument_list|(
name|dd
argument_list|)
operator|->
name|dd_child_dir_zapobj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
name|attr
argument_list|)
operator|==
literal|0
condition|;
operator|(
name|void
operator|)
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|ASSERT3U
argument_list|(
name|attr
operator|->
name|za_integer_length
argument_list|,
operator|==
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|attr
operator|->
name|za_num_integers
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dmu_objset_find_ctx_t
modifier|*
name|child_dcp
init|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|child_dcp
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
operator|*
name|child_dcp
operator|=
operator|*
name|dcp
expr_stmt|;
name|child_dcp
operator|->
name|dc_ddobj
operator|=
name|attr
operator|->
name|za_first_integer
expr_stmt|;
name|child_dcp
operator|->
name|dc_ddname
operator|=
name|spa_strdup
argument_list|(
name|attr
operator|->
name|za_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcp
operator|->
name|dc_tq
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|taskq_dispatch
argument_list|(
name|dcp
operator|->
name|dc_tq
argument_list|,
name|dmu_objset_find_dp_cb
argument_list|,
name|child_dcp
argument_list|,
name|TQ_SLEEP
argument_list|)
expr_stmt|;
else|else
name|dmu_objset_find_dp_impl
argument_list|(
name|child_dcp
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Iterate over all snapshots. 	 */
if|if
condition|(
name|dcp
operator|->
name|dc_flags
operator|&
name|DS_FIND_SNAPSHOTS
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|thisobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|snapobj
decl_stmt|;
name|snapobj
operator|=
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_snapnames_zapobj
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|snapobj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
name|attr
argument_list|)
operator|==
literal|0
condition|;
operator|(
name|void
operator|)
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|ASSERT3U
argument_list|(
name|attr
operator|->
name|za_integer_length
argument_list|,
operator|==
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|attr
operator|->
name|za_num_integers
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|attr
operator|->
name|za_first_integer
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
break|break;
name|err
operator|=
name|dcp
operator|->
name|dc_func
argument_list|(
name|dp
argument_list|,
name|ds
argument_list|,
name|dcp
operator|->
name|dc_arg
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
break|break;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
block|}
name|kmem_free
argument_list|(
name|attr
argument_list|,
sizeof|sizeof
argument_list|(
name|zap_attribute_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|dsl_dir_rele
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Apply to self. 	 */
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|thisobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
comment|/* 	 * Note: we hold the dir while calling dsl_dataset_hold_obj() so 	 * that the dir will remain cached, and we won't have to re-instantiate 	 * it (which could be expensive due to finding its name via 	 * zap_value_search()). 	 */
name|dsl_dir_rele
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|dcp
operator|->
name|dc_func
argument_list|(
name|dp
argument_list|,
name|ds
argument_list|,
name|dcp
operator|->
name|dc_arg
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|mutex_enter
argument_list|(
name|dcp
operator|->
name|dc_error_lock
argument_list|)
expr_stmt|;
comment|/* only keep first error */
if|if
condition|(
operator|*
name|dcp
operator|->
name|dc_error
operator|==
literal|0
condition|)
operator|*
name|dcp
operator|->
name|dc_error
operator|=
name|err
expr_stmt|;
name|mutex_exit
argument_list|(
name|dcp
operator|->
name|dc_error_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dcp
operator|->
name|dc_ddname
operator|!=
name|NULL
condition|)
name|spa_strfree
argument_list|(
name|dcp
operator|->
name|dc_ddname
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|dcp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dcp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dmu_objset_find_dp_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dmu_objset_find_ctx_t
modifier|*
name|dcp
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dcp
operator|->
name|dc_dp
decl_stmt|;
comment|/* 	 * We need to get a pool_config_lock here, as there are several 	 * asssert(pool_config_held) down the stack. Getting a lock via 	 * dsl_pool_config_enter is risky, as it might be stalled by a 	 * pending writer. This would deadlock, as the write lock can 	 * only be granted when our parent thread gives up the lock. 	 * The _prio interface gives us priority over a pending writer. 	 */
name|dsl_pool_config_enter_prio
argument_list|(
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dmu_objset_find_dp_impl
argument_list|(
name|dcp
argument_list|)
expr_stmt|;
name|dsl_pool_config_exit
argument_list|(
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find objsets under and including ddobj, call func(ds) on each.  * The order for the enumeration is completely undefined.  * func is called with dsl_pool_config held.  */
end_comment

begin_function
name|int
name|dmu_objset_find_dp
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|ddobj
parameter_list|,
name|int
name|func
parameter_list|(
name|dsl_pool_t
modifier|*
parameter_list|,
name|dsl_dataset_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|taskq_t
modifier|*
name|tq
init|=
name|NULL
decl_stmt|;
name|int
name|ntasks
decl_stmt|;
name|dmu_objset_find_ctx_t
modifier|*
name|dcp
decl_stmt|;
name|kmutex_t
name|err_lock
decl_stmt|;
name|mutex_init
argument_list|(
operator|&
name|err_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dcp
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dcp
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|dcp
operator|->
name|dc_tq
operator|=
name|NULL
expr_stmt|;
name|dcp
operator|->
name|dc_dp
operator|=
name|dp
expr_stmt|;
name|dcp
operator|->
name|dc_ddobj
operator|=
name|ddobj
expr_stmt|;
name|dcp
operator|->
name|dc_ddname
operator|=
name|NULL
expr_stmt|;
name|dcp
operator|->
name|dc_func
operator|=
name|func
expr_stmt|;
name|dcp
operator|->
name|dc_arg
operator|=
name|arg
expr_stmt|;
name|dcp
operator|->
name|dc_flags
operator|=
name|flags
expr_stmt|;
name|dcp
operator|->
name|dc_error_lock
operator|=
operator|&
name|err_lock
expr_stmt|;
name|dcp
operator|->
name|dc_error
operator|=
operator|&
name|error
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|DS_FIND_SERIALIZE
operator|)
operator|||
name|dsl_pool_config_held_writer
argument_list|(
name|dp
argument_list|)
condition|)
block|{
comment|/* 		 * In case a write lock is held we can't make use of 		 * parallelism, as down the stack of the worker threads 		 * the lock is asserted via dsl_pool_config_held. 		 * In case of a read lock this is solved by getting a read 		 * lock in each worker thread, which isn't possible in case 		 * of a writer lock. So we fall back to the synchronous path 		 * here. 		 * In the future it might be possible to get some magic into 		 * dsl_pool_config_held in a way that it returns true for 		 * the worker threads so that a single lock held from this 		 * thread suffices. For now, stay single threaded. 		 */
name|dmu_objset_find_dp_impl
argument_list|(
name|dcp
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|err_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ntasks
operator|=
name|dmu_find_threads
expr_stmt|;
if|if
condition|(
name|ntasks
operator|==
literal|0
condition|)
name|ntasks
operator|=
name|vdev_count_leaves
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|*
literal|4
expr_stmt|;
name|tq
operator|=
name|taskq_create
argument_list|(
literal|"dmu_objset_find"
argument_list|,
name|ntasks
argument_list|,
name|minclsyspri
argument_list|,
name|ntasks
argument_list|,
name|INT_MAX
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tq
operator|==
name|NULL
condition|)
block|{
name|kmem_free
argument_list|(
name|dcp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dcp
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|err_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOMEM
argument_list|)
operator|)
return|;
block|}
name|dcp
operator|->
name|dc_tq
operator|=
name|tq
expr_stmt|;
comment|/* dcp will be freed by task */
operator|(
name|void
operator|)
name|taskq_dispatch
argument_list|(
name|tq
argument_list|,
name|dmu_objset_find_dp_cb
argument_list|,
name|dcp
argument_list|,
name|TQ_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * PORTING: this code relies on the property of taskq_wait to wait 	 * until no more tasks are queued and no more tasks are active. As 	 * we always queue new tasks from within other tasks, task_wait 	 * reliably waits for the full recursion to finish, even though we 	 * enqueue new tasks after taskq_wait has been called. 	 * On platforms other than illumos, taskq_wait may not have this 	 * property. 	 */
name|taskq_wait
argument_list|(
name|tq
argument_list|)
expr_stmt|;
name|taskq_destroy
argument_list|(
name|tq
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|err_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find all objsets under name, and for each, call 'func(child_name, arg)'.  * The dp_config_rwlock must not be held when this is called, and it  * will not be held when the callback is called.  * Therefore this function should only be used when the pool is not changing  * (e.g. in syncing context), or the callback can deal with the possible races.  */
end_comment

begin_function
specifier|static
name|int
name|dmu_objset_find_impl
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|func
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
modifier|*
name|attr
decl_stmt|;
name|char
modifier|*
name|child
decl_stmt|;
name|uint64_t
name|thisobj
decl_stmt|;
name|int
name|err
decl_stmt|;
name|dsl_pool_config_enter
argument_list|(
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_dir_hold
argument_list|(
name|dp
argument_list|,
name|name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|dsl_pool_config_exit
argument_list|(
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* Don't visit hidden ($MOS& $ORIGIN) objsets. */
if|if
condition|(
name|dd
operator|->
name|dd_myname
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
block|{
name|dsl_dir_rele
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dsl_pool_config_exit
argument_list|(
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|thisobj
operator|=
name|dsl_dir_phys
argument_list|(
name|dd
argument_list|)
operator|->
name|dd_head_dataset_obj
expr_stmt|;
name|attr
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zap_attribute_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * Iterate over all children. 	 */
if|if
condition|(
name|flags
operator|&
name|DS_FIND_CHILDREN
condition|)
block|{
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dsl_dir_phys
argument_list|(
name|dd
argument_list|)
operator|->
name|dd_child_dir_zapobj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
name|attr
argument_list|)
operator|==
literal|0
condition|;
operator|(
name|void
operator|)
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|ASSERT3U
argument_list|(
name|attr
operator|->
name|za_integer_length
argument_list|,
operator|==
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|attr
operator|->
name|za_num_integers
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|child
operator|=
name|kmem_asprintf
argument_list|(
literal|"%s/%s"
argument_list|,
name|name
argument_list|,
name|attr
operator|->
name|za_name
argument_list|)
expr_stmt|;
name|dsl_pool_config_exit
argument_list|(
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_objset_find_impl
argument_list|(
name|spa
argument_list|,
name|child
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|dsl_pool_config_enter
argument_list|(
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|strfree
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
break|break;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|dsl_dir_rele
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dsl_pool_config_exit
argument_list|(
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|attr
argument_list|,
sizeof|sizeof
argument_list|(
name|zap_attribute_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
comment|/* 	 * Iterate over all snapshots. 	 */
if|if
condition|(
name|flags
operator|&
name|DS_FIND_SNAPSHOTS
condition|)
block|{
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|thisobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|snapobj
decl_stmt|;
name|snapobj
operator|=
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_snapnames_zapobj
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|snapobj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
name|attr
argument_list|)
operator|==
literal|0
condition|;
operator|(
name|void
operator|)
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|ASSERT3U
argument_list|(
name|attr
operator|->
name|za_integer_length
argument_list|,
operator|==
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|attr
operator|->
name|za_num_integers
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|child
operator|=
name|kmem_asprintf
argument_list|(
literal|"%s@%s"
argument_list|,
name|name
argument_list|,
name|attr
operator|->
name|za_name
argument_list|)
expr_stmt|;
name|dsl_pool_config_exit
argument_list|(
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|err
operator|=
name|func
argument_list|(
name|child
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|dsl_pool_config_enter
argument_list|(
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|strfree
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
break|break;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
block|}
name|dsl_dir_rele
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|attr
argument_list|,
sizeof|sizeof
argument_list|(
name|zap_attribute_t
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_pool_config_exit
argument_list|(
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Apply to self. */
return|return
operator|(
name|func
argument_list|(
name|name
argument_list|,
name|arg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * See comment above dmu_objset_find_impl().  */
end_comment

begin_function
name|int
name|dmu_objset_find
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|func
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|spa_open
argument_list|(
name|name
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|dmu_objset_find_impl
argument_list|(
name|spa
argument_list|,
name|name
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dmu_objset_set_user
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|user_ptr
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|os
operator|->
name|os_user_ptr_lock
argument_list|)
argument_list|)
expr_stmt|;
name|os
operator|->
name|os_user_ptr
operator|=
name|user_ptr
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|dmu_objset_get_user
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|os
operator|->
name|os_user_ptr_lock
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|os
operator|->
name|os_user_ptr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine name of filesystem, given name of snapshot.  * buf must be at least ZFS_MAX_DATASET_NAME_LEN bytes  */
end_comment

begin_function
name|int
name|dmu_fsname
parameter_list|(
specifier|const
name|char
modifier|*
name|snapname
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|char
modifier|*
name|atp
init|=
name|strchr
argument_list|(
name|snapname
argument_list|,
literal|'@'
argument_list|)
decl_stmt|;
if|if
condition|(
name|atp
operator|==
name|NULL
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|atp
operator|-
name|snapname
operator|>=
name|ZFS_MAX_DATASET_NAME_LEN
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENAMETOOLONG
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|buf
argument_list|,
name|snapname
argument_list|,
name|atp
operator|-
name|snapname
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

