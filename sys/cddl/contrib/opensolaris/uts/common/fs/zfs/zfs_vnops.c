begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2012, 2015 by Delphix. All rights reserved.  * Copyright 2014 Nexenta Systems, Inc.  All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  */
end_comment

begin_comment
comment|/* Portions Copyright 2007 Jeremy Teo */
end_comment

begin_comment
comment|/* Portions Copyright 2010 Robert Milkowski */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/vfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/vm.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskq.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/atomic.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/txg.h>
end_include

begin_include
include|#
directive|include
file|<sys/dbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/sa.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/policy.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sid.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ctldir.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_fuid.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_sa.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_rlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/extdirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/kidmap.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/acl.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_comment
comment|/*  * Programming rules.  *  * Each vnode op performs some logical unit of work.  To do this, the ZPL must  * properly lock its in-core state, create a DMU transaction, do the work,  * record this work in the intent log (ZIL), commit the DMU transaction,  * and wait for the intent log to commit if it is a synchronous operation.  * Moreover, the vnode ops must work in both normal and log replay context.  * The ordering of events is important to avoid deadlocks and references  * to freed memory.  The example below illustrates the following Big Rules:  *  *  (1)	A check must be made in each zfs thread for a mounted file system.  *	This is done avoiding races using ZFS_ENTER(zfsvfs).  *	A ZFS_EXIT(zfsvfs) is needed before all returns.  Any znodes  *	must be checked with ZFS_VERIFY_ZP(zp).  Both of these macros  *	can return EIO from the calling function.  *  *  (2)	VN_RELE() should always be the last thing except for zil_commit()  *	(if necessary) and ZFS_EXIT(). This is for 3 reasons:  *	First, if it's the last reference, the vnode/znode  *	can be freed, so the zp may point to freed memory.  Second, the last  *	reference will call zfs_zinactive(), which may induce a lot of work --  *	pushing cached pages (which acquires range locks) and syncing out  *	cached atime changes.  Third, zfs_zinactive() may require a new tx,  *	which could deadlock the system if you were already holding one.  *	If you must call VN_RELE() within a tx then use VN_RELE_ASYNC().  *  *  (3)	All range locks must be grabbed before calling dmu_tx_assign(),  *	as they can span dmu_tx_assign() calls.  *  *  (4) If ZPL locks are held, pass TXG_NOWAIT as the second argument to  *      dmu_tx_assign().  This is critical because we don't want to block  *      while holding locks.  *  *	If no ZPL locks are held (aside from ZFS_ENTER()), use TXG_WAIT.  This  *	reduces lock contention and CPU usage when we must wait (note that if  *	throughput is constrained by the storage, nearly every transaction  *	must wait).  *  *      Note, in particular, that if a lock is sometimes acquired before  *      the tx assigns, and sometimes after (e.g. z_lock), then failing  *      to use a non-blocking assign can deadlock the system.  The scenario:  *  *	Thread A has grabbed a lock before calling dmu_tx_assign().  *	Thread B is in an already-assigned tx, and blocks for this lock.  *	Thread A calls dmu_tx_assign(TXG_WAIT) and blocks in txg_wait_open()  *	forever, because the previous txg can't quiesce until B's tx commits.  *  *	If dmu_tx_assign() returns ERESTART and zfsvfs->z_assign is TXG_NOWAIT,  *	then drop all locks, call dmu_tx_wait(), and try again.  On subsequent  *	calls to dmu_tx_assign(), pass TXG_WAITED rather than TXG_NOWAIT,  *	to indicate that this operation has already called dmu_tx_wait().  *	This will ensure that we don't retry forever, waiting a short bit  *	each time.  *  *  (5)	If the operation succeeded, generate the intent log entry for it  *	before dropping locks.  This ensures that the ordering of events  *	in the intent log matches the order in which they actually occurred.  *	During ZIL replay the zfs_log_* functions will update the sequence  *	number to indicate the zil transaction has replayed.  *  *  (6)	At the end of each vnode op, the DMU tx must always commit,  *	regardless of whether there were any errors.  *  *  (7)	After dropping all locks, invoke zil_commit(zilog, foid)  *	to ensure that synchronous semantics are provided when necessary.  *  * In general, this is how things should be ordered in each vnode op:  *  *	ZFS_ENTER(zfsvfs);		// exit if unmounted  * top:  *	zfs_dirent_lookup(&dl, ...)	// lock directory entry (may VN_HOLD())  *	rw_enter(...);			// grab any other locks you need  *	tx = dmu_tx_create(...);	// get DMU tx  *	dmu_tx_hold_*();		// hold each object you might modify  *	error = dmu_tx_assign(tx, waited ? TXG_WAITED : TXG_NOWAIT);  *	if (error) {  *		rw_exit(...);		// drop locks  *		zfs_dirent_unlock(dl);	// unlock directory entry  *		VN_RELE(...);		// release held vnodes  *		if (error == ERESTART) {  *			waited = B_TRUE;  *			dmu_tx_wait(tx);  *			dmu_tx_abort(tx);  *			goto top;  *		}  *		dmu_tx_abort(tx);	// abort DMU tx  *		ZFS_EXIT(zfsvfs);	// finished in zfs  *		return (error);		// really out of space  *	}  *	error = do_real_work();		// do whatever this VOP does  *	if (error == 0)  *		zfs_log_*(...);		// on success, make ZIL entry  *	dmu_tx_commit(tx);		// commit DMU tx -- error or not  *	rw_exit(...);			// drop locks  *	zfs_dirent_unlock(dl);		// unlock directory entry  *	VN_RELE(...);			// release held vnodes  *	zil_commit(zilog, foid);	// synchronous when necessary  *	ZFS_EXIT(zfsvfs);		// finished in zfs  *	return (error);			// done, report error  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_open
parameter_list|(
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|int
name|flag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
operator|*
name|vpp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|&&
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_APPENDONLY
operator|)
operator|&&
operator|(
operator|(
name|flag
operator|&
name|FAPPEND
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|zfs_has_ctldir
argument_list|(
name|zp
argument_list|)
operator|&&
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_vscan
operator|&&
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|==
name|VREG
operator|&&
operator|!
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_AV_QUARANTINED
operator|)
operator|&&
name|zp
operator|->
name|z_size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fs_vscan
argument_list|(
operator|*
name|vpp
argument_list|,
name|cr
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EACCES
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* Keep a count of the synchronous opens in the znode */
if|if
condition|(
name|flag
operator|&
operator|(
name|FSYNC
operator||
name|FDSYNC
operator|)
condition|)
name|atomic_inc_32
argument_list|(
operator|&
name|zp
operator|->
name|z_sync_cnt
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_close
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|count
parameter_list|,
name|offset_t
name|offset
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
comment|/* 	 * Clean up any locks held by this process on the vp. 	 */
name|cleanlocks
argument_list|(
name|vp
argument_list|,
name|ddi_get_pid
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cleanshares
argument_list|(
name|vp
argument_list|,
name|ddi_get_pid
argument_list|()
argument_list|)
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
comment|/* Decrement the synchronous opens in the znode */
if|if
condition|(
operator|(
name|flag
operator|&
operator|(
name|FSYNC
operator||
name|FDSYNC
operator|)
operator|)
operator|&&
operator|(
name|count
operator|==
literal|1
operator|)
condition|)
name|atomic_dec_32
argument_list|(
operator|&
name|zp
operator|->
name|z_sync_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zfs_has_ctldir
argument_list|(
name|zp
argument_list|)
operator|&&
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_vscan
operator|&&
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|==
name|VREG
operator|&&
operator|!
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_AV_QUARANTINED
operator|)
operator|&&
name|zp
operator|->
name|z_size
operator|>
literal|0
condition|)
name|VERIFY
argument_list|(
name|fs_vscan
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lseek support for finding holes (cmd == _FIO_SEEK_HOLE) and  * data (cmd == _FIO_SEEK_DATA). "off" is an in/out parameter.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_holey
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|offset_t
modifier|*
name|off
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|uint64_t
name|noff
init|=
operator|(
name|uint64_t
operator|)
operator|*
name|off
decl_stmt|;
comment|/* new offset */
name|uint64_t
name|file_sz
decl_stmt|;
name|int
name|error
decl_stmt|;
name|boolean_t
name|hole
decl_stmt|;
name|file_sz
operator|=
name|zp
operator|->
name|z_size
expr_stmt|;
if|if
condition|(
name|noff
operator|>=
name|file_sz
condition|)
block|{
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|cmd
operator|==
name|_FIO_SEEK_HOLE
condition|)
name|hole
operator|=
name|B_TRUE
expr_stmt|;
else|else
name|hole
operator|=
name|B_FALSE
expr_stmt|;
name|error
operator|=
name|dmu_offset_next
argument_list|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|hole
argument_list|,
operator|&
name|noff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ESRCH
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
comment|/* 	 * We could find a hole that begins after the logical end-of-file, 	 * because dmu_offset_next() only works on whole blocks.  If the 	 * EOF falls mid-block, then indicate that the "virtual hole" 	 * at the end of the file begins at the logical EOF, rather than 	 * at the end of the last block. 	 */
if|if
condition|(
name|noff
operator|>
name|file_sz
condition|)
block|{
name|ASSERT
argument_list|(
name|hole
argument_list|)
expr_stmt|;
name|noff
operator|=
name|file_sz
expr_stmt|;
block|}
if|if
condition|(
name|noff
operator|<
operator|*
name|off
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|off
operator|=
name|noff
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_ioctl
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|u_long
name|com
parameter_list|,
name|intptr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|cred_t
modifier|*
name|cred
parameter_list|,
name|int
modifier|*
name|rvalp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|offset_t
name|off
decl_stmt|;
name|offset_t
name|ndata
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|int
name|error
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
decl_stmt|;
name|znode_t
modifier|*
name|zp
decl_stmt|;
switch|switch
condition|(
name|com
condition|)
block|{
case|case
name|_FIOFFS
case|:
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * The following two ioctls are used by bfu.  Faking out, 		 * necessary to avoid bfu errors. 		 */
block|}
case|case
name|_FIOGDIO
case|:
case|case
name|_FIOSDIO
case|:
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|_FIO_SEEK_DATA
case|:
case|case
name|_FIO_SEEK_HOLE
case|:
block|{
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|ddi_copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|data
argument_list|,
operator|&
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|off
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EFAULT
argument_list|)
operator|)
return|;
else|#
directive|else
name|off
operator|=
operator|*
operator|(
name|offset_t
operator|*
operator|)
name|data
expr_stmt|;
endif|#
directive|endif
name|zp
operator|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|zfsvfs
operator|=
name|zp
operator|->
name|z_zfsvfs
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
comment|/* offset parameter is in/out */
name|error
operator|=
name|zfs_holey
argument_list|(
name|vp
argument_list|,
name|com
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|ddi_copyout
argument_list|(
operator|&
name|off
argument_list|,
operator|(
name|void
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|off
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EFAULT
argument_list|)
operator|)
return|;
else|#
directive|else
operator|*
operator|(
name|offset_t
operator|*
operator|)
name|data
operator|=
name|off
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|illumos
case|case
name|_FIO_COUNT_FILLED
case|:
block|{
comment|/* 		 * _FIO_COUNT_FILLED adds a new ioctl command which 		 * exposes the number of filled blocks in a 		 * ZFS object. 		 */
name|zp
operator|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|zfsvfs
operator|=
name|zp
operator|->
name|z_zfsvfs
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
comment|/* 		 * Wait for all dirty blocks for this object 		 * to get synced out to disk, and the DMU info 		 * updated. 		 */
name|error
operator|=
name|dmu_object_wait_synced
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * Retrieve fill count from DMU object. 		 */
name|error
operator|=
name|dmu_object_info
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ndata
operator|=
name|doi
operator|.
name|doi_fill_count
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddi_copyout
argument_list|(
operator|&
name|ndata
argument_list|,
operator|(
name|void
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|ndata
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EFAULT
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
block|}
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTTY
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|vm_page_t
name|page_busy
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int64_t
name|start
parameter_list|,
name|int64_t
name|off
parameter_list|,
name|int64_t
name|nbytes
parameter_list|)
block|{
name|vm_object_t
name|obj
decl_stmt|;
name|vm_page_t
name|pp
decl_stmt|;
name|int64_t
name|end
decl_stmt|;
comment|/* 	 * At present vm_page_clear_dirty extends the cleared range to DEV_BSIZE 	 * aligned boundaries, if the range is not aligned.  As a result a 	 * DEV_BSIZE subrange with partially dirty data may get marked as clean. 	 * It may happen that all DEV_BSIZE subranges are marked clean and thus 	 * the whole page would be considred clean despite have some dirty data. 	 * For this reason we should shrink the range to DEV_BSIZE aligned 	 * boundaries before calling vm_page_clear_dirty. 	 */
name|end
operator|=
name|rounddown2
argument_list|(
name|off
operator|+
name|nbytes
argument_list|,
name|DEV_BSIZE
argument_list|)
expr_stmt|;
name|off
operator|=
name|roundup2
argument_list|(
name|off
argument_list|,
name|DEV_BSIZE
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|end
operator|-
name|off
expr_stmt|;
name|obj
operator|=
name|vp
operator|->
name|v_object
expr_stmt|;
name|zfs_vmobject_assert_wlocked
argument_list|(
name|obj
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|pp
operator|=
name|vm_page_lookup
argument_list|(
name|obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|start
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|pp
operator|->
name|valid
condition|)
block|{
if|if
condition|(
name|vm_page_xbusied
argument_list|(
name|pp
argument_list|)
condition|)
block|{
comment|/* 				 * Reference the page before unlocking and 				 * sleeping so that the page daemon is less 				 * likely to reclaim it. 				 */
name|vm_page_reference
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|zfs_vmobject_wunlock
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|vm_page_busy_sleep
argument_list|(
name|pp
argument_list|,
literal|"zfsmwb"
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|zfs_vmobject_wlock
argument_list|(
name|obj
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|vm_page_sbusy
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pp
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|pp
operator|->
name|valid
argument_list|)
expr_stmt|;
name|pp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|!=
name|NULL
condition|)
block|{
name|ASSERT3U
argument_list|(
name|pp
operator|->
name|valid
argument_list|,
operator|==
argument_list|,
name|VM_PAGE_BITS_ALL
argument_list|)
expr_stmt|;
name|vm_object_pip_add
argument_list|(
name|obj
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pmap_remove_write
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nbytes
operator|!=
literal|0
condition|)
name|vm_page_clear_dirty
argument_list|(
name|pp
argument_list|,
name|off
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|pp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|page_unbusy
parameter_list|(
name|vm_page_t
name|pp
parameter_list|)
block|{
name|vm_page_sunbusy
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|vm_object_pip_subtract
argument_list|(
name|pp
operator|->
name|object
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|vm_page_t
name|page_hold
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int64_t
name|start
parameter_list|)
block|{
name|vm_object_t
name|obj
decl_stmt|;
name|vm_page_t
name|pp
decl_stmt|;
name|obj
operator|=
name|vp
operator|->
name|v_object
expr_stmt|;
name|zfs_vmobject_assert_wlocked
argument_list|(
name|obj
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|pp
operator|=
name|vm_page_lookup
argument_list|(
name|obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|start
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|pp
operator|->
name|valid
condition|)
block|{
if|if
condition|(
name|vm_page_xbusied
argument_list|(
name|pp
argument_list|)
condition|)
block|{
comment|/* 				 * Reference the page before unlocking and 				 * sleeping so that the page daemon is less 				 * likely to reclaim it. 				 */
name|vm_page_reference
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|zfs_vmobject_wunlock
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|vm_page_busy_sleep
argument_list|(
name|pp
argument_list|,
literal|"zfsmwb"
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|zfs_vmobject_wlock
argument_list|(
name|obj
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ASSERT3U
argument_list|(
name|pp
operator|->
name|valid
argument_list|,
operator|==
argument_list|,
name|VM_PAGE_BITS_ALL
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|vm_page_hold
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
else|else
name|pp
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|pp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|page_unhold
parameter_list|(
name|vm_page_t
name|pp
parameter_list|)
block|{
name|vm_page_lock
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|vm_page_unhold
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When a file is memory mapped, we must keep the IO data synchronized  * between the DMU cache and the memory mapped pages.  What this means:  *  * On Write:	If we find a memory mapped page, we write to *both*  *		the page and the dmu buffer.  */
end_comment

begin_function
specifier|static
name|void
name|update_pages
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int64_t
name|start
parameter_list|,
name|int
name|len
parameter_list|,
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|oid
parameter_list|,
name|int
name|segflg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|vm_object_t
name|obj
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|caddr_t
name|va
decl_stmt|;
name|int
name|off
decl_stmt|;
name|ASSERT
argument_list|(
name|segflg
operator|!=
name|UIO_NOCOPY
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_mount
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|obj
operator|=
name|vp
operator|->
name|v_object
expr_stmt|;
name|ASSERT
argument_list|(
name|obj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|off
operator|=
name|start
operator|&
name|PAGEOFFSET
expr_stmt|;
name|zfs_vmobject_wlock
argument_list|(
name|obj
argument_list|)
expr_stmt|;
for|for
control|(
name|start
operator|&=
name|PAGEMASK
init|;
name|len
operator|>
literal|0
condition|;
name|start
operator|+=
name|PAGESIZE
control|)
block|{
name|vm_page_t
name|pp
decl_stmt|;
name|int
name|nbytes
init|=
name|imin
argument_list|(
name|PAGESIZE
operator|-
name|off
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|page_busy
argument_list|(
name|vp
argument_list|,
name|start
argument_list|,
name|off
argument_list|,
name|nbytes
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|zfs_vmobject_wunlock
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|va
operator|=
name|zfs_map_page
argument_list|(
name|pp
argument_list|,
operator|&
name|sf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_read
argument_list|(
name|os
argument_list|,
name|oid
argument_list|,
name|start
operator|+
name|off
argument_list|,
name|nbytes
argument_list|,
name|va
operator|+
name|off
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
expr_stmt|;
empty_stmt|;
name|zfs_unmap_page
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|zfs_vmobject_wlock
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|page_unbusy
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
name|len
operator|-=
name|nbytes
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
block|}
name|vm_object_pip_wakeupn
argument_list|(
name|obj
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zfs_vmobject_wunlock
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read with UIO_NOCOPY flag means that sendfile(2) requests  * ZFS to populate a range of page cache pages with data.  *  * NOTE: this function could be optimized to pre-allocate  * all pages in advance, drain exclusive busy on all of them,  * map them into contiguous KVA region and populate them  * in one single dmu_read() call.  */
end_comment

begin_function
specifier|static
name|int
name|mappedread_sf
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|nbytes
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_os
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|vm_object_t
name|obj
decl_stmt|;
name|vm_page_t
name|pp
decl_stmt|;
name|int64_t
name|start
decl_stmt|;
name|caddr_t
name|va
decl_stmt|;
name|int
name|len
init|=
name|nbytes
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|uio
operator|->
name|uio_segflg
operator|==
name|UIO_NOCOPY
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_mount
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|obj
operator|=
name|vp
operator|->
name|v_object
expr_stmt|;
name|ASSERT
argument_list|(
name|obj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|uio
operator|->
name|uio_loffset
operator|&
name|PAGEOFFSET
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zfs_vmobject_wlock
argument_list|(
name|obj
argument_list|)
expr_stmt|;
for|for
control|(
name|start
operator|=
name|uio
operator|->
name|uio_loffset
init|;
name|len
operator|>
literal|0
condition|;
name|start
operator|+=
name|PAGESIZE
control|)
block|{
name|int
name|bytes
init|=
name|MIN
argument_list|(
name|PAGESIZE
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|pp
operator|=
name|vm_page_grab
argument_list|(
name|obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|start
argument_list|)
argument_list|,
name|VM_ALLOC_SBUSY
operator||
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_IGN_SBUSY
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|valid
operator|==
literal|0
condition|)
block|{
name|zfs_vmobject_wunlock
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|va
operator|=
name|zfs_map_page
argument_list|(
name|pp
argument_list|,
operator|&
name|sf
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_read
argument_list|(
name|os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|start
argument_list|,
name|bytes
argument_list|,
name|va
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|!=
name|PAGESIZE
operator|&&
name|error
operator|==
literal|0
condition|)
name|bzero
argument_list|(
name|va
operator|+
name|bytes
argument_list|,
name|PAGESIZE
operator|-
name|bytes
argument_list|)
expr_stmt|;
name|zfs_unmap_page
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|zfs_vmobject_wlock
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|vm_page_sunbusy
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|vm_page_lock
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|pp
operator|->
name|wire_count
operator|==
literal|0
operator|&&
name|pp
operator|->
name|valid
operator|==
literal|0
operator|&&
operator|!
name|vm_page_busied
argument_list|(
name|pp
argument_list|)
condition|)
name|vm_page_free
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
name|vm_page_activate
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
name|vm_page_unlock
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT3U
argument_list|(
name|pp
operator|->
name|valid
argument_list|,
operator|==
argument_list|,
name|VM_PAGE_BITS_ALL
argument_list|)
expr_stmt|;
name|vm_page_sunbusy
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
break|break;
name|uio
operator|->
name|uio_resid
operator|-=
name|bytes
expr_stmt|;
name|uio
operator|->
name|uio_offset
operator|+=
name|bytes
expr_stmt|;
name|len
operator|-=
name|bytes
expr_stmt|;
block|}
name|zfs_vmobject_wunlock
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * When a file is memory mapped, we must keep the IO data synchronized  * between the DMU cache and the memory mapped pages.  What this means:  *  * On Read:	We "read" preferentially from memory mapped pages,  *		else we default from the dmu buffer.  *  * NOTE: We will always "break up" the IO into PAGESIZE uiomoves when  *	 the file is memory mapped.  */
end_comment

begin_function
specifier|static
name|int
name|mappedread
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|nbytes
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|vm_object_t
name|obj
decl_stmt|;
name|int64_t
name|start
decl_stmt|;
name|caddr_t
name|va
decl_stmt|;
name|int
name|len
init|=
name|nbytes
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_mount
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|obj
operator|=
name|vp
operator|->
name|v_object
expr_stmt|;
name|ASSERT
argument_list|(
name|obj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|start
operator|=
name|uio
operator|->
name|uio_loffset
expr_stmt|;
name|off
operator|=
name|start
operator|&
name|PAGEOFFSET
expr_stmt|;
name|zfs_vmobject_wlock
argument_list|(
name|obj
argument_list|)
expr_stmt|;
for|for
control|(
name|start
operator|&=
name|PAGEMASK
init|;
name|len
operator|>
literal|0
condition|;
name|start
operator|+=
name|PAGESIZE
control|)
block|{
name|vm_page_t
name|pp
decl_stmt|;
name|uint64_t
name|bytes
init|=
name|MIN
argument_list|(
name|PAGESIZE
operator|-
name|off
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|pp
operator|=
name|page_hold
argument_list|(
name|vp
argument_list|,
name|start
argument_list|)
condition|)
block|{
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|caddr_t
name|va
decl_stmt|;
name|zfs_vmobject_wunlock
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|va
operator|=
name|zfs_map_page
argument_list|(
name|pp
argument_list|,
operator|&
name|sf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|error
operator|=
name|uiomove
argument_list|(
name|va
operator|+
name|off
argument_list|,
name|bytes
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|vn_io_fault_uiomove
argument_list|(
name|va
operator|+
name|off
argument_list|,
name|bytes
argument_list|,
name|uio
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|zfs_unmap_page
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|zfs_vmobject_wlock
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|page_unhold
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfs_vmobject_wunlock
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_read_uio_dbuf
argument_list|(
name|sa_get_db
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|)
argument_list|,
name|uio
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|zfs_vmobject_wlock
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
name|len
operator|-=
name|bytes
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|zfs_vmobject_wunlock
argument_list|(
name|obj
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|offset_t
name|zfs_read_chunk_size
init|=
literal|1024
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tunable */
end_comment

begin_comment
comment|/*  * Read bytes from specified file into supplied buffer.  *  *	IN:	vp	- vnode of file to be read from.  *		uio	- structure supplying read location, range info,  *			  and return buffer.  *		ioflag	- SYNC flags; used to provide FRSYNC semantics.  *		cr	- credentials of caller.  *		ct	- caller context  *  *	OUT:	uio	- updated offset and range, buffer filled.  *  *	RETURN:	0 on success, error code on failure.  *  * Side Effects:  *	vp - atime updated if byte count> 0  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_read
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|ssize_t
name|n
decl_stmt|,
name|nbytes
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|xuio_t
modifier|*
name|xuio
init|=
name|NULL
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_AV_QUARANTINED
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EACCES
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Validate file offset 	 */
if|if
condition|(
name|uio
operator|->
name|uio_loffset
operator|<
operator|(
name|offset_t
operator|)
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Fasttrack empty reads 	 */
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Check for mandatory locks 	 */
if|if
condition|(
name|MANDMODE
argument_list|(
name|zp
operator|->
name|z_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|chklock
argument_list|(
name|vp
argument_list|,
name|FREAD
argument_list|,
name|uio
operator|->
name|uio_loffset
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|uio
operator|->
name|uio_fmode
argument_list|,
name|ct
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * If we're in FRSYNC mode, sync out this znode before reading it. 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_log
operator|&&
operator|(
name|ioflag
operator|&
name|FRSYNC
operator|||
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
operator|)
condition|)
name|zil_commit
argument_list|(
name|zfsvfs
operator|->
name|z_log
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
comment|/* 	 * Lock the range against changes. 	 */
name|rl
operator|=
name|zfs_range_lock
argument_list|(
name|zp
argument_list|,
name|uio
operator|->
name|uio_loffset
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|RL_READER
argument_list|)
expr_stmt|;
comment|/* 	 * If we are reading past end-of-file we can skip 	 * to the end; but we might still need to set atime. 	 */
if|if
condition|(
name|uio
operator|->
name|uio_loffset
operator|>=
name|zp
operator|->
name|z_size
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ASSERT
argument_list|(
name|uio
operator|->
name|uio_loffset
operator|<
name|zp
operator|->
name|z_size
argument_list|)
expr_stmt|;
name|n
operator|=
name|MIN
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|zp
operator|->
name|z_size
operator|-
name|uio
operator|->
name|uio_loffset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
operator|(
name|uio
operator|->
name|uio_extflg
operator|==
name|UIO_XUIO
operator|)
operator|&&
operator|(
operator|(
operator|(
name|xuio_t
operator|*
operator|)
name|uio
operator|)
operator|->
name|xu_type
operator|==
name|UIOTYPE_ZEROCOPY
operator|)
condition|)
block|{
name|int
name|nblk
decl_stmt|;
name|int
name|blksz
init|=
name|zp
operator|->
name|z_blksz
decl_stmt|;
name|uint64_t
name|offset
init|=
name|uio
operator|->
name|uio_loffset
decl_stmt|;
name|xuio
operator|=
operator|(
name|xuio_t
operator|*
operator|)
name|uio
expr_stmt|;
if|if
condition|(
operator|(
name|ISP2
argument_list|(
name|blksz
argument_list|)
operator|)
condition|)
block|{
name|nblk
operator|=
operator|(
name|P2ROUNDUP
argument_list|(
name|offset
operator|+
name|n
argument_list|,
name|blksz
argument_list|)
operator|-
name|P2ALIGN
argument_list|(
name|offset
argument_list|,
name|blksz
argument_list|)
operator|)
operator|/
name|blksz
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|offset
operator|+
name|n
operator|<=
name|blksz
argument_list|)
expr_stmt|;
name|nblk
operator|=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|dmu_xuio_init
argument_list|(
name|xuio
argument_list|,
name|nblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_has_cached_data
argument_list|(
name|vp
argument_list|)
condition|)
block|{
comment|/* 			 * For simplicity, we always allocate a full buffer 			 * even if we only expect to read a portion of a block. 			 */
while|while
condition|(
operator|--
name|nblk
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|dmu_xuio_add
argument_list|(
name|xuio
argument_list|,
name|dmu_request_arcbuf
argument_list|(
name|sa_get_db
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|)
argument_list|,
name|blksz
argument_list|)
argument_list|,
literal|0
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* illumos */
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|nbytes
operator|=
name|MIN
argument_list|(
name|n
argument_list|,
name|zfs_read_chunk_size
operator|-
name|P2PHASE
argument_list|(
name|uio
operator|->
name|uio_loffset
argument_list|,
name|zfs_read_chunk_size
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
if|if
condition|(
name|uio
operator|->
name|uio_segflg
operator|==
name|UIO_NOCOPY
condition|)
name|error
operator|=
name|mappedread_sf
argument_list|(
name|vp
argument_list|,
name|nbytes
argument_list|,
name|uio
argument_list|)
expr_stmt|;
elseif|else
endif|#
directive|endif
comment|/* __FreeBSD__ */
if|if
condition|(
name|vn_has_cached_data
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|error
operator|=
name|mappedread
argument_list|(
name|vp
argument_list|,
name|nbytes
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|dmu_read_uio_dbuf
argument_list|(
name|sa_get_db
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|)
argument_list|,
name|uio
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* convert checksum errors into IO errors */
if|if
condition|(
name|error
operator|==
name|ECKSUM
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
break|break;
block|}
name|n
operator|-=
name|nbytes
expr_stmt|;
block|}
name|out
label|:
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|ZFS_ACCESSTIME_STAMP
argument_list|(
name|zfsvfs
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write the bytes to a file.  *  *	IN:	vp	- vnode of file to be written to.  *		uio	- structure supplying write location, range info,  *			  and data buffer.  *		ioflag	- FAPPEND, FSYNC, and/or FDSYNC.  FAPPEND is  *			  set if in append mode.  *		cr	- credentials of caller.  *		ct	- caller context (NFS/CIFS fem monitor only)  *  *	OUT:	uio	- updated offset and range.  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	vp - ctime|mtime updated if byte count> 0  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_write
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|rlim64_t
name|limit
init|=
name|MAXOFFSET_T
decl_stmt|;
name|ssize_t
name|start_resid
init|=
name|uio
operator|->
name|uio_resid
decl_stmt|;
name|ssize_t
name|tx_bytes
decl_stmt|;
name|uint64_t
name|end_size
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|offset_t
name|woff
decl_stmt|;
name|ssize_t
name|n
decl_stmt|,
name|nbytes
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|int
name|max_blksz
init|=
name|zfsvfs
operator|->
name|z_max_blksz
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|arc_buf_t
modifier|*
name|abuf
decl_stmt|;
name|iovec_t
modifier|*
name|aiov
init|=
name|NULL
decl_stmt|;
name|xuio_t
modifier|*
name|xuio
init|=
name|NULL
decl_stmt|;
name|int
name|i_iov
init|=
literal|0
decl_stmt|;
name|int
name|iovcnt
init|=
name|uio
operator|->
name|uio_iovcnt
decl_stmt|;
name|iovec_t
modifier|*
name|iovp
init|=
name|uio
operator|->
name|uio_iov
decl_stmt|;
name|int
name|write_eof
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|sa_bulk_attr_t
name|bulk
index|[
literal|4
index|]
decl_stmt|;
name|uint64_t
name|mtime
index|[
literal|2
index|]
decl_stmt|,
name|ctime
index|[
literal|2
index|]
decl_stmt|;
comment|/* 	 * Fasttrack empty write 	 */
name|n
operator|=
name|start_resid
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|limit
operator|==
name|RLIM64_INFINITY
operator|||
name|limit
operator|>
name|MAXOFFSET_T
condition|)
name|limit
operator|=
name|MAXOFFSET_T
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_MTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|mtime
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_CTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|ctime
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_SIZE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|zp
operator|->
name|z_size
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_FLAGS
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|zp
operator|->
name|z_pflags
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* 	 * In a case vp->v_vfsp != zp->z_zfsvfs->z_vfs (e.g. snapshots) our 	 * callers might not be able to detect properly that we are read-only, 	 * so check it explicitly here. 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EROFS
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * If immutable or not appending then return EPERM 	 */
if|if
condition|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
operator|(
name|ZFS_IMMUTABLE
operator||
name|ZFS_READONLY
operator|)
operator|)
operator|||
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_APPENDONLY
operator|)
operator|&&
operator|!
operator|(
name|ioflag
operator|&
name|FAPPEND
operator|)
operator|&&
operator|(
name|uio
operator|->
name|uio_loffset
operator|<
name|zp
operator|->
name|z_size
operator|)
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
block|}
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
comment|/* 	 * Validate file offset 	 */
name|woff
operator|=
name|ioflag
operator|&
name|FAPPEND
condition|?
name|zp
operator|->
name|z_size
else|:
name|uio
operator|->
name|uio_loffset
expr_stmt|;
if|if
condition|(
name|woff
operator|<
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Check for mandatory locks before calling zfs_range_lock() 	 * in order to prevent a deadlock with locks set via fcntl(). 	 */
if|if
condition|(
name|MANDMODE
argument_list|(
operator|(
name|mode_t
operator|)
name|zp
operator|->
name|z_mode
argument_list|)
operator|&&
operator|(
name|error
operator|=
name|chklock
argument_list|(
name|vp
argument_list|,
name|FWRITE
argument_list|,
name|woff
argument_list|,
name|n
argument_list|,
name|uio
operator|->
name|uio_fmode
argument_list|,
name|ct
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|illumos
comment|/* 	 * Pre-fault the pages to ensure slow (eg NFS) pages 	 * don't hold up txg. 	 * Skip this if uio contains loaned arc_buf. 	 */
if|if
condition|(
operator|(
name|uio
operator|->
name|uio_extflg
operator|==
name|UIO_XUIO
operator|)
operator|&&
operator|(
operator|(
operator|(
name|xuio_t
operator|*
operator|)
name|uio
operator|)
operator|->
name|xu_type
operator|==
name|UIOTYPE_ZEROCOPY
operator|)
condition|)
name|xuio
operator|=
operator|(
name|xuio_t
operator|*
operator|)
name|uio
expr_stmt|;
else|else
name|uio_prefaultpages
argument_list|(
name|MIN
argument_list|(
name|n
argument_list|,
name|max_blksz
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If in append mode, set the io offset pointer to eof. 	 */
if|if
condition|(
name|ioflag
operator|&
name|FAPPEND
condition|)
block|{
comment|/* 		 * Obtain an appending range lock to guarantee file append 		 * semantics.  We reset the write offset once we have the lock. 		 */
name|rl
operator|=
name|zfs_range_lock
argument_list|(
name|zp
argument_list|,
literal|0
argument_list|,
name|n
argument_list|,
name|RL_APPEND
argument_list|)
expr_stmt|;
name|woff
operator|=
name|rl
operator|->
name|r_off
expr_stmt|;
if|if
condition|(
name|rl
operator|->
name|r_len
operator|==
name|UINT64_MAX
condition|)
block|{
comment|/* 			 * We overlocked the file because this write will cause 			 * the file block size to increase. 			 * Note that zp_size cannot change with this lock held. 			 */
name|woff
operator|=
name|zp
operator|->
name|z_size
expr_stmt|;
block|}
name|uio
operator|->
name|uio_loffset
operator|=
name|woff
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Note that if the file block size will change as a result of 		 * this write, then this range lock will lock the entire file 		 * so that we can re-write the block safely. 		 */
name|rl
operator|=
name|zfs_range_lock
argument_list|(
name|zp
argument_list|,
name|woff
argument_list|,
name|n
argument_list|,
name|RL_WRITER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vn_rlimit_fsize
argument_list|(
name|vp
argument_list|,
name|uio
argument_list|,
name|uio
operator|->
name|uio_td
argument_list|)
condition|)
block|{
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFBIG
operator|)
return|;
block|}
if|if
condition|(
name|woff
operator|>=
name|limit
condition|)
block|{
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EFBIG
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|woff
operator|+
name|n
operator|)
operator|>
name|limit
operator|||
name|woff
operator|>
operator|(
name|limit
operator|-
name|n
operator|)
condition|)
name|n
operator|=
name|limit
operator|-
name|woff
expr_stmt|;
comment|/* Will this write extend the file length? */
name|write_eof
operator|=
operator|(
name|woff
operator|+
name|n
operator|>
name|zp
operator|->
name|z_size
operator|)
expr_stmt|;
name|end_size
operator|=
name|MAX
argument_list|(
name|zp
operator|->
name|z_size
argument_list|,
name|woff
operator|+
name|n
argument_list|)
expr_stmt|;
comment|/* 	 * Write the file in reasonable size chunks.  Each chunk is written 	 * in a separate transaction; this keeps the intent log records small 	 * and allows us to do more fine-grained space accounting. 	 */
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|abuf
operator|=
name|NULL
expr_stmt|;
name|woff
operator|=
name|uio
operator|->
name|uio_loffset
expr_stmt|;
if|if
condition|(
name|zfs_owner_overquota
argument_list|(
name|zfsvfs
argument_list|,
name|zp
argument_list|,
name|B_FALSE
argument_list|)
operator|||
name|zfs_owner_overquota
argument_list|(
name|zfsvfs
argument_list|,
name|zp
argument_list|,
name|B_TRUE
argument_list|)
condition|)
block|{
if|if
condition|(
name|abuf
operator|!=
name|NULL
condition|)
name|dmu_return_arcbuf
argument_list|(
name|abuf
argument_list|)
expr_stmt|;
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EDQUOT
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|xuio
operator|&&
name|abuf
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|i_iov
operator|<
name|iovcnt
argument_list|)
expr_stmt|;
name|aiov
operator|=
operator|&
name|iovp
index|[
name|i_iov
index|]
expr_stmt|;
name|abuf
operator|=
name|dmu_xuio_arcbuf
argument_list|(
name|xuio
argument_list|,
name|i_iov
argument_list|)
expr_stmt|;
name|dmu_xuio_clear
argument_list|(
name|xuio
argument_list|,
name|i_iov
argument_list|)
expr_stmt|;
name|DTRACE_PROBE3
argument_list|(
name|zfs_cp_write
argument_list|,
name|int
argument_list|,
name|i_iov
argument_list|,
name|iovec_t
operator|*
argument_list|,
name|aiov
argument_list|,
name|arc_buf_t
operator|*
argument_list|,
name|abuf
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|aiov
operator|->
name|iov_base
operator|==
name|abuf
operator|->
name|b_data
operator|)
operator|||
operator|(
operator|(
name|char
operator|*
operator|)
name|aiov
operator|->
name|iov_base
operator|-
operator|(
name|char
operator|*
operator|)
name|abuf
operator|->
name|b_data
operator|+
name|aiov
operator|->
name|iov_len
operator|==
name|arc_buf_size
argument_list|(
name|abuf
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|i_iov
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|abuf
operator|==
name|NULL
operator|&&
name|n
operator|>=
name|max_blksz
operator|&&
name|woff
operator|>=
name|zp
operator|->
name|z_size
operator|&&
name|P2PHASE
argument_list|(
name|woff
argument_list|,
name|max_blksz
argument_list|)
operator|==
literal|0
operator|&&
name|zp
operator|->
name|z_blksz
operator|==
name|max_blksz
condition|)
block|{
comment|/* 			 * This write covers a full block.  "Borrow" a buffer 			 * from the dmu so that we can fill it before we enter 			 * a transaction.  This avoids the possibility of 			 * holding up the transaction if the data copy hangs 			 * up on a pagefault (e.g., from an NFS server mapping). 			 */
ifdef|#
directive|ifdef
name|illumos
name|size_t
name|cbytes
decl_stmt|;
endif|#
directive|endif
name|abuf
operator|=
name|dmu_request_arcbuf
argument_list|(
name|sa_get_db
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|)
argument_list|,
name|max_blksz
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|abuf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|arc_buf_size
argument_list|(
name|abuf
argument_list|)
operator|==
name|max_blksz
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|error
operator|=
name|uiocopy
argument_list|(
name|abuf
operator|->
name|b_data
argument_list|,
name|max_blksz
argument_list|,
name|UIO_WRITE
argument_list|,
name|uio
argument_list|,
operator|&
name|cbytes
argument_list|)
condition|)
block|{
name|dmu_return_arcbuf
argument_list|(
name|abuf
argument_list|)
expr_stmt|;
break|break;
block|}
name|ASSERT
argument_list|(
name|cbytes
operator|==
name|max_blksz
argument_list|)
expr_stmt|;
else|#
directive|else
name|ssize_t
name|resid
init|=
name|uio
operator|->
name|uio_resid
decl_stmt|;
name|error
operator|=
name|vn_io_fault_uiomove
argument_list|(
name|abuf
operator|->
name|b_data
argument_list|,
name|max_blksz
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|uio
operator|->
name|uio_offset
operator|-=
name|resid
operator|-
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|=
name|resid
expr_stmt|;
name|dmu_return_arcbuf
argument_list|(
name|abuf
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
block|}
comment|/* 		 * Start a transaction. 		 */
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|woff
argument_list|,
name|MIN
argument_list|(
name|n
argument_list|,
name|max_blksz
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|abuf
operator|!=
name|NULL
condition|)
name|dmu_return_arcbuf
argument_list|(
name|abuf
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * If zfs_range_lock() over-locked we grow the blocksize 		 * and then reduce the lock range.  This will only happen 		 * on the first iteration since zfs_range_reduce() will 		 * shrink down r_len to the appropriate size. 		 */
if|if
condition|(
name|rl
operator|->
name|r_len
operator|==
name|UINT64_MAX
condition|)
block|{
name|uint64_t
name|new_blksz
decl_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_blksz
operator|>
name|max_blksz
condition|)
block|{
comment|/* 				 * File's blocksize is already larger than the 				 * "recordsize" property.  Only let it grow to 				 * the next power of 2. 				 */
name|ASSERT
argument_list|(
operator|!
name|ISP2
argument_list|(
name|zp
operator|->
name|z_blksz
argument_list|)
argument_list|)
expr_stmt|;
name|new_blksz
operator|=
name|MIN
argument_list|(
name|end_size
argument_list|,
literal|1
operator|<<
name|highbit64
argument_list|(
name|zp
operator|->
name|z_blksz
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_blksz
operator|=
name|MIN
argument_list|(
name|end_size
argument_list|,
name|max_blksz
argument_list|)
expr_stmt|;
block|}
name|zfs_grow_blocksize
argument_list|(
name|zp
argument_list|,
name|new_blksz
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zfs_range_reduce
argument_list|(
name|rl
argument_list|,
name|woff
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * XXX - should we really limit each write to z_max_blksz? 		 * Perhaps we should use SPA_MAXBLOCKSIZE chunks? 		 */
name|nbytes
operator|=
name|MIN
argument_list|(
name|n
argument_list|,
name|max_blksz
operator|-
name|P2PHASE
argument_list|(
name|woff
argument_list|,
name|max_blksz
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|woff
operator|+
name|nbytes
operator|>
name|zp
operator|->
name|z_size
condition|)
name|vnode_pager_setsize
argument_list|(
name|vp
argument_list|,
name|woff
operator|+
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|abuf
operator|==
name|NULL
condition|)
block|{
name|tx_bytes
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|error
operator|=
name|dmu_write_uio_dbuf
argument_list|(
name|sa_get_db
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|)
argument_list|,
name|uio
argument_list|,
name|nbytes
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|tx_bytes
operator|-=
name|uio
operator|->
name|uio_resid
expr_stmt|;
block|}
else|else
block|{
name|tx_bytes
operator|=
name|nbytes
expr_stmt|;
name|ASSERT
argument_list|(
name|xuio
operator|==
name|NULL
operator|||
name|tx_bytes
operator|==
name|aiov
operator|->
name|iov_len
argument_list|)
expr_stmt|;
comment|/* 			 * If this is not a full block write, but we are 			 * extending the file past EOF and this data starts 			 * block-aligned, use assign_arcbuf().  Otherwise, 			 * write via dmu_write(). 			 */
if|if
condition|(
name|tx_bytes
operator|<
name|max_blksz
operator|&&
operator|(
operator|!
name|write_eof
operator|||
name|aiov
operator|->
name|iov_base
operator|!=
name|abuf
operator|->
name|b_data
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|xuio
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|woff
argument_list|,
name|aiov
operator|->
name|iov_len
argument_list|,
name|aiov
operator|->
name|iov_base
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_return_arcbuf
argument_list|(
name|abuf
argument_list|)
expr_stmt|;
name|xuio_stat_wbuf_copied
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|xuio
operator|||
name|tx_bytes
operator|==
name|max_blksz
argument_list|)
expr_stmt|;
name|dmu_assign_arcbuf
argument_list|(
name|sa_get_db
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|)
argument_list|,
name|woff
argument_list|,
name|abuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|illumos
name|ASSERT
argument_list|(
name|tx_bytes
operator|<=
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|uioskip
argument_list|(
name|uio
argument_list|,
name|tx_bytes
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|tx_bytes
operator|&&
name|vn_has_cached_data
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|update_pages
argument_list|(
name|vp
argument_list|,
name|woff
argument_list|,
name|tx_bytes
argument_list|,
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|uio
operator|->
name|uio_segflg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we made no progress, we're done.  If we made even 		 * partial progress, update the znode and ZIL accordingly. 		 */
if|if
condition|(
name|tx_bytes
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sa_update
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_SIZE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|zp
operator|->
name|z_size
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|!=
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Clear Set-UID/Set-GID bits on successful write if not 		 * privileged and at least one of the excute bits is set. 		 * 		 * It would be nice to to this after all writes have 		 * been done, but that would still expose the ISUID/ISGID 		 * to another app after the partial write is committed. 		 * 		 * Note: we don't call zfs_fuid_map_id() here because 		 * user 0 is not an ephemeral uid. 		 */
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zp
operator|->
name|z_mode
operator|&
operator|(
name|S_IXUSR
operator||
operator|(
name|S_IXUSR
operator|>>
literal|3
operator|)
operator||
operator|(
name|S_IXUSR
operator|>>
literal|6
operator|)
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|zp
operator|->
name|z_mode
operator|&
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|secpolicy_vnode_setid_retain
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|,
operator|(
name|zp
operator|->
name|z_mode
operator|&
name|S_ISUID
operator|)
operator|!=
literal|0
operator|&&
name|zp
operator|->
name|z_uid
operator|==
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|uint64_t
name|newmode
decl_stmt|;
name|zp
operator|->
name|z_mode
operator|&=
operator|~
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator|)
expr_stmt|;
name|newmode
operator|=
name|zp
operator|->
name|z_mode
expr_stmt|;
operator|(
name|void
operator|)
name|sa_update
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_MODE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|newmode
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|zfs_tstamp_update_setup
argument_list|(
name|zp
argument_list|,
name|CONTENT_MODIFIED
argument_list|,
name|mtime
argument_list|,
name|ctime
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
comment|/* 		 * Update the file size (zp_size) if it has changed; 		 * account for possible concurrent updates. 		 */
while|while
condition|(
operator|(
name|end_size
operator|=
name|zp
operator|->
name|z_size
operator|)
operator|<
name|uio
operator|->
name|uio_loffset
condition|)
block|{
operator|(
name|void
operator|)
name|atomic_cas_64
argument_list|(
operator|&
name|zp
operator|->
name|z_size
argument_list|,
name|end_size
argument_list|,
name|uio
operator|->
name|uio_loffset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|EFAULT
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 		 * If we are replaying and eof is non zero then force 		 * the file size to the specified eof. Note, there's no 		 * concurrency during replay. 		 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_replay
operator|&&
name|zfsvfs
operator|->
name|z_replay_eof
operator|!=
literal|0
condition|)
name|zp
operator|->
name|z_size
operator|=
name|zfsvfs
operator|->
name|z_replay_eof
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|sa_bulk_update
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|bulk
argument_list|,
name|count
argument_list|,
name|tx
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sa_bulk_update
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|bulk
argument_list|,
name|count
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zfs_log_write
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|TX_WRITE
argument_list|,
name|zp
argument_list|,
name|woff
argument_list|,
name|tx_bytes
argument_list|,
name|ioflag
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|ASSERT
argument_list|(
name|tx_bytes
operator|==
name|nbytes
argument_list|)
expr_stmt|;
name|n
operator|-=
name|nbytes
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
operator|!
name|xuio
operator|&&
name|n
operator|>
literal|0
condition|)
name|uio_prefaultpages
argument_list|(
name|MIN
argument_list|(
name|n
argument_list|,
name|max_blksz
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
comment|/* 	 * If we're in replay mode, or we made no progress, return error. 	 * Otherwise, it's at least a partial write, so it's successful. 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_replay
operator|||
name|uio
operator|->
name|uio_resid
operator|==
name|start_resid
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|__FreeBSD__
comment|/* 	 * EFAULT means that at least one page of the source buffer was not 	 * available.  VFS will re-try remaining I/O upon this error. 	 */
if|if
condition|(
name|error
operator|==
name|EFAULT
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ioflag
operator|&
operator|(
name|FSYNC
operator||
name|FDSYNC
operator|)
operator|||
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
condition|)
name|zil_commit
argument_list|(
name|zilog
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zfs_get_done
parameter_list|(
name|zgd_t
modifier|*
name|zgd
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|zgd
operator|->
name|zgd_private
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_os
decl_stmt|;
if|if
condition|(
name|zgd
operator|->
name|zgd_db
condition|)
name|dmu_buf_rele
argument_list|(
name|zgd
operator|->
name|zgd_db
argument_list|,
name|zgd
argument_list|)
expr_stmt|;
name|zfs_range_unlock
argument_list|(
name|zgd
operator|->
name|zgd_rl
argument_list|)
expr_stmt|;
comment|/* 	 * Release the vnode asynchronously as we currently have the 	 * txg stopped from syncing. 	 */
name|VN_RELE_ASYNC
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|dsl_pool_vnrele_taskq
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|zgd
operator|->
name|zgd_bp
condition|)
name|zil_add_block
argument_list|(
name|zgd
operator|->
name|zgd_zilog
argument_list|,
name|zgd
operator|->
name|zgd_bp
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zgd
argument_list|,
sizeof|sizeof
argument_list|(
name|zgd_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|zil_fault_io
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Get data to generate a TX_WRITE intent log record.  */
end_comment

begin_function
name|int
name|zfs_get_data
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|lr_write_t
modifier|*
name|lr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zfsvfs
operator|->
name|z_os
decl_stmt|;
name|znode_t
modifier|*
name|zp
decl_stmt|;
name|uint64_t
name|object
init|=
name|lr
operator|->
name|lr_foid
decl_stmt|;
name|uint64_t
name|offset
init|=
name|lr
operator|->
name|lr_offset
decl_stmt|;
name|uint64_t
name|size
init|=
name|lr
operator|->
name|lr_length
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
operator|&
name|lr
operator|->
name|lr_blkptr
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|zgd_t
modifier|*
name|zgd
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Nothing to do if the file has been removed 	 */
if|if
condition|(
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|object
argument_list|,
operator|&
name|zp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
if|if
condition|(
name|zp
operator|->
name|z_unlinked
condition|)
block|{
comment|/* 		 * Release the vnode asynchronously as we currently have the 		 * txg stopped from syncing. 		 */
name|VN_RELE_ASYNC
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|dsl_pool_vnrele_taskq
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
block|}
name|zgd
operator|=
operator|(
name|zgd_t
operator|*
operator|)
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zgd_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zgd
operator|->
name|zgd_zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
name|zgd
operator|->
name|zgd_private
operator|=
name|zp
expr_stmt|;
comment|/* 	 * Write records come in two flavors: immediate and indirect. 	 * For small writes it's cheaper to store the data with the 	 * log record (immediate); for large writes it's cheaper to 	 * sync the data and get a pointer to it (indirect) so that 	 * we don't have to write the data twice. 	 */
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
comment|/* immediate write */
name|zgd
operator|->
name|zgd_rl
operator|=
name|zfs_range_lock
argument_list|(
name|zp
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|RL_READER
argument_list|)
expr_stmt|;
comment|/* test for truncation needs to be done while range locked */
if|if
condition|(
name|offset
operator|>=
name|zp
operator|->
name|z_size
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|dmu_read
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|buf
argument_list|,
name|DMU_READ_NO_PREFETCH
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* indirect write */
comment|/* 		 * Have to lock the whole block to ensure when it's 		 * written out and it's checksum is being calculated 		 * that no one can change the data. We need to re-check 		 * blocksize after we get the lock in case it's changed! 		 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|uint64_t
name|blkoff
decl_stmt|;
name|size
operator|=
name|zp
operator|->
name|z_blksz
expr_stmt|;
name|blkoff
operator|=
name|ISP2
argument_list|(
name|size
argument_list|)
condition|?
name|P2PHASE
argument_list|(
name|offset
argument_list|,
name|size
argument_list|)
else|:
name|offset
expr_stmt|;
name|offset
operator|-=
name|blkoff
expr_stmt|;
name|zgd
operator|->
name|zgd_rl
operator|=
name|zfs_range_lock
argument_list|(
name|zp
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|RL_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_blksz
operator|==
name|size
condition|)
break|break;
name|offset
operator|+=
name|blkoff
expr_stmt|;
name|zfs_range_unlock
argument_list|(
name|zgd
operator|->
name|zgd_rl
argument_list|)
expr_stmt|;
block|}
comment|/* test for truncation needs to be done while range locked */
if|if
condition|(
name|lr
operator|->
name|lr_offset
operator|>=
name|zp
operator|->
name|z_size
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|zil_fault_io
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
name|zil_fault_io
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|dmu_buf_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|zgd
argument_list|,
operator|&
name|db
argument_list|,
name|DMU_READ_NO_PREFETCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|blkptr_t
modifier|*
name|obp
init|=
name|dmu_buf_get_blkptr
argument_list|(
name|db
argument_list|)
decl_stmt|;
if|if
condition|(
name|obp
condition|)
block|{
name|ASSERT
argument_list|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
operator|*
name|obp
expr_stmt|;
block|}
name|zgd
operator|->
name|zgd_db
operator|=
name|db
expr_stmt|;
name|zgd
operator|->
name|zgd_bp
operator|=
name|bp
expr_stmt|;
name|ASSERT
argument_list|(
name|db
operator|->
name|db_offset
operator|==
name|offset
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|db
operator|->
name|db_size
operator|==
name|size
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_sync
argument_list|(
name|zio
argument_list|,
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txg
argument_list|,
name|zfs_get_done
argument_list|,
name|zgd
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|||
name|lr
operator|->
name|lr_length
operator|<=
name|zp
operator|->
name|z_blksz
argument_list|)
expr_stmt|;
comment|/* 			 * On success, we need to wait for the write I/O 			 * initiated by dmu_sync() to complete before we can 			 * release this dbuf.  We will finish everything up 			 * in the zfs_get_done() callback. 			 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|error
operator|==
name|EALREADY
condition|)
block|{
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txtype
operator|=
name|TX_WRITE2
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|zfs_get_done
argument_list|(
name|zgd
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_access
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|flag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|V_ACE_MASK
condition|)
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|mode
argument_list|,
name|flag
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|zfs_zaccess_rwx
argument_list|(
name|zp
argument_list|,
name|mode
argument_list|,
name|flag
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_dd_callback
parameter_list|(
name|struct
name|mount
modifier|*
name|mp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|lkflags
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
operator|*
name|vpp
operator|=
name|arg
expr_stmt|;
name|error
operator|=
name|vn_lock
argument_list|(
operator|*
name|vpp
argument_list|,
name|lkflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|vrele
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_lookup_lock
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|vnode_t
modifier|*
name|vp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|lkflags
parameter_list|)
block|{
name|znode_t
modifier|*
name|zdp
init|=
name|VTOZ
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zdp
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|ltype
decl_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|dvp
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|zdp
operator|->
name|z_pflags
operator|&
name|ZFS_XATTR
operator|)
operator|==
literal|0
condition|)
name|VERIFY
argument_list|(
operator|!
name|RRM_LOCK_HELD
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_lock
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|0
operator|||
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
block|{
name|ASSERT3P
argument_list|(
name|dvp
argument_list|,
operator|==
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|vref
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|ltype
operator|=
name|lkflags
operator|&
name|LK_TYPE_MASK
expr_stmt|;
if|if
condition|(
name|ltype
operator|!=
name|VOP_ISLOCKED
argument_list|(
name|dvp
argument_list|)
condition|)
block|{
if|if
condition|(
name|ltype
operator|==
name|LK_EXCLUSIVE
condition|)
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|LK_UPGRADE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
else|else
comment|/* if (ltype == LK_SHARED) */
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|LK_DOWNGRADE
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
comment|/* 			 * Relock for the "." case could leave us with 			 * reclaimed vnode. 			 */
if|if
condition|(
name|dvp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
condition|)
block|{
name|vrele
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Note that in this case, dvp is the child vnode, and we 		 * are looking up the parent vnode - exactly reverse from 		 * normal operation.  Unlocking dvp requires some rather 		 * tricky unlock/relock dance to prevent mp from being freed; 		 * use vn_vget_ino_gen() which takes care of all that. 		 * 		 * XXX Note that there is a time window when both vnodes are 		 * unlocked.  It is possible, although highly unlikely, that 		 * during that window the parent-child relationship between 		 * the vnodes may change, for example, get reversed. 		 * In that case we would have a wrong lock order for the vnodes. 		 * All other filesystems seem to ignore this problem, so we 		 * do the same here. 		 * A potential solution could be implemented as follows: 		 * - using LK_NOWAIT when locking the second vnode and retrying 		 *   if necessary 		 * - checking that the parent-child relationship still holds 		 *   after locking both vnodes and retrying if it doesn't 		 */
name|error
operator|=
name|vn_vget_ino_gen
argument_list|(
name|dvp
argument_list|,
name|zfs_dd_callback
argument_list|,
name|vp
argument_list|,
name|lkflags
argument_list|,
operator|&
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
name|error
operator|=
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|lkflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Lookup an entry in a directory, or an extended attribute directory.  * If it exists, return a held vnode reference for it.  *  *	IN:	dvp	- vnode of directory to search.  *		nm	- name of entry to lookup.  *		pnp	- full pathname to lookup [UNUSED].  *		flags	- LOOKUP_XATTR set if looking for an attribute.  *		rdir	- root directory vnode [UNUSED].  *		cr	- credentials of caller.  *		ct	- caller context  *  *	OUT:	vpp	- vnode of located entry, NULL if not found.  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	NA  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_lookup
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|nm
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|struct
name|componentname
modifier|*
name|cnp
parameter_list|,
name|int
name|nameiop
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|kthread_t
modifier|*
name|td
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|znode_t
modifier|*
name|zdp
init|=
name|VTOZ
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|znode_t
modifier|*
name|zp
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zdp
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* fast path (should be redundant with vfs namecache) */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|LOOKUP_XATTR
operator|)
condition|)
block|{
if|if
condition|(
name|dvp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTDIR
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|zdp
operator|->
name|z_sa_hdl
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
block|}
block|}
name|DTRACE_PROBE2
argument_list|(
name|zfs__fastpath__lookup__miss
argument_list|,
name|vnode_t
operator|*
argument_list|,
name|dvp
argument_list|,
name|char
operator|*
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zdp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_XATTR
condition|)
block|{
ifdef|#
directive|ifdef
name|TODO
comment|/* 		 * If the xattr property is off, refuse the lookup request. 		 */
if|if
condition|(
operator|!
operator|(
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&
name|VFS_XATTR
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* 		 * We don't allow recursive attributes.. 		 * Maybe someday we will. 		 */
if|if
condition|(
name|zdp
operator|->
name|z_pflags
operator|&
name|ZFS_XATTR
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|=
name|zfs_get_xattrdir
argument_list|(
name|VTOZ
argument_list|(
name|dvp
argument_list|)
argument_list|,
name|vpp
argument_list|,
name|cr
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * Do we have permission to get into attribute directory? 		 */
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|VTOZ
argument_list|(
operator|*
name|vpp
argument_list|)
argument_list|,
name|ACE_EXECUTE
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
condition|)
block|{
name|vrele
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Check accessibility of directory. 	 */
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|zdp
argument_list|,
name|ACE_EXECUTE
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|zfsvfs
operator|->
name|z_utf8
operator|&&
name|u8_validate
argument_list|(
name|nm
argument_list|,
name|strlen
argument_list|(
name|nm
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|U8_VALIDATE_ENTIRE
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EILSEQ
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * First handle the special cases. 	 */
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISDOTDOT
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * If we are a snapshot mounted under .zfs, return 		 * the vp for the snapshot directory. 		 */
if|if
condition|(
name|zdp
operator|->
name|z_id
operator|==
name|zfsvfs
operator|->
name|z_root
operator|&&
name|zfsvfs
operator|->
name|z_parent
operator|!=
name|zfsvfs
condition|)
block|{
name|error
operator|=
name|zfsctl_root_lookup
argument_list|(
name|zfsvfs
operator|->
name|z_parent
operator|->
name|z_ctldir
argument_list|,
literal|"snapshot"
argument_list|,
name|vpp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|kcred
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|zfs_lookup_lock
argument_list|(
name|dvp
argument_list|,
operator|*
name|vpp
argument_list|,
name|nm
argument_list|,
name|cnp
operator|->
name|cn_lkflags
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|zfs_has_ctldir
argument_list|(
name|zdp
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|nm
argument_list|,
name|ZFS_CTLDIR_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
operator|)
operator|!=
literal|0
operator|&&
name|nameiop
operator|!=
name|LOOKUP
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
expr_stmt|;
else|else
operator|*
name|vpp
operator|=
name|zfsctl_root
argument_list|(
name|zdp
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|zfs_lookup_lock
argument_list|(
name|dvp
argument_list|,
operator|*
name|vpp
argument_list|,
name|nm
argument_list|,
name|cnp
operator|->
name|cn_lkflags
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * The loop is retry the lookup if the parent-child relationship 	 * changes during the dot-dot locking complexities. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|uint64_t
name|parent
decl_stmt|;
name|error
operator|=
name|zfs_dirlook
argument_list|(
name|zdp
argument_list|,
name|nm
argument_list|,
operator|&
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
name|vpp
operator|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|error
operator|=
name|zfs_lookup_lock
argument_list|(
name|dvp
argument_list|,
operator|*
name|vpp
argument_list|,
name|nm
argument_list|,
name|cnp
operator|->
name|cn_lkflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * If we've got a locking error, then the vnode 			 * got reclaimed because of a force unmount. 			 * We never enter doomed vnodes into the name cache. 			 */
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISDOTDOT
operator|)
operator|==
literal|0
condition|)
break|break;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|zdp
operator|->
name|z_sa_hdl
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|sa_lookup
argument_list|(
name|zdp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_PARENT
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|&
name|parent
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|zp
operator|->
name|z_id
operator|==
name|parent
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
break|break;
block|}
name|vput
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
comment|/* Translate errors and add SAVENAME when needed. */
if|if
condition|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
condition|)
block|{
switch|switch
condition|(
name|nameiop
condition|)
block|{
case|case
name|CREATE
case|:
case|case
name|RENAME
case|:
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
block|{
name|error
operator|=
name|EJUSTRETURN
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|DELETE
case|:
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
break|break;
block|}
block|}
comment|/* Insert name into cache (as non-existent) if appropriate. */
if|if
condition|(
name|zfsvfs
operator|->
name|z_use_namecache
operator|&&
name|error
operator|==
name|ENOENT
operator|&&
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
operator|)
operator|!=
literal|0
condition|)
name|cache_enter
argument_list|(
name|dvp
argument_list|,
name|NULL
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
comment|/* Insert name into cache if appropriate. */
if|if
condition|(
name|zfsvfs
operator|->
name|z_use_namecache
operator|&&
name|error
operator|==
literal|0
operator|&&
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
operator|)
operator|||
operator|(
name|nameiop
operator|!=
name|DELETE
operator|&&
name|nameiop
operator|!=
name|RENAME
operator|)
condition|)
block|{
name|cache_enter
argument_list|(
name|dvp
argument_list|,
operator|*
name|vpp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt to create a new entry in a directory.  If the entry  * already exists, truncate the file if permissible, else return  * an error.  Return the vp of the created or trunc'd file.  *  *	IN:	dvp	- vnode of directory to put new file entry in.  *		name	- name of new file entry.  *		vap	- attributes of new file.  *		excl	- flag indicating exclusive or non-exclusive mode.  *		mode	- mode to open file with.  *		cr	- credentials of caller.  *		flag	- large file flag [UNUSED].  *		ct	- caller context  *		vsecp	- ACL to be set  *  *	OUT:	vpp	- vnode of created or trunc'd entry.  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	dvp - ctime|mtime updated if new entry created  *	 vp - ctime|mtime always, atime if new  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_create
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|int
name|excl
parameter_list|,
name|int
name|mode
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|kthread_t
modifier|*
name|td
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
decl_stmt|,
modifier|*
name|dzp
init|=
name|VTOZ
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ksid_t
modifier|*
name|ksid
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
init|=
name|crgetgid
argument_list|(
name|cr
argument_list|)
decl_stmt|;
name|zfs_acl_ids_t
name|acl_ids
decl_stmt|;
name|boolean_t
name|fuid_dirtied
decl_stmt|;
name|void
modifier|*
name|vsecp
init|=
name|NULL
decl_stmt|;
name|int
name|flag
init|=
literal|0
decl_stmt|;
name|uint64_t
name|txtype
decl_stmt|;
comment|/* 	 * If we have an ephemeral id, ACL, or XVATTR then 	 * make sure file system is at proper version 	 */
name|ksid
operator|=
name|crgetsid
argument_list|(
name|cr
argument_list|,
name|KSID_OWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ksid
condition|)
name|uid
operator|=
name|ksid_getid
argument_list|(
name|ksid
argument_list|)
expr_stmt|;
else|else
name|uid
operator|=
name|crgetuid
argument_list|(
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_use_fuids
operator|==
name|B_FALSE
operator|&&
operator|(
name|vsecp
operator|||
operator|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_XVATTR
operator|)
operator|||
name|IS_EPHEMERAL
argument_list|(
name|uid
argument_list|)
operator|||
name|IS_EPHEMERAL
argument_list|(
name|gid
argument_list|)
operator|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|dzp
argument_list|)
expr_stmt|;
name|os
operator|=
name|zfsvfs
operator|->
name|z_os
expr_stmt|;
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_utf8
operator|&&
name|u8_validate
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|U8_VALIDATE_ENTIRE
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EILSEQ
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_XVATTR
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|secpolicy_xvattr
argument_list|(
name|dvp
argument_list|,
operator|(
name|xvattr_t
operator|*
operator|)
name|vap
argument_list|,
name|crgetuid
argument_list|(
name|cr
argument_list|)
argument_list|,
name|cr
argument_list|,
name|vap
operator|->
name|va_type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|vap
operator|->
name|va_mode
operator|&
name|S_ISVTX
operator|)
operator|&&
name|secpolicy_vnode_stky_modify
argument_list|(
name|cr
argument_list|)
condition|)
name|vap
operator|->
name|va_mode
operator|&=
operator|~
name|S_ISVTX
expr_stmt|;
name|error
operator|=
name|zfs_dirent_lookup
argument_list|(
name|dzp
argument_list|,
name|name
argument_list|,
operator|&
name|zp
argument_list|,
name|ZNEW
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ASSERT3P
argument_list|(
name|zp
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Create a new file object and update the directory 	 * to reference it. 	 */
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|dzp
argument_list|,
name|ACE_ADD_FILE
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* 	 * We only support the creation of regular files in 	 * extended attribute directories. 	 */
if|if
condition|(
operator|(
name|dzp
operator|->
name|z_pflags
operator|&
name|ZFS_XATTR
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_type
operator|!=
name|VREG
operator|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_acl_ids_create
argument_list|(
name|dzp
argument_list|,
literal|0
argument_list|,
name|vap
argument_list|,
name|cr
argument_list|,
name|vsecp
argument_list|,
operator|&
name|acl_ids
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|zfs_acl_ids_overquota
argument_list|(
name|zfsvfs
argument_list|,
operator|&
name|acl_ids
argument_list|)
condition|)
block|{
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EDQUOT
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|getnewvnode_reserve
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa_create
argument_list|(
name|tx
argument_list|,
name|acl_ids
operator|.
name|z_aclp
operator|->
name|z_acl_bytes
operator|+
name|ZFS_SA_BASE_ATTR_SIZE
argument_list|)
expr_stmt|;
name|fuid_dirtied
operator|=
name|zfsvfs
operator|->
name|z_fuid_dirty
expr_stmt|;
if|if
condition|(
name|fuid_dirtied
condition|)
name|zfs_fuid_txhold
argument_list|(
name|zfsvfs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|TRUE
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zfsvfs
operator|->
name|z_use_sa
operator|&&
name|acl_ids
operator|.
name|z_aclp
operator|->
name|z_acl_bytes
operator|>
name|ZFS_ACE_SPACE
condition|)
block|{
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|acl_ids
operator|.
name|z_aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|getnewvnode_drop_reserve
argument_list|()
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|zfs_mknode
argument_list|(
name|dzp
argument_list|,
name|vap
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
literal|0
argument_list|,
operator|&
name|zp
argument_list|,
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuid_dirtied
condition|)
name|zfs_fuid_sync
argument_list|(
name|zfsvfs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_link_create
argument_list|(
name|dzp
argument_list|,
name|name
argument_list|,
name|zp
argument_list|,
name|tx
argument_list|,
name|ZNEW
argument_list|)
expr_stmt|;
name|txtype
operator|=
name|zfs_log_create_txtype
argument_list|(
name|Z_FILE
argument_list|,
name|vsecp
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|zfs_log_create
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|txtype
argument_list|,
name|dzp
argument_list|,
name|zp
argument_list|,
name|name
argument_list|,
name|vsecp
argument_list|,
name|acl_ids
operator|.
name|z_fuidp
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|getnewvnode_drop_reserve
argument_list|()
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|vpp
operator|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
condition|)
name|zil_commit
argument_list|(
name|zilog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove an entry from a directory.  *  *	IN:	dvp	- vnode of directory to remove entry from.  *		name	- name of entry to remove.  *		cr	- credentials of caller.  *		ct	- caller context  *		flags	- case flags  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	dvp - ctime|mtime  *	 vp - ctime (if nlink> 0)  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_remove
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|znode_t
modifier|*
name|dzp
init|=
name|VTOZ
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|znode_t
modifier|*
name|xzp
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|uint64_t
name|acl_obj
decl_stmt|,
name|xattr_obj
decl_stmt|;
name|uint64_t
name|obj
init|=
literal|0
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|boolean_t
name|unlinked
decl_stmt|,
name|toobig
init|=
name|FALSE
decl_stmt|;
name|uint64_t
name|txtype
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|dzp
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
name|zp
operator|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|xattr_obj
operator|=
literal|0
expr_stmt|;
name|xzp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|zfs_zaccess_delete
argument_list|(
name|dzp
argument_list|,
name|zp
argument_list|,
name|cr
argument_list|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Need to use rmdir for removing directories. 	 */
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vnevent_remove
argument_list|(
name|vp
argument_list|,
name|dvp
argument_list|,
name|name
argument_list|,
name|ct
argument_list|)
expr_stmt|;
name|obj
operator|=
name|zp
operator|->
name|z_id
expr_stmt|;
comment|/* are there any extended attributes? */
name|error
operator|=
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_XATTR
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|&
name|xattr_obj
argument_list|,
sizeof|sizeof
argument_list|(
name|xattr_obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|xattr_obj
condition|)
block|{
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|xattr_obj
argument_list|,
operator|&
name|xzp
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We may delete the znode now, or we may put it in the unlinked set; 	 * it depends on whether we're the last link, and on whether there are 	 * other holds on the vnode.  So we dmu_tx_hold() the right things to 	 * allow for either case. 	 */
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|FALSE
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|dzp
argument_list|)
expr_stmt|;
if|if
condition|(
name|xzp
condition|)
block|{
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|xzp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* charge as an update -- would be nice not to charge at all */
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_unlinkedobj
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Mark this transaction as typically resulting in a net free of space 	 */
name|dmu_tx_mark_netfree
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Remove the directory entry. 	 */
name|error
operator|=
name|zfs_link_destroy
argument_list|(
name|dzp
argument_list|,
name|name
argument_list|,
name|zp
argument_list|,
name|tx
argument_list|,
name|ZEXISTS
argument_list|,
operator|&
name|unlinked
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|unlinked
condition|)
block|{
name|zfs_unlinked_add
argument_list|(
name|zp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_vflag
operator||=
name|VV_NOSYNC
expr_stmt|;
block|}
name|txtype
operator|=
name|TX_REMOVE
expr_stmt|;
name|zfs_log_remove
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|txtype
argument_list|,
name|dzp
argument_list|,
name|name
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|xzp
condition|)
name|vrele
argument_list|(
name|ZTOV
argument_list|(
name|xzp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
condition|)
name|zil_commit
argument_list|(
name|zilog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new directory and insert it into dvp using the name  * provided.  Return a pointer to the inserted directory.  *  *	IN:	dvp	- vnode of directory to add subdir to.  *		dirname	- name of new directory.  *		vap	- attributes of new directory.  *		cr	- credentials of caller.  *		ct	- caller context  *		flags	- case flags  *		vsecp	- ACL to be set  *  *	OUT:	vpp	- vnode of created directory.  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	dvp - ctime|mtime updated  *	 vp - ctime|mtime|atime updated  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_mkdir
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|dirname
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
decl_stmt|,
modifier|*
name|dzp
init|=
name|VTOZ
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|uint64_t
name|txtype
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ksid_t
modifier|*
name|ksid
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
init|=
name|crgetgid
argument_list|(
name|cr
argument_list|)
decl_stmt|;
name|zfs_acl_ids_t
name|acl_ids
decl_stmt|;
name|boolean_t
name|fuid_dirtied
decl_stmt|;
name|ASSERT
argument_list|(
name|vap
operator|->
name|va_type
operator|==
name|VDIR
argument_list|)
expr_stmt|;
comment|/* 	 * If we have an ephemeral id, ACL, or XVATTR then 	 * make sure file system is at proper version 	 */
name|ksid
operator|=
name|crgetsid
argument_list|(
name|cr
argument_list|,
name|KSID_OWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ksid
condition|)
name|uid
operator|=
name|ksid_getid
argument_list|(
name|ksid
argument_list|)
expr_stmt|;
else|else
name|uid
operator|=
name|crgetuid
argument_list|(
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_use_fuids
operator|==
name|B_FALSE
operator|&&
operator|(
operator|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_XVATTR
operator|)
operator|||
name|IS_EPHEMERAL
argument_list|(
name|uid
argument_list|)
operator|||
name|IS_EPHEMERAL
argument_list|(
name|gid
argument_list|)
operator|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|dzp
argument_list|)
expr_stmt|;
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
if|if
condition|(
name|dzp
operator|->
name|z_pflags
operator|&
name|ZFS_XATTR
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zfsvfs
operator|->
name|z_utf8
operator|&&
name|u8_validate
argument_list|(
name|dirname
argument_list|,
name|strlen
argument_list|(
name|dirname
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|U8_VALIDATE_ENTIRE
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EILSEQ
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_XVATTR
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|secpolicy_xvattr
argument_list|(
name|dvp
argument_list|,
operator|(
name|xvattr_t
operator|*
operator|)
name|vap
argument_list|,
name|crgetuid
argument_list|(
name|cr
argument_list|)
argument_list|,
name|cr
argument_list|,
name|vap
operator|->
name|va_type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_acl_ids_create
argument_list|(
name|dzp
argument_list|,
literal|0
argument_list|,
name|vap
argument_list|,
name|cr
argument_list|,
name|NULL
argument_list|,
operator|&
name|acl_ids
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * First make sure the new directory doesn't exist. 	 * 	 * Existence is checked first to make sure we don't return 	 * EACCES instead of EEXIST which can cause some applications 	 * to fail. 	 */
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|zfs_dirent_lookup
argument_list|(
name|dzp
argument_list|,
name|dirname
argument_list|,
operator|&
name|zp
argument_list|,
name|ZNEW
argument_list|)
condition|)
block|{
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ASSERT3P
argument_list|(
name|zp
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|dzp
argument_list|,
name|ACE_ADD_SUBDIRECTORY
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
condition|)
block|{
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|zfs_acl_ids_overquota
argument_list|(
name|zfsvfs
argument_list|,
operator|&
name|acl_ids
argument_list|)
condition|)
block|{
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EDQUOT
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Add a new entry to the directory. 	 */
name|getnewvnode_reserve
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|TRUE
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fuid_dirtied
operator|=
name|zfsvfs
operator|->
name|z_fuid_dirty
expr_stmt|;
if|if
condition|(
name|fuid_dirtied
condition|)
name|zfs_fuid_txhold
argument_list|(
name|zfsvfs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zfsvfs
operator|->
name|z_use_sa
operator|&&
name|acl_ids
operator|.
name|z_aclp
operator|->
name|z_acl_bytes
operator|>
name|ZFS_ACE_SPACE
condition|)
block|{
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|acl_ids
operator|.
name|z_aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_hold_sa_create
argument_list|(
name|tx
argument_list|,
name|acl_ids
operator|.
name|z_aclp
operator|->
name|z_acl_bytes
operator|+
name|ZFS_SA_BASE_ATTR_SIZE
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|getnewvnode_drop_reserve
argument_list|()
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Create new node. 	 */
name|zfs_mknode
argument_list|(
name|dzp
argument_list|,
name|vap
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
literal|0
argument_list|,
operator|&
name|zp
argument_list|,
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuid_dirtied
condition|)
name|zfs_fuid_sync
argument_list|(
name|zfsvfs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Now put new name in parent dir. 	 */
operator|(
name|void
operator|)
name|zfs_link_create
argument_list|(
name|dzp
argument_list|,
name|dirname
argument_list|,
name|zp
argument_list|,
name|tx
argument_list|,
name|ZNEW
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|txtype
operator|=
name|zfs_log_create_txtype
argument_list|(
name|Z_DIR
argument_list|,
name|NULL
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|zfs_log_create
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|txtype
argument_list|,
name|dzp
argument_list|,
name|zp
argument_list|,
name|dirname
argument_list|,
name|NULL
argument_list|,
name|acl_ids
operator|.
name|z_fuidp
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|getnewvnode_drop_reserve
argument_list|()
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
condition|)
name|zil_commit
argument_list|(
name|zilog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a directory subdir entry.  If the current working  * directory is the same as the subdir to be removed, the  * remove will fail.  *  *	IN:	dvp	- vnode of directory to remove from.  *		name	- name of directory to be removed.  *		cwd	- vnode of current working directory.  *		cr	- credentials of caller.  *		ct	- caller context  *		flags	- case flags  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	dvp - ctime|mtime updated  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_rmdir
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|znode_t
modifier|*
name|dzp
init|=
name|VTOZ
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|dzp
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|zfs_zaccess_delete
argument_list|(
name|dzp
argument_list|,
name|zp
argument_list|,
name|cr
argument_list|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOTDIR
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vnevent_rmdir
argument_list|(
name|vp
argument_list|,
name|dvp
argument_list|,
name|name
argument_list|,
name|ct
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|FALSE
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_unlinkedobj
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|dzp
argument_list|)
expr_stmt|;
name|dmu_tx_mark_netfree
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|cache_purge
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_link_destroy
argument_list|(
name|dzp
argument_list|,
name|name
argument_list|,
name|zp
argument_list|,
name|tx
argument_list|,
name|ZEXISTS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|txtype
init|=
name|TX_RMDIR
decl_stmt|;
name|zfs_log_remove
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|txtype
argument_list|,
name|dzp
argument_list|,
name|name
argument_list|,
name|ZFS_NO_OBJECT
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
condition|)
name|zil_commit
argument_list|(
name|zilog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read as many directory entries as will fit into the provided  * buffer from the given directory cursor position (specified in  * the uio structure).  *  *	IN:	vp	- vnode of directory to read.  *		uio	- structure supplying read location, range info,  *			  and return buffer.  *		cr	- credentials of caller.  *		ct	- caller context  *		flags	- case flags  *  *	OUT:	uio	- updated offset and range, buffer filled.  *		eofp	- set to true if end-of-file detected.  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	vp - atime updated  *  * Note that the low 4 bits of the cookie returned by zap is always zero.  * This allows us to use the low range for "special" directory entries:  * We use 0 for '.', and 1 for '..'.  If this is the root of the filesystem,  * we use the offset 2 for the '.zfs' directory.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_readdir
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|,
name|int
modifier|*
name|ncookies
parameter_list|,
name|u_long
modifier|*
modifier|*
name|cookies
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|iovec_t
modifier|*
name|iovp
decl_stmt|;
name|edirent_t
modifier|*
name|eodp
decl_stmt|;
name|dirent64_t
modifier|*
name|odp
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|caddr_t
name|outbuf
decl_stmt|;
name|size_t
name|bufsize
decl_stmt|;
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|zap
decl_stmt|;
name|uint_t
name|bytes_wanted
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|;
comment|/* must be unsigned; checks for< 1 */
name|uint64_t
name|parent
decl_stmt|;
name|int
name|local_eof
decl_stmt|;
name|int
name|outcount
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint8_t
name|prefetch
decl_stmt|;
name|boolean_t
name|check_sysattrs
decl_stmt|;
name|uint8_t
name|type
decl_stmt|;
name|int
name|ncooks
decl_stmt|;
name|u_long
modifier|*
name|cooks
init|=
name|NULL
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_PARENT
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|&
name|parent
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * If we are not given an eof variable, 	 * use a local one. 	 */
if|if
condition|(
name|eofp
operator|==
name|NULL
condition|)
name|eofp
operator|=
operator|&
name|local_eof
expr_stmt|;
comment|/* 	 * Check for valid iov_len. 	 */
if|if
condition|(
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|<=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Quit if directory has been removed (posix) 	 */
if|if
condition|(
operator|(
operator|*
name|eofp
operator|=
name|zp
operator|->
name|z_unlinked
operator|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|os
operator|=
name|zfsvfs
operator|->
name|z_os
expr_stmt|;
name|offset
operator|=
name|uio
operator|->
name|uio_loffset
expr_stmt|;
name|prefetch
operator|=
name|zp
operator|->
name|z_zn_prefetch
expr_stmt|;
comment|/* 	 * Initialize the iterator cursor. 	 */
if|if
condition|(
name|offset
operator|<=
literal|3
condition|)
block|{
comment|/* 		 * Start iteration from the beginning of the directory. 		 */
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The offset is a serialized cursor. 		 */
name|zap_cursor_init_serialized
argument_list|(
operator|&
name|zc
argument_list|,
name|os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Get space to change directory entries into fs independent format. 	 */
name|iovp
operator|=
name|uio
operator|->
name|uio_iov
expr_stmt|;
name|bytes_wanted
operator|=
name|iovp
operator|->
name|iov_len
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_segflg
operator|!=
name|UIO_SYSSPACE
operator|||
name|uio
operator|->
name|uio_iovcnt
operator|!=
literal|1
condition|)
block|{
name|bufsize
operator|=
name|bytes_wanted
expr_stmt|;
name|outbuf
operator|=
name|kmem_alloc
argument_list|(
name|bufsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|odp
operator|=
operator|(
expr|struct
name|dirent64
operator|*
operator|)
name|outbuf
expr_stmt|;
block|}
else|else
block|{
name|bufsize
operator|=
name|bytes_wanted
expr_stmt|;
name|outbuf
operator|=
name|NULL
expr_stmt|;
name|odp
operator|=
operator|(
expr|struct
name|dirent64
operator|*
operator|)
name|iovp
operator|->
name|iov_base
expr_stmt|;
block|}
name|eodp
operator|=
operator|(
expr|struct
name|edirent
operator|*
operator|)
name|odp
expr_stmt|;
if|if
condition|(
name|ncookies
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Minimum entry size is dirent size and 1 byte for a file name. 		 */
name|ncooks
operator|=
name|uio
operator|->
name|uio_resid
operator|/
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
operator|(
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|NULL
operator|)
operator|->
name|d_name
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|cooks
operator|=
name|malloc
argument_list|(
name|ncooks
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
operator|*
name|cookies
operator|=
name|cooks
expr_stmt|;
operator|*
name|ncookies
operator|=
name|ncooks
expr_stmt|;
block|}
comment|/* 	 * If this VFS supports the system attribute view interface; and 	 * we're looking at an extended attribute directory; and we care 	 * about normalization conflicts on this vfs; then we must check 	 * for normalization conflicts with the sysattr name space. 	 */
ifdef|#
directive|ifdef
name|TODO
name|check_sysattrs
operator|=
name|vfs_has_feature
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_SYSATTR_VIEWS
argument_list|)
operator|&&
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|V_XATTRDIR
operator|)
operator|&&
name|zfsvfs
operator|->
name|z_norm
operator|&&
operator|(
name|flags
operator|&
name|V_RDDIR_ENTFLAGS
operator|)
expr_stmt|;
else|#
directive|else
name|check_sysattrs
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Transform to file-system independent format 	 */
name|outcount
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|outcount
operator|<
name|bytes_wanted
condition|)
block|{
name|ino64_t
name|objnum
decl_stmt|;
name|ushort_t
name|reclen
decl_stmt|;
name|off64_t
modifier|*
name|next
init|=
name|NULL
decl_stmt|;
comment|/* 		 * Special case `.', `..', and `.zfs'. 		 */
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zap
operator|.
name|za_name
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|zap
operator|.
name|za_normalization_conflict
operator|=
literal|0
expr_stmt|;
name|objnum
operator|=
name|zp
operator|->
name|z_id
expr_stmt|;
name|type
operator|=
name|DT_DIR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|==
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zap
operator|.
name|za_name
argument_list|,
literal|".."
argument_list|)
expr_stmt|;
name|zap
operator|.
name|za_normalization_conflict
operator|=
literal|0
expr_stmt|;
name|objnum
operator|=
name|parent
expr_stmt|;
name|type
operator|=
name|DT_DIR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|==
literal|2
operator|&&
name|zfs_show_ctldir
argument_list|(
name|zp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zap
operator|.
name|za_name
argument_list|,
name|ZFS_CTLDIR_NAME
argument_list|)
expr_stmt|;
name|zap
operator|.
name|za_normalization_conflict
operator|=
literal|0
expr_stmt|;
name|objnum
operator|=
name|ZFSCTL_INO_ROOT
expr_stmt|;
name|type
operator|=
name|DT_DIR
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Grab next entry. 			 */
if|if
condition|(
name|error
operator|=
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|zap
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|eofp
operator|=
operator|(
name|error
operator|==
name|ENOENT
operator|)
operator|)
operator|!=
literal|0
condition|)
break|break;
else|else
goto|goto
name|update
goto|;
block|}
if|if
condition|(
name|zap
operator|.
name|za_integer_length
operator|!=
literal|8
operator|||
name|zap
operator|.
name|za_num_integers
operator|!=
literal|1
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"zap_readdir: bad directory "
literal|"entry, obj = %lld, offset = %lld\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|zp
operator|->
name|z_id
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|offset
argument_list|)
expr_stmt|;
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
goto|goto
name|update
goto|;
block|}
name|objnum
operator|=
name|ZFS_DIRENT_OBJ
argument_list|(
name|zap
operator|.
name|za_first_integer
argument_list|)
expr_stmt|;
comment|/* 			 * MacOS X can extract the object type here such as: 			 * uint8_t type = ZFS_DIRENT_TYPE(zap.za_first_integer); 			 */
name|type
operator|=
name|ZFS_DIRENT_TYPE
argument_list|(
name|zap
operator|.
name|za_first_integer
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_sysattrs
operator|&&
operator|!
name|zap
operator|.
name|za_normalization_conflict
condition|)
block|{
ifdef|#
directive|ifdef
name|TODO
name|zap
operator|.
name|za_normalization_conflict
operator|=
name|xattr_sysattr_casechk
argument_list|(
name|zap
operator|.
name|za_name
argument_list|)
expr_stmt|;
else|#
directive|else
name|panic
argument_list|(
literal|"%s:%u: TODO"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|V_RDDIR_ACCFILTER
condition|)
block|{
comment|/* 			 * If we have no access at all, don't include 			 * this entry in the returned information 			 */
name|znode_t
modifier|*
name|ezp
decl_stmt|;
if|if
condition|(
name|zfs_zget
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|,
name|objnum
argument_list|,
operator|&
name|ezp
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|skip_entry
goto|;
if|if
condition|(
operator|!
name|zfs_has_access
argument_list|(
name|ezp
argument_list|,
name|cr
argument_list|)
condition|)
block|{
name|vrele
argument_list|(
name|ZTOV
argument_list|(
name|ezp
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|skip_entry
goto|;
block|}
name|vrele
argument_list|(
name|ZTOV
argument_list|(
name|ezp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|V_RDDIR_ENTFLAGS
condition|)
name|reclen
operator|=
name|EDIRENT_RECLEN
argument_list|(
name|strlen
argument_list|(
name|zap
operator|.
name|za_name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|reclen
operator|=
name|DIRENT64_RECLEN
argument_list|(
name|strlen
argument_list|(
name|zap
operator|.
name|za_name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Will this entry fit in the buffer? 		 */
if|if
condition|(
name|outcount
operator|+
name|reclen
operator|>
name|bufsize
condition|)
block|{
comment|/* 			 * Did we manage to fit anything in the buffer? 			 */
if|if
condition|(
operator|!
name|outcount
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|update
goto|;
block|}
break|break;
block|}
if|if
condition|(
name|flags
operator|&
name|V_RDDIR_ENTFLAGS
condition|)
block|{
comment|/* 			 * Add extended flag entry: 			 */
name|eodp
operator|->
name|ed_ino
operator|=
name|objnum
expr_stmt|;
name|eodp
operator|->
name|ed_reclen
operator|=
name|reclen
expr_stmt|;
comment|/* NOTE: ed_off is the offset for the *next* entry */
name|next
operator|=
operator|&
operator|(
name|eodp
operator|->
name|ed_off
operator|)
expr_stmt|;
name|eodp
operator|->
name|ed_eflags
operator|=
name|zap
operator|.
name|za_normalization_conflict
condition|?
name|ED_CASE_CONFLICT
else|:
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|eodp
operator|->
name|ed_name
argument_list|,
name|zap
operator|.
name|za_name
argument_list|,
name|EDIRENT_NAMELEN
argument_list|(
name|reclen
argument_list|)
argument_list|)
expr_stmt|;
name|eodp
operator|=
operator|(
name|edirent_t
operator|*
operator|)
operator|(
operator|(
name|intptr_t
operator|)
name|eodp
operator|+
name|reclen
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Add normal entry: 			 */
name|odp
operator|->
name|d_ino
operator|=
name|objnum
expr_stmt|;
name|odp
operator|->
name|d_reclen
operator|=
name|reclen
expr_stmt|;
name|odp
operator|->
name|d_namlen
operator|=
name|strlen
argument_list|(
name|zap
operator|.
name|za_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|odp
operator|->
name|d_name
argument_list|,
name|zap
operator|.
name|za_name
argument_list|,
name|odp
operator|->
name|d_namlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|odp
operator|->
name|d_type
operator|=
name|type
expr_stmt|;
name|odp
operator|=
operator|(
name|dirent64_t
operator|*
operator|)
operator|(
operator|(
name|intptr_t
operator|)
name|odp
operator|+
name|reclen
operator|)
expr_stmt|;
block|}
name|outcount
operator|+=
name|reclen
expr_stmt|;
name|ASSERT
argument_list|(
name|outcount
operator|<=
name|bufsize
argument_list|)
expr_stmt|;
comment|/* Prefetch znode */
if|if
condition|(
name|prefetch
condition|)
name|dmu_prefetch
argument_list|(
name|os
argument_list|,
name|objnum
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ZIO_PRIORITY_SYNC_READ
argument_list|)
expr_stmt|;
name|skip_entry
label|:
comment|/* 		 * Move to the next entry, fill in the previous offset. 		 */
if|if
condition|(
name|offset
operator|>
literal|2
operator|||
operator|(
name|offset
operator|==
literal|2
operator|&&
operator|!
name|zfs_show_ctldir
argument_list|(
name|zp
argument_list|)
operator|)
condition|)
block|{
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|offset
operator|=
name|zap_cursor_serialize
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cooks
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cooks
operator|++
operator|=
name|offset
expr_stmt|;
name|ncooks
operator|--
expr_stmt|;
name|KASSERT
argument_list|(
name|ncooks
operator|>=
literal|0
argument_list|,
operator|(
literal|"ncookies=%d"
operator|,
name|ncooks
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|zp
operator|->
name|z_zn_prefetch
operator|=
name|B_FALSE
expr_stmt|;
comment|/* a lookup will re-enable pre-fetching */
comment|/* Subtract unused cookies */
if|if
condition|(
name|ncookies
operator|!=
name|NULL
condition|)
operator|*
name|ncookies
operator|-=
name|ncooks
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_segflg
operator|==
name|UIO_SYSSPACE
operator|&&
name|uio
operator|->
name|uio_iovcnt
operator|==
literal|1
condition|)
block|{
name|iovp
operator|->
name|iov_base
operator|+=
name|outcount
expr_stmt|;
name|iovp
operator|->
name|iov_len
operator|-=
name|outcount
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|-=
name|outcount
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|=
name|uiomove
argument_list|(
name|outbuf
argument_list|,
operator|(
name|long
operator|)
name|outcount
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
condition|)
block|{
comment|/* 		 * Reset the pointer. 		 */
name|offset
operator|=
name|uio
operator|->
name|uio_loffset
expr_stmt|;
block|}
name|update
label|:
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_segflg
operator|!=
name|UIO_SYSSPACE
operator|||
name|uio
operator|->
name|uio_iovcnt
operator|!=
literal|1
condition|)
name|kmem_free
argument_list|(
name|outbuf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
literal|0
expr_stmt|;
name|ZFS_ACCESSTIME_STAMP
argument_list|(
name|zfsvfs
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_loffset
operator|=
name|offset
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|cookies
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|*
name|cookies
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
operator|*
name|cookies
operator|=
name|NULL
expr_stmt|;
operator|*
name|ncookies
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|ulong_t
name|zfs_fsync_sync_cnt
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|zfs_fsync
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|syncflag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
operator|(
name|void
operator|)
name|tsd_set
argument_list|(
name|zfs_fsyncer_key
argument_list|,
operator|(
name|void
operator|*
operator|)
name|zfs_fsync_sync_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|!=
name|ZFS_SYNC_DISABLED
condition|)
block|{
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|zil_commit
argument_list|(
name|zfsvfs
operator|->
name|z_log
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the requested file attributes and place them in the provided  * vattr structure.  *  *	IN:	vp	- vnode of file.  *		vap	- va_mask identifies requested attributes.  *			  If AT_XVATTR set, then optional attrs are requested  *		flags	- ATTR_NOACLCHECK (CIFS server context)  *		cr	- credentials of caller.  *		ct	- caller context  *  *	OUT:	vap	- attribute values.  *  *	RETURN:	0 (always succeeds).  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_getattr
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint32_t
name|blksize
decl_stmt|;
name|u_longlong_t
name|nblocks
decl_stmt|;
name|uint64_t
name|links
decl_stmt|;
name|uint64_t
name|mtime
index|[
literal|2
index|]
decl_stmt|,
name|ctime
index|[
literal|2
index|]
decl_stmt|,
name|crtime
index|[
literal|2
index|]
decl_stmt|,
name|rdev
decl_stmt|;
name|xvattr_t
modifier|*
name|xvap
init|=
operator|(
name|xvattr_t
operator|*
operator|)
name|vap
decl_stmt|;
comment|/* vap may be an xvattr_t * */
name|xoptattr_t
modifier|*
name|xoap
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|skipaclchk
init|=
operator|(
name|flags
operator|&
name|ATTR_NOACLCHECK
operator|)
condition|?
name|B_TRUE
else|:
name|B_FALSE
decl_stmt|;
name|sa_bulk_attr_t
name|bulk
index|[
literal|4
index|]
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|zfs_fuid_map_ids
argument_list|(
name|zp
argument_list|,
name|cr
argument_list|,
operator|&
name|vap
operator|->
name|va_uid
argument_list|,
operator|&
name|vap
operator|->
name|va_gid
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_MTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|mtime
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_CTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|ctime
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_CRTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|crtime
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VBLK
operator|||
name|vp
operator|->
name|v_type
operator|==
name|VCHR
condition|)
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_RDEV
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|rdev
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sa_bulk_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|bulk
argument_list|,
name|count
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * If ACL is trivial don't bother looking for ACE_READ_ATTRIBUTES. 	 * Also, if we are the owner don't bother, since owner should 	 * always be allowed to read basic attributes of file. 	 */
if|if
condition|(
operator|!
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_ACL_TRIVIAL
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_uid
operator|!=
name|crgetuid
argument_list|(
name|cr
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|ACE_READ_ATTRIBUTES
argument_list|,
literal|0
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Return all attributes.  It's cheaper to provide the answer 	 * than to determine whether we were asked the question. 	 */
name|vap
operator|->
name|va_type
operator|=
name|IFTOVT
argument_list|(
name|zp
operator|->
name|z_mode
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_mode
operator|=
name|zp
operator|->
name|z_mode
operator|&
operator|~
name|S_IFMT
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|vap
operator|->
name|va_fsid
operator|=
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_dev
expr_stmt|;
else|#
directive|else
name|vap
operator|->
name|va_fsid
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
name|vap
operator|->
name|va_nodeid
operator|=
name|zp
operator|->
name|z_id
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|VROOT
operator|)
operator|&&
name|zfs_show_ctldir
argument_list|(
name|zp
argument_list|)
condition|)
name|links
operator|=
name|zp
operator|->
name|z_links
operator|+
literal|1
expr_stmt|;
else|else
name|links
operator|=
name|zp
operator|->
name|z_links
expr_stmt|;
name|vap
operator|->
name|va_nlink
operator|=
name|MIN
argument_list|(
name|links
argument_list|,
name|LINK_MAX
argument_list|)
expr_stmt|;
comment|/* nlink_t limit! */
name|vap
operator|->
name|va_size
operator|=
name|zp
operator|->
name|z_size
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
name|vap
operator|->
name|va_rdev
operator|=
name|vp
operator|->
name|v_rdev
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VBLK
operator|||
name|vp
operator|->
name|v_type
operator|==
name|VCHR
condition|)
name|vap
operator|->
name|va_rdev
operator|=
name|zfs_cmpldev
argument_list|(
name|rdev
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vap
operator|->
name|va_seq
operator|=
name|zp
operator|->
name|z_seq
expr_stmt|;
name|vap
operator|->
name|va_flags
operator|=
literal|0
expr_stmt|;
comment|/* FreeBSD: Reset chflags(2) flags. */
name|vap
operator|->
name|va_filerev
operator|=
name|zp
operator|->
name|z_seq
expr_stmt|;
comment|/* 	 * Add in any requested optional attributes and the create time. 	 * Also set the corresponding bits in the returned attribute bitmap. 	 */
if|if
condition|(
operator|(
name|xoap
operator|=
name|xva_getxoptattr
argument_list|(
name|xvap
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|zfsvfs
operator|->
name|z_use_fuids
condition|)
block|{
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_ARCHIVE
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_archive
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_ARCHIVE
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_ARCHIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_READONLY
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_readonly
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_READONLY
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_READONLY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_SYSTEM
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_system
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_SYSTEM
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_SYSTEM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_HIDDEN
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_hidden
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_HIDDEN
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_HIDDEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_NOUNLINK
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_nounlink
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_NOUNLINK
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_NOUNLINK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_IMMUTABLE
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_immutable
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_IMMUTABLE
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_IMMUTABLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_APPENDONLY
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_appendonly
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_APPENDONLY
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_APPENDONLY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_NODUMP
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_nodump
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_NODUMP
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_NODUMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_OPAQUE
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_opaque
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_OPAQUE
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_OPAQUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_QUARANTINED
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_av_quarantined
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_AV_QUARANTINED
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_QUARANTINED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_MODIFIED
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_av_modified
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_AV_MODIFIED
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_MODIFIED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_SCANSTAMP
argument_list|)
operator|&&
name|vp
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
name|zfs_sa_get_scanstamp
argument_list|(
name|zp
argument_list|,
name|xvap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_REPARSE
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_reparse
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_REPARSE
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_REPARSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_GEN
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_generation
operator|=
name|zp
operator|->
name|z_gen
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_GEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_OFFLINE
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_offline
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_OFFLINE
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_OFFLINE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_SPARSE
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_sparse
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_SPARSE
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_SPARSE
argument_list|)
expr_stmt|;
block|}
block|}
name|ZFS_TIME_DECODE
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|,
name|zp
operator|->
name|z_atime
argument_list|)
expr_stmt|;
name|ZFS_TIME_DECODE
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
name|mtime
argument_list|)
expr_stmt|;
name|ZFS_TIME_DECODE
argument_list|(
operator|&
name|vap
operator|->
name|va_ctime
argument_list|,
name|ctime
argument_list|)
expr_stmt|;
name|ZFS_TIME_DECODE
argument_list|(
operator|&
name|vap
operator|->
name|va_birthtime
argument_list|,
name|crtime
argument_list|)
expr_stmt|;
name|sa_object_size
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
operator|&
name|blksize
argument_list|,
operator|&
name|nblocks
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_blksize
operator|=
name|blksize
expr_stmt|;
name|vap
operator|->
name|va_bytes
operator|=
name|nblocks
operator|<<
literal|9
expr_stmt|;
comment|/* nblocks * 512 */
if|if
condition|(
name|zp
operator|->
name|z_blksz
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Block size hasn't been set; suggest maximal I/O transfers. 		 */
name|vap
operator|->
name|va_blksize
operator|=
name|zfsvfs
operator|->
name|z_max_blksz
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the file attributes to the values contained in the  * vattr structure.  *  *	IN:	vp	- vnode of file to be modified.  *		vap	- new attribute values.  *			  If AT_XVATTR set, then optional attrs are being set  *		flags	- ATTR_UTIME set if non-default time values provided.  *			- ATTR_NOACLCHECK (CIFS context only).  *		cr	- credentials of caller.  *		ct	- caller context  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	vp - ctime updated, mtime updated if size changed.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_setattr
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|vattr_t
name|oldva
decl_stmt|;
name|xvattr_t
name|tmpxvattr
decl_stmt|;
name|uint_t
name|mask
init|=
name|vap
operator|->
name|va_mask
decl_stmt|;
name|uint_t
name|saved_mask
init|=
literal|0
decl_stmt|;
name|uint64_t
name|saved_mode
decl_stmt|;
name|int
name|trim_mask
init|=
literal|0
decl_stmt|;
name|uint64_t
name|new_mode
decl_stmt|;
name|uint64_t
name|new_uid
decl_stmt|,
name|new_gid
decl_stmt|;
name|uint64_t
name|xattr_obj
decl_stmt|;
name|uint64_t
name|mtime
index|[
literal|2
index|]
decl_stmt|,
name|ctime
index|[
literal|2
index|]
decl_stmt|;
name|znode_t
modifier|*
name|attrzp
decl_stmt|;
name|int
name|need_policy
init|=
name|FALSE
decl_stmt|;
name|int
name|err
decl_stmt|,
name|err2
decl_stmt|;
name|zfs_fuid_info_t
modifier|*
name|fuidp
init|=
name|NULL
decl_stmt|;
name|xvattr_t
modifier|*
name|xvap
init|=
operator|(
name|xvattr_t
operator|*
operator|)
name|vap
decl_stmt|;
comment|/* vap may be an xvattr_t * */
name|xoptattr_t
modifier|*
name|xoap
decl_stmt|;
name|zfs_acl_t
modifier|*
name|aclp
decl_stmt|;
name|boolean_t
name|skipaclchk
init|=
operator|(
name|flags
operator|&
name|ATTR_NOACLCHECK
operator|)
condition|?
name|B_TRUE
else|:
name|B_FALSE
decl_stmt|;
name|boolean_t
name|fuid_dirtied
init|=
name|B_FALSE
decl_stmt|;
name|sa_bulk_attr_t
name|bulk
index|[
literal|7
index|]
decl_stmt|,
name|xattr_bulk
index|[
literal|7
index|]
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|xattr_count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|mask
operator|&
name|AT_NOSET
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
comment|/* 	 * Make sure that if we have ephemeral uid/gid or xvattr specified 	 * that file system is at proper version level 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_use_fuids
operator|==
name|B_FALSE
operator|&&
operator|(
operator|(
operator|(
name|mask
operator|&
name|AT_UID
operator|)
operator|&&
name|IS_EPHEMERAL
argument_list|(
name|vap
operator|->
name|va_uid
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|mask
operator|&
name|AT_GID
operator|)
operator|&&
name|IS_EPHEMERAL
argument_list|(
name|vap
operator|->
name|va_gid
argument_list|)
operator|)
operator|||
operator|(
name|mask
operator|&
name|AT_XVATTR
operator|)
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|mask
operator|&
name|AT_SIZE
operator|&&
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EISDIR
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|mask
operator|&
name|AT_SIZE
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VREG
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VFIFO
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * If this is an xvattr_t, then get a pointer to the structure of 	 * optional attributes.  If this is NULL, then we have a vattr_t. 	 */
name|xoap
operator|=
name|xva_getxoptattr
argument_list|(
name|xvap
argument_list|)
expr_stmt|;
name|xva_init
argument_list|(
operator|&
name|tmpxvattr
argument_list|)
expr_stmt|;
comment|/* 	 * Immutable files can only alter immutable bit and atime 	 */
if|if
condition|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_IMMUTABLE
operator|)
operator|&&
operator|(
operator|(
name|mask
operator|&
operator|(
name|AT_SIZE
operator||
name|AT_UID
operator||
name|AT_GID
operator||
name|AT_MTIME
operator||
name|AT_MODE
operator|)
operator|)
operator|||
operator|(
operator|(
name|mask
operator|&
name|AT_XVATTR
operator|)
operator|&&
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_CREATETIME
argument_list|)
operator|)
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|AT_SIZE
operator|)
operator|&&
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_READONLY
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Verify timestamps doesn't overflow 32 bits. 	 * ZFS can handle large timestamps, but 32bit syscalls can't 	 * handle times greater than 2039.  This check should be removed 	 * once large timestamps are fully supported. 	 */
if|if
condition|(
name|mask
operator|&
operator|(
name|AT_ATIME
operator||
name|AT_MTIME
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|mask
operator|&
name|AT_ATIME
operator|)
operator|&&
name|TIMESPEC_OVERFLOW
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|mask
operator|&
name|AT_MTIME
operator|)
operator|&&
name|TIMESPEC_OVERFLOW
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|)
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EOVERFLOW
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
name|xoap
operator|&&
operator|(
name|mask
operator|&
name|AT_XVATTR
operator|)
operator|&&
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_CREATETIME
argument_list|)
operator|&&
name|TIMESPEC_OVERFLOW
argument_list|(
operator|&
name|vap
operator|->
name|va_birthtime
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EOVERFLOW
argument_list|)
operator|)
return|;
block|}
name|attrzp
operator|=
name|NULL
expr_stmt|;
name|aclp
operator|=
name|NULL
expr_stmt|;
comment|/* Can this be moved to before the top label? */
if|if
condition|(
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EROFS
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * First validate permissions 	 */
if|if
condition|(
name|mask
operator|&
name|AT_SIZE
condition|)
block|{
comment|/* 		 * XXX - Note, we are not providing any open 		 * mode flags here (like FNDELAY), so we may 		 * block if there are locks present... this 		 * should be addressed in openat(). 		 */
comment|/* XXX - would it be OK to generate a log record here? */
name|err
operator|=
name|zfs_freesp
argument_list|(
name|zp
argument_list|,
name|vap
operator|->
name|va_size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
operator|(
name|AT_ATIME
operator||
name|AT_MTIME
operator|)
operator|||
operator|(
operator|(
name|mask
operator|&
name|AT_XVATTR
operator|)
operator|&&
operator|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_HIDDEN
argument_list|)
operator|||
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_READONLY
argument_list|)
operator|||
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_ARCHIVE
argument_list|)
operator|||
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_OFFLINE
argument_list|)
operator|||
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_SPARSE
argument_list|)
operator|||
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_CREATETIME
argument_list|)
operator|||
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_SYSTEM
argument_list|)
operator|)
operator|)
condition|)
block|{
name|need_policy
operator|=
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|ACE_WRITE_ATTRIBUTES
argument_list|,
literal|0
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
operator|(
name|AT_UID
operator||
name|AT_GID
operator|)
condition|)
block|{
name|int
name|idmask
init|=
operator|(
name|mask
operator|&
operator|(
name|AT_UID
operator||
name|AT_GID
operator|)
operator|)
decl_stmt|;
name|int
name|take_owner
decl_stmt|;
name|int
name|take_group
decl_stmt|;
comment|/* 		 * NOTE: even if a new mode is being set, 		 * we may clear S_ISUID/S_ISGID bits. 		 */
if|if
condition|(
operator|!
operator|(
name|mask
operator|&
name|AT_MODE
operator|)
condition|)
name|vap
operator|->
name|va_mode
operator|=
name|zp
operator|->
name|z_mode
expr_stmt|;
comment|/* 		 * Take ownership or chgrp to group we are a member of 		 */
name|take_owner
operator|=
operator|(
name|mask
operator|&
name|AT_UID
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_uid
operator|==
name|crgetuid
argument_list|(
name|cr
argument_list|)
operator|)
expr_stmt|;
name|take_group
operator|=
operator|(
name|mask
operator|&
name|AT_GID
operator|)
operator|&&
name|zfs_groupmember
argument_list|(
name|zfsvfs
argument_list|,
name|vap
operator|->
name|va_gid
argument_list|,
name|cr
argument_list|)
expr_stmt|;
comment|/* 		 * If both AT_UID and AT_GID are set then take_owner and 		 * take_group must both be set in order to allow taking 		 * ownership. 		 * 		 * Otherwise, send the check through secpolicy_vnode_setattr() 		 * 		 */
if|if
condition|(
operator|(
operator|(
name|idmask
operator|==
operator|(
name|AT_UID
operator||
name|AT_GID
operator|)
operator|)
operator|&&
name|take_owner
operator|&&
name|take_group
operator|)
operator|||
operator|(
operator|(
name|idmask
operator|==
name|AT_UID
operator|)
operator|&&
name|take_owner
operator|)
operator|||
operator|(
operator|(
name|idmask
operator|==
name|AT_GID
operator|)
operator|&&
name|take_group
operator|)
condition|)
block|{
if|if
condition|(
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|ACE_WRITE_OWNER
argument_list|,
literal|0
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Remove setuid/setgid for non-privileged users 				 */
name|secpolicy_setid_clear
argument_list|(
name|vap
argument_list|,
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|trim_mask
operator|=
operator|(
name|mask
operator|&
operator|(
name|AT_UID
operator||
name|AT_GID
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|need_policy
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
name|need_policy
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|oldva
operator|.
name|va_mode
operator|=
name|zp
operator|->
name|z_mode
expr_stmt|;
name|zfs_fuid_map_ids
argument_list|(
name|zp
argument_list|,
name|cr
argument_list|,
operator|&
name|oldva
operator|.
name|va_uid
argument_list|,
operator|&
name|oldva
operator|.
name|va_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|AT_XVATTR
condition|)
block|{
comment|/* 		 * Update xvattr mask to include only those attributes 		 * that are actually changing. 		 * 		 * the bits will be restored prior to actually setting 		 * the attributes so the caller thinks they were set. 		 */
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_APPENDONLY
argument_list|)
condition|)
block|{
if|if
condition|(
name|xoap
operator|->
name|xoa_appendonly
operator|!=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_APPENDONLY
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|need_policy
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|XVA_CLR_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_APPENDONLY
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|tmpxvattr
argument_list|,
name|XAT_APPENDONLY
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_NOUNLINK
argument_list|)
condition|)
block|{
if|if
condition|(
name|xoap
operator|->
name|xoa_nounlink
operator|!=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_NOUNLINK
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|need_policy
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|XVA_CLR_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_NOUNLINK
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|tmpxvattr
argument_list|,
name|XAT_NOUNLINK
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_IMMUTABLE
argument_list|)
condition|)
block|{
if|if
condition|(
name|xoap
operator|->
name|xoa_immutable
operator|!=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_IMMUTABLE
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|need_policy
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|XVA_CLR_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_IMMUTABLE
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|tmpxvattr
argument_list|,
name|XAT_IMMUTABLE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_NODUMP
argument_list|)
condition|)
block|{
if|if
condition|(
name|xoap
operator|->
name|xoa_nodump
operator|!=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_NODUMP
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|need_policy
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|XVA_CLR_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_NODUMP
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|tmpxvattr
argument_list|,
name|XAT_NODUMP
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_MODIFIED
argument_list|)
condition|)
block|{
if|if
condition|(
name|xoap
operator|->
name|xoa_av_modified
operator|!=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_AV_MODIFIED
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|need_policy
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|XVA_CLR_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_MODIFIED
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|tmpxvattr
argument_list|,
name|XAT_AV_MODIFIED
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_QUARANTINED
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|!=
name|VREG
operator|&&
name|xoap
operator|->
name|xoa_av_quarantined
operator|)
operator|||
name|xoap
operator|->
name|xoa_av_quarantined
operator|!=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_AV_QUARANTINED
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|need_policy
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|XVA_CLR_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_QUARANTINED
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|tmpxvattr
argument_list|,
name|XAT_AV_QUARANTINED
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_REPARSE
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|need_policy
operator|==
name|FALSE
operator|&&
operator|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_SCANSTAMP
argument_list|)
operator|||
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_OPAQUE
argument_list|)
operator|)
condition|)
block|{
name|need_policy
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|AT_MODE
condition|)
block|{
if|if
condition|(
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|ACE_WRITE_ACL
argument_list|,
literal|0
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|secpolicy_setid_setsticky_clear
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|,
operator|&
name|oldva
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|trim_mask
operator||=
name|AT_MODE
expr_stmt|;
block|}
else|else
block|{
name|need_policy
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|need_policy
condition|)
block|{
comment|/* 		 * If trim_mask is set then take ownership 		 * has been granted or write_acl is present and user 		 * has the ability to modify mode.  In that case remove 		 * UID|GID and or MODE from mask so that 		 * secpolicy_vnode_setattr() doesn't revoke it. 		 */
if|if
condition|(
name|trim_mask
condition|)
block|{
name|saved_mask
operator|=
name|vap
operator|->
name|va_mask
expr_stmt|;
name|vap
operator|->
name|va_mask
operator|&=
operator|~
name|trim_mask
expr_stmt|;
if|if
condition|(
name|trim_mask
operator|&
name|AT_MODE
condition|)
block|{
comment|/* 				 * Save the mode, as secpolicy_vnode_setattr() 				 * will overwrite it with ova.va_mode. 				 */
name|saved_mode
operator|=
name|vap
operator|->
name|va_mode
expr_stmt|;
block|}
block|}
name|err
operator|=
name|secpolicy_vnode_setattr
argument_list|(
name|cr
argument_list|,
name|vp
argument_list|,
name|vap
argument_list|,
operator|&
name|oldva
argument_list|,
name|flags
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|int
argument_list|,
name|cred_t
operator|*
argument_list|)
operator|)
name|zfs_zaccess_unix
argument_list|,
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|trim_mask
condition|)
block|{
name|vap
operator|->
name|va_mask
operator||=
name|saved_mask
expr_stmt|;
if|if
condition|(
name|trim_mask
operator|&
name|AT_MODE
condition|)
block|{
comment|/* 				 * Recover the mode after 				 * secpolicy_vnode_setattr(). 				 */
name|vap
operator|->
name|va_mode
operator|=
name|saved_mode
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * secpolicy_vnode_setattr, or take ownership may have 	 * changed va_mask 	 */
name|mask
operator|=
name|vap
operator|->
name|va_mask
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
name|AT_UID
operator||
name|AT_GID
operator|)
operator|)
condition|)
block|{
name|err
operator|=
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_XATTR
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|&
name|xattr_obj
argument_list|,
sizeof|sizeof
argument_list|(
name|xattr_obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|xattr_obj
condition|)
block|{
name|err
operator|=
name|zfs_zget
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|,
name|xattr_obj
argument_list|,
operator|&
name|attrzp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|vn_lock
argument_list|(
name|ZTOV
argument_list|(
name|attrzp
argument_list|)
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|vrele
argument_list|(
name|ZTOV
argument_list|(
name|attrzp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
goto|goto
name|out2
goto|;
block|}
if|if
condition|(
name|mask
operator|&
name|AT_UID
condition|)
block|{
name|new_uid
operator|=
name|zfs_fuid_create
argument_list|(
name|zfsvfs
argument_list|,
operator|(
name|uint64_t
operator|)
name|vap
operator|->
name|va_uid
argument_list|,
name|cr
argument_list|,
name|ZFS_OWNER
argument_list|,
operator|&
name|fuidp
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_uid
operator|!=
name|zp
operator|->
name|z_uid
operator|&&
name|zfs_fuid_overquota
argument_list|(
name|zfsvfs
argument_list|,
name|B_FALSE
argument_list|,
name|new_uid
argument_list|)
condition|)
block|{
if|if
condition|(
name|attrzp
condition|)
name|vput
argument_list|(
name|ZTOV
argument_list|(
name|attrzp
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|SET_ERROR
argument_list|(
name|EDQUOT
argument_list|)
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|AT_GID
condition|)
block|{
name|new_gid
operator|=
name|zfs_fuid_create
argument_list|(
name|zfsvfs
argument_list|,
operator|(
name|uint64_t
operator|)
name|vap
operator|->
name|va_gid
argument_list|,
name|cr
argument_list|,
name|ZFS_GROUP
argument_list|,
operator|&
name|fuidp
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_gid
operator|!=
name|zp
operator|->
name|z_gid
operator|&&
name|zfs_fuid_overquota
argument_list|(
name|zfsvfs
argument_list|,
name|B_TRUE
argument_list|,
name|new_gid
argument_list|)
condition|)
block|{
if|if
condition|(
name|attrzp
condition|)
name|vput
argument_list|(
name|ZTOV
argument_list|(
name|attrzp
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|SET_ERROR
argument_list|(
name|EDQUOT
argument_list|)
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
block|}
block|}
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|AT_MODE
condition|)
block|{
name|uint64_t
name|pmode
init|=
name|zp
operator|->
name|z_mode
decl_stmt|;
name|uint64_t
name|acl_obj
decl_stmt|;
name|new_mode
operator|=
operator|(
name|pmode
operator|&
name|S_IFMT
operator|)
operator||
operator|(
name|vap
operator|->
name|va_mode
operator|&
operator|~
name|S_IFMT
operator|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_acl_mode
operator|==
name|ZFS_ACL_RESTRICTED
operator|&&
operator|!
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_ACL_TRIVIAL
operator|)
condition|)
block|{
name|err
operator|=
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|err
operator|=
name|zfs_acl_chmod_setattr
argument_list|(
name|zp
argument_list|,
operator|&
name|aclp
argument_list|,
name|new_mode
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|zp
operator|->
name|z_is_sa
operator|&&
operator|(
operator|(
name|acl_obj
operator|=
name|zfs_external_acl
argument_list|(
name|zp
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 			 * Are we upgrading ACL from old V0 format 			 * to V1 format? 			 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_version
operator|>=
name|ZPL_VERSION_FUID
operator|&&
name|zfs_znode_acl_version
argument_list|(
name|zp
argument_list|)
operator|==
name|ZFS_ACL_VERSION_INITIAL
condition|)
block|{
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|acl_obj
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|acl_obj
argument_list|,
literal|0
argument_list|,
name|aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|zp
operator|->
name|z_is_sa
operator|&&
name|aclp
operator|->
name|z_acl_bytes
operator|>
name|ZFS_ACE_SPACE
condition|)
block|{
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|mask
operator|&
name|AT_XVATTR
operator|)
operator|&&
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_SCANSTAMP
argument_list|)
condition|)
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
else|else
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attrzp
condition|)
block|{
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|attrzp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|fuid_dirtied
operator|=
name|zfsvfs
operator|->
name|z_fuid_dirty
expr_stmt|;
if|if
condition|(
name|fuid_dirtied
condition|)
name|zfs_fuid_txhold
argument_list|(
name|zfsvfs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Set each attribute requested. 	 * We group settings according to the locks they need to acquire. 	 * 	 * Note: you cannot set ctime directly, although it will be 	 * updated as a side-effect of calling this function. 	 */
if|if
condition|(
name|mask
operator|&
operator|(
name|AT_UID
operator||
name|AT_GID
operator||
name|AT_MODE
operator|)
condition|)
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_FLAGS
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|zp
operator|->
name|z_pflags
argument_list|,
sizeof|sizeof
argument_list|(
name|zp
operator|->
name|z_pflags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrzp
condition|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
name|AT_UID
operator||
name|AT_GID
operator||
name|AT_MODE
operator|)
condition|)
name|mutex_enter
argument_list|(
operator|&
name|attrzp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|xattr_bulk
argument_list|,
name|xattr_count
argument_list|,
name|SA_ZPL_FLAGS
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|attrzp
operator|->
name|z_pflags
argument_list|,
sizeof|sizeof
argument_list|(
name|attrzp
operator|->
name|z_pflags
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
operator|(
name|AT_UID
operator||
name|AT_GID
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|AT_UID
condition|)
block|{
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_UID
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|new_uid
argument_list|,
sizeof|sizeof
argument_list|(
name|new_uid
argument_list|)
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_uid
operator|=
name|new_uid
expr_stmt|;
if|if
condition|(
name|attrzp
condition|)
block|{
name|SA_ADD_BULK_ATTR
argument_list|(
name|xattr_bulk
argument_list|,
name|xattr_count
argument_list|,
name|SA_ZPL_UID
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|new_uid
argument_list|,
sizeof|sizeof
argument_list|(
name|new_uid
argument_list|)
argument_list|)
expr_stmt|;
name|attrzp
operator|->
name|z_uid
operator|=
name|new_uid
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|AT_GID
condition|)
block|{
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_GID
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|new_gid
argument_list|,
sizeof|sizeof
argument_list|(
name|new_gid
argument_list|)
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_gid
operator|=
name|new_gid
expr_stmt|;
if|if
condition|(
name|attrzp
condition|)
block|{
name|SA_ADD_BULK_ATTR
argument_list|(
name|xattr_bulk
argument_list|,
name|xattr_count
argument_list|,
name|SA_ZPL_GID
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|new_gid
argument_list|,
sizeof|sizeof
argument_list|(
name|new_gid
argument_list|)
argument_list|)
expr_stmt|;
name|attrzp
operator|->
name|z_gid
operator|=
name|new_gid
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|mask
operator|&
name|AT_MODE
operator|)
condition|)
block|{
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_MODE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|new_mode
argument_list|,
sizeof|sizeof
argument_list|(
name|new_mode
argument_list|)
argument_list|)
expr_stmt|;
name|new_mode
operator|=
name|zp
operator|->
name|z_mode
expr_stmt|;
block|}
name|err
operator|=
name|zfs_acl_chown_setattr
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrzp
condition|)
block|{
name|err
operator|=
name|zfs_acl_chown_setattr
argument_list|(
name|attrzp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|AT_MODE
condition|)
block|{
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_MODE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|new_mode
argument_list|,
sizeof|sizeof
argument_list|(
name|new_mode
argument_list|)
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_mode
operator|=
name|new_mode
expr_stmt|;
name|ASSERT3U
argument_list|(
operator|(
name|uintptr_t
operator|)
name|aclp
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|zfs_aclset_common
argument_list|(
name|zp
argument_list|,
name|aclp
argument_list|,
name|cr
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_acl_cached
condition|)
name|zfs_acl_free
argument_list|(
name|zp
operator|->
name|z_acl_cached
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_acl_cached
operator|=
name|aclp
expr_stmt|;
name|aclp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|AT_ATIME
condition|)
block|{
name|ZFS_TIME_ENCODE
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|,
name|zp
operator|->
name|z_atime
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_ATIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|zp
operator|->
name|z_atime
argument_list|,
sizeof|sizeof
argument_list|(
name|zp
operator|->
name|z_atime
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|AT_MTIME
condition|)
block|{
name|ZFS_TIME_ENCODE
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
name|mtime
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_MTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|mtime
argument_list|,
sizeof|sizeof
argument_list|(
name|mtime
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* XXX - shouldn't this be done *before* the ATIME/MTIME checks? */
if|if
condition|(
name|mask
operator|&
name|AT_SIZE
operator|&&
operator|!
operator|(
name|mask
operator|&
name|AT_MTIME
operator|)
condition|)
block|{
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_MTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|mtime
argument_list|,
sizeof|sizeof
argument_list|(
name|mtime
argument_list|)
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_CTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|ctime
argument_list|,
sizeof|sizeof
argument_list|(
name|ctime
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_tstamp_update_setup
argument_list|(
name|zp
argument_list|,
name|CONTENT_MODIFIED
argument_list|,
name|mtime
argument_list|,
name|ctime
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
block|{
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_CTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|ctime
argument_list|,
sizeof|sizeof
argument_list|(
name|ctime
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_tstamp_update_setup
argument_list|(
name|zp
argument_list|,
name|STATE_CHANGED
argument_list|,
name|mtime
argument_list|,
name|ctime
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrzp
condition|)
block|{
name|SA_ADD_BULK_ATTR
argument_list|(
name|xattr_bulk
argument_list|,
name|xattr_count
argument_list|,
name|SA_ZPL_CTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|ctime
argument_list|,
sizeof|sizeof
argument_list|(
name|ctime
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_tstamp_update_setup
argument_list|(
name|attrzp
argument_list|,
name|STATE_CHANGED
argument_list|,
name|mtime
argument_list|,
name|ctime
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Do this after setting timestamps to prevent timestamp 	 * update from toggling bit 	 */
if|if
condition|(
name|xoap
operator|&&
operator|(
name|mask
operator|&
name|AT_XVATTR
operator|)
condition|)
block|{
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_CREATETIME
argument_list|)
condition|)
name|xoap
operator|->
name|xoa_createtime
operator|=
name|vap
operator|->
name|va_birthtime
expr_stmt|;
comment|/* 		 * restore trimmed off masks 		 * so that return masks can be set for caller. 		 */
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
operator|&
name|tmpxvattr
argument_list|,
name|XAT_APPENDONLY
argument_list|)
condition|)
block|{
name|XVA_SET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_APPENDONLY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
operator|&
name|tmpxvattr
argument_list|,
name|XAT_NOUNLINK
argument_list|)
condition|)
block|{
name|XVA_SET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_NOUNLINK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
operator|&
name|tmpxvattr
argument_list|,
name|XAT_IMMUTABLE
argument_list|)
condition|)
block|{
name|XVA_SET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_IMMUTABLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
operator|&
name|tmpxvattr
argument_list|,
name|XAT_NODUMP
argument_list|)
condition|)
block|{
name|XVA_SET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_NODUMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
operator|&
name|tmpxvattr
argument_list|,
name|XAT_AV_MODIFIED
argument_list|)
condition|)
block|{
name|XVA_SET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_MODIFIED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
operator|&
name|tmpxvattr
argument_list|,
name|XAT_AV_QUARANTINED
argument_list|)
condition|)
block|{
name|XVA_SET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_QUARANTINED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_SCANSTAMP
argument_list|)
condition|)
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
argument_list|)
expr_stmt|;
name|zfs_xvattr_set
argument_list|(
name|zp
argument_list|,
name|xvap
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fuid_dirtied
condition|)
name|zfs_fuid_sync
argument_list|(
name|zfsvfs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
name|zfs_log_setattr
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|TX_SETATTR
argument_list|,
name|zp
argument_list|,
name|vap
argument_list|,
name|mask
argument_list|,
name|fuidp
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
operator|(
name|AT_UID
operator||
name|AT_GID
operator||
name|AT_MODE
operator|)
condition|)
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrzp
condition|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
name|AT_UID
operator||
name|AT_GID
operator||
name|AT_MODE
operator|)
condition|)
name|mutex_exit
argument_list|(
operator|&
name|attrzp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|attrzp
condition|)
block|{
name|err2
operator|=
name|sa_bulk_update
argument_list|(
name|attrzp
operator|->
name|z_sa_hdl
argument_list|,
name|xattr_bulk
argument_list|,
name|xattr_count
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err2
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attrzp
condition|)
name|vput
argument_list|(
name|ZTOV
argument_list|(
name|attrzp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|aclp
condition|)
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuidp
condition|)
block|{
name|zfs_fuid_info_free
argument_list|(
name|fuidp
argument_list|)
expr_stmt|;
name|fuidp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err2
operator|=
name|sa_bulk_update
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|bulk
argument_list|,
name|count
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
name|out2
label|:
if|if
condition|(
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
condition|)
name|zil_commit
argument_list|(
name|zilog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We acquire all but fdvp locks using non-blocking acquisitions.  If we  * fail to acquire any lock in the path we will drop all held locks,  * acquire the new lock in a blocking fashion, and then release it and  * restart the rename.  This acquire/release step ensures that we do not  * spin on a lock waiting for release.  On error release all vnode locks  * and decrement references the way tmpfs_rename() would do.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_rename_relock
parameter_list|(
name|struct
name|vnode
modifier|*
name|sdvp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|svpp
parameter_list|,
name|struct
name|vnode
modifier|*
name|tdvp
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|tvpp
parameter_list|,
specifier|const
name|struct
name|componentname
modifier|*
name|scnp
parameter_list|,
specifier|const
name|struct
name|componentname
modifier|*
name|tcnp
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
decl_stmt|;
name|struct
name|vnode
modifier|*
name|nvp
decl_stmt|,
modifier|*
name|svp
decl_stmt|,
modifier|*
name|tvp
decl_stmt|;
name|znode_t
modifier|*
name|sdzp
decl_stmt|,
modifier|*
name|tdzp
decl_stmt|,
modifier|*
name|szp
decl_stmt|,
modifier|*
name|tzp
decl_stmt|;
specifier|const
name|char
modifier|*
name|snm
init|=
name|scnp
operator|->
name|cn_nameptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|tnm
init|=
name|tcnp
operator|->
name|cn_nameptr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|VOP_UNLOCK
argument_list|(
name|tdvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tvpp
operator|!=
name|NULL
operator|&&
operator|*
name|tvpp
operator|!=
name|tdvp
condition|)
name|VOP_UNLOCK
argument_list|(
operator|*
name|tvpp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|relock
label|:
name|error
operator|=
name|vn_lock
argument_list|(
name|sdvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|sdzp
operator|=
name|VTOZ
argument_list|(
name|sdvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_lock
argument_list|(
name|tdvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|sdvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EBUSY
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|vn_lock
argument_list|(
name|tdvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|VOP_UNLOCK
argument_list|(
name|tdvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|relock
goto|;
block|}
name|tdzp
operator|=
name|VTOZ
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
comment|/* 	 * Before using sdzp and tdzp we must ensure that they are live. 	 * As a porting legacy from illumos we have two things to worry 	 * about.  One is typical for FreeBSD and it is that the vnode is 	 * not reclaimed (doomed).  The other is that the znode is live. 	 * The current code can invalidate the znode without acquiring the 	 * corresponding vnode lock if the object represented by the znode 	 * and vnode is no longer valid after a rollback or receive operation. 	 * z_teardown_lock hidden behind ZFS_ENTER and ZFS_EXIT is the lock 	 * that protects the znodes from the invalidation. 	 */
name|zfsvfs
operator|=
name|sdzp
operator|->
name|z_zfsvfs
expr_stmt|;
name|ASSERT3P
argument_list|(
name|zfsvfs
argument_list|,
operator|==
argument_list|,
name|tdzp
operator|->
name|z_zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
comment|/* 	 * We can not use ZFS_VERIFY_ZP() here because it could directly return 	 * bypassing the cleanup code in the case of an error. 	 */
if|if
condition|(
name|tdzp
operator|->
name|z_sa_hdl
operator|==
name|NULL
operator|||
name|sdzp
operator|->
name|z_sa_hdl
operator|==
name|NULL
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|sdvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|tdvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Re-resolve svp to be certain it still exists and fetch the 	 * correct vnode. 	 */
name|error
operator|=
name|zfs_dirent_lookup
argument_list|(
name|sdzp
argument_list|,
name|snm
argument_list|,
operator|&
name|szp
argument_list|,
name|ZEXISTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* Source entry invalid or not there. */
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|sdvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|tdvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scnp
operator|->
name|cn_flags
operator|&
name|ISDOTDOT
operator|)
operator|!=
literal|0
operator|||
operator|(
name|scnp
operator|->
name|cn_namelen
operator|==
literal|1
operator|&&
name|scnp
operator|->
name|cn_nameptr
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|svp
operator|=
name|ZTOV
argument_list|(
name|szp
argument_list|)
expr_stmt|;
comment|/* 	 * Re-resolve tvp, if it disappeared we just carry on. 	 */
name|error
operator|=
name|zfs_dirent_lookup
argument_list|(
name|tdzp
argument_list|,
name|tnm
argument_list|,
operator|&
name|tzp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|sdvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|tdvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|svp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tcnp
operator|->
name|cn_flags
operator|&
name|ISDOTDOT
operator|)
operator|!=
literal|0
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|tzp
operator|!=
name|NULL
condition|)
name|tvp
operator|=
name|ZTOV
argument_list|(
name|tzp
argument_list|)
expr_stmt|;
else|else
name|tvp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * At present the vnode locks must be acquired before z_teardown_lock, 	 * although it would be more logical to use the opposite order. 	 */
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
comment|/* 	 * Now try acquire locks on svp and tvp. 	 */
name|nvp
operator|=
name|svp
expr_stmt|;
name|error
operator|=
name|vn_lock
argument_list|(
name|nvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|sdvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|tdvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
operator|!=
name|NULL
condition|)
name|vrele
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EBUSY
condition|)
block|{
name|vrele
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|vn_lock
argument_list|(
name|nvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|vrele
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|VOP_UNLOCK
argument_list|(
name|nvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Concurrent rename race. 		 * XXX ? 		 */
if|if
condition|(
name|nvp
operator|==
name|tdvp
condition|)
block|{
name|vrele
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vrele
argument_list|(
operator|*
name|svpp
argument_list|)
expr_stmt|;
operator|*
name|svpp
operator|=
name|nvp
expr_stmt|;
goto|goto
name|relock
goto|;
block|}
name|vrele
argument_list|(
operator|*
name|svpp
argument_list|)
expr_stmt|;
operator|*
name|svpp
operator|=
name|nvp
expr_stmt|;
if|if
condition|(
operator|*
name|tvpp
operator|!=
name|NULL
condition|)
name|vrele
argument_list|(
operator|*
name|tvpp
argument_list|)
expr_stmt|;
operator|*
name|tvpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tvp
operator|!=
name|NULL
condition|)
block|{
name|nvp
operator|=
name|tvp
expr_stmt|;
name|error
operator|=
name|vn_lock
argument_list|(
name|nvp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|sdvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|tdvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
operator|*
name|svpp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|EBUSY
condition|)
block|{
name|vrele
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|vn_lock
argument_list|(
name|nvp
argument_list|,
name|LK_EXCLUSIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|vrele
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vput
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
goto|goto
name|relock
goto|;
block|}
operator|*
name|tvpp
operator|=
name|nvp
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note that we must use VRELE_ASYNC in this function as it walks  * up the directory tree and vrele may need to acquire an exclusive  * lock if a last reference to a vnode is dropped.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_rename_check
parameter_list|(
name|znode_t
modifier|*
name|szp
parameter_list|,
name|znode_t
modifier|*
name|sdzp
parameter_list|,
name|znode_t
modifier|*
name|tdzp
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
decl_stmt|;
name|znode_t
modifier|*
name|zp
decl_stmt|,
modifier|*
name|zp1
decl_stmt|;
name|uint64_t
name|parent
decl_stmt|;
name|int
name|error
decl_stmt|;
name|zfsvfs
operator|=
name|tdzp
operator|->
name|z_zfsvfs
expr_stmt|;
if|if
condition|(
name|tdzp
operator|==
name|szp
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|tdzp
operator|==
name|sdzp
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|tdzp
operator|->
name|z_id
operator|==
name|zfsvfs
operator|->
name|z_root
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|zp
operator|=
name|tdzp
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ASSERT
argument_list|(
operator|!
name|zp
operator|->
name|z_unlinked
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_PARENT
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|&
name|parent
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|parent
operator|==
name|szp
operator|->
name|z_id
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|parent
operator|==
name|zfsvfs
operator|->
name|z_root
condition|)
break|break;
if|if
condition|(
name|parent
operator|==
name|sdzp
operator|->
name|z_id
condition|)
break|break;
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|parent
argument_list|,
operator|&
name|zp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|zp
operator|!=
name|tdzp
condition|)
name|VN_RELE_ASYNC
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|dsl_pool_vnrele_taskq
argument_list|(
name|dmu_objset_pool
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|zp
operator|=
name|zp1
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
name|ENOTDIR
condition|)
name|panic
argument_list|(
literal|"checkpath: .. not a directory\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|!=
name|tdzp
condition|)
name|VN_RELE_ASYNC
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|dsl_pool_vnrele_taskq
argument_list|(
name|dmu_objset_pool
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Move an entry from the provided source directory to the target  * directory.  Change the entry name as indicated.  *  *	IN:	sdvp	- Source directory containing the "old entry".  *		snm	- Old entry name.  *		tdvp	- Target directory to contain the "new entry".  *		tnm	- New entry name.  *		cr	- credentials of caller.  *		ct	- caller context  *		flags	- case flags  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	sdvp,tdvp - ctime|mtime updated  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_rename
parameter_list|(
name|vnode_t
modifier|*
name|sdvp
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|svpp
parameter_list|,
name|struct
name|componentname
modifier|*
name|scnp
parameter_list|,
name|vnode_t
modifier|*
name|tdvp
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|tvpp
parameter_list|,
name|struct
name|componentname
modifier|*
name|tcnp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
decl_stmt|;
name|znode_t
modifier|*
name|sdzp
decl_stmt|,
modifier|*
name|tdzp
decl_stmt|,
modifier|*
name|szp
decl_stmt|,
modifier|*
name|tzp
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
init|=
name|NULL
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|char
modifier|*
name|snm
init|=
name|scnp
operator|->
name|cn_nameptr
decl_stmt|;
name|char
modifier|*
name|tnm
init|=
name|tcnp
operator|->
name|cn_nameptr
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Reject renames across filesystems. */
if|if
condition|(
operator|(
operator|*
name|svpp
operator|)
operator|->
name|v_mount
operator|!=
name|tdvp
operator|->
name|v_mount
operator|||
operator|(
operator|(
operator|*
name|tvpp
operator|)
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|svpp
operator|)
operator|->
name|v_mount
operator|!=
operator|(
operator|*
name|tvpp
operator|)
operator|->
name|v_mount
operator|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EXDEV
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|zfsctl_is_node
argument_list|(
name|tdvp
argument_list|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EXDEV
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Lock all four vnodes to ensure safety and semantics of renaming. 	 */
name|error
operator|=
name|zfs_rename_relock
argument_list|(
name|sdvp
argument_list|,
name|svpp
argument_list|,
name|tdvp
argument_list|,
name|tvpp
argument_list|,
name|scnp
argument_list|,
name|tcnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* no vnodes are locked in the case of error here */
return|return
operator|(
name|error
operator|)
return|;
block|}
name|tdzp
operator|=
name|VTOZ
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
name|sdzp
operator|=
name|VTOZ
argument_list|(
name|sdvp
argument_list|)
expr_stmt|;
name|zfsvfs
operator|=
name|tdzp
operator|->
name|z_zfsvfs
expr_stmt|;
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
comment|/* 	 * After we re-enter ZFS_ENTER() we will have to revalidate all 	 * znodes involved. 	 */
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_utf8
operator|&&
name|u8_validate
argument_list|(
name|tnm
argument_list|,
name|strlen
argument_list|(
name|tnm
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|U8_VALIDATE_ENTIRE
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EILSEQ
argument_list|)
expr_stmt|;
goto|goto
name|unlockout
goto|;
block|}
comment|/* If source and target are the same file, there is nothing to do. */
if|if
condition|(
operator|(
operator|*
name|svpp
operator|)
operator|==
operator|(
operator|*
name|tvpp
operator|)
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|unlockout
goto|;
block|}
if|if
condition|(
operator|(
operator|(
operator|*
name|svpp
operator|)
operator|->
name|v_type
operator|==
name|VDIR
operator|&&
operator|(
operator|*
name|svpp
operator|)
operator|->
name|v_mountedhere
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|(
operator|*
name|tvpp
operator|)
operator|!=
name|NULL
operator|&&
operator|(
operator|*
name|tvpp
operator|)
operator|->
name|v_type
operator|==
name|VDIR
operator|&&
operator|(
operator|*
name|tvpp
operator|)
operator|->
name|v_mountedhere
operator|!=
name|NULL
operator|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EXDEV
argument_list|)
expr_stmt|;
goto|goto
name|unlockout
goto|;
block|}
comment|/* 	 * We can not use ZFS_VERIFY_ZP() here because it could directly return 	 * bypassing the cleanup code in the case of an error. 	 */
if|if
condition|(
name|tdzp
operator|->
name|z_sa_hdl
operator|==
name|NULL
operator|||
name|sdzp
operator|->
name|z_sa_hdl
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
goto|goto
name|unlockout
goto|;
block|}
name|szp
operator|=
name|VTOZ
argument_list|(
operator|*
name|svpp
argument_list|)
expr_stmt|;
name|tzp
operator|=
operator|*
name|tvpp
operator|==
name|NULL
condition|?
name|NULL
else|:
name|VTOZ
argument_list|(
operator|*
name|tvpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|szp
operator|->
name|z_sa_hdl
operator|==
name|NULL
operator|||
operator|(
name|tzp
operator|!=
name|NULL
operator|&&
name|tzp
operator|->
name|z_sa_hdl
operator|==
name|NULL
operator|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
goto|goto
name|unlockout
goto|;
block|}
comment|/* 	 * This is to prevent the creation of links into attribute space 	 * by renaming a linked file into/outof an attribute directory. 	 * See the comment in zfs_link() for why this is considered bad. 	 */
if|if
condition|(
operator|(
name|tdzp
operator|->
name|z_pflags
operator|&
name|ZFS_XATTR
operator|)
operator|!=
operator|(
name|sdzp
operator|->
name|z_pflags
operator|&
name|ZFS_XATTR
operator|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|unlockout
goto|;
block|}
comment|/* 	 * Must have write access at the source to remove the old entry 	 * and write access at the target to create the new entry. 	 * Note that if target and source are the same, this can be 	 * done in a single check. 	 */
if|if
condition|(
name|error
operator|=
name|zfs_zaccess_rename
argument_list|(
name|sdzp
argument_list|,
name|szp
argument_list|,
name|tdzp
argument_list|,
name|tzp
argument_list|,
name|cr
argument_list|)
condition|)
goto|goto
name|unlockout
goto|;
if|if
condition|(
operator|(
operator|*
name|svpp
operator|)
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
comment|/* 		 * Avoid ".", "..", and aliases of "." for obvious reasons. 		 */
if|if
condition|(
operator|(
name|scnp
operator|->
name|cn_namelen
operator|==
literal|1
operator|&&
name|scnp
operator|->
name|cn_nameptr
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|||
name|sdzp
operator|==
name|szp
operator|||
operator|(
name|scnp
operator|->
name|cn_flags
operator||
name|tcnp
operator|->
name|cn_flags
operator|)
operator|&
name|ISDOTDOT
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|unlockout
goto|;
block|}
comment|/* 		 * Check to make sure rename is valid. 		 * Can't do a move like this: /usr/a/b to /usr/a/b/c/d 		 */
if|if
condition|(
name|error
operator|=
name|zfs_rename_check
argument_list|(
name|szp
argument_list|,
name|sdzp
argument_list|,
name|tdzp
argument_list|)
condition|)
goto|goto
name|unlockout
goto|;
block|}
comment|/* 	 * Does target exist? 	 */
if|if
condition|(
name|tzp
condition|)
block|{
comment|/* 		 * Source and target must be the same type. 		 */
if|if
condition|(
operator|(
operator|*
name|svpp
operator|)
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|tvpp
operator|)
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOTDIR
argument_list|)
expr_stmt|;
goto|goto
name|unlockout
goto|;
block|}
else|else
block|{
name|cache_purge
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdvp
operator|!=
name|tdvp
condition|)
name|cache_purge
argument_list|(
name|sdvp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|*
name|tvpp
operator|)
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EISDIR
argument_list|)
expr_stmt|;
goto|goto
name|unlockout
goto|;
block|}
block|}
block|}
name|vnevent_rename_src
argument_list|(
operator|*
name|svpp
argument_list|,
name|sdvp
argument_list|,
name|scnp
operator|->
name|cn_nameptr
argument_list|,
name|ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|tzp
condition|)
name|vnevent_rename_dest
argument_list|(
operator|*
name|tvpp
argument_list|,
name|tdvp
argument_list|,
name|tnm
argument_list|,
name|ct
argument_list|)
expr_stmt|;
comment|/* 	 * notify the target directory if it is not the same 	 * as source directory. 	 */
if|if
condition|(
name|tdvp
operator|!=
name|sdvp
condition|)
block|{
name|vnevent_rename_dest_dir
argument_list|(
name|tdvp
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|szp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|sdzp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|sdzp
operator|->
name|z_id
argument_list|,
name|FALSE
argument_list|,
name|snm
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|tdzp
operator|->
name|z_id
argument_list|,
name|TRUE
argument_list|,
name|tnm
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdzp
operator|!=
name|tdzp
condition|)
block|{
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|tdzp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|tdzp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tzp
condition|)
block|{
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|tzp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|tzp
argument_list|)
expr_stmt|;
block|}
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|szp
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_unlinkedobj
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|unlockout
goto|;
block|}
if|if
condition|(
name|tzp
condition|)
comment|/* Attempt to remove the existing target */
name|error
operator|=
name|zfs_link_destroy
argument_list|(
name|tdzp
argument_list|,
name|tnm
argument_list|,
name|tzp
argument_list|,
name|tx
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|zfs_link_create
argument_list|(
name|tdzp
argument_list|,
name|tnm
argument_list|,
name|szp
argument_list|,
name|tx
argument_list|,
name|ZRENAMING
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|szp
operator|->
name|z_pflags
operator||=
name|ZFS_AV_MODIFIED
expr_stmt|;
name|error
operator|=
name|sa_update
argument_list|(
name|szp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_FLAGS
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|szp
operator|->
name|z_pflags
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_link_destroy
argument_list|(
name|sdzp
argument_list|,
name|snm
argument_list|,
name|szp
argument_list|,
name|tx
argument_list|,
name|ZRENAMING
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|zfs_log_rename
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|TX_RENAME
argument_list|,
name|sdzp
argument_list|,
name|snm
argument_list|,
name|tdzp
argument_list|,
name|tnm
argument_list|,
name|szp
argument_list|)
expr_stmt|;
comment|/* 				 * Update path information for the target vnode 				 */
name|vn_renamepath
argument_list|(
name|tdvp
argument_list|,
operator|*
name|svpp
argument_list|,
name|tnm
argument_list|,
name|strlen
argument_list|(
name|tnm
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * At this point, we have successfully created 				 * the target name, but have failed to remove 				 * the source name.  Since the create was done 				 * with the ZRENAMING flag, there are 				 * complications; for one, the link count is 				 * wrong.  The easiest way to deal with this 				 * is to remove the newly created target, and 				 * return the original error.  This must 				 * succeed; fortunately, it is very unlikely to 				 * fail, since we just created it. 				 */
name|VERIFY3U
argument_list|(
name|zfs_link_destroy
argument_list|(
name|tdzp
argument_list|,
name|tnm
argument_list|,
name|szp
argument_list|,
name|tx
argument_list|,
name|ZRENAMING
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|cache_purge
argument_list|(
operator|*
name|svpp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tvpp
operator|!=
name|NULL
condition|)
name|cache_purge
argument_list|(
operator|*
name|tvpp
argument_list|)
expr_stmt|;
name|cache_purge_negative
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
block|}
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|unlockout
label|:
comment|/* all 4 vnodes are locked, ZFS_ENTER called */
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
operator|*
name|svpp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|sdvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
comment|/* original two vnodes are locked */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
condition|)
name|zil_commit
argument_list|(
name|zilog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tvpp
operator|!=
name|NULL
condition|)
name|VOP_UNLOCK
argument_list|(
operator|*
name|tvpp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdvp
operator|!=
operator|*
name|tvpp
condition|)
name|VOP_UNLOCK
argument_list|(
name|tdvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert the indicated symbolic reference entry into the directory.  *  *	IN:	dvp	- Directory to contain new symbolic link.  *		link	- Name for new symlink entry.  *		vap	- Attributes of new entry.  *		cr	- credentials of caller.  *		ct	- caller context  *		flags	- case flags  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	dvp - ctime|mtime updated  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_symlink
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|char
modifier|*
name|link
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|kthread_t
modifier|*
name|td
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
decl_stmt|,
modifier|*
name|dzp
init|=
name|VTOZ
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|uint64_t
name|len
init|=
name|strlen
argument_list|(
name|link
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|zfs_acl_ids_t
name|acl_ids
decl_stmt|;
name|boolean_t
name|fuid_dirtied
decl_stmt|;
name|uint64_t
name|txtype
init|=
name|TX_SYMLINK
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|vap
operator|->
name|va_type
operator|==
name|VLNK
argument_list|)
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|dzp
argument_list|)
expr_stmt|;
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_utf8
operator|&&
name|u8_validate
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|U8_VALIDATE_ENTIRE
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EILSEQ
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|>
name|MAXPATHLEN
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENAMETOOLONG
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_acl_ids_create
argument_list|(
name|dzp
argument_list|,
literal|0
argument_list|,
name|vap
argument_list|,
name|cr
argument_list|,
name|NULL
argument_list|,
operator|&
name|acl_ids
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Attempt to lock directory; fail if entry already exists. 	 */
name|error
operator|=
name|zfs_dirent_lookup
argument_list|(
name|dzp
argument_list|,
name|name
argument_list|,
operator|&
name|zp
argument_list|,
name|ZNEW
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|dzp
argument_list|,
name|ACE_ADD_FILE
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
condition|)
block|{
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|zfs_acl_ids_overquota
argument_list|(
name|zfsvfs
argument_list|,
operator|&
name|acl_ids
argument_list|)
condition|)
block|{
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EDQUOT
argument_list|)
operator|)
return|;
block|}
name|getnewvnode_reserve
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|fuid_dirtied
operator|=
name|zfsvfs
operator|->
name|z_fuid_dirty
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|MAX
argument_list|(
literal|1
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|TRUE
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa_create
argument_list|(
name|tx
argument_list|,
name|acl_ids
operator|.
name|z_aclp
operator|->
name|z_acl_bytes
operator|+
name|ZFS_SA_BASE_ATTR_SIZE
operator|+
name|len
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zfsvfs
operator|->
name|z_use_sa
operator|&&
name|acl_ids
operator|.
name|z_aclp
operator|->
name|z_acl_bytes
operator|>
name|ZFS_ACE_SPACE
condition|)
block|{
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|acl_ids
operator|.
name|z_aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fuid_dirtied
condition|)
name|zfs_fuid_txhold
argument_list|(
name|zfsvfs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|getnewvnode_drop_reserve
argument_list|()
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Create a new object for the symlink. 	 * for version 4 ZPL datsets the symlink will be an SA attribute 	 */
name|zfs_mknode
argument_list|(
name|dzp
argument_list|,
name|vap
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
literal|0
argument_list|,
operator|&
name|zp
argument_list|,
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuid_dirtied
condition|)
name|zfs_fuid_sync
argument_list|(
name|zfsvfs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_is_sa
condition|)
name|error
operator|=
name|sa_update
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_SYMLINK
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|link
argument_list|,
name|len
argument_list|,
name|tx
argument_list|)
expr_stmt|;
else|else
name|zfs_sa_symlink
argument_list|(
name|zp
argument_list|,
name|link
argument_list|,
name|len
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_size
operator|=
name|len
expr_stmt|;
operator|(
name|void
operator|)
name|sa_update
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_SIZE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|&
name|zp
operator|->
name|z_size
argument_list|,
sizeof|sizeof
argument_list|(
name|zp
operator|->
name|z_size
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Insert the new object into the directory. 	 */
operator|(
name|void
operator|)
name|zfs_link_create
argument_list|(
name|dzp
argument_list|,
name|name
argument_list|,
name|zp
argument_list|,
name|tx
argument_list|,
name|ZNEW
argument_list|)
expr_stmt|;
name|zfs_log_symlink
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|txtype
argument_list|,
name|dzp
argument_list|,
name|zp
argument_list|,
name|name
argument_list|,
name|link
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|getnewvnode_drop_reserve
argument_list|()
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
condition|)
name|zil_commit
argument_list|(
name|zilog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return, in the buffer contained in the provided uio structure,  * the symbolic path referred to by vp.  *  *	IN:	vp	- vnode of symbolic link.  *		uio	- structure to contain the link path.  *		cr	- credentials of caller.  *		ct	- caller context  *  *	OUT:	uio	- structure containing the link path.  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	vp - atime updated  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_readlink
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_is_sa
condition|)
name|error
operator|=
name|sa_lookup_uio
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_SYMLINK
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|zfs_sa_readlink
argument_list|(
name|zp
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|ZFS_ACCESSTIME_STAMP
argument_list|(
name|zfsvfs
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert a new entry into directory tdvp referencing svp.  *  *	IN:	tdvp	- Directory to contain new entry.  *		svp	- vnode of new entry.  *		name	- name of new entry.  *		cr	- credentials of caller.  *		ct	- caller context  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	tdvp - ctime|mtime updated  *	 svp - ctime updated  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_link
parameter_list|(
name|vnode_t
modifier|*
name|tdvp
parameter_list|,
name|vnode_t
modifier|*
name|svp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|znode_t
modifier|*
name|dzp
init|=
name|VTOZ
argument_list|(
name|tdvp
argument_list|)
decl_stmt|;
name|znode_t
modifier|*
name|tzp
decl_stmt|,
modifier|*
name|szp
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint64_t
name|parent
decl_stmt|;
name|uid_t
name|owner
decl_stmt|;
name|ASSERT
argument_list|(
name|tdvp
operator|->
name|v_type
operator|==
name|VDIR
argument_list|)
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|dzp
argument_list|)
expr_stmt|;
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
comment|/* 	 * POSIX dictates that we return EPERM here. 	 * Better choices include ENOTSUP or EISDIR. 	 */
if|if
condition|(
name|svp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
block|}
name|szp
operator|=
name|VTOZ
argument_list|(
name|svp
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|szp
argument_list|)
expr_stmt|;
if|if
condition|(
name|szp
operator|->
name|z_pflags
operator|&
operator|(
name|ZFS_APPENDONLY
operator||
name|ZFS_IMMUTABLE
operator||
name|ZFS_READONLY
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
block|}
comment|/* Prevent links to .zfs/shares files */
if|if
condition|(
operator|(
name|error
operator|=
name|sa_lookup
argument_list|(
name|szp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_PARENT
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|&
name|parent
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|parent
operator|==
name|zfsvfs
operator|->
name|z_shares_dir
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zfsvfs
operator|->
name|z_utf8
operator|&&
name|u8_validate
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|U8_VALIDATE_ENTIRE
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EILSEQ
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * We do not support links between attributes and non-attributes 	 * because of the potential security risk of creating links 	 * into "normal" file space in order to circumvent restrictions 	 * imposed in attribute space. 	 */
if|if
condition|(
operator|(
name|szp
operator|->
name|z_pflags
operator|&
name|ZFS_XATTR
operator|)
operator|!=
operator|(
name|dzp
operator|->
name|z_pflags
operator|&
name|ZFS_XATTR
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|owner
operator|=
name|zfs_fuid_map_id
argument_list|(
name|zfsvfs
argument_list|,
name|szp
operator|->
name|z_uid
argument_list|,
name|cr
argument_list|,
name|ZFS_OWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|!=
name|crgetuid
argument_list|(
name|cr
argument_list|)
operator|&&
name|secpolicy_basic_link
argument_list|(
name|svp
argument_list|,
name|cr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|dzp
argument_list|,
name|ACE_ADD_FILE
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Attempt to lock directory; fail if entry already exists. 	 */
name|error
operator|=
name|zfs_dirent_lookup
argument_list|(
name|dzp
argument_list|,
name|name
argument_list|,
operator|&
name|tzp
argument_list|,
name|ZNEW
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|szp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|TRUE
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|szp
argument_list|)
expr_stmt|;
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|dzp
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|zfs_link_create
argument_list|(
name|dzp
argument_list|,
name|name
argument_list|,
name|szp
argument_list|,
name|tx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|txtype
init|=
name|TX_LINK
decl_stmt|;
name|zfs_log_link
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|txtype
argument_list|,
name|dzp
argument_list|,
name|szp
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|vnevent_link
argument_list|(
name|svp
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
condition|)
name|zil_commit
argument_list|(
name|zilog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|zfs_inactive
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|rw_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_sa_hdl
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * The fs has been unmounted, or we did a 		 * suspend/resume and this file no longer exists. 		 */
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|)
expr_stmt|;
name|vrecycle
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|zp
operator|->
name|z_unlinked
condition|)
block|{
comment|/* 		 * Fast path to recycle a vnode of a removed file. 		 */
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|)
expr_stmt|;
name|vrecycle
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|zp
operator|->
name|z_atime_dirty
operator|&&
name|zp
operator|->
name|z_unlinked
operator|==
literal|0
condition|)
block|{
name|dmu_tx_t
modifier|*
name|tx
init|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
decl_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sa_update
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_ATIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|zp
operator|->
name|z_atime
argument_list|,
sizeof|sizeof
argument_list|(
name|zp
operator|->
name|z_atime
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_atime_dirty
operator|=
literal|0
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|zfid_short
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|fid
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|zfid_long
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|fid
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_fid
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|fid_t
modifier|*
name|fidp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|uint32_t
name|gen
decl_stmt|;
name|uint64_t
name|gen64
decl_stmt|;
name|uint64_t
name|object
init|=
name|zp
operator|->
name|z_id
decl_stmt|;
name|zfid_short_t
modifier|*
name|zfid
decl_stmt|;
name|int
name|size
decl_stmt|,
name|i
decl_stmt|,
name|error
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_GEN
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|&
name|gen64
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|gen
operator|=
operator|(
name|uint32_t
operator|)
name|gen64
expr_stmt|;
name|size
operator|=
operator|(
name|zfsvfs
operator|->
name|z_parent
operator|!=
name|zfsvfs
operator|)
condition|?
name|LONG_FID_LEN
else|:
name|SHORT_FID_LEN
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|fidp
operator|->
name|fid_len
operator|<
name|size
condition|)
block|{
name|fidp
operator|->
name|fid_len
operator|=
name|size
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
operator|)
return|;
block|}
else|#
directive|else
name|fidp
operator|->
name|fid_len
operator|=
name|size
expr_stmt|;
endif|#
directive|endif
name|zfid
operator|=
operator|(
name|zfid_short_t
operator|*
operator|)
name|fidp
expr_stmt|;
name|zfid
operator|->
name|zf_len
operator|=
name|size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zfid
operator|->
name|zf_object
argument_list|)
condition|;
name|i
operator|++
control|)
name|zfid
operator|->
name|zf_object
index|[
name|i
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|object
operator|>>
operator|(
literal|8
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
comment|/* Must have a non-zero generation number to distinguish from .zfs */
if|if
condition|(
name|gen
operator|==
literal|0
condition|)
name|gen
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zfid
operator|->
name|zf_gen
argument_list|)
condition|;
name|i
operator|++
control|)
name|zfid
operator|->
name|zf_gen
index|[
name|i
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|gen
operator|>>
operator|(
literal|8
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|LONG_FID_LEN
condition|)
block|{
name|uint64_t
name|objsetid
init|=
name|dmu_objset_id
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
decl_stmt|;
name|zfid_long_t
modifier|*
name|zlfid
decl_stmt|;
name|zlfid
operator|=
operator|(
name|zfid_long_t
operator|*
operator|)
name|fidp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zlfid
operator|->
name|zf_setid
argument_list|)
condition|;
name|i
operator|++
control|)
name|zlfid
operator|->
name|zf_setid
index|[
name|i
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|objsetid
operator|>>
operator|(
literal|8
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX - this should be the generation number for the objset */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zlfid
operator|->
name|zf_setgen
argument_list|)
condition|;
name|i
operator|++
control|)
name|zlfid
operator|->
name|zf_setgen
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_pathconf
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|ulong_t
modifier|*
name|valp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
decl_stmt|,
modifier|*
name|xzp
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
decl_stmt|;
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|_PC_LINK_MAX
case|:
operator|*
name|valp
operator|=
name|INT_MAX
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_FILESIZEBITS
case|:
operator|*
name|valp
operator|=
literal|64
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|illumos
case|case
name|_PC_XATTR_EXISTS
case|:
name|zp
operator|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|zfsvfs
operator|=
name|zp
operator|->
name|z_zfsvfs
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
operator|*
name|valp
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|zfs_dirent_lookup
argument_list|(
name|zp
argument_list|,
literal|""
argument_list|,
operator|&
name|xzp
argument_list|,
name|ZXATTR
operator||
name|ZEXISTS
operator||
name|ZSHARED
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|zfs_dirempty
argument_list|(
name|xzp
argument_list|)
condition|)
operator|*
name|valp
operator|=
literal|1
expr_stmt|;
name|vrele
argument_list|(
name|ZTOV
argument_list|(
name|xzp
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
block|{
comment|/* 			 * If there aren't extended attributes, it's the 			 * same as having zero of them. 			 */
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
case|case
name|_PC_SATTR_ENABLED
case|:
case|case
name|_PC_SATTR_EXISTS
case|:
operator|*
name|valp
operator|=
name|vfs_has_feature
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_SYSATTR_VIEWS
argument_list|)
operator|&&
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|||
name|vp
operator|->
name|v_type
operator|==
name|VDIR
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_ACCESS_FILTERING
case|:
operator|*
name|valp
operator|=
name|vfs_has_feature
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_ACCESS_FILTER
argument_list|)
operator|&&
name|vp
operator|->
name|v_type
operator|==
name|VDIR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_ACL_ENABLED
case|:
operator|*
name|valp
operator|=
name|_ACL_ACE_ENABLED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
comment|/* illumos */
case|case
name|_PC_MIN_HOLE_SIZE
case|:
operator|*
name|valp
operator|=
operator|(
name|int
operator|)
name|SPA_MINBLOCKSIZE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|illumos
case|case
name|_PC_TIMESTAMP_RESOLUTION
case|:
comment|/* nanosecond timestamp resolution */
operator|*
name|valp
operator|=
literal|1L
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
case|case
name|_PC_ACL_EXTENDED
case|:
operator|*
name|valp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_ACL_NFS4
case|:
operator|*
name|valp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_ACL_PATH_MAX
case|:
operator|*
name|valp
operator|=
name|ACL_MAX_ENTRIES
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_getsecattr
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|,
name|int
name|flag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|boolean_t
name|skipaclchk
init|=
operator|(
name|flag
operator|&
name|ATTR_NOACLCHECK
operator|)
condition|?
name|B_TRUE
else|:
name|B_FALSE
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_getacl
argument_list|(
name|zp
argument_list|,
name|vsecp
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|zfs_setsecattr
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|,
name|int
name|flag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|boolean_t
name|skipaclchk
init|=
operator|(
name|flag
operator|&
name|ATTR_NOACLCHECK
operator|)
condition|?
name|B_TRUE
else|:
name|B_FALSE
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
init|=
name|zfsvfs
operator|->
name|z_log
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_setacl
argument_list|(
name|zp
argument_list|,
name|vsecp
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
condition|)
name|zil_commit
argument_list|(
name|zilog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ioflags
parameter_list|(
name|int
name|ioflags
parameter_list|)
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ioflags
operator|&
name|IO_APPEND
condition|)
name|flags
operator||=
name|FAPPEND
expr_stmt|;
if|if
condition|(
name|ioflags
operator|&
name|IO_NDELAY
condition|)
name|flags
operator||=
name|FNONBLOCK
expr_stmt|;
if|if
condition|(
name|ioflags
operator|&
name|IO_SYNC
condition|)
name|flags
operator||=
operator|(
name|FSYNC
operator||
name|FDSYNC
operator||
name|FRSYNC
operator|)
expr_stmt|;
return|return
operator|(
name|flags
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_getpages
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|int
name|count
parameter_list|,
name|int
modifier|*
name|rbehind
parameter_list|,
name|int
modifier|*
name|rahead
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_os
decl_stmt|;
name|vm_page_t
name|mlast
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|caddr_t
name|va
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|off_t
name|startoff
decl_stmt|,
name|endoff
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|vm_pindex_t
name|reqstart
decl_stmt|,
name|reqend
decl_stmt|;
name|int
name|lsize
decl_stmt|,
name|size
decl_stmt|;
name|object
operator|=
name|m
index|[
literal|0
index|]
operator|->
name|object
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|zfs_vmobject_wlock
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
index|[
name|count
operator|-
literal|1
index|]
operator|->
name|valid
operator|!=
literal|0
operator|&&
operator|--
name|count
operator|==
literal|0
condition|)
block|{
name|zfs_vmobject_wunlock
argument_list|(
name|object
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mlast
operator|=
name|m
index|[
name|count
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|IDX_TO_OFF
argument_list|(
name|mlast
operator|->
name|pindex
argument_list|)
operator|>=
name|object
operator|->
name|un_pager
operator|.
name|vnp
operator|.
name|vnp_size
condition|)
block|{
name|zfs_vmobject_wunlock
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_vm_pagerret_bad
operator|)
return|;
block|}
name|PCPU_INC
argument_list|(
name|cnt
operator|.
name|v_vnodein
argument_list|)
expr_stmt|;
name|PCPU_ADD
argument_list|(
name|cnt
operator|.
name|v_vnodepgsin
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|lsize
operator|=
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|IDX_TO_OFF
argument_list|(
name|mlast
operator|->
name|pindex
argument_list|)
operator|+
name|lsize
operator|>
name|object
operator|->
name|un_pager
operator|.
name|vnp
operator|.
name|vnp_size
condition|)
name|lsize
operator|=
name|object
operator|->
name|un_pager
operator|.
name|vnp
operator|.
name|vnp_size
operator|-
name|IDX_TO_OFF
argument_list|(
name|mlast
operator|->
name|pindex
argument_list|)
expr_stmt|;
name|zfs_vmobject_wunlock
argument_list|(
name|object
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|=
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|count
operator|-
literal|1
condition|)
name|size
operator|=
name|lsize
expr_stmt|;
name|va
operator|=
name|zfs_map_page
argument_list|(
name|m
index|[
name|i
index|]
argument_list|,
operator|&
name|sf
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_read
argument_list|(
name|os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|IDX_TO_OFF
argument_list|(
name|m
index|[
name|i
index|]
operator|->
name|pindex
argument_list|)
argument_list|,
name|size
argument_list|,
name|va
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|PAGE_SIZE
condition|)
name|bzero
argument_list|(
name|va
operator|+
name|size
argument_list|,
name|PAGE_SIZE
operator|-
name|size
argument_list|)
expr_stmt|;
name|zfs_unmap_page
argument_list|(
name|sf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
name|zfs_vmobject_wlock
argument_list|(
name|object
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|m
index|[
name|i
index|]
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
name|zfs_vmobject_wunlock
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|out
label|:
name|ZFS_ACCESSTIME_STAMP
argument_list|(
name|zfsvfs
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rbehind
condition|)
operator|*
name|rbehind
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rahead
condition|)
operator|*
name|rahead
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|zfs_vm_pagerret_ok
operator|)
return|;
block|}
else|else
return|return
operator|(
name|zfs_vm_pagerret_error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_getpages
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_getpages_args
comment|/* { 		struct vnode *a_vp; 		vm_page_t *a_m; 		int a_count; 		int *a_rbehind; 		int *a_rahead; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|zfs_getpages
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_m
argument_list|,
name|ap
operator|->
name|a_count
argument_list|,
name|ap
operator|->
name|a_rbehind
argument_list|,
name|ap
operator|->
name|a_rahead
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_putpages
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|vm_page_t
modifier|*
name|ma
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|rtvals
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|caddr_t
name|va
decl_stmt|;
name|size_t
name|tocopy
decl_stmt|;
name|size_t
name|lo_len
decl_stmt|;
name|vm_ooffset_t
name|lo_off
decl_stmt|;
name|vm_ooffset_t
name|off
decl_stmt|;
name|uint_t
name|blksz
decl_stmt|;
name|int
name|ncount
decl_stmt|;
name|int
name|pcount
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|object
operator|=
name|vp
operator|->
name|v_object
expr_stmt|;
name|pcount
operator|=
name|btoc
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ncount
operator|=
name|pcount
expr_stmt|;
name|KASSERT
argument_list|(
name|ma
index|[
literal|0
index|]
operator|->
name|object
operator|==
name|object
argument_list|,
operator|(
literal|"mismatching object"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|len
operator|>
literal|0
operator|&&
operator|(
name|len
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"unexpected length"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pcount
condition|;
name|i
operator|++
control|)
name|rtvals
index|[
name|i
index|]
operator|=
name|zfs_vm_pagerret_error
expr_stmt|;
name|off
operator|=
name|IDX_TO_OFF
argument_list|(
name|ma
index|[
literal|0
index|]
operator|->
name|pindex
argument_list|)
expr_stmt|;
name|blksz
operator|=
name|zp
operator|->
name|z_blksz
expr_stmt|;
name|lo_off
operator|=
name|rounddown
argument_list|(
name|off
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
name|lo_len
operator|=
name|roundup
argument_list|(
name|len
operator|+
operator|(
name|off
operator|-
name|lo_off
operator|)
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
name|rl
operator|=
name|zfs_range_lock
argument_list|(
name|zp
argument_list|,
name|lo_off
argument_list|,
name|lo_len
argument_list|,
name|RL_WRITER
argument_list|)
expr_stmt|;
name|zfs_vmobject_wlock
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|+
name|off
operator|>
name|object
operator|->
name|un_pager
operator|.
name|vnp
operator|.
name|vnp_size
condition|)
block|{
if|if
condition|(
name|object
operator|->
name|un_pager
operator|.
name|vnp
operator|.
name|vnp_size
operator|>
name|off
condition|)
block|{
name|int
name|pgoff
decl_stmt|;
name|len
operator|=
name|object
operator|->
name|un_pager
operator|.
name|vnp
operator|.
name|vnp_size
operator|-
name|off
expr_stmt|;
name|ncount
operator|=
name|btoc
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pgoff
operator|=
operator|(
name|int
operator|)
name|len
operator|&
name|PAGE_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * If the object is locked and the following 				 * conditions hold, then the page's dirty 				 * field cannot be concurrently changed by a 				 * pmap operation. 				 */
name|m
operator|=
name|ma
index|[
name|ncount
operator|-
literal|1
index|]
expr_stmt|;
name|vm_page_assert_sbusied
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|pmap_page_is_write_mapped
argument_list|(
name|m
argument_list|)
argument_list|,
operator|(
literal|"zfs_putpages: page %p is not read-only"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|vm_page_clear_dirty
argument_list|(
name|m
argument_list|,
name|pgoff
argument_list|,
name|PAGE_SIZE
operator|-
name|pgoff
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|len
operator|=
literal|0
expr_stmt|;
name|ncount
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ncount
operator|<
name|pcount
condition|)
block|{
for|for
control|(
name|i
operator|=
name|ncount
init|;
name|i
operator|<
name|pcount
condition|;
name|i
operator|++
control|)
block|{
name|rtvals
index|[
name|i
index|]
operator|=
name|zfs_vm_pagerret_bad
expr_stmt|;
block|}
block|}
block|}
name|zfs_vmobject_wunlock
argument_list|(
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncount
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|zfs_owner_overquota
argument_list|(
name|zfsvfs
argument_list|,
name|zp
argument_list|,
name|B_FALSE
argument_list|)
operator|||
name|zfs_owner_overquota
argument_list|(
name|zfsvfs
argument_list|,
name|zp
argument_list|,
name|B_TRUE
argument_list|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|top
label|:
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|err
operator|==
name|ERESTART
condition|)
block|{
name|dmu_tx_wait
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_blksz
operator|<
name|PAGE_SIZE
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|len
operator|>
literal|0
condition|;
name|off
operator|+=
name|tocopy
operator|,
name|len
operator|-=
name|tocopy
operator|,
name|i
operator|++
control|)
block|{
name|tocopy
operator|=
name|len
operator|>
name|PAGE_SIZE
condition|?
name|PAGE_SIZE
else|:
name|len
expr_stmt|;
name|va
operator|=
name|zfs_map_page
argument_list|(
name|ma
index|[
name|i
index|]
argument_list|,
operator|&
name|sf
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|off
argument_list|,
name|tocopy
argument_list|,
name|va
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zfs_unmap_page
argument_list|(
name|sf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|err
operator|=
name|dmu_write_pages
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|ma
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|mtime
index|[
literal|2
index|]
decl_stmt|,
name|ctime
index|[
literal|2
index|]
decl_stmt|;
name|sa_bulk_attr_t
name|bulk
index|[
literal|3
index|]
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_MTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|mtime
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_CTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|ctime
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_FLAGS
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|zp
operator|->
name|z_pflags
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|zfs_tstamp_update_setup
argument_list|(
name|zp
argument_list|,
name|CONTENT_MODIFIED
argument_list|,
name|mtime
argument_list|,
name|ctime
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sa_bulk_update
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|bulk
argument_list|,
name|count
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zfs_log_write
argument_list|(
name|zfsvfs
operator|->
name|z_log
argument_list|,
name|tx
argument_list|,
name|TX_WRITE
argument_list|,
name|zp
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zfs_vmobject_wlock
argument_list|(
name|object
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncount
condition|;
name|i
operator|++
control|)
block|{
name|rtvals
index|[
name|i
index|]
operator|=
name|zfs_vm_pagerret_ok
expr_stmt|;
name|vm_page_undirty
argument_list|(
name|ma
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|zfs_vmobject_wunlock
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|PCPU_INC
argument_list|(
name|cnt
operator|.
name|v_vnodeout
argument_list|)
expr_stmt|;
name|PCPU_ADD
argument_list|(
name|cnt
operator|.
name|v_vnodepgsout
argument_list|,
name|ncount
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|out
label|:
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|zfs_vm_pagerput_sync
operator||
name|zfs_vm_pagerput_inval
operator|)
operator|)
operator|!=
literal|0
operator|||
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
condition|)
name|zil_commit
argument_list|(
name|zfsvfs
operator|->
name|z_log
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|rtvals
index|[
literal|0
index|]
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_freebsd_putpages
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_putpages_args
comment|/* { 		struct vnode *a_vp; 		vm_page_t *a_m; 		int a_count; 		int a_sync; 		int *a_rtvals; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|zfs_putpages
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_m
argument_list|,
name|ap
operator|->
name|a_count
argument_list|,
name|ap
operator|->
name|a_sync
argument_list|,
name|ap
operator|->
name|a_rtvals
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_bmap
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_bmap_args
comment|/* { 		struct vnode *a_vp; 		daddr_t  a_bn; 		struct bufobj **a_bop; 		daddr_t *a_bnp; 		int *a_runp; 		int *a_runb; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
if|if
condition|(
name|ap
operator|->
name|a_bop
operator|!=
name|NULL
condition|)
operator|*
name|ap
operator|->
name|a_bop
operator|=
operator|&
name|ap
operator|->
name|a_vp
operator|->
name|v_bufobj
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_bnp
operator|!=
name|NULL
condition|)
operator|*
name|ap
operator|->
name|a_bnp
operator|=
name|ap
operator|->
name|a_bn
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_runp
operator|!=
name|NULL
condition|)
operator|*
name|ap
operator|->
name|a_runp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_runb
operator|!=
name|NULL
condition|)
operator|*
name|ap
operator|->
name|a_runb
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_open
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_open_args
comment|/* { 		struct vnode *a_vp; 		int a_mode; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|vnode_t
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|zfs_open
argument_list|(
operator|&
name|vp
argument_list|,
name|ap
operator|->
name|a_mode
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|vnode_create_vobject
argument_list|(
name|vp
argument_list|,
name|zp
operator|->
name|z_size
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_close
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_close_args
comment|/* { 		struct vnode *a_vp; 		int  a_fflag; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|zfs_close
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_fflag
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_ioctl
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_ioctl_args
comment|/* { 		struct vnode *a_vp; 		u_long a_command; 		caddr_t a_data; 		int a_fflag; 		struct ucred *cred; 		struct thread *td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|zfs_ioctl
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_command
argument_list|,
operator|(
name|intptr_t
operator|)
name|ap
operator|->
name|a_data
argument_list|,
name|ap
operator|->
name|a_fflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_read
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_read_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|zfs_read
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ioflags
argument_list|(
name|ap
operator|->
name|a_ioflag
argument_list|)
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_write
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_write_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|zfs_write
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ioflags
argument_list|(
name|ap
operator|->
name|a_ioflag
argument_list|)
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_access
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_access_args
comment|/* { 		struct vnode *a_vp; 		accmode_t a_accmode; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|vnode_t
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|accmode_t
name|accmode
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * ZFS itself only knowns about VREAD, VWRITE, VEXEC and VAPPEND, 	 */
name|accmode
operator|=
name|ap
operator|->
name|a_accmode
operator|&
operator|(
name|VREAD
operator||
name|VWRITE
operator||
name|VEXEC
operator||
name|VAPPEND
operator|)
expr_stmt|;
if|if
condition|(
name|accmode
operator|!=
literal|0
condition|)
name|error
operator|=
name|zfs_access
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|accmode
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * VADMIN has to be handled by vaccess(). 	 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|accmode
operator|=
name|ap
operator|->
name|a_accmode
operator|&
operator|~
operator|(
name|VREAD
operator||
name|VWRITE
operator||
name|VEXEC
operator||
name|VAPPEND
operator|)
expr_stmt|;
if|if
condition|(
name|accmode
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|vaccess
argument_list|(
name|vp
operator|->
name|v_type
argument_list|,
name|zp
operator|->
name|z_mode
argument_list|,
name|zp
operator|->
name|z_uid
argument_list|,
name|zp
operator|->
name|z_gid
argument_list|,
name|accmode
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * For VEXEC, ensure that at least one execute bit is set for 	 * non-directories. 	 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|ap
operator|->
name|a_accmode
operator|&
name|VEXEC
operator|)
operator|!=
literal|0
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
operator|&&
operator|(
name|zp
operator|->
name|z_mode
operator|&
operator|(
name|S_IXUSR
operator||
name|S_IXGRP
operator||
name|S_IXOTH
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EACCES
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_lookup
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_lookup_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|char
name|nm
index|[
name|NAME_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|cnp
operator|->
name|cn_namelen
operator|<
sizeof|sizeof
argument_list|(
name|nm
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|nm
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|MIN
argument_list|(
name|cnp
operator|->
name|cn_namelen
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|nm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_lookup
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
name|nm
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|cnp
argument_list|,
name|cnp
operator|->
name|cn_nameiop
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_cache_lookup
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_lookup_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
decl_stmt|;
name|zfsvfs
operator|=
name|ap
operator|->
name|a_dvp
operator|->
name|v_mount
operator|->
name|mnt_data
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_use_namecache
condition|)
return|return
operator|(
name|vfs_cache_lookup
argument_list|(
name|ap
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|zfs_freebsd_lookup
argument_list|(
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_create
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_create_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
decl_stmt|;
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|vattr_t
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|int
name|error
decl_stmt|,
name|mode
decl_stmt|;
name|ASSERT
argument_list|(
name|cnp
operator|->
name|cn_flags
operator|&
name|SAVENAME
argument_list|)
expr_stmt|;
name|vattr_init_mask
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|mode
operator|=
name|vap
operator|->
name|va_mode
operator|&
name|ALLPERMS
expr_stmt|;
name|zfsvfs
operator|=
name|ap
operator|->
name|a_dvp
operator|->
name|v_mount
operator|->
name|mnt_data
expr_stmt|;
name|error
operator|=
name|zfs_create
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|vap
argument_list|,
operator|!
name|EXCL
argument_list|,
name|mode
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_use_namecache
operator|&&
name|error
operator|==
literal|0
operator|&&
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
operator|)
operator|!=
literal|0
condition|)
name|cache_enter
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
operator|*
name|ap
operator|->
name|a_vpp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_remove
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_remove_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|ASSERT
argument_list|(
name|ap
operator|->
name|a_cnp
operator|->
name|cn_flags
operator|&
name|SAVENAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_remove
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_cnp
operator|->
name|cn_nameptr
argument_list|,
name|ap
operator|->
name|a_cnp
operator|->
name|cn_cred
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_mkdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_mkdir_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|vattr_t
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|ASSERT
argument_list|(
name|ap
operator|->
name|a_cnp
operator|->
name|cn_flags
operator|&
name|SAVENAME
argument_list|)
expr_stmt|;
name|vattr_init_mask
argument_list|(
name|vap
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_mkdir
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
name|ap
operator|->
name|a_cnp
operator|->
name|cn_nameptr
argument_list|,
name|vap
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|ap
operator|->
name|a_cnp
operator|->
name|cn_cred
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_rmdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_rmdir_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|ASSERT
argument_list|(
name|cnp
operator|->
name|cn_flags
operator|&
name|SAVENAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_rmdir
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
name|ap
operator|->
name|a_vp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_readdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_readdir_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 		int *a_eofflag; 		int *a_ncookies; 		u_long **a_cookies; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|zfs_readdir
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_eofflag
argument_list|,
name|ap
operator|->
name|a_ncookies
argument_list|,
name|ap
operator|->
name|a_cookies
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_fsync
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_fsync_args
comment|/* { 		struct vnode *a_vp; 		int a_waitfor; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|vop_stdfsync
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_fsync
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_td
operator|->
name|td_ucred
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_getattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_getattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|vattr_t
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|xvattr_t
name|xvap
decl_stmt|;
name|u_long
name|fflags
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|xva_init
argument_list|(
operator|&
name|xvap
argument_list|)
expr_stmt|;
name|xvap
operator|.
name|xva_vattr
operator|=
operator|*
name|vap
expr_stmt|;
name|xvap
operator|.
name|xva_vattr
operator|.
name|va_mask
operator||=
name|AT_XVATTR
expr_stmt|;
comment|/* Convert chflags into ZFS-type flags. */
comment|/* XXX: what about SF_SETTABLE?. */
name|XVA_SET_REQ
argument_list|(
operator|&
name|xvap
argument_list|,
name|XAT_IMMUTABLE
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|xvap
argument_list|,
name|XAT_APPENDONLY
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|xvap
argument_list|,
name|XAT_NOUNLINK
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|xvap
argument_list|,
name|XAT_NODUMP
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|xvap
argument_list|,
name|XAT_READONLY
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|xvap
argument_list|,
name|XAT_ARCHIVE
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|xvap
argument_list|,
name|XAT_SYSTEM
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|xvap
argument_list|,
name|XAT_HIDDEN
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|xvap
argument_list|,
name|XAT_REPARSE
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|xvap
argument_list|,
name|XAT_OFFLINE
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|xvap
argument_list|,
name|XAT_SPARSE
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_getattr
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
operator|(
name|vattr_t
operator|*
operator|)
operator|&
name|xvap
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Convert ZFS xattr into chflags. */
define|#
directive|define
name|FLAG_CHECK
parameter_list|(
name|fflag
parameter_list|,
name|xflag
parameter_list|,
name|xfield
parameter_list|)
value|do {			\ 	if (XVA_ISSET_RTN(&xvap, (xflag))&& (xfield) != 0)		\ 		fflags |= (fflag);					\ } while (0)
name|FLAG_CHECK
argument_list|(
name|SF_IMMUTABLE
argument_list|,
name|XAT_IMMUTABLE
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_immutable
argument_list|)
expr_stmt|;
name|FLAG_CHECK
argument_list|(
name|SF_APPEND
argument_list|,
name|XAT_APPENDONLY
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_appendonly
argument_list|)
expr_stmt|;
name|FLAG_CHECK
argument_list|(
name|SF_NOUNLINK
argument_list|,
name|XAT_NOUNLINK
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_nounlink
argument_list|)
expr_stmt|;
name|FLAG_CHECK
argument_list|(
name|UF_ARCHIVE
argument_list|,
name|XAT_ARCHIVE
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_archive
argument_list|)
expr_stmt|;
name|FLAG_CHECK
argument_list|(
name|UF_NODUMP
argument_list|,
name|XAT_NODUMP
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_nodump
argument_list|)
expr_stmt|;
name|FLAG_CHECK
argument_list|(
name|UF_READONLY
argument_list|,
name|XAT_READONLY
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_readonly
argument_list|)
expr_stmt|;
name|FLAG_CHECK
argument_list|(
name|UF_SYSTEM
argument_list|,
name|XAT_SYSTEM
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_system
argument_list|)
expr_stmt|;
name|FLAG_CHECK
argument_list|(
name|UF_HIDDEN
argument_list|,
name|XAT_HIDDEN
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_hidden
argument_list|)
expr_stmt|;
name|FLAG_CHECK
argument_list|(
name|UF_REPARSE
argument_list|,
name|XAT_REPARSE
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_reparse
argument_list|)
expr_stmt|;
name|FLAG_CHECK
argument_list|(
name|UF_OFFLINE
argument_list|,
name|XAT_OFFLINE
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_offline
argument_list|)
expr_stmt|;
name|FLAG_CHECK
argument_list|(
name|UF_SPARSE
argument_list|,
name|XAT_SPARSE
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_sparse
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|FLAG_CHECK
operator|*
name|vap
operator|=
name|xvap
operator|.
name|xva_vattr
expr_stmt|;
name|vap
operator|->
name|va_flags
operator|=
name|fflags
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_setattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_setattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|vnode_t
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|vattr_t
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|cred_t
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|xvattr_t
name|xvap
decl_stmt|;
name|u_long
name|fflags
decl_stmt|;
name|uint64_t
name|zflags
decl_stmt|;
name|vattr_init_mask
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_mask
operator|&=
operator|~
name|AT_NOSET
expr_stmt|;
name|xva_init
argument_list|(
operator|&
name|xvap
argument_list|)
expr_stmt|;
name|xvap
operator|.
name|xva_vattr
operator|=
operator|*
name|vap
expr_stmt|;
name|zflags
operator|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
operator|->
name|z_pflags
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_flags
operator|!=
name|VNOVAL
condition|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_use_fuids
operator|==
name|B_FALSE
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|fflags
operator|=
name|vap
operator|->
name|va_flags
expr_stmt|;
comment|/* 		 * XXX KDM  		 * We need to figure out whether it makes sense to allow 		 * UF_REPARSE through, since we don't really have other 		 * facilities to handle reparse points and zfs_setattr() 		 * doesn't currently allow setting that attribute anyway. 		 */
if|if
condition|(
operator|(
name|fflags
operator|&
operator|~
operator|(
name|SF_IMMUTABLE
operator||
name|SF_APPEND
operator||
name|SF_NOUNLINK
operator||
name|UF_ARCHIVE
operator||
name|UF_NODUMP
operator||
name|UF_SYSTEM
operator||
name|UF_HIDDEN
operator||
name|UF_READONLY
operator||
name|UF_REPARSE
operator||
name|UF_OFFLINE
operator||
name|UF_SPARSE
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
comment|/* 		 * Unprivileged processes are not permitted to unset system 		 * flags, or modify flags if any system flags are set. 		 * Privileged non-jail processes may not modify system flags 		 * if securelevel> 0 and any existing system flags are set. 		 * Privileged jail processes behave like privileged non-jail 		 * processes if the security.jail.chflags_allowed sysctl is 		 * is non-zero; otherwise, they behave like unprivileged 		 * processes. 		 */
if|if
condition|(
name|secpolicy_fs_owner
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|,
name|cred
argument_list|)
operator|==
literal|0
operator|||
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_VFS_SYSFLAGS
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|zflags
operator|&
operator|(
name|ZFS_IMMUTABLE
operator||
name|ZFS_APPENDONLY
operator||
name|ZFS_NOUNLINK
operator|)
condition|)
block|{
name|error
operator|=
name|securelevel_gt
argument_list|(
name|cred
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 			 * Callers may only modify the file flags on objects they 			 * have VADMIN rights for. 			 */
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VADMIN
argument_list|,
name|cred
argument_list|,
name|curthread
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|zflags
operator|&
operator|(
name|ZFS_IMMUTABLE
operator||
name|ZFS_APPENDONLY
operator||
name|ZFS_NOUNLINK
operator|)
condition|)
block|{
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
if|if
condition|(
name|fflags
operator|&
operator|(
name|SF_IMMUTABLE
operator||
name|SF_APPEND
operator||
name|SF_NOUNLINK
operator|)
condition|)
block|{
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
block|}
define|#
directive|define
name|FLAG_CHANGE
parameter_list|(
name|fflag
parameter_list|,
name|zflag
parameter_list|,
name|xflag
parameter_list|,
name|xfield
parameter_list|)
value|do {		\ 	if (((fflags& (fflag))&& !(zflags& (zflag))) ||		\ 	    ((zflags& (zflag))&& !(fflags& (fflag)))) {		\ 		XVA_SET_REQ(&xvap, (xflag));				\ 		(xfield) = ((fflags& (fflag)) != 0);			\ 	}								\ } while (0)
comment|/* Convert chflags into ZFS-type flags. */
comment|/* XXX: what about SF_SETTABLE?. */
name|FLAG_CHANGE
argument_list|(
name|SF_IMMUTABLE
argument_list|,
name|ZFS_IMMUTABLE
argument_list|,
name|XAT_IMMUTABLE
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_immutable
argument_list|)
expr_stmt|;
name|FLAG_CHANGE
argument_list|(
name|SF_APPEND
argument_list|,
name|ZFS_APPENDONLY
argument_list|,
name|XAT_APPENDONLY
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_appendonly
argument_list|)
expr_stmt|;
name|FLAG_CHANGE
argument_list|(
name|SF_NOUNLINK
argument_list|,
name|ZFS_NOUNLINK
argument_list|,
name|XAT_NOUNLINK
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_nounlink
argument_list|)
expr_stmt|;
name|FLAG_CHANGE
argument_list|(
name|UF_ARCHIVE
argument_list|,
name|ZFS_ARCHIVE
argument_list|,
name|XAT_ARCHIVE
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_archive
argument_list|)
expr_stmt|;
name|FLAG_CHANGE
argument_list|(
name|UF_NODUMP
argument_list|,
name|ZFS_NODUMP
argument_list|,
name|XAT_NODUMP
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_nodump
argument_list|)
expr_stmt|;
name|FLAG_CHANGE
argument_list|(
name|UF_READONLY
argument_list|,
name|ZFS_READONLY
argument_list|,
name|XAT_READONLY
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_readonly
argument_list|)
expr_stmt|;
name|FLAG_CHANGE
argument_list|(
name|UF_SYSTEM
argument_list|,
name|ZFS_SYSTEM
argument_list|,
name|XAT_SYSTEM
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_system
argument_list|)
expr_stmt|;
name|FLAG_CHANGE
argument_list|(
name|UF_HIDDEN
argument_list|,
name|ZFS_HIDDEN
argument_list|,
name|XAT_HIDDEN
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_hidden
argument_list|)
expr_stmt|;
name|FLAG_CHANGE
argument_list|(
name|UF_REPARSE
argument_list|,
name|ZFS_REPARSE
argument_list|,
name|XAT_REPARSE
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_hidden
argument_list|)
expr_stmt|;
name|FLAG_CHANGE
argument_list|(
name|UF_OFFLINE
argument_list|,
name|ZFS_OFFLINE
argument_list|,
name|XAT_OFFLINE
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_offline
argument_list|)
expr_stmt|;
name|FLAG_CHANGE
argument_list|(
name|UF_SPARSE
argument_list|,
name|ZFS_SPARSE
argument_list|,
name|XAT_SPARSE
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_sparse
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|FLAG_CHANGE
block|}
if|if
condition|(
name|vap
operator|->
name|va_birthtime
operator|.
name|tv_sec
operator|!=
name|VNOVAL
condition|)
block|{
name|xvap
operator|.
name|xva_vattr
operator|.
name|va_mask
operator||=
name|AT_XVATTR
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|xvap
argument_list|,
name|XAT_CREATETIME
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|zfs_setattr
argument_list|(
name|vp
argument_list|,
operator|(
name|vattr_t
operator|*
operator|)
operator|&
name|xvap
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_rename
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_rename_args
comment|/* { 		struct vnode *a_fdvp; 		struct vnode *a_fvp; 		struct componentname *a_fcnp; 		struct vnode *a_tdvp; 		struct vnode *a_tvp; 		struct componentname *a_tcnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|vnode_t
modifier|*
name|fdvp
init|=
name|ap
operator|->
name|a_fdvp
decl_stmt|;
name|vnode_t
modifier|*
name|fvp
init|=
name|ap
operator|->
name|a_fvp
decl_stmt|;
name|vnode_t
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_tdvp
decl_stmt|;
name|vnode_t
modifier|*
name|tvp
init|=
name|ap
operator|->
name|a_tvp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|ap
operator|->
name|a_fcnp
operator|->
name|cn_flags
operator|&
operator|(
name|SAVENAME
operator||
name|SAVESTART
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ap
operator|->
name|a_tcnp
operator|->
name|cn_flags
operator|&
operator|(
name|SAVENAME
operator||
name|SAVESTART
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_rename
argument_list|(
name|fdvp
argument_list|,
operator|&
name|fvp
argument_list|,
name|ap
operator|->
name|a_fcnp
argument_list|,
name|tdvp
argument_list|,
operator|&
name|tvp
argument_list|,
name|ap
operator|->
name|a_tcnp
argument_list|,
name|ap
operator|->
name|a_fcnp
operator|->
name|cn_cred
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
name|vrele
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
operator|!=
name|NULL
condition|)
name|vrele
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_symlink
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_symlink_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 		char *a_target; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|vattr_t
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|ASSERT
argument_list|(
name|cnp
operator|->
name|cn_flags
operator|&
name|SAVENAME
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_type
operator|=
name|VLNK
expr_stmt|;
comment|/* FreeBSD: Syscall only sets va_mode. */
name|vattr_init_mask
argument_list|(
name|vap
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_symlink
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|vap
argument_list|,
name|ap
operator|->
name|a_target
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_readlink
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_readlink_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|zfs_readlink
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_link
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_link_args
comment|/* { 		struct vnode *a_tdvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|vnode_t
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|vnode_t
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_tdvp
decl_stmt|;
if|if
condition|(
name|tdvp
operator|->
name|v_mount
operator|!=
name|vp
operator|->
name|v_mount
condition|)
return|return
operator|(
name|EXDEV
operator|)
return|;
name|ASSERT
argument_list|(
name|cnp
operator|->
name|cn_flags
operator|&
name|SAVENAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_link
argument_list|(
name|tdvp
argument_list|,
name|vp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_inactive
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_inactive_args
comment|/* { 		struct vnode *a_vp; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|vnode_t
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|zfs_inactive
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_td
operator|->
name|td_ucred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_reclaim
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_reclaim_args
comment|/* { 		struct vnode *a_vp; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|vnode_t
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|ASSERT
argument_list|(
name|zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Destroy the vm object and flush associated pages. */
name|vnode_destroy_vobject
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* 	 * z_teardown_inactive_lock protects from a race with 	 * zfs_znode_dmu_fini in zfsvfs_teardown during 	 * force unmount. 	 */
name|rw_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_sa_hdl
operator|==
name|NULL
condition|)
name|zfs_znode_free
argument_list|(
name|zp
argument_list|)
expr_stmt|;
else|else
name|zfs_zinactive
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_fid
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_fid_args
comment|/* { 		struct vnode *a_vp; 		struct fid *a_fid; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|zfs_fid
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ap
operator|->
name|a_fid
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_pathconf
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_pathconf_args
comment|/* { 		struct vnode *a_vp; 		int a_name; 		register_t *a_retval; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|ulong_t
name|val
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|zfs_pathconf
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_name
argument_list|,
operator|&
name|val
argument_list|,
name|curthread
operator|->
name|td_ucred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|==
name|EOPNOTSUPP
condition|)
name|error
operator|=
name|vop_stdpathconf
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_fifo_pathconf
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_pathconf_args
comment|/* { 		struct vnode *a_vp; 		int a_name; 		register_t *a_retval; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
switch|switch
condition|(
name|ap
operator|->
name|a_name
condition|)
block|{
case|case
name|_PC_ACL_EXTENDED
case|:
case|case
name|_PC_ACL_NFS4
case|:
case|case
name|_PC_ACL_PATH_MAX
case|:
case|case
name|_PC_MAC_PRESENT
case|:
return|return
operator|(
name|zfs_freebsd_pathconf
argument_list|(
name|ap
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|fifo_specops
operator|.
name|vop_pathconf
argument_list|(
name|ap
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * FreeBSD's extended attributes namespace defines file name prefix for ZFS'  * extended attribute name:  *  *	NAMESPACE	PREFIX	  *	system		freebsd:system:  *	user		(none, can be used to access ZFS fsattr(5) attributes  *			created on Solaris)  */
end_comment

begin_function
specifier|static
name|int
name|zfs_create_attrname
parameter_list|(
name|int
name|attrnamespace
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|attrname
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|namespace
decl_stmt|,
modifier|*
name|prefix
decl_stmt|,
modifier|*
name|suffix
decl_stmt|;
comment|/* We don't allow '/' character in attribute name. */
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* We don't allow attribute names that start with "freebsd:" string. */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"freebsd:"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bzero
argument_list|(
name|attrname
argument_list|,
name|size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|attrnamespace
condition|)
block|{
case|case
name|EXTATTR_NAMESPACE_USER
case|:
if|#
directive|if
literal|0
block|prefix = "freebsd:"; 		namespace = EXTATTR_NAMESPACE_USER_STRING; 		suffix = ":";
else|#
directive|else
comment|/* 		 * This is the default namespace by which we can access all 		 * attributes created on Solaris. 		 */
name|prefix
operator|=
name|namespace
operator|=
name|suffix
operator|=
literal|""
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|EXTATTR_NAMESPACE_SYSTEM
case|:
name|prefix
operator|=
literal|"freebsd:"
expr_stmt|;
name|namespace
operator|=
name|EXTATTR_NAMESPACE_SYSTEM_STRING
expr_stmt|;
name|suffix
operator|=
literal|":"
expr_stmt|;
break|break;
case|case
name|EXTATTR_NAMESPACE_EMPTY
case|:
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|snprintf
argument_list|(
name|attrname
argument_list|,
name|size
argument_list|,
literal|"%s%s%s%s"
argument_list|,
name|prefix
argument_list|,
name|namespace
argument_list|,
name|suffix
argument_list|,
name|name
argument_list|)
operator|>=
name|size
condition|)
block|{
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Vnode operating to retrieve a named extended attribute.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_getextattr
parameter_list|(
name|struct
name|vop_getextattr_args
modifier|*
name|ap
parameter_list|)
comment|/* vop_getextattr { 	IN struct vnode *a_vp; 	IN int a_attrnamespace; 	IN const char *a_name; 	INOUT struct uio *a_uio; 	OUT size_t *a_size; 	IN struct ucred *a_cred; 	IN struct thread *a_td; }; */
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|VTOZ
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|->
name|z_zfsvfs
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|char
name|attrname
index|[
literal|255
index|]
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
name|vnode_t
modifier|*
name|xvp
init|=
name|NULL
decl_stmt|,
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|;
name|error
operator|=
name|extattr_check_cred
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_attrnamespace
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
name|VREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|zfs_create_attrname
argument_list|(
name|ap
operator|->
name|a_attrnamespace
argument_list|,
name|ap
operator|->
name|a_name
argument_list|,
name|attrname
argument_list|,
sizeof|sizeof
argument_list|(
name|attrname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_lookup
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|NULL
argument_list|,
operator|&
name|xvp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|,
name|LOOKUP_XATTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|flags
operator|=
name|FREAD
expr_stmt|;
name|NDINIT_ATVP
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|NOFOLLOW
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|attrname
argument_list|,
name|xvp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_open_cred
argument_list|(
operator|&
name|nd
argument_list|,
operator|&
name|flags
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
name|ENOATTR
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|ap
operator|->
name|a_size
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|va
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
name|ap
operator|->
name|a_size
operator|=
operator|(
name|size_t
operator|)
name|va
operator|.
name|va_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ap
operator|->
name|a_uio
operator|!=
name|NULL
condition|)
name|error
operator|=
name|VOP_READ
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|IO_UNIT
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vn_close
argument_list|(
name|vp
argument_list|,
name|flags
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Vnode operation to remove a named attribute.  */
end_comment

begin_function
name|int
name|zfs_deleteextattr
parameter_list|(
name|struct
name|vop_deleteextattr_args
modifier|*
name|ap
parameter_list|)
comment|/* vop_deleteextattr { 	IN struct vnode *a_vp; 	IN int a_attrnamespace; 	IN const char *a_name; 	IN struct ucred *a_cred; 	IN struct thread *a_td; }; */
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|VTOZ
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|->
name|z_zfsvfs
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|char
name|attrname
index|[
literal|255
index|]
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
name|vnode_t
modifier|*
name|xvp
init|=
name|NULL
decl_stmt|,
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|;
name|error
operator|=
name|extattr_check_cred
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_attrnamespace
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
name|VWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|zfs_create_attrname
argument_list|(
name|ap
operator|->
name|a_attrnamespace
argument_list|,
name|ap
operator|->
name|a_name
argument_list|,
name|attrname
argument_list|,
sizeof|sizeof
argument_list|(
name|attrname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_lookup
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|NULL
argument_list|,
operator|&
name|xvp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|,
name|LOOKUP_XATTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|NDINIT_ATVP
argument_list|(
operator|&
name|nd
argument_list|,
name|DELETE
argument_list|,
name|NOFOLLOW
operator||
name|LOCKPARENT
operator||
name|LOCKLEAF
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|attrname
argument_list|,
name|xvp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
name|ENOATTR
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|VOP_REMOVE
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|,
name|vp
argument_list|,
operator|&
name|nd
operator|.
name|ni_cnd
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|nd
operator|.
name|ni_dvp
condition|)
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Vnode operation to set a named attribute.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_setextattr
parameter_list|(
name|struct
name|vop_setextattr_args
modifier|*
name|ap
parameter_list|)
comment|/* vop_setextattr { 	IN struct vnode *a_vp; 	IN int a_attrnamespace; 	IN const char *a_name; 	INOUT struct uio *a_uio; 	IN struct ucred *a_cred; 	IN struct thread *a_td; }; */
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|VTOZ
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|->
name|z_zfsvfs
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|char
name|attrname
index|[
literal|255
index|]
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
name|vnode_t
modifier|*
name|xvp
init|=
name|NULL
decl_stmt|,
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|;
name|error
operator|=
name|extattr_check_cred
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_attrnamespace
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
name|VWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|zfs_create_attrname
argument_list|(
name|ap
operator|->
name|a_attrnamespace
argument_list|,
name|ap
operator|->
name|a_name
argument_list|,
name|attrname
argument_list|,
sizeof|sizeof
argument_list|(
name|attrname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_lookup
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|NULL
argument_list|,
operator|&
name|xvp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|,
name|LOOKUP_XATTR
operator||
name|CREATE_XATTR_DIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|flags
operator|=
name|FFLAGS
argument_list|(
name|O_WRONLY
operator||
name|O_CREAT
argument_list|)
expr_stmt|;
name|NDINIT_ATVP
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|NOFOLLOW
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|attrname
argument_list|,
name|xvp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_open_cred
argument_list|(
operator|&
name|nd
argument_list|,
operator|&
name|flags
argument_list|,
literal|0600
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|VATTR_NULL
argument_list|(
operator|&
name|va
argument_list|)
expr_stmt|;
name|va
operator|.
name|va_size
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|VOP_SETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|va
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|VOP_WRITE
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|IO_UNIT
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vn_close
argument_list|(
name|vp
argument_list|,
name|flags
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Vnode operation to retrieve extended attributes on a vnode.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_listextattr
parameter_list|(
name|struct
name|vop_listextattr_args
modifier|*
name|ap
parameter_list|)
comment|/* vop_listextattr { 	IN struct vnode *a_vp; 	IN int a_attrnamespace; 	INOUT struct uio *a_uio; 	OUT size_t *a_size; 	IN struct ucred *a_cred; 	IN struct thread *a_td; }; */
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|VTOZ
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|->
name|z_zfsvfs
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|char
name|attrprefix
index|[
literal|16
index|]
decl_stmt|;
name|u_char
name|dirbuf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
index|]
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|,
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|size_t
modifier|*
name|sizep
init|=
name|ap
operator|->
name|a_size
decl_stmt|;
name|size_t
name|plen
decl_stmt|;
name|vnode_t
modifier|*
name|xvp
init|=
name|NULL
decl_stmt|,
modifier|*
name|vp
decl_stmt|;
name|int
name|done
decl_stmt|,
name|error
decl_stmt|,
name|eof
decl_stmt|,
name|pos
decl_stmt|;
name|error
operator|=
name|extattr_check_cred
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_attrnamespace
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
name|VREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|zfs_create_attrname
argument_list|(
name|ap
operator|->
name|a_attrnamespace
argument_list|,
literal|""
argument_list|,
name|attrprefix
argument_list|,
sizeof|sizeof
argument_list|(
name|attrprefix
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|plen
operator|=
name|strlen
argument_list|(
name|attrprefix
argument_list|)
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|sizep
operator|!=
name|NULL
condition|)
operator|*
name|sizep
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|zfs_lookup
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|NULL
argument_list|,
operator|&
name|xvp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|,
name|LOOKUP_XATTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
comment|/* 		 * ENOATTR means that the EA directory does not yet exist, 		 * i.e. there are no extended attributes there. 		 */
if|if
condition|(
name|error
operator|==
name|ENOATTR
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|NDINIT_ATVP
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|NOFOLLOW
operator||
name|LOCKLEAF
operator||
name|LOCKSHARED
argument_list|,
name|UIO_SYSSPACE
argument_list|,
literal|"."
argument_list|,
name|xvp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|u_char
name|nlen
decl_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
name|dirbuf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|dirbuf
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
sizeof|sizeof
argument_list|(
name|dirbuf
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_READDIR
argument_list|(
name|vp
argument_list|,
operator|&
name|auio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
operator|&
name|eof
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|done
operator|=
sizeof|sizeof
argument_list|(
name|dirbuf
argument_list|)
operator|-
name|auio
operator|.
name|uio_resid
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|done
condition|;
control|)
block|{
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
operator|(
name|dirbuf
operator|+
name|pos
operator|)
expr_stmt|;
name|pos
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
comment|/* 			 * XXX: Temporarily we also accept DT_UNKNOWN, as this 			 * is what we get when attribute was created on Solaris. 			 */
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|DT_REG
operator|&&
name|dp
operator|->
name|d_type
operator|!=
name|DT_UNKNOWN
condition|)
continue|continue;
if|if
condition|(
name|plen
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"freebsd:"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|attrprefix
argument_list|,
name|plen
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|nlen
operator|=
name|dp
operator|->
name|d_namlen
operator|-
name|plen
expr_stmt|;
if|if
condition|(
name|sizep
operator|!=
name|NULL
condition|)
operator|*
name|sizep
operator|+=
literal|1
operator|+
name|nlen
expr_stmt|;
elseif|else
if|if
condition|(
name|uio
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Format of extattr name entry is one byte for 				 * length and the rest for name. 				 */
name|error
operator|=
name|uiomove
argument_list|(
operator|&
name|nlen
argument_list|,
literal|1
argument_list|,
name|uio
operator|->
name|uio_rw
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|uiomove
argument_list|(
name|dp
operator|->
name|d_name
operator|+
name|plen
argument_list|,
name|nlen
argument_list|,
name|uio
operator|->
name|uio_rw
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
block|}
do|while
condition|(
operator|!
name|eof
operator|&&
name|error
operator|==
literal|0
condition|)
do|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_freebsd_getacl
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_getacl_args
comment|/* { 		struct vnode *vp; 		acl_type_t type; 		struct acl *aclp; 		struct ucred *cred; 		struct thread *td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|vsecattr_t
name|vsecattr
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_type
operator|!=
name|ACL_TYPE_NFS4
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|vsecattr
operator|.
name|vsa_mask
operator|=
name|VSA_ACE
operator||
name|VSA_ACECNT
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|zfs_getsecattr
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
operator|&
name|vsecattr
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|acl_from_aces
argument_list|(
name|ap
operator|->
name|a_aclp
argument_list|,
name|vsecattr
operator|.
name|vsa_aclentp
argument_list|,
name|vsecattr
operator|.
name|vsa_aclcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsecattr
operator|.
name|vsa_aclentp
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|vsecattr
operator|.
name|vsa_aclentp
argument_list|,
name|vsecattr
operator|.
name|vsa_aclentsz
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_freebsd_setacl
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_setacl_args
comment|/* { 		struct vnode *vp; 		acl_type_t type; 		struct acl *aclp; 		struct ucred *cred; 		struct thread *td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|vsecattr_t
name|vsecattr
decl_stmt|;
name|int
name|aclbsize
decl_stmt|;
comment|/* size of acl list in bytes */
name|aclent_t
modifier|*
name|aaclp
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_type
operator|!=
name|ACL_TYPE_NFS4
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ap
operator|->
name|a_aclp
operator|->
name|acl_cnt
operator|<
literal|1
operator|||
name|ap
operator|->
name|a_aclp
operator|->
name|acl_cnt
operator|>
name|MAX_ACL_ENTRIES
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * With NFSv4 ACLs, chmod(2) may need to add additional entries, 	 * splitting every entry into two and appending "canonical six" 	 * entries at the end.  Don't allow for setting an ACL that would 	 * cause chmod(2) to run out of ACL entries. 	 */
if|if
condition|(
name|ap
operator|->
name|a_aclp
operator|->
name|acl_cnt
operator|*
literal|2
operator|+
literal|6
operator|>
name|ACL_MAX_ENTRIES
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|error
operator|=
name|acl_nfs4_check
argument_list|(
name|ap
operator|->
name|a_aclp
argument_list|,
name|ap
operator|->
name|a_vp
operator|->
name|v_type
operator|==
name|VDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vsecattr
operator|.
name|vsa_mask
operator|=
name|VSA_ACE
expr_stmt|;
name|aclbsize
operator|=
name|ap
operator|->
name|a_aclp
operator|->
name|acl_cnt
operator|*
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
expr_stmt|;
name|vsecattr
operator|.
name|vsa_aclentp
operator|=
name|kmem_alloc
argument_list|(
name|aclbsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|aaclp
operator|=
name|vsecattr
operator|.
name|vsa_aclentp
expr_stmt|;
name|vsecattr
operator|.
name|vsa_aclentsz
operator|=
name|aclbsize
expr_stmt|;
name|aces_from_acl
argument_list|(
name|vsecattr
operator|.
name|vsa_aclentp
argument_list|,
operator|&
name|vsecattr
operator|.
name|vsa_aclcnt
argument_list|,
name|ap
operator|->
name|a_aclp
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_setsecattr
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
operator|&
name|vsecattr
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|aaclp
argument_list|,
name|aclbsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_freebsd_aclcheck
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_aclcheck_args
comment|/* { 		struct vnode *vp; 		acl_type_t type; 		struct acl *aclp; 		struct ucred *cred; 		struct thread *td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_vptocnp
parameter_list|(
name|struct
name|vop_vptocnp_args
modifier|*
name|ap
parameter_list|)
block|{
name|vnode_t
modifier|*
name|covered_vp
decl_stmt|;
name|vnode_t
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
empty_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vp
operator|->
name|v_vfsp
operator|->
name|vfs_data
decl_stmt|;
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|uint64_t
name|parent
decl_stmt|;
name|int
name|ltype
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
comment|/* 	 * If we are a snapshot mounted under .zfs, run the operation 	 * on the covered vnode. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_PARENT
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|&
name|parent
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_id
operator|!=
name|parent
operator|||
name|zfsvfs
operator|->
name|z_parent
operator|==
name|zfsvfs
condition|)
block|{
name|char
name|name
index|[
name|MAXNAMLEN
operator|+
literal|1
index|]
decl_stmt|;
name|znode_t
modifier|*
name|dzp
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|error
operator|=
name|zfs_znode_parent_and_name
argument_list|(
name|zp
argument_list|,
operator|&
name|dzp
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ap
operator|->
name|a_buflen
operator|<
name|len
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|ap
operator|->
name|a_buflen
operator|-=
name|len
expr_stmt|;
name|bcopy
argument_list|(
name|name
argument_list|,
name|ap
operator|->
name|a_buf
operator|+
operator|*
name|ap
operator|->
name|a_buflen
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|ap
operator|->
name|a_vpp
operator|=
name|ZTOV
argument_list|(
name|dzp
argument_list|)
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|covered_vp
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_vnodecovered
expr_stmt|;
name|vhold
argument_list|(
name|covered_vp
argument_list|)
expr_stmt|;
name|ltype
operator|=
name|VOP_ISLOCKED
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|vget
argument_list|(
name|covered_vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_VNHELD
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|VOP_VPTOCNP
argument_list|(
name|covered_vp
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_buf
argument_list|,
name|ap
operator|->
name|a_buflen
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|covered_vp
argument_list|)
expr_stmt|;
block|}
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|ltype
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
operator|)
operator|!=
literal|0
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DIAGNOSTIC
end_ifdef

begin_function
specifier|static
name|int
name|zfs_lock
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_lock1_args
comment|/* { 		struct vnode *a_vp; 		int a_flags; 		char *file; 		int line; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|znode_t
modifier|*
name|zp
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|vop_stdlock
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
operator|(
name|ap
operator|->
name|a_flags
operator|&
name|LK_NOWAIT
operator|)
operator|==
literal|0
condition|)
block|{
name|vp
operator|=
name|ap
operator|->
name|a_vp
expr_stmt|;
name|zp
operator|=
name|vp
operator|->
name|v_data
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_mount
operator|!=
name|NULL
operator|&&
operator|(
name|vp
operator|->
name|v_iflag
operator|&
name|VI_DOOMED
operator|)
operator|==
literal|0
operator|&&
name|zp
operator|!=
name|NULL
operator|&&
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_XATTR
operator|)
operator|==
literal|0
condition|)
name|VERIFY
argument_list|(
operator|!
name|RRM_LOCK_HELD
argument_list|(
operator|&
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_teardown_lock
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|vop_vector
name|zfs_vnodeops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vop_vector
name|zfs_fifoops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vop_vector
name|zfs_shareops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vop_vector
name|zfs_vnodeops
init|=
block|{
operator|.
name|vop_default
operator|=
operator|&
name|default_vnodeops
block|,
operator|.
name|vop_inactive
operator|=
name|zfs_freebsd_inactive
block|,
operator|.
name|vop_reclaim
operator|=
name|zfs_freebsd_reclaim
block|,
operator|.
name|vop_access
operator|=
name|zfs_freebsd_access
block|,
operator|.
name|vop_lookup
operator|=
name|zfs_cache_lookup
block|,
operator|.
name|vop_cachedlookup
operator|=
name|zfs_freebsd_lookup
block|,
operator|.
name|vop_getattr
operator|=
name|zfs_freebsd_getattr
block|,
operator|.
name|vop_setattr
operator|=
name|zfs_freebsd_setattr
block|,
operator|.
name|vop_create
operator|=
name|zfs_freebsd_create
block|,
operator|.
name|vop_mknod
operator|=
name|zfs_freebsd_create
block|,
operator|.
name|vop_mkdir
operator|=
name|zfs_freebsd_mkdir
block|,
operator|.
name|vop_readdir
operator|=
name|zfs_freebsd_readdir
block|,
operator|.
name|vop_fsync
operator|=
name|zfs_freebsd_fsync
block|,
operator|.
name|vop_open
operator|=
name|zfs_freebsd_open
block|,
operator|.
name|vop_close
operator|=
name|zfs_freebsd_close
block|,
operator|.
name|vop_rmdir
operator|=
name|zfs_freebsd_rmdir
block|,
operator|.
name|vop_ioctl
operator|=
name|zfs_freebsd_ioctl
block|,
operator|.
name|vop_link
operator|=
name|zfs_freebsd_link
block|,
operator|.
name|vop_symlink
operator|=
name|zfs_freebsd_symlink
block|,
operator|.
name|vop_readlink
operator|=
name|zfs_freebsd_readlink
block|,
operator|.
name|vop_read
operator|=
name|zfs_freebsd_read
block|,
operator|.
name|vop_write
operator|=
name|zfs_freebsd_write
block|,
operator|.
name|vop_remove
operator|=
name|zfs_freebsd_remove
block|,
operator|.
name|vop_rename
operator|=
name|zfs_freebsd_rename
block|,
operator|.
name|vop_pathconf
operator|=
name|zfs_freebsd_pathconf
block|,
operator|.
name|vop_bmap
operator|=
name|zfs_freebsd_bmap
block|,
operator|.
name|vop_fid
operator|=
name|zfs_freebsd_fid
block|,
operator|.
name|vop_getextattr
operator|=
name|zfs_getextattr
block|,
operator|.
name|vop_deleteextattr
operator|=
name|zfs_deleteextattr
block|,
operator|.
name|vop_setextattr
operator|=
name|zfs_setextattr
block|,
operator|.
name|vop_listextattr
operator|=
name|zfs_listextattr
block|,
operator|.
name|vop_getacl
operator|=
name|zfs_freebsd_getacl
block|,
operator|.
name|vop_setacl
operator|=
name|zfs_freebsd_setacl
block|,
operator|.
name|vop_aclcheck
operator|=
name|zfs_freebsd_aclcheck
block|,
operator|.
name|vop_getpages
operator|=
name|zfs_freebsd_getpages
block|,
operator|.
name|vop_putpages
operator|=
name|zfs_freebsd_putpages
block|,
operator|.
name|vop_vptocnp
operator|=
name|zfs_vptocnp
block|,
ifdef|#
directive|ifdef
name|DIAGNOSTIC
operator|.
name|vop_lock1
operator|=
name|zfs_lock
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vop_vector
name|zfs_fifoops
init|=
block|{
operator|.
name|vop_default
operator|=
operator|&
name|fifo_specops
block|,
operator|.
name|vop_fsync
operator|=
name|zfs_freebsd_fsync
block|,
operator|.
name|vop_access
operator|=
name|zfs_freebsd_access
block|,
operator|.
name|vop_getattr
operator|=
name|zfs_freebsd_getattr
block|,
operator|.
name|vop_inactive
operator|=
name|zfs_freebsd_inactive
block|,
operator|.
name|vop_read
operator|=
name|VOP_PANIC
block|,
operator|.
name|vop_reclaim
operator|=
name|zfs_freebsd_reclaim
block|,
operator|.
name|vop_setattr
operator|=
name|zfs_freebsd_setattr
block|,
operator|.
name|vop_write
operator|=
name|VOP_PANIC
block|,
operator|.
name|vop_pathconf
operator|=
name|zfs_freebsd_fifo_pathconf
block|,
operator|.
name|vop_fid
operator|=
name|zfs_freebsd_fid
block|,
operator|.
name|vop_getacl
operator|=
name|zfs_freebsd_getacl
block|,
operator|.
name|vop_setacl
operator|=
name|zfs_freebsd_setacl
block|,
operator|.
name|vop_aclcheck
operator|=
name|zfs_freebsd_aclcheck
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * special share hidden files vnode operations template  */
end_comment

begin_decl_stmt
name|struct
name|vop_vector
name|zfs_shareops
init|=
block|{
operator|.
name|vop_default
operator|=
operator|&
name|default_vnodeops
block|,
operator|.
name|vop_access
operator|=
name|zfs_freebsd_access
block|,
operator|.
name|vop_inactive
operator|=
name|zfs_freebsd_inactive
block|,
operator|.
name|vop_reclaim
operator|=
name|zfs_freebsd_reclaim
block|,
operator|.
name|vop_fid
operator|=
name|zfs_freebsd_fid
block|,
operator|.
name|vop_pathconf
operator|=
name|zfs_freebsd_pathconf
block|, }
decl_stmt|;
end_decl_stmt

end_unit

