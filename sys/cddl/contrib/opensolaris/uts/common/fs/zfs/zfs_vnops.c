begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/* Portions Copyright 2007 Jeremy Teo */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/vfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskq.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/atomic.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/txg.h>
end_include

begin_include
include|#
directive|include
file|<sys/dbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/policy.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ctldir.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_fuid.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnlc.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_rlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/extdirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/kidmap.h>
end_include

begin_include
include|#
directive|include
file|<sys/bio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sf_buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/acl.h>
end_include

begin_comment
comment|/*  * Programming rules.  *  * Each vnode op performs some logical unit of work.  To do this, the ZPL must  * properly lock its in-core state, create a DMU transaction, do the work,  * record this work in the intent log (ZIL), commit the DMU transaction,  * and wait for the intent log to commit if it is a synchronous operation.  * Moreover, the vnode ops must work in both normal and log replay context.  * The ordering of events is important to avoid deadlocks and references  * to freed memory.  The example below illustrates the following Big Rules:  *  *  (1) A check must be made in each zfs thread for a mounted file system.  *	This is done avoiding races using ZFS_ENTER(zfsvfs).  *      A ZFS_EXIT(zfsvfs) is needed before all returns.  Any znodes  *      must be checked with ZFS_VERIFY_ZP(zp).  Both of these macros  *      can return EIO from the calling function.  *  *  (2)	VN_RELE() should always be the last thing except for zil_commit()  *	(if necessary) and ZFS_EXIT(). This is for 3 reasons:  *	First, if it's the last reference, the vnode/znode  *	can be freed, so the zp may point to freed memory.  Second, the last  *	reference will call zfs_zinactive(), which may induce a lot of work --  *	pushing cached pages (which acquires range locks) and syncing out  *	cached atime changes.  Third, zfs_zinactive() may require a new tx,  *	which could deadlock the system if you were already holding one.  *	If you must call VN_RELE() within a tx then use VN_RELE_ASYNC().  *  *  (3)	All range locks must be grabbed before calling dmu_tx_assign(),  *	as they can span dmu_tx_assign() calls.  *  *  (4)	Always pass zfsvfs->z_assign as the second argument to dmu_tx_assign().  *	In normal operation, this will be TXG_NOWAIT.  During ZIL replay,  *	it will be a specific txg.  Either way, dmu_tx_assign() never blocks.  *	This is critical because we don't want to block while holding locks.  *	Note, in particular, that if a lock is sometimes acquired before  *	the tx assigns, and sometimes after (e.g. z_lock), then failing to  *	use a non-blocking assign can deadlock the system.  The scenario:  *  *	Thread A has grabbed a lock before calling dmu_tx_assign().  *	Thread B is in an already-assigned tx, and blocks for this lock.  *	Thread A calls dmu_tx_assign(TXG_WAIT) and blocks in txg_wait_open()  *	forever, because the previous txg can't quiesce until B's tx commits.  *  *	If dmu_tx_assign() returns ERESTART and zfsvfs->z_assign is TXG_NOWAIT,  *	then drop all locks, call dmu_tx_wait(), and try again.  *  *  (5)	If the operation succeeded, generate the intent log entry for it  *	before dropping locks.  This ensures that the ordering of events  *	in the intent log matches the order in which they actually occurred.  *  *  (6)	At the end of each vnode op, the DMU tx must always commit,  *	regardless of whether there were any errors.  *  *  (7)	After dropping all locks, invoke zil_commit(zilog, seq, foid)  *	to ensure that synchronous semantics are provided when necessary.  *  * In general, this is how things should be ordered in each vnode op:  *  *	ZFS_ENTER(zfsvfs);		// exit if unmounted  * top:  *	zfs_dirent_lock(&dl, ...)	// lock directory entry (may VN_HOLD())  *	rw_enter(...);			// grab any other locks you need  *	tx = dmu_tx_create(...);	// get DMU tx  *	dmu_tx_hold_*();		// hold each object you might modify  *	error = dmu_tx_assign(tx, zfsvfs->z_assign);	// try to assign  *	if (error) {  *		rw_exit(...);		// drop locks  *		zfs_dirent_unlock(dl);	// unlock directory entry  *		VN_RELE(...);		// release held vnodes  *		if (error == ERESTART&& zfsvfs->z_assign == TXG_NOWAIT) {  *			dmu_tx_wait(tx);  *			dmu_tx_abort(tx);  *			goto top;  *		}  *		dmu_tx_abort(tx);	// abort DMU tx  *		ZFS_EXIT(zfsvfs);	// finished in zfs  *		return (error);		// really out of space  *	}  *	error = do_real_work();		// do whatever this VOP does  *	if (error == 0)  *		zfs_log_*(...);		// on success, make ZIL entry  *	dmu_tx_commit(tx);		// commit DMU tx -- error or not  *	rw_exit(...);			// drop locks  *	zfs_dirent_unlock(dl);		// unlock directory entry  *	VN_RELE(...);			// release held vnodes  *	zil_commit(zilog, seq, foid);	// synchronous when necessary  *	ZFS_EXIT(zfsvfs);		// finished in zfs  *	return (error);			// done, report error  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_open
parameter_list|(
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|int
name|flag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
operator|*
name|vpp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|&&
operator|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_APPENDONLY
operator|)
operator|&&
operator|(
operator|(
name|flag
operator|&
name|FAPPEND
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|zfs_has_ctldir
argument_list|(
name|zp
argument_list|)
operator|&&
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_vscan
operator|&&
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|==
name|VREG
operator|&&
operator|!
operator|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_AV_QUARANTINED
operator|)
operator|&&
name|zp
operator|->
name|z_phys
operator|->
name|zp_size
operator|>
literal|0
condition|)
if|if
condition|(
name|fs_vscan
argument_list|(
operator|*
name|vpp
argument_list|,
name|cr
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
comment|/* Keep a count of the synchronous opens in the znode */
if|if
condition|(
name|flag
operator|&
operator|(
name|FSYNC
operator||
name|FDSYNC
operator|)
condition|)
name|atomic_inc_32
argument_list|(
operator|&
name|zp
operator|->
name|z_sync_cnt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_close
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|count
parameter_list|,
name|offset_t
name|offset
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
comment|/* Decrement the synchronous opens in the znode */
if|if
condition|(
operator|(
name|flag
operator|&
operator|(
name|FSYNC
operator||
name|FDSYNC
operator|)
operator|)
operator|&&
operator|(
name|count
operator|==
literal|1
operator|)
condition|)
name|atomic_dec_32
argument_list|(
operator|&
name|zp
operator|->
name|z_sync_cnt
argument_list|)
expr_stmt|;
comment|/* 	 * Clean up any locks held by this process on the vp. 	 */
name|cleanlocks
argument_list|(
name|vp
argument_list|,
name|ddi_get_pid
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cleanshares
argument_list|(
name|vp
argument_list|,
name|ddi_get_pid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zfs_has_ctldir
argument_list|(
name|zp
argument_list|)
operator|&&
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_vscan
operator|&&
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|==
name|VREG
operator|&&
operator|!
operator|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_AV_QUARANTINED
operator|)
operator|&&
name|zp
operator|->
name|z_phys
operator|->
name|zp_size
operator|>
literal|0
condition|)
name|VERIFY
argument_list|(
name|fs_vscan
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lseek support for finding holes (cmd == _FIO_SEEK_HOLE) and  * data (cmd == _FIO_SEEK_DATA). "off" is an in/out parameter.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_holey
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|offset_t
modifier|*
name|off
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|uint64_t
name|noff
init|=
operator|(
name|uint64_t
operator|)
operator|*
name|off
decl_stmt|;
comment|/* new offset */
name|uint64_t
name|file_sz
decl_stmt|;
name|int
name|error
decl_stmt|;
name|boolean_t
name|hole
decl_stmt|;
name|file_sz
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_size
expr_stmt|;
if|if
condition|(
name|noff
operator|>=
name|file_sz
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|cmd
operator|==
name|_FIO_SEEK_HOLE
condition|)
name|hole
operator|=
name|B_TRUE
expr_stmt|;
else|else
name|hole
operator|=
name|B_FALSE
expr_stmt|;
name|error
operator|=
name|dmu_offset_next
argument_list|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|hole
argument_list|,
operator|&
name|noff
argument_list|)
expr_stmt|;
comment|/* end of file? */
if|if
condition|(
operator|(
name|error
operator|==
name|ESRCH
operator|)
operator|||
operator|(
name|noff
operator|>
name|file_sz
operator|)
condition|)
block|{
comment|/* 		 * Handle the virtual hole at the end of file. 		 */
if|if
condition|(
name|hole
condition|)
block|{
operator|*
name|off
operator|=
name|file_sz
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|noff
operator|<
operator|*
name|off
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|off
operator|=
name|noff
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_ioctl
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|u_long
name|com
parameter_list|,
name|intptr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|cred_t
modifier|*
name|cred
parameter_list|,
name|int
modifier|*
name|rvalp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|offset_t
name|off
decl_stmt|;
name|int
name|error
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
decl_stmt|;
name|znode_t
modifier|*
name|zp
decl_stmt|;
switch|switch
condition|(
name|com
condition|)
block|{
case|case
name|_FIOFFS
case|:
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * The following two ioctls are used by bfu.  Faking out, 		 * necessary to avoid bfu errors. 		 */
case|case
name|_FIOGDIO
case|:
case|case
name|_FIOSDIO
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_FIO_SEEK_DATA
case|:
case|case
name|_FIO_SEEK_HOLE
case|:
if|if
condition|(
name|ddi_copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|data
argument_list|,
operator|&
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|off
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|zp
operator|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|zfsvfs
operator|=
name|zp
operator|->
name|z_zfsvfs
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
comment|/* offset parameter is in/out */
name|error
operator|=
name|zfs_holey
argument_list|(
name|vp
argument_list|,
name|com
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|ddi_copyout
argument_list|(
operator|&
name|off
argument_list|,
operator|(
name|void
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|off
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * When a file is memory mapped, we must keep the IO data synchronized  * between the DMU cache and the memory mapped pages.  What this means:  *  * On Write:	If we find a memory mapped page, we write to *both*  *		the page and the dmu buffer.  *  * NOTE: We will always "break up" the IO into PAGESIZE uiomoves when  *	the file is memory mapped.  */
end_comment

begin_function
specifier|static
name|int
name|mappedwrite
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|nbytes
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_os
decl_stmt|;
name|vm_object_t
name|obj
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|int64_t
name|start
decl_stmt|,
name|off
decl_stmt|;
name|int
name|len
init|=
name|nbytes
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint64_t
name|dirbytes
decl_stmt|;
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_mount
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|obj
operator|=
name|vp
operator|->
name|v_object
expr_stmt|;
name|ASSERT
argument_list|(
name|obj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|start
operator|=
name|uio
operator|->
name|uio_loffset
expr_stmt|;
name|off
operator|=
name|start
operator|&
name|PAGEOFFSET
expr_stmt|;
name|dirbytes
operator|=
literal|0
expr_stmt|;
name|VM_OBJECT_LOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
for|for
control|(
name|start
operator|&=
name|PAGEMASK
init|;
name|len
operator|>
literal|0
condition|;
name|start
operator|+=
name|PAGESIZE
control|)
block|{
name|uint64_t
name|bytes
init|=
name|MIN
argument_list|(
name|PAGESIZE
operator|-
name|off
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|uint64_t
name|fsize
decl_stmt|;
name|again
label|:
if|if
condition|(
operator|(
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|start
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|vm_page_is_valid
argument_list|(
name|m
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|off
argument_list|,
name|bytes
argument_list|)
condition|)
block|{
name|uint64_t
name|woff
decl_stmt|;
name|caddr_t
name|va
decl_stmt|;
if|if
condition|(
name|vm_page_sleep_if_busy
argument_list|(
name|m
argument_list|,
name|FALSE
argument_list|,
literal|"zfsmwb"
argument_list|)
condition|)
goto|goto
name|again
goto|;
name|fsize
operator|=
name|obj
operator|->
name|un_pager
operator|.
name|vnp
operator|.
name|vnp_size
expr_stmt|;
name|vm_page_busy
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_lock_queues
argument_list|()
expr_stmt|;
name|vm_page_undirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unlock_queues
argument_list|()
expr_stmt|;
name|VM_OBJECT_UNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirbytes
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|dmu_write_uio
argument_list|(
name|os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|uio
argument_list|,
name|dirbytes
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dirbytes
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|sched_pin
argument_list|()
expr_stmt|;
name|sf
operator|=
name|sf_buf_alloc
argument_list|(
name|m
argument_list|,
name|SFB_CPUPRIVATE
argument_list|)
expr_stmt|;
name|va
operator|=
operator|(
name|caddr_t
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|woff
operator|=
name|uio
operator|->
name|uio_loffset
operator|-
name|off
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|va
operator|+
name|off
argument_list|,
name|bytes
argument_list|,
name|UIO_WRITE
argument_list|,
name|uio
argument_list|)
expr_stmt|;
comment|/* 				 * The uiomove() above could have been partially 				 * successful, that's why we call dmu_write() 				 * below unconditionally. The page was marked 				 * non-dirty above and we would lose the changes 				 * without doing so. If the uiomove() failed 				 * entirely, well, we just write what we got 				 * before one more time. 				 */
name|dmu_write
argument_list|(
name|os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|woff
argument_list|,
name|MIN
argument_list|(
name|PAGESIZE
argument_list|,
name|fsize
operator|-
name|woff
argument_list|)
argument_list|,
name|va
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|sched_unpin
argument_list|()
expr_stmt|;
block|}
name|VM_OBJECT_LOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|vm_page_wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|__predict_false
argument_list|(
name|obj
operator|->
name|cache
operator|!=
name|NULL
argument_list|)
condition|)
block|{
name|vm_page_cache_free
argument_list|(
name|obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|start
argument_list|)
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|start
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|dirbytes
operator|+=
name|bytes
expr_stmt|;
block|}
name|len
operator|-=
name|bytes
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|VM_OBJECT_UNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|dirbytes
operator|>
literal|0
condition|)
name|error
operator|=
name|dmu_write_uio
argument_list|(
name|os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|uio
argument_list|,
name|dirbytes
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * When a file is memory mapped, we must keep the IO data synchronized  * between the DMU cache and the memory mapped pages.  What this means:  *  * On Read:	We "read" preferentially from memory mapped pages,  *		else we default from the dmu buffer.  *  * NOTE: We will always "break up" the IO into PAGESIZE uiomoves when  *	the file is memory mapped.  */
end_comment

begin_function
specifier|static
name|int
name|mappedread
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|nbytes
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_os
decl_stmt|;
name|vm_object_t
name|obj
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|int64_t
name|start
decl_stmt|,
name|off
decl_stmt|;
name|caddr_t
name|va
decl_stmt|;
name|int
name|len
init|=
name|nbytes
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint64_t
name|dirbytes
decl_stmt|;
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_mount
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|obj
operator|=
name|vp
operator|->
name|v_object
expr_stmt|;
name|ASSERT
argument_list|(
name|obj
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|start
operator|=
name|uio
operator|->
name|uio_loffset
expr_stmt|;
name|off
operator|=
name|start
operator|&
name|PAGEOFFSET
expr_stmt|;
name|dirbytes
operator|=
literal|0
expr_stmt|;
name|VM_OBJECT_LOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
for|for
control|(
name|start
operator|&=
name|PAGEMASK
init|;
name|len
operator|>
literal|0
condition|;
name|start
operator|+=
name|PAGESIZE
control|)
block|{
name|uint64_t
name|bytes
init|=
name|MIN
argument_list|(
name|PAGESIZE
operator|-
name|off
argument_list|,
name|len
argument_list|)
decl_stmt|;
name|again
label|:
if|if
condition|(
operator|(
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|obj
argument_list|,
name|OFF_TO_IDX
argument_list|(
name|start
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|vm_page_is_valid
argument_list|(
name|m
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|off
argument_list|,
name|bytes
argument_list|)
condition|)
block|{
if|if
condition|(
name|vm_page_sleep_if_busy
argument_list|(
name|m
argument_list|,
name|FALSE
argument_list|,
literal|"zfsmrb"
argument_list|)
condition|)
goto|goto
name|again
goto|;
name|vm_page_busy
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|VM_OBJECT_UNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirbytes
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|dmu_read_uio
argument_list|(
name|os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|uio
argument_list|,
name|dirbytes
argument_list|)
expr_stmt|;
name|dirbytes
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|sched_pin
argument_list|()
expr_stmt|;
name|sf
operator|=
name|sf_buf_alloc
argument_list|(
name|m
argument_list|,
name|SFB_CPUPRIVATE
argument_list|)
expr_stmt|;
name|va
operator|=
operator|(
name|caddr_t
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|va
operator|+
name|off
argument_list|,
name|bytes
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|sched_unpin
argument_list|()
expr_stmt|;
block|}
name|VM_OBJECT_LOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|vm_page_wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
name|uio
operator|->
name|uio_segflg
operator|==
name|UIO_NOCOPY
condition|)
block|{
comment|/* 			 * The code below is here to make sendfile(2) work 			 * correctly with ZFS. As pointed out by ups@ 			 * sendfile(2) should be changed to use VOP_GETPAGES(), 			 * but it pessimize performance of sendfile/UFS, that's 			 * why I handle this special case in ZFS code. 			 */
if|if
condition|(
name|vm_page_sleep_if_busy
argument_list|(
name|m
argument_list|,
name|FALSE
argument_list|,
literal|"zfsmrb"
argument_list|)
condition|)
goto|goto
name|again
goto|;
name|vm_page_busy
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|VM_OBJECT_UNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirbytes
operator|>
literal|0
condition|)
block|{
name|error
operator|=
name|dmu_read_uio
argument_list|(
name|os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|uio
argument_list|,
name|dirbytes
argument_list|)
expr_stmt|;
name|dirbytes
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|sched_pin
argument_list|()
expr_stmt|;
name|sf
operator|=
name|sf_buf_alloc
argument_list|(
name|m
argument_list|,
name|SFB_CPUPRIVATE
argument_list|)
expr_stmt|;
name|va
operator|=
operator|(
name|caddr_t
operator|)
name|sf_buf_kva
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_read
argument_list|(
name|os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|start
operator|+
name|off
argument_list|,
name|bytes
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|va
operator|+
name|off
operator|)
argument_list|)
expr_stmt|;
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|sched_unpin
argument_list|()
expr_stmt|;
block|}
name|VM_OBJECT_LOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|vm_page_wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|uio
operator|->
name|uio_resid
operator|-=
name|bytes
expr_stmt|;
block|}
else|else
block|{
name|dirbytes
operator|+=
name|bytes
expr_stmt|;
block|}
name|len
operator|-=
name|bytes
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|VM_OBJECT_UNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|dirbytes
operator|>
literal|0
condition|)
name|error
operator|=
name|dmu_read_uio
argument_list|(
name|os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|uio
argument_list|,
name|dirbytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|offset_t
name|zfs_read_chunk_size
init|=
literal|1024
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tunable */
end_comment

begin_comment
comment|/*  * Read bytes from specified file into supplied buffer.  *  *	IN:	vp	- vnode of file to be read from.  *		uio	- structure supplying read location, range info,  *			  and return buffer.  *		ioflag	- SYNC flags; used to provide FRSYNC semantics.  *		cr	- credentials of caller.  *		ct	- caller context  *  *	OUT:	uio	- updated offset and range, buffer filled.  *  *	RETURN:	0 if success  *		error code if failure  *  * Side Effects:  *	vp - atime updated if byte count> 0  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_read
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|ssize_t
name|n
decl_stmt|,
name|nbytes
decl_stmt|;
name|int
name|error
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|os
operator|=
name|zfsvfs
operator|->
name|z_os
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_AV_QUARANTINED
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EACCES
operator|)
return|;
block|}
comment|/* 	 * Validate file offset 	 */
if|if
condition|(
name|uio
operator|->
name|uio_loffset
operator|<
operator|(
name|offset_t
operator|)
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Fasttrack empty reads 	 */
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Check for mandatory locks 	 */
if|if
condition|(
name|MANDMODE
argument_list|(
operator|(
name|mode_t
operator|)
name|zp
operator|->
name|z_phys
operator|->
name|zp_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|chklock
argument_list|(
name|vp
argument_list|,
name|FREAD
argument_list|,
name|uio
operator|->
name|uio_loffset
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|uio
operator|->
name|uio_fmode
argument_list|,
name|ct
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * If we're in FRSYNC mode, sync out this znode before reading it. 	 */
if|if
condition|(
name|ioflag
operator|&
name|FRSYNC
condition|)
name|zil_commit
argument_list|(
name|zfsvfs
operator|->
name|z_log
argument_list|,
name|zp
operator|->
name|z_last_itx
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
comment|/* 	 * Lock the range against changes. 	 */
name|rl
operator|=
name|zfs_range_lock
argument_list|(
name|zp
argument_list|,
name|uio
operator|->
name|uio_loffset
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|RL_READER
argument_list|)
expr_stmt|;
comment|/* 	 * If we are reading past end-of-file we can skip 	 * to the end; but we might still need to set atime. 	 */
if|if
condition|(
name|uio
operator|->
name|uio_loffset
operator|>=
name|zp
operator|->
name|z_phys
operator|->
name|zp_size
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ASSERT
argument_list|(
name|uio
operator|->
name|uio_loffset
operator|<
name|zp
operator|->
name|z_phys
operator|->
name|zp_size
argument_list|)
expr_stmt|;
name|n
operator|=
name|MIN
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|zp
operator|->
name|z_phys
operator|->
name|zp_size
operator|-
name|uio
operator|->
name|uio_loffset
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|nbytes
operator|=
name|MIN
argument_list|(
name|n
argument_list|,
name|zfs_read_chunk_size
operator|-
name|P2PHASE
argument_list|(
name|uio
operator|->
name|uio_loffset
argument_list|,
name|zfs_read_chunk_size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_has_cached_data
argument_list|(
name|vp
argument_list|)
condition|)
name|error
operator|=
name|mappedread
argument_list|(
name|vp
argument_list|,
name|nbytes
argument_list|,
name|uio
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|dmu_read_uio
argument_list|(
name|os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|uio
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* convert checksum errors into IO errors */
if|if
condition|(
name|error
operator|==
name|ECKSUM
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
break|break;
block|}
name|n
operator|-=
name|nbytes
expr_stmt|;
block|}
name|out
label|:
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|ZFS_ACCESSTIME_STAMP
argument_list|(
name|zfsvfs
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fault in the pages of the first n bytes specified by the uio structure.  * 1 byte in each page is touched and the uio struct is unmodified.  * Any error will exit this routine as this is only a best  * attempt to get the pages resident. This is a copy of ufs_trans_touch().  */
end_comment

begin_function
specifier|static
name|void
name|zfs_prefault_write
parameter_list|(
name|ssize_t
name|n
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
block|{
name|struct
name|iovec
modifier|*
name|iov
decl_stmt|;
name|ulong_t
name|cnt
decl_stmt|,
name|incr
decl_stmt|;
name|caddr_t
name|p
decl_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_segflg
operator|!=
name|UIO_USERSPACE
condition|)
return|return;
name|iov
operator|=
name|uio
operator|->
name|uio_iov
expr_stmt|;
while|while
condition|(
name|n
condition|)
block|{
name|cnt
operator|=
name|MIN
argument_list|(
name|iov
operator|->
name|iov_len
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
block|{
comment|/* empty iov entry */
name|iov
operator|++
expr_stmt|;
continue|continue;
block|}
name|n
operator|-=
name|cnt
expr_stmt|;
comment|/* 		 * touch each page in this segment. 		 */
name|p
operator|=
name|iov
operator|->
name|iov_base
expr_stmt|;
while|while
condition|(
name|cnt
condition|)
block|{
if|if
condition|(
name|fubyte
argument_list|(
name|p
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return;
name|incr
operator|=
name|MIN
argument_list|(
name|cnt
argument_list|,
name|PAGESIZE
argument_list|)
expr_stmt|;
name|p
operator|+=
name|incr
expr_stmt|;
name|cnt
operator|-=
name|incr
expr_stmt|;
block|}
comment|/* 		 * touch the last byte in case it straddles a page. 		 */
name|p
operator|--
expr_stmt|;
if|if
condition|(
name|fubyte
argument_list|(
name|p
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return;
name|iov
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Write the bytes to a file.  *  *	IN:	vp	- vnode of file to be written to.  *		uio	- structure supplying write location, range info,  *			  and data buffer.  *		ioflag	- IO_APPEND flag set if in append mode.  *		cr	- credentials of caller.  *		ct	- caller context (NFS/CIFS fem monitor only)  *  *	OUT:	uio	- updated offset and range.  *  *	RETURN:	0 if success  *		error code if failure  *  * Timestamps:  *	vp - ctime|mtime updated if byte count> 0  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_write
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|rlim64_t
name|limit
init|=
name|MAXOFFSET_T
decl_stmt|;
name|ssize_t
name|start_resid
init|=
name|uio
operator|->
name|uio_resid
decl_stmt|;
name|ssize_t
name|tx_bytes
decl_stmt|;
name|uint64_t
name|end_size
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|offset_t
name|woff
decl_stmt|;
name|ssize_t
name|n
decl_stmt|,
name|nbytes
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|int
name|max_blksz
init|=
name|zfsvfs
operator|->
name|z_max_blksz
decl_stmt|;
name|uint64_t
name|pflags
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Fasttrack empty write 	 */
name|n
operator|=
name|start_resid
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|limit
operator|==
name|RLIM64_INFINITY
operator|||
name|limit
operator|>
name|MAXOFFSET_T
condition|)
name|limit
operator|=
name|MAXOFFSET_T
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
comment|/* 	 * If immutable or not appending then return EPERM 	 */
name|pflags
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_flags
expr_stmt|;
if|if
condition|(
operator|(
name|pflags
operator|&
operator|(
name|ZFS_IMMUTABLE
operator||
name|ZFS_READONLY
operator|)
operator|)
operator|||
operator|(
operator|(
name|pflags
operator|&
name|ZFS_APPENDONLY
operator|)
operator|&&
operator|!
operator|(
name|ioflag
operator|&
name|FAPPEND
operator|)
operator|&&
operator|(
name|uio
operator|->
name|uio_loffset
operator|<
name|zp
operator|->
name|z_phys
operator|->
name|zp_size
operator|)
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
comment|/* 	 * Pre-fault the pages to ensure slow (eg NFS) pages 	 * don't hold up txg. 	 */
name|zfs_prefault_write
argument_list|(
name|n
argument_list|,
name|uio
argument_list|)
expr_stmt|;
comment|/* 	 * If in append mode, set the io offset pointer to eof. 	 */
if|if
condition|(
name|ioflag
operator|&
name|IO_APPEND
condition|)
block|{
comment|/* 		 * Range lock for a file append: 		 * The value for the start of range will be determined by 		 * zfs_range_lock() (to guarantee append semantics). 		 * If this write will cause the block size to increase, 		 * zfs_range_lock() will lock the entire file, so we must 		 * later reduce the range after we grow the block size. 		 */
name|rl
operator|=
name|zfs_range_lock
argument_list|(
name|zp
argument_list|,
literal|0
argument_list|,
name|n
argument_list|,
name|RL_APPEND
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|->
name|r_len
operator|==
name|UINT64_MAX
condition|)
block|{
comment|/* overlocked, zp_size can't change */
name|woff
operator|=
name|uio
operator|->
name|uio_loffset
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_size
expr_stmt|;
block|}
else|else
block|{
name|woff
operator|=
name|uio
operator|->
name|uio_loffset
operator|=
name|rl
operator|->
name|r_off
expr_stmt|;
block|}
block|}
else|else
block|{
name|woff
operator|=
name|uio
operator|->
name|uio_loffset
expr_stmt|;
comment|/* 		 * Validate file offset 		 */
if|if
condition|(
name|woff
operator|<
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 		 * If we need to grow the block size then zfs_range_lock() 		 * will lock a wider range than we request here. 		 * Later after growing the block size we reduce the range. 		 */
name|rl
operator|=
name|zfs_range_lock
argument_list|(
name|zp
argument_list|,
name|woff
argument_list|,
name|n
argument_list|,
name|RL_WRITER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|woff
operator|>=
name|limit
condition|)
block|{
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFBIG
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|woff
operator|+
name|n
operator|)
operator|>
name|limit
operator|||
name|woff
operator|>
operator|(
name|limit
operator|-
name|n
operator|)
condition|)
name|n
operator|=
name|limit
operator|-
name|woff
expr_stmt|;
comment|/* 	 * Check for mandatory locks 	 */
if|if
condition|(
name|MANDMODE
argument_list|(
operator|(
name|mode_t
operator|)
name|zp
operator|->
name|z_phys
operator|->
name|zp_mode
argument_list|)
operator|&&
operator|(
name|error
operator|=
name|chklock
argument_list|(
name|vp
argument_list|,
name|FWRITE
argument_list|,
name|woff
argument_list|,
name|n
argument_list|,
name|uio
operator|->
name|uio_fmode
argument_list|,
name|ct
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|end_size
operator|=
name|MAX
argument_list|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_size
argument_list|,
name|woff
operator|+
name|n
argument_list|)
expr_stmt|;
comment|/* 	 * Write the file in reasonable size chunks.  Each chunk is written 	 * in a separate transaction; this keeps the intent log records small 	 * and allows us to do more fine-grained space accounting. 	 */
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Start a transaction. 		 */
name|woff
operator|=
name|uio
operator|->
name|uio_loffset
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|woff
argument_list|,
name|MIN
argument_list|(
name|n
argument_list|,
name|max_blksz
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_assign
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|&&
name|zfsvfs
operator|->
name|z_assign
operator|==
name|TXG_NOWAIT
condition|)
block|{
name|dmu_tx_wait
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * If zfs_range_lock() over-locked we grow the blocksize 		 * and then reduce the lock range.  This will only happen 		 * on the first iteration since zfs_range_reduce() will 		 * shrink down r_len to the appropriate size. 		 */
if|if
condition|(
name|rl
operator|->
name|r_len
operator|==
name|UINT64_MAX
condition|)
block|{
name|uint64_t
name|new_blksz
decl_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_blksz
operator|>
name|max_blksz
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|ISP2
argument_list|(
name|zp
operator|->
name|z_blksz
argument_list|)
argument_list|)
expr_stmt|;
name|new_blksz
operator|=
name|MIN
argument_list|(
name|end_size
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_blksz
operator|=
name|MIN
argument_list|(
name|end_size
argument_list|,
name|max_blksz
argument_list|)
expr_stmt|;
block|}
name|zfs_grow_blocksize
argument_list|(
name|zp
argument_list|,
name|new_blksz
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zfs_range_reduce
argument_list|(
name|rl
argument_list|,
name|woff
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * XXX - should we really limit each write to z_max_blksz? 		 * Perhaps we should use SPA_MAXBLOCKSIZE chunks? 		 */
name|nbytes
operator|=
name|MIN
argument_list|(
name|n
argument_list|,
name|max_blksz
operator|-
name|P2PHASE
argument_list|(
name|woff
argument_list|,
name|max_blksz
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|woff
operator|+
name|nbytes
operator|>
name|zp
operator|->
name|z_phys
operator|->
name|zp_size
condition|)
name|vnode_pager_setsize
argument_list|(
name|vp
argument_list|,
name|woff
operator|+
name|nbytes
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_map_lock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|tx_bytes
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
name|vn_has_cached_data
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_map_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|mappedwrite
argument_list|(
name|vp
argument_list|,
name|nbytes
argument_list|,
name|uio
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|dmu_write_uio
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|uio
argument_list|,
name|nbytes
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_map_lock
argument_list|)
expr_stmt|;
block|}
name|tx_bytes
operator|-=
name|uio
operator|->
name|uio_resid
expr_stmt|;
comment|/* 		 * If we made no progress, we're done.  If we made even 		 * partial progress, update the znode and ZIL accordingly. 		 */
if|if
condition|(
name|tx_bytes
operator|==
literal|0
condition|)
block|{
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|!=
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Clear Set-UID/Set-GID bits on successful write if not 		 * privileged and at least one of the excute bits is set. 		 * 		 * It would be nice to to this after all writes have 		 * been done, but that would still expose the ISUID/ISGID 		 * to another app after the partial write is committed. 		 * 		 * Note: we don't call zfs_fuid_map_id() here because 		 * user 0 is not an ephemeral uid. 		 */
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_mode
operator|&
operator|(
name|S_IXUSR
operator||
operator|(
name|S_IXUSR
operator|>>
literal|3
operator|)
operator||
operator|(
name|S_IXUSR
operator|>>
literal|6
operator|)
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_mode
operator|&
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|secpolicy_vnode_setid_retain
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|,
operator|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_mode
operator|&
name|S_ISUID
operator|)
operator|!=
literal|0
operator|&&
name|zp
operator|->
name|z_phys
operator|->
name|zp_uid
operator|==
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zp
operator|->
name|z_phys
operator|->
name|zp_mode
operator|&=
operator|~
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Update time stamp.  NOTE: This marks the bonus buffer as 		 * dirty, so we don't have to do it again for zp_size. 		 */
name|zfs_time_stamper
argument_list|(
name|zp
argument_list|,
name|CONTENT_MODIFIED
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 		 * Update the file size (zp_size) if it has changed; 		 * account for possible concurrent updates. 		 */
while|while
condition|(
operator|(
name|end_size
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_size
operator|)
operator|<
name|uio
operator|->
name|uio_loffset
condition|)
operator|(
name|void
operator|)
name|atomic_cas_64
argument_list|(
operator|&
name|zp
operator|->
name|z_phys
operator|->
name|zp_size
argument_list|,
name|end_size
argument_list|,
name|uio
operator|->
name|uio_loffset
argument_list|)
expr_stmt|;
name|zfs_log_write
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|TX_WRITE
argument_list|,
name|zp
argument_list|,
name|woff
argument_list|,
name|tx_bytes
argument_list|,
name|ioflag
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|ASSERT
argument_list|(
name|tx_bytes
operator|==
name|nbytes
argument_list|)
expr_stmt|;
name|n
operator|-=
name|nbytes
expr_stmt|;
block|}
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
comment|/* 	 * If we're in replay mode, or we made no progress, return error. 	 * Otherwise, it's at least a partial write, so it's successful. 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_assign
operator|>=
name|TXG_INITIAL
operator|||
name|uio
operator|->
name|uio_resid
operator|==
name|start_resid
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|ioflag
operator|&
operator|(
name|FSYNC
operator||
name|FDSYNC
operator|)
condition|)
name|zil_commit
argument_list|(
name|zilog
argument_list|,
name|zp
operator|->
name|z_last_itx
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zfs_get_done
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|vzgd
parameter_list|)
block|{
name|zgd_t
modifier|*
name|zgd
init|=
operator|(
name|zgd_t
operator|*
operator|)
name|vzgd
decl_stmt|;
name|rl_t
modifier|*
name|rl
init|=
name|zgd
operator|->
name|zgd_rl
decl_stmt|;
name|vnode_t
modifier|*
name|vp
init|=
name|ZTOV
argument_list|(
name|rl
operator|->
name|r_zp
argument_list|)
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|rl
operator|->
name|r_zp
operator|->
name|z_zfsvfs
operator|->
name|z_os
decl_stmt|;
name|int
name|vfslocked
decl_stmt|;
name|vfslocked
operator|=
name|VFS_LOCK_GIANT
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|vzgd
argument_list|)
expr_stmt|;
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
comment|/* 	 * Release the vnode asynchronously as we currently have the 	 * txg stopped from syncing. 	 */
name|VN_RELE_ASYNC
argument_list|(
name|vp
argument_list|,
name|dsl_pool_vnrele_taskq
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|zil_add_block
argument_list|(
name|zgd
operator|->
name|zgd_zilog
argument_list|,
name|zgd
operator|->
name|zgd_bp
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zgd
argument_list|,
sizeof|sizeof
argument_list|(
name|zgd_t
argument_list|)
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get data to generate a TX_WRITE intent log record.  */
end_comment

begin_function
name|int
name|zfs_get_data
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|lr_write_t
modifier|*
name|lr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zfsvfs
operator|->
name|z_os
decl_stmt|;
name|znode_t
modifier|*
name|zp
decl_stmt|;
name|uint64_t
name|off
init|=
name|lr
operator|->
name|lr_offset
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|zgd_t
modifier|*
name|zgd
decl_stmt|;
name|int
name|dlen
init|=
name|lr
operator|->
name|lr_length
decl_stmt|;
comment|/* length of user data */
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dlen
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Nothing to do if the file has been removed 	 */
if|if
condition|(
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
operator|&
name|zp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|zp
operator|->
name|z_unlinked
condition|)
block|{
comment|/* 		 * Release the vnode asynchronously as we currently have the 		 * txg stopped from syncing. 		 */
name|VN_RELE_ASYNC
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|dsl_pool_vnrele_taskq
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* 	 * Write records come in two flavors: immediate and indirect. 	 * For small writes it's cheaper to store the data with the 	 * log record (immediate); for large writes it's cheaper to 	 * sync the data and get a pointer to it (indirect) so that 	 * we don't have to write the data twice. 	 */
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
comment|/* immediate write */
name|rl
operator|=
name|zfs_range_lock
argument_list|(
name|zp
argument_list|,
name|off
argument_list|,
name|dlen
argument_list|,
name|RL_READER
argument_list|)
expr_stmt|;
comment|/* test for truncation needs to be done while range locked */
if|if
condition|(
name|off
operator|>=
name|zp
operator|->
name|z_phys
operator|->
name|zp_size
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_read
argument_list|(
name|os
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|off
argument_list|,
name|dlen
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* indirect write */
name|uint64_t
name|boff
decl_stmt|;
comment|/* block starting offset */
comment|/* 		 * Have to lock the whole block to ensure when it's 		 * written out and it's checksum is being calculated 		 * that no one can change the data. We need to re-check 		 * blocksize after we get the lock in case it's changed! 		 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ISP2
argument_list|(
name|zp
operator|->
name|z_blksz
argument_list|)
condition|)
block|{
name|boff
operator|=
name|P2ALIGN_TYPED
argument_list|(
name|off
argument_list|,
name|zp
operator|->
name|z_blksz
argument_list|,
name|uint64_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|boff
operator|=
literal|0
expr_stmt|;
block|}
name|dlen
operator|=
name|zp
operator|->
name|z_blksz
expr_stmt|;
name|rl
operator|=
name|zfs_range_lock
argument_list|(
name|zp
argument_list|,
name|boff
argument_list|,
name|dlen
argument_list|,
name|RL_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_blksz
operator|==
name|dlen
condition|)
break|break;
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
block|}
comment|/* test for truncation needs to be done while range locked */
if|if
condition|(
name|off
operator|>=
name|zp
operator|->
name|z_phys
operator|->
name|zp_size
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|zgd
operator|=
operator|(
name|zgd_t
operator|*
operator|)
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zgd_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zgd
operator|->
name|zgd_rl
operator|=
name|rl
expr_stmt|;
name|zgd
operator|->
name|zgd_zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
name|zgd
operator|->
name|zgd_bp
operator|=
operator|&
name|lr
operator|->
name|lr_blkptr
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_buf_hold
argument_list|(
name|os
argument_list|,
name|lr
operator|->
name|lr_foid
argument_list|,
name|boff
argument_list|,
name|zgd
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|boff
operator|==
name|db
operator|->
name|db_offset
argument_list|)
expr_stmt|;
name|lr
operator|->
name|lr_blkoff
operator|=
name|off
operator|-
name|boff
expr_stmt|;
name|error
operator|=
name|dmu_sync
argument_list|(
name|zio
argument_list|,
name|db
argument_list|,
operator|&
name|lr
operator|->
name|lr_blkptr
argument_list|,
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txg
argument_list|,
name|zfs_get_done
argument_list|,
name|zgd
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|error
operator|&&
name|error
operator|!=
name|EINPROGRESS
operator|)
operator|||
name|lr
operator|->
name|lr_length
operator|<=
name|zp
operator|->
name|z_blksz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|zil_add_block
argument_list|(
name|zfsvfs
operator|->
name|z_log
argument_list|,
operator|&
name|lr
operator|->
name|lr_blkptr
argument_list|)
expr_stmt|;
comment|/* 		 * If we get EINPROGRESS, then we need to wait for a 		 * write IO initiated by dmu_sync() to complete before 		 * we can release this dbuf.  We will finish everything 		 * up in the zfs_get_done() callback. 		 */
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|zgd
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zgd
argument_list|,
sizeof|sizeof
argument_list|(
name|zgd_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
comment|/* 	 * Release the vnode asynchronously as we currently have the 	 * txg stopped from syncing. 	 */
name|VN_RELE_ASYNC
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|dsl_pool_vnrele_taskq
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_access
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|flag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|V_ACE_MASK
condition|)
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|mode
argument_list|,
name|flag
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|zfs_zaccess_rwx
argument_list|(
name|zp
argument_list|,
name|mode
argument_list|,
name|flag
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup an entry in a directory, or an extended attribute directory.  * If it exists, return a held vnode reference for it.  *  *	IN:	dvp	- vnode of directory to search.  *		nm	- name of entry to lookup.  *		pnp	- full pathname to lookup [UNUSED].  *		flags	- LOOKUP_XATTR set if looking for an attribute.  *		rdir	- root directory vnode [UNUSED].  *		cr	- credentials of caller.  *		ct	- caller context  *		direntflags - directory lookup flags  *		realpnp - returned pathname.  *  *	OUT:	vpp	- vnode of located entry, NULL if not found.  *  *	RETURN:	0 if success  *		error code if failure  *  * Timestamps:  *	NA  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_lookup
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|nm
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|struct
name|componentname
modifier|*
name|cnp
parameter_list|,
name|int
name|nameiop
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|kthread_t
modifier|*
name|td
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|znode_t
modifier|*
name|zdp
init|=
name|VTOZ
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zdp
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
modifier|*
name|direntflags
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|realpnp
init|=
name|NULL
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zdp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_XATTR
condition|)
block|{
ifdef|#
directive|ifdef
name|TODO
comment|/* 		 * If the xattr property is off, refuse the lookup request. 		 */
if|if
condition|(
operator|!
operator|(
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&
name|VFS_XATTR
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* 		 * We don't allow recursive attributes.. 		 * Maybe someday we will. 		 */
if|if
condition|(
name|zdp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_XATTR
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|=
name|zfs_get_xattrdir
argument_list|(
name|VTOZ
argument_list|(
name|dvp
argument_list|)
argument_list|,
name|vpp
argument_list|,
name|cr
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * Do we have permission to get into attribute directory? 		 */
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|VTOZ
argument_list|(
operator|*
name|vpp
argument_list|)
argument_list|,
name|ACE_EXECUTE
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
condition|)
block|{
name|VN_RELE
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|dvp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTDIR
operator|)
return|;
block|}
comment|/* 	 * Check accessibility of directory. 	 */
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|zdp
argument_list|,
name|ACE_EXECUTE
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|zfsvfs
operator|->
name|z_utf8
operator|&&
name|u8_validate
argument_list|(
name|nm
argument_list|,
name|strlen
argument_list|(
name|nm
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|U8_VALIDATE_ENTIRE
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EILSEQ
operator|)
return|;
block|}
name|error
operator|=
name|zfs_dirlook
argument_list|(
name|zdp
argument_list|,
name|nm
argument_list|,
name|vpp
argument_list|,
name|flags
argument_list|,
name|direntflags
argument_list|,
name|realpnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Convert device special files 		 */
if|if
condition|(
name|IS_DEVVP
argument_list|(
operator|*
name|vpp
argument_list|)
condition|)
block|{
name|vnode_t
modifier|*
name|svp
decl_stmt|;
name|svp
operator|=
name|specvp
argument_list|(
operator|*
name|vpp
argument_list|,
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_rdev
argument_list|,
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_type
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|svp
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOSYS
expr_stmt|;
else|else
operator|*
name|vpp
operator|=
name|svp
expr_stmt|;
block|}
block|}
comment|/* Translate errors and add SAVENAME when needed. */
if|if
condition|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
condition|)
block|{
switch|switch
condition|(
name|nameiop
condition|)
block|{
case|case
name|CREATE
case|:
case|case
name|RENAME
case|:
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
block|{
name|error
operator|=
name|EJUSTRETURN
expr_stmt|;
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
name|DELETE
case|:
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|cnp
operator|->
name|cn_flags
operator||=
name|SAVENAME
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|nm
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|||
name|nm
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|)
condition|)
block|{
name|int
name|ltype
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISDOTDOT
condition|)
block|{
name|ltype
operator|=
name|VOP_ISLOCKED
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|dvp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|vn_lock
argument_list|(
operator|*
name|vpp
argument_list|,
name|cnp
operator|->
name|cn_lkflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISDOTDOT
condition|)
name|vn_lock
argument_list|(
name|dvp
argument_list|,
name|ltype
operator||
name|LK_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|VN_RELE
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|FREEBSD_NAMECACHE
comment|/* 	 * Insert name into cache (as non-existent) if appropriate. 	 */
if|if
condition|(
name|error
operator|==
name|ENOENT
operator|&&
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
operator|)
operator|&&
name|nameiop
operator|!=
name|CREATE
condition|)
name|cache_enter
argument_list|(
name|dvp
argument_list|,
operator|*
name|vpp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
comment|/* 	 * Insert name into cache if appropriate. 	 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|MAKEENTRY
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|cnp
operator|->
name|cn_flags
operator|&
name|ISLASTCN
operator|)
operator|||
operator|(
name|nameiop
operator|!=
name|DELETE
operator|&&
name|nameiop
operator|!=
name|RENAME
operator|)
condition|)
block|{
name|cache_enter
argument_list|(
name|dvp
argument_list|,
operator|*
name|vpp
argument_list|,
name|cnp
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt to create a new entry in a directory.  If the entry  * already exists, truncate the file if permissible, else return  * an error.  Return the vp of the created or trunc'd file.  *  *	IN:	dvp	- vnode of directory to put new file entry in.  *		name	- name of new file entry.  *		vap	- attributes of new file.  *		excl	- flag indicating exclusive or non-exclusive mode.  *		mode	- mode to open file with.  *		cr	- credentials of caller.  *		flag	- large file flag [UNUSED].  *		ct	- caller context  *		vsecp 	- ACL to be set  *  *	OUT:	vpp	- vnode of created or trunc'd entry.  *  *	RETURN:	0 if success  *		error code if failure  *  * Timestamps:  *	dvp - ctime|mtime updated if new entry created  *	 vp - ctime|mtime always, atime if new  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_create
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|int
name|excl
parameter_list|,
name|int
name|mode
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|kthread_t
modifier|*
name|td
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
decl_stmt|,
modifier|*
name|dzp
init|=
name|VTOZ
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|zfs_dirlock_t
modifier|*
name|dl
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|zfs_acl_t
modifier|*
name|aclp
init|=
name|NULL
decl_stmt|;
name|zfs_fuid_info_t
modifier|*
name|fuidp
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|vsecp
init|=
name|NULL
decl_stmt|;
name|int
name|flag
init|=
literal|0
decl_stmt|;
comment|/* 	 * If we have an ephemeral id, ACL, or XVATTR then 	 * make sure file system is at proper version 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_use_fuids
operator|==
name|B_FALSE
operator|&&
operator|(
name|vsecp
operator|||
operator|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_XVATTR
operator|)
operator|||
name|IS_EPHEMERAL
argument_list|(
name|crgetuid
argument_list|(
name|cr
argument_list|)
argument_list|)
operator|||
name|IS_EPHEMERAL
argument_list|(
name|crgetgid
argument_list|(
name|cr
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|dzp
argument_list|)
expr_stmt|;
name|os
operator|=
name|zfsvfs
operator|->
name|z_os
expr_stmt|;
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_utf8
operator|&&
name|u8_validate
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|U8_VALIDATE_ENTIRE
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EILSEQ
operator|)
return|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_XVATTR
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|secpolicy_xvattr
argument_list|(
operator|(
name|xvattr_t
operator|*
operator|)
name|vap
argument_list|,
name|crgetuid
argument_list|(
name|cr
argument_list|)
argument_list|,
name|cr
argument_list|,
name|vap
operator|->
name|va_type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|top
label|:
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|vap
operator|->
name|va_mode
operator|&
name|S_ISVTX
operator|)
operator|&&
name|secpolicy_vnode_stky_modify
argument_list|(
name|cr
argument_list|)
condition|)
name|vap
operator|->
name|va_mode
operator|&=
operator|~
name|S_ISVTX
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
block|{
comment|/* 		 * Null component name refers to the directory itself. 		 */
name|VN_HOLD
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|zp
operator|=
name|dzp
expr_stmt|;
name|dl
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* possible VN_HOLD(zp) */
name|int
name|zflg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flag
operator|&
name|FIGNORECASE
condition|)
name|zflg
operator||=
name|ZCILOOK
expr_stmt|;
name|error
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|dl
argument_list|,
name|dzp
argument_list|,
name|name
argument_list|,
operator|&
name|zp
argument_list|,
name|zflg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
name|error
operator|=
name|EISDIR
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|aclp
condition|)
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
if|if
condition|(
name|vsecp
operator|&&
name|aclp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|zfs_vsec_2_aclp
argument_list|(
name|zfsvfs
argument_list|,
name|vap
operator|->
name|va_type
argument_list|,
name|vsecp
argument_list|,
operator|&
name|aclp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|dl
condition|)
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
if|if
condition|(
name|zp
operator|==
name|NULL
condition|)
block|{
name|uint64_t
name|txtype
decl_stmt|;
comment|/* 		 * Create a new file object and update the directory 		 * to reference it. 		 */
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|dzp
argument_list|,
name|ACE_ADD_FILE
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* 		 * We only support the creation of regular files in 		 * extended attribute directories. 		 */
if|if
condition|(
operator|(
name|dzp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_XATTR
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_type
operator|!=
name|VREG
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|aclp
operator|&&
name|aclp
operator|->
name|z_has_fuids
operator|)
operator|||
name|IS_EPHEMERAL
argument_list|(
name|crgetuid
argument_list|(
name|cr
argument_list|)
argument_list|)
operator|||
name|IS_EPHEMERAL
argument_list|(
name|crgetgid
argument_list|(
name|cr
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|zfsvfs
operator|->
name|z_fuid_obj
operator|==
literal|0
condition|)
block|{
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|FUID_SIZE_ESTIMATE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_fuid_obj
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_fuid_obj
argument_list|,
literal|0
argument_list|,
name|FUID_SIZE_ESTIMATE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|TRUE
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dzp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_INHERIT_ACE
operator|)
operator|||
name|aclp
condition|)
block|{
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_assign
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|&&
name|zfsvfs
operator|->
name|z_assign
operator|==
name|TXG_NOWAIT
condition|)
block|{
name|dmu_tx_wait
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|aclp
condition|)
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|zfs_mknode
argument_list|(
name|dzp
argument_list|,
name|vap
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
literal|0
argument_list|,
operator|&
name|zp
argument_list|,
literal|0
argument_list|,
name|aclp
argument_list|,
operator|&
name|fuidp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_link_create
argument_list|(
name|dl
argument_list|,
name|zp
argument_list|,
name|tx
argument_list|,
name|ZNEW
argument_list|)
expr_stmt|;
name|txtype
operator|=
name|zfs_log_create_txtype
argument_list|(
name|Z_FILE
argument_list|,
name|vsecp
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|FIGNORECASE
condition|)
name|txtype
operator||=
name|TX_CI
expr_stmt|;
name|zfs_log_create
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|txtype
argument_list|,
name|dzp
argument_list|,
name|zp
argument_list|,
name|name
argument_list|,
name|vsecp
argument_list|,
name|fuidp
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuidp
condition|)
name|zfs_fuid_info_free
argument_list|(
name|fuidp
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|aflags
init|=
operator|(
name|flag
operator|&
name|FAPPEND
operator|)
condition|?
name|V_APPEND
else|:
literal|0
decl_stmt|;
comment|/* 		 * A directory entry already exists for this name. 		 */
comment|/* 		 * Can't truncate an existing file if in exclusive mode. 		 */
if|if
condition|(
name|excl
operator|==
name|EXCL
condition|)
block|{
name|error
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * Can't open a directory for writing. 		 */
if|if
condition|(
operator|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
operator|)
operator|&&
operator|(
name|mode
operator|&
name|S_IWRITE
operator|)
condition|)
block|{
name|error
operator|=
name|EISDIR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * Verify requested access to file. 		 */
if|if
condition|(
name|mode
operator|&&
operator|(
name|error
operator|=
name|zfs_zaccess_rwx
argument_list|(
name|zp
argument_list|,
name|mode
argument_list|,
name|aflags
argument_list|,
name|cr
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|dzp
operator|->
name|z_seq
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Truncate regular files if requested. 		 */
if|if
condition|(
operator|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|==
name|VREG
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_SIZE
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_size
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* we can't hold any locks when calling zfs_freesp() */
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|dl
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|zfs_freesp
argument_list|(
name|zp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|vnevent_create
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|out
label|:
if|if
condition|(
name|dl
condition|)
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|zp
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|vpp
operator|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
expr_stmt|;
comment|/* 		 * If vnode is for a device return a specfs vnode instead. 		 */
if|if
condition|(
name|IS_DEVVP
argument_list|(
operator|*
name|vpp
argument_list|)
condition|)
block|{
name|struct
name|vnode
modifier|*
name|svp
decl_stmt|;
name|svp
operator|=
name|specvp
argument_list|(
operator|*
name|vpp
argument_list|,
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_rdev
argument_list|,
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_type
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|svp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOSYS
expr_stmt|;
block|}
operator|*
name|vpp
operator|=
name|svp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|aclp
condition|)
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove an entry from a directory.  *  *	IN:	dvp	- vnode of directory to remove entry from.  *		name	- name of entry to remove.  *		cr	- credentials of caller.  *		ct	- caller context  *		flags	- case flags  *  *	RETURN:	0 if success  *		error code if failure  *  * Timestamps:  *	dvp - ctime|mtime  *	 vp - ctime (if nlink> 0)  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_remove
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
decl_stmt|,
modifier|*
name|dzp
init|=
name|VTOZ
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|znode_t
modifier|*
name|xzp
init|=
name|NULL
decl_stmt|;
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|uint64_t
name|acl_obj
decl_stmt|,
name|xattr_obj
decl_stmt|;
name|zfs_dirlock_t
modifier|*
name|dl
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|boolean_t
name|may_delete_now
decl_stmt|,
name|delete_now
init|=
name|FALSE
decl_stmt|;
name|boolean_t
name|unlinked
decl_stmt|,
name|toobig
init|=
name|FALSE
decl_stmt|;
name|uint64_t
name|txtype
decl_stmt|;
name|pathname_t
modifier|*
name|realnmp
init|=
name|NULL
decl_stmt|;
name|pathname_t
name|realnm
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|zflg
init|=
name|ZEXISTS
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|dzp
argument_list|)
expr_stmt|;
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
condition|)
block|{
name|zflg
operator||=
name|ZCILOOK
expr_stmt|;
name|pn_alloc
argument_list|(
operator|&
name|realnm
argument_list|)
expr_stmt|;
name|realnmp
operator|=
operator|&
name|realnm
expr_stmt|;
block|}
name|top
label|:
comment|/* 	 * Attempt to lock directory; fail if entry doesn't exist. 	 */
if|if
condition|(
name|error
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|dl
argument_list|,
name|dzp
argument_list|,
name|name
argument_list|,
operator|&
name|zp
argument_list|,
name|zflg
argument_list|,
name|NULL
argument_list|,
name|realnmp
argument_list|)
condition|)
block|{
if|if
condition|(
name|realnmp
condition|)
name|pn_free
argument_list|(
name|realnmp
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vp
operator|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|zfs_zaccess_delete
argument_list|(
name|dzp
argument_list|,
name|zp
argument_list|,
name|cr
argument_list|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Need to use rmdir for removing directories. 	 */
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vnevent_remove
argument_list|(
name|vp
argument_list|,
name|dvp
argument_list|,
name|name
argument_list|,
name|ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|realnmp
condition|)
name|dnlc_remove
argument_list|(
name|dvp
argument_list|,
name|realnmp
operator|->
name|pn_buf
argument_list|)
expr_stmt|;
else|else
name|dnlc_remove
argument_list|(
name|dvp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|may_delete_now
operator|=
name|FALSE
expr_stmt|;
comment|/* 	 * We may delete the znode now, or we may put it in the unlinked set; 	 * it depends on whether we're the last link, and on whether there are 	 * other holds on the vnode.  So we dmu_tx_hold() the right things to 	 * allow for either case. 	 */
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|FALSE
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|may_delete_now
condition|)
block|{
name|toobig
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_size
operator|>
name|zp
operator|->
name|z_blksz
operator|*
name|DMU_MAX_DELETEBLKCNT
expr_stmt|;
comment|/* if the file is too big, only hold_free a token amount */
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
literal|0
argument_list|,
operator|(
name|toobig
condition|?
name|DMU_MAX_ACCESS
else|:
name|DMU_OBJECT_END
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* are there any extended attributes? */
if|if
condition|(
operator|(
name|xattr_obj
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_xattr
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* XXX - do we need this if we are deleting? */
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|xattr_obj
argument_list|)
expr_stmt|;
block|}
comment|/* are there any additional acls */
if|if
condition|(
operator|(
name|acl_obj
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
operator|)
operator|!=
literal|0
operator|&&
name|may_delete_now
condition|)
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|acl_obj
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
comment|/* charge as an update -- would be nice not to charge at all */
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_unlinkedobj
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_assign
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|&&
name|zfsvfs
operator|->
name|z_assign
operator|==
name|TXG_NOWAIT
condition|)
block|{
name|dmu_tx_wait
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
if|if
condition|(
name|realnmp
condition|)
name|pn_free
argument_list|(
name|realnmp
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Remove the directory entry. 	 */
name|error
operator|=
name|zfs_link_destroy
argument_list|(
name|dl
argument_list|,
name|zp
argument_list|,
name|tx
argument_list|,
name|zflg
argument_list|,
operator|&
name|unlinked
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
literal|0
operator|&&
name|unlinked
condition|)
block|{
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|delete_now
operator|=
name|may_delete_now
operator|&&
operator|!
name|toobig
operator|&&
name|vp
operator|->
name|v_count
operator|==
literal|1
operator|&&
operator|!
name|vn_has_cached_data
argument_list|(
name|vp
argument_list|)
operator|&&
name|zp
operator|->
name|z_phys
operator|->
name|zp_xattr
operator|==
name|xattr_obj
operator|&&
name|zp
operator|->
name|z_phys
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
operator|==
name|acl_obj
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|delete_now
condition|)
block|{
if|if
condition|(
name|zp
operator|->
name|z_phys
operator|->
name|zp_xattr
condition|)
block|{
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|zp
operator|->
name|z_phys
operator|->
name|zp_xattr
argument_list|,
operator|&
name|xzp
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|xzp
operator|->
name|z_phys
operator|->
name|zp_links
argument_list|,
operator|==
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|xzp
operator|->
name|z_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|xzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|xzp
operator|->
name|z_unlinked
operator|=
literal|1
expr_stmt|;
name|xzp
operator|->
name|z_phys
operator|->
name|zp_links
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|xzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|zfs_unlinked_add
argument_list|(
name|xzp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_phys
operator|->
name|zp_xattr
operator|=
literal|0
expr_stmt|;
comment|/* probably unnecessary */
block|}
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_count
operator|--
expr_stmt|;
name|ASSERT3U
argument_list|(
name|vp
operator|->
name|v_count
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|zfs_znode_delete
argument_list|(
name|zp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unlinked
condition|)
block|{
name|zfs_unlinked_add
argument_list|(
name|zp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|txtype
operator|=
name|TX_REMOVE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
condition|)
name|txtype
operator||=
name|TX_CI
expr_stmt|;
name|zfs_log_remove
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|txtype
argument_list|,
name|dzp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|realnmp
condition|)
name|pn_free
argument_list|(
name|realnmp
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|delete_now
condition|)
block|{
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xzp
condition|)
block|{
comment|/* this rele is delayed to prevent nesting transactions */
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|xzp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new directory and insert it into dvp using the name  * provided.  Return a pointer to the inserted directory.  *  *	IN:	dvp	- vnode of directory to add subdir to.  *		dirname	- name of new directory.  *		vap	- attributes of new directory.  *		cr	- credentials of caller.  *		ct	- caller context  *		vsecp	- ACL to be set  *  *	OUT:	vpp	- vnode of created directory.  *  *	RETURN:	0 if success  *		error code if failure  *  * Timestamps:  *	dvp - ctime|mtime updated  *	 vp - ctime|mtime|atime updated  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_mkdir
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|dirname
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
decl_stmt|,
modifier|*
name|dzp
init|=
name|VTOZ
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|zfs_dirlock_t
modifier|*
name|dl
decl_stmt|;
name|uint64_t
name|txtype
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|zfs_acl_t
modifier|*
name|aclp
init|=
name|NULL
decl_stmt|;
name|zfs_fuid_info_t
modifier|*
name|fuidp
init|=
name|NULL
decl_stmt|;
name|int
name|zf
init|=
name|ZNEW
decl_stmt|;
name|ASSERT
argument_list|(
name|vap
operator|->
name|va_type
operator|==
name|VDIR
argument_list|)
expr_stmt|;
comment|/* 	 * If we have an ephemeral id, ACL, or XVATTR then 	 * make sure file system is at proper version 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_use_fuids
operator|==
name|B_FALSE
operator|&&
operator|(
name|vsecp
operator|||
operator|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_XVATTR
operator|)
operator|||
name|IS_EPHEMERAL
argument_list|(
name|crgetuid
argument_list|(
name|cr
argument_list|)
argument_list|)
operator|||
name|IS_EPHEMERAL
argument_list|(
name|crgetgid
argument_list|(
name|cr
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|dzp
argument_list|)
expr_stmt|;
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
if|if
condition|(
name|dzp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_XATTR
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|zfsvfs
operator|->
name|z_utf8
operator|&&
name|u8_validate
argument_list|(
name|dirname
argument_list|,
name|strlen
argument_list|(
name|dirname
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|U8_VALIDATE_ENTIRE
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EILSEQ
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
condition|)
name|zf
operator||=
name|ZCILOOK
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_XVATTR
condition|)
if|if
condition|(
operator|(
name|error
operator|=
name|secpolicy_xvattr
argument_list|(
operator|(
name|xvattr_t
operator|*
operator|)
name|vap
argument_list|,
name|crgetuid
argument_list|(
name|cr
argument_list|)
argument_list|,
name|cr
argument_list|,
name|vap
operator|->
name|va_type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * First make sure the new directory doesn't exist. 	 */
name|top
label|:
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|dl
argument_list|,
name|dzp
argument_list|,
name|dirname
argument_list|,
operator|&
name|zp
argument_list|,
name|zf
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|dzp
argument_list|,
name|ACE_ADD_SUBDIRECTORY
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|vsecp
operator|&&
name|aclp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|zfs_vsec_2_aclp
argument_list|(
name|zfsvfs
argument_list|,
name|vap
operator|->
name|va_type
argument_list|,
name|vsecp
argument_list|,
operator|&
name|aclp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Add a new entry to the directory. 	 */
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|TRUE
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|aclp
operator|&&
name|aclp
operator|->
name|z_has_fuids
operator|)
operator|||
name|IS_EPHEMERAL
argument_list|(
name|crgetuid
argument_list|(
name|cr
argument_list|)
argument_list|)
operator|||
name|IS_EPHEMERAL
argument_list|(
name|crgetgid
argument_list|(
name|cr
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|zfsvfs
operator|->
name|z_fuid_obj
operator|==
literal|0
condition|)
block|{
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|FUID_SIZE_ESTIMATE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_fuid_obj
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_fuid_obj
argument_list|,
literal|0
argument_list|,
name|FUID_SIZE_ESTIMATE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|dzp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_INHERIT_ACE
operator|)
operator|||
name|aclp
condition|)
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_assign
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|&&
name|zfsvfs
operator|->
name|z_assign
operator|==
name|TXG_NOWAIT
condition|)
block|{
name|dmu_tx_wait
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|aclp
condition|)
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Create new node. 	 */
name|zfs_mknode
argument_list|(
name|dzp
argument_list|,
name|vap
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
literal|0
argument_list|,
operator|&
name|zp
argument_list|,
literal|0
argument_list|,
name|aclp
argument_list|,
operator|&
name|fuidp
argument_list|)
expr_stmt|;
if|if
condition|(
name|aclp
condition|)
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
comment|/* 	 * Now put new name in parent dir. 	 */
operator|(
name|void
operator|)
name|zfs_link_create
argument_list|(
name|dl
argument_list|,
name|zp
argument_list|,
name|tx
argument_list|,
name|ZNEW
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|txtype
operator|=
name|zfs_log_create_txtype
argument_list|(
name|Z_DIR
argument_list|,
name|vsecp
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
condition|)
name|txtype
operator||=
name|TX_CI
expr_stmt|;
name|zfs_log_create
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|txtype
argument_list|,
name|dzp
argument_list|,
name|zp
argument_list|,
name|dirname
argument_list|,
name|vsecp
argument_list|,
name|fuidp
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuidp
condition|)
name|zfs_fuid_info_free
argument_list|(
name|fuidp
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a directory subdir entry.  If the current working  * directory is the same as the subdir to be removed, the  * remove will fail.  *  *	IN:	dvp	- vnode of directory to remove from.  *		name	- name of directory to be removed.  *		cwd	- vnode of current working directory.  *		cr	- credentials of caller.  *		ct	- caller context  *		flags	- case flags  *  *	RETURN:	0 if success  *		error code if failure  *  * Timestamps:  *	dvp - ctime|mtime updated  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_rmdir
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|vnode_t
modifier|*
name|cwd
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|znode_t
modifier|*
name|dzp
init|=
name|VTOZ
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|znode_t
modifier|*
name|zp
decl_stmt|;
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|zfs_dirlock_t
modifier|*
name|dl
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|zflg
init|=
name|ZEXISTS
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|dzp
argument_list|)
expr_stmt|;
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
condition|)
name|zflg
operator||=
name|ZCILOOK
expr_stmt|;
name|top
label|:
name|zp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Attempt to lock directory; fail if entry doesn't exist. 	 */
if|if
condition|(
name|error
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|dl
argument_list|,
name|dzp
argument_list|,
name|name
argument_list|,
operator|&
name|zp
argument_list|,
name|zflg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vp
operator|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|zfs_zaccess_delete
argument_list|(
name|dzp
argument_list|,
name|zp
argument_list|,
name|cr
argument_list|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
name|error
operator|=
name|ENOTDIR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|vp
operator|==
name|cwd
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vnevent_rmdir
argument_list|(
name|vp
argument_list|,
name|dvp
argument_list|,
name|name
argument_list|,
name|ct
argument_list|)
expr_stmt|;
comment|/* 	 * Grab a lock on the directory to make sure that noone is 	 * trying to add (or lookup) entries while we are removing it. 	 */
name|rw_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_name_lock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
comment|/* 	 * Grab a lock on the parent pointer to make sure we play well 	 * with the treewalk and directory rename code. 	 */
name|rw_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_parent_lock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|FALSE
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_unlinkedobj
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_assign
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_parent_lock
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_name_lock
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|&&
name|zfsvfs
operator|->
name|z_assign
operator|==
name|TXG_NOWAIT
condition|)
block|{
name|dmu_tx_wait
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|FREEBSD_NAMECACHE
name|cache_purge
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|zfs_link_destroy
argument_list|(
name|dl
argument_list|,
name|zp
argument_list|,
name|tx
argument_list|,
name|zflg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|txtype
init|=
name|TX_RMDIR
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
condition|)
name|txtype
operator||=
name|TX_CI
expr_stmt|;
name|zfs_log_remove
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|txtype
argument_list|,
name|dzp
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_parent_lock
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_name_lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FREEBSD_NAMECACHE
name|cache_purge
argument_list|(
name|vp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|out
label|:
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read as many directory entries as will fit into the provided  * buffer from the given directory cursor position (specified in  * the uio structure.  *  *	IN:	vp	- vnode of directory to read.  *		uio	- structure supplying read location, range info,  *			  and return buffer.  *		cr	- credentials of caller.  *		ct	- caller context  *		flags	- case flags  *  *	OUT:	uio	- updated offset and range, buffer filled.  *		eofp	- set to true if end-of-file detected.  *  *	RETURN:	0 if success  *		error code if failure  *  * Timestamps:  *	vp - atime updated  *  * Note that the low 4 bits of the cookie returned by zap is always zero.  * This allows us to use the low range for "special" directory entries:  * We use 0 for '.', and 1 for '..'.  If this is the root of the filesystem,  * we use the offset 2 for the '.zfs' directory.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_readdir
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|,
name|int
modifier|*
name|ncookies
parameter_list|,
name|u_long
modifier|*
modifier|*
name|cookies
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|iovec_t
modifier|*
name|iovp
decl_stmt|;
name|edirent_t
modifier|*
name|eodp
decl_stmt|;
name|dirent64_t
modifier|*
name|odp
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|caddr_t
name|outbuf
decl_stmt|;
name|size_t
name|bufsize
decl_stmt|;
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|zap
decl_stmt|;
name|uint_t
name|bytes_wanted
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|;
comment|/* must be unsigned; checks for< 1 */
name|int
name|local_eof
decl_stmt|;
name|int
name|outcount
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint8_t
name|prefetch
decl_stmt|;
name|boolean_t
name|check_sysattrs
decl_stmt|;
name|uint8_t
name|type
decl_stmt|;
name|int
name|ncooks
decl_stmt|;
name|u_long
modifier|*
name|cooks
init|=
name|NULL
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
comment|/* 	 * If we are not given an eof variable, 	 * use a local one. 	 */
if|if
condition|(
name|eofp
operator|==
name|NULL
condition|)
name|eofp
operator|=
operator|&
name|local_eof
expr_stmt|;
comment|/* 	 * Check for valid iov_len. 	 */
if|if
condition|(
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|<=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Quit if directory has been removed (posix) 	 */
if|if
condition|(
operator|(
operator|*
name|eofp
operator|=
name|zp
operator|->
name|z_unlinked
operator|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|os
operator|=
name|zfsvfs
operator|->
name|z_os
expr_stmt|;
name|offset
operator|=
name|uio
operator|->
name|uio_loffset
expr_stmt|;
name|prefetch
operator|=
name|zp
operator|->
name|z_zn_prefetch
expr_stmt|;
comment|/* 	 * Initialize the iterator cursor. 	 */
if|if
condition|(
name|offset
operator|<=
literal|3
condition|)
block|{
comment|/* 		 * Start iteration from the beginning of the directory. 		 */
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The offset is a serialized cursor. 		 */
name|zap_cursor_init_serialized
argument_list|(
operator|&
name|zc
argument_list|,
name|os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Get space to change directory entries into fs independent format. 	 */
name|iovp
operator|=
name|uio
operator|->
name|uio_iov
expr_stmt|;
name|bytes_wanted
operator|=
name|iovp
operator|->
name|iov_len
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_segflg
operator|!=
name|UIO_SYSSPACE
operator|||
name|uio
operator|->
name|uio_iovcnt
operator|!=
literal|1
condition|)
block|{
name|bufsize
operator|=
name|bytes_wanted
expr_stmt|;
name|outbuf
operator|=
name|kmem_alloc
argument_list|(
name|bufsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|odp
operator|=
operator|(
expr|struct
name|dirent64
operator|*
operator|)
name|outbuf
expr_stmt|;
block|}
else|else
block|{
name|bufsize
operator|=
name|bytes_wanted
expr_stmt|;
name|odp
operator|=
operator|(
expr|struct
name|dirent64
operator|*
operator|)
name|iovp
operator|->
name|iov_base
expr_stmt|;
block|}
name|eodp
operator|=
operator|(
expr|struct
name|edirent
operator|*
operator|)
name|odp
expr_stmt|;
if|if
condition|(
name|ncookies
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Minimum entry size is dirent size and 1 byte for a file name. 		 */
name|ncooks
operator|=
name|uio
operator|->
name|uio_resid
operator|/
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
operator|(
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|NULL
operator|)
operator|->
name|d_name
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|cooks
operator|=
name|malloc
argument_list|(
name|ncooks
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
operator|*
name|cookies
operator|=
name|cooks
expr_stmt|;
operator|*
name|ncookies
operator|=
name|ncooks
expr_stmt|;
block|}
comment|/* 	 * If this VFS supports the system attribute view interface; and 	 * we're looking at an extended attribute directory; and we care 	 * about normalization conflicts on this vfs; then we must check 	 * for normalization conflicts with the sysattr name space. 	 */
ifdef|#
directive|ifdef
name|TODO
name|check_sysattrs
operator|=
name|vfs_has_feature
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_SYSATTR_VIEWS
argument_list|)
operator|&&
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|V_XATTRDIR
operator|)
operator|&&
name|zfsvfs
operator|->
name|z_norm
operator|&&
operator|(
name|flags
operator|&
name|V_RDDIR_ENTFLAGS
operator|)
expr_stmt|;
else|#
directive|else
name|check_sysattrs
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Transform to file-system independent format 	 */
name|outcount
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|outcount
operator|<
name|bytes_wanted
condition|)
block|{
name|ino64_t
name|objnum
decl_stmt|;
name|ushort_t
name|reclen
decl_stmt|;
name|off64_t
modifier|*
name|next
decl_stmt|;
comment|/* 		 * Special case `.', `..', and `.zfs'. 		 */
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zap
operator|.
name|za_name
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|zap
operator|.
name|za_normalization_conflict
operator|=
literal|0
expr_stmt|;
name|objnum
operator|=
name|zp
operator|->
name|z_id
expr_stmt|;
name|type
operator|=
name|DT_DIR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|==
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zap
operator|.
name|za_name
argument_list|,
literal|".."
argument_list|)
expr_stmt|;
name|zap
operator|.
name|za_normalization_conflict
operator|=
literal|0
expr_stmt|;
name|objnum
operator|=
name|zp
operator|->
name|z_phys
operator|->
name|zp_parent
expr_stmt|;
name|type
operator|=
name|DT_DIR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|==
literal|2
operator|&&
name|zfs_show_ctldir
argument_list|(
name|zp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zap
operator|.
name|za_name
argument_list|,
name|ZFS_CTLDIR_NAME
argument_list|)
expr_stmt|;
name|zap
operator|.
name|za_normalization_conflict
operator|=
literal|0
expr_stmt|;
name|objnum
operator|=
name|ZFSCTL_INO_ROOT
expr_stmt|;
name|type
operator|=
name|DT_DIR
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Grab next entry. 			 */
if|if
condition|(
name|error
operator|=
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|zap
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|eofp
operator|=
operator|(
name|error
operator|==
name|ENOENT
operator|)
operator|)
operator|!=
literal|0
condition|)
break|break;
else|else
goto|goto
name|update
goto|;
block|}
if|if
condition|(
name|zap
operator|.
name|za_integer_length
operator|!=
literal|8
operator|||
name|zap
operator|.
name|za_num_integers
operator|!=
literal|1
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"zap_readdir: bad directory "
literal|"entry, obj = %lld, offset = %lld\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|zp
operator|->
name|z_id
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|offset
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|update
goto|;
block|}
name|objnum
operator|=
name|ZFS_DIRENT_OBJ
argument_list|(
name|zap
operator|.
name|za_first_integer
argument_list|)
expr_stmt|;
comment|/* 			 * MacOS X can extract the object type here such as: 			 * uint8_t type = ZFS_DIRENT_TYPE(zap.za_first_integer); 			 */
name|type
operator|=
name|ZFS_DIRENT_TYPE
argument_list|(
name|zap
operator|.
name|za_first_integer
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_sysattrs
operator|&&
operator|!
name|zap
operator|.
name|za_normalization_conflict
condition|)
block|{
ifdef|#
directive|ifdef
name|TODO
name|zap
operator|.
name|za_normalization_conflict
operator|=
name|xattr_sysattr_casechk
argument_list|(
name|zap
operator|.
name|za_name
argument_list|)
expr_stmt|;
else|#
directive|else
name|panic
argument_list|(
literal|"%s:%u: TODO"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|V_RDDIR_ENTFLAGS
condition|)
name|reclen
operator|=
name|EDIRENT_RECLEN
argument_list|(
name|strlen
argument_list|(
name|zap
operator|.
name|za_name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|reclen
operator|=
name|DIRENT64_RECLEN
argument_list|(
name|strlen
argument_list|(
name|zap
operator|.
name|za_name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Will this entry fit in the buffer? 		 */
if|if
condition|(
name|outcount
operator|+
name|reclen
operator|>
name|bufsize
condition|)
block|{
comment|/* 			 * Did we manage to fit anything in the buffer? 			 */
if|if
condition|(
operator|!
name|outcount
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|update
goto|;
block|}
break|break;
block|}
if|if
condition|(
name|flags
operator|&
name|V_RDDIR_ENTFLAGS
condition|)
block|{
comment|/* 			 * Add extended flag entry: 			 */
name|eodp
operator|->
name|ed_ino
operator|=
name|objnum
expr_stmt|;
name|eodp
operator|->
name|ed_reclen
operator|=
name|reclen
expr_stmt|;
comment|/* NOTE: ed_off is the offset for the *next* entry */
name|next
operator|=
operator|&
operator|(
name|eodp
operator|->
name|ed_off
operator|)
expr_stmt|;
name|eodp
operator|->
name|ed_eflags
operator|=
name|zap
operator|.
name|za_normalization_conflict
condition|?
name|ED_CASE_CONFLICT
else|:
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|eodp
operator|->
name|ed_name
argument_list|,
name|zap
operator|.
name|za_name
argument_list|,
name|EDIRENT_NAMELEN
argument_list|(
name|reclen
argument_list|)
argument_list|)
expr_stmt|;
name|eodp
operator|=
operator|(
name|edirent_t
operator|*
operator|)
operator|(
operator|(
name|intptr_t
operator|)
name|eodp
operator|+
name|reclen
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Add normal entry: 			 */
name|odp
operator|->
name|d_ino
operator|=
name|objnum
expr_stmt|;
name|odp
operator|->
name|d_reclen
operator|=
name|reclen
expr_stmt|;
name|odp
operator|->
name|d_namlen
operator|=
name|strlen
argument_list|(
name|zap
operator|.
name|za_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|odp
operator|->
name|d_name
argument_list|,
name|zap
operator|.
name|za_name
argument_list|,
name|odp
operator|->
name|d_namlen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|odp
operator|->
name|d_type
operator|=
name|type
expr_stmt|;
name|odp
operator|=
operator|(
name|dirent64_t
operator|*
operator|)
operator|(
operator|(
name|intptr_t
operator|)
name|odp
operator|+
name|reclen
operator|)
expr_stmt|;
block|}
name|outcount
operator|+=
name|reclen
expr_stmt|;
name|ASSERT
argument_list|(
name|outcount
operator|<=
name|bufsize
argument_list|)
expr_stmt|;
comment|/* Prefetch znode */
if|if
condition|(
name|prefetch
condition|)
name|dmu_prefetch
argument_list|(
name|os
argument_list|,
name|objnum
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Move to the next entry, fill in the previous offset. 		 */
if|if
condition|(
name|offset
operator|>
literal|2
operator|||
operator|(
name|offset
operator|==
literal|2
operator|&&
operator|!
name|zfs_show_ctldir
argument_list|(
name|zp
argument_list|)
operator|)
condition|)
block|{
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|offset
operator|=
name|zap_cursor_serialize
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cooks
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cooks
operator|++
operator|=
name|offset
expr_stmt|;
name|ncooks
operator|--
expr_stmt|;
name|KASSERT
argument_list|(
name|ncooks
operator|>=
literal|0
argument_list|,
operator|(
literal|"ncookies=%d"
operator|,
name|ncooks
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|zp
operator|->
name|z_zn_prefetch
operator|=
name|B_FALSE
expr_stmt|;
comment|/* a lookup will re-enable pre-fetching */
comment|/* Subtract unused cookies */
if|if
condition|(
name|ncookies
operator|!=
name|NULL
condition|)
operator|*
name|ncookies
operator|-=
name|ncooks
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_segflg
operator|==
name|UIO_SYSSPACE
operator|&&
name|uio
operator|->
name|uio_iovcnt
operator|==
literal|1
condition|)
block|{
name|iovp
operator|->
name|iov_base
operator|+=
name|outcount
expr_stmt|;
name|iovp
operator|->
name|iov_len
operator|-=
name|outcount
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|-=
name|outcount
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|=
name|uiomove
argument_list|(
name|outbuf
argument_list|,
operator|(
name|long
operator|)
name|outcount
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
condition|)
block|{
comment|/* 		 * Reset the pointer. 		 */
name|offset
operator|=
name|uio
operator|->
name|uio_loffset
expr_stmt|;
block|}
name|update
label|:
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_segflg
operator|!=
name|UIO_SYSSPACE
operator|||
name|uio
operator|->
name|uio_iovcnt
operator|!=
literal|1
condition|)
name|kmem_free
argument_list|(
name|outbuf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
literal|0
expr_stmt|;
name|ZFS_ACCESSTIME_STAMP
argument_list|(
name|zfsvfs
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_loffset
operator|=
name|offset
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|cookies
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|*
name|cookies
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
operator|*
name|cookies
operator|=
name|NULL
expr_stmt|;
operator|*
name|ncookies
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|ulong_t
name|zfs_fsync_sync_cnt
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|zfs_fsync
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|syncflag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
operator|(
name|void
operator|)
name|tsd_set
argument_list|(
name|zfs_fsyncer_key
argument_list|,
operator|(
name|void
operator|*
operator|)
name|zfs_fsync_sync_cnt
argument_list|)
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|zil_commit
argument_list|(
name|zfsvfs
operator|->
name|z_log
argument_list|,
name|zp
operator|->
name|z_last_itx
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the requested file attributes and place them in the provided  * vattr structure.  *  *	IN:	vp	- vnode of file.  *		vap	- va_mask identifies requested attributes.  *			  If AT_XVATTR set, then optional attrs are requested  *		flags	- ATTR_NOACLCHECK (CIFS server context)  *		cr	- credentials of caller.  *		ct	- caller context  *  *	OUT:	vap	- attribute values.  *  *	RETURN:	0 (always succeeds)  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_getattr
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|znode_phys_t
modifier|*
name|pzp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint32_t
name|blksize
decl_stmt|;
name|u_longlong_t
name|nblocks
decl_stmt|;
name|uint64_t
name|links
decl_stmt|;
name|xvattr_t
modifier|*
name|xvap
init|=
operator|(
name|xvattr_t
operator|*
operator|)
name|vap
decl_stmt|;
comment|/* vap may be an xvattr_t * */
name|xoptattr_t
modifier|*
name|xoap
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|skipaclchk
init|=
operator|(
name|flags
operator|&
name|ATTR_NOACLCHECK
operator|)
condition|?
name|B_TRUE
else|:
name|B_FALSE
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|pzp
operator|=
name|zp
operator|->
name|z_phys
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If ACL is trivial don't bother looking for ACE_READ_ATTRIBUTES. 	 * Also, if we are the owner don't bother, since owner should 	 * always be allowed to read basic attributes of file. 	 */
if|if
condition|(
operator|!
operator|(
name|pzp
operator|->
name|zp_flags
operator|&
name|ZFS_ACL_TRIVIAL
operator|)
operator|&&
operator|(
name|pzp
operator|->
name|zp_uid
operator|!=
name|crgetuid
argument_list|(
name|cr
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|ACE_READ_ATTRIBUTES
argument_list|,
literal|0
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Return all attributes.  It's cheaper to provide the answer 	 * than to determine whether we were asked the question. 	 */
name|vap
operator|->
name|va_type
operator|=
name|IFTOVT
argument_list|(
name|pzp
operator|->
name|zp_mode
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_mode
operator|=
name|pzp
operator|->
name|zp_mode
operator|&
operator|~
name|S_IFMT
expr_stmt|;
name|zfs_fuid_map_ids
argument_list|(
name|zp
argument_list|,
name|cr
argument_list|,
operator|&
name|vap
operator|->
name|va_uid
argument_list|,
operator|&
name|vap
operator|->
name|va_gid
argument_list|)
expr_stmt|;
comment|//	vap->va_fsid = zp->z_zfsvfs->z_vfs->vfs_dev;
name|vap
operator|->
name|va_nodeid
operator|=
name|zp
operator|->
name|z_id
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|VROOT
operator|)
operator|&&
name|zfs_show_ctldir
argument_list|(
name|zp
argument_list|)
condition|)
name|links
operator|=
name|pzp
operator|->
name|zp_links
operator|+
literal|1
expr_stmt|;
else|else
name|links
operator|=
name|pzp
operator|->
name|zp_links
expr_stmt|;
name|vap
operator|->
name|va_nlink
operator|=
name|MIN
argument_list|(
name|links
argument_list|,
name|UINT32_MAX
argument_list|)
expr_stmt|;
comment|/* nlink_t limit! */
name|vap
operator|->
name|va_size
operator|=
name|pzp
operator|->
name|zp_size
expr_stmt|;
name|vap
operator|->
name|va_fsid
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_stat
operator|.
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
expr_stmt|;
name|vap
operator|->
name|va_rdev
operator|=
name|zfs_cmpldev
argument_list|(
name|pzp
operator|->
name|zp_rdev
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_seq
operator|=
name|zp
operator|->
name|z_seq
expr_stmt|;
name|vap
operator|->
name|va_flags
operator|=
literal|0
expr_stmt|;
comment|/* FreeBSD: Reset chflags(2) flags. */
comment|/* 	 * Add in any requested optional attributes and the create time. 	 * Also set the corresponding bits in the returned attribute bitmap. 	 */
if|if
condition|(
operator|(
name|xoap
operator|=
name|xva_getxoptattr
argument_list|(
name|xvap
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|zfsvfs
operator|->
name|z_use_fuids
condition|)
block|{
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_ARCHIVE
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_archive
operator|=
operator|(
operator|(
name|pzp
operator|->
name|zp_flags
operator|&
name|ZFS_ARCHIVE
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_ARCHIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_READONLY
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_readonly
operator|=
operator|(
operator|(
name|pzp
operator|->
name|zp_flags
operator|&
name|ZFS_READONLY
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_READONLY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_SYSTEM
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_system
operator|=
operator|(
operator|(
name|pzp
operator|->
name|zp_flags
operator|&
name|ZFS_SYSTEM
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_SYSTEM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_HIDDEN
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_hidden
operator|=
operator|(
operator|(
name|pzp
operator|->
name|zp_flags
operator|&
name|ZFS_HIDDEN
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_HIDDEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_NOUNLINK
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_nounlink
operator|=
operator|(
operator|(
name|pzp
operator|->
name|zp_flags
operator|&
name|ZFS_NOUNLINK
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_NOUNLINK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_IMMUTABLE
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_immutable
operator|=
operator|(
operator|(
name|pzp
operator|->
name|zp_flags
operator|&
name|ZFS_IMMUTABLE
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_IMMUTABLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_APPENDONLY
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_appendonly
operator|=
operator|(
operator|(
name|pzp
operator|->
name|zp_flags
operator|&
name|ZFS_APPENDONLY
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_APPENDONLY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_NODUMP
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_nodump
operator|=
operator|(
operator|(
name|pzp
operator|->
name|zp_flags
operator|&
name|ZFS_NODUMP
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_NODUMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_OPAQUE
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_opaque
operator|=
operator|(
operator|(
name|pzp
operator|->
name|zp_flags
operator|&
name|ZFS_OPAQUE
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_OPAQUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_QUARANTINED
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_av_quarantined
operator|=
operator|(
operator|(
name|pzp
operator|->
name|zp_flags
operator|&
name|ZFS_AV_QUARANTINED
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_QUARANTINED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_MODIFIED
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_av_modified
operator|=
operator|(
operator|(
name|pzp
operator|->
name|zp_flags
operator|&
name|ZFS_AV_MODIFIED
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_MODIFIED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_SCANSTAMP
argument_list|)
operator|&&
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|&&
operator|(
name|pzp
operator|->
name|zp_flags
operator|&
name|ZFS_BONUS_SCANSTAMP
operator|)
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
comment|/* 			 * Only VREG files have anti-virus scanstamps, so we 			 * won't conflict with symlinks in the bonus buffer. 			 */
name|dmu_object_info_from_db
argument_list|(
name|zp
operator|->
name|z_dbuf
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|xoap
operator|->
name|xoa_av_scanstamp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|znode_phys_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
name|doi
operator|.
name|doi_bonus_size
condition|)
block|{
comment|/* 				 * pzp points to the start of the 				 * znode_phys_t. pzp + 1 points to the 				 * first byte after the znode_phys_t. 				 */
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|xoap
operator|->
name|xoa_av_scanstamp
argument_list|,
name|pzp
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|xoap
operator|->
name|xoa_av_scanstamp
argument_list|)
argument_list|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_SCANSTAMP
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_CREATETIME
argument_list|)
condition|)
block|{
name|ZFS_TIME_DECODE
argument_list|(
operator|&
name|xoap
operator|->
name|xoa_createtime
argument_list|,
name|pzp
operator|->
name|zp_crtime
argument_list|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_CREATETIME
argument_list|)
expr_stmt|;
block|}
block|}
name|ZFS_TIME_DECODE
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|,
name|pzp
operator|->
name|zp_atime
argument_list|)
expr_stmt|;
name|ZFS_TIME_DECODE
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
name|pzp
operator|->
name|zp_mtime
argument_list|)
expr_stmt|;
name|ZFS_TIME_DECODE
argument_list|(
operator|&
name|vap
operator|->
name|va_ctime
argument_list|,
name|pzp
operator|->
name|zp_ctime
argument_list|)
expr_stmt|;
name|ZFS_TIME_DECODE
argument_list|(
operator|&
name|vap
operator|->
name|va_birthtime
argument_list|,
name|pzp
operator|->
name|zp_crtime
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|dmu_object_size_from_db
argument_list|(
name|zp
operator|->
name|z_dbuf
argument_list|,
operator|&
name|blksize
argument_list|,
operator|&
name|nblocks
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_blksize
operator|=
name|blksize
expr_stmt|;
name|vap
operator|->
name|va_bytes
operator|=
name|nblocks
operator|<<
literal|9
expr_stmt|;
comment|/* nblocks * 512 */
if|if
condition|(
name|zp
operator|->
name|z_blksz
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Block size hasn't been set; suggest maximal I/O transfers. 		 */
name|vap
operator|->
name|va_blksize
operator|=
name|zfsvfs
operator|->
name|z_max_blksz
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the file attributes to the values contained in the  * vattr structure.  *  *	IN:	vp	- vnode of file to be modified.  *		vap	- new attribute values.  *			  If AT_XVATTR set, then optional attrs are being set  *		flags	- ATTR_UTIME set if non-default time values provided.  *			- ATTR_NOACLCHECK (CIFS context only).  *		cr	- credentials of caller.  *		ct	- caller context  *  *	RETURN:	0 if success  *		error code if failure  *  * Timestamps:  *	vp - ctime updated, mtime updated if size changed.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_setattr
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|znode_phys_t
modifier|*
name|pzp
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|vattr_t
name|oldva
decl_stmt|;
name|uint_t
name|mask
init|=
name|vap
operator|->
name|va_mask
decl_stmt|;
name|uint_t
name|saved_mask
decl_stmt|;
name|int
name|trim_mask
init|=
literal|0
decl_stmt|;
name|uint64_t
name|new_mode
decl_stmt|;
name|znode_t
modifier|*
name|attrzp
decl_stmt|;
name|int
name|need_policy
init|=
name|FALSE
decl_stmt|;
name|int
name|err
decl_stmt|;
name|zfs_fuid_info_t
modifier|*
name|fuidp
init|=
name|NULL
decl_stmt|;
name|xvattr_t
modifier|*
name|xvap
init|=
operator|(
name|xvattr_t
operator|*
operator|)
name|vap
decl_stmt|;
comment|/* vap may be an xvattr_t * */
name|xoptattr_t
modifier|*
name|xoap
decl_stmt|;
name|zfs_acl_t
modifier|*
name|aclp
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|skipaclchk
init|=
operator|(
name|flags
operator|&
name|ATTR_NOACLCHECK
operator|)
condition|?
name|B_TRUE
else|:
name|B_FALSE
decl_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|mask
operator|&
name|AT_NOSET
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|pzp
operator|=
name|zp
operator|->
name|z_phys
expr_stmt|;
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
comment|/* 	 * Make sure that if we have ephemeral uid/gid or xvattr specified 	 * that file system is at proper version level 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_use_fuids
operator|==
name|B_FALSE
operator|&&
operator|(
operator|(
operator|(
name|mask
operator|&
name|AT_UID
operator|)
operator|&&
name|IS_EPHEMERAL
argument_list|(
name|vap
operator|->
name|va_uid
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|mask
operator|&
name|AT_GID
operator|)
operator|&&
name|IS_EPHEMERAL
argument_list|(
name|vap
operator|->
name|va_gid
argument_list|)
operator|)
operator|||
operator|(
name|mask
operator|&
name|AT_XVATTR
operator|)
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|mask
operator|&
name|AT_SIZE
operator|&&
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EISDIR
operator|)
return|;
block|}
if|if
condition|(
name|mask
operator|&
name|AT_SIZE
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VREG
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VFIFO
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * If this is an xvattr_t, then get a pointer to the structure of 	 * optional attributes.  If this is NULL, then we have a vattr_t. 	 */
name|xoap
operator|=
name|xva_getxoptattr
argument_list|(
name|xvap
argument_list|)
expr_stmt|;
comment|/* 	 * Immutable files can only alter immutable bit and atime 	 */
if|if
condition|(
operator|(
name|pzp
operator|->
name|zp_flags
operator|&
name|ZFS_IMMUTABLE
operator|)
operator|&&
operator|(
operator|(
name|mask
operator|&
operator|(
name|AT_SIZE
operator||
name|AT_UID
operator||
name|AT_GID
operator||
name|AT_MTIME
operator||
name|AT_MODE
operator|)
operator|)
operator|||
operator|(
operator|(
name|mask
operator|&
name|AT_XVATTR
operator|)
operator|&&
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_CREATETIME
argument_list|)
operator|)
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|AT_SIZE
operator|)
operator|&&
operator|(
name|pzp
operator|->
name|zp_flags
operator|&
name|ZFS_READONLY
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
comment|/* 	 * Verify timestamps doesn't overflow 32 bits. 	 * ZFS can handle large timestamps, but 32bit syscalls can't 	 * handle times greater than 2039.  This check should be removed 	 * once large timestamps are fully supported. 	 */
if|if
condition|(
name|mask
operator|&
operator|(
name|AT_ATIME
operator||
name|AT_MTIME
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|mask
operator|&
name|AT_ATIME
operator|)
operator|&&
name|TIMESPEC_OVERFLOW
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|mask
operator|&
name|AT_MTIME
operator|)
operator|&&
name|TIMESPEC_OVERFLOW
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|)
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOVERFLOW
operator|)
return|;
block|}
block|}
name|top
label|:
name|attrzp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EROFS
operator|)
return|;
block|}
comment|/* 	 * First validate permissions 	 */
if|if
condition|(
name|mask
operator|&
name|AT_SIZE
condition|)
block|{
name|err
operator|=
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|ACE_WRITE_DATA
argument_list|,
literal|0
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 		 * XXX - Note, we are not providing any open 		 * mode flags here (like FNDELAY), so we may 		 * block if there are locks present... this 		 * should be addressed in openat(). 		 */
comment|/* XXX - would it be OK to generate a log record here? */
name|err
operator|=
name|zfs_freesp
argument_list|(
name|zp
argument_list|,
name|vap
operator|->
name|va_size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
operator|(
name|AT_ATIME
operator||
name|AT_MTIME
operator|)
operator|||
operator|(
operator|(
name|mask
operator|&
name|AT_XVATTR
operator|)
operator|&&
operator|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_HIDDEN
argument_list|)
operator|||
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_READONLY
argument_list|)
operator|||
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_ARCHIVE
argument_list|)
operator|||
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_CREATETIME
argument_list|)
operator|||
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_SYSTEM
argument_list|)
operator|)
operator|)
condition|)
name|need_policy
operator|=
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|ACE_WRITE_ATTRIBUTES
argument_list|,
literal|0
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
operator|(
name|AT_UID
operator||
name|AT_GID
operator|)
condition|)
block|{
name|int
name|idmask
init|=
operator|(
name|mask
operator|&
operator|(
name|AT_UID
operator||
name|AT_GID
operator|)
operator|)
decl_stmt|;
name|int
name|take_owner
decl_stmt|;
name|int
name|take_group
decl_stmt|;
comment|/* 		 * NOTE: even if a new mode is being set, 		 * we may clear S_ISUID/S_ISGID bits. 		 */
if|if
condition|(
operator|!
operator|(
name|mask
operator|&
name|AT_MODE
operator|)
condition|)
name|vap
operator|->
name|va_mode
operator|=
name|pzp
operator|->
name|zp_mode
expr_stmt|;
comment|/* 		 * Take ownership or chgrp to group we are a member of 		 */
name|take_owner
operator|=
operator|(
name|mask
operator|&
name|AT_UID
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_uid
operator|==
name|crgetuid
argument_list|(
name|cr
argument_list|)
operator|)
expr_stmt|;
name|take_group
operator|=
operator|(
name|mask
operator|&
name|AT_GID
operator|)
operator|&&
name|zfs_groupmember
argument_list|(
name|zfsvfs
argument_list|,
name|vap
operator|->
name|va_gid
argument_list|,
name|cr
argument_list|)
expr_stmt|;
comment|/* 		 * If both AT_UID and AT_GID are set then take_owner and 		 * take_group must both be set in order to allow taking 		 * ownership. 		 * 		 * Otherwise, send the check through secpolicy_vnode_setattr() 		 * 		 */
if|if
condition|(
operator|(
operator|(
name|idmask
operator|==
operator|(
name|AT_UID
operator||
name|AT_GID
operator|)
operator|)
operator|&&
name|take_owner
operator|&&
name|take_group
operator|)
operator|||
operator|(
operator|(
name|idmask
operator|==
name|AT_UID
operator|)
operator|&&
name|take_owner
operator|)
operator|||
operator|(
operator|(
name|idmask
operator|==
name|AT_GID
operator|)
operator|&&
name|take_group
operator|)
condition|)
block|{
if|if
condition|(
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|ACE_WRITE_OWNER
argument_list|,
literal|0
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Remove setuid/setgid for non-privileged users 				 */
name|secpolicy_setid_clear
argument_list|(
name|vap
argument_list|,
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|trim_mask
operator|=
operator|(
name|mask
operator|&
operator|(
name|AT_UID
operator||
name|AT_GID
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|need_policy
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
name|need_policy
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|oldva
operator|.
name|va_mode
operator|=
name|pzp
operator|->
name|zp_mode
expr_stmt|;
name|zfs_fuid_map_ids
argument_list|(
name|zp
argument_list|,
name|cr
argument_list|,
operator|&
name|oldva
operator|.
name|va_uid
argument_list|,
operator|&
name|oldva
operator|.
name|va_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|AT_XVATTR
condition|)
block|{
if|if
condition|(
operator|(
name|need_policy
operator|==
name|FALSE
operator|)
operator|&&
operator|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_APPENDONLY
argument_list|)
operator|&&
name|xoap
operator|->
name|xoa_appendonly
operator|!=
operator|(
operator|(
name|pzp
operator|->
name|zp_flags
operator|&
name|ZFS_APPENDONLY
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_NOUNLINK
argument_list|)
operator|&&
name|xoap
operator|->
name|xoa_nounlink
operator|!=
operator|(
operator|(
name|pzp
operator|->
name|zp_flags
operator|&
name|ZFS_NOUNLINK
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_IMMUTABLE
argument_list|)
operator|&&
name|xoap
operator|->
name|xoa_immutable
operator|!=
operator|(
operator|(
name|pzp
operator|->
name|zp_flags
operator|&
name|ZFS_IMMUTABLE
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_NODUMP
argument_list|)
operator|&&
name|xoap
operator|->
name|xoa_nodump
operator|!=
operator|(
operator|(
name|pzp
operator|->
name|zp_flags
operator|&
name|ZFS_NODUMP
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_MODIFIED
argument_list|)
operator|&&
name|xoap
operator|->
name|xoa_av_modified
operator|!=
operator|(
operator|(
name|pzp
operator|->
name|zp_flags
operator|&
name|ZFS_AV_MODIFIED
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_QUARANTINED
argument_list|)
operator|&&
operator|(
operator|(
name|vp
operator|->
name|v_type
operator|!=
name|VREG
operator|&&
name|xoap
operator|->
name|xoa_av_quarantined
operator|)
operator|||
name|xoap
operator|->
name|xoa_av_quarantined
operator|!=
operator|(
operator|(
name|pzp
operator|->
name|zp_flags
operator|&
name|ZFS_AV_QUARANTINED
operator|)
operator|!=
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_SCANSTAMP
argument_list|)
operator|)
operator|||
operator|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_OPAQUE
argument_list|)
operator|)
condition|)
block|{
name|need_policy
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|AT_MODE
condition|)
block|{
if|if
condition|(
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|ACE_WRITE_ACL
argument_list|,
literal|0
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|secpolicy_setid_setsticky_clear
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|,
operator|&
name|oldva
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|trim_mask
operator||=
name|AT_MODE
expr_stmt|;
block|}
else|else
block|{
name|need_policy
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|need_policy
condition|)
block|{
comment|/* 		 * If trim_mask is set then take ownership 		 * has been granted or write_acl is present and user 		 * has the ability to modify mode.  In that case remove 		 * UID|GID and or MODE from mask so that 		 * secpolicy_vnode_setattr() doesn't revoke it. 		 */
if|if
condition|(
name|trim_mask
condition|)
block|{
name|saved_mask
operator|=
name|vap
operator|->
name|va_mask
expr_stmt|;
name|vap
operator|->
name|va_mask
operator|&=
operator|~
name|trim_mask
expr_stmt|;
block|}
name|err
operator|=
name|secpolicy_vnode_setattr
argument_list|(
name|cr
argument_list|,
name|vp
argument_list|,
name|vap
argument_list|,
operator|&
name|oldva
argument_list|,
name|flags
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|int
argument_list|,
name|cred_t
operator|*
argument_list|)
operator|)
name|zfs_zaccess_unix
argument_list|,
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|trim_mask
condition|)
name|vap
operator|->
name|va_mask
operator||=
name|saved_mask
expr_stmt|;
block|}
comment|/* 	 * secpolicy_vnode_setattr, or take ownership may have 	 * changed va_mask 	 */
name|mask
operator|=
name|vap
operator|->
name|va_mask
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|mask
operator|&
name|AT_UID
operator|)
operator|&&
name|IS_EPHEMERAL
argument_list|(
name|vap
operator|->
name|va_uid
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|mask
operator|&
name|AT_GID
operator|)
operator|&&
name|IS_EPHEMERAL
argument_list|(
name|vap
operator|->
name|va_gid
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|zfsvfs
operator|->
name|z_fuid_obj
operator|==
literal|0
condition|)
block|{
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|FUID_SIZE_ESTIMATE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_fuid_obj
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_fuid_obj
argument_list|,
literal|0
argument_list|,
name|FUID_SIZE_ESTIMATE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|AT_MODE
condition|)
block|{
name|uint64_t
name|pmode
init|=
name|pzp
operator|->
name|zp_mode
decl_stmt|;
name|new_mode
operator|=
operator|(
name|pmode
operator|&
name|S_IFMT
operator|)
operator||
operator|(
name|vap
operator|->
name|va_mode
operator|&
operator|~
name|S_IFMT
operator|)
expr_stmt|;
if|if
condition|(
name|err
operator|=
name|zfs_acl_chmod_setattr
argument_list|(
name|zp
argument_list|,
operator|&
name|aclp
argument_list|,
name|new_mode
argument_list|)
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|pzp
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
condition|)
block|{
comment|/* Are we upgrading ACL from old V0 format to new V1 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_version
operator|<=
name|ZPL_VERSION_FUID
operator|&&
name|pzp
operator|->
name|zp_acl
operator|.
name|z_acl_version
operator|==
name|ZFS_ACL_VERSION_INITIAL
condition|)
block|{
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|pzp
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|pzp
operator|->
name|zp_acl
operator|.
name|z_acl_extern_obj
argument_list|,
literal|0
argument_list|,
name|aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|aclp
operator|->
name|z_acl_bytes
operator|>
name|ZFS_ACE_SPACE
condition|)
block|{
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
name|AT_UID
operator||
name|AT_GID
operator|)
operator|)
operator|&&
name|pzp
operator|->
name|zp_xattr
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|zfs_zget
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|,
name|pzp
operator|->
name|zp_xattr
argument_list|,
operator|&
name|attrzp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|aclp
condition|)
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|attrzp
operator|->
name|z_id
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_assign
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|attrzp
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|attrzp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|aclp
condition|)
block|{
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
name|aclp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
name|ERESTART
operator|&&
name|zfsvfs
operator|->
name|z_assign
operator|==
name|TXG_NOWAIT
condition|)
block|{
name|dmu_tx_wait
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|dmu_buf_will_dirty
argument_list|(
name|zp
operator|->
name|z_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Set each attribute requested. 	 * We group settings according to the locks they need to acquire. 	 * 	 * Note: you cannot set ctime directly, although it will be 	 * updated as a side-effect of calling this function. 	 */
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|AT_MODE
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_phys
operator|->
name|zp_mode
operator|=
name|new_mode
expr_stmt|;
name|err
operator|=
name|zfs_aclset_common
argument_list|(
name|zp
argument_list|,
name|aclp
argument_list|,
name|cr
argument_list|,
operator|&
name|fuidp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attrzp
condition|)
name|mutex_enter
argument_list|(
operator|&
name|attrzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|AT_UID
condition|)
block|{
name|pzp
operator|->
name|zp_uid
operator|=
name|zfs_fuid_create
argument_list|(
name|zfsvfs
argument_list|,
name|vap
operator|->
name|va_uid
argument_list|,
name|cr
argument_list|,
name|ZFS_OWNER
argument_list|,
name|tx
argument_list|,
operator|&
name|fuidp
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrzp
condition|)
block|{
name|attrzp
operator|->
name|z_phys
operator|->
name|zp_uid
operator|=
name|zfs_fuid_create
argument_list|(
name|zfsvfs
argument_list|,
name|vap
operator|->
name|va_uid
argument_list|,
name|cr
argument_list|,
name|ZFS_OWNER
argument_list|,
name|tx
argument_list|,
operator|&
name|fuidp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|AT_GID
condition|)
block|{
name|pzp
operator|->
name|zp_gid
operator|=
name|zfs_fuid_create
argument_list|(
name|zfsvfs
argument_list|,
name|vap
operator|->
name|va_gid
argument_list|,
name|cr
argument_list|,
name|ZFS_GROUP
argument_list|,
name|tx
argument_list|,
operator|&
name|fuidp
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrzp
condition|)
name|attrzp
operator|->
name|z_phys
operator|->
name|zp_gid
operator|=
name|zfs_fuid_create
argument_list|(
name|zfsvfs
argument_list|,
name|vap
operator|->
name|va_gid
argument_list|,
name|cr
argument_list|,
name|ZFS_GROUP
argument_list|,
name|tx
argument_list|,
operator|&
name|fuidp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aclp
condition|)
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrzp
condition|)
name|mutex_exit
argument_list|(
operator|&
name|attrzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|AT_ATIME
condition|)
name|ZFS_TIME_ENCODE
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|,
name|pzp
operator|->
name|zp_atime
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|AT_MTIME
condition|)
name|ZFS_TIME_ENCODE
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
name|pzp
operator|->
name|zp_mtime
argument_list|)
expr_stmt|;
comment|/* XXX - shouldn't this be done *before* the ATIME/MTIME checks? */
if|if
condition|(
name|mask
operator|&
name|AT_SIZE
condition|)
name|zfs_time_stamper_locked
argument_list|(
name|zp
argument_list|,
name|CONTENT_MODIFIED
argument_list|,
name|tx
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
name|zfs_time_stamper_locked
argument_list|(
name|zp
argument_list|,
name|STATE_CHANGED
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Do this after setting timestamps to prevent timestamp 	 * update from toggling bit 	 */
if|if
condition|(
name|xoap
operator|&&
operator|(
name|mask
operator|&
name|AT_XVATTR
operator|)
condition|)
block|{
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_SCANSTAMP
argument_list|)
condition|)
block|{
name|size_t
name|len
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
argument_list|)
expr_stmt|;
comment|/* Grow the bonus buffer if necessary. */
name|dmu_object_info_from_db
argument_list|(
name|zp
operator|->
name|z_dbuf
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|xoap
operator|->
name|xoa_av_scanstamp
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|znode_phys_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|doi
operator|.
name|doi_bonus_size
condition|)
name|VERIFY
argument_list|(
name|dmu_set_bonus
argument_list|(
name|zp
operator|->
name|z_dbuf
argument_list|,
name|len
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|zfs_xvattr_set
argument_list|(
name|zp
argument_list|,
name|xvap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
name|zfs_log_setattr
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|TX_SETATTR
argument_list|,
name|zp
argument_list|,
name|vap
argument_list|,
name|mask
argument_list|,
name|fuidp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuidp
condition|)
name|zfs_fuid_info_free
argument_list|(
name|fuidp
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrzp
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|attrzp
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|zfs_zlock
block|{
name|krwlock_t
modifier|*
name|zl_rwlock
decl_stmt|;
comment|/* lock we acquired */
name|znode_t
modifier|*
name|zl_znode
decl_stmt|;
comment|/* znode we held */
name|struct
name|zfs_zlock
modifier|*
name|zl_next
decl_stmt|;
comment|/* next in list */
block|}
name|zfs_zlock_t
typedef|;
end_typedef

begin_comment
comment|/*  * Drop locks and release vnodes that were held by zfs_rename_lock().  */
end_comment

begin_function
specifier|static
name|void
name|zfs_rename_unlock
parameter_list|(
name|zfs_zlock_t
modifier|*
modifier|*
name|zlpp
parameter_list|)
block|{
name|zfs_zlock_t
modifier|*
name|zl
decl_stmt|;
while|while
condition|(
operator|(
name|zl
operator|=
operator|*
name|zlpp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|zl
operator|->
name|zl_znode
operator|!=
name|NULL
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|zl
operator|->
name|zl_znode
argument_list|)
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
name|zl
operator|->
name|zl_rwlock
argument_list|)
expr_stmt|;
operator|*
name|zlpp
operator|=
name|zl
operator|->
name|zl_next
expr_stmt|;
name|kmem_free
argument_list|(
name|zl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Search back through the directory tree, using the ".." entries.  * Lock each directory in the chain to prevent concurrent renames.  * Fail any attempt to move a directory into one of its own descendants.  * XXX - z_parent_lock can overlap with map or grow locks  */
end_comment

begin_function
specifier|static
name|int
name|zfs_rename_lock
parameter_list|(
name|znode_t
modifier|*
name|szp
parameter_list|,
name|znode_t
modifier|*
name|tdzp
parameter_list|,
name|znode_t
modifier|*
name|sdzp
parameter_list|,
name|zfs_zlock_t
modifier|*
modifier|*
name|zlpp
parameter_list|)
block|{
name|zfs_zlock_t
modifier|*
name|zl
decl_stmt|;
name|znode_t
modifier|*
name|zp
init|=
name|tdzp
decl_stmt|;
name|uint64_t
name|rootid
init|=
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_root
decl_stmt|;
name|uint64_t
modifier|*
name|oidp
init|=
operator|&
name|zp
operator|->
name|z_id
decl_stmt|;
name|krwlock_t
modifier|*
name|rwlp
init|=
operator|&
name|szp
operator|->
name|z_parent_lock
decl_stmt|;
name|krw_t
name|rw
init|=
name|RW_WRITER
decl_stmt|;
comment|/* 	 * First pass write-locks szp and compares to zp->z_id. 	 * Later passes read-lock zp and compare to zp->z_parent. 	 */
do|do
block|{
if|if
condition|(
operator|!
name|rw_tryenter
argument_list|(
name|rwlp
argument_list|,
name|rw
argument_list|)
condition|)
block|{
comment|/* 			 * Another thread is renaming in this path. 			 * Note that if we are a WRITER, we don't have any 			 * parent_locks held yet. 			 */
if|if
condition|(
name|rw
operator|==
name|RW_READER
operator|&&
name|zp
operator|->
name|z_id
operator|>
name|szp
operator|->
name|z_id
condition|)
block|{
comment|/* 				 * Drop our locks and restart 				 */
name|zfs_rename_unlock
argument_list|(
operator|&
name|zl
argument_list|)
expr_stmt|;
operator|*
name|zlpp
operator|=
name|NULL
expr_stmt|;
name|zp
operator|=
name|tdzp
expr_stmt|;
name|oidp
operator|=
operator|&
name|zp
operator|->
name|z_id
expr_stmt|;
name|rwlp
operator|=
operator|&
name|szp
operator|->
name|z_parent_lock
expr_stmt|;
name|rw
operator|=
name|RW_WRITER
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* 				 * Wait for other thread to drop its locks 				 */
name|rw_enter
argument_list|(
name|rwlp
argument_list|,
name|rw
argument_list|)
expr_stmt|;
block|}
block|}
name|zl
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|zl
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zl
operator|->
name|zl_rwlock
operator|=
name|rwlp
expr_stmt|;
name|zl
operator|->
name|zl_znode
operator|=
name|NULL
expr_stmt|;
name|zl
operator|->
name|zl_next
operator|=
operator|*
name|zlpp
expr_stmt|;
operator|*
name|zlpp
operator|=
name|zl
expr_stmt|;
if|if
condition|(
operator|*
name|oidp
operator|==
name|szp
operator|->
name|z_id
condition|)
comment|/* We're a descendant of szp */
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|*
name|oidp
operator|==
name|rootid
condition|)
comment|/* We've hit the top */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|rw
operator|==
name|RW_READER
condition|)
block|{
comment|/* i.e. not the first pass */
name|int
name|error
init|=
name|zfs_zget
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|,
operator|*
name|oidp
argument_list|,
operator|&
name|zp
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|zl
operator|->
name|zl_znode
operator|=
name|zp
expr_stmt|;
block|}
name|oidp
operator|=
operator|&
name|zp
operator|->
name|z_phys
operator|->
name|zp_parent
expr_stmt|;
name|rwlp
operator|=
operator|&
name|zp
operator|->
name|z_parent_lock
expr_stmt|;
name|rw
operator|=
name|RW_READER
expr_stmt|;
block|}
do|while
condition|(
name|zp
operator|->
name|z_id
operator|!=
name|sdzp
operator|->
name|z_id
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Move an entry from the provided source directory to the target  * directory.  Change the entry name as indicated.  *  *	IN:	sdvp	- Source directory containing the "old entry".  *		snm	- Old entry name.  *		tdvp	- Target directory to contain the "new entry".  *		tnm	- New entry name.  *		cr	- credentials of caller.  *		ct	- caller context  *		flags	- case flags  *  *	RETURN:	0 if success  *		error code if failure  *  * Timestamps:  *	sdvp,tdvp - ctime|mtime updated  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_rename
parameter_list|(
name|vnode_t
modifier|*
name|sdvp
parameter_list|,
name|char
modifier|*
name|snm
parameter_list|,
name|vnode_t
modifier|*
name|tdvp
parameter_list|,
name|char
modifier|*
name|tnm
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|znode_t
modifier|*
name|tdzp
decl_stmt|,
modifier|*
name|szp
decl_stmt|,
modifier|*
name|tzp
decl_stmt|;
name|znode_t
modifier|*
name|sdzp
init|=
name|VTOZ
argument_list|(
name|sdvp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|sdzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|vnode_t
modifier|*
name|realvp
decl_stmt|;
name|zfs_dirlock_t
modifier|*
name|sdl
decl_stmt|,
modifier|*
name|tdl
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|zfs_zlock_t
modifier|*
name|zl
decl_stmt|;
name|int
name|cmp
decl_stmt|,
name|serr
decl_stmt|,
name|terr
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|zflg
init|=
literal|0
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|sdzp
argument_list|)
expr_stmt|;
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
comment|/* 	 * Make sure we have the real vp for the target directory. 	 */
if|if
condition|(
name|VOP_REALVP
argument_list|(
name|tdvp
argument_list|,
operator|&
name|realvp
argument_list|,
name|ct
argument_list|)
operator|==
literal|0
condition|)
name|tdvp
operator|=
name|realvp
expr_stmt|;
if|if
condition|(
name|tdvp
operator|->
name|v_vfsp
operator|!=
name|sdvp
operator|->
name|v_vfsp
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EXDEV
operator|)
return|;
block|}
name|tdzp
operator|=
name|VTOZ
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|tdzp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_utf8
operator|&&
name|u8_validate
argument_list|(
name|tnm
argument_list|,
name|strlen
argument_list|(
name|tnm
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|U8_VALIDATE_ENTIRE
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EILSEQ
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
condition|)
name|zflg
operator||=
name|ZCILOOK
expr_stmt|;
name|top
label|:
name|szp
operator|=
name|NULL
expr_stmt|;
name|tzp
operator|=
name|NULL
expr_stmt|;
name|zl
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * This is to prevent the creation of links into attribute space 	 * by renaming a linked file into/outof an attribute directory. 	 * See the comment in zfs_link() for why this is considered bad. 	 */
if|if
condition|(
operator|(
name|tdzp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_XATTR
operator|)
operator|!=
operator|(
name|sdzp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_XATTR
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Lock source and target directory entries.  To prevent deadlock, 	 * a lock ordering must be defined.  We lock the directory with 	 * the smallest object id first, or if it's a tie, the one with 	 * the lexically first name. 	 */
if|if
condition|(
name|sdzp
operator|->
name|z_id
operator|<
name|tdzp
operator|->
name|z_id
condition|)
block|{
name|cmp
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sdzp
operator|->
name|z_id
operator|>
name|tdzp
operator|->
name|z_id
condition|)
block|{
name|cmp
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * First compare the two name arguments without 		 * considering any case folding. 		 */
name|int
name|nofold
init|=
operator|(
name|zfsvfs
operator|->
name|z_norm
operator|&
operator|~
name|U8_TEXTPREP_TOUPPER
operator|)
decl_stmt|;
name|cmp
operator|=
name|u8_strcmp
argument_list|(
name|snm
argument_list|,
name|tnm
argument_list|,
literal|0
argument_list|,
name|nofold
argument_list|,
name|U8_UNICODE_LATEST
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
operator|||
operator|!
name|zfsvfs
operator|->
name|z_utf8
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
comment|/* 			 * POSIX: "If the old argument and the new argument 			 * both refer to links to the same existing file, 			 * the rename() function shall return successfully 			 * and perform no other action." 			 */
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * If the file system is case-folding, then we may 		 * have some more checking to do.  A case-folding file 		 * system is either supporting mixed case sensitivity 		 * access or is completely case-insensitive.  Note 		 * that the file system is always case preserving. 		 * 		 * In mixed sensitivity mode case sensitive behavior 		 * is the default.  FIGNORECASE must be used to 		 * explicitly request case insensitive behavior. 		 * 		 * If the source and target names provided differ only 		 * by case (e.g., a request to rename 'tim' to 'Tim'), 		 * we will treat this as a special case in the 		 * case-insensitive mode: as long as the source name 		 * is an exact match, we will allow this to proceed as 		 * a name-change request. 		 */
if|if
condition|(
operator|(
name|zfsvfs
operator|->
name|z_case
operator|==
name|ZFS_CASE_INSENSITIVE
operator|||
operator|(
name|zfsvfs
operator|->
name|z_case
operator|==
name|ZFS_CASE_MIXED
operator|&&
name|flags
operator|&
name|FIGNORECASE
operator|)
operator|)
operator|&&
name|u8_strcmp
argument_list|(
name|snm
argument_list|,
name|tnm
argument_list|,
literal|0
argument_list|,
name|zfsvfs
operator|->
name|z_norm
argument_list|,
name|U8_UNICODE_LATEST
argument_list|,
operator|&
name|error
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * case preserving rename request, require exact 			 * name matches 			 */
name|zflg
operator||=
name|ZCIEXACT
expr_stmt|;
name|zflg
operator|&=
operator|~
name|ZCILOOK
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|serr
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|sdl
argument_list|,
name|sdzp
argument_list|,
name|snm
argument_list|,
operator|&
name|szp
argument_list|,
name|ZEXISTS
operator||
name|zflg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|terr
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|tdl
argument_list|,
name|tdzp
argument_list|,
name|tnm
argument_list|,
operator|&
name|tzp
argument_list|,
name|ZRENAMING
operator||
name|zflg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|terr
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|tdl
argument_list|,
name|tdzp
argument_list|,
name|tnm
argument_list|,
operator|&
name|tzp
argument_list|,
name|zflg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|serr
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|sdl
argument_list|,
name|sdzp
argument_list|,
name|snm
argument_list|,
operator|&
name|szp
argument_list|,
name|ZEXISTS
operator||
name|ZRENAMING
operator||
name|zflg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|serr
condition|)
block|{
comment|/* 		 * Source entry invalid or not there. 		 */
if|if
condition|(
operator|!
name|terr
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|tdl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tzp
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|tzp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|snm
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|snm
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
name|serr
operator|=
name|EINVAL
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|serr
operator|)
return|;
block|}
if|if
condition|(
name|terr
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|sdl
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|szp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|tnm
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
name|terr
operator|=
name|EINVAL
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|terr
operator|)
return|;
block|}
comment|/* 	 * Must have write access at the source to remove the old entry 	 * and write access at the target to create the new entry. 	 * Note that if target and source are the same, this can be 	 * done in a single check. 	 */
if|if
condition|(
name|error
operator|=
name|zfs_zaccess_rename
argument_list|(
name|sdzp
argument_list|,
name|szp
argument_list|,
name|tdzp
argument_list|,
name|tzp
argument_list|,
name|cr
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|ZTOV
argument_list|(
name|szp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
comment|/* 		 * Check to make sure rename is valid. 		 * Can't do a move like this: /usr/a/b to /usr/a/b/c/d 		 */
if|if
condition|(
name|error
operator|=
name|zfs_rename_lock
argument_list|(
name|szp
argument_list|,
name|tdzp
argument_list|,
name|sdzp
argument_list|,
operator|&
name|zl
argument_list|)
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Does target exist? 	 */
if|if
condition|(
name|tzp
condition|)
block|{
comment|/* 		 * Source and target must be the same type. 		 */
if|if
condition|(
name|ZTOV
argument_list|(
name|szp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
if|if
condition|(
name|ZTOV
argument_list|(
name|tzp
argument_list|)
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
name|error
operator|=
name|ENOTDIR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ZTOV
argument_list|(
name|tzp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
name|error
operator|=
name|EISDIR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 		 * POSIX dictates that when the source and target 		 * entries refer to the same file object, rename 		 * must do nothing and exit without error. 		 */
if|if
condition|(
name|szp
operator|->
name|z_id
operator|==
name|tzp
operator|->
name|z_id
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|vnevent_rename_src
argument_list|(
name|ZTOV
argument_list|(
name|szp
argument_list|)
argument_list|,
name|sdvp
argument_list|,
name|snm
argument_list|,
name|ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|tzp
condition|)
name|vnevent_rename_dest
argument_list|(
name|ZTOV
argument_list|(
name|tzp
argument_list|)
argument_list|,
name|tdvp
argument_list|,
name|tnm
argument_list|,
name|ct
argument_list|)
expr_stmt|;
comment|/* 	 * notify the target directory if it is not the same 	 * as source directory. 	 */
if|if
condition|(
name|tdvp
operator|!=
name|sdvp
condition|)
block|{
name|vnevent_rename_dest_dir
argument_list|(
name|tdvp
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|szp
operator|->
name|z_id
argument_list|)
expr_stmt|;
comment|/* nlink changes */
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|sdzp
operator|->
name|z_id
argument_list|)
expr_stmt|;
comment|/* nlink changes */
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|sdzp
operator|->
name|z_id
argument_list|,
name|FALSE
argument_list|,
name|snm
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|tdzp
operator|->
name|z_id
argument_list|,
name|TRUE
argument_list|,
name|tnm
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdzp
operator|!=
name|tdzp
condition|)
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|tdzp
operator|->
name|z_id
argument_list|)
expr_stmt|;
comment|/* nlink changes */
if|if
condition|(
name|tzp
condition|)
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|tzp
operator|->
name|z_id
argument_list|)
expr_stmt|;
comment|/* parent changes */
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_unlinkedobj
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_assign
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|zl
operator|!=
name|NULL
condition|)
name|zfs_rename_unlock
argument_list|(
operator|&
name|zl
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|sdl
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|tdl
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|szp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tzp
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|tzp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|&&
name|zfsvfs
operator|->
name|z_assign
operator|==
name|TXG_NOWAIT
condition|)
block|{
name|dmu_tx_wait
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|tzp
condition|)
comment|/* Attempt to remove the existing target */
name|error
operator|=
name|zfs_link_destroy
argument_list|(
name|tdl
argument_list|,
name|tzp
argument_list|,
name|tx
argument_list|,
name|zflg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|zfs_link_create
argument_list|(
name|tdl
argument_list|,
name|szp
argument_list|,
name|tx
argument_list|,
name|ZRENAMING
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|szp
operator|->
name|z_phys
operator|->
name|zp_flags
operator||=
name|ZFS_AV_MODIFIED
expr_stmt|;
name|error
operator|=
name|zfs_link_destroy
argument_list|(
name|sdl
argument_list|,
name|szp
argument_list|,
name|tx
argument_list|,
name|ZRENAMING
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zfs_log_rename
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|TX_RENAME
operator||
operator|(
name|flags
operator|&
name|FIGNORECASE
condition|?
name|TX_CI
else|:
literal|0
operator|)
argument_list|,
name|sdzp
argument_list|,
name|sdl
operator|->
name|dl_name
argument_list|,
name|tdzp
argument_list|,
name|tdl
operator|->
name|dl_name
argument_list|,
name|szp
argument_list|)
expr_stmt|;
comment|/* Update path information for the target vnode */
name|vn_renamepath
argument_list|(
name|tdvp
argument_list|,
name|ZTOV
argument_list|(
name|szp
argument_list|)
argument_list|,
name|tnm
argument_list|,
name|strlen
argument_list|(
name|tnm
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|FREEBSD_NAMECACHE
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|cache_purge
argument_list|(
name|sdvp
argument_list|)
expr_stmt|;
name|cache_purge
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|zl
operator|!=
name|NULL
condition|)
name|zfs_rename_unlock
argument_list|(
operator|&
name|zl
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|sdl
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|tdl
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|szp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tzp
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|tzp
argument_list|)
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert the indicated symbolic reference entry into the directory.  *  *	IN:	dvp	- Directory to contain new symbolic link.  *		link	- Name for new symlink entry.  *		vap	- Attributes of new entry.  *		target	- Target path of new symlink.  *		cr	- credentials of caller.  *		ct	- caller context  *		flags	- case flags  *  *	RETURN:	0 if success  *		error code if failure  *  * Timestamps:  *	dvp - ctime|mtime updated  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_symlink
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|char
modifier|*
name|link
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|kthread_t
modifier|*
name|td
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
decl_stmt|,
modifier|*
name|dzp
init|=
name|VTOZ
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|zfs_dirlock_t
modifier|*
name|dl
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|link
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|zflg
init|=
name|ZNEW
decl_stmt|;
name|zfs_fuid_info_t
modifier|*
name|fuidp
init|=
name|NULL
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|vap
operator|->
name|va_type
operator|==
name|VLNK
argument_list|)
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|dzp
argument_list|)
expr_stmt|;
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_utf8
operator|&&
name|u8_validate
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|U8_VALIDATE_ENTIRE
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EILSEQ
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
condition|)
name|zflg
operator||=
name|ZCILOOK
expr_stmt|;
name|top
label|:
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|dzp
argument_list|,
name|ACE_ADD_FILE
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|>
name|MAXPATHLEN
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
block|}
comment|/* 	 * Attempt to lock directory; fail if entry already exists. 	 */
name|error
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|dl
argument_list|,
name|dzp
argument_list|,
name|name
argument_list|,
operator|&
name|zp
argument_list|,
name|zflg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|MAX
argument_list|(
literal|1
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|TRUE
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dzp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_INHERIT_ACE
condition|)
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_EPHEMERAL
argument_list|(
name|crgetuid
argument_list|(
name|cr
argument_list|)
argument_list|)
operator|||
name|IS_EPHEMERAL
argument_list|(
name|crgetgid
argument_list|(
name|cr
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|zfsvfs
operator|->
name|z_fuid_obj
operator|==
literal|0
condition|)
block|{
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|FUID_SIZE_ESTIMATE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_fuid_obj
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_fuid_obj
argument_list|,
literal|0
argument_list|,
name|FUID_SIZE_ESTIMATE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_assign
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|&&
name|zfsvfs
operator|->
name|z_assign
operator|==
name|TXG_NOWAIT
condition|)
block|{
name|dmu_tx_wait
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|dmu_buf_will_dirty
argument_list|(
name|dzp
operator|->
name|z_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Create a new object for the symlink. 	 * Put the link content into bonus buffer if it will fit; 	 * otherwise, store it just like any other file data. 	 */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|znode_phys_t
argument_list|)
operator|+
name|len
operator|<=
name|dmu_bonus_max
argument_list|()
condition|)
block|{
name|zfs_mknode
argument_list|(
name|dzp
argument_list|,
name|vap
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
literal|0
argument_list|,
operator|&
name|zp
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
operator|&
name|fuidp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
name|bcopy
argument_list|(
name|link
argument_list|,
name|zp
operator|->
name|z_phys
operator|+
literal|1
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_buf_t
modifier|*
name|dbp
decl_stmt|;
name|zfs_mknode
argument_list|(
name|dzp
argument_list|,
name|vap
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
literal|0
argument_list|,
operator|&
name|zp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|&
name|fuidp
argument_list|)
expr_stmt|;
comment|/* 		 * Nothing can access the znode yet so no locking needed 		 * for growing the znode's blocksize. 		 */
name|zfs_grow_blocksize
argument_list|(
name|zp
argument_list|,
name|len
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_buf_hold
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
literal|0
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dbp
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|dbp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|len
argument_list|,
operator|<=
argument_list|,
name|dbp
operator|->
name|db_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|link
argument_list|,
name|dbp
operator|->
name|db_data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|dbp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|zp
operator|->
name|z_phys
operator|->
name|zp_size
operator|=
name|len
expr_stmt|;
comment|/* 	 * Insert the new object into the directory. 	 */
operator|(
name|void
operator|)
name|zfs_link_create
argument_list|(
name|dl
argument_list|,
name|zp
argument_list|,
name|tx
argument_list|,
name|ZNEW
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|txtype
init|=
name|TX_SYMLINK
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
condition|)
name|txtype
operator||=
name|TX_CI
expr_stmt|;
name|zfs_log_symlink
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|txtype
argument_list|,
name|dzp
argument_list|,
name|zp
argument_list|,
name|name
argument_list|,
name|link
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fuidp
condition|)
name|zfs_fuid_info_free
argument_list|(
name|fuidp
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return, in the buffer contained in the provided uio structure,  * the symbolic path referred to by vp.  *  *	IN:	vp	- vnode of symbolic link.  *		uoip	- structure to contain the link path.  *		cr	- credentials of caller.  *		ct	- caller context  *  *	OUT:	uio	- structure to contain the link path.  *  *	RETURN:	0 if success  *		error code if failure  *  * Timestamps:  *	vp - atime updated  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_readlink
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|size_t
name|bufsz
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|bufsz
operator|=
operator|(
name|size_t
operator|)
name|zp
operator|->
name|z_phys
operator|->
name|zp_size
expr_stmt|;
if|if
condition|(
name|bufsz
operator|+
sizeof|sizeof
argument_list|(
name|znode_phys_t
argument_list|)
operator|<=
name|zp
operator|->
name|z_dbuf
operator|->
name|db_size
condition|)
block|{
name|error
operator|=
name|uiomove
argument_list|(
name|zp
operator|->
name|z_phys
operator|+
literal|1
argument_list|,
name|MIN
argument_list|(
operator|(
name|size_t
operator|)
name|bufsz
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_buf_t
modifier|*
name|dbp
decl_stmt|;
name|error
operator|=
name|dmu_buf_hold
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
literal|0
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|uiomove
argument_list|(
name|dbp
operator|->
name|db_data
argument_list|,
name|MIN
argument_list|(
operator|(
name|size_t
operator|)
name|bufsz
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|dbp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|ZFS_ACCESSTIME_STAMP
argument_list|(
name|zfsvfs
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert a new entry into directory tdvp referencing svp.  *  *	IN:	tdvp	- Directory to contain new entry.  *		svp	- vnode of new entry.  *		name	- name of new entry.  *		cr	- credentials of caller.  *		ct	- caller context  *  *	RETURN:	0 if success  *		error code if failure  *  * Timestamps:  *	tdvp - ctime|mtime updated  *	 svp - ctime updated  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_link
parameter_list|(
name|vnode_t
modifier|*
name|tdvp
parameter_list|,
name|vnode_t
modifier|*
name|svp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|znode_t
modifier|*
name|dzp
init|=
name|VTOZ
argument_list|(
name|tdvp
argument_list|)
decl_stmt|;
name|znode_t
modifier|*
name|tzp
decl_stmt|,
modifier|*
name|szp
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|zfs_dirlock_t
modifier|*
name|dl
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|vnode_t
modifier|*
name|realvp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|zf
init|=
name|ZNEW
decl_stmt|;
name|uid_t
name|owner
decl_stmt|;
name|ASSERT
argument_list|(
name|tdvp
operator|->
name|v_type
operator|==
name|VDIR
argument_list|)
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|dzp
argument_list|)
expr_stmt|;
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
if|if
condition|(
name|VOP_REALVP
argument_list|(
name|svp
argument_list|,
operator|&
name|realvp
argument_list|,
name|ct
argument_list|)
operator|==
literal|0
condition|)
name|svp
operator|=
name|realvp
expr_stmt|;
if|if
condition|(
name|svp
operator|->
name|v_vfsp
operator|!=
name|tdvp
operator|->
name|v_vfsp
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EXDEV
operator|)
return|;
block|}
name|szp
operator|=
name|VTOZ
argument_list|(
name|svp
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|szp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_utf8
operator|&&
name|u8_validate
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|U8_VALIDATE_ENTIRE
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EILSEQ
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
condition|)
name|zf
operator||=
name|ZCILOOK
expr_stmt|;
name|top
label|:
comment|/* 	 * We do not support links between attributes and non-attributes 	 * because of the potential security risk of creating links 	 * into "normal" file space in order to circumvent restrictions 	 * imposed in attribute space. 	 */
if|if
condition|(
operator|(
name|szp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_XATTR
operator|)
operator|!=
operator|(
name|dzp
operator|->
name|z_phys
operator|->
name|zp_flags
operator|&
name|ZFS_XATTR
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * POSIX dictates that we return EPERM here. 	 * Better choices include ENOTSUP or EISDIR. 	 */
if|if
condition|(
name|svp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|owner
operator|=
name|zfs_fuid_map_id
argument_list|(
name|zfsvfs
argument_list|,
name|szp
operator|->
name|z_phys
operator|->
name|zp_uid
argument_list|,
name|cr
argument_list|,
name|ZFS_OWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|!=
name|crgetuid
argument_list|(
name|cr
argument_list|)
operator|&&
name|secpolicy_basic_link
argument_list|(
name|svp
argument_list|,
name|cr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|dzp
argument_list|,
name|ACE_ADD_FILE
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Attempt to lock directory; fail if entry already exists. 	 */
name|error
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|dl
argument_list|,
name|dzp
argument_list|,
name|name
argument_list|,
operator|&
name|tzp
argument_list|,
name|zf
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|szp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|TRUE
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_assign
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
operator|&&
name|zfsvfs
operator|->
name|z_assign
operator|==
name|TXG_NOWAIT
condition|)
block|{
name|dmu_tx_wait
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|zfs_link_create
argument_list|(
name|dl
argument_list|,
name|szp
argument_list|,
name|tx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|txtype
init|=
name|TX_LINK
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
condition|)
name|txtype
operator||=
name|TX_CI
expr_stmt|;
name|zfs_log_link
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|txtype
argument_list|,
name|dzp
argument_list|,
name|szp
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|vnevent_link
argument_list|(
name|svp
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|zfs_inactive
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|rw_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_dbuf
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * The fs has been unmounted, or we did a 		 * suspend/resume and this file no longer exists. 		 */
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_count
operator|=
literal|0
expr_stmt|;
comment|/* count arrives as 1 */
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vrecycle
argument_list|(
name|vp
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|zp
operator|->
name|z_atime_dirty
operator|&&
name|zp
operator|->
name|z_unlinked
operator|==
literal|0
condition|)
block|{
name|dmu_tx_t
modifier|*
name|tx
init|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
decl_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_buf_will_dirty
argument_list|(
name|zp
operator|->
name|z_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_atime_dirty
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
name|zfs_zinactive
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|zfid_short
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|fid
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|zfid_long
argument_list|)
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|fid
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_fid
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|fid_t
modifier|*
name|fidp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|uint32_t
name|gen
decl_stmt|;
name|uint64_t
name|object
init|=
name|zp
operator|->
name|z_id
decl_stmt|;
name|zfid_short_t
modifier|*
name|zfid
decl_stmt|;
name|int
name|size
decl_stmt|,
name|i
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|gen
operator|=
operator|(
name|uint32_t
operator|)
name|zp
operator|->
name|z_gen
expr_stmt|;
name|size
operator|=
operator|(
name|zfsvfs
operator|->
name|z_parent
operator|!=
name|zfsvfs
operator|)
condition|?
name|LONG_FID_LEN
else|:
name|SHORT_FID_LEN
expr_stmt|;
name|fidp
operator|->
name|fid_len
operator|=
name|size
expr_stmt|;
name|zfid
operator|=
operator|(
name|zfid_short_t
operator|*
operator|)
name|fidp
expr_stmt|;
name|zfid
operator|->
name|zf_len
operator|=
name|size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zfid
operator|->
name|zf_object
argument_list|)
condition|;
name|i
operator|++
control|)
name|zfid
operator|->
name|zf_object
index|[
name|i
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|object
operator|>>
operator|(
literal|8
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
comment|/* Must have a non-zero generation number to distinguish from .zfs */
if|if
condition|(
name|gen
operator|==
literal|0
condition|)
name|gen
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zfid
operator|->
name|zf_gen
argument_list|)
condition|;
name|i
operator|++
control|)
name|zfid
operator|->
name|zf_gen
index|[
name|i
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|gen
operator|>>
operator|(
literal|8
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|LONG_FID_LEN
condition|)
block|{
name|uint64_t
name|objsetid
init|=
name|dmu_objset_id
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
decl_stmt|;
name|zfid_long_t
modifier|*
name|zlfid
decl_stmt|;
name|zlfid
operator|=
operator|(
name|zfid_long_t
operator|*
operator|)
name|fidp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zlfid
operator|->
name|zf_setid
argument_list|)
condition|;
name|i
operator|++
control|)
name|zlfid
operator|->
name|zf_setid
index|[
name|i
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|objsetid
operator|>>
operator|(
literal|8
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX - this should be the generation number for the objset */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zlfid
operator|->
name|zf_setgen
argument_list|)
condition|;
name|i
operator|++
control|)
name|zlfid
operator|->
name|zf_setgen
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_pathconf
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|ulong_t
modifier|*
name|valp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
decl_stmt|,
modifier|*
name|xzp
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
decl_stmt|;
name|zfs_dirlock_t
modifier|*
name|dl
decl_stmt|;
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|_PC_LINK_MAX
case|:
operator|*
name|valp
operator|=
name|INT_MAX
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_FILESIZEBITS
case|:
operator|*
name|valp
operator|=
literal|64
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
literal|0
block|case _PC_XATTR_EXISTS: 		zp = VTOZ(vp); 		zfsvfs = zp->z_zfsvfs; 		ZFS_ENTER(zfsvfs); 		ZFS_VERIFY_ZP(zp); 		*valp = 0; 		error = zfs_dirent_lock(&dl, zp, "",&xzp, 		    ZXATTR | ZEXISTS | ZSHARED, NULL, NULL); 		if (error == 0) { 			zfs_dirent_unlock(dl); 			if (!zfs_dirempty(xzp)) 				*valp = 1; 			VN_RELE(ZTOV(xzp)); 		} else if (error == ENOENT) {
comment|/* 			 * If there aren't extended attributes, it's the 			 * same as having zero of them. 			 */
block|error = 0; 		} 		ZFS_EXIT(zfsvfs); 		return (error);
endif|#
directive|endif
case|case
name|_PC_ACL_EXTENDED
case|:
operator|*
name|valp
operator|=
literal|0
expr_stmt|;
comment|/* TODO */
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_MIN_HOLE_SIZE
case|:
operator|*
name|valp
operator|=
operator|(
name|int
operator|)
name|SPA_MINBLOCKSIZE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_getsecattr
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|,
name|int
name|flag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|boolean_t
name|skipaclchk
init|=
operator|(
name|flag
operator|&
name|ATTR_NOACLCHECK
operator|)
condition|?
name|B_TRUE
else|:
name|B_FALSE
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_getacl
argument_list|(
name|zp
argument_list|,
name|vsecp
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_setsecattr
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|,
name|int
name|flag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|boolean_t
name|skipaclchk
init|=
operator|(
name|flag
operator|&
name|ATTR_NOACLCHECK
operator|)
condition|?
name|B_TRUE
else|:
name|B_FALSE
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_setacl
argument_list|(
name|zp
argument_list|,
name|vsecp
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_open
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_open_args
comment|/* { 		struct vnode *a_vp; 		int a_mode; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|vnode_t
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|zfs_open
argument_list|(
operator|&
name|vp
argument_list|,
name|ap
operator|->
name|a_mode
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|vnode_create_vobject
argument_list|(
name|vp
argument_list|,
name|zp
operator|->
name|z_phys
operator|->
name|zp_size
argument_list|,
name|ap
operator|->
name|a_td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_close
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_close_args
comment|/* { 		struct vnode *a_vp; 		int  a_fflag; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|zfs_close
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_fflag
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_ioctl
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_ioctl_args
comment|/* { 		struct vnode *a_vp; 		u_long a_command; 		caddr_t a_data; 		int a_fflag; 		struct ucred *cred; 		struct thread *td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|zfs_ioctl
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_command
argument_list|,
operator|(
name|intptr_t
operator|)
name|ap
operator|->
name|a_data
argument_list|,
name|ap
operator|->
name|a_fflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_read
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_read_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|zfs_read
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_ioflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_write
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_write_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		int a_ioflag; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|zfs_write
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_ioflag
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_access
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_access_args
comment|/* { 		struct vnode *a_vp; 		accmode_t a_accmode; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
comment|/* 	 * ZFS itself only knowns about VREAD, VWRITE and VEXEC, the rest 	 * we have to handle by calling vaccess(). 	 */
if|if
condition|(
operator|(
name|ap
operator|->
name|a_accmode
operator|&
operator|~
operator|(
name|VREAD
operator||
name|VWRITE
operator||
name|VEXEC
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|vnode_t
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|znode_phys_t
modifier|*
name|zphys
init|=
name|zp
operator|->
name|z_phys
decl_stmt|;
return|return
operator|(
name|vaccess
argument_list|(
name|vp
operator|->
name|v_type
argument_list|,
name|zphys
operator|->
name|zp_mode
argument_list|,
name|zphys
operator|->
name|zp_uid
argument_list|,
name|zphys
operator|->
name|zp_gid
argument_list|,
name|ap
operator|->
name|a_accmode
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|zfs_access
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_accmode
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_lookup
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_lookup_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|char
name|nm
index|[
name|NAME_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|cnp
operator|->
name|cn_namelen
operator|<
sizeof|sizeof
argument_list|(
name|nm
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|nm
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|MIN
argument_list|(
name|cnp
operator|->
name|cn_namelen
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|nm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_lookup
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
name|nm
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|cnp
argument_list|,
name|cnp
operator|->
name|cn_nameiop
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_create
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_create_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|vattr_t
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|ASSERT
argument_list|(
name|cnp
operator|->
name|cn_flags
operator|&
name|SAVENAME
argument_list|)
expr_stmt|;
name|vattr_init_mask
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|mode
operator|=
name|vap
operator|->
name|va_mode
operator|&
name|ALLPERMS
expr_stmt|;
return|return
operator|(
name|zfs_create
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|vap
argument_list|,
operator|!
name|EXCL
argument_list|,
name|mode
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_remove
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_remove_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|ASSERT
argument_list|(
name|ap
operator|->
name|a_cnp
operator|->
name|cn_flags
operator|&
name|SAVENAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_remove
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
name|ap
operator|->
name|a_cnp
operator|->
name|cn_nameptr
argument_list|,
name|ap
operator|->
name|a_cnp
operator|->
name|cn_cred
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_mkdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_mkdir_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|vattr_t
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|ASSERT
argument_list|(
name|ap
operator|->
name|a_cnp
operator|->
name|cn_flags
operator|&
name|SAVENAME
argument_list|)
expr_stmt|;
name|vattr_init_mask
argument_list|(
name|vap
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_mkdir
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
name|ap
operator|->
name|a_cnp
operator|->
name|cn_nameptr
argument_list|,
name|vap
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|ap
operator|->
name|a_cnp
operator|->
name|cn_cred
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_rmdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_rmdir_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|ASSERT
argument_list|(
name|cnp
operator|->
name|cn_flags
operator|&
name|SAVENAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_rmdir
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|NULL
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_readdir
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_readdir_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 		int *a_eofflag; 		int *a_ncookies; 		u_long **a_cookies; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|zfs_readdir
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_eofflag
argument_list|,
name|ap
operator|->
name|a_ncookies
argument_list|,
name|ap
operator|->
name|a_cookies
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_fsync
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_fsync_args
comment|/* { 		struct vnode *a_vp; 		int a_waitfor; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|vop_stdfsync
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_fsync
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_td
operator|->
name|td_ucred
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_getattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_getattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|vattr_t
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|xvattr_t
name|xvap
decl_stmt|;
name|u_long
name|fflags
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|xva_init
argument_list|(
operator|&
name|xvap
argument_list|)
expr_stmt|;
name|xvap
operator|.
name|xva_vattr
operator|=
operator|*
name|vap
expr_stmt|;
name|xvap
operator|.
name|xva_vattr
operator|.
name|va_mask
operator||=
name|AT_XVATTR
expr_stmt|;
comment|/* Convert chflags into ZFS-type flags. */
comment|/* XXX: what about SF_SETTABLE?. */
name|XVA_SET_REQ
argument_list|(
operator|&
name|xvap
argument_list|,
name|XAT_IMMUTABLE
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|xvap
argument_list|,
name|XAT_APPENDONLY
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|xvap
argument_list|,
name|XAT_NOUNLINK
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|xvap
argument_list|,
name|XAT_NODUMP
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_getattr
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
operator|(
name|vattr_t
operator|*
operator|)
operator|&
name|xvap
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Convert ZFS xattr into chflags. */
define|#
directive|define
name|FLAG_CHECK
parameter_list|(
name|fflag
parameter_list|,
name|xflag
parameter_list|,
name|xfield
parameter_list|)
value|do {			\ 	if (XVA_ISSET_RTN(&xvap, (xflag))&& (xfield) != 0)		\ 		fflags |= (fflag);					\ } while (0)
name|FLAG_CHECK
argument_list|(
name|SF_IMMUTABLE
argument_list|,
name|XAT_IMMUTABLE
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_immutable
argument_list|)
expr_stmt|;
name|FLAG_CHECK
argument_list|(
name|SF_APPEND
argument_list|,
name|XAT_APPENDONLY
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_appendonly
argument_list|)
expr_stmt|;
name|FLAG_CHECK
argument_list|(
name|SF_NOUNLINK
argument_list|,
name|XAT_NOUNLINK
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_nounlink
argument_list|)
expr_stmt|;
name|FLAG_CHECK
argument_list|(
name|UF_NODUMP
argument_list|,
name|XAT_NODUMP
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_nodump
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|FLAG_CHECK
operator|*
name|vap
operator|=
name|xvap
operator|.
name|xva_vattr
expr_stmt|;
name|vap
operator|->
name|va_flags
operator|=
name|fflags
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_setattr
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_setattr_args
comment|/* { 		struct vnode *a_vp; 		struct vattr *a_vap; 		struct ucred *a_cred; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|vnode_t
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|vattr_t
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|cred_t
modifier|*
name|cred
init|=
name|ap
operator|->
name|a_cred
decl_stmt|;
name|xvattr_t
name|xvap
decl_stmt|;
name|u_long
name|fflags
decl_stmt|;
name|uint64_t
name|zflags
decl_stmt|;
name|vattr_init_mask
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_mask
operator|&=
operator|~
name|AT_NOSET
expr_stmt|;
name|xva_init
argument_list|(
operator|&
name|xvap
argument_list|)
expr_stmt|;
name|xvap
operator|.
name|xva_vattr
operator|=
operator|*
name|vap
expr_stmt|;
name|zflags
operator|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
operator|->
name|z_phys
operator|->
name|zp_flags
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_flags
operator|!=
name|VNOVAL
condition|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_use_fuids
operator|==
name|B_FALSE
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|fflags
operator|=
name|vap
operator|->
name|va_flags
expr_stmt|;
if|if
condition|(
operator|(
name|fflags
operator|&
operator|~
operator|(
name|SF_IMMUTABLE
operator||
name|SF_APPEND
operator||
name|SF_NOUNLINK
operator||
name|UF_NODUMP
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
comment|/* 		 * Callers may only modify the file flags on objects they 		 * have VADMIN rights for. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VADMIN
argument_list|,
name|cred
argument_list|,
name|curthread
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * Unprivileged processes are not permitted to unset system 		 * flags, or modify flags if any system flags are set. 		 * Privileged non-jail processes may not modify system flags 		 * if securelevel> 0 and any existing system flags are set. 		 * Privileged jail processes behave like privileged non-jail 		 * processes if the security.jail.chflags_allowed sysctl is 		 * is non-zero; otherwise, they behave like unprivileged 		 * processes. 		 */
if|if
condition|(
name|priv_check_cred
argument_list|(
name|cred
argument_list|,
name|PRIV_VFS_SYSFLAGS
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|zflags
operator|&
operator|(
name|ZFS_IMMUTABLE
operator||
name|ZFS_APPENDONLY
operator||
name|ZFS_NOUNLINK
operator|)
condition|)
block|{
name|error
operator|=
name|securelevel_gt
argument_list|(
name|cred
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|zflags
operator|&
operator|(
name|ZFS_IMMUTABLE
operator||
name|ZFS_APPENDONLY
operator||
name|ZFS_NOUNLINK
operator|)
condition|)
block|{
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
if|if
condition|(
name|fflags
operator|&
operator|(
name|SF_IMMUTABLE
operator||
name|SF_APPEND
operator||
name|SF_NOUNLINK
operator|)
condition|)
block|{
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
block|}
define|#
directive|define
name|FLAG_CHANGE
parameter_list|(
name|fflag
parameter_list|,
name|zflag
parameter_list|,
name|xflag
parameter_list|,
name|xfield
parameter_list|)
value|do {		\ 	if (((fflags& (fflag))&& !(zflags& (zflag))) ||		\ 	    ((zflags& (zflag))&& !(fflags& (fflag)))) {		\ 		XVA_SET_REQ(&xvap, (xflag));				\ 		(xfield) = ((fflags& (fflag)) != 0);			\ 	}								\ } while (0)
comment|/* Convert chflags into ZFS-type flags. */
comment|/* XXX: what about SF_SETTABLE?. */
name|FLAG_CHANGE
argument_list|(
name|SF_IMMUTABLE
argument_list|,
name|ZFS_IMMUTABLE
argument_list|,
name|XAT_IMMUTABLE
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_immutable
argument_list|)
expr_stmt|;
name|FLAG_CHANGE
argument_list|(
name|SF_APPEND
argument_list|,
name|ZFS_APPENDONLY
argument_list|,
name|XAT_APPENDONLY
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_appendonly
argument_list|)
expr_stmt|;
name|FLAG_CHANGE
argument_list|(
name|SF_NOUNLINK
argument_list|,
name|ZFS_NOUNLINK
argument_list|,
name|XAT_NOUNLINK
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_nounlink
argument_list|)
expr_stmt|;
name|FLAG_CHANGE
argument_list|(
name|UF_NODUMP
argument_list|,
name|ZFS_NODUMP
argument_list|,
name|XAT_NODUMP
argument_list|,
name|xvap
operator|.
name|xva_xoptattrs
operator|.
name|xoa_nodump
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|FLAG_CHANGE
block|}
return|return
operator|(
name|zfs_setattr
argument_list|(
name|vp
argument_list|,
operator|(
name|vattr_t
operator|*
operator|)
operator|&
name|xvap
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_rename
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_rename_args
comment|/* { 		struct vnode *a_fdvp; 		struct vnode *a_fvp; 		struct componentname *a_fcnp; 		struct vnode *a_tdvp; 		struct vnode *a_tvp; 		struct componentname *a_tcnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|vnode_t
modifier|*
name|fdvp
init|=
name|ap
operator|->
name|a_fdvp
decl_stmt|;
name|vnode_t
modifier|*
name|fvp
init|=
name|ap
operator|->
name|a_fvp
decl_stmt|;
name|vnode_t
modifier|*
name|tdvp
init|=
name|ap
operator|->
name|a_tdvp
decl_stmt|;
name|vnode_t
modifier|*
name|tvp
init|=
name|ap
operator|->
name|a_tvp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|ap
operator|->
name|a_fcnp
operator|->
name|cn_flags
operator|&
operator|(
name|SAVENAME
operator||
name|SAVESTART
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ap
operator|->
name|a_tcnp
operator|->
name|cn_flags
operator|&
operator|(
name|SAVENAME
operator||
name|SAVESTART
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_rename
argument_list|(
name|fdvp
argument_list|,
name|ap
operator|->
name|a_fcnp
operator|->
name|cn_nameptr
argument_list|,
name|tdvp
argument_list|,
name|ap
operator|->
name|a_tcnp
operator|->
name|cn_nameptr
argument_list|,
name|ap
operator|->
name|a_fcnp
operator|->
name|cn_cred
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdvp
operator|==
name|tvp
condition|)
name|VN_RELE
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
else|else
name|VN_URELE
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tvp
condition|)
name|VN_URELE
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|fdvp
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_symlink
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_symlink_args
comment|/* { 		struct vnode *a_dvp; 		struct vnode **a_vpp; 		struct componentname *a_cnp; 		struct vattr *a_vap; 		char *a_target; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|vattr_t
modifier|*
name|vap
init|=
name|ap
operator|->
name|a_vap
decl_stmt|;
name|ASSERT
argument_list|(
name|cnp
operator|->
name|cn_flags
operator|&
name|SAVENAME
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_type
operator|=
name|VLNK
expr_stmt|;
comment|/* FreeBSD: Syscall only sets va_mode. */
name|vattr_init_mask
argument_list|(
name|vap
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_symlink
argument_list|(
name|ap
operator|->
name|a_dvp
argument_list|,
name|ap
operator|->
name|a_vpp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|vap
argument_list|,
name|ap
operator|->
name|a_target
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|cnp
operator|->
name|cn_thread
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_readlink
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_readlink_args
comment|/* { 		struct vnode *a_vp; 		struct uio *a_uio; 		struct ucred *a_cred; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|zfs_readlink
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_link
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_link_args
comment|/* { 		struct vnode *a_tdvp; 		struct vnode *a_vp; 		struct componentname *a_cnp; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|componentname
modifier|*
name|cnp
init|=
name|ap
operator|->
name|a_cnp
decl_stmt|;
name|ASSERT
argument_list|(
name|cnp
operator|->
name|cn_flags
operator|&
name|SAVENAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_link
argument_list|(
name|ap
operator|->
name|a_tdvp
argument_list|,
name|ap
operator|->
name|a_vp
argument_list|,
name|cnp
operator|->
name|cn_nameptr
argument_list|,
name|cnp
operator|->
name|cn_cred
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_inactive
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_inactive_args
comment|/* { 		struct vnode *a_vp; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|vnode_t
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|zfs_inactive
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_td
operator|->
name|td_ucred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_reclaim_complete
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|arg
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|rw_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_dbuf
operator|!=
name|NULL
condition|)
block|{
name|ZFS_OBJ_HOLD_ENTER
argument_list|(
name|zfsvfs
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|zfs_znode_dmu_fini
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|ZFS_OBJ_HOLD_EXIT
argument_list|(
name|zfsvfs
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
block|}
name|zfs_znode_free
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If the file system is being unmounted, there is a process waiting 	 * for us, wake it up. 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_unmounted
condition|)
name|wakeup_one
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_reclaim
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_reclaim_args
comment|/* { 		struct vnode *a_vp; 		struct thread *a_td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|vnode_t
modifier|*
name|vp
init|=
name|ap
operator|->
name|a_vp
decl_stmt|;
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|rw_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Destroy the vm object and flush associated pages. 	 */
name|vnode_destroy_vobject
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zp
operator|->
name|z_phys
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_vnode
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_unlinked
condition|)
empty_stmt|;
comment|/* Do nothing. */
elseif|else
if|if
condition|(
name|zp
operator|->
name|z_dbuf
operator|==
name|NULL
condition|)
name|zfs_znode_free
argument_list|(
name|zp
argument_list|)
expr_stmt|;
else|else
comment|/* if (!zp->z_unlinked&& zp->z_dbuf != NULL) */
block|{
name|int
name|locked
decl_stmt|;
name|locked
operator|=
name|MUTEX_HELD
argument_list|(
name|ZFS_OBJ_MUTEX
argument_list|(
name|zfsvfs
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
argument_list|)
condition|?
literal|2
else|:
name|ZFS_OBJ_HOLD_TRYENTER
argument_list|(
name|zfsvfs
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Lock can't be obtained due to deadlock possibility, 			 * so defer znode destruction. 			 */
name|TASK_INIT
argument_list|(
operator|&
name|zp
operator|->
name|z_task
argument_list|,
literal|0
argument_list|,
name|zfs_reclaim_complete
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|zp
operator|->
name|z_task
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfs_znode_dmu_fini
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
operator|==
literal|1
condition|)
name|ZFS_OBJ_HOLD_EXIT
argument_list|(
name|zfsvfs
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|zfs_znode_free
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
block|}
name|VI_LOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|NULL
expr_stmt|;
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_holdcnt
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|VI_UNLOCK
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_fid
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_fid_args
comment|/* { 		struct vnode *a_vp; 		struct fid *a_fid; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|zfs_fid
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ap
operator|->
name|a_fid
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_freebsd_pathconf
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_pathconf_args
comment|/* { 		struct vnode *a_vp; 		int a_name; 		register_t *a_retval; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|ulong_t
name|val
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|zfs_pathconf
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_name
argument_list|,
operator|&
name|val
argument_list|,
name|curthread
operator|->
name|td_ucred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
name|ap
operator|->
name|a_retval
operator|=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|==
name|EOPNOTSUPP
condition|)
name|error
operator|=
name|vop_stdpathconf
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * FreeBSD's extended attributes namespace defines file name prefix for ZFS'  * extended attribute name:  *  *	NAMESPACE	PREFIX	  *	system		freebsd:system:  *	user		(none, can be used to access ZFS fsattr(5) attributes  *			created on Solaris)  */
end_comment

begin_function
specifier|static
name|int
name|zfs_create_attrname
parameter_list|(
name|int
name|attrnamespace
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|attrname
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|namespace
decl_stmt|,
modifier|*
name|prefix
decl_stmt|,
modifier|*
name|suffix
decl_stmt|;
comment|/* We don't allow '/' character in attribute name. */
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* We don't allow attribute names that start with "freebsd:" string. */
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"freebsd:"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bzero
argument_list|(
name|attrname
argument_list|,
name|size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|attrnamespace
condition|)
block|{
case|case
name|EXTATTR_NAMESPACE_USER
case|:
if|#
directive|if
literal|0
block|prefix = "freebsd:"; 		namespace = EXTATTR_NAMESPACE_USER_STRING; 		suffix = ":";
else|#
directive|else
comment|/* 		 * This is the default namespace by which we can access all 		 * attributes created on Solaris. 		 */
name|prefix
operator|=
name|namespace
operator|=
name|suffix
operator|=
literal|""
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|EXTATTR_NAMESPACE_SYSTEM
case|:
name|prefix
operator|=
literal|"freebsd:"
expr_stmt|;
name|namespace
operator|=
name|EXTATTR_NAMESPACE_SYSTEM_STRING
expr_stmt|;
name|suffix
operator|=
literal|":"
expr_stmt|;
break|break;
case|case
name|EXTATTR_NAMESPACE_EMPTY
case|:
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|snprintf
argument_list|(
name|attrname
argument_list|,
name|size
argument_list|,
literal|"%s%s%s%s"
argument_list|,
name|prefix
argument_list|,
name|namespace
argument_list|,
name|suffix
argument_list|,
name|name
argument_list|)
operator|>=
name|size
condition|)
block|{
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Vnode operating to retrieve a named extended attribute.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_getextattr
parameter_list|(
name|struct
name|vop_getextattr_args
modifier|*
name|ap
parameter_list|)
comment|/* vop_getextattr { 	IN struct vnode *a_vp; 	IN int a_attrnamespace; 	IN const char *a_name; 	INOUT struct uio *a_uio; 	OUT size_t *a_size; 	IN struct ucred *a_cred; 	IN struct thread *a_td; }; */
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|VTOZ
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|->
name|z_zfsvfs
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|char
name|attrname
index|[
literal|255
index|]
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
name|vnode_t
modifier|*
name|xvp
init|=
name|NULL
decl_stmt|,
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|;
name|error
operator|=
name|extattr_check_cred
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_attrnamespace
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
name|VREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|zfs_create_attrname
argument_list|(
name|ap
operator|->
name|a_attrnamespace
argument_list|,
name|ap
operator|->
name|a_name
argument_list|,
name|attrname
argument_list|,
sizeof|sizeof
argument_list|(
name|attrname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_lookup
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|NULL
argument_list|,
operator|&
name|xvp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|,
name|LOOKUP_XATTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|flags
operator|=
name|FREAD
expr_stmt|;
name|NDINIT_ATVP
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|NOFOLLOW
operator||
name|MPSAFE
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|attrname
argument_list|,
name|xvp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_open_cred
argument_list|(
operator|&
name|nd
argument_list|,
operator|&
name|flags
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
name|ENOATTR
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|ap
operator|->
name|a_size
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|va
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
name|ap
operator|->
name|a_size
operator|=
operator|(
name|size_t
operator|)
name|va
operator|.
name|va_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ap
operator|->
name|a_uio
operator|!=
name|NULL
condition|)
name|error
operator|=
name|VOP_READ
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|IO_UNIT
operator||
name|IO_SYNC
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vn_close
argument_list|(
name|vp
argument_list|,
name|flags
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Vnode operation to remove a named attribute.  */
end_comment

begin_function
name|int
name|zfs_deleteextattr
parameter_list|(
name|struct
name|vop_deleteextattr_args
modifier|*
name|ap
parameter_list|)
comment|/* vop_deleteextattr { 	IN struct vnode *a_vp; 	IN int a_attrnamespace; 	IN const char *a_name; 	IN struct ucred *a_cred; 	IN struct thread *a_td; }; */
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|VTOZ
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|->
name|z_zfsvfs
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|char
name|attrname
index|[
literal|255
index|]
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
name|vnode_t
modifier|*
name|xvp
init|=
name|NULL
decl_stmt|,
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|;
name|error
operator|=
name|extattr_check_cred
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_attrnamespace
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
name|VWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|zfs_create_attrname
argument_list|(
name|ap
operator|->
name|a_attrnamespace
argument_list|,
name|ap
operator|->
name|a_name
argument_list|,
name|attrname
argument_list|,
sizeof|sizeof
argument_list|(
name|attrname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_lookup
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|NULL
argument_list|,
operator|&
name|xvp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|,
name|LOOKUP_XATTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|NDINIT_ATVP
argument_list|(
operator|&
name|nd
argument_list|,
name|DELETE
argument_list|,
name|NOFOLLOW
operator||
name|LOCKPARENT
operator||
name|LOCKLEAF
operator||
name|MPSAFE
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|attrname
argument_list|,
name|xvp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
name|ENOATTR
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|VOP_REMOVE
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|,
name|vp
argument_list|,
operator|&
name|nd
operator|.
name|ni_cnd
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|nd
operator|.
name|ni_dvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|==
name|nd
operator|.
name|ni_dvp
condition|)
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
else|else
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Vnode operation to set a named attribute.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_setextattr
parameter_list|(
name|struct
name|vop_setextattr_args
modifier|*
name|ap
parameter_list|)
comment|/* vop_setextattr { 	IN struct vnode *a_vp; 	IN int a_attrnamespace; 	IN const char *a_name; 	INOUT struct uio *a_uio; 	IN struct ucred *a_cred; 	IN struct thread *a_td; }; */
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|VTOZ
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|->
name|z_zfsvfs
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|char
name|attrname
index|[
literal|255
index|]
decl_stmt|;
name|struct
name|vattr
name|va
decl_stmt|;
name|vnode_t
modifier|*
name|xvp
init|=
name|NULL
decl_stmt|,
modifier|*
name|vp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|flags
decl_stmt|;
name|error
operator|=
name|extattr_check_cred
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_attrnamespace
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
name|VWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|zfs_create_attrname
argument_list|(
name|ap
operator|->
name|a_attrnamespace
argument_list|,
name|ap
operator|->
name|a_name
argument_list|,
name|attrname
argument_list|,
sizeof|sizeof
argument_list|(
name|attrname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_lookup
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|NULL
argument_list|,
operator|&
name|xvp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|,
name|LOOKUP_XATTR
operator||
name|CREATE_XATTR_DIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|flags
operator|=
name|FFLAGS
argument_list|(
name|O_WRONLY
operator||
name|O_CREAT
argument_list|)
expr_stmt|;
name|NDINIT_ATVP
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|NOFOLLOW
operator||
name|MPSAFE
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|attrname
argument_list|,
name|xvp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|vn_open_cred
argument_list|(
operator|&
name|nd
argument_list|,
operator|&
name|flags
argument_list|,
literal|0600
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|VATTR_NULL
argument_list|(
operator|&
name|va
argument_list|)
expr_stmt|;
name|va
operator|.
name|va_size
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|VOP_SETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|va
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|VOP_WRITE
argument_list|(
name|vp
argument_list|,
name|ap
operator|->
name|a_uio
argument_list|,
name|IO_UNIT
operator||
name|IO_SYNC
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vn_close
argument_list|(
name|vp
argument_list|,
name|flags
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Vnode operation to retrieve extended attributes on a vnode.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_listextattr
parameter_list|(
name|struct
name|vop_listextattr_args
modifier|*
name|ap
parameter_list|)
comment|/* vop_listextattr { 	IN struct vnode *a_vp; 	IN int a_attrnamespace; 	INOUT struct uio *a_uio; 	OUT size_t *a_size; 	IN struct ucred *a_cred; 	IN struct thread *a_td; }; */
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|VTOZ
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
operator|->
name|z_zfsvfs
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|ap
operator|->
name|a_td
decl_stmt|;
name|struct
name|nameidata
name|nd
decl_stmt|;
name|char
name|attrprefix
index|[
literal|16
index|]
decl_stmt|;
name|u_char
name|dirbuf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|dirent
argument_list|)
index|]
decl_stmt|;
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|,
modifier|*
name|uio
init|=
name|ap
operator|->
name|a_uio
decl_stmt|;
name|size_t
modifier|*
name|sizep
init|=
name|ap
operator|->
name|a_size
decl_stmt|;
name|size_t
name|plen
decl_stmt|;
name|vnode_t
modifier|*
name|xvp
init|=
name|NULL
decl_stmt|,
modifier|*
name|vp
decl_stmt|;
name|int
name|done
decl_stmt|,
name|error
decl_stmt|,
name|eof
decl_stmt|,
name|pos
decl_stmt|;
name|error
operator|=
name|extattr_check_cred
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_attrnamespace
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|ap
operator|->
name|a_td
argument_list|,
name|VREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|zfs_create_attrname
argument_list|(
name|ap
operator|->
name|a_attrnamespace
argument_list|,
literal|""
argument_list|,
name|attrprefix
argument_list|,
sizeof|sizeof
argument_list|(
name|attrprefix
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|plen
operator|=
name|strlen
argument_list|(
name|attrprefix
argument_list|)
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|sizep
operator|!=
name|NULL
condition|)
operator|*
name|sizep
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|zfs_lookup
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|NULL
argument_list|,
operator|&
name|xvp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|td
argument_list|,
name|LOOKUP_XATTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
comment|/* 		 * ENOATTR means that the EA directory does not yet exist, 		 * i.e. there are no extended attributes there. 		 */
if|if
condition|(
name|error
operator|==
name|ENOATTR
condition|)
name|error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|NDINIT_ATVP
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|NOFOLLOW
operator||
name|LOCKLEAF
operator||
name|LOCKSHARED
operator||
name|MPSAFE
argument_list|,
name|UIO_SYSSPACE
argument_list|,
literal|"."
argument_list|,
name|xvp
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
expr_stmt|;
name|vp
operator|=
name|nd
operator|.
name|ni_vp
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|u_char
name|nlen
decl_stmt|;
name|aiov
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
name|dirbuf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|dirbuf
argument_list|)
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
sizeof|sizeof
argument_list|(
name|dirbuf
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_READDIR
argument_list|(
name|vp
argument_list|,
operator|&
name|auio
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
operator|&
name|eof
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|done
operator|=
sizeof|sizeof
argument_list|(
name|dirbuf
argument_list|)
operator|-
name|auio
operator|.
name|uio_resid
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|done
condition|;
control|)
block|{
name|dp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
operator|(
name|dirbuf
operator|+
name|pos
operator|)
expr_stmt|;
name|pos
operator|+=
name|dp
operator|->
name|d_reclen
expr_stmt|;
comment|/* 			 * XXX: Temporarily we also accept DT_UNKNOWN, as this 			 * is what we get when attribute was created on Solaris. 			 */
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|DT_REG
operator|&&
name|dp
operator|->
name|d_type
operator|!=
name|DT_UNKNOWN
condition|)
continue|continue;
if|if
condition|(
name|plen
operator|==
literal|0
operator|&&
name|strncmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
literal|"freebsd:"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|attrprefix
argument_list|,
name|plen
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|nlen
operator|=
name|dp
operator|->
name|d_namlen
operator|-
name|plen
expr_stmt|;
if|if
condition|(
name|sizep
operator|!=
name|NULL
condition|)
operator|*
name|sizep
operator|+=
literal|1
operator|+
name|nlen
expr_stmt|;
elseif|else
if|if
condition|(
name|uio
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Format of extattr name entry is one byte for 				 * length and the rest for name. 				 */
name|error
operator|=
name|uiomove
argument_list|(
operator|&
name|nlen
argument_list|,
literal|1
argument_list|,
name|uio
operator|->
name|uio_rw
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|uiomove
argument_list|(
name|dp
operator|->
name|d_name
operator|+
name|plen
argument_list|,
name|nlen
argument_list|,
name|uio
operator|->
name|uio_rw
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
block|}
do|while
condition|(
operator|!
name|eof
operator|&&
name|error
operator|==
literal|0
condition|)
do|;
name|vput
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_freebsd_getacl
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_getacl_args
comment|/* { 		struct vnode *vp; 		acl_type_t type; 		struct acl *aclp; 		struct ucred *cred; 		struct thread *td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|vsecattr_t
name|vsecattr
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_type
operator|!=
name|ACL_TYPE_NFS4
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|vsecattr
operator|.
name|vsa_mask
operator|=
name|VSA_ACE
operator||
name|VSA_ACECNT
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|zfs_getsecattr
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
operator|&
name|vsecattr
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|acl_from_aces
argument_list|(
name|ap
operator|->
name|a_aclp
argument_list|,
name|vsecattr
operator|.
name|vsa_aclentp
argument_list|,
name|vsecattr
operator|.
name|vsa_aclcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsecattr
operator|.
name|vsa_aclentp
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|vsecattr
operator|.
name|vsa_aclentp
argument_list|,
name|vsecattr
operator|.
name|vsa_aclentsz
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_freebsd_setacl
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_setacl_args
comment|/* { 		struct vnode *vp; 		acl_type_t type; 		struct acl *aclp; 		struct ucred *cred; 		struct thread *td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|vsecattr_t
name|vsecattr
decl_stmt|;
name|int
name|aclbsize
decl_stmt|;
comment|/* size of acl list in bytes */
name|aclent_t
modifier|*
name|aaclp
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|a_type
operator|!=
name|ACL_TYPE_NFS4
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
name|ap
operator|->
name|a_aclp
operator|->
name|acl_cnt
operator|<
literal|1
operator|||
name|ap
operator|->
name|a_aclp
operator|->
name|acl_cnt
operator|>
name|MAX_ACL_ENTRIES
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * With NFS4 ACLs, chmod(2) may need to add additional entries, 	 * splitting every entry into two and appending "canonical six" 	 * entries at the end.  Don't allow for setting an ACL that would 	 * cause chmod(2) to run out of ACL entries. 	 */
if|if
condition|(
name|ap
operator|->
name|a_aclp
operator|->
name|acl_cnt
operator|*
literal|2
operator|+
literal|6
operator|>
name|ACL_MAX_ENTRIES
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|vsecattr
operator|.
name|vsa_mask
operator|=
name|VSA_ACE
expr_stmt|;
name|aclbsize
operator|=
name|ap
operator|->
name|a_aclp
operator|->
name|acl_cnt
operator|*
sizeof|sizeof
argument_list|(
name|ace_t
argument_list|)
expr_stmt|;
name|vsecattr
operator|.
name|vsa_aclentp
operator|=
name|kmem_alloc
argument_list|(
name|aclbsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|aaclp
operator|=
name|vsecattr
operator|.
name|vsa_aclentp
expr_stmt|;
name|vsecattr
operator|.
name|vsa_aclentsz
operator|=
name|aclbsize
expr_stmt|;
name|aces_from_acl
argument_list|(
name|vsecattr
operator|.
name|vsa_aclentp
argument_list|,
operator|&
name|vsecattr
operator|.
name|vsa_aclcnt
argument_list|,
name|ap
operator|->
name|a_aclp
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_setsecattr
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
operator|&
name|vsecattr
argument_list|,
literal|0
argument_list|,
name|ap
operator|->
name|a_cred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|aaclp
argument_list|,
name|aclbsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_freebsd_aclcheck
parameter_list|(
name|ap
parameter_list|)
name|struct
name|vop_aclcheck_args
comment|/* { 		struct vnode *vp; 		acl_type_t type; 		struct acl *aclp; 		struct ucred *cred; 		struct thread *td; 	} */
modifier|*
name|ap
decl_stmt|;
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|vop_vector
name|zfs_vnodeops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vop_vector
name|zfs_fifoops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vop_vector
name|zfs_vnodeops
init|=
block|{
operator|.
name|vop_default
operator|=
operator|&
name|default_vnodeops
block|,
operator|.
name|vop_inactive
operator|=
name|zfs_freebsd_inactive
block|,
operator|.
name|vop_reclaim
operator|=
name|zfs_freebsd_reclaim
block|,
operator|.
name|vop_access
operator|=
name|zfs_freebsd_access
block|,
ifdef|#
directive|ifdef
name|FREEBSD_NAMECACHE
operator|.
name|vop_lookup
operator|=
name|vfs_cache_lookup
block|,
operator|.
name|vop_cachedlookup
operator|=
name|zfs_freebsd_lookup
block|,
else|#
directive|else
operator|.
name|vop_lookup
operator|=
name|zfs_freebsd_lookup
block|,
endif|#
directive|endif
operator|.
name|vop_getattr
operator|=
name|zfs_freebsd_getattr
block|,
operator|.
name|vop_setattr
operator|=
name|zfs_freebsd_setattr
block|,
operator|.
name|vop_create
operator|=
name|zfs_freebsd_create
block|,
operator|.
name|vop_mknod
operator|=
name|zfs_freebsd_create
block|,
operator|.
name|vop_mkdir
operator|=
name|zfs_freebsd_mkdir
block|,
operator|.
name|vop_readdir
operator|=
name|zfs_freebsd_readdir
block|,
operator|.
name|vop_fsync
operator|=
name|zfs_freebsd_fsync
block|,
operator|.
name|vop_open
operator|=
name|zfs_freebsd_open
block|,
operator|.
name|vop_close
operator|=
name|zfs_freebsd_close
block|,
operator|.
name|vop_rmdir
operator|=
name|zfs_freebsd_rmdir
block|,
operator|.
name|vop_ioctl
operator|=
name|zfs_freebsd_ioctl
block|,
operator|.
name|vop_link
operator|=
name|zfs_freebsd_link
block|,
operator|.
name|vop_symlink
operator|=
name|zfs_freebsd_symlink
block|,
operator|.
name|vop_readlink
operator|=
name|zfs_freebsd_readlink
block|,
operator|.
name|vop_read
operator|=
name|zfs_freebsd_read
block|,
operator|.
name|vop_write
operator|=
name|zfs_freebsd_write
block|,
operator|.
name|vop_remove
operator|=
name|zfs_freebsd_remove
block|,
operator|.
name|vop_rename
operator|=
name|zfs_freebsd_rename
block|,
operator|.
name|vop_pathconf
operator|=
name|zfs_freebsd_pathconf
block|,
operator|.
name|vop_bmap
operator|=
name|VOP_EOPNOTSUPP
block|,
operator|.
name|vop_fid
operator|=
name|zfs_freebsd_fid
block|,
operator|.
name|vop_getextattr
operator|=
name|zfs_getextattr
block|,
operator|.
name|vop_deleteextattr
operator|=
name|zfs_deleteextattr
block|,
operator|.
name|vop_setextattr
operator|=
name|zfs_setextattr
block|,
operator|.
name|vop_listextattr
operator|=
name|zfs_listextattr
block|,
ifdef|#
directive|ifdef
name|notyet
operator|.
name|vop_getacl
operator|=
name|zfs_freebsd_getacl
block|,
operator|.
name|vop_setacl
operator|=
name|zfs_freebsd_setacl
block|,
operator|.
name|vop_aclcheck
operator|=
name|zfs_freebsd_aclcheck
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vop_vector
name|zfs_fifoops
init|=
block|{
operator|.
name|vop_default
operator|=
operator|&
name|fifo_specops
block|,
operator|.
name|vop_fsync
operator|=
name|VOP_PANIC
block|,
operator|.
name|vop_access
operator|=
name|zfs_freebsd_access
block|,
operator|.
name|vop_getattr
operator|=
name|zfs_freebsd_getattr
block|,
operator|.
name|vop_inactive
operator|=
name|zfs_freebsd_inactive
block|,
operator|.
name|vop_read
operator|=
name|VOP_PANIC
block|,
operator|.
name|vop_reclaim
operator|=
name|zfs_freebsd_reclaim
block|,
operator|.
name|vop_setattr
operator|=
name|zfs_freebsd_setattr
block|,
operator|.
name|vop_write
operator|=
name|VOP_PANIC
block|,
operator|.
name|vop_fid
operator|=
name|zfs_freebsd_fid
block|,
ifdef|#
directive|ifdef
name|notyet
operator|.
name|vop_getacl
operator|=
name|zfs_freebsd_getacl
block|,
operator|.
name|vop_setacl
operator|=
name|zfs_freebsd_setacl
block|,
operator|.
name|vop_aclcheck
operator|=
name|zfs_freebsd_aclcheck
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

end_unit

