begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2007, 2010, Oracle and/or its affiliates. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/avl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/nvpair.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/kidmap.h>
end_include

begin_include
include|#
directive|include
file|<sys/sid.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_vfsops.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/zfs_fuid.h>
end_include

begin_comment
comment|/*  * FUID Domain table(s).  *  * The FUID table is stored as a packed nvlist of an array  * of nvlists which contain an index, domain string and offset  *  * During file system initialization the nvlist(s) are read and  * two AVL trees are created.  One tree is keyed by the index number  * and the other by the domain string.  Nodes are never removed from  * trees, but new entries may be added.  If a new entry is added then  * the zfsvfs->z_fuid_dirty flag is set to true and the caller will then  * be responsible for calling zfs_fuid_sync() to sync the changes to disk.  *  */
end_comment

begin_define
define|#
directive|define
name|FUID_IDX
value|"fuid_idx"
end_define

begin_define
define|#
directive|define
name|FUID_DOMAIN
value|"fuid_domain"
end_define

begin_define
define|#
directive|define
name|FUID_OFFSET
value|"fuid_offset"
end_define

begin_define
define|#
directive|define
name|FUID_NVP_ARRAY
value|"fuid_nvlist"
end_define

begin_typedef
typedef|typedef
struct|struct
name|fuid_domain
block|{
name|avl_node_t
name|f_domnode
decl_stmt|;
name|avl_node_t
name|f_idxnode
decl_stmt|;
name|ksiddomain_t
modifier|*
name|f_ksid
decl_stmt|;
name|uint64_t
name|f_idx
decl_stmt|;
block|}
name|fuid_domain_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|nulldomain
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Compare two indexes.  */
end_comment

begin_function
specifier|static
name|int
name|idx_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
specifier|const
name|fuid_domain_t
modifier|*
name|node1
init|=
name|arg1
decl_stmt|;
specifier|const
name|fuid_domain_t
modifier|*
name|node2
init|=
name|arg2
decl_stmt|;
if|if
condition|(
name|node1
operator|->
name|f_idx
operator|<
name|node2
operator|->
name|f_idx
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|node1
operator|->
name|f_idx
operator|>
name|node2
operator|->
name|f_idx
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compare two domain strings.  */
end_comment

begin_function
specifier|static
name|int
name|domain_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
specifier|const
name|fuid_domain_t
modifier|*
name|node1
init|=
name|arg1
decl_stmt|;
specifier|const
name|fuid_domain_t
modifier|*
name|node2
init|=
name|arg2
decl_stmt|;
name|int
name|val
decl_stmt|;
name|val
operator|=
name|strcmp
argument_list|(
name|node1
operator|->
name|f_ksid
operator|->
name|kd_name
argument_list|,
name|node2
operator|->
name|f_ksid
operator|->
name|kd_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|val
operator|>
literal|0
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zfs_fuid_avl_tree_create
parameter_list|(
name|avl_tree_t
modifier|*
name|idx_tree
parameter_list|,
name|avl_tree_t
modifier|*
name|domain_tree
parameter_list|)
block|{
name|avl_create
argument_list|(
name|idx_tree
argument_list|,
name|idx_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|fuid_domain_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|fuid_domain_t
argument_list|,
name|f_idxnode
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
name|domain_tree
argument_list|,
name|domain_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|fuid_domain_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|fuid_domain_t
argument_list|,
name|f_domnode
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * load initial fuid domain and idx trees.  This function is used by  * both the kernel and zdb.  */
end_comment

begin_function
name|uint64_t
name|zfs_fuid_table_load
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|fuid_obj
parameter_list|,
name|avl_tree_t
modifier|*
name|idx_tree
parameter_list|,
name|avl_tree_t
modifier|*
name|domain_tree
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|uint64_t
name|fuid_size
decl_stmt|;
name|ASSERT
argument_list|(
name|fuid_obj
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|fuid_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|fuid_size
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|db
operator|->
name|db_data
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuid_size
condition|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|fuidnvp
decl_stmt|;
name|nvlist_t
modifier|*
name|nvp
init|=
name|NULL
decl_stmt|;
name|uint_t
name|count
decl_stmt|;
name|char
modifier|*
name|packed
decl_stmt|;
name|int
name|i
decl_stmt|;
name|packed
operator|=
name|kmem_alloc
argument_list|(
name|fuid_size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dmu_read
argument_list|(
name|os
argument_list|,
name|fuid_obj
argument_list|,
literal|0
argument_list|,
name|fuid_size
argument_list|,
name|packed
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_unpack
argument_list|(
name|packed
argument_list|,
name|fuid_size
argument_list|,
operator|&
name|nvp
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvp
argument_list|,
name|FUID_NVP_ARRAY
argument_list|,
operator|&
name|fuidnvp
argument_list|,
operator|&
name|count
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|count
condition|;
name|i
operator|++
control|)
block|{
name|fuid_domain_t
modifier|*
name|domnode
decl_stmt|;
name|char
modifier|*
name|domain
decl_stmt|;
name|uint64_t
name|idx
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|fuidnvp
index|[
name|i
index|]
argument_list|,
name|FUID_DOMAIN
argument_list|,
operator|&
name|domain
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|fuidnvp
index|[
name|i
index|]
argument_list|,
name|FUID_IDX
argument_list|,
operator|&
name|idx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|domnode
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fuid_domain_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|domnode
operator|->
name|f_idx
operator|=
name|idx
expr_stmt|;
name|domnode
operator|->
name|f_ksid
operator|=
name|ksid_lookupdomain
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|avl_add
argument_list|(
name|idx_tree
argument_list|,
name|domnode
argument_list|)
expr_stmt|;
name|avl_add
argument_list|(
name|domain_tree
argument_list|,
name|domnode
argument_list|)
expr_stmt|;
block|}
name|nvlist_free
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|packed
argument_list|,
name|fuid_size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fuid_size
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zfs_fuid_table_destroy
parameter_list|(
name|avl_tree_t
modifier|*
name|idx_tree
parameter_list|,
name|avl_tree_t
modifier|*
name|domain_tree
parameter_list|)
block|{
name|fuid_domain_t
modifier|*
name|domnode
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
name|cookie
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|domnode
operator|=
name|avl_destroy_nodes
argument_list|(
name|domain_tree
argument_list|,
operator|&
name|cookie
argument_list|)
condition|)
name|ksiddomain_rele
argument_list|(
name|domnode
operator|->
name|f_ksid
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
name|domain_tree
argument_list|)
expr_stmt|;
name|cookie
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|domnode
operator|=
name|avl_destroy_nodes
argument_list|(
name|idx_tree
argument_list|,
operator|&
name|cookie
argument_list|)
condition|)
name|kmem_free
argument_list|(
name|domnode
argument_list|,
sizeof|sizeof
argument_list|(
name|fuid_domain_t
argument_list|)
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
name|idx_tree
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|zfs_fuid_idx_domain
parameter_list|(
name|avl_tree_t
modifier|*
name|idx_tree
parameter_list|,
name|uint32_t
name|idx
parameter_list|)
block|{
name|fuid_domain_t
name|searchnode
decl_stmt|,
modifier|*
name|findnode
decl_stmt|;
name|avl_index_t
name|loc
decl_stmt|;
name|searchnode
operator|.
name|f_idx
operator|=
name|idx
expr_stmt|;
name|findnode
operator|=
name|avl_find
argument_list|(
name|idx_tree
argument_list|,
operator|&
name|searchnode
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
return|return
operator|(
name|findnode
condition|?
name|findnode
operator|->
name|f_ksid
operator|->
name|kd_name
else|:
name|nulldomain
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_comment
comment|/*  * Load the fuid table(s) into memory.  */
end_comment

begin_function
specifier|static
name|void
name|zfs_fuid_init
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|)
block|{
name|rw_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_lock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_fuid_loaded
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|zfs_fuid_avl_tree_create
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_idx
argument_list|,
operator|&
name|zfsvfs
operator|->
name|z_fuid_domain
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zap_lookup
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|ZFS_FUID_TABLES
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|zfsvfs
operator|->
name|z_fuid_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_fuid_obj
operator|!=
literal|0
condition|)
block|{
name|zfsvfs
operator|->
name|z_fuid_size
operator|=
name|zfs_fuid_table_load
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zfsvfs
operator|->
name|z_fuid_obj
argument_list|,
operator|&
name|zfsvfs
operator|->
name|z_fuid_idx
argument_list|,
operator|&
name|zfsvfs
operator|->
name|z_fuid_domain
argument_list|)
expr_stmt|;
block|}
name|zfsvfs
operator|->
name|z_fuid_loaded
operator|=
name|B_TRUE
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sync out AVL trees to persistent storage.  */
end_comment

begin_function
name|void
name|zfs_fuid_sync
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvp
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|fuids
decl_stmt|;
name|size_t
name|nvsize
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|packed
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|fuid_domain_t
modifier|*
name|domnode
decl_stmt|;
name|int
name|numnodes
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|zfsvfs
operator|->
name|z_fuid_dirty
condition|)
block|{
return|return;
block|}
name|rw_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_lock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
comment|/* 	 * First see if table needs to be created? 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_fuid_obj
operator|==
literal|0
condition|)
block|{
name|zfsvfs
operator|->
name|z_fuid_obj
operator|=
name|dmu_object_alloc
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|DMU_OT_FUID
argument_list|,
literal|1
operator|<<
literal|14
argument_list|,
name|DMU_OT_FUID_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_add
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|ZFS_FUID_TABLES
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|zfsvfs
operator|->
name|z_fuid_obj
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|nvp
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|numnodes
operator|=
name|avl_numnodes
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_idx
argument_list|)
expr_stmt|;
name|fuids
operator|=
name|kmem_alloc
argument_list|(
name|numnodes
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|domnode
operator|=
name|avl_first
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_domain
argument_list|)
init|;
name|domnode
condition|;
name|i
operator|++
operator|,
name|domnode
operator|=
name|AVL_NEXT
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_domain
argument_list|,
name|domnode
argument_list|)
control|)
block|{
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|fuids
index|[
name|i
index|]
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|fuids
index|[
name|i
index|]
argument_list|,
name|FUID_IDX
argument_list|,
name|domnode
operator|->
name|f_idx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|fuids
index|[
name|i
index|]
argument_list|,
name|FUID_OFFSET
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|fuids
index|[
name|i
index|]
argument_list|,
name|FUID_DOMAIN
argument_list|,
name|domnode
operator|->
name|f_ksid
operator|->
name|kd_name
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|nvp
argument_list|,
name|FUID_NVP_ARRAY
argument_list|,
name|fuids
argument_list|,
name|numnodes
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|numnodes
condition|;
name|i
operator|++
control|)
name|nvlist_free
argument_list|(
name|fuids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|fuids
argument_list|,
name|numnodes
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_size
argument_list|(
name|nvp
argument_list|,
operator|&
name|nvsize
argument_list|,
name|NV_ENCODE_XDR
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|packed
operator|=
name|kmem_alloc
argument_list|(
name|nvsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_pack
argument_list|(
name|nvp
argument_list|,
operator|&
name|packed
argument_list|,
operator|&
name|nvsize
argument_list|,
name|NV_ENCODE_XDR
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_fuid_size
operator|=
name|nvsize
expr_stmt|;
name|dmu_write
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zfsvfs
operator|->
name|z_fuid_obj
argument_list|,
literal|0
argument_list|,
name|zfsvfs
operator|->
name|z_fuid_size
argument_list|,
name|packed
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|packed
argument_list|,
name|zfsvfs
operator|->
name|z_fuid_size
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_bonus_hold
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zfsvfs
operator|->
name|z_fuid_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|db
operator|->
name|db_data
operator|=
name|zfsvfs
operator|->
name|z_fuid_size
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_fuid_dirty
operator|=
name|B_FALSE
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Query domain table for a given domain.  *  * If domain isn't found and addok is set, it is added to AVL trees and  * the zfsvfs->z_fuid_dirty flag will be set to TRUE.  It will then be  * necessary for the caller or another thread to detect the dirty table  * and sync out the changes.  */
end_comment

begin_function
name|int
name|zfs_fuid_find_by_domain
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
name|char
modifier|*
modifier|*
name|retdomain
parameter_list|,
name|boolean_t
name|addok
parameter_list|)
block|{
name|fuid_domain_t
name|searchnode
decl_stmt|,
modifier|*
name|findnode
decl_stmt|;
name|avl_index_t
name|loc
decl_stmt|;
name|krw_t
name|rw
init|=
name|RW_READER
decl_stmt|;
comment|/* 	 * If the dummy "nobody" domain then return an index of 0 	 * to cause the created FUID to be a standard POSIX id 	 * for the user nobody. 	 */
if|if
condition|(
name|domain
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|retdomain
condition|)
operator|*
name|retdomain
operator|=
name|nulldomain
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|searchnode
operator|.
name|f_ksid
operator|=
name|ksid_lookupdomain
argument_list|(
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|retdomain
condition|)
operator|*
name|retdomain
operator|=
name|searchnode
operator|.
name|f_ksid
operator|->
name|kd_name
expr_stmt|;
if|if
condition|(
operator|!
name|zfsvfs
operator|->
name|z_fuid_loaded
condition|)
name|zfs_fuid_init
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|retry
label|:
name|rw_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_lock
argument_list|,
name|rw
argument_list|)
expr_stmt|;
name|findnode
operator|=
name|avl_find
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_domain
argument_list|,
operator|&
name|searchnode
argument_list|,
operator|&
name|loc
argument_list|)
expr_stmt|;
if|if
condition|(
name|findnode
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_lock
argument_list|)
expr_stmt|;
name|ksiddomain_rele
argument_list|(
name|searchnode
operator|.
name|f_ksid
argument_list|)
expr_stmt|;
return|return
operator|(
name|findnode
operator|->
name|f_idx
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|addok
condition|)
block|{
name|fuid_domain_t
modifier|*
name|domnode
decl_stmt|;
name|uint64_t
name|retidx
decl_stmt|;
if|if
condition|(
name|rw
operator|==
name|RW_READER
operator|&&
operator|!
name|rw_tryupgrade
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_lock
argument_list|)
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_lock
argument_list|)
expr_stmt|;
name|rw
operator|=
name|RW_WRITER
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|domnode
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fuid_domain_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|domnode
operator|->
name|f_ksid
operator|=
name|searchnode
operator|.
name|f_ksid
expr_stmt|;
name|retidx
operator|=
name|domnode
operator|->
name|f_idx
operator|=
name|avl_numnodes
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_idx
argument_list|)
operator|+
literal|1
expr_stmt|;
name|avl_add
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_domain
argument_list|,
name|domnode
argument_list|)
expr_stmt|;
name|avl_add
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_idx
argument_list|,
name|domnode
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_fuid_dirty
operator|=
name|B_TRUE
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|retidx
operator|)
return|;
block|}
else|else
block|{
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_lock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Query domain table by index, returning domain string  *  * Returns a pointer from an avl node of the domain string.  *  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|zfs_fuid_find_by_idx
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|uint32_t
name|idx
parameter_list|)
block|{
name|char
modifier|*
name|domain
decl_stmt|;
if|if
condition|(
name|idx
operator|==
literal|0
operator|||
operator|!
name|zfsvfs
operator|->
name|z_use_fuids
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|!
name|zfsvfs
operator|->
name|z_fuid_loaded
condition|)
name|zfs_fuid_init
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_lock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_fuid_obj
operator|||
name|zfsvfs
operator|->
name|z_fuid_dirty
condition|)
name|domain
operator|=
name|zfs_fuid_idx_domain
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_idx
argument_list|,
name|idx
argument_list|)
expr_stmt|;
else|else
name|domain
operator|=
name|nulldomain
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|domain
argument_list|)
expr_stmt|;
return|return
operator|(
name|domain
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zfs_fuid_map_ids
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|uid_t
modifier|*
name|uidp
parameter_list|,
name|uid_t
modifier|*
name|gidp
parameter_list|)
block|{
operator|*
name|uidp
operator|=
name|zfs_fuid_map_id
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|,
name|zp
operator|->
name|z_uid
argument_list|,
name|cr
argument_list|,
name|ZFS_OWNER
argument_list|)
expr_stmt|;
operator|*
name|gidp
operator|=
name|zfs_fuid_map_id
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|,
name|zp
operator|->
name|z_gid
argument_list|,
name|cr
argument_list|,
name|ZFS_GROUP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uid_t
name|zfs_fuid_map_id
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|uint64_t
name|fuid
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|zfs_fuid_type_t
name|type
parameter_list|)
block|{
name|uint32_t
name|index
init|=
name|FUID_INDEX
argument_list|(
name|fuid
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|domain
decl_stmt|;
name|uid_t
name|id
decl_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
return|return
operator|(
name|fuid
operator|)
return|;
name|domain
operator|=
name|zfs_fuid_find_by_idx
argument_list|(
name|zfsvfs
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|domain
operator|!=
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|type
operator|==
name|ZFS_OWNER
operator|||
name|type
operator|==
name|ZFS_ACE_USER
condition|)
block|{
operator|(
name|void
operator|)
name|kidmap_getuidbysid
argument_list|(
name|crgetzone
argument_list|(
name|cr
argument_list|)
argument_list|,
name|domain
argument_list|,
name|FUID_RID
argument_list|(
name|fuid
argument_list|)
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|kidmap_getgidbysid
argument_list|(
name|crgetzone
argument_list|(
name|cr
argument_list|)
argument_list|,
name|domain
argument_list|,
name|FUID_RID
argument_list|(
name|fuid
argument_list|)
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|id
operator|=
name|UID_NOBODY
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|id
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a FUID node to the list of fuid's being created for this  * ACL  *  * If ACL has multiple domains, then keep only one copy of each unique  * domain.  */
end_comment

begin_function
name|void
name|zfs_fuid_node_add
parameter_list|(
name|zfs_fuid_info_t
modifier|*
modifier|*
name|fuidpp
parameter_list|,
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
name|uint32_t
name|rid
parameter_list|,
name|uint64_t
name|idx
parameter_list|,
name|uint64_t
name|id
parameter_list|,
name|zfs_fuid_type_t
name|type
parameter_list|)
block|{
name|zfs_fuid_t
modifier|*
name|fuid
decl_stmt|;
name|zfs_fuid_domain_t
modifier|*
name|fuid_domain
decl_stmt|;
name|zfs_fuid_info_t
modifier|*
name|fuidp
decl_stmt|;
name|uint64_t
name|fuididx
decl_stmt|;
name|boolean_t
name|found
init|=
name|B_FALSE
decl_stmt|;
if|if
condition|(
operator|*
name|fuidpp
operator|==
name|NULL
condition|)
operator|*
name|fuidpp
operator|=
name|zfs_fuid_info_alloc
argument_list|()
expr_stmt|;
name|fuidp
operator|=
operator|*
name|fuidpp
expr_stmt|;
comment|/* 	 * First find fuid domain index in linked list 	 * 	 * If one isn't found then create an entry. 	 */
for|for
control|(
name|fuididx
operator|=
literal|1
operator|,
name|fuid_domain
operator|=
name|list_head
argument_list|(
operator|&
name|fuidp
operator|->
name|z_domains
argument_list|)
init|;
name|fuid_domain
condition|;
name|fuid_domain
operator|=
name|list_next
argument_list|(
operator|&
name|fuidp
operator|->
name|z_domains
argument_list|,
name|fuid_domain
argument_list|)
operator|,
name|fuididx
operator|++
control|)
block|{
if|if
condition|(
name|idx
operator|==
name|fuid_domain
operator|->
name|z_domidx
condition|)
block|{
name|found
operator|=
name|B_TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|fuid_domain
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_fuid_domain_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|fuid_domain
operator|->
name|z_domain
operator|=
name|domain
expr_stmt|;
name|fuid_domain
operator|->
name|z_domidx
operator|=
name|idx
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|fuidp
operator|->
name|z_domains
argument_list|,
name|fuid_domain
argument_list|)
expr_stmt|;
name|fuidp
operator|->
name|z_domain_str_sz
operator|+=
name|strlen
argument_list|(
name|domain
argument_list|)
operator|+
literal|1
expr_stmt|;
name|fuidp
operator|->
name|z_domain_cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|ZFS_ACE_USER
operator|||
name|type
operator|==
name|ZFS_ACE_GROUP
condition|)
block|{
comment|/* 		 * Now allocate fuid entry and add it on the end of the list 		 */
name|fuid
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_fuid_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|fuid
operator|->
name|z_id
operator|=
name|id
expr_stmt|;
name|fuid
operator|->
name|z_domidx
operator|=
name|idx
expr_stmt|;
name|fuid
operator|->
name|z_logfuid
operator|=
name|FUID_ENCODE
argument_list|(
name|fuididx
argument_list|,
name|rid
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|fuidp
operator|->
name|z_fuids
argument_list|,
name|fuid
argument_list|)
expr_stmt|;
name|fuidp
operator|->
name|z_fuid_cnt
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|type
operator|==
name|ZFS_OWNER
condition|)
name|fuidp
operator|->
name|z_fuid_owner
operator|=
name|FUID_ENCODE
argument_list|(
name|fuididx
argument_list|,
name|rid
argument_list|)
expr_stmt|;
else|else
name|fuidp
operator|->
name|z_fuid_group
operator|=
name|FUID_ENCODE
argument_list|(
name|fuididx
argument_list|,
name|rid
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Create a file system FUID, based on information in the users cred  *  * If cred contains KSID_OWNER then it should be used to determine  * the uid otherwise cred's uid will be used. By default cred's gid  * is used unless it's an ephemeral ID in which case KSID_GROUP will  * be used if it exists.  */
end_comment

begin_function
name|uint64_t
name|zfs_fuid_create_cred
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|zfs_fuid_type_t
name|type
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|zfs_fuid_info_t
modifier|*
modifier|*
name|fuidp
parameter_list|)
block|{
name|uint64_t
name|idx
decl_stmt|;
name|ksid_t
modifier|*
name|ksid
decl_stmt|;
name|uint32_t
name|rid
decl_stmt|;
name|char
modifier|*
name|kdomain
decl_stmt|;
specifier|const
name|char
modifier|*
name|domain
decl_stmt|;
name|uid_t
name|id
decl_stmt|;
name|VERIFY
argument_list|(
name|type
operator|==
name|ZFS_OWNER
operator|||
name|type
operator|==
name|ZFS_GROUP
argument_list|)
expr_stmt|;
name|ksid
operator|=
name|crgetsid
argument_list|(
name|cr
argument_list|,
operator|(
name|type
operator|==
name|ZFS_OWNER
operator|)
condition|?
name|KSID_OWNER
else|:
name|KSID_GROUP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zfsvfs
operator|->
name|z_use_fuids
operator|||
operator|(
name|ksid
operator|==
name|NULL
operator|)
condition|)
block|{
name|id
operator|=
operator|(
name|type
operator|==
name|ZFS_OWNER
operator|)
condition|?
name|crgetuid
argument_list|(
name|cr
argument_list|)
else|:
name|crgetgid
argument_list|(
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_EPHEMERAL
argument_list|(
name|id
argument_list|)
condition|)
return|return
operator|(
operator|(
name|type
operator|==
name|ZFS_OWNER
operator|)
condition|?
name|UID_NOBODY
else|:
name|GID_NOBODY
operator|)
return|;
return|return
operator|(
operator|(
name|uint64_t
operator|)
name|id
operator|)
return|;
block|}
comment|/* 	 * ksid is present and FUID is supported 	 */
name|id
operator|=
operator|(
name|type
operator|==
name|ZFS_OWNER
operator|)
condition|?
name|ksid_getid
argument_list|(
name|ksid
argument_list|)
else|:
name|crgetgid
argument_list|(
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_EPHEMERAL
argument_list|(
name|id
argument_list|)
condition|)
return|return
operator|(
operator|(
name|uint64_t
operator|)
name|id
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|ZFS_GROUP
condition|)
name|id
operator|=
name|ksid_getid
argument_list|(
name|ksid
argument_list|)
expr_stmt|;
name|rid
operator|=
name|ksid_getrid
argument_list|(
name|ksid
argument_list|)
expr_stmt|;
name|domain
operator|=
name|ksid_getdomain
argument_list|(
name|ksid
argument_list|)
expr_stmt|;
name|idx
operator|=
name|zfs_fuid_find_by_domain
argument_list|(
name|zfsvfs
argument_list|,
name|domain
argument_list|,
operator|&
name|kdomain
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|zfs_fuid_node_add
argument_list|(
name|fuidp
argument_list|,
name|kdomain
argument_list|,
name|rid
argument_list|,
name|idx
argument_list|,
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|FUID_ENCODE
argument_list|(
name|idx
argument_list|,
name|rid
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a file system FUID for an ACL ace  * or a chown/chgrp of the file.  * This is similar to zfs_fuid_create_cred, except that  * we can't find the domain + rid information in the  * cred.  Instead we have to query Winchester for the  * domain and rid.  *  * During replay operations the domain+rid information is  * found in the zfs_fuid_info_t that the replay code has  * attached to the zfsvfs of the file system.  */
end_comment

begin_function
name|uint64_t
name|zfs_fuid_create
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|uint64_t
name|id
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|zfs_fuid_type_t
name|type
parameter_list|,
name|zfs_fuid_info_t
modifier|*
modifier|*
name|fuidpp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|domain
decl_stmt|;
name|char
modifier|*
name|kdomain
decl_stmt|;
name|uint32_t
name|fuid_idx
init|=
name|FUID_INDEX
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|uint32_t
name|rid
decl_stmt|;
name|idmap_stat
name|status
decl_stmt|;
name|uint64_t
name|idx
init|=
literal|0
decl_stmt|;
name|zfs_fuid_t
modifier|*
name|zfuid
init|=
name|NULL
decl_stmt|;
name|zfs_fuid_info_t
modifier|*
name|fuidp
init|=
name|NULL
decl_stmt|;
comment|/* 	 * If POSIX ID, or entry is already a FUID then 	 * just return the id 	 * 	 * We may also be handed an already FUID'ized id via 	 * chmod. 	 */
if|if
condition|(
operator|!
name|zfsvfs
operator|->
name|z_use_fuids
operator|||
operator|!
name|IS_EPHEMERAL
argument_list|(
name|id
argument_list|)
operator|||
name|fuid_idx
operator|!=
literal|0
condition|)
return|return
operator|(
name|id
operator|)
return|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_replay
condition|)
block|{
name|fuidp
operator|=
name|zfsvfs
operator|->
name|z_fuid_replay
expr_stmt|;
comment|/* 		 * If we are passed an ephemeral id, but no 		 * fuid_info was logged then return NOBODY. 		 * This is most likely a result of idmap service 		 * not being available. 		 */
if|if
condition|(
name|fuidp
operator|==
name|NULL
condition|)
return|return
operator|(
name|UID_NOBODY
operator|)
return|;
name|VERIFY3U
argument_list|(
name|type
argument_list|,
operator|>=
argument_list|,
name|ZFS_OWNER
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|type
argument_list|,
operator|<=
argument_list|,
name|ZFS_ACE_GROUP
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ZFS_ACE_USER
case|:
case|case
name|ZFS_ACE_GROUP
case|:
name|zfuid
operator|=
name|list_head
argument_list|(
operator|&
name|fuidp
operator|->
name|z_fuids
argument_list|)
expr_stmt|;
name|rid
operator|=
name|FUID_RID
argument_list|(
name|zfuid
operator|->
name|z_logfuid
argument_list|)
expr_stmt|;
name|idx
operator|=
name|FUID_INDEX
argument_list|(
name|zfuid
operator|->
name|z_logfuid
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_OWNER
case|:
name|rid
operator|=
name|FUID_RID
argument_list|(
name|fuidp
operator|->
name|z_fuid_owner
argument_list|)
expr_stmt|;
name|idx
operator|=
name|FUID_INDEX
argument_list|(
name|fuidp
operator|->
name|z_fuid_owner
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZFS_GROUP
case|:
name|rid
operator|=
name|FUID_RID
argument_list|(
name|fuidp
operator|->
name|z_fuid_group
argument_list|)
expr_stmt|;
name|idx
operator|=
name|FUID_INDEX
argument_list|(
name|fuidp
operator|->
name|z_fuid_group
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
name|domain
operator|=
name|fuidp
operator|->
name|z_domain_table
index|[
name|idx
operator|-
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|type
operator|==
name|ZFS_OWNER
operator|||
name|type
operator|==
name|ZFS_ACE_USER
condition|)
name|status
operator|=
name|kidmap_getsidbyuid
argument_list|(
name|crgetzone
argument_list|(
name|cr
argument_list|)
argument_list|,
name|id
argument_list|,
operator|&
name|domain
argument_list|,
operator|&
name|rid
argument_list|)
expr_stmt|;
else|else
name|status
operator|=
name|kidmap_getsidbygid
argument_list|(
name|crgetzone
argument_list|(
name|cr
argument_list|)
argument_list|,
name|id
argument_list|,
operator|&
name|domain
argument_list|,
operator|&
name|rid
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * When returning nobody we will need to 			 * make a dummy fuid table entry for logging 			 * purposes. 			 */
name|rid
operator|=
name|UID_NOBODY
expr_stmt|;
name|domain
operator|=
name|nulldomain
expr_stmt|;
block|}
block|}
name|idx
operator|=
name|zfs_fuid_find_by_domain
argument_list|(
name|zfsvfs
argument_list|,
name|domain
argument_list|,
operator|&
name|kdomain
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zfsvfs
operator|->
name|z_replay
condition|)
name|zfs_fuid_node_add
argument_list|(
name|fuidpp
argument_list|,
name|kdomain
argument_list|,
name|rid
argument_list|,
name|idx
argument_list|,
name|id
argument_list|,
name|type
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|zfuid
operator|!=
name|NULL
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|fuidp
operator|->
name|z_fuids
argument_list|,
name|zfuid
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zfuid
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_fuid_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|FUID_ENCODE
argument_list|(
name|idx
argument_list|,
name|rid
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zfs_fuid_destroy
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|)
block|{
name|rw_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_lock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zfsvfs
operator|->
name|z_fuid_loaded
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|zfs_fuid_table_destroy
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_idx
argument_list|,
operator|&
name|zfsvfs
operator|->
name|z_fuid_domain
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate zfs_fuid_info for tracking FUIDs created during  * zfs_mknode, VOP_SETATTR() or VOP_SETSECATTR()  */
end_comment

begin_function
name|zfs_fuid_info_t
modifier|*
name|zfs_fuid_info_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|zfs_fuid_info_t
modifier|*
name|fuidp
decl_stmt|;
name|fuidp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_fuid_info_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|fuidp
operator|->
name|z_domains
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_fuid_domain_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zfs_fuid_domain_t
argument_list|,
name|z_next
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|fuidp
operator|->
name|z_fuids
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_fuid_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zfs_fuid_t
argument_list|,
name|z_next
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|fuidp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release all memory associated with zfs_fuid_info_t  */
end_comment

begin_function
name|void
name|zfs_fuid_info_free
parameter_list|(
name|zfs_fuid_info_t
modifier|*
name|fuidp
parameter_list|)
block|{
name|zfs_fuid_t
modifier|*
name|zfuid
decl_stmt|;
name|zfs_fuid_domain_t
modifier|*
name|zdomain
decl_stmt|;
while|while
condition|(
operator|(
name|zfuid
operator|=
name|list_head
argument_list|(
operator|&
name|fuidp
operator|->
name|z_fuids
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|fuidp
operator|->
name|z_fuids
argument_list|,
name|zfuid
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zfuid
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_fuid_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fuidp
operator|->
name|z_domain_table
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|fuidp
operator|->
name|z_domain_table
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
operator|)
operator|*
name|fuidp
operator|->
name|z_domain_cnt
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|zdomain
operator|=
name|list_head
argument_list|(
operator|&
name|fuidp
operator|->
name|z_domains
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|fuidp
operator|->
name|z_domains
argument_list|,
name|zdomain
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zdomain
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_fuid_domain_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|fuidp
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_fuid_info_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to see if id is a groupmember.  If cred  * has ksid info then sidlist is checked first  * and if still not found then POSIX groups are checked  *  * Will use a straight FUID compare when possible.  */
end_comment

begin_function
name|boolean_t
name|zfs_groupmember
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|uint64_t
name|id
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|illumos
name|ksid_t
modifier|*
name|ksid
init|=
name|crgetsid
argument_list|(
name|cr
argument_list|,
name|KSID_GROUP
argument_list|)
decl_stmt|;
name|ksidlist_t
modifier|*
name|ksidlist
init|=
name|crgetsidlist
argument_list|(
name|cr
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|uid_t
name|gid
decl_stmt|;
ifdef|#
directive|ifdef
name|illumos
if|if
condition|(
name|ksid
operator|&&
name|ksidlist
condition|)
block|{
name|int
name|i
decl_stmt|;
name|ksid_t
modifier|*
name|ksid_groups
decl_stmt|;
name|uint32_t
name|idx
init|=
name|FUID_INDEX
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|uint32_t
name|rid
init|=
name|FUID_RID
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|ksid_groups
operator|=
name|ksidlist
operator|->
name|ksl_sids
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|ksidlist
operator|->
name|ksl_nsid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|idx
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|id
operator|!=
name|IDMAP_WK_CREATOR_GROUP_GID
operator|&&
name|id
operator|==
name|ksid_groups
index|[
name|i
index|]
operator|.
name|ks_id
condition|)
block|{
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|domain
decl_stmt|;
name|domain
operator|=
name|zfs_fuid_find_by_idx
argument_list|(
name|zfsvfs
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|domain
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|domain
argument_list|,
name|IDMAP_WK_CREATOR_SID_AUTHORITY
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|domain
argument_list|,
name|ksid_groups
index|[
name|i
index|]
operator|.
name|ks_domain
operator|->
name|kd_name
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|rid
operator|==
name|ksid_groups
index|[
name|i
index|]
operator|.
name|ks_rid
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* illumos */
comment|/* 	 * Not found in ksidlist, check posix groups 	 */
name|gid
operator|=
name|zfs_fuid_map_id
argument_list|(
name|zfsvfs
argument_list|,
name|id
argument_list|,
name|cr
argument_list|,
name|ZFS_GROUP
argument_list|)
expr_stmt|;
return|return
operator|(
name|groupmember
argument_list|(
name|gid
argument_list|,
name|cr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zfs_fuid_txhold
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
if|if
condition|(
name|zfsvfs
operator|->
name|z_fuid_obj
operator|==
literal|0
condition|)
block|{
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|FUID_SIZE_ESTIMATE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_fuid_obj
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_fuid_obj
argument_list|,
literal|0
argument_list|,
name|FUID_SIZE_ESTIMATE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

