begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/txg_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_scan.h>
end_include

begin_include
include|#
directive|include
file|<sys/callb.h>
end_include

begin_comment
comment|/*  * Pool-wide transaction groups.  */
end_comment

begin_function_decl
specifier|static
name|void
name|txg_sync_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|txg_quiesce_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|zfs_txg_timeout
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max seconds worth of delta per txg */
end_comment

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_zfs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vfs_zfs
argument_list|,
name|OID_AUTO
argument_list|,
name|txg
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"ZFS TXG"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.zfs.txg.timeout"
argument_list|,
operator|&
name|zfs_txg_timeout
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_txg
argument_list|,
name|OID_AUTO
argument_list|,
name|timeout
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|zfs_txg_timeout
argument_list|,
literal|0
argument_list|,
literal|"Maximum seconds worth of delta per txg"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Prepare the txg subsystem.  */
end_comment

begin_function
name|void
name|txg_init
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|int
name|c
decl_stmt|;
name|bzero
argument_list|(
name|tx
argument_list|,
sizeof|sizeof
argument_list|(
name|tx_state_t
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|->
name|tx_cpu
operator|=
name|kmem_zalloc
argument_list|(
name|max_ncpus
operator|*
sizeof|sizeof
argument_list|(
name|tx_cpu_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|max_ncpus
condition|;
name|c
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
name|mutex_init
argument_list|(
operator|&
name|tx
operator|->
name|tx_cpu
index|[
name|c
index|]
operator|.
name|tc_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|cv_init
argument_list|(
operator|&
name|tx
operator|->
name|tx_cpu
index|[
name|c
index|]
operator|.
name|tc_cv
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|tx
operator|->
name|tx_cpu
index|[
name|c
index|]
operator|.
name|tc_callbacks
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dmu_tx_callback_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dmu_tx_callback_t
argument_list|,
name|dcb_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_init
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_more_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_done_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_more_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_done_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|tx
operator|->
name|tx_exit_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tx
operator|->
name|tx_open_txg
operator|=
name|txg
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Close down the txg subsystem.  */
end_comment

begin_function
name|void
name|txg_fini
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|int
name|c
decl_stmt|;
name|ASSERT
argument_list|(
name|tx
operator|->
name|tx_threads
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_more_cv
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_done_cv
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_more_cv
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_done_cv
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|tx
operator|->
name|tx_exit_cv
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|max_ncpus
condition|;
name|c
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|tx
operator|->
name|tx_cpu
index|[
name|c
index|]
operator|.
name|tc_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|cv_destroy
argument_list|(
operator|&
name|tx
operator|->
name|tx_cpu
index|[
name|c
index|]
operator|.
name|tc_cv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|tx
operator|->
name|tx_cpu
index|[
name|c
index|]
operator|.
name|tc_callbacks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tx
operator|->
name|tx_commit_cb_taskq
operator|!=
name|NULL
condition|)
name|taskq_destroy
argument_list|(
name|tx
operator|->
name|tx_commit_cb_taskq
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|tx
operator|->
name|tx_cpu
argument_list|,
name|max_ncpus
operator|*
sizeof|sizeof
argument_list|(
name|tx_cpu_t
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|tx
argument_list|,
sizeof|sizeof
argument_list|(
name|tx_state_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start syncing transaction groups.  */
end_comment

begin_function
name|void
name|txg_sync_start
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"pool %p\n"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tx
operator|->
name|tx_threads
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tx
operator|->
name|tx_threads
operator|=
literal|2
expr_stmt|;
name|tx
operator|->
name|tx_quiesce_thread
operator|=
name|thread_create
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|txg_quiesce_thread
argument_list|,
name|dp
argument_list|,
literal|0
argument_list|,
operator|&
name|p0
argument_list|,
name|TS_RUN
argument_list|,
name|minclsyspri
argument_list|)
expr_stmt|;
comment|/* 	 * The sync thread can need a larger-than-default stack size on 	 * 32-bit x86.  This is due in part to nested pools and 	 * scrub_visitbp() recursion. 	 */
name|tx
operator|->
name|tx_sync_thread
operator|=
name|thread_create
argument_list|(
name|NULL
argument_list|,
literal|32
operator|<<
literal|10
argument_list|,
name|txg_sync_thread
argument_list|,
name|dp
argument_list|,
literal|0
argument_list|,
operator|&
name|p0
argument_list|,
name|TS_RUN
argument_list|,
name|minclsyspri
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|txg_thread_enter
parameter_list|(
name|tx_state_t
modifier|*
name|tx
parameter_list|,
name|callb_cpr_t
modifier|*
name|cpr
parameter_list|)
block|{
name|CALLB_CPR_INIT
argument_list|(
name|cpr
argument_list|,
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|,
name|callb_generic_cpr
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|txg_thread_exit
parameter_list|(
name|tx_state_t
modifier|*
name|tx
parameter_list|,
name|callb_cpr_t
modifier|*
name|cpr
parameter_list|,
name|kthread_t
modifier|*
modifier|*
name|tpp
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|*
name|tpp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|tpp
operator|=
name|NULL
expr_stmt|;
name|tx
operator|->
name|tx_threads
operator|--
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tx
operator|->
name|tx_exit_cv
argument_list|)
expr_stmt|;
name|CALLB_CPR_EXIT
argument_list|(
name|cpr
argument_list|)
expr_stmt|;
comment|/* drops&tx->tx_sync_lock */
name|thread_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|txg_thread_wait
parameter_list|(
name|tx_state_t
modifier|*
name|tx
parameter_list|,
name|callb_cpr_t
modifier|*
name|cpr
parameter_list|,
name|kcondvar_t
modifier|*
name|cv
parameter_list|,
name|uint64_t
name|time
parameter_list|)
block|{
name|CALLB_CPR_SAFE_BEGIN
argument_list|(
name|cpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|time
condition|)
operator|(
name|void
operator|)
name|cv_timedwait
argument_list|(
name|cv
argument_list|,
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|,
name|time
argument_list|)
expr_stmt|;
else|else
name|cv_wait
argument_list|(
name|cv
argument_list|,
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
name|CALLB_CPR_SAFE_END
argument_list|(
name|cpr
argument_list|,
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop syncing transaction groups.  */
end_comment

begin_function
name|void
name|txg_sync_stop
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|dprintf
argument_list|(
literal|"pool %p\n"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
comment|/* 	 * Finish off any work in progress. 	 */
name|ASSERT
argument_list|(
name|tx
operator|->
name|tx_threads
operator|==
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * We need to ensure that we've vacated the deferred space_maps. 	 */
name|txg_wait_synced
argument_list|(
name|dp
argument_list|,
name|tx
operator|->
name|tx_open_txg
operator|+
name|TXG_DEFER_SIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Wake all sync threads and wait for them to die. 	 */
name|mutex_enter
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tx
operator|->
name|tx_threads
operator|==
literal|2
argument_list|)
expr_stmt|;
name|tx
operator|->
name|tx_exiting
operator|=
literal|1
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_more_cv
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_done_cv
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_more_cv
argument_list|)
expr_stmt|;
while|while
condition|(
name|tx
operator|->
name|tx_threads
operator|!=
literal|0
condition|)
name|cv_wait
argument_list|(
operator|&
name|tx
operator|->
name|tx_exit_cv
argument_list|,
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
name|tx
operator|->
name|tx_exiting
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|txg_hold_open
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|txg_handle_t
modifier|*
name|th
parameter_list|)
block|{
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|tx_cpu_t
modifier|*
name|tc
init|=
operator|&
name|tx
operator|->
name|tx_cpu
index|[
name|CPU_SEQID
index|]
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
name|txg
operator|=
name|tx
operator|->
name|tx_open_txg
expr_stmt|;
name|tc
operator|->
name|tc_count
index|[
name|txg
operator|&
name|TXG_MASK
index|]
operator|++
expr_stmt|;
name|th
operator|->
name|th_cpu
operator|=
name|tc
expr_stmt|;
name|th
operator|->
name|th_txg
operator|=
name|txg
expr_stmt|;
return|return
operator|(
name|txg
operator|)
return|;
block|}
end_function

begin_function
name|void
name|txg_rele_to_quiesce
parameter_list|(
name|txg_handle_t
modifier|*
name|th
parameter_list|)
block|{
name|tx_cpu_t
modifier|*
name|tc
init|=
name|th
operator|->
name|th_cpu
decl_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|txg_register_callbacks
parameter_list|(
name|txg_handle_t
modifier|*
name|th
parameter_list|,
name|list_t
modifier|*
name|tx_callbacks
parameter_list|)
block|{
name|tx_cpu_t
modifier|*
name|tc
init|=
name|th
operator|->
name|th_cpu
decl_stmt|;
name|int
name|g
init|=
name|th
operator|->
name|th_txg
operator|&
name|TXG_MASK
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
name|list_move_tail
argument_list|(
operator|&
name|tc
operator|->
name|tc_callbacks
index|[
name|g
index|]
argument_list|,
name|tx_callbacks
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|txg_rele_to_sync
parameter_list|(
name|txg_handle_t
modifier|*
name|th
parameter_list|)
block|{
name|tx_cpu_t
modifier|*
name|tc
init|=
name|th
operator|->
name|th_cpu
decl_stmt|;
name|int
name|g
init|=
name|th
operator|->
name|th_txg
operator|&
name|TXG_MASK
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tc
operator|->
name|tc_count
index|[
name|g
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|tc
operator|->
name|tc_count
index|[
name|g
index|]
operator|==
literal|0
condition|)
name|cv_broadcast
argument_list|(
operator|&
name|tc
operator|->
name|tc_cv
index|[
name|g
index|]
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_cpu
operator|=
name|NULL
expr_stmt|;
comment|/* defensive */
block|}
end_function

begin_function
specifier|static
name|void
name|txg_quiesce
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|int
name|g
init|=
name|txg
operator|&
name|TXG_MASK
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* 	 * Grab all tx_cpu locks so nobody else can get into this txg. 	 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|max_ncpus
condition|;
name|c
operator|++
control|)
name|mutex_enter
argument_list|(
operator|&
name|tx
operator|->
name|tx_cpu
index|[
name|c
index|]
operator|.
name|tc_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|txg
operator|==
name|tx
operator|->
name|tx_open_txg
argument_list|)
expr_stmt|;
name|tx
operator|->
name|tx_open_txg
operator|++
expr_stmt|;
comment|/* 	 * Now that we've incremented tx_open_txg, we can let threads 	 * enter the next transaction group. 	 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|max_ncpus
condition|;
name|c
operator|++
control|)
name|mutex_exit
argument_list|(
operator|&
name|tx
operator|->
name|tx_cpu
index|[
name|c
index|]
operator|.
name|tc_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Quiesce the transaction group by waiting for everyone to txg_exit(). 	 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|max_ncpus
condition|;
name|c
operator|++
control|)
block|{
name|tx_cpu_t
modifier|*
name|tc
init|=
operator|&
name|tx
operator|->
name|tx_cpu
index|[
name|c
index|]
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|tc
operator|->
name|tc_count
index|[
name|g
index|]
operator|!=
literal|0
condition|)
name|cv_wait
argument_list|(
operator|&
name|tc
operator|->
name|tc_cv
index|[
name|g
index|]
argument_list|,
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|txg_do_callbacks
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|list_t
modifier|*
name|cb_list
init|=
name|arg
decl_stmt|;
name|dmu_tx_do_callbacks
argument_list|(
name|cb_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
name|cb_list
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|cb_list
argument_list|,
sizeof|sizeof
argument_list|(
name|list_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dispatch the commit callbacks registered on this txg to worker threads.  */
end_comment

begin_function
specifier|static
name|void
name|txg_dispatch_callbacks
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|list_t
modifier|*
name|cb_list
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|max_ncpus
condition|;
name|c
operator|++
control|)
block|{
name|tx_cpu_t
modifier|*
name|tc
init|=
operator|&
name|tx
operator|->
name|tx_cpu
index|[
name|c
index|]
decl_stmt|;
comment|/* No need to lock tx_cpu_t at this point */
name|int
name|g
init|=
name|txg
operator|&
name|TXG_MASK
decl_stmt|;
if|if
condition|(
name|list_is_empty
argument_list|(
operator|&
name|tc
operator|->
name|tc_callbacks
index|[
name|g
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|tx
operator|->
name|tx_commit_cb_taskq
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Commit callback taskq hasn't been created yet. 			 */
name|tx
operator|->
name|tx_commit_cb_taskq
operator|=
name|taskq_create
argument_list|(
literal|"tx_commit_cb"
argument_list|,
name|max_ncpus
argument_list|,
name|minclsyspri
argument_list|,
name|max_ncpus
argument_list|,
name|max_ncpus
operator|*
literal|2
argument_list|,
name|TASKQ_PREPOPULATE
argument_list|)
expr_stmt|;
block|}
name|cb_list
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|list_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
name|cb_list
argument_list|,
sizeof|sizeof
argument_list|(
name|dmu_tx_callback_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dmu_tx_callback_t
argument_list|,
name|dcb_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_move_tail
argument_list|(
operator|&
name|tc
operator|->
name|tc_callbacks
index|[
name|g
index|]
argument_list|,
name|cb_list
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|taskq_dispatch
argument_list|(
name|tx
operator|->
name|tx_commit_cb_taskq
argument_list|,
operator|(
name|task_func_t
operator|*
operator|)
name|txg_do_callbacks
argument_list|,
name|cb_list
argument_list|,
name|TQ_SLEEP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|txg_sync_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|arg
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|dp
operator|->
name|dp_spa
decl_stmt|;
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|callb_cpr_t
name|cpr
decl_stmt|;
name|uint64_t
name|start
decl_stmt|,
name|delta
decl_stmt|;
name|txg_thread_enter
argument_list|(
name|tx
argument_list|,
operator|&
name|cpr
argument_list|)
expr_stmt|;
name|start
operator|=
name|delta
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|uint64_t
name|timer
decl_stmt|,
name|timeout
init|=
name|zfs_txg_timeout
operator|*
name|hz
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|;
comment|/* 		 * We sync when we're scanning, there's someone waiting 		 * on us, or the quiesce thread has handed off a txg to 		 * us, or we have reached our timeout. 		 */
name|timer
operator|=
operator|(
name|delta
operator|>=
name|timeout
condition|?
literal|0
else|:
name|timeout
operator|-
name|delta
operator|)
expr_stmt|;
while|while
condition|(
operator|!
name|dsl_scan_active
argument_list|(
name|dp
operator|->
name|dp_scan
argument_list|)
operator|&&
operator|!
name|tx
operator|->
name|tx_exiting
operator|&&
name|timer
operator|>
literal|0
operator|&&
name|tx
operator|->
name|tx_synced_txg
operator|>=
name|tx
operator|->
name|tx_sync_txg_waiting
operator|&&
name|tx
operator|->
name|tx_quiesced_txg
operator|==
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|"waiting; tx_synced=%llu waiting=%llu dp=%p\n"
argument_list|,
name|tx
operator|->
name|tx_synced_txg
argument_list|,
name|tx
operator|->
name|tx_sync_txg_waiting
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|txg_thread_wait
argument_list|(
name|tx
argument_list|,
operator|&
name|cpr
argument_list|,
operator|&
name|tx
operator|->
name|tx_sync_more_cv
argument_list|,
name|timer
argument_list|)
expr_stmt|;
name|delta
operator|=
name|ddi_get_lbolt
argument_list|()
operator|-
name|start
expr_stmt|;
name|timer
operator|=
operator|(
name|delta
operator|>
name|timeout
condition|?
literal|0
else|:
name|timeout
operator|-
name|delta
operator|)
expr_stmt|;
block|}
comment|/* 		 * Wait until the quiesce thread hands off a txg to us, 		 * prompting it to do so if necessary. 		 */
while|while
condition|(
operator|!
name|tx
operator|->
name|tx_exiting
operator|&&
name|tx
operator|->
name|tx_quiesced_txg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tx
operator|->
name|tx_quiesce_txg_waiting
operator|<
name|tx
operator|->
name|tx_open_txg
operator|+
literal|1
condition|)
name|tx
operator|->
name|tx_quiesce_txg_waiting
operator|=
name|tx
operator|->
name|tx_open_txg
operator|+
literal|1
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_more_cv
argument_list|)
expr_stmt|;
name|txg_thread_wait
argument_list|(
name|tx
argument_list|,
operator|&
name|cpr
argument_list|,
operator|&
name|tx
operator|->
name|tx_quiesce_done_cv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tx
operator|->
name|tx_exiting
condition|)
name|txg_thread_exit
argument_list|(
name|tx
argument_list|,
operator|&
name|cpr
argument_list|,
operator|&
name|tx
operator|->
name|tx_sync_thread
argument_list|)
expr_stmt|;
comment|/* 		 * Consume the quiesced txg which has been handed off to 		 * us.  This may cause the quiescing thread to now be 		 * able to quiesce another txg, so we must signal it. 		 */
name|txg
operator|=
name|tx
operator|->
name|tx_quiesced_txg
expr_stmt|;
name|tx
operator|->
name|tx_quiesced_txg
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|tx_syncing_txg
operator|=
name|txg
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_more_cv
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"txg=%llu quiesce_txg=%llu sync_txg=%llu\n"
argument_list|,
name|txg
argument_list|,
name|tx
operator|->
name|tx_quiesce_txg_waiting
argument_list|,
name|tx
operator|->
name|tx_sync_txg_waiting
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
name|start
operator|=
name|ddi_get_lbolt
argument_list|()
expr_stmt|;
name|spa_sync
argument_list|(
name|spa
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|delta
operator|=
name|ddi_get_lbolt
argument_list|()
operator|-
name|start
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
name|tx
operator|->
name|tx_synced_txg
operator|=
name|txg
expr_stmt|;
name|tx
operator|->
name|tx_syncing_txg
operator|=
literal|0
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_done_cv
argument_list|)
expr_stmt|;
comment|/* 		 * Dispatch commit callbacks to worker threads. 		 */
name|txg_dispatch_callbacks
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|txg_quiesce_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|arg
decl_stmt|;
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|callb_cpr_t
name|cpr
decl_stmt|;
name|txg_thread_enter
argument_list|(
name|tx
argument_list|,
operator|&
name|cpr
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|uint64_t
name|txg
decl_stmt|;
comment|/* 		 * We quiesce when there's someone waiting on us. 		 * However, we can only have one txg in "quiescing" or 		 * "quiesced, waiting to sync" state.  So we wait until 		 * the "quiesced, waiting to sync" txg has been consumed 		 * by the sync thread. 		 */
while|while
condition|(
operator|!
name|tx
operator|->
name|tx_exiting
operator|&&
operator|(
name|tx
operator|->
name|tx_open_txg
operator|>=
name|tx
operator|->
name|tx_quiesce_txg_waiting
operator|||
name|tx
operator|->
name|tx_quiesced_txg
operator|!=
literal|0
operator|)
condition|)
name|txg_thread_wait
argument_list|(
name|tx
argument_list|,
operator|&
name|cpr
argument_list|,
operator|&
name|tx
operator|->
name|tx_quiesce_more_cv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|->
name|tx_exiting
condition|)
name|txg_thread_exit
argument_list|(
name|tx
argument_list|,
operator|&
name|cpr
argument_list|,
operator|&
name|tx
operator|->
name|tx_quiesce_thread
argument_list|)
expr_stmt|;
name|txg
operator|=
name|tx
operator|->
name|tx_open_txg
expr_stmt|;
name|dprintf
argument_list|(
literal|"txg=%llu quiesce_txg=%llu sync_txg=%llu\n"
argument_list|,
name|txg
argument_list|,
name|tx
operator|->
name|tx_quiesce_txg_waiting
argument_list|,
name|tx
operator|->
name|tx_sync_txg_waiting
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
name|txg_quiesce
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Hand this txg off to the sync thread. 		 */
name|dprintf
argument_list|(
literal|"quiesce done, handing off txg %llu\n"
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|tx
operator|->
name|tx_quiesced_txg
operator|=
name|txg
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_more_cv
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_done_cv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Delay this thread by 'ticks' if we are still in the open transaction  * group and there is already a waiting txg quiesing or quiesced.  Abort  * the delay if this txg stalls or enters the quiesing state.  */
end_comment

begin_function
name|void
name|txg_delay
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|int
name|ticks
parameter_list|)
block|{
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|clock_t
name|timeout
init|=
name|ddi_get_lbolt
argument_list|()
operator|+
name|ticks
decl_stmt|;
comment|/* don't delay if this txg could transition to quiesing immediately */
if|if
condition|(
name|tx
operator|->
name|tx_open_txg
operator|>
name|txg
operator|||
name|tx
operator|->
name|tx_syncing_txg
operator|==
name|txg
operator|-
literal|1
operator|||
name|tx
operator|->
name|tx_synced_txg
operator|==
name|txg
operator|-
literal|1
condition|)
return|return;
name|mutex_enter
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|->
name|tx_open_txg
operator|>
name|txg
operator|||
name|tx
operator|->
name|tx_synced_txg
operator|==
name|txg
operator|-
literal|1
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|ddi_get_lbolt
argument_list|()
operator|<
name|timeout
operator|&&
name|tx
operator|->
name|tx_syncing_txg
operator|<
name|txg
operator|-
literal|1
operator|&&
operator|!
name|txg_stalled
argument_list|(
name|dp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|cv_timedwait
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_more_cv
argument_list|,
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|,
name|timeout
operator|-
name|ddi_get_lbolt
argument_list|()
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|txg_wait_synced
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tx
operator|->
name|tx_threads
operator|==
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|==
literal|0
condition|)
name|txg
operator|=
name|tx
operator|->
name|tx_open_txg
operator|+
name|TXG_DEFER_SIZE
expr_stmt|;
if|if
condition|(
name|tx
operator|->
name|tx_sync_txg_waiting
operator|<
name|txg
condition|)
name|tx
operator|->
name|tx_sync_txg_waiting
operator|=
name|txg
expr_stmt|;
name|dprintf
argument_list|(
literal|"txg=%llu quiesce_txg=%llu sync_txg=%llu\n"
argument_list|,
name|txg
argument_list|,
name|tx
operator|->
name|tx_quiesce_txg_waiting
argument_list|,
name|tx
operator|->
name|tx_sync_txg_waiting
argument_list|)
expr_stmt|;
while|while
condition|(
name|tx
operator|->
name|tx_synced_txg
operator|<
name|txg
condition|)
block|{
name|dprintf
argument_list|(
literal|"broadcasting sync more "
literal|"tx_synced=%llu waiting=%llu dp=%p\n"
argument_list|,
name|tx
operator|->
name|tx_synced_txg
argument_list|,
name|tx
operator|->
name|tx_sync_txg_waiting
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_more_cv
argument_list|)
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_done_cv
argument_list|,
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|txg_wait_open
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tx
operator|->
name|tx_threads
operator|==
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|==
literal|0
condition|)
name|txg
operator|=
name|tx
operator|->
name|tx_open_txg
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tx
operator|->
name|tx_quiesce_txg_waiting
operator|<
name|txg
condition|)
name|tx
operator|->
name|tx_quiesce_txg_waiting
operator|=
name|txg
expr_stmt|;
name|dprintf
argument_list|(
literal|"txg=%llu quiesce_txg=%llu sync_txg=%llu\n"
argument_list|,
name|txg
argument_list|,
name|tx
operator|->
name|tx_quiesce_txg_waiting
argument_list|,
name|tx
operator|->
name|tx_sync_txg_waiting
argument_list|)
expr_stmt|;
while|while
condition|(
name|tx
operator|->
name|tx_open_txg
operator|<
name|txg
condition|)
block|{
name|cv_broadcast
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_more_cv
argument_list|)
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_done_cv
argument_list|,
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|txg_stalled
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
return|return
operator|(
name|tx
operator|->
name|tx_quiesce_txg_waiting
operator|>
name|tx
operator|->
name|tx_open_txg
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|txg_sync_waiting
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
return|return
operator|(
name|tx
operator|->
name|tx_syncing_txg
operator|<=
name|tx
operator|->
name|tx_sync_txg_waiting
operator|||
name|tx
operator|->
name|tx_quiesced_txg
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Per-txg object lists.  */
end_comment

begin_function
name|void
name|txg_list_create
parameter_list|(
name|txg_list_t
modifier|*
name|tl
parameter_list|,
name|size_t
name|offset
parameter_list|)
block|{
name|int
name|t
decl_stmt|;
name|mutex_init
argument_list|(
operator|&
name|tl
operator|->
name|tl_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tl
operator|->
name|tl_offset
operator|=
name|offset
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|TXG_SIZE
condition|;
name|t
operator|++
control|)
name|tl
operator|->
name|tl_head
index|[
name|t
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|txg_list_destroy
parameter_list|(
name|txg_list_t
modifier|*
name|tl
parameter_list|)
block|{
name|int
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|TXG_SIZE
condition|;
name|t
operator|++
control|)
name|ASSERT
argument_list|(
name|txg_list_empty
argument_list|(
name|tl
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|tl
operator|->
name|tl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|txg_list_empty
parameter_list|(
name|txg_list_t
modifier|*
name|tl
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
return|return
operator|(
name|tl
operator|->
name|tl_head
index|[
name|txg
operator|&
name|TXG_MASK
index|]
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an entry to the list.  * Returns 0 if it's a new entry, 1 if it's already there.  */
end_comment

begin_function
name|int
name|txg_list_add
parameter_list|(
name|txg_list_t
modifier|*
name|tl
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|int
name|t
init|=
name|txg
operator|&
name|TXG_MASK
decl_stmt|;
name|txg_node_t
modifier|*
name|tn
init|=
operator|(
name|txg_node_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|tl
operator|->
name|tl_offset
operator|)
decl_stmt|;
name|int
name|already_on_list
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tl
operator|->
name|tl_lock
argument_list|)
expr_stmt|;
name|already_on_list
operator|=
name|tn
operator|->
name|tn_member
index|[
name|t
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|already_on_list
condition|)
block|{
name|tn
operator|->
name|tn_member
index|[
name|t
index|]
operator|=
literal|1
expr_stmt|;
name|tn
operator|->
name|tn_next
index|[
name|t
index|]
operator|=
name|tl
operator|->
name|tl_head
index|[
name|t
index|]
expr_stmt|;
name|tl
operator|->
name|tl_head
index|[
name|t
index|]
operator|=
name|tn
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|tl
operator|->
name|tl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|already_on_list
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an entry to the end of the list (walks list to find end).  * Returns 0 if it's a new entry, 1 if it's already there.  */
end_comment

begin_function
name|int
name|txg_list_add_tail
parameter_list|(
name|txg_list_t
modifier|*
name|tl
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|int
name|t
init|=
name|txg
operator|&
name|TXG_MASK
decl_stmt|;
name|txg_node_t
modifier|*
name|tn
init|=
operator|(
name|txg_node_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|tl
operator|->
name|tl_offset
operator|)
decl_stmt|;
name|int
name|already_on_list
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tl
operator|->
name|tl_lock
argument_list|)
expr_stmt|;
name|already_on_list
operator|=
name|tn
operator|->
name|tn_member
index|[
name|t
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|already_on_list
condition|)
block|{
name|txg_node_t
modifier|*
modifier|*
name|tp
decl_stmt|;
for|for
control|(
name|tp
operator|=
operator|&
name|tl
operator|->
name|tl_head
index|[
name|t
index|]
init|;
operator|*
name|tp
operator|!=
name|NULL
condition|;
name|tp
operator|=
operator|&
operator|(
operator|*
name|tp
operator|)
operator|->
name|tn_next
index|[
name|t
index|]
control|)
continue|continue;
name|tn
operator|->
name|tn_member
index|[
name|t
index|]
operator|=
literal|1
expr_stmt|;
name|tn
operator|->
name|tn_next
index|[
name|t
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|tp
operator|=
name|tn
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|tl
operator|->
name|tl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|already_on_list
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove the head of the list and return it.  */
end_comment

begin_function
name|void
modifier|*
name|txg_list_remove
parameter_list|(
name|txg_list_t
modifier|*
name|tl
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|int
name|t
init|=
name|txg
operator|&
name|TXG_MASK
decl_stmt|;
name|txg_node_t
modifier|*
name|tn
decl_stmt|;
name|void
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tl
operator|->
name|tl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tn
operator|=
name|tl
operator|->
name|tl_head
index|[
name|t
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|tn
operator|-
name|tl
operator|->
name|tl_offset
expr_stmt|;
name|tl
operator|->
name|tl_head
index|[
name|t
index|]
operator|=
name|tn
operator|->
name|tn_next
index|[
name|t
index|]
expr_stmt|;
name|tn
operator|->
name|tn_next
index|[
name|t
index|]
operator|=
name|NULL
expr_stmt|;
name|tn
operator|->
name|tn_member
index|[
name|t
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|tl
operator|->
name|tl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a specific item from the list and return it.  */
end_comment

begin_function
name|void
modifier|*
name|txg_list_remove_this
parameter_list|(
name|txg_list_t
modifier|*
name|tl
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|int
name|t
init|=
name|txg
operator|&
name|TXG_MASK
decl_stmt|;
name|txg_node_t
modifier|*
name|tn
decl_stmt|,
modifier|*
modifier|*
name|tp
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tl
operator|->
name|tl_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|tp
operator|=
operator|&
name|tl
operator|->
name|tl_head
index|[
name|t
index|]
init|;
operator|(
name|tn
operator|=
operator|*
name|tp
operator|)
operator|!=
name|NULL
condition|;
name|tp
operator|=
operator|&
name|tn
operator|->
name|tn_next
index|[
name|t
index|]
control|)
block|{
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|tn
operator|-
name|tl
operator|->
name|tl_offset
operator|==
name|p
condition|)
block|{
operator|*
name|tp
operator|=
name|tn
operator|->
name|tn_next
index|[
name|t
index|]
expr_stmt|;
name|tn
operator|->
name|tn_next
index|[
name|t
index|]
operator|=
name|NULL
expr_stmt|;
name|tn
operator|->
name|tn_member
index|[
name|t
index|]
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tl
operator|->
name|tl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|tl
operator|->
name|tl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|txg_list_member
parameter_list|(
name|txg_list_t
modifier|*
name|tl
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|int
name|t
init|=
name|txg
operator|&
name|TXG_MASK
decl_stmt|;
name|txg_node_t
modifier|*
name|tn
init|=
operator|(
name|txg_node_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|tl
operator|->
name|tl_offset
operator|)
decl_stmt|;
return|return
operator|(
name|tn
operator|->
name|tn_member
index|[
name|t
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Walk a txg list -- only safe if you know it's not changing.  */
end_comment

begin_function
name|void
modifier|*
name|txg_list_head
parameter_list|(
name|txg_list_t
modifier|*
name|tl
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|int
name|t
init|=
name|txg
operator|&
name|TXG_MASK
decl_stmt|;
name|txg_node_t
modifier|*
name|tn
init|=
name|tl
operator|->
name|tl_head
index|[
name|t
index|]
decl_stmt|;
return|return
operator|(
name|tn
operator|==
name|NULL
condition|?
name|NULL
else|:
operator|(
name|char
operator|*
operator|)
name|tn
operator|-
name|tl
operator|->
name|tl_offset
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|txg_list_next
parameter_list|(
name|txg_list_t
modifier|*
name|tl
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|int
name|t
init|=
name|txg
operator|&
name|TXG_MASK
decl_stmt|;
name|txg_node_t
modifier|*
name|tn
init|=
operator|(
name|txg_node_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|tl
operator|->
name|tl_offset
operator|)
decl_stmt|;
name|tn
operator|=
name|tn
operator|->
name|tn_next
index|[
name|t
index|]
expr_stmt|;
return|return
operator|(
name|tn
operator|==
name|NULL
condition|?
name|NULL
else|:
operator|(
name|char
operator|*
operator|)
name|tn
operator|-
name|tl
operator|->
name|tl_offset
operator|)
return|;
block|}
end_function

end_unit

