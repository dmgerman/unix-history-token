begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2006 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_comment
comment|/*  * Virtual device vector for mirroring.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|mirror_child
block|{
name|vdev_t
modifier|*
name|mc_vd
decl_stmt|;
name|uint64_t
name|mc_offset
decl_stmt|;
name|int
name|mc_error
decl_stmt|;
name|short
name|mc_tried
decl_stmt|;
name|short
name|mc_skipped
decl_stmt|;
block|}
name|mirror_child_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|mirror_map
block|{
name|int
name|mm_children
decl_stmt|;
name|int
name|mm_replacing
decl_stmt|;
name|int
name|mm_preferred
decl_stmt|;
name|int
name|mm_root
decl_stmt|;
name|mirror_child_t
name|mm_child
index|[
literal|1
index|]
decl_stmt|;
block|}
name|mirror_map_t
typedef|;
end_typedef

begin_decl_stmt
name|int
name|vdev_mirror_shift
init|=
literal|21
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|mirror_map_t
modifier|*
name|vdev_mirror_map_alloc
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|mirror_map_t
modifier|*
name|mm
init|=
name|NULL
decl_stmt|;
name|mirror_child_t
modifier|*
name|mc
decl_stmt|;
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
decl_stmt|;
name|int
name|c
decl_stmt|,
name|d
decl_stmt|;
if|if
condition|(
name|vd
operator|==
name|NULL
condition|)
block|{
name|dva_t
modifier|*
name|dva
init|=
name|zio
operator|->
name|io_bp
operator|->
name|blk_dva
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|c
operator|=
name|BP_GET_NDVAS
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
expr_stmt|;
name|mm
operator|=
name|kmem_zalloc
argument_list|(
name|offsetof
argument_list|(
name|mirror_map_t
argument_list|,
name|mm_child
index|[
name|c
index|]
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|mm
operator|->
name|mm_children
operator|=
name|c
expr_stmt|;
name|mm
operator|->
name|mm_replacing
operator|=
name|B_FALSE
expr_stmt|;
name|mm
operator|->
name|mm_preferred
operator|=
name|spa_get_random
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|mm
operator|->
name|mm_root
operator|=
name|B_TRUE
expr_stmt|;
comment|/* 		 * Check the other, lower-index DVAs to see if they're on 		 * the same vdev as the child we picked.  If they are, use 		 * them since they are likely to have been allocated from 		 * the primary metaslab in use at the time, and hence are 		 * more likely to have locality with single-copy data. 		 */
for|for
control|(
name|c
operator|=
name|mm
operator|->
name|mm_preferred
operator|,
name|d
operator|=
name|c
operator|-
literal|1
init|;
name|d
operator|>=
literal|0
condition|;
name|d
operator|--
control|)
block|{
if|if
condition|(
name|DVA_GET_VDEV
argument_list|(
operator|&
name|dva
index|[
name|d
index|]
argument_list|)
operator|==
name|DVA_GET_VDEV
argument_list|(
operator|&
name|dva
index|[
name|c
index|]
argument_list|)
condition|)
name|mm
operator|->
name|mm_preferred
operator|=
name|d
expr_stmt|;
block|}
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|mm
operator|->
name|mm_children
condition|;
name|c
operator|++
control|)
block|{
name|mc
operator|=
operator|&
name|mm
operator|->
name|mm_child
index|[
name|c
index|]
expr_stmt|;
name|mc
operator|->
name|mc_vd
operator|=
name|vdev_lookup_top
argument_list|(
name|spa
argument_list|,
name|DVA_GET_VDEV
argument_list|(
operator|&
name|dva
index|[
name|c
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|mc
operator|->
name|mc_offset
operator|=
name|DVA_GET_OFFSET
argument_list|(
operator|&
name|dva
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|c
operator|=
name|vd
operator|->
name|vdev_children
expr_stmt|;
name|mm
operator|=
name|kmem_zalloc
argument_list|(
name|offsetof
argument_list|(
name|mirror_map_t
argument_list|,
name|mm_child
index|[
name|c
index|]
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|mm
operator|->
name|mm_children
operator|=
name|c
expr_stmt|;
name|mm
operator|->
name|mm_replacing
operator|=
operator|(
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_replacing_ops
operator|||
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
operator|)
expr_stmt|;
name|mm
operator|->
name|mm_preferred
operator|=
name|mm
operator|->
name|mm_replacing
condition|?
literal|0
else|:
operator|(
name|zio
operator|->
name|io_offset
operator|>>
name|vdev_mirror_shift
operator|)
operator|%
name|c
expr_stmt|;
name|mm
operator|->
name|mm_root
operator|=
name|B_FALSE
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|mm
operator|->
name|mm_children
condition|;
name|c
operator|++
control|)
block|{
name|mc
operator|=
operator|&
name|mm
operator|->
name|mm_child
index|[
name|c
index|]
expr_stmt|;
name|mc
operator|->
name|mc_vd
operator|=
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
expr_stmt|;
name|mc
operator|->
name|mc_offset
operator|=
name|zio
operator|->
name|io_offset
expr_stmt|;
block|}
block|}
name|zio
operator|->
name|io_vsd
operator|=
name|mm
expr_stmt|;
return|return
operator|(
name|mm
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_mirror_map_free
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|mirror_map_t
modifier|*
name|mm
init|=
name|zio
operator|->
name|io_vsd
decl_stmt|;
name|kmem_free
argument_list|(
name|mm
argument_list|,
name|offsetof
argument_list|(
name|mirror_map_t
argument_list|,
name|mm_child
index|[
name|mm
operator|->
name|mm_children
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_vsd
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_mirror_open
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
modifier|*
name|asize
parameter_list|,
name|uint64_t
modifier|*
name|ashift
parameter_list|)
block|{
name|vdev_t
modifier|*
name|cvd
decl_stmt|;
name|uint64_t
name|c
decl_stmt|;
name|int
name|numerrors
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|lasterror
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
condition|)
block|{
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|VDEV_AUX_BAD_LABEL
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|cvd
operator|=
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|vdev_open
argument_list|(
name|cvd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|lasterror
operator|=
name|ret
expr_stmt|;
name|numerrors
operator|++
expr_stmt|;
continue|continue;
block|}
operator|*
name|asize
operator|=
name|MIN
argument_list|(
operator|*
name|asize
operator|-
literal|1
argument_list|,
name|cvd
operator|->
name|vdev_asize
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|ashift
operator|=
name|MAX
argument_list|(
operator|*
name|ashift
argument_list|,
name|cvd
operator|->
name|vdev_ashift
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numerrors
operator|==
name|vd
operator|->
name|vdev_children
condition|)
block|{
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|VDEV_AUX_NO_REPLICAS
expr_stmt|;
return|return
operator|(
name|lasterror
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_mirror_close
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|uint64_t
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_close
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_mirror_child_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|mirror_child_t
modifier|*
name|mc
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|mc
operator|->
name|mc_error
operator|=
name|zio
operator|->
name|io_error
expr_stmt|;
name|mc
operator|->
name|mc_tried
operator|=
literal|1
expr_stmt|;
name|mc
operator|->
name|mc_skipped
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_mirror_scrub_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|mirror_child_t
modifier|*
name|mc
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
condition|)
block|{
name|zio_t
modifier|*
name|pio
init|=
name|zio
operator|->
name|io_parent
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_size
argument_list|,
operator|>=
argument_list|,
name|pio
operator|->
name|io_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|zio
operator|->
name|io_data
argument_list|,
name|pio
operator|->
name|io_data
argument_list|,
name|pio
operator|->
name|io_size
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
block|}
name|zio_buf_free
argument_list|(
name|zio
operator|->
name|io_data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|)
expr_stmt|;
name|mc
operator|->
name|mc_error
operator|=
name|zio
operator|->
name|io_error
expr_stmt|;
name|mc
operator|->
name|mc_tried
operator|=
literal|1
expr_stmt|;
name|mc
operator|->
name|mc_skipped
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_mirror_repair_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_private
operator|==
name|zio
operator|->
name|io_parent
argument_list|)
expr_stmt|;
name|vdev_mirror_map_free
argument_list|(
name|zio
operator|->
name|io_private
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Try to find a child whose DTL doesn't contain the block we want to read.  * If we can't, try the read on any vdev we haven't already tried.  */
end_comment

begin_function
specifier|static
name|int
name|vdev_mirror_child_select
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|mirror_map_t
modifier|*
name|mm
init|=
name|zio
operator|->
name|io_vsd
decl_stmt|;
name|mirror_child_t
modifier|*
name|mc
decl_stmt|;
name|uint64_t
name|txg
init|=
name|zio
operator|->
name|io_txg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_bp
operator|==
name|NULL
operator|||
name|zio
operator|->
name|io_bp
operator|->
name|blk_birth
operator|==
name|txg
argument_list|)
expr_stmt|;
comment|/* 	 * Try to find a child whose DTL doesn't contain the block to read. 	 * If a child is known to be completely inaccessible (indicated by 	 * vdev_is_dead() returning B_TRUE), don't even try. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|c
operator|=
name|mm
operator|->
name|mm_preferred
init|;
name|i
operator|<
name|mm
operator|->
name|mm_children
condition|;
name|i
operator|++
operator|,
name|c
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|>=
name|mm
operator|->
name|mm_children
condition|)
name|c
operator|=
literal|0
expr_stmt|;
name|mc
operator|=
operator|&
name|mm
operator|->
name|mm_child
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|mc_tried
operator|||
name|mc
operator|->
name|mc_skipped
condition|)
continue|continue;
if|if
condition|(
name|vdev_is_dead
argument_list|(
name|mc
operator|->
name|mc_vd
argument_list|)
condition|)
block|{
name|mc
operator|->
name|mc_error
operator|=
name|ENXIO
expr_stmt|;
name|mc
operator|->
name|mc_tried
operator|=
literal|1
expr_stmt|;
comment|/* don't even try */
name|mc
operator|->
name|mc_skipped
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|vdev_dtl_contains
argument_list|(
operator|&
name|mc
operator|->
name|mc_vd
operator|->
name|vdev_dtl_map
argument_list|,
name|txg
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
name|c
operator|)
return|;
name|mc
operator|->
name|mc_error
operator|=
name|ESTALE
expr_stmt|;
name|mc
operator|->
name|mc_skipped
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Every device is either missing or has this txg in its DTL. 	 * Look for any child we haven't already tried before giving up. 	 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|mm
operator|->
name|mm_children
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|!
name|mm
operator|->
name|mm_child
index|[
name|c
index|]
operator|.
name|mc_tried
condition|)
return|return
operator|(
name|c
operator|)
return|;
comment|/* 	 * Every child failed.  There's no place left to look. 	 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_mirror_io_start
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|mirror_map_t
modifier|*
name|mm
decl_stmt|;
name|mirror_child_t
modifier|*
name|mc
decl_stmt|;
name|int
name|c
decl_stmt|,
name|children
decl_stmt|;
name|mm
operator|=
name|vdev_mirror_map_alloc
argument_list|(
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
condition|)
block|{
if|if
condition|(
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_SCRUB
operator|)
operator|&&
operator|!
name|mm
operator|->
name|mm_replacing
condition|)
block|{
comment|/* 			 * For scrubbing reads we need to allocate a read 			 * buffer for each child and issue reads to all 			 * children.  If any child succeeds, it will copy its 			 * data into zio->io_data in vdev_mirror_scrub_done. 			 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|mm
operator|->
name|mm_children
condition|;
name|c
operator|++
control|)
block|{
name|mc
operator|=
operator|&
name|mm
operator|->
name|mm_child
index|[
name|c
index|]
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_vdev_child_io
argument_list|(
name|zio
argument_list|,
name|zio
operator|->
name|io_bp
argument_list|,
name|mc
operator|->
name|mc_vd
argument_list|,
name|mc
operator|->
name|mc_offset
argument_list|,
name|zio_buf_alloc
argument_list|(
name|zio
operator|->
name|io_size
argument_list|)
argument_list|,
name|zio
operator|->
name|io_size
argument_list|,
name|zio
operator|->
name|io_type
argument_list|,
name|zio
operator|->
name|io_priority
argument_list|,
name|ZIO_FLAG_CANFAIL
argument_list|,
name|vdev_mirror_scrub_done
argument_list|,
name|mc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zio_wait_children_done
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * For normal reads just pick one child. 		 */
name|c
operator|=
name|vdev_mirror_child_select
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|children
operator|=
operator|(
name|c
operator|>=
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
argument_list|)
expr_stmt|;
comment|/* 		 * If this is a resilvering I/O to a replacing vdev, 		 * only the last child should be written -- unless the 		 * first child happens to have a DTL entry here as well. 		 * All other writes go to all children. 		 */
if|if
condition|(
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_RESILVER
operator|)
operator|&&
name|mm
operator|->
name|mm_replacing
operator|&&
operator|!
name|vdev_dtl_contains
argument_list|(
operator|&
name|mm
operator|->
name|mm_child
index|[
literal|0
index|]
operator|.
name|mc_vd
operator|->
name|vdev_dtl_map
argument_list|,
name|zio
operator|->
name|io_txg
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|c
operator|=
name|mm
operator|->
name|mm_children
operator|-
literal|1
expr_stmt|;
name|children
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|c
operator|=
literal|0
expr_stmt|;
name|children
operator|=
name|mm
operator|->
name|mm_children
expr_stmt|;
block|}
block|}
while|while
condition|(
name|children
operator|--
condition|)
block|{
name|mc
operator|=
operator|&
name|mm
operator|->
name|mm_child
index|[
name|c
index|]
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_vdev_child_io
argument_list|(
name|zio
argument_list|,
name|zio
operator|->
name|io_bp
argument_list|,
name|mc
operator|->
name|mc_vd
argument_list|,
name|mc
operator|->
name|mc_offset
argument_list|,
name|zio
operator|->
name|io_data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|,
name|zio
operator|->
name|io_type
argument_list|,
name|zio
operator|->
name|io_priority
argument_list|,
name|ZIO_FLAG_CANFAIL
argument_list|,
name|vdev_mirror_child_done
argument_list|,
name|mc
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
name|zio_wait_children_done
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_mirror_io_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|mirror_map_t
modifier|*
name|mm
init|=
name|zio
operator|->
name|io_vsd
decl_stmt|;
name|mirror_child_t
modifier|*
name|mc
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|good_copies
init|=
literal|0
decl_stmt|;
name|int
name|unexpected_errors
init|=
literal|0
decl_stmt|;
name|zio
operator|->
name|io_error
operator|=
literal|0
expr_stmt|;
name|zio
operator|->
name|io_numerrors
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|mm
operator|->
name|mm_children
condition|;
name|c
operator|++
control|)
block|{
name|mc
operator|=
operator|&
name|mm
operator|->
name|mm_child
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|mc_tried
operator|&&
name|mc
operator|->
name|mc_error
operator|==
literal|0
condition|)
block|{
name|good_copies
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * We preserve any EIOs because those may be worth retrying; 		 * whereas ECKSUM and ENXIO are more likely to be persistent. 		 */
if|if
condition|(
name|mc
operator|->
name|mc_error
condition|)
block|{
if|if
condition|(
name|zio
operator|->
name|io_error
operator|!=
name|EIO
condition|)
name|zio
operator|->
name|io_error
operator|=
name|mc
operator|->
name|mc_error
expr_stmt|;
if|if
condition|(
operator|!
name|mc
operator|->
name|mc_skipped
condition|)
name|unexpected_errors
operator|++
expr_stmt|;
name|zio
operator|->
name|io_numerrors
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
condition|)
block|{
comment|/* 		 * XXX -- for now, treat partial writes as success. 		 * XXX -- For a replacing vdev, we need to make sure the 		 *	  new child succeeds. 		 */
comment|/* XXPOLICY */
if|if
condition|(
name|good_copies
operator|!=
literal|0
condition|)
name|zio
operator|->
name|io_error
operator|=
literal|0
expr_stmt|;
name|vdev_mirror_map_free
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|zio_next_stage
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return;
block|}
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
argument_list|)
expr_stmt|;
comment|/* 	 * If we don't have a good copy yet, keep trying other children. 	 */
comment|/* XXPOLICY */
if|if
condition|(
name|good_copies
operator|==
literal|0
operator|&&
operator|(
name|c
operator|=
name|vdev_mirror_child_select
argument_list|(
name|zio
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|ASSERT
argument_list|(
name|c
operator|>=
literal|0
operator|&&
name|c
operator|<
name|mm
operator|->
name|mm_children
argument_list|)
expr_stmt|;
name|mc
operator|=
operator|&
name|mm
operator|->
name|mm_child
index|[
name|c
index|]
expr_stmt|;
name|dprintf
argument_list|(
literal|"retrying i/o (err=%d) on child %s\n"
argument_list|,
name|zio
operator|->
name|io_error
argument_list|,
name|vdev_description
argument_list|(
name|mc
operator|->
name|mc_vd
argument_list|)
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_error
operator|=
literal|0
expr_stmt|;
name|zio_vdev_io_redone
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_vdev_child_io
argument_list|(
name|zio
argument_list|,
name|zio
operator|->
name|io_bp
argument_list|,
name|mc
operator|->
name|mc_vd
argument_list|,
name|mc
operator|->
name|mc_offset
argument_list|,
name|zio
operator|->
name|io_data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|,
name|ZIO_TYPE_READ
argument_list|,
name|zio
operator|->
name|io_priority
argument_list|,
name|ZIO_FLAG_CANFAIL
argument_list|,
name|vdev_mirror_child_done
argument_list|,
name|mc
argument_list|)
argument_list|)
expr_stmt|;
name|zio_wait_children_done
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* XXPOLICY */
if|if
condition|(
name|good_copies
condition|)
name|zio
operator|->
name|io_error
operator|=
literal|0
expr_stmt|;
else|else
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_error
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|good_copies
operator|&&
operator|(
name|spa_mode
operator|&
name|FWRITE
operator|)
operator|&&
operator|(
name|unexpected_errors
operator|||
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_RESILVER
operator|)
operator|||
operator|(
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_SCRUB
operator|)
operator|&&
name|mm
operator|->
name|mm_replacing
operator|)
operator|)
condition|)
block|{
name|zio_t
modifier|*
name|rio
decl_stmt|;
comment|/* 		 * Use the good data we have in hand to repair damaged children. 		 * 		 * We issue all repair I/Os as children of 'rio' to arrange 		 * that vdev_mirror_map_free(zio) will be invoked after all 		 * repairs complete, but before we advance to the next stage. 		 */
name|rio
operator|=
name|zio_null
argument_list|(
name|zio
argument_list|,
name|zio
operator|->
name|io_spa
argument_list|,
name|vdev_mirror_repair_done
argument_list|,
name|zio
argument_list|,
name|ZIO_FLAG_CANFAIL
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|mm
operator|->
name|mm_children
condition|;
name|c
operator|++
control|)
block|{
comment|/* 			 * Don't rewrite known good children. 			 * Not only is it unnecessary, it could 			 * actually be harmful: if the system lost 			 * power while rewriting the only good copy, 			 * there would be no good copies left! 			 */
name|mc
operator|=
operator|&
name|mm
operator|->
name|mm_child
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|mc_error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mc
operator|->
name|mc_tried
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_SCRUB
operator|)
operator|&&
operator|!
name|vdev_dtl_contains
argument_list|(
operator|&
name|mc
operator|->
name|mc_vd
operator|->
name|vdev_dtl_map
argument_list|,
name|zio
operator|->
name|io_txg
argument_list|,
literal|1
argument_list|)
condition|)
continue|continue;
name|mc
operator|->
name|mc_error
operator|=
name|ESTALE
expr_stmt|;
block|}
name|dprintf
argument_list|(
literal|"resilvered %s @ 0x%llx error %d\n"
argument_list|,
name|vdev_description
argument_list|(
name|mc
operator|->
name|mc_vd
argument_list|)
argument_list|,
name|mc
operator|->
name|mc_offset
argument_list|,
name|mc
operator|->
name|mc_error
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_vdev_child_io
argument_list|(
name|rio
argument_list|,
name|zio
operator|->
name|io_bp
argument_list|,
name|mc
operator|->
name|mc_vd
argument_list|,
name|mc
operator|->
name|mc_offset
argument_list|,
name|zio
operator|->
name|io_data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|,
name|ZIO_TYPE_WRITE
argument_list|,
name|zio
operator|->
name|io_priority
argument_list|,
name|ZIO_FLAG_IO_REPAIR
operator||
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_DONT_PROPAGATE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zio_nowait
argument_list|(
name|rio
argument_list|)
expr_stmt|;
name|zio_wait_children_done
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return;
block|}
name|vdev_mirror_map_free
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|zio_next_stage
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_mirror_state_change
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|int
name|faulted
parameter_list|,
name|int
name|degraded
parameter_list|)
block|{
if|if
condition|(
name|faulted
operator|==
name|vd
operator|->
name|vdev_children
condition|)
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_NO_REPLICAS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|degraded
operator|+
name|faulted
operator|!=
literal|0
condition|)
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_DEGRADED
argument_list|,
name|VDEV_AUX_NONE
argument_list|)
expr_stmt|;
else|else
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_HEALTHY
argument_list|,
name|VDEV_AUX_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|vdev_ops_t
name|vdev_mirror_ops
init|=
block|{
name|vdev_mirror_open
block|,
name|vdev_mirror_close
block|,
name|vdev_default_asize
block|,
name|vdev_mirror_io_start
block|,
name|vdev_mirror_io_done
block|,
name|vdev_mirror_state_change
block|,
name|VDEV_TYPE_MIRROR
block|,
comment|/* name of this vdev type */
name|B_FALSE
comment|/* not a leaf vdev */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vdev_ops_t
name|vdev_replacing_ops
init|=
block|{
name|vdev_mirror_open
block|,
name|vdev_mirror_close
block|,
name|vdev_default_asize
block|,
name|vdev_mirror_io_start
block|,
name|vdev_mirror_io_done
block|,
name|vdev_mirror_state_change
block|,
name|VDEV_TYPE_REPLACING
block|,
comment|/* name of this vdev type */
name|B_FALSE
comment|/* not a leaf vdev */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vdev_ops_t
name|vdev_spare_ops
init|=
block|{
name|vdev_mirror_open
block|,
name|vdev_mirror_close
block|,
name|vdev_default_asize
block|,
name|vdev_mirror_io_start
block|,
name|vdev_mirror_io_done
block|,
name|vdev_mirror_state_change
block|,
name|VDEV_TYPE_SPARE
block|,
comment|/* name of this vdev type */
name|B_FALSE
comment|/* not a leaf vdev */
block|}
decl_stmt|;
end_decl_stmt

end_unit

