begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2012, 2014 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_comment
comment|/*  * Virtual device vector for mirroring.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|mirror_child
block|{
name|vdev_t
modifier|*
name|mc_vd
decl_stmt|;
name|uint64_t
name|mc_offset
decl_stmt|;
name|int
name|mc_error
decl_stmt|;
name|int
name|mc_load
decl_stmt|;
name|uint8_t
name|mc_tried
decl_stmt|;
name|uint8_t
name|mc_skipped
decl_stmt|;
name|uint8_t
name|mc_speculative
decl_stmt|;
block|}
name|mirror_child_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|mirror_map
block|{
name|int
modifier|*
name|mm_preferred
decl_stmt|;
name|int
name|mm_preferred_cnt
decl_stmt|;
name|int
name|mm_children
decl_stmt|;
name|boolean_t
name|mm_replacing
decl_stmt|;
name|boolean_t
name|mm_root
decl_stmt|;
name|mirror_child_t
name|mm_child
index|[]
decl_stmt|;
block|}
name|mirror_map_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|vdev_mirror_shift
init|=
literal|21
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_vfs_zfs_vdev
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_vfs_zfs_vdev
argument_list|,
name|OID_AUTO
argument_list|,
name|mirror
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"ZFS VDEV Mirror"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The load configuration settings below are tuned by default for  * the case where all devices are of the same rotational type.  *  * If there is a mixture of rotating and non-rotating media, setting  * non_rotating_seek_inc to 0 may well provide better results as it  * will direct more reads to the non-rotating vdevs which are more  * likely to have a higher performance.  */
end_comment

begin_comment
comment|/* Rotating media load calculation configuration. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|rotating_inc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.zfs.vdev.mirror.rotating_inc"
argument_list|,
operator|&
name|rotating_inc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_vdev_mirror
argument_list|,
name|OID_AUTO
argument_list|,
name|rotating_inc
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|rotating_inc
argument_list|,
literal|0
argument_list|,
literal|"Rotating media load increment for non-seeking I/O's"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|rotating_seek_inc
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.zfs.vdev.mirror.rotating_seek_inc"
argument_list|,
operator|&
name|rotating_seek_inc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_vdev_mirror
argument_list|,
name|OID_AUTO
argument_list|,
name|rotating_seek_inc
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|rotating_seek_inc
argument_list|,
literal|0
argument_list|,
literal|"Rotating media load increment for seeking I/O's"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|rotating_seek_offset
init|=
literal|1
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.zfs.vdev.mirror.rotating_seek_offset"
argument_list|,
operator|&
name|rotating_seek_offset
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_vdev_mirror
argument_list|,
name|OID_AUTO
argument_list|,
name|rotating_seek_offset
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|rotating_seek_offset
argument_list|,
literal|0
argument_list|,
literal|"Offset in bytes from the last I/O which "
literal|"triggers a reduced rotating media seek increment"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Non-rotating media load calculation configuration. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|non_rotating_inc
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.zfs.vdev.mirror.non_rotating_inc"
argument_list|,
operator|&
name|non_rotating_inc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_vdev_mirror
argument_list|,
name|OID_AUTO
argument_list|,
name|non_rotating_inc
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|non_rotating_inc
argument_list|,
literal|0
argument_list|,
literal|"Non-rotating media load increment for non-seeking I/O's"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|non_rotating_seek_inc
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"vfs.zfs.vdev.mirror.non_rotating_seek_inc"
argument_list|,
operator|&
name|non_rotating_seek_inc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vfs_zfs_vdev_mirror
argument_list|,
name|OID_AUTO
argument_list|,
name|non_rotating_seek_inc
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|non_rotating_seek_inc
argument_list|,
literal|0
argument_list|,
literal|"Non-rotating media load increment for seeking I/O's"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
specifier|inline
name|size_t
name|vdev_mirror_map_size
parameter_list|(
name|int
name|children
parameter_list|)
block|{
return|return
operator|(
name|offsetof
argument_list|(
name|mirror_map_t
argument_list|,
name|mm_child
index|[
name|children
index|]
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|children
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|mirror_map_t
modifier|*
name|vdev_mirror_map_alloc
parameter_list|(
name|int
name|children
parameter_list|,
name|boolean_t
name|replacing
parameter_list|,
name|boolean_t
name|root
parameter_list|)
block|{
name|mirror_map_t
modifier|*
name|mm
decl_stmt|;
name|mm
operator|=
name|kmem_zalloc
argument_list|(
name|vdev_mirror_map_size
argument_list|(
name|children
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|mm
operator|->
name|mm_children
operator|=
name|children
expr_stmt|;
name|mm
operator|->
name|mm_replacing
operator|=
name|replacing
expr_stmt|;
name|mm
operator|->
name|mm_root
operator|=
name|root
expr_stmt|;
name|mm
operator|->
name|mm_preferred
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|mm
operator|+
name|offsetof
argument_list|(
name|mirror_map_t
argument_list|,
name|mm_child
index|[
name|children
index|]
argument_list|)
operator|)
expr_stmt|;
return|return
name|mm
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_mirror_map_free
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|mirror_map_t
modifier|*
name|mm
init|=
name|zio
operator|->
name|io_vsd
decl_stmt|;
name|kmem_free
argument_list|(
name|mm
argument_list|,
name|vdev_mirror_map_size
argument_list|(
name|mm
operator|->
name|mm_children
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|zio_vsd_ops_t
name|vdev_mirror_vsd_ops
init|=
block|{
name|vdev_mirror_map_free
block|,
name|zio_vsd_default_cksum_report
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|vdev_mirror_load
parameter_list|(
name|mirror_map_t
modifier|*
name|mm
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|zio_offset
parameter_list|)
block|{
name|uint64_t
name|lastoffset
decl_stmt|;
name|int
name|load
decl_stmt|;
comment|/* All DVAs have equal weight at the root. */
if|if
condition|(
name|mm
operator|->
name|mm_root
condition|)
return|return
operator|(
name|INT_MAX
operator|)
return|;
comment|/* 	 * We don't return INT_MAX if the device is resilvering i.e. 	 * vdev_resilver_txg != 0 as when tested performance was slightly 	 * worse overall when resilvering with compared to without. 	 */
comment|/* Standard load based on pending queue length. */
name|load
operator|=
name|vdev_queue_length
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|lastoffset
operator|=
name|vdev_queue_lastoffset
argument_list|(
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_rotation_rate
operator|==
name|VDEV_RATE_NON_ROTATING
condition|)
block|{
comment|/* Non-rotating media. */
if|if
condition|(
name|lastoffset
operator|==
name|zio_offset
condition|)
return|return
operator|(
name|load
operator|+
name|non_rotating_inc
operator|)
return|;
comment|/* 		 * Apply a seek penalty even for non-rotating devices as 		 * sequential I/O'a can be aggregated into fewer operations 		 * on the device, thus avoiding unnecessary per-command 		 * overhead and boosting performance. 		 */
return|return
operator|(
name|load
operator|+
name|non_rotating_seek_inc
operator|)
return|;
block|}
comment|/* Rotating media I/O's which directly follow the last I/O. */
if|if
condition|(
name|lastoffset
operator|==
name|zio_offset
condition|)
return|return
operator|(
name|load
operator|+
name|rotating_inc
operator|)
return|;
comment|/* 	 * Apply half the seek increment to I/O's within seek offset 	 * of the last I/O queued to this vdev as they should incure less 	 * of a seek increment. 	 */
if|if
condition|(
name|ABS
argument_list|(
name|lastoffset
operator|-
name|zio_offset
argument_list|)
operator|<
name|rotating_seek_offset
condition|)
return|return
operator|(
name|load
operator|+
operator|(
name|rotating_seek_inc
operator|/
literal|2
operator|)
operator|)
return|;
comment|/* Apply the full seek increment to all other I/O's. */
return|return
operator|(
name|load
operator|+
name|rotating_seek_inc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|mirror_map_t
modifier|*
name|vdev_mirror_map_init
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|mirror_map_t
modifier|*
name|mm
init|=
name|NULL
decl_stmt|;
name|mirror_child_t
modifier|*
name|mc
decl_stmt|;
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|vd
operator|==
name|NULL
condition|)
block|{
name|dva_t
modifier|*
name|dva
init|=
name|zio
operator|->
name|io_bp
operator|->
name|blk_dva
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|mm
operator|=
name|vdev_mirror_map_alloc
argument_list|(
name|BP_GET_NDVAS
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
argument_list|,
name|B_FALSE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|mm
operator|->
name|mm_children
condition|;
name|c
operator|++
control|)
block|{
name|mc
operator|=
operator|&
name|mm
operator|->
name|mm_child
index|[
name|c
index|]
expr_stmt|;
name|mc
operator|->
name|mc_vd
operator|=
name|vdev_lookup_top
argument_list|(
name|spa
argument_list|,
name|DVA_GET_VDEV
argument_list|(
operator|&
name|dva
index|[
name|c
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|mc
operator|->
name|mc_offset
operator|=
name|DVA_GET_OFFSET
argument_list|(
operator|&
name|dva
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mm
operator|=
name|vdev_mirror_map_alloc
argument_list|(
name|vd
operator|->
name|vdev_children
argument_list|,
operator|(
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_replacing_ops
operator|||
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
operator|)
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|mm
operator|->
name|mm_children
condition|;
name|c
operator|++
control|)
block|{
name|mc
operator|=
operator|&
name|mm
operator|->
name|mm_child
index|[
name|c
index|]
expr_stmt|;
name|mc
operator|->
name|mc_vd
operator|=
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
expr_stmt|;
name|mc
operator|->
name|mc_offset
operator|=
name|zio
operator|->
name|io_offset
expr_stmt|;
block|}
block|}
name|zio
operator|->
name|io_vsd
operator|=
name|mm
expr_stmt|;
name|zio
operator|->
name|io_vsd_ops
operator|=
operator|&
name|vdev_mirror_vsd_ops
expr_stmt|;
return|return
operator|(
name|mm
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_mirror_open
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
modifier|*
name|asize
parameter_list|,
name|uint64_t
modifier|*
name|max_asize
parameter_list|,
name|uint64_t
modifier|*
name|logical_ashift
parameter_list|,
name|uint64_t
modifier|*
name|physical_ashift
parameter_list|)
block|{
name|int
name|numerrors
init|=
literal|0
decl_stmt|;
name|int
name|lasterror
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
condition|)
block|{
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|VDEV_AUX_BAD_LABEL
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|vdev_open_children
argument_list|(
name|vd
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|cvd
init|=
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
decl_stmt|;
if|if
condition|(
name|cvd
operator|->
name|vdev_open_error
condition|)
block|{
name|lasterror
operator|=
name|cvd
operator|->
name|vdev_open_error
expr_stmt|;
name|numerrors
operator|++
expr_stmt|;
continue|continue;
block|}
operator|*
name|asize
operator|=
name|MIN
argument_list|(
operator|*
name|asize
operator|-
literal|1
argument_list|,
name|cvd
operator|->
name|vdev_asize
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|max_asize
operator|=
name|MIN
argument_list|(
operator|*
name|max_asize
operator|-
literal|1
argument_list|,
name|cvd
operator|->
name|vdev_max_asize
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|logical_ashift
operator|=
name|MAX
argument_list|(
operator|*
name|logical_ashift
argument_list|,
name|cvd
operator|->
name|vdev_ashift
argument_list|)
expr_stmt|;
operator|*
name|physical_ashift
operator|=
name|MAX
argument_list|(
operator|*
name|physical_ashift
argument_list|,
name|cvd
operator|->
name|vdev_physical_ashift
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|numerrors
operator|==
name|vd
operator|->
name|vdev_children
condition|)
block|{
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|VDEV_AUX_NO_REPLICAS
expr_stmt|;
return|return
operator|(
name|lasterror
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_mirror_close
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_close
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_mirror_child_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|mirror_child_t
modifier|*
name|mc
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|mc
operator|->
name|mc_error
operator|=
name|zio
operator|->
name|io_error
expr_stmt|;
name|mc
operator|->
name|mc_tried
operator|=
literal|1
expr_stmt|;
name|mc
operator|->
name|mc_skipped
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_mirror_scrub_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|mirror_child_t
modifier|*
name|mc
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
condition|)
block|{
name|zio_t
modifier|*
name|pio
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pio
operator|=
name|zio_walk_parents
argument_list|(
name|zio
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_size
argument_list|,
operator|>=
argument_list|,
name|pio
operator|->
name|io_size
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|zio
operator|->
name|io_data
argument_list|,
name|pio
operator|->
name|io_data
argument_list|,
name|pio
operator|->
name|io_size
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
block|}
name|zio_buf_free
argument_list|(
name|zio
operator|->
name|io_data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|)
expr_stmt|;
name|mc
operator|->
name|mc_error
operator|=
name|zio
operator|->
name|io_error
expr_stmt|;
name|mc
operator|->
name|mc_tried
operator|=
literal|1
expr_stmt|;
name|mc
operator|->
name|mc_skipped
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check the other, lower-index DVAs to see if they're on the same  * vdev as the child we picked.  If they are, use them since they  * are likely to have been allocated from the primary metaslab in  * use at the time, and hence are more likely to have locality with  * single-copy data.  */
end_comment

begin_function
specifier|static
name|int
name|vdev_mirror_dva_select
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|int
name|p
parameter_list|)
block|{
name|dva_t
modifier|*
name|dva
init|=
name|zio
operator|->
name|io_bp
operator|->
name|blk_dva
decl_stmt|;
name|mirror_map_t
modifier|*
name|mm
init|=
name|zio
operator|->
name|io_vsd
decl_stmt|;
name|int
name|preferred
decl_stmt|;
name|int
name|c
decl_stmt|;
name|preferred
operator|=
name|mm
operator|->
name|mm_preferred
index|[
name|p
index|]
expr_stmt|;
for|for
control|(
name|p
operator|--
init|;
name|p
operator|>=
literal|0
condition|;
name|p
operator|--
control|)
block|{
name|c
operator|=
name|mm
operator|->
name|mm_preferred
index|[
name|p
index|]
expr_stmt|;
if|if
condition|(
name|DVA_GET_VDEV
argument_list|(
operator|&
name|dva
index|[
name|c
index|]
argument_list|)
operator|==
name|DVA_GET_VDEV
argument_list|(
operator|&
name|dva
index|[
name|preferred
index|]
argument_list|)
condition|)
name|preferred
operator|=
name|c
expr_stmt|;
block|}
return|return
operator|(
name|preferred
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_mirror_preferred_child_randomize
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|mirror_map_t
modifier|*
name|mm
init|=
name|zio
operator|->
name|io_vsd
decl_stmt|;
name|int
name|p
decl_stmt|;
if|if
condition|(
name|mm
operator|->
name|mm_root
condition|)
block|{
name|p
operator|=
name|spa_get_random
argument_list|(
name|mm
operator|->
name|mm_preferred_cnt
argument_list|)
expr_stmt|;
return|return
operator|(
name|vdev_mirror_dva_select
argument_list|(
name|zio
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * To ensure we don't always favour the first matching vdev, 	 * which could lead to wear leveling issues on SSD's, we 	 * use the I/O offset as a pseudo random seed into the vdevs 	 * which have the lowest load. 	 */
name|p
operator|=
operator|(
name|zio
operator|->
name|io_offset
operator|>>
name|vdev_mirror_shift
operator|)
operator|%
name|mm
operator|->
name|mm_preferred_cnt
expr_stmt|;
return|return
operator|(
name|mm
operator|->
name|mm_preferred
index|[
name|p
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try to find a vdev whose DTL doesn't contain the block we want to read  * prefering vdevs based on determined load.  *  * If we can't, try the read on any vdev we haven't already tried.  */
end_comment

begin_function
specifier|static
name|int
name|vdev_mirror_child_select
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|mirror_map_t
modifier|*
name|mm
init|=
name|zio
operator|->
name|io_vsd
decl_stmt|;
name|uint64_t
name|txg
init|=
name|zio
operator|->
name|io_txg
decl_stmt|;
name|int
name|c
decl_stmt|,
name|lowest_load
decl_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_bp
operator|==
name|NULL
operator|||
name|BP_PHYSICAL_BIRTH
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
operator|==
name|txg
argument_list|)
expr_stmt|;
name|lowest_load
operator|=
name|INT_MAX
expr_stmt|;
name|mm
operator|->
name|mm_preferred_cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|mm
operator|->
name|mm_children
condition|;
name|c
operator|++
control|)
block|{
name|mirror_child_t
modifier|*
name|mc
decl_stmt|;
name|mc
operator|=
operator|&
name|mm
operator|->
name|mm_child
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|mc_tried
operator|||
name|mc
operator|->
name|mc_skipped
condition|)
continue|continue;
if|if
condition|(
operator|!
name|vdev_readable
argument_list|(
name|mc
operator|->
name|mc_vd
argument_list|)
condition|)
block|{
name|mc
operator|->
name|mc_error
operator|=
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
name|mc
operator|->
name|mc_tried
operator|=
literal|1
expr_stmt|;
comment|/* don't even try */
name|mc
operator|->
name|mc_skipped
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|vdev_dtl_contains
argument_list|(
name|mc
operator|->
name|mc_vd
argument_list|,
name|DTL_MISSING
argument_list|,
name|txg
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|mc
operator|->
name|mc_error
operator|=
name|SET_ERROR
argument_list|(
name|ESTALE
argument_list|)
expr_stmt|;
name|mc
operator|->
name|mc_skipped
operator|=
literal|1
expr_stmt|;
name|mc
operator|->
name|mc_speculative
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|mc
operator|->
name|mc_load
operator|=
name|vdev_mirror_load
argument_list|(
name|mm
argument_list|,
name|mc
operator|->
name|mc_vd
argument_list|,
name|mc
operator|->
name|mc_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|mc_load
operator|>
name|lowest_load
condition|)
continue|continue;
if|if
condition|(
name|mc
operator|->
name|mc_load
operator|<
name|lowest_load
condition|)
block|{
name|lowest_load
operator|=
name|mc
operator|->
name|mc_load
expr_stmt|;
name|mm
operator|->
name|mm_preferred_cnt
operator|=
literal|0
expr_stmt|;
block|}
name|mm
operator|->
name|mm_preferred
index|[
name|mm
operator|->
name|mm_preferred_cnt
index|]
operator|=
name|c
expr_stmt|;
name|mm
operator|->
name|mm_preferred_cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mm
operator|->
name|mm_preferred_cnt
operator|==
literal|1
condition|)
block|{
name|vdev_queue_register_lastoffset
argument_list|(
name|mm
operator|->
name|mm_child
index|[
name|mm
operator|->
name|mm_preferred
index|[
literal|0
index|]
index|]
operator|.
name|mc_vd
argument_list|,
name|zio
argument_list|)
expr_stmt|;
return|return
operator|(
name|mm
operator|->
name|mm_preferred
index|[
literal|0
index|]
operator|)
return|;
block|}
if|if
condition|(
name|mm
operator|->
name|mm_preferred_cnt
operator|>
literal|1
condition|)
block|{
name|int
name|c
init|=
name|vdev_mirror_preferred_child_randomize
argument_list|(
name|zio
argument_list|)
decl_stmt|;
name|vdev_queue_register_lastoffset
argument_list|(
name|mm
operator|->
name|mm_child
index|[
name|c
index|]
operator|.
name|mc_vd
argument_list|,
name|zio
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
comment|/* 	 * Every device is either missing or has this txg in its DTL. 	 * Look for any child we haven't already tried before giving up. 	 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|mm
operator|->
name|mm_children
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|mm
operator|->
name|mm_child
index|[
name|c
index|]
operator|.
name|mc_tried
condition|)
block|{
name|vdev_queue_register_lastoffset
argument_list|(
name|mm
operator|->
name|mm_child
index|[
name|c
index|]
operator|.
name|mc_vd
argument_list|,
name|zio
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
block|}
comment|/* 	 * Every child failed.  There's no place left to look. 	 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_mirror_io_start
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|mirror_map_t
modifier|*
name|mm
decl_stmt|;
name|mirror_child_t
modifier|*
name|mc
decl_stmt|;
name|int
name|c
decl_stmt|,
name|children
decl_stmt|;
name|mm
operator|=
name|vdev_mirror_map_init
argument_list|(
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
condition|)
block|{
if|if
condition|(
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_SCRUB
operator|)
operator|&&
operator|!
name|mm
operator|->
name|mm_replacing
operator|&&
name|mm
operator|->
name|mm_children
operator|>
literal|1
condition|)
block|{
comment|/* 			 * For scrubbing reads we need to allocate a read 			 * buffer for each child and issue reads to all 			 * children.  If any child succeeds, it will copy its 			 * data into zio->io_data in vdev_mirror_scrub_done. 			 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|mm
operator|->
name|mm_children
condition|;
name|c
operator|++
control|)
block|{
name|mc
operator|=
operator|&
name|mm
operator|->
name|mm_child
index|[
name|c
index|]
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_vdev_child_io
argument_list|(
name|zio
argument_list|,
name|zio
operator|->
name|io_bp
argument_list|,
name|mc
operator|->
name|mc_vd
argument_list|,
name|mc
operator|->
name|mc_offset
argument_list|,
name|zio_buf_alloc
argument_list|(
name|zio
operator|->
name|io_size
argument_list|)
argument_list|,
name|zio
operator|->
name|io_size
argument_list|,
name|zio
operator|->
name|io_type
argument_list|,
name|zio
operator|->
name|io_priority
argument_list|,
literal|0
argument_list|,
name|vdev_mirror_scrub_done
argument_list|,
name|mc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zio_execute
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * For normal reads just pick one child. 		 */
name|c
operator|=
name|vdev_mirror_child_select
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|children
operator|=
operator|(
name|c
operator|>=
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
operator|||
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_FREE
argument_list|)
expr_stmt|;
comment|/* 		 * Writes and frees go to all children. 		 */
name|c
operator|=
literal|0
expr_stmt|;
name|children
operator|=
name|mm
operator|->
name|mm_children
expr_stmt|;
block|}
while|while
condition|(
name|children
operator|--
condition|)
block|{
name|mc
operator|=
operator|&
name|mm
operator|->
name|mm_child
index|[
name|c
index|]
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_vdev_child_io
argument_list|(
name|zio
argument_list|,
name|zio
operator|->
name|io_bp
argument_list|,
name|mc
operator|->
name|mc_vd
argument_list|,
name|mc
operator|->
name|mc_offset
argument_list|,
name|zio
operator|->
name|io_data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|,
name|zio
operator|->
name|io_type
argument_list|,
name|zio
operator|->
name|io_priority
argument_list|,
literal|0
argument_list|,
name|vdev_mirror_child_done
argument_list|,
name|mc
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
name|zio_execute
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_mirror_worst_error
parameter_list|(
name|mirror_map_t
modifier|*
name|mm
parameter_list|)
block|{
name|int
name|error
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|mm
operator|->
name|mm_children
condition|;
name|c
operator|++
control|)
block|{
name|mirror_child_t
modifier|*
name|mc
init|=
operator|&
name|mm
operator|->
name|mm_child
index|[
name|c
index|]
decl_stmt|;
name|int
name|s
init|=
name|mc
operator|->
name|mc_speculative
decl_stmt|;
name|error
index|[
name|s
index|]
operator|=
name|zio_worst_error
argument_list|(
name|error
index|[
name|s
index|]
argument_list|,
name|mc
operator|->
name|mc_error
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
index|[
literal|0
index|]
condition|?
name|error
index|[
literal|0
index|]
else|:
name|error
index|[
literal|1
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_mirror_io_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|mirror_map_t
modifier|*
name|mm
init|=
name|zio
operator|->
name|io_vsd
decl_stmt|;
name|mirror_child_t
modifier|*
name|mc
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|good_copies
init|=
literal|0
decl_stmt|;
name|int
name|unexpected_errors
init|=
literal|0
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|mm
operator|->
name|mm_children
condition|;
name|c
operator|++
control|)
block|{
name|mc
operator|=
operator|&
name|mm
operator|->
name|mm_child
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|mc_error
condition|)
block|{
if|if
condition|(
operator|!
name|mc
operator|->
name|mc_skipped
condition|)
name|unexpected_errors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mc
operator|->
name|mc_tried
condition|)
block|{
name|good_copies
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
condition|)
block|{
comment|/* 		 * XXX -- for now, treat partial writes as success. 		 * 		 * Now that we support write reallocation, it would be better 		 * to treat partial failure as real failure unless there are 		 * no non-degraded top-level vdevs left, and not update DTLs 		 * if we intend to reallocate. 		 */
comment|/* XXPOLICY */
if|if
condition|(
name|good_copies
operator|!=
name|mm
operator|->
name|mm_children
condition|)
block|{
comment|/* 			 * Always require at least one good copy. 			 * 			 * For ditto blocks (io_vd == NULL), require 			 * all copies to be good. 			 * 			 * XXX -- for replacing vdevs, there's no great answer. 			 * If the old device is really dead, we may not even 			 * be able to access it -- so we only want to 			 * require good writes to the new device.  But if 			 * the new device turns out to be flaky, we want 			 * to be able to detach it -- which requires all 			 * writes to the old device to have succeeded. 			 */
if|if
condition|(
name|good_copies
operator|==
literal|0
operator|||
name|zio
operator|->
name|io_vd
operator|==
name|NULL
condition|)
name|zio
operator|->
name|io_error
operator|=
name|vdev_mirror_worst_error
argument_list|(
name|mm
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_FREE
condition|)
block|{
return|return;
block|}
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
argument_list|)
expr_stmt|;
comment|/* 	 * If we don't have a good copy yet, keep trying other children. 	 */
comment|/* XXPOLICY */
if|if
condition|(
name|good_copies
operator|==
literal|0
operator|&&
operator|(
name|c
operator|=
name|vdev_mirror_child_select
argument_list|(
name|zio
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|ASSERT
argument_list|(
name|c
operator|>=
literal|0
operator|&&
name|c
operator|<
name|mm
operator|->
name|mm_children
argument_list|)
expr_stmt|;
name|mc
operator|=
operator|&
name|mm
operator|->
name|mm_child
index|[
name|c
index|]
expr_stmt|;
name|zio_vdev_io_redone
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_vdev_child_io
argument_list|(
name|zio
argument_list|,
name|zio
operator|->
name|io_bp
argument_list|,
name|mc
operator|->
name|mc_vd
argument_list|,
name|mc
operator|->
name|mc_offset
argument_list|,
name|zio
operator|->
name|io_data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|,
name|ZIO_TYPE_READ
argument_list|,
name|zio
operator|->
name|io_priority
argument_list|,
literal|0
argument_list|,
name|vdev_mirror_child_done
argument_list|,
name|mc
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* XXPOLICY */
if|if
condition|(
name|good_copies
operator|==
literal|0
condition|)
block|{
name|zio
operator|->
name|io_error
operator|=
name|vdev_mirror_worst_error
argument_list|(
name|mm
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_error
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|good_copies
operator|&&
name|spa_writeable
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|)
operator|&&
operator|(
name|unexpected_errors
operator|||
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_RESILVER
operator|)
operator|||
operator|(
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_SCRUB
operator|)
operator|&&
name|mm
operator|->
name|mm_replacing
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Use the good data we have in hand to repair damaged children. 		 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|mm
operator|->
name|mm_children
condition|;
name|c
operator|++
control|)
block|{
comment|/* 			 * Don't rewrite known good children. 			 * Not only is it unnecessary, it could 			 * actually be harmful: if the system lost 			 * power while rewriting the only good copy, 			 * there would be no good copies left! 			 */
name|mc
operator|=
operator|&
name|mm
operator|->
name|mm_child
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|mc_error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mc
operator|->
name|mc_tried
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_SCRUB
operator|)
operator|&&
operator|!
name|vdev_dtl_contains
argument_list|(
name|mc
operator|->
name|mc_vd
argument_list|,
name|DTL_PARTIAL
argument_list|,
name|zio
operator|->
name|io_txg
argument_list|,
literal|1
argument_list|)
condition|)
continue|continue;
name|mc
operator|->
name|mc_error
operator|=
name|SET_ERROR
argument_list|(
name|ESTALE
argument_list|)
expr_stmt|;
block|}
name|zio_nowait
argument_list|(
name|zio_vdev_child_io
argument_list|(
name|zio
argument_list|,
name|zio
operator|->
name|io_bp
argument_list|,
name|mc
operator|->
name|mc_vd
argument_list|,
name|mc
operator|->
name|mc_offset
argument_list|,
name|zio
operator|->
name|io_data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|,
name|ZIO_TYPE_WRITE
argument_list|,
name|ZIO_PRIORITY_ASYNC_WRITE
argument_list|,
name|ZIO_FLAG_IO_REPAIR
operator||
operator|(
name|unexpected_errors
condition|?
name|ZIO_FLAG_SELF_HEAL
else|:
literal|0
operator|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_mirror_state_change
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|int
name|faulted
parameter_list|,
name|int
name|degraded
parameter_list|)
block|{
if|if
condition|(
name|faulted
operator|==
name|vd
operator|->
name|vdev_children
condition|)
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_NO_REPLICAS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|degraded
operator|+
name|faulted
operator|!=
literal|0
condition|)
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_DEGRADED
argument_list|,
name|VDEV_AUX_NONE
argument_list|)
expr_stmt|;
else|else
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_HEALTHY
argument_list|,
name|VDEV_AUX_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|vdev_ops_t
name|vdev_mirror_ops
init|=
block|{
name|vdev_mirror_open
block|,
name|vdev_mirror_close
block|,
name|vdev_default_asize
block|,
name|vdev_mirror_io_start
block|,
name|vdev_mirror_io_done
block|,
name|vdev_mirror_state_change
block|,
name|NULL
block|,
name|NULL
block|,
name|VDEV_TYPE_MIRROR
block|,
comment|/* name of this vdev type */
name|B_FALSE
comment|/* not a leaf vdev */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vdev_ops_t
name|vdev_replacing_ops
init|=
block|{
name|vdev_mirror_open
block|,
name|vdev_mirror_close
block|,
name|vdev_default_asize
block|,
name|vdev_mirror_io_start
block|,
name|vdev_mirror_io_done
block|,
name|vdev_mirror_state_change
block|,
name|NULL
block|,
name|NULL
block|,
name|VDEV_TYPE_REPLACING
block|,
comment|/* name of this vdev type */
name|B_FALSE
comment|/* not a leaf vdev */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vdev_ops_t
name|vdev_spare_ops
init|=
block|{
name|vdev_mirror_open
block|,
name|vdev_mirror_close
block|,
name|vdev_default_asize
block|,
name|vdev_mirror_io_start
block|,
name|vdev_mirror_io_done
block|,
name|vdev_mirror_state_change
block|,
name|NULL
block|,
name|NULL
block|,
name|VDEV_TYPE_SPARE
block|,
comment|/* name of this vdev type */
name|B_FALSE
comment|/* not a leaf vdev */
block|}
decl_stmt|;
end_decl_stmt

end_unit

