begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2013, 2015 by Delphix. All rights reserved.  */
end_comment

begin_comment
comment|/*  * The 512-byte leaf is broken into 32 16-byte chunks.  * chunk number n means l_chunk[n], even though the header precedes it.  * the names are stored null-terminated.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap_leaf.h>
end_include

begin_include
include|#
directive|include
file|<sys/arc.h>
end_include

begin_function_decl
specifier|static
name|uint16_t
modifier|*
name|zap_leaf_rehash_entry
parameter_list|(
name|zap_leaf_t
modifier|*
name|l
parameter_list|,
name|uint16_t
name|entry
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|CHAIN_END
value|0xffff
end_define

begin_comment
comment|/* end of the chunk chain */
end_comment

begin_comment
comment|/* half the (current) minimum block size */
end_comment

begin_define
define|#
directive|define
name|MAX_ARRAY_BYTES
value|(8<<10)
end_define

begin_define
define|#
directive|define
name|LEAF_HASH
parameter_list|(
name|l
parameter_list|,
name|h
parameter_list|)
define|\
value|((ZAP_LEAF_HASH_NUMENTRIES(l)-1)& \ 	((h)>> \ 	(64 - ZAP_LEAF_HASH_SHIFT(l) - zap_leaf_phys(l)->l_hdr.lh_prefix_len)))
end_define

begin_define
define|#
directive|define
name|LEAF_HASH_ENTPTR
parameter_list|(
name|l
parameter_list|,
name|h
parameter_list|)
value|(&zap_leaf_phys(l)->l_hash[LEAF_HASH(l, h)])
end_define

begin_function_decl
specifier|extern
specifier|inline
name|zap_leaf_phys_t
modifier|*
name|zap_leaf_phys
parameter_list|(
name|zap_leaf_t
modifier|*
name|l
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|zap_memset
parameter_list|(
name|void
modifier|*
name|a
parameter_list|,
name|int
name|c
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
name|a
decl_stmt|;
name|char
modifier|*
name|cpend
init|=
name|cp
operator|+
name|n
decl_stmt|;
while|while
condition|(
name|cp
operator|<
name|cpend
condition|)
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stv
parameter_list|(
name|int
name|len
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|1
case|:
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|addr
operator|=
name|value
expr_stmt|;
return|return;
case|case
literal|2
case|:
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|addr
operator|=
name|value
expr_stmt|;
return|return;
case|case
literal|4
case|:
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|addr
operator|=
name|value
expr_stmt|;
return|return;
case|case
literal|8
case|:
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|addr
operator|=
name|value
expr_stmt|;
return|return;
block|}
name|ASSERT
argument_list|(
operator|!
literal|"bad int len"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|ldv
parameter_list|(
name|int
name|len
parameter_list|,
specifier|const
name|void
modifier|*
name|addr
parameter_list|)
block|{
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|1
case|:
return|return
operator|(
operator|*
operator|(
name|uint8_t
operator|*
operator|)
name|addr
operator|)
return|;
case|case
literal|2
case|:
return|return
operator|(
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|addr
operator|)
return|;
case|case
literal|4
case|:
return|return
operator|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|addr
operator|)
return|;
case|case
literal|8
case|:
return|return
operator|(
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|addr
operator|)
return|;
block|}
name|ASSERT
argument_list|(
operator|!
literal|"bad int len"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0xFEEDFACEDEADBEEFULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zap_leaf_byteswap
parameter_list|(
name|zap_leaf_phys_t
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|zap_leaf_t
name|l
decl_stmt|;
name|dmu_buf_t
name|l_dbuf
decl_stmt|;
name|l_dbuf
operator|.
name|db_data
operator|=
name|buf
expr_stmt|;
name|l
operator|.
name|l_bs
operator|=
name|highbit64
argument_list|(
name|size
argument_list|)
operator|-
literal|1
expr_stmt|;
name|l
operator|.
name|l_dbuf
operator|=
operator|&
name|l_dbuf
expr_stmt|;
name|buf
operator|->
name|l_hdr
operator|.
name|lh_block_type
operator|=
name|BSWAP_64
argument_list|(
name|buf
operator|->
name|l_hdr
operator|.
name|lh_block_type
argument_list|)
expr_stmt|;
name|buf
operator|->
name|l_hdr
operator|.
name|lh_prefix
operator|=
name|BSWAP_64
argument_list|(
name|buf
operator|->
name|l_hdr
operator|.
name|lh_prefix
argument_list|)
expr_stmt|;
name|buf
operator|->
name|l_hdr
operator|.
name|lh_magic
operator|=
name|BSWAP_32
argument_list|(
name|buf
operator|->
name|l_hdr
operator|.
name|lh_magic
argument_list|)
expr_stmt|;
name|buf
operator|->
name|l_hdr
operator|.
name|lh_nfree
operator|=
name|BSWAP_16
argument_list|(
name|buf
operator|->
name|l_hdr
operator|.
name|lh_nfree
argument_list|)
expr_stmt|;
name|buf
operator|->
name|l_hdr
operator|.
name|lh_nentries
operator|=
name|BSWAP_16
argument_list|(
name|buf
operator|->
name|l_hdr
operator|.
name|lh_nentries
argument_list|)
expr_stmt|;
name|buf
operator|->
name|l_hdr
operator|.
name|lh_prefix_len
operator|=
name|BSWAP_16
argument_list|(
name|buf
operator|->
name|l_hdr
operator|.
name|lh_prefix_len
argument_list|)
expr_stmt|;
name|buf
operator|->
name|l_hdr
operator|.
name|lh_freelist
operator|=
name|BSWAP_16
argument_list|(
name|buf
operator|->
name|l_hdr
operator|.
name|lh_freelist
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZAP_LEAF_HASH_NUMENTRIES
argument_list|(
operator|&
name|l
argument_list|)
condition|;
name|i
operator|++
control|)
name|buf
operator|->
name|l_hash
index|[
name|i
index|]
operator|=
name|BSWAP_16
argument_list|(
name|buf
operator|->
name|l_hash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZAP_LEAF_NUMCHUNKS
argument_list|(
operator|&
name|l
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|zap_leaf_chunk_t
modifier|*
name|lc
init|=
operator|&
name|ZAP_LEAF_CHUNK
argument_list|(
operator|&
name|l
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|struct
name|zap_leaf_entry
modifier|*
name|le
decl_stmt|;
switch|switch
condition|(
name|lc
operator|->
name|l_free
operator|.
name|lf_type
condition|)
block|{
case|case
name|ZAP_CHUNK_ENTRY
case|:
name|le
operator|=
operator|&
name|lc
operator|->
name|l_entry
expr_stmt|;
name|le
operator|->
name|le_type
operator|=
name|BSWAP_8
argument_list|(
name|le
operator|->
name|le_type
argument_list|)
expr_stmt|;
name|le
operator|->
name|le_value_intlen
operator|=
name|BSWAP_8
argument_list|(
name|le
operator|->
name|le_value_intlen
argument_list|)
expr_stmt|;
name|le
operator|->
name|le_next
operator|=
name|BSWAP_16
argument_list|(
name|le
operator|->
name|le_next
argument_list|)
expr_stmt|;
name|le
operator|->
name|le_name_chunk
operator|=
name|BSWAP_16
argument_list|(
name|le
operator|->
name|le_name_chunk
argument_list|)
expr_stmt|;
name|le
operator|->
name|le_name_numints
operator|=
name|BSWAP_16
argument_list|(
name|le
operator|->
name|le_name_numints
argument_list|)
expr_stmt|;
name|le
operator|->
name|le_value_chunk
operator|=
name|BSWAP_16
argument_list|(
name|le
operator|->
name|le_value_chunk
argument_list|)
expr_stmt|;
name|le
operator|->
name|le_value_numints
operator|=
name|BSWAP_16
argument_list|(
name|le
operator|->
name|le_value_numints
argument_list|)
expr_stmt|;
name|le
operator|->
name|le_cd
operator|=
name|BSWAP_32
argument_list|(
name|le
operator|->
name|le_cd
argument_list|)
expr_stmt|;
name|le
operator|->
name|le_hash
operator|=
name|BSWAP_64
argument_list|(
name|le
operator|->
name|le_hash
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZAP_CHUNK_FREE
case|:
name|lc
operator|->
name|l_free
operator|.
name|lf_type
operator|=
name|BSWAP_8
argument_list|(
name|lc
operator|->
name|l_free
operator|.
name|lf_type
argument_list|)
expr_stmt|;
name|lc
operator|->
name|l_free
operator|.
name|lf_next
operator|=
name|BSWAP_16
argument_list|(
name|lc
operator|->
name|l_free
operator|.
name|lf_next
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZAP_CHUNK_ARRAY
case|:
name|lc
operator|->
name|l_array
operator|.
name|la_type
operator|=
name|BSWAP_8
argument_list|(
name|lc
operator|->
name|l_array
operator|.
name|la_type
argument_list|)
expr_stmt|;
name|lc
operator|->
name|l_array
operator|.
name|la_next
operator|=
name|BSWAP_16
argument_list|(
name|lc
operator|->
name|l_array
operator|.
name|la_next
argument_list|)
expr_stmt|;
comment|/* la_array doesn't need swapping */
break|break;
default|default:
name|ASSERT
argument_list|(
operator|!
literal|"bad leaf type"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|zap_leaf_init
parameter_list|(
name|zap_leaf_t
modifier|*
name|l
parameter_list|,
name|boolean_t
name|sort
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|l
operator|->
name|l_bs
operator|=
name|highbit64
argument_list|(
name|l
operator|->
name|l_dbuf
operator|->
name|db_size
argument_list|)
operator|-
literal|1
expr_stmt|;
name|zap_memset
argument_list|(
operator|&
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|zap_leaf_header
argument_list|)
argument_list|)
expr_stmt|;
name|zap_memset
argument_list|(
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hash
argument_list|,
name|CHAIN_END
argument_list|,
literal|2
operator|*
name|ZAP_LEAF_HASH_NUMENTRIES
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZAP_LEAF_NUMCHUNKS
argument_list|(
name|l
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ZAP_LEAF_CHUNK
argument_list|(
name|l
argument_list|,
name|i
argument_list|)
operator|.
name|l_free
operator|.
name|lf_type
operator|=
name|ZAP_CHUNK_FREE
expr_stmt|;
name|ZAP_LEAF_CHUNK
argument_list|(
name|l
argument_list|,
name|i
argument_list|)
operator|.
name|l_free
operator|.
name|lf_next
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
name|ZAP_LEAF_CHUNK
argument_list|(
name|l
argument_list|,
name|ZAP_LEAF_NUMCHUNKS
argument_list|(
name|l
argument_list|)
operator|-
literal|1
argument_list|)
operator|.
name|l_free
operator|.
name|lf_next
operator|=
name|CHAIN_END
expr_stmt|;
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_block_type
operator|=
name|ZBT_LEAF
expr_stmt|;
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_magic
operator|=
name|ZAP_LEAF_MAGIC
expr_stmt|;
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_nfree
operator|=
name|ZAP_LEAF_NUMCHUNKS
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|sort
condition|)
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_flags
operator||=
name|ZLF_ENTRIES_CDSORTED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routines which manipulate leaf chunks (l_chunk[]).  */
end_comment

begin_function
specifier|static
name|uint16_t
name|zap_leaf_chunk_alloc
parameter_list|(
name|zap_leaf_t
modifier|*
name|l
parameter_list|)
block|{
name|int
name|chunk
decl_stmt|;
name|ASSERT
argument_list|(
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_nfree
operator|>
literal|0
argument_list|)
expr_stmt|;
name|chunk
operator|=
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_freelist
expr_stmt|;
name|ASSERT3U
argument_list|(
name|chunk
argument_list|,
operator|<
argument_list|,
name|ZAP_LEAF_NUMCHUNKS
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ZAP_LEAF_CHUNK
argument_list|(
name|l
argument_list|,
name|chunk
argument_list|)
operator|.
name|l_free
operator|.
name|lf_type
argument_list|,
operator|==
argument_list|,
name|ZAP_CHUNK_FREE
argument_list|)
expr_stmt|;
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_freelist
operator|=
name|ZAP_LEAF_CHUNK
argument_list|(
name|l
argument_list|,
name|chunk
argument_list|)
operator|.
name|l_free
operator|.
name|lf_next
expr_stmt|;
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_nfree
operator|--
expr_stmt|;
return|return
operator|(
name|chunk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zap_leaf_chunk_free
parameter_list|(
name|zap_leaf_t
modifier|*
name|l
parameter_list|,
name|uint16_t
name|chunk
parameter_list|)
block|{
name|struct
name|zap_leaf_free
modifier|*
name|zlf
init|=
operator|&
name|ZAP_LEAF_CHUNK
argument_list|(
name|l
argument_list|,
name|chunk
argument_list|)
operator|.
name|l_free
decl_stmt|;
name|ASSERT3U
argument_list|(
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_nfree
argument_list|,
operator|<
argument_list|,
name|ZAP_LEAF_NUMCHUNKS
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|chunk
argument_list|,
operator|<
argument_list|,
name|ZAP_LEAF_NUMCHUNKS
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zlf
operator|->
name|lf_type
operator|!=
name|ZAP_CHUNK_FREE
argument_list|)
expr_stmt|;
name|zlf
operator|->
name|lf_type
operator|=
name|ZAP_CHUNK_FREE
expr_stmt|;
name|zlf
operator|->
name|lf_next
operator|=
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_freelist
expr_stmt|;
name|bzero
argument_list|(
name|zlf
operator|->
name|lf_pad
argument_list|,
sizeof|sizeof
argument_list|(
name|zlf
operator|->
name|lf_pad
argument_list|)
argument_list|)
expr_stmt|;
comment|/* help it to compress */
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_freelist
operator|=
name|chunk
expr_stmt|;
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_nfree
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routines which manipulate leaf arrays (zap_leaf_array type chunks).  */
end_comment

begin_function
specifier|static
name|uint16_t
name|zap_leaf_array_create
parameter_list|(
name|zap_leaf_t
modifier|*
name|l
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|integer_size
parameter_list|,
name|int
name|num_integers
parameter_list|)
block|{
name|uint16_t
name|chunk_head
decl_stmt|;
name|uint16_t
modifier|*
name|chunkp
init|=
operator|&
name|chunk_head
decl_stmt|;
name|int
name|byten
init|=
literal|0
decl_stmt|;
name|uint64_t
name|value
init|=
literal|0
decl_stmt|;
name|int
name|shift
init|=
operator|(
name|integer_size
operator|-
literal|1
operator|)
operator|*
literal|8
decl_stmt|;
name|int
name|len
init|=
name|num_integers
decl_stmt|;
name|ASSERT3U
argument_list|(
name|num_integers
operator|*
name|integer_size
argument_list|,
operator|<
argument_list|,
name|MAX_ARRAY_BYTES
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|uint16_t
name|chunk
init|=
name|zap_leaf_chunk_alloc
argument_list|(
name|l
argument_list|)
decl_stmt|;
name|struct
name|zap_leaf_array
modifier|*
name|la
init|=
operator|&
name|ZAP_LEAF_CHUNK
argument_list|(
name|l
argument_list|,
name|chunk
argument_list|)
operator|.
name|l_array
decl_stmt|;
name|int
name|i
decl_stmt|;
name|la
operator|->
name|la_type
operator|=
name|ZAP_CHUNK_ARRAY
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZAP_LEAF_ARRAY_BYTES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|byten
operator|==
literal|0
condition|)
name|value
operator|=
name|ldv
argument_list|(
name|integer_size
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|la
operator|->
name|la_array
index|[
name|i
index|]
operator|=
name|value
operator|>>
name|shift
expr_stmt|;
name|value
operator|<<=
literal|8
expr_stmt|;
if|if
condition|(
operator|++
name|byten
operator|==
name|integer_size
condition|)
block|{
name|byten
operator|=
literal|0
expr_stmt|;
name|buf
operator|+=
name|integer_size
expr_stmt|;
if|if
condition|(
operator|--
name|len
operator|==
literal|0
condition|)
break|break;
block|}
block|}
operator|*
name|chunkp
operator|=
name|chunk
expr_stmt|;
name|chunkp
operator|=
operator|&
name|la
operator|->
name|la_next
expr_stmt|;
block|}
operator|*
name|chunkp
operator|=
name|CHAIN_END
expr_stmt|;
return|return
operator|(
name|chunk_head
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zap_leaf_array_free
parameter_list|(
name|zap_leaf_t
modifier|*
name|l
parameter_list|,
name|uint16_t
modifier|*
name|chunkp
parameter_list|)
block|{
name|uint16_t
name|chunk
init|=
operator|*
name|chunkp
decl_stmt|;
operator|*
name|chunkp
operator|=
name|CHAIN_END
expr_stmt|;
while|while
condition|(
name|chunk
operator|!=
name|CHAIN_END
condition|)
block|{
name|int
name|nextchunk
init|=
name|ZAP_LEAF_CHUNK
argument_list|(
name|l
argument_list|,
name|chunk
argument_list|)
operator|.
name|l_array
operator|.
name|la_next
decl_stmt|;
name|ASSERT3U
argument_list|(
name|ZAP_LEAF_CHUNK
argument_list|(
name|l
argument_list|,
name|chunk
argument_list|)
operator|.
name|l_array
operator|.
name|la_type
argument_list|,
operator|==
argument_list|,
name|ZAP_CHUNK_ARRAY
argument_list|)
expr_stmt|;
name|zap_leaf_chunk_free
argument_list|(
name|l
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|chunk
operator|=
name|nextchunk
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* array_len and buf_len are in integers, not bytes */
end_comment

begin_function
specifier|static
name|void
name|zap_leaf_array_read
parameter_list|(
name|zap_leaf_t
modifier|*
name|l
parameter_list|,
name|uint16_t
name|chunk
parameter_list|,
name|int
name|array_int_len
parameter_list|,
name|int
name|array_len
parameter_list|,
name|int
name|buf_int_len
parameter_list|,
name|uint64_t
name|buf_len
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|len
init|=
name|MIN
argument_list|(
name|array_len
argument_list|,
name|buf_len
argument_list|)
decl_stmt|;
name|int
name|byten
init|=
literal|0
decl_stmt|;
name|uint64_t
name|value
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
name|ASSERT3U
argument_list|(
name|array_int_len
argument_list|,
operator|<=
argument_list|,
name|buf_int_len
argument_list|)
expr_stmt|;
comment|/* Fast path for one 8-byte integer */
if|if
condition|(
name|array_int_len
operator|==
literal|8
operator|&&
name|buf_int_len
operator|==
literal|8
operator|&&
name|len
operator|==
literal|1
condition|)
block|{
name|struct
name|zap_leaf_array
modifier|*
name|la
init|=
operator|&
name|ZAP_LEAF_CHUNK
argument_list|(
name|l
argument_list|,
name|chunk
argument_list|)
operator|.
name|l_array
decl_stmt|;
name|uint8_t
modifier|*
name|ip
init|=
name|la
operator|->
name|la_array
decl_stmt|;
name|uint64_t
modifier|*
name|buf64
init|=
name|buf
decl_stmt|;
operator|*
name|buf64
operator|=
operator|(
name|uint64_t
operator|)
name|ip
index|[
literal|0
index|]
operator|<<
literal|56
operator||
operator|(
name|uint64_t
operator|)
name|ip
index|[
literal|1
index|]
operator|<<
literal|48
operator||
operator|(
name|uint64_t
operator|)
name|ip
index|[
literal|2
index|]
operator|<<
literal|40
operator||
operator|(
name|uint64_t
operator|)
name|ip
index|[
literal|3
index|]
operator|<<
literal|32
operator||
operator|(
name|uint64_t
operator|)
name|ip
index|[
literal|4
index|]
operator|<<
literal|24
operator||
operator|(
name|uint64_t
operator|)
name|ip
index|[
literal|5
index|]
operator|<<
literal|16
operator||
operator|(
name|uint64_t
operator|)
name|ip
index|[
literal|6
index|]
operator|<<
literal|8
operator||
operator|(
name|uint64_t
operator|)
name|ip
index|[
literal|7
index|]
expr_stmt|;
return|return;
block|}
comment|/* Fast path for an array of 1-byte integers (eg. the entry name) */
if|if
condition|(
name|array_int_len
operator|==
literal|1
operator|&&
name|buf_int_len
operator|==
literal|1
operator|&&
name|buf_len
operator|>
name|array_len
operator|+
name|ZAP_LEAF_ARRAY_BYTES
condition|)
block|{
while|while
condition|(
name|chunk
operator|!=
name|CHAIN_END
condition|)
block|{
name|struct
name|zap_leaf_array
modifier|*
name|la
init|=
operator|&
name|ZAP_LEAF_CHUNK
argument_list|(
name|l
argument_list|,
name|chunk
argument_list|)
operator|.
name|l_array
decl_stmt|;
name|bcopy
argument_list|(
name|la
operator|->
name|la_array
argument_list|,
name|p
argument_list|,
name|ZAP_LEAF_ARRAY_BYTES
argument_list|)
expr_stmt|;
name|p
operator|+=
name|ZAP_LEAF_ARRAY_BYTES
expr_stmt|;
name|chunk
operator|=
name|la
operator|->
name|la_next
expr_stmt|;
block|}
return|return;
block|}
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|struct
name|zap_leaf_array
modifier|*
name|la
init|=
operator|&
name|ZAP_LEAF_CHUNK
argument_list|(
name|l
argument_list|,
name|chunk
argument_list|)
operator|.
name|l_array
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT3U
argument_list|(
name|chunk
argument_list|,
operator|<
argument_list|,
name|ZAP_LEAF_NUMCHUNKS
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZAP_LEAF_ARRAY_BYTES
operator|&&
name|len
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|value
operator|=
operator|(
name|value
operator|<<
literal|8
operator|)
operator||
name|la
operator|->
name|la_array
index|[
name|i
index|]
expr_stmt|;
name|byten
operator|++
expr_stmt|;
if|if
condition|(
name|byten
operator|==
name|array_int_len
condition|)
block|{
name|stv
argument_list|(
name|buf_int_len
argument_list|,
name|p
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|byten
operator|=
literal|0
expr_stmt|;
name|len
operator|--
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return;
name|p
operator|+=
name|buf_int_len
expr_stmt|;
block|}
block|}
name|chunk
operator|=
name|la
operator|->
name|la_next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|zap_leaf_array_match
parameter_list|(
name|zap_leaf_t
modifier|*
name|l
parameter_list|,
name|zap_name_t
modifier|*
name|zn
parameter_list|,
name|int
name|chunk
parameter_list|,
name|int
name|array_numints
parameter_list|)
block|{
name|int
name|bseen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|zap_getflags
argument_list|(
name|zn
operator|->
name|zn_zap
argument_list|)
operator|&
name|ZAP_FLAG_UINT64_KEY
condition|)
block|{
name|uint64_t
modifier|*
name|thiskey
decl_stmt|;
name|boolean_t
name|match
decl_stmt|;
name|ASSERT
argument_list|(
name|zn
operator|->
name|zn_key_intlen
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|thiskey
argument_list|)
argument_list|)
expr_stmt|;
name|thiskey
operator|=
name|kmem_alloc
argument_list|(
name|array_numints
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|thiskey
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zap_leaf_array_read
argument_list|(
name|l
argument_list|,
name|chunk
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|thiskey
argument_list|)
argument_list|,
name|array_numints
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|thiskey
argument_list|)
argument_list|,
name|array_numints
argument_list|,
name|thiskey
argument_list|)
expr_stmt|;
name|match
operator|=
name|bcmp
argument_list|(
name|thiskey
argument_list|,
name|zn
operator|->
name|zn_key_orig
argument_list|,
name|array_numints
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|thiskey
argument_list|)
argument_list|)
operator|==
literal|0
expr_stmt|;
name|kmem_free
argument_list|(
name|thiskey
argument_list|,
name|array_numints
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|thiskey
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|match
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|zn
operator|->
name|zn_key_intlen
operator|==
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|zn
operator|->
name|zn_matchtype
operator|==
name|MT_FIRST
condition|)
block|{
name|char
modifier|*
name|thisname
init|=
name|kmem_alloc
argument_list|(
name|array_numints
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|boolean_t
name|match
decl_stmt|;
name|zap_leaf_array_read
argument_list|(
name|l
argument_list|,
name|chunk
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|array_numints
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|array_numints
argument_list|,
name|thisname
argument_list|)
expr_stmt|;
name|match
operator|=
name|zap_match
argument_list|(
name|zn
argument_list|,
name|thisname
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|thisname
argument_list|,
name|array_numints
argument_list|)
expr_stmt|;
return|return
operator|(
name|match
operator|)
return|;
block|}
comment|/* 	 * Fast path for exact matching. 	 * First check that the lengths match, so that we don't read 	 * past the end of the zn_key_orig array. 	 */
if|if
condition|(
name|array_numints
operator|!=
name|zn
operator|->
name|zn_key_orig_numints
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
while|while
condition|(
name|bseen
operator|<
name|array_numints
condition|)
block|{
name|struct
name|zap_leaf_array
modifier|*
name|la
init|=
operator|&
name|ZAP_LEAF_CHUNK
argument_list|(
name|l
argument_list|,
name|chunk
argument_list|)
operator|.
name|l_array
decl_stmt|;
name|int
name|toread
init|=
name|MIN
argument_list|(
name|array_numints
operator|-
name|bseen
argument_list|,
name|ZAP_LEAF_ARRAY_BYTES
argument_list|)
decl_stmt|;
name|ASSERT3U
argument_list|(
name|chunk
argument_list|,
operator|<
argument_list|,
name|ZAP_LEAF_NUMCHUNKS
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|la
operator|->
name|la_array
argument_list|,
operator|(
name|char
operator|*
operator|)
name|zn
operator|->
name|zn_key_orig
operator|+
name|bseen
argument_list|,
name|toread
argument_list|)
condition|)
break|break;
name|chunk
operator|=
name|la
operator|->
name|la_next
expr_stmt|;
name|bseen
operator|+=
name|toread
expr_stmt|;
block|}
return|return
operator|(
name|bseen
operator|==
name|array_numints
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routines which manipulate leaf entries.  */
end_comment

begin_function
name|int
name|zap_leaf_lookup
parameter_list|(
name|zap_leaf_t
modifier|*
name|l
parameter_list|,
name|zap_name_t
modifier|*
name|zn
parameter_list|,
name|zap_entry_handle_t
modifier|*
name|zeh
parameter_list|)
block|{
name|uint16_t
modifier|*
name|chunkp
decl_stmt|;
name|struct
name|zap_leaf_entry
modifier|*
name|le
decl_stmt|;
name|ASSERT3U
argument_list|(
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_magic
argument_list|,
operator|==
argument_list|,
name|ZAP_LEAF_MAGIC
argument_list|)
expr_stmt|;
name|again
label|:
for|for
control|(
name|chunkp
operator|=
name|LEAF_HASH_ENTPTR
argument_list|(
name|l
argument_list|,
name|zn
operator|->
name|zn_hash
argument_list|)
init|;
operator|*
name|chunkp
operator|!=
name|CHAIN_END
condition|;
name|chunkp
operator|=
operator|&
name|le
operator|->
name|le_next
control|)
block|{
name|uint16_t
name|chunk
init|=
operator|*
name|chunkp
decl_stmt|;
name|le
operator|=
name|ZAP_LEAF_ENTRY
argument_list|(
name|l
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|chunk
argument_list|,
operator|<
argument_list|,
name|ZAP_LEAF_NUMCHUNKS
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|le
operator|->
name|le_type
argument_list|,
operator|==
argument_list|,
name|ZAP_CHUNK_ENTRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|le
operator|->
name|le_hash
operator|!=
name|zn
operator|->
name|zn_hash
condition|)
continue|continue;
comment|/* 		 * NB: the entry chain is always sorted by cd on 		 * normalized zap objects, so this will find the 		 * lowest-cd match for MT_FIRST. 		 */
name|ASSERT
argument_list|(
name|zn
operator|->
name|zn_matchtype
operator|==
name|MT_EXACT
operator|||
operator|(
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_flags
operator|&
name|ZLF_ENTRIES_CDSORTED
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zap_leaf_array_match
argument_list|(
name|l
argument_list|,
name|zn
argument_list|,
name|le
operator|->
name|le_name_chunk
argument_list|,
name|le
operator|->
name|le_name_numints
argument_list|)
condition|)
block|{
name|zeh
operator|->
name|zeh_num_integers
operator|=
name|le
operator|->
name|le_value_numints
expr_stmt|;
name|zeh
operator|->
name|zeh_integer_size
operator|=
name|le
operator|->
name|le_value_intlen
expr_stmt|;
name|zeh
operator|->
name|zeh_cd
operator|=
name|le
operator|->
name|le_cd
expr_stmt|;
name|zeh
operator|->
name|zeh_hash
operator|=
name|le
operator|->
name|le_hash
expr_stmt|;
name|zeh
operator|->
name|zeh_chunkp
operator|=
name|chunkp
expr_stmt|;
name|zeh
operator|->
name|zeh_leaf
operator|=
name|l
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * NB: we could of course do this in one pass, but that would be 	 * a pain.  We'll see if MT_BEST is even used much. 	 */
if|if
condition|(
name|zn
operator|->
name|zn_matchtype
operator|==
name|MT_BEST
condition|)
block|{
name|zn
operator|->
name|zn_matchtype
operator|=
name|MT_FIRST
expr_stmt|;
goto|goto
name|again
goto|;
block|}
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return (h1,cd1>= h2,cd2) */
end_comment

begin_define
define|#
directive|define
name|HCD_GTEQ
parameter_list|(
name|h1
parameter_list|,
name|cd1
parameter_list|,
name|h2
parameter_list|,
name|cd2
parameter_list|)
define|\
value|((h1> h2) ? TRUE : ((h1 == h2&& cd1>= cd2) ? TRUE : FALSE))
end_define

begin_function
name|int
name|zap_leaf_lookup_closest
parameter_list|(
name|zap_leaf_t
modifier|*
name|l
parameter_list|,
name|uint64_t
name|h
parameter_list|,
name|uint32_t
name|cd
parameter_list|,
name|zap_entry_handle_t
modifier|*
name|zeh
parameter_list|)
block|{
name|uint16_t
name|chunk
decl_stmt|;
name|uint64_t
name|besth
init|=
operator|-
literal|1ULL
decl_stmt|;
name|uint32_t
name|bestcd
init|=
operator|-
literal|1U
decl_stmt|;
name|uint16_t
name|bestlh
init|=
name|ZAP_LEAF_HASH_NUMENTRIES
argument_list|(
name|l
argument_list|)
operator|-
literal|1
decl_stmt|;
name|uint16_t
name|lh
decl_stmt|;
name|struct
name|zap_leaf_entry
modifier|*
name|le
decl_stmt|;
name|ASSERT3U
argument_list|(
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_magic
argument_list|,
operator|==
argument_list|,
name|ZAP_LEAF_MAGIC
argument_list|)
expr_stmt|;
for|for
control|(
name|lh
operator|=
name|LEAF_HASH
argument_list|(
name|l
argument_list|,
name|h
argument_list|)
init|;
name|lh
operator|<=
name|bestlh
condition|;
name|lh
operator|++
control|)
block|{
for|for
control|(
name|chunk
operator|=
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hash
index|[
name|lh
index|]
init|;
name|chunk
operator|!=
name|CHAIN_END
condition|;
name|chunk
operator|=
name|le
operator|->
name|le_next
control|)
block|{
name|le
operator|=
name|ZAP_LEAF_ENTRY
argument_list|(
name|l
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|chunk
argument_list|,
operator|<
argument_list|,
name|ZAP_LEAF_NUMCHUNKS
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|le
operator|->
name|le_type
argument_list|,
operator|==
argument_list|,
name|ZAP_CHUNK_ENTRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|HCD_GTEQ
argument_list|(
name|le
operator|->
name|le_hash
argument_list|,
name|le
operator|->
name|le_cd
argument_list|,
name|h
argument_list|,
name|cd
argument_list|)
operator|&&
name|HCD_GTEQ
argument_list|(
name|besth
argument_list|,
name|bestcd
argument_list|,
name|le
operator|->
name|le_hash
argument_list|,
name|le
operator|->
name|le_cd
argument_list|)
condition|)
block|{
name|ASSERT3U
argument_list|(
name|bestlh
argument_list|,
operator|>=
argument_list|,
name|lh
argument_list|)
expr_stmt|;
name|bestlh
operator|=
name|lh
expr_stmt|;
name|besth
operator|=
name|le
operator|->
name|le_hash
expr_stmt|;
name|bestcd
operator|=
name|le
operator|->
name|le_cd
expr_stmt|;
name|zeh
operator|->
name|zeh_num_integers
operator|=
name|le
operator|->
name|le_value_numints
expr_stmt|;
name|zeh
operator|->
name|zeh_integer_size
operator|=
name|le
operator|->
name|le_value_intlen
expr_stmt|;
name|zeh
operator|->
name|zeh_cd
operator|=
name|le
operator|->
name|le_cd
expr_stmt|;
name|zeh
operator|->
name|zeh_hash
operator|=
name|le
operator|->
name|le_hash
expr_stmt|;
name|zeh
operator|->
name|zeh_fakechunk
operator|=
name|chunk
expr_stmt|;
name|zeh
operator|->
name|zeh_chunkp
operator|=
operator|&
name|zeh
operator|->
name|zeh_fakechunk
expr_stmt|;
name|zeh
operator|->
name|zeh_leaf
operator|=
name|l
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|bestcd
operator|==
operator|-
literal|1U
condition|?
name|ENOENT
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zap_entry_read
parameter_list|(
specifier|const
name|zap_entry_handle_t
modifier|*
name|zeh
parameter_list|,
name|uint8_t
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|zap_leaf_entry
modifier|*
name|le
init|=
name|ZAP_LEAF_ENTRY
argument_list|(
name|zeh
operator|->
name|zeh_leaf
argument_list|,
operator|*
name|zeh
operator|->
name|zeh_chunkp
argument_list|)
decl_stmt|;
name|ASSERT3U
argument_list|(
name|le
operator|->
name|le_type
argument_list|,
operator|==
argument_list|,
name|ZAP_CHUNK_ENTRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|le
operator|->
name|le_value_intlen
operator|>
name|integer_size
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
name|zap_leaf_array_read
argument_list|(
name|zeh
operator|->
name|zeh_leaf
argument_list|,
name|le
operator|->
name|le_value_chunk
argument_list|,
name|le
operator|->
name|le_value_intlen
argument_list|,
name|le
operator|->
name|le_value_numints
argument_list|,
name|integer_size
argument_list|,
name|num_integers
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|zeh
operator|->
name|zeh_num_integers
operator|>
name|num_integers
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EOVERFLOW
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zap_entry_read_name
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
specifier|const
name|zap_entry_handle_t
modifier|*
name|zeh
parameter_list|,
name|uint16_t
name|buflen
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|zap_leaf_entry
modifier|*
name|le
init|=
name|ZAP_LEAF_ENTRY
argument_list|(
name|zeh
operator|->
name|zeh_leaf
argument_list|,
operator|*
name|zeh
operator|->
name|zeh_chunkp
argument_list|)
decl_stmt|;
name|ASSERT3U
argument_list|(
name|le
operator|->
name|le_type
argument_list|,
operator|==
argument_list|,
name|ZAP_CHUNK_ENTRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|zap_getflags
argument_list|(
name|zap
argument_list|)
operator|&
name|ZAP_FLAG_UINT64_KEY
condition|)
block|{
name|zap_leaf_array_read
argument_list|(
name|zeh
operator|->
name|zeh_leaf
argument_list|,
name|le
operator|->
name|le_name_chunk
argument_list|,
literal|8
argument_list|,
name|le
operator|->
name|le_name_numints
argument_list|,
literal|8
argument_list|,
name|buflen
operator|/
literal|8
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zap_leaf_array_read
argument_list|(
name|zeh
operator|->
name|zeh_leaf
argument_list|,
name|le
operator|->
name|le_name_chunk
argument_list|,
literal|1
argument_list|,
name|le
operator|->
name|le_name_numints
argument_list|,
literal|1
argument_list|,
name|buflen
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|le
operator|->
name|le_name_numints
operator|>
name|buflen
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EOVERFLOW
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zap_entry_update
parameter_list|(
name|zap_entry_handle_t
modifier|*
name|zeh
parameter_list|,
name|uint8_t
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|int
name|delta_chunks
decl_stmt|;
name|zap_leaf_t
modifier|*
name|l
init|=
name|zeh
operator|->
name|zeh_leaf
decl_stmt|;
name|struct
name|zap_leaf_entry
modifier|*
name|le
init|=
name|ZAP_LEAF_ENTRY
argument_list|(
name|l
argument_list|,
operator|*
name|zeh
operator|->
name|zeh_chunkp
argument_list|)
decl_stmt|;
name|delta_chunks
operator|=
name|ZAP_LEAF_ARRAY_NCHUNKS
argument_list|(
name|num_integers
operator|*
name|integer_size
argument_list|)
operator|-
name|ZAP_LEAF_ARRAY_NCHUNKS
argument_list|(
name|le
operator|->
name|le_value_numints
operator|*
name|le
operator|->
name|le_value_intlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_nfree
operator|<
name|delta_chunks
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EAGAIN
argument_list|)
operator|)
return|;
name|zap_leaf_array_free
argument_list|(
name|l
argument_list|,
operator|&
name|le
operator|->
name|le_value_chunk
argument_list|)
expr_stmt|;
name|le
operator|->
name|le_value_chunk
operator|=
name|zap_leaf_array_create
argument_list|(
name|l
argument_list|,
name|buf
argument_list|,
name|integer_size
argument_list|,
name|num_integers
argument_list|)
expr_stmt|;
name|le
operator|->
name|le_value_numints
operator|=
name|num_integers
expr_stmt|;
name|le
operator|->
name|le_value_intlen
operator|=
name|integer_size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zap_entry_remove
parameter_list|(
name|zap_entry_handle_t
modifier|*
name|zeh
parameter_list|)
block|{
name|uint16_t
name|entry_chunk
decl_stmt|;
name|struct
name|zap_leaf_entry
modifier|*
name|le
decl_stmt|;
name|zap_leaf_t
modifier|*
name|l
init|=
name|zeh
operator|->
name|zeh_leaf
decl_stmt|;
name|ASSERT3P
argument_list|(
name|zeh
operator|->
name|zeh_chunkp
argument_list|,
operator|!=
argument_list|,
operator|&
name|zeh
operator|->
name|zeh_fakechunk
argument_list|)
expr_stmt|;
name|entry_chunk
operator|=
operator|*
name|zeh
operator|->
name|zeh_chunkp
expr_stmt|;
name|le
operator|=
name|ZAP_LEAF_ENTRY
argument_list|(
name|l
argument_list|,
name|entry_chunk
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|le
operator|->
name|le_type
argument_list|,
operator|==
argument_list|,
name|ZAP_CHUNK_ENTRY
argument_list|)
expr_stmt|;
name|zap_leaf_array_free
argument_list|(
name|l
argument_list|,
operator|&
name|le
operator|->
name|le_name_chunk
argument_list|)
expr_stmt|;
name|zap_leaf_array_free
argument_list|(
name|l
argument_list|,
operator|&
name|le
operator|->
name|le_value_chunk
argument_list|)
expr_stmt|;
operator|*
name|zeh
operator|->
name|zeh_chunkp
operator|=
name|le
operator|->
name|le_next
expr_stmt|;
name|zap_leaf_chunk_free
argument_list|(
name|l
argument_list|,
name|entry_chunk
argument_list|)
expr_stmt|;
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_nentries
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|int
name|zap_entry_create
parameter_list|(
name|zap_leaf_t
modifier|*
name|l
parameter_list|,
name|zap_name_t
modifier|*
name|zn
parameter_list|,
name|uint32_t
name|cd
parameter_list|,
name|uint8_t
name|integer_size
parameter_list|,
name|uint64_t
name|num_integers
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|zap_entry_handle_t
modifier|*
name|zeh
parameter_list|)
block|{
name|uint16_t
name|chunk
decl_stmt|;
name|uint16_t
modifier|*
name|chunkp
decl_stmt|;
name|struct
name|zap_leaf_entry
modifier|*
name|le
decl_stmt|;
name|uint64_t
name|valuelen
decl_stmt|;
name|int
name|numchunks
decl_stmt|;
name|uint64_t
name|h
init|=
name|zn
operator|->
name|zn_hash
decl_stmt|;
name|valuelen
operator|=
name|integer_size
operator|*
name|num_integers
expr_stmt|;
name|numchunks
operator|=
literal|1
operator|+
name|ZAP_LEAF_ARRAY_NCHUNKS
argument_list|(
name|zn
operator|->
name|zn_key_orig_numints
operator|*
name|zn
operator|->
name|zn_key_intlen
argument_list|)
operator|+
name|ZAP_LEAF_ARRAY_NCHUNKS
argument_list|(
name|valuelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|numchunks
operator|>
name|ZAP_LEAF_NUMCHUNKS
argument_list|(
name|l
argument_list|)
condition|)
return|return
operator|(
name|E2BIG
operator|)
return|;
if|if
condition|(
name|cd
operator|==
name|ZAP_NEED_CD
condition|)
block|{
comment|/* find the lowest unused cd */
if|if
condition|(
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_flags
operator|&
name|ZLF_ENTRIES_CDSORTED
condition|)
block|{
name|cd
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|chunk
operator|=
operator|*
name|LEAF_HASH_ENTPTR
argument_list|(
name|l
argument_list|,
name|h
argument_list|)
init|;
name|chunk
operator|!=
name|CHAIN_END
condition|;
name|chunk
operator|=
name|le
operator|->
name|le_next
control|)
block|{
name|le
operator|=
name|ZAP_LEAF_ENTRY
argument_list|(
name|l
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|le
operator|->
name|le_cd
operator|>
name|cd
condition|)
break|break;
if|if
condition|(
name|le
operator|->
name|le_hash
operator|==
name|h
condition|)
block|{
name|ASSERT3U
argument_list|(
name|cd
argument_list|,
operator|==
argument_list|,
name|le
operator|->
name|le_cd
argument_list|)
expr_stmt|;
name|cd
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* old unsorted format; do it the O(n^2) way */
for|for
control|(
name|cd
operator|=
literal|0
init|;
condition|;
name|cd
operator|++
control|)
block|{
for|for
control|(
name|chunk
operator|=
operator|*
name|LEAF_HASH_ENTPTR
argument_list|(
name|l
argument_list|,
name|h
argument_list|)
init|;
name|chunk
operator|!=
name|CHAIN_END
condition|;
name|chunk
operator|=
name|le
operator|->
name|le_next
control|)
block|{
name|le
operator|=
name|ZAP_LEAF_ENTRY
argument_list|(
name|l
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|le
operator|->
name|le_hash
operator|==
name|h
operator|&&
name|le
operator|->
name|le_cd
operator|==
name|cd
condition|)
block|{
break|break;
block|}
block|}
comment|/* If this cd is not in use, we are good. */
if|if
condition|(
name|chunk
operator|==
name|CHAIN_END
condition|)
break|break;
block|}
block|}
comment|/* 		 * We would run out of space in a block before we could 		 * store enough entries to run out of CD values. 		 */
name|ASSERT3U
argument_list|(
name|cd
argument_list|,
operator|<
argument_list|,
name|zap_maxcd
argument_list|(
name|zn
operator|->
name|zn_zap
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_nfree
operator|<
name|numchunks
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EAGAIN
argument_list|)
operator|)
return|;
comment|/* make the entry */
name|chunk
operator|=
name|zap_leaf_chunk_alloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|le
operator|=
name|ZAP_LEAF_ENTRY
argument_list|(
name|l
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|le
operator|->
name|le_type
operator|=
name|ZAP_CHUNK_ENTRY
expr_stmt|;
name|le
operator|->
name|le_name_chunk
operator|=
name|zap_leaf_array_create
argument_list|(
name|l
argument_list|,
name|zn
operator|->
name|zn_key_orig
argument_list|,
name|zn
operator|->
name|zn_key_intlen
argument_list|,
name|zn
operator|->
name|zn_key_orig_numints
argument_list|)
expr_stmt|;
name|le
operator|->
name|le_name_numints
operator|=
name|zn
operator|->
name|zn_key_orig_numints
expr_stmt|;
name|le
operator|->
name|le_value_chunk
operator|=
name|zap_leaf_array_create
argument_list|(
name|l
argument_list|,
name|buf
argument_list|,
name|integer_size
argument_list|,
name|num_integers
argument_list|)
expr_stmt|;
name|le
operator|->
name|le_value_numints
operator|=
name|num_integers
expr_stmt|;
name|le
operator|->
name|le_value_intlen
operator|=
name|integer_size
expr_stmt|;
name|le
operator|->
name|le_hash
operator|=
name|h
expr_stmt|;
name|le
operator|->
name|le_cd
operator|=
name|cd
expr_stmt|;
comment|/* link it into the hash chain */
comment|/* XXX if we did the search above, we could just use that */
name|chunkp
operator|=
name|zap_leaf_rehash_entry
argument_list|(
name|l
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_nentries
operator|++
expr_stmt|;
name|zeh
operator|->
name|zeh_leaf
operator|=
name|l
expr_stmt|;
name|zeh
operator|->
name|zeh_num_integers
operator|=
name|num_integers
expr_stmt|;
name|zeh
operator|->
name|zeh_integer_size
operator|=
name|le
operator|->
name|le_value_intlen
expr_stmt|;
name|zeh
operator|->
name|zeh_cd
operator|=
name|le
operator|->
name|le_cd
expr_stmt|;
name|zeh
operator|->
name|zeh_hash
operator|=
name|le
operator|->
name|le_hash
expr_stmt|;
name|zeh
operator|->
name|zeh_chunkp
operator|=
name|chunkp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if there is another entry with the same normalized form.  * For performance purposes, either zn or name must be provided (the  * other can be NULL).  Note, there usually won't be any hash  * conflicts, in which case we don't need the concatenated/normalized  * form of the name.  But all callers have one of these on hand anyway,  * so might as well take advantage.  A cleaner but slower interface  * would accept neither argument, and compute the normalized name as  * needed (using zap_name_alloc(zap_entry_read_name(zeh))).  */
end_comment

begin_function
name|boolean_t
name|zap_entry_normalization_conflict
parameter_list|(
name|zap_entry_handle_t
modifier|*
name|zeh
parameter_list|,
name|zap_name_t
modifier|*
name|zn
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|zap_t
modifier|*
name|zap
parameter_list|)
block|{
name|uint64_t
name|chunk
decl_stmt|;
name|struct
name|zap_leaf_entry
modifier|*
name|le
decl_stmt|;
name|boolean_t
name|allocdzn
init|=
name|B_FALSE
decl_stmt|;
if|if
condition|(
name|zap
operator|->
name|zap_normflags
operator|==
literal|0
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
for|for
control|(
name|chunk
operator|=
operator|*
name|LEAF_HASH_ENTPTR
argument_list|(
name|zeh
operator|->
name|zeh_leaf
argument_list|,
name|zeh
operator|->
name|zeh_hash
argument_list|)
init|;
name|chunk
operator|!=
name|CHAIN_END
condition|;
name|chunk
operator|=
name|le
operator|->
name|le_next
control|)
block|{
name|le
operator|=
name|ZAP_LEAF_ENTRY
argument_list|(
name|zeh
operator|->
name|zeh_leaf
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|le
operator|->
name|le_hash
operator|!=
name|zeh
operator|->
name|zeh_hash
condition|)
continue|continue;
if|if
condition|(
name|le
operator|->
name|le_cd
operator|==
name|zeh
operator|->
name|zeh_cd
condition|)
continue|continue;
if|if
condition|(
name|zn
operator|==
name|NULL
condition|)
block|{
name|zn
operator|=
name|zap_name_alloc
argument_list|(
name|zap
argument_list|,
name|name
argument_list|,
name|MT_FIRST
argument_list|)
expr_stmt|;
name|allocdzn
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|zap_leaf_array_match
argument_list|(
name|zeh
operator|->
name|zeh_leaf
argument_list|,
name|zn
argument_list|,
name|le
operator|->
name|le_name_chunk
argument_list|,
name|le
operator|->
name|le_name_numints
argument_list|)
condition|)
block|{
if|if
condition|(
name|allocdzn
condition|)
name|zap_name_free
argument_list|(
name|zn
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
block|}
if|if
condition|(
name|allocdzn
condition|)
name|zap_name_free
argument_list|(
name|zn
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Routines for transferring entries between leafs.  */
end_comment

begin_function
specifier|static
name|uint16_t
modifier|*
name|zap_leaf_rehash_entry
parameter_list|(
name|zap_leaf_t
modifier|*
name|l
parameter_list|,
name|uint16_t
name|entry
parameter_list|)
block|{
name|struct
name|zap_leaf_entry
modifier|*
name|le
init|=
name|ZAP_LEAF_ENTRY
argument_list|(
name|l
argument_list|,
name|entry
argument_list|)
decl_stmt|;
name|struct
name|zap_leaf_entry
modifier|*
name|le2
decl_stmt|;
name|uint16_t
modifier|*
name|chunkp
decl_stmt|;
comment|/* 	 * keep the entry chain sorted by cd 	 * NB: this will not cause problems for unsorted leafs, though 	 * it is unnecessary there. 	 */
for|for
control|(
name|chunkp
operator|=
name|LEAF_HASH_ENTPTR
argument_list|(
name|l
argument_list|,
name|le
operator|->
name|le_hash
argument_list|)
init|;
operator|*
name|chunkp
operator|!=
name|CHAIN_END
condition|;
name|chunkp
operator|=
operator|&
name|le2
operator|->
name|le_next
control|)
block|{
name|le2
operator|=
name|ZAP_LEAF_ENTRY
argument_list|(
name|l
argument_list|,
operator|*
name|chunkp
argument_list|)
expr_stmt|;
if|if
condition|(
name|le2
operator|->
name|le_cd
operator|>
name|le
operator|->
name|le_cd
condition|)
break|break;
block|}
name|le
operator|->
name|le_next
operator|=
operator|*
name|chunkp
expr_stmt|;
operator|*
name|chunkp
operator|=
name|entry
expr_stmt|;
return|return
operator|(
name|chunkp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|zap_leaf_transfer_array
parameter_list|(
name|zap_leaf_t
modifier|*
name|l
parameter_list|,
name|uint16_t
name|chunk
parameter_list|,
name|zap_leaf_t
modifier|*
name|nl
parameter_list|)
block|{
name|uint16_t
name|new_chunk
decl_stmt|;
name|uint16_t
modifier|*
name|nchunkp
init|=
operator|&
name|new_chunk
decl_stmt|;
while|while
condition|(
name|chunk
operator|!=
name|CHAIN_END
condition|)
block|{
name|uint16_t
name|nchunk
init|=
name|zap_leaf_chunk_alloc
argument_list|(
name|nl
argument_list|)
decl_stmt|;
name|struct
name|zap_leaf_array
modifier|*
name|nla
init|=
operator|&
name|ZAP_LEAF_CHUNK
argument_list|(
name|nl
argument_list|,
name|nchunk
argument_list|)
operator|.
name|l_array
decl_stmt|;
name|struct
name|zap_leaf_array
modifier|*
name|la
init|=
operator|&
name|ZAP_LEAF_CHUNK
argument_list|(
name|l
argument_list|,
name|chunk
argument_list|)
operator|.
name|l_array
decl_stmt|;
name|int
name|nextchunk
init|=
name|la
operator|->
name|la_next
decl_stmt|;
name|ASSERT3U
argument_list|(
name|chunk
argument_list|,
operator|<
argument_list|,
name|ZAP_LEAF_NUMCHUNKS
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|nchunk
argument_list|,
operator|<
argument_list|,
name|ZAP_LEAF_NUMCHUNKS
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|nla
operator|=
operator|*
name|la
expr_stmt|;
comment|/* structure assignment */
name|zap_leaf_chunk_free
argument_list|(
name|l
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|chunk
operator|=
name|nextchunk
expr_stmt|;
operator|*
name|nchunkp
operator|=
name|nchunk
expr_stmt|;
name|nchunkp
operator|=
operator|&
name|nla
operator|->
name|la_next
expr_stmt|;
block|}
operator|*
name|nchunkp
operator|=
name|CHAIN_END
expr_stmt|;
return|return
operator|(
name|new_chunk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zap_leaf_transfer_entry
parameter_list|(
name|zap_leaf_t
modifier|*
name|l
parameter_list|,
name|int
name|entry
parameter_list|,
name|zap_leaf_t
modifier|*
name|nl
parameter_list|)
block|{
name|struct
name|zap_leaf_entry
modifier|*
name|le
decl_stmt|,
modifier|*
name|nle
decl_stmt|;
name|uint16_t
name|chunk
decl_stmt|;
name|le
operator|=
name|ZAP_LEAF_ENTRY
argument_list|(
name|l
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|le
operator|->
name|le_type
argument_list|,
operator|==
argument_list|,
name|ZAP_CHUNK_ENTRY
argument_list|)
expr_stmt|;
name|chunk
operator|=
name|zap_leaf_chunk_alloc
argument_list|(
name|nl
argument_list|)
expr_stmt|;
name|nle
operator|=
name|ZAP_LEAF_ENTRY
argument_list|(
name|nl
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
operator|*
name|nle
operator|=
operator|*
name|le
expr_stmt|;
comment|/* structure assignment */
operator|(
name|void
operator|)
name|zap_leaf_rehash_entry
argument_list|(
name|nl
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|nle
operator|->
name|le_name_chunk
operator|=
name|zap_leaf_transfer_array
argument_list|(
name|l
argument_list|,
name|le
operator|->
name|le_name_chunk
argument_list|,
name|nl
argument_list|)
expr_stmt|;
name|nle
operator|->
name|le_value_chunk
operator|=
name|zap_leaf_transfer_array
argument_list|(
name|l
argument_list|,
name|le
operator|->
name|le_value_chunk
argument_list|,
name|nl
argument_list|)
expr_stmt|;
name|zap_leaf_chunk_free
argument_list|(
name|l
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_nentries
operator|--
expr_stmt|;
name|zap_leaf_phys
argument_list|(
name|nl
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_nentries
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Transfer the entries whose hash prefix ends in 1 to the new leaf.  */
end_comment

begin_function
name|void
name|zap_leaf_split
parameter_list|(
name|zap_leaf_t
modifier|*
name|l
parameter_list|,
name|zap_leaf_t
modifier|*
name|nl
parameter_list|,
name|boolean_t
name|sort
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|bit
init|=
literal|64
operator|-
literal|1
operator|-
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_prefix_len
decl_stmt|;
comment|/* set new prefix and prefix_len */
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_prefix
operator|<<=
literal|1
expr_stmt|;
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_prefix_len
operator|++
expr_stmt|;
name|zap_leaf_phys
argument_list|(
name|nl
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_prefix
operator|=
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_prefix
operator||
literal|1
expr_stmt|;
name|zap_leaf_phys
argument_list|(
name|nl
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_prefix_len
operator|=
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_prefix_len
expr_stmt|;
comment|/* break existing hash chains */
name|zap_memset
argument_list|(
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hash
argument_list|,
name|CHAIN_END
argument_list|,
literal|2
operator|*
name|ZAP_LEAF_HASH_NUMENTRIES
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sort
condition|)
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_flags
operator||=
name|ZLF_ENTRIES_CDSORTED
expr_stmt|;
comment|/* 	 * Transfer entries whose hash bit 'bit' is set to nl; rehash 	 * the remaining entries 	 * 	 * NB: We could find entries via the hashtable instead. That 	 * would be O(hashents+numents) rather than O(numblks+numents), 	 * but this accesses memory more sequentially, and when we're 	 * called, the block is usually pretty full. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZAP_LEAF_NUMCHUNKS
argument_list|(
name|l
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|zap_leaf_entry
modifier|*
name|le
init|=
name|ZAP_LEAF_ENTRY
argument_list|(
name|l
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|le
operator|->
name|le_type
operator|!=
name|ZAP_CHUNK_ENTRY
condition|)
continue|continue;
if|if
condition|(
name|le
operator|->
name|le_hash
operator|&
operator|(
literal|1ULL
operator|<<
name|bit
operator|)
condition|)
name|zap_leaf_transfer_entry
argument_list|(
name|l
argument_list|,
name|i
argument_list|,
name|nl
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|zap_leaf_rehash_entry
argument_list|(
name|l
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|zap_leaf_stats
parameter_list|(
name|zap_t
modifier|*
name|zap
parameter_list|,
name|zap_leaf_t
modifier|*
name|l
parameter_list|,
name|zap_stats_t
modifier|*
name|zs
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|n
operator|=
name|zap_f_phys
argument_list|(
name|zap
argument_list|)
operator|->
name|zap_ptrtbl
operator|.
name|zt_shift
operator|-
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_prefix_len
expr_stmt|;
name|n
operator|=
name|MIN
argument_list|(
name|n
argument_list|,
name|ZAP_HISTOGRAM_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|zs
operator|->
name|zs_leafs_with_2n_pointers
index|[
name|n
index|]
operator|++
expr_stmt|;
name|n
operator|=
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_nentries
operator|/
literal|5
expr_stmt|;
name|n
operator|=
name|MIN
argument_list|(
name|n
argument_list|,
name|ZAP_HISTOGRAM_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|zs
operator|->
name|zs_blocks_with_n5_entries
index|[
name|n
index|]
operator|++
expr_stmt|;
name|n
operator|=
operator|(
operator|(
literal|1
operator|<<
name|FZAP_BLOCK_SHIFT
argument_list|(
name|zap
argument_list|)
operator|)
operator|-
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hdr
operator|.
name|lh_nfree
operator|*
operator|(
name|ZAP_LEAF_ARRAY_BYTES
operator|+
literal|1
operator|)
operator|)
operator|*
literal|10
operator|/
operator|(
literal|1
operator|<<
name|FZAP_BLOCK_SHIFT
argument_list|(
name|zap
argument_list|)
operator|)
expr_stmt|;
name|n
operator|=
name|MIN
argument_list|(
name|n
argument_list|,
name|ZAP_HISTOGRAM_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|zs
operator|->
name|zs_blocks_n_tenths_full
index|[
name|n
index|]
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ZAP_LEAF_HASH_NUMENTRIES
argument_list|(
name|l
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|int
name|nentries
init|=
literal|0
decl_stmt|;
name|int
name|chunk
init|=
name|zap_leaf_phys
argument_list|(
name|l
argument_list|)
operator|->
name|l_hash
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|chunk
operator|!=
name|CHAIN_END
condition|)
block|{
name|struct
name|zap_leaf_entry
modifier|*
name|le
init|=
name|ZAP_LEAF_ENTRY
argument_list|(
name|l
argument_list|,
name|chunk
argument_list|)
decl_stmt|;
name|n
operator|=
literal|1
operator|+
name|ZAP_LEAF_ARRAY_NCHUNKS
argument_list|(
name|le
operator|->
name|le_name_numints
argument_list|)
operator|+
name|ZAP_LEAF_ARRAY_NCHUNKS
argument_list|(
name|le
operator|->
name|le_value_numints
operator|*
name|le
operator|->
name|le_value_intlen
argument_list|)
expr_stmt|;
name|n
operator|=
name|MIN
argument_list|(
name|n
argument_list|,
name|ZAP_HISTOGRAM_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|zs
operator|->
name|zs_entries_using_n_chunks
index|[
name|n
index|]
operator|++
expr_stmt|;
name|chunk
operator|=
name|le
operator|->
name|le_next
expr_stmt|;
name|nentries
operator|++
expr_stmt|;
block|}
name|n
operator|=
name|nentries
expr_stmt|;
name|n
operator|=
name|MIN
argument_list|(
name|n
argument_list|,
name|ZAP_HISTOGRAM_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|zs
operator|->
name|zs_buckets_with_n_entries
index|[
name|n
index|]
operator|++
expr_stmt|;
block|}
block|}
end_function

end_unit

