begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2012, 2015 by Delphix. All rights reserved.  * Copyright (c) 2013 by Saso Kiselkov. All rights reserved.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_DBUF_H
end_ifndef

begin_define
define|#
directive|define
name|_SYS_DBUF_H
end_define

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/txg.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/arc.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/zrlock.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
define|#
directive|define
name|IN_DMU_SYNC
value|2
comment|/*  * define flags for dbuf_read  */
define|#
directive|define
name|DB_RF_MUST_SUCCEED
value|(1<< 0)
define|#
directive|define
name|DB_RF_CANFAIL
value|(1<< 1)
define|#
directive|define
name|DB_RF_HAVESTRUCT
value|(1<< 2)
define|#
directive|define
name|DB_RF_NOPREFETCH
value|(1<< 3)
define|#
directive|define
name|DB_RF_NEVERWAIT
value|(1<< 4)
define|#
directive|define
name|DB_RF_CACHED
value|(1<< 5)
comment|/*  * The simplified state transition diagram for dbufs looks like:  *  *		+----> READ ----+  *		|		|  *		|		V  *  (alloc)-->UNCACHED	     CACHED-->EVICTING-->(free)  *		|		^	 ^  *		|		|	 |  *		+----> FILL ----+	 |  *		|			 |  *		|			 |  *		+--------> NOFILL -------+  */
typedef|typedef
enum|enum
name|dbuf_states
block|{
name|DB_UNCACHED
block|,
name|DB_FILL
block|,
name|DB_NOFILL
block|,
name|DB_READ
block|,
name|DB_CACHED
block|,
name|DB_EVICTING
block|}
name|dbuf_states_t
typedef|;
struct_decl|struct
name|dnode
struct_decl|;
struct_decl|struct
name|dmu_tx
struct_decl|;
comment|/*  * level = 0 means the user data  * level = 1 means the single indirect block  * etc.  */
struct_decl|struct
name|dmu_buf_impl
struct_decl|;
typedef|typedef
enum|enum
name|override_states
block|{
name|DR_NOT_OVERRIDDEN
block|,
name|DR_IN_DMU_SYNC
block|,
name|DR_OVERRIDDEN
block|}
name|override_states_t
typedef|;
typedef|typedef
struct|struct
name|dbuf_dirty_record
block|{
comment|/* link on our parents dirty list */
name|list_node_t
name|dr_dirty_node
decl_stmt|;
comment|/* transaction group this data will sync in */
name|uint64_t
name|dr_txg
decl_stmt|;
comment|/* zio of outstanding write IO */
name|zio_t
modifier|*
name|dr_zio
decl_stmt|;
comment|/* pointer back to our dbuf */
name|struct
name|dmu_buf_impl
modifier|*
name|dr_dbuf
decl_stmt|;
comment|/* pointer to next dirty record */
name|struct
name|dbuf_dirty_record
modifier|*
name|dr_next
decl_stmt|;
comment|/* pointer to parent dirty record */
name|struct
name|dbuf_dirty_record
modifier|*
name|dr_parent
decl_stmt|;
comment|/* How much space was changed to dsl_pool_dirty_space() for this? */
name|unsigned
name|int
name|dr_accounted
decl_stmt|;
union|union
name|dirty_types
block|{
struct|struct
name|dirty_indirect
block|{
comment|/* protect access to list */
name|kmutex_t
name|dr_mtx
decl_stmt|;
comment|/* Our list of dirty children */
name|list_t
name|dr_children
decl_stmt|;
block|}
name|di
struct|;
struct|struct
name|dirty_leaf
block|{
comment|/* 			 * dr_data is set when we dirty the buffer 			 * so that we can retain the pointer even if it 			 * gets COW'd in a subsequent transaction group. 			 */
name|arc_buf_t
modifier|*
name|dr_data
decl_stmt|;
name|blkptr_t
name|dr_overridden_by
decl_stmt|;
name|override_states_t
name|dr_override_state
decl_stmt|;
name|uint8_t
name|dr_copies
decl_stmt|;
name|boolean_t
name|dr_nopwrite
decl_stmt|;
block|}
name|dl
struct|;
block|}
name|dt
union|;
block|}
name|dbuf_dirty_record_t
typedef|;
typedef|typedef
struct|struct
name|dmu_buf_impl
block|{
comment|/* 	 * The following members are immutable, with the exception of 	 * db.db_data, which is protected by db_mtx. 	 */
comment|/* the publicly visible structure */
name|dmu_buf_t
name|db
decl_stmt|;
comment|/* the objset we belong to */
name|struct
name|objset
modifier|*
name|db_objset
decl_stmt|;
comment|/* 	 * handle to safely access the dnode we belong to (NULL when evicted) 	 */
name|struct
name|dnode_handle
modifier|*
name|db_dnode_handle
decl_stmt|;
comment|/* 	 * our parent buffer; if the dnode points to us directly, 	 * db_parent == db_dnode_handle->dnh_dnode->dn_dbuf 	 * only accessed by sync thread ??? 	 * (NULL when evicted) 	 * May change from NULL to non-NULL under the protection of db_mtx 	 * (see dbuf_check_blkptr()) 	 */
name|struct
name|dmu_buf_impl
modifier|*
name|db_parent
decl_stmt|;
comment|/* 	 * link for hash table of all dmu_buf_impl_t's 	 */
name|struct
name|dmu_buf_impl
modifier|*
name|db_hash_next
decl_stmt|;
comment|/* our block number */
name|uint64_t
name|db_blkid
decl_stmt|;
comment|/* 	 * Pointer to the blkptr_t which points to us. May be NULL if we 	 * don't have one yet. (NULL when evicted) 	 */
name|blkptr_t
modifier|*
name|db_blkptr
decl_stmt|;
comment|/* 	 * Our indirection level.  Data buffers have db_level==0. 	 * Indirect buffers which point to data buffers have 	 * db_level==1. etc.  Buffers which contain dnodes have 	 * db_level==0, since the dnodes are stored in a file. 	 */
name|uint8_t
name|db_level
decl_stmt|;
comment|/* db_mtx protects the members below */
name|kmutex_t
name|db_mtx
decl_stmt|;
comment|/* 	 * Current state of the buffer 	 */
name|dbuf_states_t
name|db_state
decl_stmt|;
comment|/* 	 * Refcount accessed by dmu_buf_{hold,rele}. 	 * If nonzero, the buffer can't be destroyed. 	 * Protected by db_mtx. 	 */
name|refcount_t
name|db_holds
decl_stmt|;
comment|/* buffer holding our data */
name|arc_buf_t
modifier|*
name|db_buf
decl_stmt|;
name|kcondvar_t
name|db_changed
decl_stmt|;
name|dbuf_dirty_record_t
modifier|*
name|db_data_pending
decl_stmt|;
comment|/* pointer to most recent dirty record for this buffer */
name|dbuf_dirty_record_t
modifier|*
name|db_last_dirty
decl_stmt|;
comment|/* 	 * Our link on the owner dnodes's dn_dbufs list. 	 * Protected by its dn_dbufs_mtx. 	 */
name|list_node_t
name|db_link
decl_stmt|;
comment|/* Data which is unique to data (leaf) blocks: */
comment|/* stuff we store for the user (see dmu_buf_set_user) */
name|void
modifier|*
name|db_user_ptr
decl_stmt|;
name|void
modifier|*
modifier|*
name|db_user_data_ptr_ptr
decl_stmt|;
name|dmu_buf_evict_func_t
modifier|*
name|db_evict_func
decl_stmt|;
name|uint8_t
name|db_immediate_evict
decl_stmt|;
name|uint8_t
name|db_freed_in_flight
decl_stmt|;
name|uint8_t
name|db_dirtycnt
decl_stmt|;
block|}
name|dmu_buf_impl_t
typedef|;
comment|/* Note: the dbuf hash table is exposed only for the mdb module */
define|#
directive|define
name|DBUF_MUTEXES
value|256
define|#
directive|define
name|DBUF_HASH_MUTEX
parameter_list|(
name|h
parameter_list|,
name|idx
parameter_list|)
value|(&(h)->hash_mutexes[(idx)& (DBUF_MUTEXES-1)])
typedef|typedef
struct|struct
name|dbuf_hash_table
block|{
name|uint64_t
name|hash_table_mask
decl_stmt|;
name|dmu_buf_impl_t
modifier|*
modifier|*
name|hash_table
decl_stmt|;
name|kmutex_t
name|hash_mutexes
index|[
name|DBUF_MUTEXES
index|]
decl_stmt|;
block|}
name|dbuf_hash_table_t
typedef|;
name|uint64_t
name|dbuf_whichblock
parameter_list|(
name|struct
name|dnode
modifier|*
name|di
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
function_decl|;
name|dmu_buf_impl_t
modifier|*
name|dbuf_create_tlib
parameter_list|(
name|struct
name|dnode
modifier|*
name|dn
parameter_list|,
name|char
modifier|*
name|data
parameter_list|)
function_decl|;
name|void
name|dbuf_create_bonus
parameter_list|(
name|struct
name|dnode
modifier|*
name|dn
parameter_list|)
function_decl|;
name|int
name|dbuf_spill_set_blksz
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|uint64_t
name|blksz
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|void
name|dbuf_spill_hold
parameter_list|(
name|struct
name|dnode
modifier|*
name|dn
parameter_list|,
name|dmu_buf_impl_t
modifier|*
modifier|*
name|dbp
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
name|void
name|dbuf_rm_spill
parameter_list|(
name|struct
name|dnode
modifier|*
name|dn
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|dmu_buf_impl_t
modifier|*
name|dbuf_hold
parameter_list|(
name|struct
name|dnode
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|blkid
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
name|dmu_buf_impl_t
modifier|*
name|dbuf_hold_level
parameter_list|(
name|struct
name|dnode
modifier|*
name|dn
parameter_list|,
name|int
name|level
parameter_list|,
name|uint64_t
name|blkid
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
name|int
name|dbuf_hold_impl
parameter_list|(
name|struct
name|dnode
modifier|*
name|dn
parameter_list|,
name|uint8_t
name|level
parameter_list|,
name|uint64_t
name|blkid
parameter_list|,
name|int
name|create
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_buf_impl_t
modifier|*
modifier|*
name|dbp
parameter_list|)
function_decl|;
name|void
name|dbuf_prefetch
parameter_list|(
name|struct
name|dnode
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|blkid
parameter_list|,
name|zio_priority_t
name|prio
parameter_list|)
function_decl|;
name|void
name|dbuf_add_ref
parameter_list|(
name|dmu_buf_impl_t
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
name|uint64_t
name|dbuf_refcount
parameter_list|(
name|dmu_buf_impl_t
modifier|*
name|db
parameter_list|)
function_decl|;
name|void
name|dbuf_rele
parameter_list|(
name|dmu_buf_impl_t
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
name|void
name|dbuf_rele_and_unlock
parameter_list|(
name|dmu_buf_impl_t
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
name|dmu_buf_impl_t
modifier|*
name|dbuf_find
parameter_list|(
name|struct
name|dnode
modifier|*
name|dn
parameter_list|,
name|uint8_t
name|level
parameter_list|,
name|uint64_t
name|blkid
parameter_list|)
function_decl|;
name|int
name|dbuf_read
parameter_list|(
name|dmu_buf_impl_t
modifier|*
name|db
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
function_decl|;
name|void
name|dmu_buf_will_not_fill
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|void
name|dmu_buf_will_fill
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|void
name|dmu_buf_fill_done
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|void
name|dbuf_assign_arcbuf
parameter_list|(
name|dmu_buf_impl_t
modifier|*
name|db
parameter_list|,
name|arc_buf_t
modifier|*
name|buf
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|dbuf_dirty_record_t
modifier|*
name|dbuf_dirty
parameter_list|(
name|dmu_buf_impl_t
modifier|*
name|db
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|arc_buf_t
modifier|*
name|dbuf_loan_arcbuf
parameter_list|(
name|dmu_buf_impl_t
modifier|*
name|db
parameter_list|)
function_decl|;
name|void
name|dbuf_clear
parameter_list|(
name|dmu_buf_impl_t
modifier|*
name|db
parameter_list|)
function_decl|;
name|void
name|dbuf_evict
parameter_list|(
name|dmu_buf_impl_t
modifier|*
name|db
parameter_list|)
function_decl|;
name|void
name|dbuf_setdirty
parameter_list|(
name|dmu_buf_impl_t
modifier|*
name|db
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|void
name|dbuf_unoverride
parameter_list|(
name|dbuf_dirty_record_t
modifier|*
name|dr
parameter_list|)
function_decl|;
name|void
name|dbuf_sync_list
parameter_list|(
name|list_t
modifier|*
name|list
parameter_list|,
name|int
name|level
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|void
name|dbuf_release_bp
parameter_list|(
name|dmu_buf_impl_t
modifier|*
name|db
parameter_list|)
function_decl|;
name|void
name|dbuf_free_range
parameter_list|(
name|struct
name|dnode
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|start
parameter_list|,
name|uint64_t
name|end
parameter_list|,
name|struct
name|dmu_tx
modifier|*
parameter_list|)
function_decl|;
name|void
name|dbuf_new_size
parameter_list|(
name|dmu_buf_impl_t
modifier|*
name|db
parameter_list|,
name|int
name|size
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
define|#
directive|define
name|DB_DNODE
parameter_list|(
name|_db
parameter_list|)
value|((_db)->db_dnode_handle->dnh_dnode)
define|#
directive|define
name|DB_DNODE_LOCK
parameter_list|(
name|_db
parameter_list|)
value|((_db)->db_dnode_handle->dnh_zrlock)
define|#
directive|define
name|DB_DNODE_ENTER
parameter_list|(
name|_db
parameter_list|)
value|(zrl_add(&DB_DNODE_LOCK(_db)))
define|#
directive|define
name|DB_DNODE_EXIT
parameter_list|(
name|_db
parameter_list|)
value|(zrl_remove(&DB_DNODE_LOCK(_db)))
define|#
directive|define
name|DB_DNODE_HELD
parameter_list|(
name|_db
parameter_list|)
value|(!zrl_is_zero(&DB_DNODE_LOCK(_db)))
name|void
name|dbuf_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|dbuf_fini
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|boolean_t
name|dbuf_is_metadata
parameter_list|(
name|dmu_buf_impl_t
modifier|*
name|db
parameter_list|)
function_decl|;
define|#
directive|define
name|DBUF_GET_BUFC_TYPE
parameter_list|(
name|_db
parameter_list|)
define|\
value|(dbuf_is_metadata(_db) ? ARC_BUFC_METADATA : ARC_BUFC_DATA)
define|#
directive|define
name|DBUF_IS_CACHEABLE
parameter_list|(
name|_db
parameter_list|)
define|\
value|((_db)->db_objset->os_primary_cache == ZFS_CACHE_ALL ||		\ 	(dbuf_is_metadata(_db)&&					\ 	((_db)->db_objset->os_primary_cache == ZFS_CACHE_METADATA)))
define|#
directive|define
name|DBUF_IS_L2CACHEABLE
parameter_list|(
name|_db
parameter_list|)
define|\
value|((_db)->db_objset->os_secondary_cache == ZFS_CACHE_ALL ||	\ 	(dbuf_is_metadata(_db)&&					\ 	((_db)->db_objset->os_secondary_cache == ZFS_CACHE_METADATA)))
define|#
directive|define
name|DBUF_IS_L2COMPRESSIBLE
parameter_list|(
name|_db
parameter_list|)
define|\
value|((_db)->db_objset->os_compress != ZIO_COMPRESS_OFF ||		\ 	(dbuf_is_metadata(_db)&& zfs_mdcomp_disable == B_FALSE))
ifdef|#
directive|ifdef
name|ZFS_DEBUG
comment|/*  * There should be a ## between the string literal and fmt, to make it  * clear that we're joining two strings together, but gcc does not  * support that preprocessor token.  */
define|#
directive|define
name|dprintf_dbuf
parameter_list|(
name|dbuf
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do { \ 	if (zfs_flags& ZFS_DEBUG_DPRINTF) { \ 	char __db_buf[32]; \ 	uint64_t __db_obj = (dbuf)->db.db_object; \ 	if (__db_obj == DMU_META_DNODE_OBJECT) \ 		(void) strcpy(__db_buf, "mdn"); \ 	else \ 		(void) snprintf(__db_buf, sizeof (__db_buf), "%lld", \ 		    (u_longlong_t)__db_obj); \ 	dprintf_ds((dbuf)->db_objset->os_dsl_dataset, \ 	    "obj=%s lvl=%u blkid=%lld " fmt, \ 	    __db_buf, (dbuf)->db_level, \ 	    (u_longlong_t)(dbuf)->db_blkid, __VA_ARGS__); \ 	} \ _NOTE(CONSTCOND) } while (0)
define|#
directive|define
name|dprintf_dbuf_bp
parameter_list|(
name|db
parameter_list|,
name|bp
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {			\ 	if (zfs_flags& ZFS_DEBUG_DPRINTF) {			\ 	char *__blkbuf = kmem_alloc(BP_SPRINTF_LEN, KM_SLEEP);	\ 	snprintf_blkptr(__blkbuf, BP_SPRINTF_LEN, bp);		\ 	dprintf_dbuf(db, fmt " %s\n", __VA_ARGS__, __blkbuf);	\ 	kmem_free(__blkbuf, BP_SPRINTF_LEN);			\ 	}							\ _NOTE(CONSTCOND) } while (0)
define|#
directive|define
name|DBUF_VERIFY
parameter_list|(
name|db
parameter_list|)
value|dbuf_verify(db)
else|#
directive|else
define|#
directive|define
name|dprintf_dbuf
parameter_list|(
name|db
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
define|#
directive|define
name|dprintf_dbuf_bp
parameter_list|(
name|db
parameter_list|,
name|bp
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
define|#
directive|define
name|DBUF_VERIFY
parameter_list|(
name|db
parameter_list|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _SYS_DBUF_H */
end_comment

end_unit

