begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* inffast.c -- fast decoding  * Copyright (C) 1995-2004 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|"zutil.h"
end_include

begin_include
include|#
directive|include
file|"inftrees.h"
end_include

begin_include
include|#
directive|include
file|"inflate.h"
end_include

begin_include
include|#
directive|include
file|"inffast.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|ASMINF
end_ifndef

begin_comment
comment|/* Allow machine dependent optimization for post-increment or pre-increment.    Based on testing to date,    Pre-increment preferred for:    - PowerPC G3 (Adler)    - MIPS R5000 (Randers-Pehrson)    Post-increment preferred for:    - none    No measurable difference:    - Pentium III (Anderson)    - M68060 (Nikl)  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|POSTINC
end_ifdef

begin_define
define|#
directive|define
name|OFF
value|0
end_define

begin_define
define|#
directive|define
name|PUP
parameter_list|(
name|a
parameter_list|)
value|*(a)++
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|OFF
value|1
end_define

begin_define
define|#
directive|define
name|PUP
parameter_list|(
name|a
parameter_list|)
value|*++(a)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*    Decode literal, length, and distance codes and write out the resulting    literal and match bytes until either not enough input or output is    available, an end-of-block is encountered, or a data error is encountered.    When large enough input and output buffers are supplied to inflate(), for    example, a 16K input buffer and a 64K output buffer, more than 95% of the    inflate execution time is spent in this routine.     Entry assumptions:          state->mode == LEN         strm->avail_in>= 6         strm->avail_out>= 258         start>= strm->avail_out         state->bits< 8     On return, state->mode is one of:          LEN -- ran out of enough output space or enough available input         TYPE -- reached end of block code, inflate() to interpret next block         BAD -- error in block data     Notes:      - The maximum input bits used by a length/distance pair is 15 bits for the       length code, 5 bits for the length extra, 15 bits for the distance code,       and 13 bits for the distance extra.  This totals 48 bits, or six bytes.       Therefore if strm->avail_in>= 6, then there is enough input to avoid       checking for available input while decoding.      - The maximum bytes that a single length/distance pair can output is 258       bytes, which is the maximum length that can be coded.  inflate_fast()       requires strm->avail_out>= 258 for each loop to avoid checking for       output space.  */
end_comment

begin_function
name|void
name|inflate_fast
parameter_list|(
name|strm
parameter_list|,
name|start
parameter_list|)
name|z_streamp
name|strm
decl_stmt|;
name|unsigned
name|start
decl_stmt|;
comment|/* inflate()'s starting value for strm->avail_out */
block|{
name|struct
name|inflate_state
name|FAR
modifier|*
name|state
decl_stmt|;
name|unsigned
name|char
name|FAR
modifier|*
name|in
decl_stmt|;
comment|/* local strm->next_in */
name|unsigned
name|char
name|FAR
modifier|*
name|last
decl_stmt|;
comment|/* while in< last, enough input available */
name|unsigned
name|char
name|FAR
modifier|*
name|out
decl_stmt|;
comment|/* local strm->next_out */
name|unsigned
name|char
name|FAR
modifier|*
name|beg
decl_stmt|;
comment|/* inflate()'s initial strm->next_out */
name|unsigned
name|char
name|FAR
modifier|*
name|end
decl_stmt|;
comment|/* while out< end, enough space available */
ifdef|#
directive|ifdef
name|INFLATE_STRICT
name|unsigned
name|dmax
decl_stmt|;
comment|/* maximum distance from zlib header */
endif|#
directive|endif
name|unsigned
name|wsize
decl_stmt|;
comment|/* window size or zero if not using window */
name|unsigned
name|whave
decl_stmt|;
comment|/* valid bytes in the window */
name|unsigned
name|write
decl_stmt|;
comment|/* window write index */
name|unsigned
name|char
name|FAR
modifier|*
name|window
decl_stmt|;
comment|/* allocated sliding window, if wsize != 0 */
name|unsigned
name|long
name|hold
decl_stmt|;
comment|/* local strm->hold */
name|unsigned
name|bits
decl_stmt|;
comment|/* local strm->bits */
name|code
specifier|const
name|FAR
modifier|*
name|lcode
decl_stmt|;
comment|/* local strm->lencode */
name|code
specifier|const
name|FAR
modifier|*
name|dcode
decl_stmt|;
comment|/* local strm->distcode */
name|unsigned
name|lmask
decl_stmt|;
comment|/* mask for first level of length codes */
name|unsigned
name|dmask
decl_stmt|;
comment|/* mask for first level of distance codes */
name|code
name|this
decl_stmt|;
comment|/* retrieved table entry */
name|unsigned
name|op
decl_stmt|;
comment|/* code bits, operation, extra bits, or */
comment|/*  window position, window bytes to copy */
name|unsigned
name|len
decl_stmt|;
comment|/* match length, unused bytes */
name|unsigned
name|dist
decl_stmt|;
comment|/* match distance */
name|unsigned
name|char
name|FAR
modifier|*
name|from
decl_stmt|;
comment|/* where to copy match from */
comment|/* copy state to local variables */
name|state
operator|=
operator|(
expr|struct
name|inflate_state
name|FAR
operator|*
operator|)
name|strm
operator|->
name|state
expr_stmt|;
name|in
operator|=
name|strm
operator|->
name|next_in
operator|-
name|OFF
expr_stmt|;
name|last
operator|=
name|in
operator|+
operator|(
name|strm
operator|->
name|avail_in
operator|-
literal|5
operator|)
expr_stmt|;
name|out
operator|=
name|strm
operator|->
name|next_out
operator|-
name|OFF
expr_stmt|;
name|beg
operator|=
name|out
operator|-
operator|(
name|start
operator|-
name|strm
operator|->
name|avail_out
operator|)
expr_stmt|;
name|end
operator|=
name|out
operator|+
operator|(
name|strm
operator|->
name|avail_out
operator|-
literal|257
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INFLATE_STRICT
name|dmax
operator|=
name|state
operator|->
name|dmax
expr_stmt|;
endif|#
directive|endif
name|wsize
operator|=
name|state
operator|->
name|wsize
expr_stmt|;
name|whave
operator|=
name|state
operator|->
name|whave
expr_stmt|;
name|write
operator|=
name|state
operator|->
name|write
expr_stmt|;
name|window
operator|=
name|state
operator|->
name|window
expr_stmt|;
name|hold
operator|=
name|state
operator|->
name|hold
expr_stmt|;
name|bits
operator|=
name|state
operator|->
name|bits
expr_stmt|;
name|lcode
operator|=
name|state
operator|->
name|lencode
expr_stmt|;
name|dcode
operator|=
name|state
operator|->
name|distcode
expr_stmt|;
name|lmask
operator|=
operator|(
literal|1U
operator|<<
name|state
operator|->
name|lenbits
operator|)
operator|-
literal|1
expr_stmt|;
name|dmask
operator|=
operator|(
literal|1U
operator|<<
name|state
operator|->
name|distbits
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* decode literals and length/distances until end-of-block or not enough        input data or output space */
do|do
block|{
if|if
condition|(
name|bits
operator|<
literal|15
condition|)
block|{
name|hold
operator|+=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|PUP
argument_list|(
name|in
argument_list|)
argument_list|)
operator|<<
name|bits
expr_stmt|;
name|bits
operator|+=
literal|8
expr_stmt|;
name|hold
operator|+=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|PUP
argument_list|(
name|in
argument_list|)
argument_list|)
operator|<<
name|bits
expr_stmt|;
name|bits
operator|+=
literal|8
expr_stmt|;
block|}
name|this
operator|=
name|lcode
index|[
name|hold
operator|&
name|lmask
index|]
expr_stmt|;
name|dolen
label|:
name|op
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|this
operator|.
name|bits
argument_list|)
expr_stmt|;
name|hold
operator|>>=
name|op
expr_stmt|;
name|bits
operator|-=
name|op
expr_stmt|;
name|op
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|this
operator|.
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|0
condition|)
block|{
comment|/* literal */
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
name|this
operator|.
name|val
operator|>=
literal|0x20
operator|&&
name|this
operator|.
name|val
operator|<
literal|0x7f
condition|?
literal|"inflate:         literal '%c'\n"
else|:
literal|"inflate:         literal 0x%02x\n"
operator|,
name|this
operator|.
name|val
operator|)
argument_list|)
expr_stmt|;
name|PUP
argument_list|(
name|out
argument_list|)
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|this
operator|.
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|op
operator|&
literal|16
condition|)
block|{
comment|/* length base */
name|len
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|this
operator|.
name|val
argument_list|)
expr_stmt|;
name|op
operator|&=
literal|15
expr_stmt|;
comment|/* number of extra bits */
if|if
condition|(
name|op
condition|)
block|{
if|if
condition|(
name|bits
operator|<
name|op
condition|)
block|{
name|hold
operator|+=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|PUP
argument_list|(
name|in
argument_list|)
argument_list|)
operator|<<
name|bits
expr_stmt|;
name|bits
operator|+=
literal|8
expr_stmt|;
block|}
name|len
operator|+=
operator|(
name|unsigned
operator|)
name|hold
operator|&
operator|(
operator|(
literal|1U
operator|<<
name|op
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|hold
operator|>>=
name|op
expr_stmt|;
name|bits
operator|-=
name|op
expr_stmt|;
block|}
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:         length %u\n"
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|<
literal|15
condition|)
block|{
name|hold
operator|+=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|PUP
argument_list|(
name|in
argument_list|)
argument_list|)
operator|<<
name|bits
expr_stmt|;
name|bits
operator|+=
literal|8
expr_stmt|;
name|hold
operator|+=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|PUP
argument_list|(
name|in
argument_list|)
argument_list|)
operator|<<
name|bits
expr_stmt|;
name|bits
operator|+=
literal|8
expr_stmt|;
block|}
name|this
operator|=
name|dcode
index|[
name|hold
operator|&
name|dmask
index|]
expr_stmt|;
name|dodist
label|:
name|op
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|this
operator|.
name|bits
argument_list|)
expr_stmt|;
name|hold
operator|>>=
name|op
expr_stmt|;
name|bits
operator|-=
name|op
expr_stmt|;
name|op
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|this
operator|.
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|&
literal|16
condition|)
block|{
comment|/* distance base */
name|dist
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|this
operator|.
name|val
argument_list|)
expr_stmt|;
name|op
operator|&=
literal|15
expr_stmt|;
comment|/* number of extra bits */
if|if
condition|(
name|bits
operator|<
name|op
condition|)
block|{
name|hold
operator|+=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|PUP
argument_list|(
name|in
argument_list|)
argument_list|)
operator|<<
name|bits
expr_stmt|;
name|bits
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|bits
operator|<
name|op
condition|)
block|{
name|hold
operator|+=
call|(
name|unsigned
name|long
call|)
argument_list|(
name|PUP
argument_list|(
name|in
argument_list|)
argument_list|)
operator|<<
name|bits
expr_stmt|;
name|bits
operator|+=
literal|8
expr_stmt|;
block|}
block|}
name|dist
operator|+=
operator|(
name|unsigned
operator|)
name|hold
operator|&
operator|(
operator|(
literal|1U
operator|<<
name|op
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INFLATE_STRICT
if|if
condition|(
name|dist
operator|>
name|dmax
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid distance too far back"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
name|hold
operator|>>=
name|op
expr_stmt|;
name|bits
operator|-=
name|op
expr_stmt|;
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:         distance %u\n"
operator|,
name|dist
operator|)
argument_list|)
expr_stmt|;
name|op
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|out
operator|-
name|beg
argument_list|)
expr_stmt|;
comment|/* max distance in output */
if|if
condition|(
name|dist
operator|>
name|op
condition|)
block|{
comment|/* see if copy from window */
name|op
operator|=
name|dist
operator|-
name|op
expr_stmt|;
comment|/* distance back in window */
if|if
condition|(
name|op
operator|>
name|whave
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid distance too far back"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
name|from
operator|=
name|window
operator|-
name|OFF
expr_stmt|;
if|if
condition|(
name|write
operator|==
literal|0
condition|)
block|{
comment|/* very common case */
name|from
operator|+=
name|wsize
operator|-
name|op
expr_stmt|;
if|if
condition|(
name|op
operator|<
name|len
condition|)
block|{
comment|/* some from window */
name|len
operator|-=
name|op
expr_stmt|;
do|do
block|{
name|PUP
argument_list|(
name|out
argument_list|)
operator|=
name|PUP
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|op
condition|)
do|;
name|from
operator|=
name|out
operator|-
name|dist
expr_stmt|;
comment|/* rest from output */
block|}
block|}
elseif|else
if|if
condition|(
name|write
operator|<
name|op
condition|)
block|{
comment|/* wrap around window */
name|from
operator|+=
name|wsize
operator|+
name|write
operator|-
name|op
expr_stmt|;
name|op
operator|-=
name|write
expr_stmt|;
if|if
condition|(
name|op
operator|<
name|len
condition|)
block|{
comment|/* some from end of window */
name|len
operator|-=
name|op
expr_stmt|;
do|do
block|{
name|PUP
argument_list|(
name|out
argument_list|)
operator|=
name|PUP
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|op
condition|)
do|;
name|from
operator|=
name|window
operator|-
name|OFF
expr_stmt|;
if|if
condition|(
name|write
operator|<
name|len
condition|)
block|{
comment|/* some from start of window */
name|op
operator|=
name|write
expr_stmt|;
name|len
operator|-=
name|op
expr_stmt|;
do|do
block|{
name|PUP
argument_list|(
name|out
argument_list|)
operator|=
name|PUP
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|op
condition|)
do|;
name|from
operator|=
name|out
operator|-
name|dist
expr_stmt|;
comment|/* rest from output */
block|}
block|}
block|}
else|else
block|{
comment|/* contiguous in window */
name|from
operator|+=
name|write
operator|-
name|op
expr_stmt|;
if|if
condition|(
name|op
operator|<
name|len
condition|)
block|{
comment|/* some from window */
name|len
operator|-=
name|op
expr_stmt|;
do|do
block|{
name|PUP
argument_list|(
name|out
argument_list|)
operator|=
name|PUP
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|op
condition|)
do|;
name|from
operator|=
name|out
operator|-
name|dist
expr_stmt|;
comment|/* rest from output */
block|}
block|}
while|while
condition|(
name|len
operator|>
literal|2
condition|)
block|{
name|PUP
argument_list|(
name|out
argument_list|)
operator|=
name|PUP
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|PUP
argument_list|(
name|out
argument_list|)
operator|=
name|PUP
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|PUP
argument_list|(
name|out
argument_list|)
operator|=
name|PUP
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
block|{
name|PUP
argument_list|(
name|out
argument_list|)
operator|=
name|PUP
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|1
condition|)
name|PUP
argument_list|(
name|out
argument_list|)
operator|=
name|PUP
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|from
operator|=
name|out
operator|-
name|dist
expr_stmt|;
comment|/* copy direct from output */
do|do
block|{
comment|/* minimum length is three */
name|PUP
argument_list|(
name|out
argument_list|)
operator|=
name|PUP
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|PUP
argument_list|(
name|out
argument_list|)
operator|=
name|PUP
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|PUP
argument_list|(
name|out
argument_list|)
operator|=
name|PUP
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|len
operator|-=
literal|3
expr_stmt|;
block|}
do|while
condition|(
name|len
operator|>
literal|2
condition|)
do|;
if|if
condition|(
name|len
condition|)
block|{
name|PUP
argument_list|(
name|out
argument_list|)
operator|=
name|PUP
argument_list|(
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|1
condition|)
name|PUP
argument_list|(
name|out
argument_list|)
operator|=
name|PUP
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|op
operator|&
literal|64
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 2nd level distance code */
name|this
operator|=
name|dcode
index|[
name|this
operator|.
name|val
operator|+
operator|(
name|hold
operator|&
operator|(
operator|(
literal|1U
operator|<<
name|op
operator|)
operator|-
literal|1
operator|)
operator|)
index|]
expr_stmt|;
goto|goto
name|dodist
goto|;
block|}
else|else
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid distance code"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|op
operator|&
literal|64
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 2nd level length code */
name|this
operator|=
name|lcode
index|[
name|this
operator|.
name|val
operator|+
operator|(
name|hold
operator|&
operator|(
operator|(
literal|1U
operator|<<
name|op
operator|)
operator|-
literal|1
operator|)
operator|)
index|]
expr_stmt|;
goto|goto
name|dolen
goto|;
block|}
elseif|else
if|if
condition|(
name|op
operator|&
literal|32
condition|)
block|{
comment|/* end-of-block */
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:         end of block\n"
operator|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|TYPE
expr_stmt|;
break|break;
block|}
else|else
block|{
name|strm
operator|->
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
literal|"invalid literal/length code"
expr_stmt|;
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|in
operator|<
name|last
operator|&&
name|out
operator|<
name|end
condition|)
do|;
comment|/* return unused bytes (on entry, bits< 8, so in won't go too far back) */
name|len
operator|=
name|bits
operator|>>
literal|3
expr_stmt|;
name|in
operator|-=
name|len
expr_stmt|;
name|bits
operator|-=
name|len
operator|<<
literal|3
expr_stmt|;
name|hold
operator|&=
operator|(
literal|1U
operator|<<
name|bits
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* update state and return */
name|strm
operator|->
name|next_in
operator|=
name|in
operator|+
name|OFF
expr_stmt|;
name|strm
operator|->
name|next_out
operator|=
name|out
operator|+
name|OFF
expr_stmt|;
name|strm
operator|->
name|avail_in
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|in
operator|<
name|last
condition|?
literal|5
operator|+
operator|(
name|last
operator|-
name|in
operator|)
else|:
literal|5
operator|-
operator|(
name|in
operator|-
name|last
operator|)
argument_list|)
expr_stmt|;
name|strm
operator|->
name|avail_out
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|out
operator|<
name|end
condition|?
literal|257
operator|+
operator|(
name|end
operator|-
name|out
operator|)
else|:
literal|257
operator|-
operator|(
name|out
operator|-
name|end
operator|)
argument_list|)
expr_stmt|;
name|state
operator|->
name|hold
operator|=
name|hold
expr_stmt|;
name|state
operator|->
name|bits
operator|=
name|bits
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*    inflate_fast() speedups that turned out slower (on a PowerPC G3 750CXe):    - Using bit fields for code structure    - Different op definition to avoid& for extra bits (do& for table bits)    - Three separate decoding do-loops for direct, window, and write == 0    - Special case for distance> 1 copies to do overlapped load and store copy    - Explicit branch predictions (based on measured branch probabilities)    - Deferring match copy and interspersed it with decoding subsequent codes    - Swapping literal/length else    - Swapping window/direct else    - Larger unrolled copy loops (three is about right)    - Moving len -= 3 statement into middle of loop  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !ASMINF */
end_comment

end_unit

