begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License, Version 1.0 only  * (the "License").  You may not use this file except in compliance  * with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  *  * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/* Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T */
end_comment

begin_comment
comment|/* All Rights Reserved */
end_comment

begin_comment
comment|/*  * Portions of this source code were derived from Berkeley  * 4.3 BSD under license from the Regents of the University of  * California.  */
end_comment

begin_comment
comment|/*  * xdr.h, External Data Representation Serialization Routines.  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_RPC_XDR_H
end_ifndef

begin_define
define|#
directive|define
name|_RPC_XDR_H
end_define

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_include
include|#
directive|include
file|<sys/byteorder.h>
end_include

begin_comment
comment|/* For all ntoh* and hton*() kind of macros */
end_comment

begin_include
include|#
directive|include
file|<rpc/types.h>
end_include

begin_comment
comment|/* For all ntoh* and hton*() kind of macros */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* defines FILE *, used in ANSI C function prototypes */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/*  * XDR provides a conventional way for converting between C data  * types and an external bit-string representation.  Library supplied  * routines provide for the conversion on built-in C data types.  These  * routines and utility routines defined here are used to help implement  * a type encode/decode routine for each user-defined type.  *  * Each data type provides a single procedure which takes two arguments:  *  *	bool_t  *	xdrproc(xdrs, argresp)  *		XDR *xdrs;  *<type> *argresp;  *  * xdrs is an instance of a XDR handle, to which or from which the data  * type is to be converted.  argresp is a pointer to the structure to be  * converted.  The XDR handle contains an operation field which indicates  * which of the operations (ENCODE, DECODE * or FREE) is to be performed.  *  * XDR_DECODE may allocate space if the pointer argresp is null.  This  * data can be freed with the XDR_FREE operation.  *  * We write only one procedure per data type to make it easy  * to keep the encode and decode procedures for a data type consistent.  * In many cases the same code performs all operations on a user defined type,  * because all the hard work is done in the component type routines.  * decode as a series of calls on the nested data types.  */
comment|/*  * Xdr operations.  XDR_ENCODE causes the type to be encoded into the  * stream.  XDR_DECODE causes the type to be extracted from the stream.  * XDR_FREE can be used to release the space allocated by an XDR_DECODE  * request.  */
enum|enum
name|xdr_op
block|{
name|XDR_ENCODE
init|=
literal|0
block|,
name|XDR_DECODE
init|=
literal|1
block|,
name|XDR_FREE
init|=
literal|2
block|}
enum|;
comment|/*  * This is the number of bytes per unit of external data.  */
define|#
directive|define
name|BYTES_PER_XDR_UNIT
value|(4)
define|#
directive|define
name|RNDUP
parameter_list|(
name|x
parameter_list|)
value|((((x) + BYTES_PER_XDR_UNIT - 1) / BYTES_PER_XDR_UNIT) \ 		    * BYTES_PER_XDR_UNIT)
comment|/*  * The XDR handle.  * Contains operation which is being applied to the stream,  * an operations vector for the paticular implementation (e.g. see xdr_mem.c),  * and two private fields for the use of the particular impelementation.  *  * PSARC 2003/523 Contract Private Interface  * XDR  * Changes must be reviewed by Solaris File Sharing  * Changes must be communicated to contract-2003-523@sun.com  */
typedef|typedef
struct|struct
name|XDR
block|{
name|enum
name|xdr_op
name|x_op
decl_stmt|;
comment|/* operation; fast additional param */
name|struct
name|xdr_ops
modifier|*
name|x_ops
decl_stmt|;
name|caddr_t
name|x_public
decl_stmt|;
comment|/* users' data */
name|caddr_t
name|x_private
decl_stmt|;
comment|/* pointer to private data */
name|caddr_t
name|x_base
decl_stmt|;
comment|/* private used for position info */
name|int
name|x_handy
decl_stmt|;
comment|/* extra private word */
block|}
name|XDR
typedef|;
comment|/*  * PSARC 2003/523 Contract Private Interface  * xdr_ops  * Changes must be reviewed by Solaris File Sharing  * Changes must be communicated to contract-2003-523@sun.com  */
struct|struct
name|xdr_ops
block|{
ifdef|#
directive|ifdef
name|__STDC__
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|bool_t
function_decl|(
modifier|*
name|x_getlong
function_decl|)
parameter_list|(
name|struct
name|XDR
modifier|*
parameter_list|,
name|long
modifier|*
parameter_list|)
function_decl|;
comment|/* get a long from underlying stream */
name|bool_t
function_decl|(
modifier|*
name|x_putlong
function_decl|)
parameter_list|(
name|struct
name|XDR
modifier|*
parameter_list|,
name|long
modifier|*
parameter_list|)
function_decl|;
comment|/* put a long to " */
endif|#
directive|endif
comment|/* KERNEL */
name|bool_t
function_decl|(
modifier|*
name|x_getbytes
function_decl|)
parameter_list|(
name|struct
name|XDR
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* get some bytes from " */
name|bool_t
function_decl|(
modifier|*
name|x_putbytes
function_decl|)
parameter_list|(
name|struct
name|XDR
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* put some bytes to " */
name|uint_t
function_decl|(
modifier|*
name|x_getpostn
function_decl|)
parameter_list|(
name|struct
name|XDR
modifier|*
parameter_list|)
function_decl|;
comment|/* returns bytes off from beginning */
name|bool_t
function_decl|(
modifier|*
name|x_setpostn
function_decl|)
parameter_list|(
name|struct
name|XDR
modifier|*
parameter_list|,
name|uint_t
parameter_list|)
function_decl|;
comment|/* lets you reposition the stream */
name|rpc_inline_t
modifier|*
function_decl|(
modifier|*
name|x_inline
function_decl|)
parameter_list|(
name|struct
name|XDR
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
comment|/* buf quick ptr to buffered data */
name|void
function_decl|(
modifier|*
name|x_destroy
function_decl|)
parameter_list|(
name|struct
name|XDR
modifier|*
parameter_list|)
function_decl|;
comment|/* free privates of this xdr_stream */
name|bool_t
function_decl|(
modifier|*
name|x_control
function_decl|)
parameter_list|(
name|struct
name|XDR
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
if|#
directive|if
name|defined
argument_list|(
name|_LP64
argument_list|)
operator|||
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|bool_t
function_decl|(
modifier|*
name|x_getint32
function_decl|)
parameter_list|(
name|struct
name|XDR
modifier|*
parameter_list|,
name|int32_t
modifier|*
parameter_list|)
function_decl|;
comment|/* get a int from underlying stream */
name|bool_t
function_decl|(
modifier|*
name|x_putint32
function_decl|)
parameter_list|(
name|struct
name|XDR
modifier|*
parameter_list|,
name|int32_t
modifier|*
parameter_list|)
function_decl|;
comment|/* put an int to " */
endif|#
directive|endif
comment|/* _LP64 || _KERNEL */
else|#
directive|else
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|bool_t
function_decl|(
modifier|*
name|x_getlong
function_decl|)
parameter_list|()
function_decl|;
comment|/* get a long from underlying stream */
name|bool_t
function_decl|(
modifier|*
name|x_putlong
function_decl|)
parameter_list|()
function_decl|;
comment|/* put a long to " */
endif|#
directive|endif
comment|/* KERNEL */
name|bool_t
function_decl|(
modifier|*
name|x_getbytes
function_decl|)
parameter_list|()
function_decl|;
comment|/* get some bytes from " */
name|bool_t
function_decl|(
modifier|*
name|x_putbytes
function_decl|)
parameter_list|()
function_decl|;
comment|/* put some bytes to " */
name|uint_t
function_decl|(
modifier|*
name|x_getpostn
function_decl|)
parameter_list|()
function_decl|;
comment|/* returns bytes off from beginning */
name|bool_t
function_decl|(
modifier|*
name|x_setpostn
function_decl|)
parameter_list|()
function_decl|;
comment|/* lets you reposition the stream */
name|rpc_inline_t
modifier|*
function_decl|(
modifier|*
name|x_inline
function_decl|)
parameter_list|()
function_decl|;
comment|/* buf quick ptr to buffered data */
name|void
function_decl|(
modifier|*
name|x_destroy
function_decl|)
parameter_list|()
function_decl|;
comment|/* free privates of this xdr_stream */
name|bool_t
function_decl|(
modifier|*
name|x_control
function_decl|)
parameter_list|()
function_decl|;
if|#
directive|if
name|defined
argument_list|(
name|_LP64
argument_list|)
operator|||
name|defined
argument_list|(
name|_KERNEL
argument_list|)
name|bool_t
function_decl|(
modifier|*
name|x_getint32
function_decl|)
parameter_list|()
function_decl|;
name|bool_t
function_decl|(
modifier|*
name|x_putint32
function_decl|)
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|/* _LP64 || defined(_KERNEL) */
endif|#
directive|endif
block|}
struct|;
comment|/*  * Operations defined on a XDR handle  *  * XDR		*xdrs;  * long		*longp;  * caddr_t	 addr;  * uint_t	 len;  * uint_t	 pos;  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
define|#
directive|define
name|XDR_GETLONG
parameter_list|(
name|xdrs
parameter_list|,
name|longp
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_getlong)(xdrs, longp)
define|#
directive|define
name|xdr_getlong
parameter_list|(
name|xdrs
parameter_list|,
name|longp
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_getlong)(xdrs, longp)
define|#
directive|define
name|XDR_PUTLONG
parameter_list|(
name|xdrs
parameter_list|,
name|longp
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_putlong)(xdrs, longp)
define|#
directive|define
name|xdr_putlong
parameter_list|(
name|xdrs
parameter_list|,
name|longp
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_putlong)(xdrs, longp)
endif|#
directive|endif
comment|/* KERNEL */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_LP64
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
comment|/*  * For binary compatability on ILP32 we do not change the shape  * of the XDR structure and the GET/PUTINT32 functions just use  * the get/putlong vectors which operate on identically-sized  * units of data.  */
define|#
directive|define
name|XDR_GETINT32
parameter_list|(
name|xdrs
parameter_list|,
name|int32p
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_getlong)(xdrs, (long *)int32p)
define|#
directive|define
name|xdr_getint32
parameter_list|(
name|xdrs
parameter_list|,
name|int32p
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_getlong)(xdrs, (long *)int32p)
define|#
directive|define
name|XDR_PUTINT32
parameter_list|(
name|xdrs
parameter_list|,
name|int32p
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_putlong)(xdrs, (long *)int32p)
define|#
directive|define
name|xdr_putint32
parameter_list|(
name|xdrs
parameter_list|,
name|int32p
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_putlong)(xdrs, (long *)int32p)
else|#
directive|else
comment|/* !_LP64&& !_KERNEL */
define|#
directive|define
name|XDR_GETINT32
parameter_list|(
name|xdrs
parameter_list|,
name|int32p
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_getint32)(xdrs, int32p)
define|#
directive|define
name|xdr_getint32
parameter_list|(
name|xdrs
parameter_list|,
name|int32p
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_getint32)(xdrs, int32p)
define|#
directive|define
name|XDR_PUTINT32
parameter_list|(
name|xdrs
parameter_list|,
name|int32p
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_putint32)(xdrs, int32p)
define|#
directive|define
name|xdr_putint32
parameter_list|(
name|xdrs
parameter_list|,
name|int32p
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_putint32)(xdrs, int32p)
endif|#
directive|endif
comment|/* !_LP64&& !_KERNEL */
define|#
directive|define
name|XDR_GETBYTES
parameter_list|(
name|xdrs
parameter_list|,
name|addr
parameter_list|,
name|len
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_getbytes)(xdrs, addr, len)
define|#
directive|define
name|xdr_getbytes
parameter_list|(
name|xdrs
parameter_list|,
name|addr
parameter_list|,
name|len
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_getbytes)(xdrs, addr, len)
define|#
directive|define
name|XDR_PUTBYTES
parameter_list|(
name|xdrs
parameter_list|,
name|addr
parameter_list|,
name|len
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_putbytes)(xdrs, addr, len)
define|#
directive|define
name|xdr_putbytes
parameter_list|(
name|xdrs
parameter_list|,
name|addr
parameter_list|,
name|len
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_putbytes)(xdrs, addr, len)
define|#
directive|define
name|XDR_GETPOS
parameter_list|(
name|xdrs
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_getpostn)(xdrs)
define|#
directive|define
name|xdr_getpos
parameter_list|(
name|xdrs
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_getpostn)(xdrs)
define|#
directive|define
name|XDR_SETPOS
parameter_list|(
name|xdrs
parameter_list|,
name|pos
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_setpostn)(xdrs, pos)
define|#
directive|define
name|xdr_setpos
parameter_list|(
name|xdrs
parameter_list|,
name|pos
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_setpostn)(xdrs, pos)
define|#
directive|define
name|XDR_INLINE
parameter_list|(
name|xdrs
parameter_list|,
name|len
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_inline)(xdrs, len)
define|#
directive|define
name|xdr_inline
parameter_list|(
name|xdrs
parameter_list|,
name|len
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_inline)(xdrs, len)
define|#
directive|define
name|XDR_DESTROY
parameter_list|(
name|xdrs
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_destroy)(xdrs)
define|#
directive|define
name|xdr_destroy
parameter_list|(
name|xdrs
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_destroy)(xdrs)
define|#
directive|define
name|XDR_CONTROL
parameter_list|(
name|xdrs
parameter_list|,
name|req
parameter_list|,
name|op
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_control)(xdrs, req, op)
define|#
directive|define
name|xdr_control
parameter_list|(
name|xdrs
parameter_list|,
name|req
parameter_list|,
name|op
parameter_list|)
define|\
value|(*(xdrs)->x_ops->x_control)(xdrs, req, op)
comment|/*  * Support struct for discriminated unions.  * You create an array of xdrdiscrim structures, terminated with  * a entry with a null procedure pointer.  The xdr_union routine gets  * the discriminant value and then searches the array of structures  * for a matching value.  If a match is found the associated xdr routine  * is called to handle that part of the union.  If there is  * no match, then a default routine may be called.  * If there is no match and no default routine it is an error.  */
comment|/*  * A xdrproc_t exists for each data type which is to be encoded or decoded.  *  * The second argument to the xdrproc_t is a pointer to an opaque pointer.  * The opaque pointer generally points to a structure of the data type  * to be decoded.  If this pointer is 0, then the type routines should  * allocate dynamic storage of the appropriate size and return it.  * bool_t	(*xdrproc_t)(XDR *, void *);  */
ifdef|#
directive|ifdef
name|__cplusplus
typedef|typedef
name|bool_t
function_decl|(
modifier|*
name|xdrproc_t
function_decl|)
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
else|#
directive|else
ifdef|#
directive|ifdef
name|__STDC__
typedef|typedef
name|bool_t
function_decl|(
modifier|*
name|xdrproc_t
function_decl|)
parameter_list|()
function_decl|;
comment|/* For Backward compatibility */
else|#
directive|else
typedef|typedef
name|bool_t
function_decl|(
modifier|*
name|xdrproc_t
function_decl|)
parameter_list|()
function_decl|;
endif|#
directive|endif
endif|#
directive|endif
define|#
directive|define
name|NULL_xdrproc_t
value|((xdrproc_t)0)
if|#
directive|if
name|defined
argument_list|(
name|_LP64
argument_list|)
operator|||
name|defined
argument_list|(
name|_I32LPx
argument_list|)
define|#
directive|define
name|xdr_rpcvers
parameter_list|(
name|xdrs
parameter_list|,
name|versp
parameter_list|)
value|xdr_u_int(xdrs, versp)
define|#
directive|define
name|xdr_rpcprog
parameter_list|(
name|xdrs
parameter_list|,
name|progp
parameter_list|)
value|xdr_u_int(xdrs, progp)
define|#
directive|define
name|xdr_rpcproc
parameter_list|(
name|xdrs
parameter_list|,
name|procp
parameter_list|)
value|xdr_u_int(xdrs, procp)
define|#
directive|define
name|xdr_rpcprot
parameter_list|(
name|xdrs
parameter_list|,
name|protp
parameter_list|)
value|xdr_u_int(xdrs, protp)
define|#
directive|define
name|xdr_rpcport
parameter_list|(
name|xdrs
parameter_list|,
name|portp
parameter_list|)
value|xdr_u_int(xdrs, portp)
else|#
directive|else
define|#
directive|define
name|xdr_rpcvers
parameter_list|(
name|xdrs
parameter_list|,
name|versp
parameter_list|)
value|xdr_u_long(xdrs, versp)
define|#
directive|define
name|xdr_rpcprog
parameter_list|(
name|xdrs
parameter_list|,
name|progp
parameter_list|)
value|xdr_u_long(xdrs, progp)
define|#
directive|define
name|xdr_rpcproc
parameter_list|(
name|xdrs
parameter_list|,
name|procp
parameter_list|)
value|xdr_u_long(xdrs, procp)
define|#
directive|define
name|xdr_rpcprot
parameter_list|(
name|xdrs
parameter_list|,
name|protp
parameter_list|)
value|xdr_u_long(xdrs, protp)
define|#
directive|define
name|xdr_rpcport
parameter_list|(
name|xdrs
parameter_list|,
name|portp
parameter_list|)
value|xdr_u_long(xdrs, portp)
endif|#
directive|endif
struct|struct
name|xdr_discrim
block|{
name|int
name|value
decl_stmt|;
name|xdrproc_t
name|proc
decl_stmt|;
block|}
struct|;
comment|/*  * In-line routines for fast encode/decode of primitve data types.  * Caveat emptor: these use single memory cycles to get the  * data from the underlying buffer, and will fail to operate  * properly if the data is not aligned.  The standard way to use these  * is to say:  *	if ((buf = XDR_INLINE(xdrs, count)) == NULL)  *		return (FALSE);  *<<< macro calls>>>  * where ``count'' is the number of bytes of data occupied  * by the primitive data types.  *  * N.B. and frozen for all time: each data type here uses 4 bytes  * of external representation.  */
define|#
directive|define
name|IXDR_GET_INT32
parameter_list|(
name|buf
parameter_list|)
value|((int32_t)ntohl((uint32_t)*(buf)++))
define|#
directive|define
name|IXDR_PUT_INT32
parameter_list|(
name|buf
parameter_list|,
name|v
parameter_list|)
value|(*(buf)++ = (int32_t)htonl((uint32_t)v))
define|#
directive|define
name|IXDR_GET_U_INT32
parameter_list|(
name|buf
parameter_list|)
value|((uint32_t)IXDR_GET_INT32(buf))
define|#
directive|define
name|IXDR_PUT_U_INT32
parameter_list|(
name|buf
parameter_list|,
name|v
parameter_list|)
value|IXDR_PUT_INT32((buf), ((int32_t)(v)))
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|_LP64
argument_list|)
define|#
directive|define
name|IXDR_GET_LONG
parameter_list|(
name|buf
parameter_list|)
value|((long)ntohl((ulong_t)*(buf)++))
define|#
directive|define
name|IXDR_PUT_LONG
parameter_list|(
name|buf
parameter_list|,
name|v
parameter_list|)
value|(*(buf)++ = (long)htonl((ulong_t)v))
define|#
directive|define
name|IXDR_GET_U_LONG
parameter_list|(
name|buf
parameter_list|)
value|((ulong_t)IXDR_GET_LONG(buf))
define|#
directive|define
name|IXDR_PUT_U_LONG
parameter_list|(
name|buf
parameter_list|,
name|v
parameter_list|)
value|IXDR_PUT_LONG((buf), ((long)(v)))
define|#
directive|define
name|IXDR_GET_BOOL
parameter_list|(
name|buf
parameter_list|)
value|((bool_t)IXDR_GET_LONG(buf))
define|#
directive|define
name|IXDR_GET_ENUM
parameter_list|(
name|buf
parameter_list|,
name|t
parameter_list|)
value|((t)IXDR_GET_LONG(buf))
define|#
directive|define
name|IXDR_GET_SHORT
parameter_list|(
name|buf
parameter_list|)
value|((short)IXDR_GET_LONG(buf))
define|#
directive|define
name|IXDR_GET_U_SHORT
parameter_list|(
name|buf
parameter_list|)
value|((ushort_t)IXDR_GET_LONG(buf))
define|#
directive|define
name|IXDR_PUT_BOOL
parameter_list|(
name|buf
parameter_list|,
name|v
parameter_list|)
value|IXDR_PUT_LONG((buf), ((long)(v)))
define|#
directive|define
name|IXDR_PUT_ENUM
parameter_list|(
name|buf
parameter_list|,
name|v
parameter_list|)
value|IXDR_PUT_LONG((buf), ((long)(v)))
define|#
directive|define
name|IXDR_PUT_SHORT
parameter_list|(
name|buf
parameter_list|,
name|v
parameter_list|)
value|IXDR_PUT_LONG((buf), ((long)(v)))
define|#
directive|define
name|IXDR_PUT_U_SHORT
parameter_list|(
name|buf
parameter_list|,
name|v
parameter_list|)
value|IXDR_PUT_LONG((buf), ((long)(v)))
else|#
directive|else
define|#
directive|define
name|IXDR_GET_BOOL
parameter_list|(
name|buf
parameter_list|)
value|((bool_t)IXDR_GET_INT32(buf))
define|#
directive|define
name|IXDR_GET_ENUM
parameter_list|(
name|buf
parameter_list|,
name|t
parameter_list|)
value|((t)IXDR_GET_INT32(buf))
define|#
directive|define
name|IXDR_GET_SHORT
parameter_list|(
name|buf
parameter_list|)
value|((short)IXDR_GET_INT32(buf))
define|#
directive|define
name|IXDR_GET_U_SHORT
parameter_list|(
name|buf
parameter_list|)
value|((ushort_t)IXDR_GET_INT32(buf))
define|#
directive|define
name|IXDR_PUT_BOOL
parameter_list|(
name|buf
parameter_list|,
name|v
parameter_list|)
value|IXDR_PUT_INT32((buf), ((int)(v)))
define|#
directive|define
name|IXDR_PUT_ENUM
parameter_list|(
name|buf
parameter_list|,
name|v
parameter_list|)
value|IXDR_PUT_INT32((buf), ((int)(v)))
define|#
directive|define
name|IXDR_PUT_SHORT
parameter_list|(
name|buf
parameter_list|,
name|v
parameter_list|)
value|IXDR_PUT_INT32((buf), ((int)(v)))
define|#
directive|define
name|IXDR_PUT_U_SHORT
parameter_list|(
name|buf
parameter_list|,
name|v
parameter_list|)
value|IXDR_PUT_INT32((buf), ((int)(v)))
endif|#
directive|endif
ifndef|#
directive|ifndef
name|_LITTLE_ENDIAN
define|#
directive|define
name|IXDR_GET_HYPER
parameter_list|(
name|buf
parameter_list|,
name|v
parameter_list|)
value|{ \ 			*((int32_t *)(&v)) = ntohl(*(uint32_t *)buf++); \ 			*((int32_t *)(((char *)&v) + BYTES_PER_XDR_UNIT)) \ 			= ntohl(*(uint32_t *)buf++); \ 			}
define|#
directive|define
name|IXDR_PUT_HYPER
parameter_list|(
name|buf
parameter_list|,
name|v
parameter_list|)
value|{ \ 			*(buf)++ = (int32_t)htonl(*(uint32_t *) \ 				((char *)&v)); \ 			*(buf)++ = \ 				(int32_t)htonl(*(uint32_t *)(((char *)&v) \ 				+ BYTES_PER_XDR_UNIT)); \ 			}
else|#
directive|else
define|#
directive|define
name|IXDR_GET_HYPER
parameter_list|(
name|buf
parameter_list|,
name|v
parameter_list|)
value|{ \ 			*((int32_t *)(((char *)&v) + \ 				BYTES_PER_XDR_UNIT)) \ 				= ntohl(*(uint32_t *)buf++); \ 			*((int32_t *)(&v)) = \ 				ntohl(*(uint32_t *)buf++); \ 			}
define|#
directive|define
name|IXDR_PUT_HYPER
parameter_list|(
name|buf
parameter_list|,
name|v
parameter_list|)
value|{ \ 			*(buf)++ = \ 				(int32_t)htonl(*(uint32_t *)(((char *)&v) + \ 				BYTES_PER_XDR_UNIT)); \ 			*(buf)++ = \ 				(int32_t)htonl(*(uint32_t *)((char *)&v)); \ 			}
endif|#
directive|endif
define|#
directive|define
name|IXDR_GET_U_HYPER
parameter_list|(
name|buf
parameter_list|,
name|v
parameter_list|)
value|IXDR_GET_HYPER(buf, v)
define|#
directive|define
name|IXDR_PUT_U_HYPER
parameter_list|(
name|buf
parameter_list|,
name|v
parameter_list|)
value|IXDR_PUT_HYPER(buf, v)
comment|/*  * These are the "generic" xdr routines.  */
ifdef|#
directive|ifdef
name|__STDC__
specifier|extern
name|bool_t
name|xdr_void
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_int
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_u_int
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|uint_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_long
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|long
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_u_long
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|ulong_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_short
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|short
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_u_short
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|ushort_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_bool
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|bool_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_enum
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|enum_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_array
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|caddr_t
modifier|*
parameter_list|,
name|uint_t
modifier|*
parameter_list|,
specifier|const
name|uint_t
parameter_list|,
specifier|const
name|uint_t
parameter_list|,
specifier|const
name|xdrproc_t
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_bytes
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|uint_t
modifier|*
parameter_list|,
specifier|const
name|uint_t
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_opaque
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
specifier|const
name|uint_t
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_string
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
specifier|const
name|uint_t
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_union
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|enum_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
specifier|const
name|struct
name|xdr_discrim
modifier|*
parameter_list|,
specifier|const
name|xdrproc_t
parameter_list|)
function_decl|;
specifier|extern
name|unsigned
name|int
name|xdr_sizeof
parameter_list|(
name|xdrproc_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_hyper
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|longlong_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_longlong_t
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|longlong_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_u_hyper
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|u_longlong_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_u_longlong_t
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|u_longlong_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_char
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_wrapstring
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_reference
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|caddr_t
modifier|*
parameter_list|,
name|uint_t
parameter_list|,
specifier|const
name|xdrproc_t
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_pointer
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|,
name|uint_t
parameter_list|,
specifier|const
name|xdrproc_t
parameter_list|)
function_decl|;
specifier|extern
name|void
name|xdr_free
parameter_list|(
name|xdrproc_t
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_time_t
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|time_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_int8_t
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|int8_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_uint8_t
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_int16_t
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|int16_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_uint16_t
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|uint16_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_int32_t
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|int32_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_uint32_t
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
if|#
directive|if
name|defined
argument_list|(
name|_INT64_TYPE
argument_list|)
specifier|extern
name|bool_t
name|xdr_int64_t
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|int64_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_uint64_t
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|uint64_t
modifier|*
parameter_list|)
function_decl|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|_KERNEL
specifier|extern
name|bool_t
name|xdr_u_char
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|uchar_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_vector
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
specifier|const
name|uint_t
parameter_list|,
specifier|const
name|uint_t
parameter_list|,
specifier|const
name|xdrproc_t
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_float
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|float
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_double
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|double
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_quadruple
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|long
name|double
modifier|*
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* !_KERNEL */
else|#
directive|else
specifier|extern
name|bool_t
name|xdr_void
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_int
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_u_int
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_long
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_u_long
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_short
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_u_short
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_bool
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_enum
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_array
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_bytes
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_opaque
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_string
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_union
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_hyper
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_longlong_t
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_u_hyper
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_u_longlong_t
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_char
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_reference
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_pointer
parameter_list|()
function_decl|;
specifier|extern
name|void
name|xdr_free
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_wrapstring
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_time_t
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_int8_t
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_uint8_t
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_int16_t
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_uint16_t
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_int32_t
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_uint32_t
parameter_list|()
function_decl|;
if|#
directive|if
name|defined
argument_list|(
name|_INT64_TYPE
argument_list|)
specifier|extern
name|bool_t
name|xdr_int64_t
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_uint64_t
parameter_list|()
function_decl|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|_KERNEL
specifier|extern
name|bool_t
name|xdr_u_char
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_vector
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_float
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_double
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdr_quadruple
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|/* !_KERNEL */
endif|#
directive|endif
comment|/*  * Common opaque bytes objects used by many rpc protocols;  * declared here due to commonality.  */
define|#
directive|define
name|MAX_NETOBJ_SZ
value|1024
struct|struct
name|netobj
block|{
name|uint_t
name|n_len
decl_stmt|;
name|char
modifier|*
name|n_bytes
decl_stmt|;
block|}
struct|;
typedef|typedef
name|struct
name|netobj
name|netobj
typedef|;
ifdef|#
directive|ifdef
name|__STDC__
specifier|extern
name|bool_t
name|xdr_netobj
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|netobj
modifier|*
parameter_list|)
function_decl|;
else|#
directive|else
specifier|extern
name|bool_t
name|xdr_netobj
parameter_list|()
function_decl|;
endif|#
directive|endif
comment|/*  * These are XDR control operators  */
define|#
directive|define
name|XDR_GET_BYTES_AVAIL
value|1
struct|struct
name|xdr_bytesrec
block|{
name|bool_t
name|xc_is_last_record
decl_stmt|;
name|size_t
name|xc_num_avail
decl_stmt|;
block|}
struct|;
typedef|typedef
name|struct
name|xdr_bytesrec
name|xdr_bytesrec
typedef|;
comment|/*  * These are the request arguments to XDR_CONTROL.  *  * XDR_PEEK - returns the contents of the next XDR unit on the XDR stream.  * XDR_SKIPBYTES - skips the next N bytes in the XDR stream.  * XDR_RDMAGET - for xdr implementation over RDMA, gets private flags from  *		 the XDR stream being moved over RDMA  * XDR_RDMANOCHUNK - for xdr implementaion over RDMA, sets private flags in  *                   the XDR stream moving over RDMA.  */
ifdef|#
directive|ifdef
name|_KERNEL
define|#
directive|define
name|XDR_PEEK
value|2
define|#
directive|define
name|XDR_SKIPBYTES
value|3
define|#
directive|define
name|XDR_RDMAGET
value|4
define|#
directive|define
name|XDR_RDMASET
value|5
endif|#
directive|endif
comment|/*  * These are the public routines for the various implementations of  * xdr streams.  */
ifndef|#
directive|ifndef
name|_KERNEL
ifdef|#
directive|ifdef
name|__STDC__
specifier|extern
name|void
name|xdrmem_create
parameter_list|(
name|XDR
modifier|*
parameter_list|,
specifier|const
name|caddr_t
parameter_list|,
specifier|const
name|uint_t
parameter_list|,
specifier|const
name|enum
name|xdr_op
parameter_list|)
function_decl|;
comment|/* XDR using memory buffers */
specifier|extern
name|void
name|xdrrec_create
parameter_list|(
name|XDR
modifier|*
parameter_list|,
specifier|const
name|uint_t
parameter_list|,
specifier|const
name|uint_t
parameter_list|,
specifier|const
name|caddr_t
parameter_list|,
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|)
parameter_list|)
function_decl|;
comment|/* XDR pseudo records for tcp */
specifier|extern
name|bool_t
name|xdrrec_endofrecord
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|bool_t
parameter_list|)
function_decl|;
comment|/* make end of xdr record */
specifier|extern
name|bool_t
name|xdrrec_skiprecord
parameter_list|(
name|XDR
modifier|*
parameter_list|)
function_decl|;
comment|/* move to beginning of next record */
specifier|extern
name|bool_t
name|xdrrec_eof
parameter_list|(
name|XDR
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|uint_t
name|xdrrec_readbytes
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|uint_t
parameter_list|)
function_decl|;
comment|/* true if no more input */
else|#
directive|else
specifier|extern
name|void
name|xdrmem_create
parameter_list|()
function_decl|;
specifier|extern
name|void
name|xdrstdio_create
parameter_list|()
function_decl|;
specifier|extern
name|void
name|xdrrec_create
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdrrec_endofrecord
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdrrec_skiprecord
parameter_list|()
function_decl|;
specifier|extern
name|bool_t
name|xdrrec_eof
parameter_list|()
function_decl|;
specifier|extern
name|uint_t
name|xdrrec_readbytes
parameter_list|()
function_decl|;
endif|#
directive|endif
else|#
directive|else
specifier|extern
name|void
name|xdrmem_create
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|uint_t
parameter_list|,
name|enum
name|xdr_op
parameter_list|)
function_decl|;
specifier|extern
name|struct
name|xdr_ops
name|xdrmblk_ops
decl_stmt|;
struct_decl|struct
name|rpc_msg
struct_decl|;
specifier|extern
name|bool_t
name|xdr_callmsg
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|struct
name|rpc_msg
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_replymsg_body
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|struct
name|rpc_msg
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|bool_t
name|xdr_replymsg_hdr
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|struct
name|rpc_msg
modifier|*
parameter_list|)
function_decl|;
include|#
directive|include
file|<sys/malloc.h>
ifdef|#
directive|ifdef
name|mem_alloc
undef|#
directive|undef
name|mem_alloc
define|#
directive|define
name|mem_alloc
parameter_list|(
name|size
parameter_list|)
value|malloc((size), M_TEMP, M_WAITOK | M_ZERO)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|mem_free
undef|#
directive|undef
name|mem_free
define|#
directive|define
name|mem_free
parameter_list|(
name|ptr
parameter_list|,
name|size
parameter_list|)
value|free((ptr), M_TEMP)
endif|#
directive|endif
endif|#
directive|endif
comment|/* !_KERNEL */
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !_RPC_XDR_H */
end_comment

end_unit

