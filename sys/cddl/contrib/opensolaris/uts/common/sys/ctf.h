begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License, Version 1.0 only  * (the "License").  You may not use this file except in compliance  * with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2004 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_CTF_H
end_ifndef

begin_define
define|#
directive|define
name|_CTF_H
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|illumos
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/*  * CTF - Compact ANSI-C Type Format  *  * This file format can be used to compactly represent the information needed  * by a debugger to interpret the ANSI-C types used by a given program.  * Traditionally, this kind of information is generated by the compiler when  * invoked with the -g flag and is stored in "stabs" strings or in the more  * modern DWARF format.  CTF provides a representation of only the information  * that is relevant to debugging a complex, optimized C program such as the  * operating system kernel in a form that is significantly more compact than  * the equivalent stabs or DWARF representation.  The format is data-model  * independent, so consumers do not need different code depending on whether  * they are 32-bit or 64-bit programs.  CTF assumes that a standard ELF symbol  * table is available for use in the debugger, and uses the structure and data  * of the symbol table to avoid storing redundant information.  The CTF data  * may be compressed on disk or in memory, indicated by a bit in the header.  * CTF may be interpreted in a raw disk file, or it may be stored in an ELF  * section, typically named .SUNW_ctf.  Data structures are aligned so that  * a raw CTF file or CTF ELF section may be manipulated using mmap(2).  *  * The CTF file or section itself has the following structure:  *  * +--------+--------+---------+----------+-------+--------+  * |  file  |  type  |  data   | function | data  | string |  * | header | labels | objects |   info   | types | table  |  * +--------+--------+---------+----------+-------+--------+  *  * The file header stores a magic number and version information, encoding  * flags, and the byte offset of each of the sections relative to the end of the  * header itself.  If the CTF data has been uniquified against another set of  * CTF data, a reference to that data also appears in the the header.  This  * reference is the name of the label corresponding to the types uniquified  * against.  *  * Following the header is a list of labels, used to group the types included in  * the data types section.  Each label is accompanied by a type ID i.  A given  * label refers to the group of types whose IDs are in the range [0, i].  *  * Data object and function records are stored in the same order as they appear  * in the corresponding symbol table, except that symbols marked SHN_UNDEF are  * not stored and symbols that have no type data are padded out with zeroes.  * For each data object, the type ID (a small integer) is recorded.  For each  * function, the type ID of the return type and argument types is recorded.  *  * The data types section is a list of variable size records that represent each  * type, in order by their ID.  The types themselves form a directed graph,  * where each node may contain one or more outgoing edges to other type nodes,  * denoted by their ID.  *  * Strings are recorded as a string table ID (0 or 1) and a byte offset into the  * string table.  String table 0 is the internal CTF string table.  String table  * 1 is the external string table, which is the string table associated with the  * ELF symbol table for this object.  CTF does not record any strings that are  * already in the symbol table, and the CTF string table does not contain any  * duplicated strings.  *  * If the CTF data has been merged with another parent CTF object, some outgoing  * edges may refer to type nodes that exist in another CTF object.  The debugger  * and libctf library are responsible for connecting the appropriate objects  * together so that the full set of types can be explored and manipulated.  */
define|#
directive|define
name|CTF_MAX_TYPE
value|0xffff
comment|/* max type identifier value */
define|#
directive|define
name|CTF_MAX_NAME
value|0x7fffffff
comment|/* max offset into a string table */
define|#
directive|define
name|CTF_MAX_VLEN
value|0x3ff
comment|/* max struct, union, enum members or args */
define|#
directive|define
name|CTF_MAX_INTOFF
value|0xff
comment|/* max offset of intrinsic value in bits */
define|#
directive|define
name|CTF_MAX_INTBITS
value|0xffff
comment|/* max size of an intrinsic in bits */
comment|/* See ctf_type_t */
define|#
directive|define
name|CTF_MAX_SIZE
value|0xfffe
comment|/* max size of a type in bytes */
define|#
directive|define
name|CTF_LSIZE_SENT
value|0xffff
comment|/* sentinel for ctt_size */
define|#
directive|define
name|CTF_MAX_LSIZE
value|UINT64_MAX
typedef|typedef
struct|struct
name|ctf_preamble
block|{
name|ushort_t
name|ctp_magic
decl_stmt|;
comment|/* magic number (CTF_MAGIC) */
name|uchar_t
name|ctp_version
decl_stmt|;
comment|/* data format version number (CTF_VERSION) */
name|uchar_t
name|ctp_flags
decl_stmt|;
comment|/* flags (see below) */
block|}
name|ctf_preamble_t
typedef|;
typedef|typedef
struct|struct
name|ctf_header
block|{
name|ctf_preamble_t
name|cth_preamble
decl_stmt|;
name|uint_t
name|cth_parlabel
decl_stmt|;
comment|/* ref to name of parent lbl uniq'd against */
name|uint_t
name|cth_parname
decl_stmt|;
comment|/* ref to basename of parent */
name|uint_t
name|cth_lbloff
decl_stmt|;
comment|/* offset of label section */
name|uint_t
name|cth_objtoff
decl_stmt|;
comment|/* offset of object section */
name|uint_t
name|cth_funcoff
decl_stmt|;
comment|/* offset of function section */
name|uint_t
name|cth_typeoff
decl_stmt|;
comment|/* offset of type section */
name|uint_t
name|cth_stroff
decl_stmt|;
comment|/* offset of string section */
name|uint_t
name|cth_strlen
decl_stmt|;
comment|/* length of string section in bytes */
block|}
name|ctf_header_t
typedef|;
define|#
directive|define
name|cth_magic
value|cth_preamble.ctp_magic
define|#
directive|define
name|cth_version
value|cth_preamble.ctp_version
define|#
directive|define
name|cth_flags
value|cth_preamble.ctp_flags
ifdef|#
directive|ifdef
name|CTF_OLD_VERSIONS
typedef|typedef
struct|struct
name|ctf_header_v1
block|{
name|ctf_preamble_t
name|cth_preamble
decl_stmt|;
name|uint_t
name|cth_objtoff
decl_stmt|;
name|uint_t
name|cth_funcoff
decl_stmt|;
name|uint_t
name|cth_typeoff
decl_stmt|;
name|uint_t
name|cth_stroff
decl_stmt|;
name|uint_t
name|cth_strlen
decl_stmt|;
block|}
name|ctf_header_v1_t
typedef|;
endif|#
directive|endif
comment|/* CTF_OLD_VERSIONS */
define|#
directive|define
name|CTF_MAGIC
value|0xcff1
comment|/* magic number identifying header */
comment|/* data format version number */
define|#
directive|define
name|CTF_VERSION_1
value|1
define|#
directive|define
name|CTF_VERSION_2
value|2
define|#
directive|define
name|CTF_VERSION
value|CTF_VERSION_2
comment|/* current version */
define|#
directive|define
name|CTF_F_COMPRESS
value|0x1
comment|/* data buffer is compressed */
typedef|typedef
struct|struct
name|ctf_lblent
block|{
name|uint_t
name|ctl_label
decl_stmt|;
comment|/* ref to name of label */
name|uint_t
name|ctl_typeidx
decl_stmt|;
comment|/* last type associated with this label */
block|}
name|ctf_lblent_t
typedef|;
typedef|typedef
struct|struct
name|ctf_stype
block|{
name|uint_t
name|ctt_name
decl_stmt|;
comment|/* reference to name in string table */
name|ushort_t
name|ctt_info
decl_stmt|;
comment|/* encoded kind, variant length (see below) */
union|union
block|{
name|ushort_t
name|_size
decl_stmt|;
comment|/* size of entire type in bytes */
name|ushort_t
name|_type
decl_stmt|;
comment|/* reference to another type */
block|}
name|_u
union|;
block|}
name|ctf_stype_t
typedef|;
comment|/*  * type sizes, measured in bytes, come in two flavors.  99% of them fit within  * (USHRT_MAX - 1), and thus can be stored in the ctt_size member of a  * ctf_stype_t.  The maximum value for these sizes is CTF_MAX_SIZE.  The sizes  * larger than CTF_MAX_SIZE must be stored in the ctt_lsize member of a  * ctf_type_t.  Use of this member is indicated by the presence of  * CTF_LSIZE_SENT in ctt_size.  */
typedef|typedef
struct|struct
name|ctf_type
block|{
name|uint_t
name|ctt_name
decl_stmt|;
comment|/* reference to name in string table */
name|ushort_t
name|ctt_info
decl_stmt|;
comment|/* encoded kind, variant length (see below) */
union|union
block|{
name|ushort_t
name|_size
decl_stmt|;
comment|/* always CTF_LSIZE_SENT */
name|ushort_t
name|_type
decl_stmt|;
comment|/* do not use */
block|}
name|_u
union|;
name|uint_t
name|ctt_lsizehi
decl_stmt|;
comment|/* high 32 bits of type size in bytes */
name|uint_t
name|ctt_lsizelo
decl_stmt|;
comment|/* low 32 bits of type size in bytes */
block|}
name|ctf_type_t
typedef|;
define|#
directive|define
name|ctt_size
value|_u._size
comment|/* for fundamental types that have a size */
define|#
directive|define
name|ctt_type
value|_u._type
comment|/* for types that reference another type */
comment|/*  * The following macros compose and decompose values for ctt_info and  * ctt_name, as well as other structures that contain name references.  *  *             ------------------------  * ctt_info:   | kind | isroot | vlen |  *             ------------------------  *             15   11    10    9     0  *  * kind = CTF_INFO_KIND(c.ctt_info);<-- CTF_K_* value (see below)  * vlen = CTF_INFO_VLEN(c.ctt_info);<-- length of variable data list  *  * stid = CTF_NAME_STID(c.ctt_name);<-- string table id number (0 or 1)  * offset = CTF_NAME_OFFSET(c.ctt_name);<-- string table byte offset  *  * c.ctt_info = CTF_TYPE_INFO(kind, vlen);  * c.ctt_name = CTF_TYPE_NAME(stid, offset);  */
define|#
directive|define
name|CTF_INFO_KIND
parameter_list|(
name|info
parameter_list|)
value|(((info)& 0xf800)>> 11)
define|#
directive|define
name|CTF_INFO_ISROOT
parameter_list|(
name|info
parameter_list|)
value|(((info)& 0x0400)>> 10)
define|#
directive|define
name|CTF_INFO_VLEN
parameter_list|(
name|info
parameter_list|)
value|(((info)& CTF_MAX_VLEN))
define|#
directive|define
name|CTF_NAME_STID
parameter_list|(
name|name
parameter_list|)
value|((name)>> 31)
define|#
directive|define
name|CTF_NAME_OFFSET
parameter_list|(
name|name
parameter_list|)
value|((name)& 0x7fffffff)
define|#
directive|define
name|CTF_TYPE_INFO
parameter_list|(
name|kind
parameter_list|,
name|isroot
parameter_list|,
name|vlen
parameter_list|)
define|\
value|(((kind)<< 11) | (((isroot) ? 1 : 0)<< 10) | ((vlen)& CTF_MAX_VLEN))
define|#
directive|define
name|CTF_TYPE_NAME
parameter_list|(
name|stid
parameter_list|,
name|offset
parameter_list|)
define|\
value|(((stid)<< 31) | ((offset)& 0x7fffffff))
define|#
directive|define
name|CTF_TYPE_ISPARENT
parameter_list|(
name|id
parameter_list|)
value|((id)< 0x8000)
define|#
directive|define
name|CTF_TYPE_ISCHILD
parameter_list|(
name|id
parameter_list|)
value|((id)> 0x7fff)
define|#
directive|define
name|CTF_TYPE_TO_INDEX
parameter_list|(
name|id
parameter_list|)
value|((id)& 0x7fff)
define|#
directive|define
name|CTF_INDEX_TO_TYPE
parameter_list|(
name|id
parameter_list|,
name|child
parameter_list|)
value|((child) ? ((id) | 0x8000) : (id))
define|#
directive|define
name|CTF_PARENT_SHIFT
value|15
define|#
directive|define
name|CTF_STRTAB_0
value|0
comment|/* symbolic define for string table id 0 */
define|#
directive|define
name|CTF_STRTAB_1
value|1
comment|/* symbolic define for string table id 1 */
define|#
directive|define
name|CTF_TYPE_LSIZE
parameter_list|(
name|cttp
parameter_list|)
define|\
value|(((uint64_t)(cttp)->ctt_lsizehi)<< 32 | (cttp)->ctt_lsizelo)
define|#
directive|define
name|CTF_SIZE_TO_LSIZE_HI
parameter_list|(
name|size
parameter_list|)
value|((uint32_t)((uint64_t)(size)>> 32))
define|#
directive|define
name|CTF_SIZE_TO_LSIZE_LO
parameter_list|(
name|size
parameter_list|)
value|((uint32_t)(size))
ifdef|#
directive|ifdef
name|CTF_OLD_VERSIONS
define|#
directive|define
name|CTF_INFO_KIND_V1
parameter_list|(
name|info
parameter_list|)
value|(((info)& 0xf000)>> 12)
define|#
directive|define
name|CTF_INFO_ISROOT_V1
parameter_list|(
name|info
parameter_list|)
value|(((info)& 0x0800)>> 11)
define|#
directive|define
name|CTF_INFO_VLEN_V1
parameter_list|(
name|info
parameter_list|)
value|(((info)& 0x07ff))
define|#
directive|define
name|CTF_TYPE_INFO_V1
parameter_list|(
name|kind
parameter_list|,
name|isroot
parameter_list|,
name|vlen
parameter_list|)
define|\
value|(((kind)<< 12) | (((isroot) ? 1 : 0)<< 11) | ((vlen)& 0x07ff))
endif|#
directive|endif
comment|/* CTF_OLD_VERSIONS */
comment|/*  * Values for CTF_TYPE_KIND().  If the kind has an associated data list,  * CTF_INFO_VLEN() will extract the number of elements in the list, and  * the type of each element is shown in the comments below.  */
define|#
directive|define
name|CTF_K_UNKNOWN
value|0
comment|/* unknown type (used for padding) */
define|#
directive|define
name|CTF_K_INTEGER
value|1
comment|/* variant data is CTF_INT_DATA() (see below) */
define|#
directive|define
name|CTF_K_FLOAT
value|2
comment|/* variant data is CTF_FP_DATA() (see below) */
define|#
directive|define
name|CTF_K_POINTER
value|3
comment|/* ctt_type is referenced type */
define|#
directive|define
name|CTF_K_ARRAY
value|4
comment|/* variant data is single ctf_array_t */
define|#
directive|define
name|CTF_K_FUNCTION
value|5
comment|/* ctt_type is return type, variant data is */
comment|/* list of argument types (ushort_t's) */
define|#
directive|define
name|CTF_K_STRUCT
value|6
comment|/* variant data is list of ctf_member_t's */
define|#
directive|define
name|CTF_K_UNION
value|7
comment|/* variant data is list of ctf_member_t's */
define|#
directive|define
name|CTF_K_ENUM
value|8
comment|/* variant data is list of ctf_enum_t's */
define|#
directive|define
name|CTF_K_FORWARD
value|9
comment|/* no additional data; ctt_name is tag */
define|#
directive|define
name|CTF_K_TYPEDEF
value|10
comment|/* ctt_type is referenced type */
define|#
directive|define
name|CTF_K_VOLATILE
value|11
comment|/* ctt_type is base type */
define|#
directive|define
name|CTF_K_CONST
value|12
comment|/* ctt_type is base type */
define|#
directive|define
name|CTF_K_RESTRICT
value|13
comment|/* ctt_type is base type */
define|#
directive|define
name|CTF_K_MAX
value|31
comment|/* Maximum possible CTF_K_* value */
comment|/*  * Values for ctt_type when kind is CTF_K_INTEGER.  The flags, offset in bits,  * and size in bits are encoded as a single word using the following macros.  */
define|#
directive|define
name|CTF_INT_ENCODING
parameter_list|(
name|data
parameter_list|)
value|(((data)& 0xff000000)>> 24)
define|#
directive|define
name|CTF_INT_OFFSET
parameter_list|(
name|data
parameter_list|)
value|(((data)& 0x00ff0000)>> 16)
define|#
directive|define
name|CTF_INT_BITS
parameter_list|(
name|data
parameter_list|)
value|(((data)& 0x0000ffff))
define|#
directive|define
name|CTF_INT_DATA
parameter_list|(
name|encoding
parameter_list|,
name|offset
parameter_list|,
name|bits
parameter_list|)
define|\
value|(((encoding)<< 24) | ((offset)<< 16) | (bits))
define|#
directive|define
name|CTF_INT_SIGNED
value|0x01
comment|/* integer is signed (otherwise unsigned) */
define|#
directive|define
name|CTF_INT_CHAR
value|0x02
comment|/* character display format */
define|#
directive|define
name|CTF_INT_BOOL
value|0x04
comment|/* boolean display format */
define|#
directive|define
name|CTF_INT_VARARGS
value|0x08
comment|/* varargs display format */
comment|/*  * Values for ctt_type when kind is CTF_K_FLOAT.  The encoding, offset in bits,  * and size in bits are encoded as a single word using the following macros.  */
define|#
directive|define
name|CTF_FP_ENCODING
parameter_list|(
name|data
parameter_list|)
value|(((data)& 0xff000000)>> 24)
define|#
directive|define
name|CTF_FP_OFFSET
parameter_list|(
name|data
parameter_list|)
value|(((data)& 0x00ff0000)>> 16)
define|#
directive|define
name|CTF_FP_BITS
parameter_list|(
name|data
parameter_list|)
value|(((data)& 0x0000ffff))
define|#
directive|define
name|CTF_FP_DATA
parameter_list|(
name|encoding
parameter_list|,
name|offset
parameter_list|,
name|bits
parameter_list|)
define|\
value|(((encoding)<< 24) | ((offset)<< 16) | (bits))
define|#
directive|define
name|CTF_FP_SINGLE
value|1
comment|/* IEEE 32-bit float encoding */
define|#
directive|define
name|CTF_FP_DOUBLE
value|2
comment|/* IEEE 64-bit float encoding */
define|#
directive|define
name|CTF_FP_CPLX
value|3
comment|/* Complex encoding */
define|#
directive|define
name|CTF_FP_DCPLX
value|4
comment|/* Double complex encoding */
define|#
directive|define
name|CTF_FP_LDCPLX
value|5
comment|/* Long double complex encoding */
define|#
directive|define
name|CTF_FP_LDOUBLE
value|6
comment|/* Long double encoding */
define|#
directive|define
name|CTF_FP_INTRVL
value|7
comment|/* Interval (2x32-bit) encoding */
define|#
directive|define
name|CTF_FP_DINTRVL
value|8
comment|/* Double interval (2x64-bit) encoding */
define|#
directive|define
name|CTF_FP_LDINTRVL
value|9
comment|/* Long double interval (2x128-bit) encoding */
define|#
directive|define
name|CTF_FP_IMAGRY
value|10
comment|/* Imaginary (32-bit) encoding */
define|#
directive|define
name|CTF_FP_DIMAGRY
value|11
comment|/* Long imaginary (64-bit) encoding */
define|#
directive|define
name|CTF_FP_LDIMAGRY
value|12
comment|/* Long double imaginary (128-bit) encoding */
define|#
directive|define
name|CTF_FP_MAX
value|12
comment|/* Maximum possible CTF_FP_* value */
typedef|typedef
struct|struct
name|ctf_array
block|{
name|ushort_t
name|cta_contents
decl_stmt|;
comment|/* reference to type of array contents */
name|ushort_t
name|cta_index
decl_stmt|;
comment|/* reference to type of array index */
name|uint_t
name|cta_nelems
decl_stmt|;
comment|/* number of elements */
block|}
name|ctf_array_t
typedef|;
comment|/*  * Most structure members have bit offsets that can be expressed using a  * short.  Some don't.  ctf_member_t is used for structs which cannot  * contain any of these large offsets, whereas ctf_lmember_t is used in the  * latter case.  If ctt_size for a given struct is>= 8192 bytes, all members  * will be stored as type ctf_lmember_t.  */
define|#
directive|define
name|CTF_LSTRUCT_THRESH
value|8192
typedef|typedef
struct|struct
name|ctf_member
block|{
name|uint_t
name|ctm_name
decl_stmt|;
comment|/* reference to name in string table */
name|ushort_t
name|ctm_type
decl_stmt|;
comment|/* reference to type of member */
name|ushort_t
name|ctm_offset
decl_stmt|;
comment|/* offset of this member in bits */
block|}
name|ctf_member_t
typedef|;
typedef|typedef
struct|struct
name|ctf_lmember
block|{
name|uint_t
name|ctlm_name
decl_stmt|;
comment|/* reference to name in string table */
name|ushort_t
name|ctlm_type
decl_stmt|;
comment|/* reference to type of member */
name|ushort_t
name|ctlm_pad
decl_stmt|;
comment|/* padding */
name|uint_t
name|ctlm_offsethi
decl_stmt|;
comment|/* high 32 bits of member offset in bits */
name|uint_t
name|ctlm_offsetlo
decl_stmt|;
comment|/* low 32 bits of member offset in bits */
block|}
name|ctf_lmember_t
typedef|;
define|#
directive|define
name|CTF_LMEM_OFFSET
parameter_list|(
name|ctlmp
parameter_list|)
define|\
value|(((uint64_t)(ctlmp)->ctlm_offsethi)<< 32 | (ctlmp)->ctlm_offsetlo)
define|#
directive|define
name|CTF_OFFSET_TO_LMEMHI
parameter_list|(
name|offset
parameter_list|)
value|((uint32_t)((uint64_t)(offset)>> 32))
define|#
directive|define
name|CTF_OFFSET_TO_LMEMLO
parameter_list|(
name|offset
parameter_list|)
value|((uint32_t)(offset))
typedef|typedef
struct|struct
name|ctf_enum
block|{
name|uint_t
name|cte_name
decl_stmt|;
comment|/* reference to name in string table */
name|int
name|cte_value
decl_stmt|;
comment|/* value associated with this name */
block|}
name|ctf_enum_t
typedef|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _CTF_H */
end_comment

end_unit

