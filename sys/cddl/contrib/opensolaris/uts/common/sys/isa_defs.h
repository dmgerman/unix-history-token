begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_ISA_DEFS_H
end_ifndef

begin_define
define|#
directive|define
name|_SYS_ISA_DEFS_H
end_define

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*  * This header file serves to group a set of well known defines and to  * set these for each instruction set architecture.  These defines may  * be divided into two groups;  characteristics of the processor and  * implementation choices for Solaris on a processor.  *  * Processor Characteristics:  *  * _LITTLE_ENDIAN / _BIG_ENDIAN:  *	The natural byte order of the processor.  A pointer to an int points  *	to the least/most significant byte of that int.  *  * _STACK_GROWS_UPWARD / _STACK_GROWS_DOWNWARD:  *	The processor specific direction of stack growth.  A push onto the  *	stack increases/decreases the stack pointer, so it stores data at  *	successively higher/lower addresses.  (Stackless machines ignored  *	without regrets).  *  * _LONG_LONG_HTOL / _LONG_LONG_LTOH:  *	A pointer to a long long points to the most/least significant long  *	within that long long.  *  * _BIT_FIELDS_HTOL / _BIT_FIELDS_LTOH:  *	The C compiler assigns bit fields from the high/low to the low/high end  *	of an int (most to least significant vs. least to most significant).  *  * _IEEE_754:  *	The processor (or supported implementations of the processor)  *	supports the ieee-754 floating point standard.  No other floating  *	point standards are supported (or significant).  Any other supported  *	floating point formats are expected to be cased on the ISA processor  *	symbol.  *  * _CHAR_IS_UNSIGNED / _CHAR_IS_SIGNED:  *	The C Compiler implements objects of type `char' as `unsigned' or  *	`signed' respectively.  This is really an implementation choice of  *	the compiler writer, but it is specified in the ABI and tends to  *	be uniform across compilers for an instruction set architecture.  *	Hence, it has the properties of a processor characteristic.  *  * _CHAR_ALIGNMENT / _SHORT_ALIGNMENT / _INT_ALIGNMENT / _LONG_ALIGNMENT /  * _LONG_LONG_ALIGNMENT / _DOUBLE_ALIGNMENT / _LONG_DOUBLE_ALIGNMENT /  * _POINTER_ALIGNMENT / _FLOAT_ALIGNMENT:  *	The ABI defines alignment requirements of each of the primitive  *	object types.  Some, if not all, may be hardware requirements as  * 	well.  The values are expressed in "byte-alignment" units.  *  * _MAX_ALIGNMENT:  *	The most stringent alignment requirement as specified by the ABI.  *	Equal to the maximum of all the above _XXX_ALIGNMENT values.  *  * _ALIGNMENT_REQUIRED:  *	True or false (1 or 0) whether or not the hardware requires the ABI  *	alignment.  *  * _LONG_LONG_ALIGNMENT_32  *	The 32-bit ABI supported by a 64-bit kernel may have different  *	alignment requirements for primitive object types.  The value of this  *	identifier is expressed in "byte-alignment" units.  *  * _HAVE_CPUID_INSN  *	This indicates that the architecture supports the 'cpuid'  *	instruction as defined by Intel.  (Intel allows other vendors  *	to extend the instruction for their own purposes.)  *  *  * Implementation Choices:  *  * _ILP32 / _LP64:  *	This specifies the compiler data type implementation as specified in  *	the relevant ABI.  The choice between these is strongly influenced  *	by the underlying hardware, but is not absolutely tied to it.  *	Currently only two data type models are supported:  *  *	_ILP32:  *		Int/Long/Pointer are 32 bits.  This is the historical UNIX  *		and Solaris implementation.  Due to its historical standing,  *		this is the default case.  *  *	_LP64:  *		Long/Pointer are 64 bits, Int is 32 bits.  This is the chosen  *		implementation for 64-bit ABIs such as SPARC V9.  *  *	_I32LPx:  *		A compilation environment where 'int' is 32-bit, and  *		longs and pointers are simply the same size.  *  *	In all cases, Char is 8 bits and Short is 16 bits.  *  * _SUNOS_VTOC_8 / _SUNOS_VTOC_16 / _SVR4_VTOC_16:  *	This specifies the form of the disk VTOC (or label):  *  *	_SUNOS_VTOC_8:  *		This is a VTOC form which is upwardly compatible with the  *		SunOS 4.x disk label and allows 8 partitions per disk.  *  *	_SUNOS_VTOC_16:  *		In this format the incore vtoc image matches the ondisk  *		version.  It allows 16 slices per disk, and is not  *		compatible with the SunOS 4.x disk label.  *  *	Note that these are not the only two VTOC forms possible and  *	additional forms may be added.  One possible form would be the  *	SVr4 VTOC form.  The symbol for that is reserved now, although  *	it is not implemented.  *  *	_SVR4_VTOC_16:  *		This VTOC form is compatible with the System V Release 4  *		VTOC (as implemented on the SVr4 Intel and 3b ports) with  *		16 partitions per disk.  *  *  * _DMA_USES_PHYSADDR / _DMA_USES_VIRTADDR  *	This describes the type of addresses used by system DMA:  *  *	_DMA_USES_PHYSADDR:  *		This type of DMA, used in the x86 implementation,  *		requires physical addresses for DMA buffers.  The 24-bit  *		addresses used by some legacy boards is the source of the  *		"low-memory" (<16MB) requirement for some devices using DMA.  *  *	_DMA_USES_VIRTADDR:  *		This method of DMA allows the use of virtual addresses for  *		DMA transfers.  *  * _FIRMWARE_NEEDS_FDISK / _NO_FDISK_PRESENT  *      This indicates the presence/absence of an fdisk table.  *  *      _FIRMWARE_NEEDS_FDISK  *              The fdisk table is required by system firmware.  If present,  *              it allows a disk to be subdivided into multiple fdisk  *              partitions, each of which is equivalent to a separate,  *              virtual disk.  This enables the co-existence of multiple  *              operating systems on a shared hard disk.  *  *      _NO_FDISK_PRESENT  *              If the fdisk table is absent, it is assumed that the entire  *              media is allocated for a single operating system.  *  * _HAVE_TEM_FIRMWARE  *	Defined if this architecture has the (fallback) option of  *	using prom_* calls for doing I/O if a suitable kernel driver  *	is not available to do it.  *  * _DONT_USE_1275_GENERIC_NAMES  *		Controls whether or not device tree node names should  *		comply with the IEEE 1275 "Generic Names" Recommended  *		Practice. With _DONT_USE_GENERIC_NAMES, device-specific  *		names identifying the particular device will be used.  *  * __i386_COMPAT  *	This indicates whether the i386 ABI is supported as a *non-native*  *	mode for the platform.  When this symbol is defined:  *	-	32-bit xstat-style system calls are enabled  *	-	32-bit xmknod-style system calls are enabled  *	-	32-bit system calls use i386 sizes -and- alignments  *  *	Note that this is NOT defined for the i386 native environment!  *  * __x86  *	This is ONLY a synonym for defined(__i386) || defined(__amd64)  *	which is useful only insofar as these two architectures share  *	common attributes.  Analogous to __sparc.  *  * _PSM_MODULES  *	This indicates whether or not the implementation uses PSM  *	modules for processor support, reading /etc/mach from inside  *	the kernel to extract a list.  *  * _RTC_CONFIG  *	This indicates whether or not the implementation uses /etc/rtc_config  *	to configure the real-time clock in the kernel.  *  * _UNIX_KRTLD  *	This indicates that the implementation uses a dynamically  *	linked unix + krtld to form the core kernel image at boot  *	time, or (in the absence of this symbol) a prelinked kernel image.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/*  * The following set of definitions characterize Solaris on AMD's  * 64-bit systems.  */
if|#
directive|if
name|defined
argument_list|(
name|__x86_64
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__amd64
argument_list|)
define|#
directive|define
name|__amd64
comment|/* preferred guard */
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__x86
argument_list|)
define|#
directive|define
name|__x86
endif|#
directive|endif
comment|/*  * Define the appropriate "processor characteristics"  */
define|#
directive|define
name|_LITTLE_ENDIAN
define|#
directive|define
name|_STACK_GROWS_DOWNWARD
define|#
directive|define
name|_LONG_LONG_LTOH
define|#
directive|define
name|_BIT_FIELDS_LTOH
define|#
directive|define
name|_IEEE_754
define|#
directive|define
name|_CHAR_IS_SIGNED
define|#
directive|define
name|_BOOL_ALIGNMENT
value|1
define|#
directive|define
name|_CHAR_ALIGNMENT
value|1
define|#
directive|define
name|_SHORT_ALIGNMENT
value|2
define|#
directive|define
name|_INT_ALIGNMENT
value|4
define|#
directive|define
name|_FLOAT_ALIGNMENT
value|4
define|#
directive|define
name|_FLOAT_COMPLEX_ALIGNMENT
value|4
define|#
directive|define
name|_LONG_ALIGNMENT
value|8
define|#
directive|define
name|_LONG_LONG_ALIGNMENT
value|8
define|#
directive|define
name|_DOUBLE_ALIGNMENT
value|8
define|#
directive|define
name|_DOUBLE_COMPLEX_ALIGNMENT
value|8
define|#
directive|define
name|_LONG_DOUBLE_ALIGNMENT
value|16
define|#
directive|define
name|_LONG_DOUBLE_COMPLEX_ALIGNMENT
value|16
define|#
directive|define
name|_POINTER_ALIGNMENT
value|8
define|#
directive|define
name|_MAX_ALIGNMENT
value|16
define|#
directive|define
name|_ALIGNMENT_REQUIRED
value|1
comment|/*  * Different alignment constraints for the i386 ABI in compatibility mode  */
define|#
directive|define
name|_LONG_LONG_ALIGNMENT_32
value|4
comment|/*  * Define the appropriate "implementation choices".  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_LP64
argument_list|)
define|#
directive|define
name|_LP64
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_I32LPx
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
define|#
directive|define
name|_I32LPx
endif|#
directive|endif
define|#
directive|define
name|_MULTI_DATAMODEL
define|#
directive|define
name|_SUNOS_VTOC_16
define|#
directive|define
name|_DMA_USES_PHYSADDR
define|#
directive|define
name|_FIRMWARE_NEEDS_FDISK
define|#
directive|define
name|__i386_COMPAT
define|#
directive|define
name|_PSM_MODULES
define|#
directive|define
name|_RTC_CONFIG
define|#
directive|define
name|_DONT_USE_1275_GENERIC_NAMES
define|#
directive|define
name|_HAVE_CPUID_INSN
comment|/*  * The feature test macro __i386 is generic for all processors implementing  * the Intel 386 instruction set or a superset of it.  Specifically, this  * includes all members of the 386, 486, and Pentium family of processors.  */
elif|#
directive|elif
name|defined
argument_list|(
name|__i386
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__i386
argument_list|)
define|#
directive|define
name|__i386
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__x86
argument_list|)
define|#
directive|define
name|__x86
endif|#
directive|endif
comment|/*  * Define the appropriate "processor characteristics"  */
define|#
directive|define
name|_LITTLE_ENDIAN
define|#
directive|define
name|_STACK_GROWS_DOWNWARD
define|#
directive|define
name|_LONG_LONG_LTOH
define|#
directive|define
name|_BIT_FIELDS_LTOH
define|#
directive|define
name|_IEEE_754
define|#
directive|define
name|_CHAR_IS_SIGNED
define|#
directive|define
name|_BOOL_ALIGNMENT
value|1
define|#
directive|define
name|_CHAR_ALIGNMENT
value|1
define|#
directive|define
name|_SHORT_ALIGNMENT
value|2
define|#
directive|define
name|_INT_ALIGNMENT
value|4
define|#
directive|define
name|_FLOAT_ALIGNMENT
value|4
define|#
directive|define
name|_FLOAT_COMPLEX_ALIGNMENT
value|4
define|#
directive|define
name|_LONG_ALIGNMENT
value|4
define|#
directive|define
name|_LONG_LONG_ALIGNMENT
value|4
define|#
directive|define
name|_DOUBLE_ALIGNMENT
value|4
define|#
directive|define
name|_DOUBLE_COMPLEX_ALIGNMENT
value|4
define|#
directive|define
name|_LONG_DOUBLE_ALIGNMENT
value|4
define|#
directive|define
name|_LONG_DOUBLE_COMPLEX_ALIGNMENT
value|4
define|#
directive|define
name|_POINTER_ALIGNMENT
value|4
define|#
directive|define
name|_MAX_ALIGNMENT
value|4
define|#
directive|define
name|_ALIGNMENT_REQUIRED
value|0
define|#
directive|define
name|_LONG_LONG_ALIGNMENT_32
value|_LONG_LONG_ALIGNMENT
comment|/*  * Define the appropriate "implementation choices".  */
define|#
directive|define
name|_ILP32
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_I32LPx
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
define|#
directive|define
name|_I32LPx
endif|#
directive|endif
define|#
directive|define
name|_SUNOS_VTOC_16
define|#
directive|define
name|_DMA_USES_PHYSADDR
define|#
directive|define
name|_FIRMWARE_NEEDS_FDISK
define|#
directive|define
name|_PSM_MODULES
define|#
directive|define
name|_RTC_CONFIG
define|#
directive|define
name|_DONT_USE_1275_GENERIC_NAMES
define|#
directive|define
name|_HAVE_CPUID_INSN
comment|/*  * The following set of definitions characterize the Solaris on SPARC systems.  *  * The symbol __sparc indicates any of the SPARC family of processor  * architectures.  This includes SPARC V7, SPARC V8 and SPARC V9.  *  * The symbol __sparcv8 indicates the 32-bit SPARC V8 architecture as defined  * by Version 8 of the SPARC Architecture Manual.  (SPARC V7 is close enough  * to SPARC V8 for the former to be subsumed into the latter definition.)  *  * The symbol __sparcv9 indicates the 64-bit SPARC V9 architecture as defined  * by Version 9 of the SPARC Architecture Manual.  *  * The symbols __sparcv8 and __sparcv9 are mutually exclusive, and are only  * relevant when the symbol __sparc is defined.  */
comment|/*  * XXX Due to the existence of 5110166, "defined(__sparcv9)" needs to be added  * to support backwards builds.  This workaround should be removed in s10_71.  */
elif|#
directive|elif
name|defined
argument_list|(
name|__sparc
argument_list|)
operator|||
name|defined
argument_list|(
name|__sparcv9
argument_list|)
operator|||
name|defined
argument_list|(
name|__sparc__
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__sparc
argument_list|)
define|#
directive|define
name|__sparc
endif|#
directive|endif
comment|/*  * You can be 32-bit or 64-bit, but not both at the same time.  */
if|#
directive|if
name|defined
argument_list|(
name|__sparcv8
argument_list|)
operator|&&
name|defined
argument_list|(
name|__sparcv9
argument_list|)
error|#
directive|error
literal|"SPARC Versions 8 and 9 are mutually exclusive choices"
endif|#
directive|endif
comment|/*  * Existing compilers do not set __sparcv8.  Years will transpire before  * the compilers can be depended on to set the feature test macro. In  * the interim, we'll set it here on the basis of historical behaviour;  * if you haven't asked for SPARC V9, then you must've meant SPARC V8.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__sparcv9
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__sparcv8
argument_list|)
define|#
directive|define
name|__sparcv8
endif|#
directive|endif
comment|/*  * Define the appropriate "processor characteristics" shared between  * all Solaris on SPARC systems.  */
define|#
directive|define
name|_BIG_ENDIAN
define|#
directive|define
name|_STACK_GROWS_DOWNWARD
define|#
directive|define
name|_LONG_LONG_HTOL
define|#
directive|define
name|_BIT_FIELDS_HTOL
define|#
directive|define
name|_IEEE_754
define|#
directive|define
name|_CHAR_IS_SIGNED
define|#
directive|define
name|_BOOL_ALIGNMENT
value|1
define|#
directive|define
name|_CHAR_ALIGNMENT
value|1
define|#
directive|define
name|_SHORT_ALIGNMENT
value|2
define|#
directive|define
name|_INT_ALIGNMENT
value|4
define|#
directive|define
name|_FLOAT_ALIGNMENT
value|4
define|#
directive|define
name|_FLOAT_COMPLEX_ALIGNMENT
value|4
define|#
directive|define
name|_LONG_LONG_ALIGNMENT
value|8
define|#
directive|define
name|_DOUBLE_ALIGNMENT
value|8
define|#
directive|define
name|_DOUBLE_COMPLEX_ALIGNMENT
value|8
define|#
directive|define
name|_ALIGNMENT_REQUIRED
value|1
comment|/*  * Define the appropriate "implementation choices" shared between versions.  */
define|#
directive|define
name|_SUNOS_VTOC_8
define|#
directive|define
name|_DMA_USES_VIRTADDR
define|#
directive|define
name|_NO_FDISK_PRESENT
define|#
directive|define
name|_HAVE_TEM_FIRMWARE
define|#
directive|define
name|_UNIX_KRTLD
comment|/*  * The following set of definitions characterize the implementation of  * 32-bit Solaris on SPARC V8 systems.  */
if|#
directive|if
name|defined
argument_list|(
name|__sparcv8
argument_list|)
comment|/*  * Define the appropriate "processor characteristics"  */
define|#
directive|define
name|_LONG_ALIGNMENT
value|4
define|#
directive|define
name|_LONG_DOUBLE_ALIGNMENT
value|8
define|#
directive|define
name|_LONG_DOUBLE_COMPLEX_ALIGNMENT
value|8
define|#
directive|define
name|_POINTER_ALIGNMENT
value|4
define|#
directive|define
name|_MAX_ALIGNMENT
value|8
define|#
directive|define
name|_LONG_LONG_ALIGNMENT_32
value|_LONG_LONG_ALIGNMENT
comment|/*  * Define the appropriate "implementation choices"  */
define|#
directive|define
name|_ILP32
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_I32LPx
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
define|#
directive|define
name|_I32LPx
endif|#
directive|endif
comment|/*  * The following set of definitions characterize the implementation of  * 64-bit Solaris on SPARC V9 systems.  */
elif|#
directive|elif
name|defined
argument_list|(
name|__sparcv9
argument_list|)
comment|/*  * Define the appropriate "processor characteristics"  */
define|#
directive|define
name|_LONG_ALIGNMENT
value|8
define|#
directive|define
name|_LONG_DOUBLE_ALIGNMENT
value|16
define|#
directive|define
name|_LONG_DOUBLE_COMPLEX_ALIGNMENT
value|16
define|#
directive|define
name|_POINTER_ALIGNMENT
value|8
define|#
directive|define
name|_MAX_ALIGNMENT
value|16
define|#
directive|define
name|_LONG_LONG_ALIGNMENT_32
value|_LONG_LONG_ALIGMENT
comment|/*  * Define the appropriate "implementation choices"  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_LP64
argument_list|)
define|#
directive|define
name|_LP64
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_I32LPx
argument_list|)
define|#
directive|define
name|_I32LPx
endif|#
directive|endif
define|#
directive|define
name|_MULTI_DATAMODEL
else|#
directive|else
error|#
directive|error
literal|"unknown SPARC version"
endif|#
directive|endif
comment|/*  * #error is strictly ansi-C, but works as well as anything for K&R systems.  */
else|#
directive|else
error|#
directive|error
literal|"ISA not supported"
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|_ILP32
argument_list|)
operator|&&
name|defined
argument_list|(
name|_LP64
argument_list|)
error|#
directive|error
literal|"Both _ILP32 and _LP64 are defined"
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _SYS_ISA_DEFS_H */
end_comment

end_unit

