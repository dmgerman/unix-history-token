begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1984, 1985, 1986, 1987, 1993  *	The Regents of the University of California.  * Copyright (c) 2004-2006 Robert N. M. Watson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Copyright (c) 1995, Mike Mitchell  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)spx_usrreq.h  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netipx/ipx.h>
end_include

begin_include
include|#
directive|include
file|<netipx/ipx_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netipx/ipx_var.h>
end_include

begin_include
include|#
directive|include
file|<netipx/spx.h>
end_include

begin_include
include|#
directive|include
file|<netipx/spx_debug.h>
end_include

begin_include
include|#
directive|include
file|<netipx/spx_timer.h>
end_include

begin_include
include|#
directive|include
file|<netipx/spx_var.h>
end_include

begin_comment
comment|/*  * SPX protocol implementation.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|spx_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Protects only spx_iss. */
end_comment

begin_decl_stmt
specifier|static
name|u_short
name|spx_iss
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|spx_newchecks
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|spx_hardnosed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|spx_use_delack
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|traceallspxs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|spx_istat
name|spx_istat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|spxrexmtthresh
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SPX_LOCK_INIT
parameter_list|()
value|mtx_init(&spx_mtx, "spx_mtx", NULL, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|SPX_LOCK
parameter_list|()
value|mtx_lock(&spx_mtx)
end_define

begin_define
define|#
directive|define
name|SPX_UNLOCK
parameter_list|()
value|mtx_unlock(&spx_mtx)
end_define

begin_comment
comment|/* Following was struct spxstat spxstat; */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|spxstat
end_ifndef

begin_define
define|#
directive|define
name|spxstat
value|spx_istat.newstats
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|int
name|spx_backoff
index|[
name|SPX_MAXRXTSHIFT
operator|+
literal|1
index|]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|,
literal|32
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|spx_close
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spx_disconnect
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spx_drop
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|,
name|int
name|errno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_output
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_reass
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|,
name|struct
name|spx
modifier|*
name|si
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spx_setpersist
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spx_template
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spx_timers
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|,
name|int
name|timer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spx_usrclosed
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spx_usr_abort
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_accept
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_attach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_bind
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spx_usr_close
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_connect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spx_detach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spx_pcbdetach
parameter_list|(
name|struct
name|ipxpcb
modifier|*
name|ipxp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_usr_disconnect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_listen
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|backlog
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_rcvd
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_rcvoob
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_send
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_shutdown
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_sp_attach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|pr_usrreqs
name|spx_usrreqs
init|=
block|{
operator|.
name|pru_abort
operator|=
name|spx_usr_abort
block|,
operator|.
name|pru_accept
operator|=
name|spx_accept
block|,
operator|.
name|pru_attach
operator|=
name|spx_attach
block|,
operator|.
name|pru_bind
operator|=
name|spx_bind
block|,
operator|.
name|pru_connect
operator|=
name|spx_connect
block|,
operator|.
name|pru_control
operator|=
name|ipx_control
block|,
operator|.
name|pru_detach
operator|=
name|spx_detach
block|,
operator|.
name|pru_disconnect
operator|=
name|spx_usr_disconnect
block|,
operator|.
name|pru_listen
operator|=
name|spx_listen
block|,
operator|.
name|pru_peeraddr
operator|=
name|ipx_peeraddr
block|,
operator|.
name|pru_rcvd
operator|=
name|spx_rcvd
block|,
operator|.
name|pru_rcvoob
operator|=
name|spx_rcvoob
block|,
operator|.
name|pru_send
operator|=
name|spx_send
block|,
operator|.
name|pru_shutdown
operator|=
name|spx_shutdown
block|,
operator|.
name|pru_sockaddr
operator|=
name|ipx_sockaddr
block|,
operator|.
name|pru_close
operator|=
name|spx_usr_close
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pr_usrreqs
name|spx_usrreq_sps
init|=
block|{
operator|.
name|pru_abort
operator|=
name|spx_usr_abort
block|,
operator|.
name|pru_accept
operator|=
name|spx_accept
block|,
operator|.
name|pru_attach
operator|=
name|spx_sp_attach
block|,
operator|.
name|pru_bind
operator|=
name|spx_bind
block|,
operator|.
name|pru_connect
operator|=
name|spx_connect
block|,
operator|.
name|pru_control
operator|=
name|ipx_control
block|,
operator|.
name|pru_detach
operator|=
name|spx_detach
block|,
operator|.
name|pru_disconnect
operator|=
name|spx_usr_disconnect
block|,
operator|.
name|pru_listen
operator|=
name|spx_listen
block|,
operator|.
name|pru_peeraddr
operator|=
name|ipx_peeraddr
block|,
operator|.
name|pru_rcvd
operator|=
name|spx_rcvd
block|,
operator|.
name|pru_rcvoob
operator|=
name|spx_rcvoob
block|,
operator|.
name|pru_send
operator|=
name|spx_send
block|,
operator|.
name|pru_shutdown
operator|=
name|spx_shutdown
block|,
operator|.
name|pru_sockaddr
operator|=
name|ipx_sockaddr
block|,
operator|.
name|pru_close
operator|=
name|spx_usr_close
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|spx_init
parameter_list|(
name|void
parameter_list|)
block|{
name|SPX_LOCK_INIT
argument_list|()
expr_stmt|;
name|spx_iss
operator|=
literal|1
expr_stmt|;
comment|/* WRONG !! should fish it out of TODR */
block|}
end_function

begin_function
name|void
name|spx_input
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ipxpcb
modifier|*
name|ipxp
parameter_list|)
block|{
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|struct
name|spx
modifier|*
name|si
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spx
operator|*
argument_list|)
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|spx
name|spx_savesi
decl_stmt|;
name|int
name|dropsocket
init|=
literal|0
decl_stmt|;
name|short
name|ostate
init|=
literal|0
decl_stmt|;
name|spxstat
operator|.
name|spxs_rcvtotal
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
name|ipxp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_input: ipxpcb == NULL"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * spx_input() assumes that the caller will hold both the pcb list 	 * lock and also the ipxp lock.  spx_input() will release both before 	 * returning, and may in fact trade in the ipxp lock for another pcb 	 * lock following sonewconn(). 	 */
name|IPX_LIST_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|IPX_LOCK_ASSERT
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_input: cb == NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipxp
operator|->
name|ipxp_flags
operator|&
name|IPXP_DROPPED
condition|)
goto|goto
name|drop
goto|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|IPX_LIST_UNLOCK
argument_list|()
expr_stmt|;
name|spxstat
operator|.
name|spxs_rcvshort
operator|++
expr_stmt|;
return|return;
block|}
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spx
operator|*
argument_list|)
expr_stmt|;
block|}
name|si
operator|->
name|si_seq
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_seq
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_ack
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_ack
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_alo
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_alo
argument_list|)
expr_stmt|;
name|so
operator|=
name|ipxp
operator|->
name|ipxp_socket
expr_stmt|;
name|KASSERT
argument_list|(
name|so
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_input: so == NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspxs
condition|)
block|{
name|ostate
operator|=
name|cb
operator|->
name|s_state
expr_stmt|;
name|spx_savesi
operator|=
operator|*
name|si
expr_stmt|;
block|}
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_ACCEPTCONN
condition|)
block|{
name|struct
name|spxpcb
modifier|*
name|ocb
init|=
name|cb
decl_stmt|;
name|so
operator|=
name|sonewconn
argument_list|(
name|so
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
goto|goto
name|drop
goto|;
comment|/* 		 * This is ugly, but .... 		 * 		 * Mark socket as temporary until we're committed to keeping 		 * it.  The code at ``drop'' and ``dropwithreset'' check the 		 * flag dropsocket to see if the temporary socket created 		 * here should be discarded.  We mark the socket as 		 * discardable until we're committed to it below in 		 * TCPS_LISTEN. 		 * 		 * XXXRW: In the new world order of real kernel parallelism, 		 * temporarily allocating the socket when we're "not sure" 		 * seems like a bad idea, as we might race to remove it if 		 * the listen socket is closed...? 		 * 		 * We drop the lock of the listen socket ipxp, and acquire 		 * the lock of the new socket ippx. 		 */
name|dropsocket
operator|++
expr_stmt|;
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|ipxp
operator|=
operator|(
expr|struct
name|ipxpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
name|IPX_LOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|ipxp
operator|->
name|ipxp_laddr
operator|=
name|si
operator|->
name|si_dna
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_mtu
operator|=
name|ocb
operator|->
name|s_mtu
expr_stmt|;
comment|/* preserve sockopts */
name|cb
operator|->
name|s_flags
operator|=
name|ocb
operator|->
name|s_flags
expr_stmt|;
comment|/* preserve sockopts */
name|cb
operator|->
name|s_flags2
operator|=
name|ocb
operator|->
name|s_flags2
expr_stmt|;
comment|/* preserve sockopts */
name|cb
operator|->
name|s_state
operator|=
name|TCPS_LISTEN
expr_stmt|;
block|}
name|IPX_LOCK_ASSERT
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
comment|/* 	 * Packet received on connection.  Reset idle time and keep-alive 	 * timer. 	 */
name|cb
operator|->
name|s_idle
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPXT_KEEP
index|]
operator|=
name|SPXTV_KEEP
expr_stmt|;
switch|switch
condition|(
name|cb
operator|->
name|s_state
condition|)
block|{
case|case
name|TCPS_LISTEN
case|:
block|{
name|struct
name|sockaddr_ipx
modifier|*
name|sipx
decl_stmt|,
name|ssipx
decl_stmt|;
name|struct
name|ipx_addr
name|laddr
decl_stmt|;
comment|/* 		 * If somebody here was carying on a conversation and went 		 * away, and his pen pal thinks he can still talk, we get the 		 * misdirected packet. 		 */
if|if
condition|(
name|spx_hardnosed
operator|&&
operator|(
name|si
operator|->
name|si_did
operator|!=
literal|0
operator|||
name|si
operator|->
name|si_seq
operator|!=
literal|0
operator|)
condition|)
block|{
name|spx_istat
operator|.
name|gonawy
operator|++
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
name|sipx
operator|=
operator|&
name|ssipx
expr_stmt|;
name|bzero
argument_list|(
name|sipx
argument_list|,
sizeof|sizeof
expr|*
name|sipx
argument_list|)
expr_stmt|;
name|sipx
operator|->
name|sipx_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sipx
argument_list|)
expr_stmt|;
name|sipx
operator|->
name|sipx_family
operator|=
name|AF_IPX
expr_stmt|;
name|sipx
operator|->
name|sipx_addr
operator|=
name|si
operator|->
name|si_sna
expr_stmt|;
name|laddr
operator|=
name|ipxp
operator|->
name|ipxp_laddr
expr_stmt|;
if|if
condition|(
name|ipx_nullhost
argument_list|(
name|laddr
argument_list|)
condition|)
name|ipxp
operator|->
name|ipxp_laddr
operator|=
name|si
operator|->
name|si_dna
expr_stmt|;
if|if
condition|(
name|ipx_pcbconnect
argument_list|(
name|ipxp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sipx
argument_list|,
operator|&
name|thread0
argument_list|)
condition|)
block|{
name|ipxp
operator|->
name|ipxp_laddr
operator|=
name|laddr
expr_stmt|;
name|spx_istat
operator|.
name|noconn
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|spx_template
argument_list|(
name|cb
argument_list|)
expr_stmt|;
name|dropsocket
operator|=
literal|0
expr_stmt|;
comment|/* committed to socket */
name|cb
operator|->
name|s_did
operator|=
name|si
operator|->
name|si_sid
expr_stmt|;
name|cb
operator|->
name|s_rack
operator|=
name|si
operator|->
name|si_ack
expr_stmt|;
name|cb
operator|->
name|s_ralo
operator|=
name|si
operator|->
name|si_alo
expr_stmt|;
define|#
directive|define
name|THREEWAYSHAKE
ifdef|#
directive|ifdef
name|THREEWAYSHAKE
name|cb
operator|->
name|s_state
operator|=
name|TCPS_SYN_RECEIVED
expr_stmt|;
name|cb
operator|->
name|s_force
operator|=
literal|1
operator|+
name|SPXT_KEEP
expr_stmt|;
name|spxstat
operator|.
name|spxs_accepts
operator|++
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPXT_KEEP
index|]
operator|=
name|SPXTV_KEEP
expr_stmt|;
block|}
break|break;
case|case
name|TCPS_SYN_RECEIVED
case|:
block|{
comment|/* 		 * This state means that we have heard a response to our 		 * acceptance of their connection.  It is probably logically 		 * unnecessary in this implementation. 		 */
if|if
condition|(
name|si
operator|->
name|si_did
operator|!=
name|cb
operator|->
name|s_sid
condition|)
block|{
name|spx_istat
operator|.
name|wrncon
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
endif|#
directive|endif
name|ipxp
operator|->
name|ipxp_fport
operator|=
name|si
operator|->
name|si_sport
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPXT_KEEP
index|]
operator|=
name|SPXTV_KEEP
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_ESTABLISHED
expr_stmt|;
name|spxstat
operator|.
name|spxs_accepts
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|TCPS_SYN_SENT
case|:
comment|/* 		 * This state means that we have gotten a response to our 		 * attempt to establish a connection.  We fill in the data 		 * from the other side, telling us which port to respond to, 		 * instead of the well-known one we might have sent to in the 		 * first place.  We also require that this is a response to 		 * our connection id. 		 */
if|if
condition|(
name|si
operator|->
name|si_did
operator|!=
name|cb
operator|->
name|s_sid
condition|)
block|{
name|spx_istat
operator|.
name|notme
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|spxstat
operator|.
name|spxs_connects
operator|++
expr_stmt|;
name|cb
operator|->
name|s_did
operator|=
name|si
operator|->
name|si_sid
expr_stmt|;
name|cb
operator|->
name|s_rack
operator|=
name|si
operator|->
name|si_ack
expr_stmt|;
name|cb
operator|->
name|s_ralo
operator|=
name|si
operator|->
name|si_alo
expr_stmt|;
name|cb
operator|->
name|s_dport
operator|=
name|ipxp
operator|->
name|ipxp_fport
operator|=
name|si
operator|->
name|si_sport
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_flags
operator||=
name|SF_ACKNOW
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_ESTABLISHED
expr_stmt|;
comment|/* 		 * Use roundtrip time of connection request for initial rtt. 		 */
if|if
condition|(
name|cb
operator|->
name|s_rtt
condition|)
block|{
name|cb
operator|->
name|s_srtt
operator|=
name|cb
operator|->
name|s_rtt
operator|<<
literal|3
expr_stmt|;
name|cb
operator|->
name|s_rttvar
operator|=
name|cb
operator|->
name|s_rtt
operator|<<
literal|1
expr_stmt|;
name|SPXT_RANGESET
argument_list|(
name|cb
operator|->
name|s_rxtcur
argument_list|,
operator|(
operator|(
name|cb
operator|->
name|s_srtt
operator|>>
literal|2
operator|)
operator|+
name|cb
operator|->
name|s_rttvar
operator|)
operator|>>
literal|1
argument_list|,
name|SPXTV_MIN
argument_list|,
name|SPXTV_REXMTMAX
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_rtt
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspxs
condition|)
name|spx_trace
argument_list|(
name|SA_INPUT
argument_list|,
operator|(
name|u_char
operator|)
name|ostate
argument_list|,
name|cb
argument_list|,
operator|&
name|spx_savesi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ipx
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ipx
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ipx
argument_list|)
expr_stmt|;
if|if
condition|(
name|spx_reass
argument_list|(
name|cb
argument_list|,
name|si
argument_list|)
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_force
operator|||
operator|(
name|cb
operator|->
name|s_flags
operator|&
operator|(
name|SF_ACKNOW
operator||
name|SF_WIN
operator||
name|SF_RXT
operator|)
operator|)
condition|)
name|spx_output
argument_list|(
name|cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_flags
operator|&=
operator|~
operator|(
name|SF_WIN
operator||
name|SF_RXT
operator|)
expr_stmt|;
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|IPX_LIST_UNLOCK
argument_list|()
expr_stmt|;
return|return;
name|dropwithreset
label|:
name|IPX_LOCK_ASSERT
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|==
name|NULL
operator|||
operator|(
name|cb
operator|->
name|s_ipxpcb
operator|->
name|ipxp_socket
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspxs
operator|)
condition|)
name|spx_trace
argument_list|(
name|SA_DROP
argument_list|,
operator|(
name|u_char
operator|)
name|ostate
argument_list|,
name|cb
argument_list|,
operator|&
name|spx_savesi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dropsocket
condition|)
block|{
name|struct
name|socket
modifier|*
name|head
decl_stmt|;
name|ACCEPT_LOCK
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|so
operator|->
name|so_qstate
operator|&
name|SQ_INCOMP
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"spx_input: nascent socket not SQ_INCOMP on soabort()"
operator|)
argument_list|)
expr_stmt|;
name|head
operator|=
name|so
operator|->
name|so_head
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|head
operator|->
name|so_incomp
argument_list|,
name|so
argument_list|,
name|so_list
argument_list|)
expr_stmt|;
name|head
operator|->
name|so_incqlen
operator|--
expr_stmt|;
name|so
operator|->
name|so_qstate
operator|&=
operator|~
name|SQ_INCOMP
expr_stmt|;
name|so
operator|->
name|so_head
operator|=
name|NULL
expr_stmt|;
name|ACCEPT_UNLOCK
argument_list|()
expr_stmt|;
name|soabort
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|IPX_LIST_UNLOCK
argument_list|()
expr_stmt|;
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
return|return;
name|drop
label|:
name|IPX_LOCK_ASSERT
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_ipxpcb
operator|->
name|ipxp_socket
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspxs
condition|)
name|spx_trace
argument_list|(
name|SA_DROP
argument_list|,
operator|(
name|u_char
operator|)
name|ostate
argument_list|,
name|cb
argument_list|,
operator|&
name|spx_savesi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|IPX_LIST_UNLOCK
argument_list|()
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is structurally similar to the tcp reassembly routine but its  * function is somewhat different:  It merely queues packets up, and  * suppresses duplicates.  */
end_comment

begin_function
specifier|static
name|int
name|spx_reass
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|,
name|struct
name|spx
modifier|*
name|si
parameter_list|)
block|{
name|struct
name|spx_q
modifier|*
name|q
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|cb
operator|->
name|s_ipxpcb
operator|->
name|ipxp_socket
decl_stmt|;
name|char
name|packetp
init|=
name|cb
operator|->
name|s_flags
operator|&
name|SF_HI
decl_stmt|;
name|int
name|incr
decl_stmt|;
name|char
name|wakeup
init|=
literal|0
decl_stmt|;
name|IPX_LOCK_ASSERT
argument_list|(
name|cb
operator|->
name|s_ipxpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|==
name|SI
argument_list|(
literal|0
argument_list|)
condition|)
goto|goto
name|present
goto|;
comment|/* 	 * Update our news from them. 	 */
if|if
condition|(
name|si
operator|->
name|si_cc
operator|&
name|SPX_SA
condition|)
name|cb
operator|->
name|s_flags
operator||=
operator|(
name|spx_use_delack
condition|?
name|SF_DELACK
else|:
name|SF_ACKNOW
operator|)
expr_stmt|;
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|si
operator|->
name|si_alo
argument_list|,
name|cb
operator|->
name|s_ralo
argument_list|)
condition|)
name|cb
operator|->
name|s_flags
operator||=
name|SF_WIN
expr_stmt|;
if|if
condition|(
name|SSEQ_LEQ
argument_list|(
name|si
operator|->
name|si_ack
argument_list|,
name|cb
operator|->
name|s_rack
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|si
operator|->
name|si_cc
operator|&
name|SPX_SP
operator|)
operator|&&
name|cb
operator|->
name|s_rack
operator|!=
operator|(
name|cb
operator|->
name|s_smax
operator|+
literal|1
operator|)
condition|)
block|{
name|spxstat
operator|.
name|spxs_rcvdupack
operator|++
expr_stmt|;
comment|/* 			 * If this is a completely duplicate ack and other 			 * conditions hold, we assume a packet has been 			 * dropped and retransmit it exactly as in 			 * tcp_input(). 			 */
if|if
condition|(
name|si
operator|->
name|si_ack
operator|!=
name|cb
operator|->
name|s_rack
operator|||
name|si
operator|->
name|si_alo
operator|!=
name|cb
operator|->
name|s_ralo
condition|)
name|cb
operator|->
name|s_dupacks
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|++
name|cb
operator|->
name|s_dupacks
operator|==
name|spxrexmtthresh
condition|)
block|{
name|u_short
name|onxt
init|=
name|cb
operator|->
name|s_snxt
decl_stmt|;
name|int
name|cwnd
init|=
name|cb
operator|->
name|s_cwnd
decl_stmt|;
name|cb
operator|->
name|s_snxt
operator|=
name|si
operator|->
name|si_ack
expr_stmt|;
name|cb
operator|->
name|s_cwnd
operator|=
name|CUNIT
expr_stmt|;
name|cb
operator|->
name|s_force
operator|=
literal|1
operator|+
name|SPXT_REXMT
expr_stmt|;
name|spx_output
argument_list|(
name|cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|=
name|cb
operator|->
name|s_rxtcur
expr_stmt|;
name|cb
operator|->
name|s_rtt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cwnd
operator|>=
literal|4
operator|*
name|CUNIT
condition|)
name|cb
operator|->
name|s_cwnd
operator|=
name|cwnd
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|onxt
argument_list|,
name|cb
operator|->
name|s_snxt
argument_list|)
condition|)
name|cb
operator|->
name|s_snxt
operator|=
name|onxt
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
name|cb
operator|->
name|s_dupacks
operator|=
literal|0
expr_stmt|;
goto|goto
name|update_window
goto|;
block|}
name|cb
operator|->
name|s_dupacks
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If our correspondent acknowledges data we haven't sent TCP would 	 * drop the packet after acking.  We'll be a little more permissive. 	 */
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|si
operator|->
name|si_ack
argument_list|,
operator|(
name|cb
operator|->
name|s_smax
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|spxstat
operator|.
name|spxs_rcvacktoomuch
operator|++
expr_stmt|;
name|si
operator|->
name|si_ack
operator|=
name|cb
operator|->
name|s_smax
operator|+
literal|1
expr_stmt|;
block|}
name|spxstat
operator|.
name|spxs_rcvackpack
operator|++
expr_stmt|;
comment|/* 	 * If transmit timer is running and timed sequence number was acked, 	 * update smoothed round trip time.  See discussion of algorithm in 	 * tcp_input.c 	 */
if|if
condition|(
name|cb
operator|->
name|s_rtt
operator|&&
name|SSEQ_GT
argument_list|(
name|si
operator|->
name|si_ack
argument_list|,
name|cb
operator|->
name|s_rtseq
argument_list|)
condition|)
block|{
name|spxstat
operator|.
name|spxs_rttupdated
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_srtt
operator|!=
literal|0
condition|)
block|{
name|short
name|delta
decl_stmt|;
name|delta
operator|=
name|cb
operator|->
name|s_rtt
operator|-
operator|(
name|cb
operator|->
name|s_srtt
operator|>>
literal|3
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cb
operator|->
name|s_srtt
operator|+=
name|delta
operator|)
operator|<=
literal|0
condition|)
name|cb
operator|->
name|s_srtt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|delta
operator|=
operator|-
name|delta
expr_stmt|;
name|delta
operator|-=
operator|(
name|cb
operator|->
name|s_rttvar
operator|>>
literal|2
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cb
operator|->
name|s_rttvar
operator|+=
name|delta
operator|)
operator|<=
literal|0
condition|)
name|cb
operator|->
name|s_rttvar
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * No rtt measurement yet. 			 */
name|cb
operator|->
name|s_srtt
operator|=
name|cb
operator|->
name|s_rtt
operator|<<
literal|3
expr_stmt|;
name|cb
operator|->
name|s_rttvar
operator|=
name|cb
operator|->
name|s_rtt
operator|<<
literal|1
expr_stmt|;
block|}
name|cb
operator|->
name|s_rtt
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_rxtshift
operator|=
literal|0
expr_stmt|;
name|SPXT_RANGESET
argument_list|(
name|cb
operator|->
name|s_rxtcur
argument_list|,
operator|(
operator|(
name|cb
operator|->
name|s_srtt
operator|>>
literal|2
operator|)
operator|+
name|cb
operator|->
name|s_rttvar
operator|)
operator|>>
literal|1
argument_list|,
name|SPXTV_MIN
argument_list|,
name|SPXTV_REXMTMAX
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If all outstanding data is acked, stop retransmit timer and 	 * remember to restart (more output or persist).  If there is more 	 * data to be acked, restart retransmit timer, using current 	 * (possibly backed-off) value; 	 */
if|if
condition|(
name|si
operator|->
name|si_ack
operator|==
name|cb
operator|->
name|s_smax
operator|+
literal|1
condition|)
block|{
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_flags
operator||=
name|SF_RXT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cb
operator|->
name|s_timer
index|[
name|SPXT_PERSIST
index|]
operator|==
literal|0
condition|)
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|=
name|cb
operator|->
name|s_rxtcur
expr_stmt|;
comment|/* 	 * When new data is acked, open the congestion window.  If the window 	 * gives us less than ssthresh packets in flight, open exponentially 	 * (maxseg at a time).  Otherwise open linearly (maxseg^2 / cwnd at a 	 * time). 	 */
name|incr
operator|=
name|CUNIT
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_cwnd
operator|>
name|cb
operator|->
name|s_ssthresh
condition|)
name|incr
operator|=
name|max
argument_list|(
name|incr
operator|*
name|incr
operator|/
name|cb
operator|->
name|s_cwnd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_cwnd
operator|=
name|min
argument_list|(
name|cb
operator|->
name|s_cwnd
operator|+
name|incr
argument_list|,
name|cb
operator|->
name|s_cwmx
argument_list|)
expr_stmt|;
comment|/* 	 * Trim Acked data from output queue. 	 */
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_mb
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SSEQ_LT
argument_list|(
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spx
operator|*
argument_list|)
operator|)
operator|->
name|si_seq
argument_list|,
name|si
operator|->
name|si_ack
argument_list|)
condition|)
name|sbdroprecord_locked
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
name|sowwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_rack
operator|=
name|si
operator|->
name|si_ack
expr_stmt|;
name|update_window
label|:
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_snxt
argument_list|,
name|cb
operator|->
name|s_rack
argument_list|)
condition|)
name|cb
operator|->
name|s_snxt
operator|=
name|cb
operator|->
name|s_rack
expr_stmt|;
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_swl1
argument_list|,
name|si
operator|->
name|si_seq
argument_list|)
operator|||
operator|(
operator|(
name|cb
operator|->
name|s_swl1
operator|==
name|si
operator|->
name|si_seq
operator|&&
operator|(
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_swl2
argument_list|,
name|si
operator|->
name|si_ack
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|cb
operator|->
name|s_swl2
operator|==
name|si
operator|->
name|si_ack
operator|&&
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_ralo
argument_list|,
name|si
operator|->
name|si_alo
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* keep track of pure window updates */
if|if
condition|(
operator|(
name|si
operator|->
name|si_cc
operator|&
name|SPX_SP
operator|)
operator|&&
name|cb
operator|->
name|s_swl2
operator|==
name|si
operator|->
name|si_ack
operator|&&
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_ralo
argument_list|,
name|si
operator|->
name|si_alo
argument_list|)
condition|)
block|{
name|spxstat
operator|.
name|spxs_rcvwinupd
operator|++
expr_stmt|;
name|spxstat
operator|.
name|spxs_rcvdupack
operator|--
expr_stmt|;
block|}
name|cb
operator|->
name|s_ralo
operator|=
name|si
operator|->
name|si_alo
expr_stmt|;
name|cb
operator|->
name|s_swl1
operator|=
name|si
operator|->
name|si_seq
expr_stmt|;
name|cb
operator|->
name|s_swl2
operator|=
name|si
operator|->
name|si_ack
expr_stmt|;
name|cb
operator|->
name|s_swnd
operator|=
operator|(
literal|1
operator|+
name|si
operator|->
name|si_alo
operator|-
name|si
operator|->
name|si_ack
operator|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_swnd
operator|>
name|cb
operator|->
name|s_smxw
condition|)
name|cb
operator|->
name|s_smxw
operator|=
name|cb
operator|->
name|s_swnd
expr_stmt|;
name|cb
operator|->
name|s_flags
operator||=
name|SF_WIN
expr_stmt|;
block|}
comment|/* 	 * If this packet number is higher than that which we have allocated 	 * refuse it, unless urgent. 	 */
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|cb
operator|->
name|s_alo
argument_list|)
condition|)
block|{
if|if
condition|(
name|si
operator|->
name|si_cc
operator|&
name|SPX_SP
condition|)
block|{
name|spxstat
operator|.
name|spxs_rcvwinprobe
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
name|spxstat
operator|.
name|spxs_rcvpackafterwin
operator|++
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|si_cc
operator|&
name|SPX_OB
condition|)
block|{
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|cb
operator|->
name|s_alo
operator|+
literal|60
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* else queue this packet; */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|BROKEN
comment|/* 			 * XXXRW: This is broken on at least one count: 			 * spx_close() will free the ipxp and related parts, 			 * which are then touched by spx_input() after the 			 * return from spx_reass(). 			 */
comment|/*struct socket *so = cb->s_ipxpcb->ipxp_socket; 			if (so->so_state&& SS_NOFDREF) { 				spx_close(cb); 			} else 				       would crash system*/
endif|#
directive|endif
name|spx_istat
operator|.
name|notyet
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * If this is a system packet, we don't need to queue it up, and 	 * won't update acknowledge #. 	 */
if|if
condition|(
name|si
operator|->
name|si_cc
operator|&
name|SPX_SP
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * We have already seen this packet, so drop. 	 */
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|cb
operator|->
name|s_ack
argument_list|)
condition|)
block|{
name|spx_istat
operator|.
name|bdreas
operator|++
expr_stmt|;
name|spxstat
operator|.
name|spxs_rcvduppack
operator|++
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|si_seq
operator|==
name|cb
operator|->
name|s_ack
operator|-
literal|1
condition|)
name|spx_istat
operator|.
name|lstdup
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Loop through all packets queued up to insert in appropriate 	 * sequence. 	 */
for|for
control|(
name|q
operator|=
name|cb
operator|->
name|s_q
operator|.
name|si_next
init|;
name|q
operator|!=
operator|&
name|cb
operator|->
name|s_q
condition|;
name|q
operator|=
name|q
operator|->
name|si_next
control|)
block|{
if|if
condition|(
name|si
operator|->
name|si_seq
operator|==
name|SI
argument_list|(
name|q
argument_list|)
operator|->
name|si_seq
condition|)
block|{
name|spxstat
operator|.
name|spxs_rcvduppack
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|SI
argument_list|(
name|q
argument_list|)
operator|->
name|si_seq
argument_list|)
condition|)
block|{
name|spxstat
operator|.
name|spxs_rcvoopack
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|insque
argument_list|(
name|si
argument_list|,
name|q
operator|->
name|si_prev
argument_list|)
expr_stmt|;
comment|/* 	 * If this packet is urgent, inform process 	 */
if|if
condition|(
name|si
operator|->
name|si_cc
operator|&
name|SPX_OB
condition|)
block|{
name|cb
operator|->
name|s_iobc
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|si
operator|)
index|[
literal|1
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
index|]
expr_stmt|;
name|sohasoutofband
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_oobflags
operator||=
name|SF_IOOB
expr_stmt|;
block|}
name|present
label|:
define|#
directive|define
name|SPINC
value|sizeof(struct spxhdr)
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* 	 * Loop through all packets queued up to update acknowledge number, 	 * and present all acknowledged data to user; if in packet interface 	 * mode, show packet headers. 	 */
for|for
control|(
name|q
operator|=
name|cb
operator|->
name|s_q
operator|.
name|si_next
init|;
name|q
operator|!=
operator|&
name|cb
operator|->
name|s_q
condition|;
name|q
operator|=
name|q
operator|->
name|si_next
control|)
block|{
if|if
condition|(
name|SI
argument_list|(
name|q
argument_list|)
operator|->
name|si_seq
operator|==
name|cb
operator|->
name|s_ack
condition|)
block|{
name|cb
operator|->
name|s_ack
operator|++
expr_stmt|;
name|m
operator|=
name|dtom
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|SI
argument_list|(
name|q
argument_list|)
operator|->
name|si_cc
operator|&
name|SPX_OB
condition|)
block|{
name|cb
operator|->
name|s_oobflags
operator|&=
operator|~
name|SF_IOOB
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
condition|)
name|so
operator|->
name|so_oobmark
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
expr_stmt|;
else|else
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator||=
name|SBS_RCVATMARK
expr_stmt|;
block|}
name|q
operator|=
name|q
operator|->
name|si_prev
expr_stmt|;
name|remque
argument_list|(
name|q
operator|->
name|si_next
argument_list|)
expr_stmt|;
name|wakeup
operator|=
literal|1
expr_stmt|;
name|spxstat
operator|.
name|spxs_rcvpack
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SF_NEWCALL
if|if
condition|(
name|cb
operator|->
name|s_flags2
operator|&
name|SF_NEWCALL
condition|)
block|{
name|struct
name|spxhdr
modifier|*
name|sp
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spxhdr
operator|*
argument_list|)
decl_stmt|;
name|u_char
name|dt
init|=
name|sp
operator|->
name|spx_dt
decl_stmt|;
name|spx_newchecks
index|[
literal|4
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|dt
operator|!=
name|cb
operator|->
name|s_rhdr
operator|.
name|spx_dt
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mm
init|=
name|m_getclr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_CONTROL
argument_list|)
decl_stmt|;
name|spx_newchecks
index|[
literal|0
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|mm
operator|!=
name|NULL
condition|)
block|{
name|u_short
modifier|*
name|s
init|=
name|mtod
argument_list|(
name|mm
argument_list|,
name|u_short
operator|*
argument_list|)
decl_stmt|;
name|cb
operator|->
name|s_rhdr
operator|.
name|spx_dt
operator|=
name|dt
expr_stmt|;
name|mm
operator|->
name|m_len
operator|=
literal|5
expr_stmt|;
comment|/*XXX*/
name|s
index|[
literal|0
index|]
operator|=
literal|5
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
name|s
index|[
literal|2
index|]
operator|)
operator|=
name|dt
expr_stmt|;
name|sbappend_locked
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|mm
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sp
operator|->
name|spx_cc
operator|&
name|SPX_OB
condition|)
block|{
name|MCHTYPE
argument_list|(
name|m
argument_list|,
name|MT_OOBDATA
argument_list|)
expr_stmt|;
name|spx_newchecks
index|[
literal|1
index|]
operator|++
expr_stmt|;
name|so
operator|->
name|so_oobmark
operator|=
literal|0
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&=
operator|~
name|SBS_RCVATMARK
expr_stmt|;
block|}
if|if
condition|(
name|packetp
operator|==
literal|0
condition|)
block|{
name|m
operator|->
name|m_data
operator|+=
name|SPINC
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|SPINC
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|SPINC
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sp
operator|->
name|spx_cc
operator|&
name|SPX_EM
operator|)
operator|||
name|packetp
condition|)
block|{
name|sbappendrecord_locked
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|spx_newchecks
index|[
literal|9
index|]
operator|++
expr_stmt|;
block|}
else|else
name|sbappend_locked
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|packetp
condition|)
name|sbappendrecord_locked
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|else
block|{
name|cb
operator|->
name|s_rhdr
operator|=
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spxhdr
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|SPINC
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|SPINC
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|SPINC
expr_stmt|;
name|sbappend_locked
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
if|if
condition|(
name|wakeup
condition|)
name|sorwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
else|else
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spx_ctlinput
parameter_list|(
name|int
name|cmd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|arg_as_sa
parameter_list|,
name|void
modifier|*
name|dummy
parameter_list|)
block|{
comment|/* Currently, nothing. */
block|}
end_function

begin_function
specifier|static
name|int
name|spx_output
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|cb
operator|->
name|s_ipxpcb
operator|->
name|ipxp_socket
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|spx
modifier|*
name|si
init|=
name|NULL
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
name|so
operator|->
name|so_snd
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|,
name|win
decl_stmt|,
name|rcv_win
decl_stmt|;
name|short
name|span
decl_stmt|,
name|off
decl_stmt|,
name|recordp
init|=
literal|0
decl_stmt|;
name|u_short
name|alo
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|sendalot
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|int
name|idle
decl_stmt|;
endif|#
directive|endif
name|struct
name|mbuf
modifier|*
name|mprev
decl_stmt|;
name|IPX_LOCK_ASSERT
argument_list|(
name|cb
operator|->
name|s_ipxpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|!=
name|NULL
condition|)
block|{
name|int
name|mtu
init|=
name|cb
operator|->
name|s_mtu
decl_stmt|;
name|int
name|datalen
decl_stmt|;
comment|/* 		 * Make sure that packet isn't too big. 		 */
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|mprev
operator|=
name|m
expr_stmt|;
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EOR
condition|)
name|recordp
operator|=
literal|1
expr_stmt|;
block|}
name|datalen
operator|=
operator|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_HO
operator|)
condition|?
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|spxhdr
argument_list|)
else|:
name|len
expr_stmt|;
if|if
condition|(
name|datalen
operator|>
name|mtu
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_PI
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
block|}
else|else
block|{
name|int
name|oldEM
init|=
name|cb
operator|->
name|s_cc
operator|&
name|SPX_EM
decl_stmt|;
name|cb
operator|->
name|s_cc
operator|&=
operator|~
name|SPX_EM
expr_stmt|;
while|while
condition|(
name|len
operator|>
name|mtu
condition|)
block|{
name|m
operator|=
name|m_copym
argument_list|(
name|m0
argument_list|,
literal|0
argument_list|,
name|mtu
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|cb
operator|->
name|s_cc
operator||=
name|oldEM
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
if|if
condition|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_NEWCALL
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mm
init|=
name|m
decl_stmt|;
name|spx_newchecks
index|[
literal|7
index|]
operator|++
expr_stmt|;
while|while
condition|(
name|mm
operator|!=
name|NULL
condition|)
block|{
name|mm
operator|->
name|m_flags
operator|&=
operator|~
name|M_EOR
expr_stmt|;
name|mm
operator|=
name|mm
operator|->
name|m_next
expr_stmt|;
block|}
block|}
name|error
operator|=
name|spx_output
argument_list|(
name|cb
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cb
operator|->
name|s_cc
operator||=
name|oldEM
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|m_adj
argument_list|(
name|m0
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
name|len
operator|-=
name|mtu
expr_stmt|;
block|}
name|cb
operator|->
name|s_cc
operator||=
name|oldEM
expr_stmt|;
block|}
block|}
comment|/* 		 * Force length even, by adding a "garbage byte" if 		 * necessary. 		 */
if|if
condition|(
name|len
operator|&
literal|1
condition|)
block|{
name|m
operator|=
name|mprev
expr_stmt|;
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
operator|>=
literal|1
condition|)
name|m
operator|->
name|m_len
operator|++
expr_stmt|;
else|else
block|{
name|struct
name|mbuf
modifier|*
name|m1
init|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
decl_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m1
operator|->
name|m_len
operator|=
literal|1
expr_stmt|;
operator|*
operator|(
name|mtod
argument_list|(
name|m1
argument_list|,
name|u_char
operator|*
argument_list|)
operator|)
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|m1
expr_stmt|;
block|}
block|}
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* 		 * Fill in mbuf with extended SP header and addresses and 		 * length put into network format. 		 */
name|MH_ALIGN
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|spx
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|spx
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spx
operator|*
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_i
operator|=
operator|*
name|cb
operator|->
name|s_ipx
expr_stmt|;
name|si
operator|->
name|si_s
operator|=
name|cb
operator|->
name|s_shdr
expr_stmt|;
if|if
condition|(
operator|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_PI
operator|)
operator|&&
operator|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_HO
operator|)
condition|)
block|{
name|struct
name|spxhdr
modifier|*
name|sh
decl_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|m0
operator|=
name|m_pullup
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|m
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
block|}
name|sh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|spxhdr
operator|*
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_dt
operator|=
name|sh
operator|->
name|spx_dt
expr_stmt|;
name|si
operator|->
name|si_cc
operator||=
name|sh
operator|->
name|spx_cc
operator|&
name|SPX_EM
expr_stmt|;
name|m0
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
expr_stmt|;
block|}
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cb
operator|->
name|s_flags2
operator|&
name|SF_NEWCALL
operator|)
operator|&&
name|recordp
condition|)
block|{
name|si
operator|->
name|si_cc
operator||=
name|SPX_EM
expr_stmt|;
name|spx_newchecks
index|[
literal|8
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|->
name|s_oobflags
operator|&
name|SF_SOOB
condition|)
block|{
comment|/* 			 * Per jqj@cornell: Make sure OB packets convey 			 * exactly 1 byte.  If the packet is 1 byte or 			 * larger, we have already guaranted there to be at 			 * least one garbage byte for the checksum, and extra 			 * bytes shouldn't hurt! 			 */
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
condition|)
block|{
name|si
operator|->
name|si_cc
operator||=
name|SPX_OB
expr_stmt|;
name|len
operator|=
operator|(
literal|1
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
name|si
operator|->
name|si_len
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
operator|(
operator|(
name|len
operator|-
literal|1
operator|)
operator||
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* 		 * Queue stuff up for output. 		 */
name|sbappendrecord
argument_list|(
name|sb
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_seq
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
name|idle
operator|=
operator|(
name|cb
operator|->
name|s_smax
operator|==
operator|(
name|cb
operator|->
name|s_rack
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|again
label|:
name|sendalot
operator|=
literal|0
expr_stmt|;
name|off
operator|=
name|cb
operator|->
name|s_snxt
operator|-
name|cb
operator|->
name|s_rack
expr_stmt|;
name|win
operator|=
name|min
argument_list|(
name|cb
operator|->
name|s_swnd
argument_list|,
operator|(
name|cb
operator|->
name|s_cwnd
operator|/
name|CUNIT
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If in persist timeout with window of 0, send a probe.  Otherwise, 	 * if window is small but nonzero and timer expired, send what we can 	 * and go into transmit state. 	 */
if|if
condition|(
name|cb
operator|->
name|s_force
operator|==
literal|1
operator|+
name|SPXT_PERSIST
condition|)
block|{
if|if
condition|(
name|win
operator|!=
literal|0
condition|)
block|{
name|cb
operator|->
name|s_timer
index|[
name|SPXT_PERSIST
index|]
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_rxtshift
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|span
operator|=
name|cb
operator|->
name|s_seq
operator|-
name|cb
operator|->
name|s_rack
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|span
argument_list|,
name|win
argument_list|)
operator|-
name|off
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Window shrank after we went into it.  If window shrank to 		 * 0, cancel pending restransmission and pull s_snxt back to 		 * (closed) window.  We will enter persist state below.  If 		 * the widndow didn't close completely, just wait for an ACK. 		 */
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|win
operator|==
literal|0
condition|)
block|{
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_snxt
operator|=
name|cb
operator|->
name|s_rack
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|>
literal|1
condition|)
name|sendalot
operator|=
literal|1
expr_stmt|;
name|rcv_win
operator|=
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* 	 * Send if we owe peer an ACK. 	 */
if|if
condition|(
name|cb
operator|->
name|s_oobflags
operator|&
name|SF_SOOB
condition|)
block|{
comment|/* 		 * Must transmit this out of band packet. 		 */
name|cb
operator|->
name|s_oobflags
operator|&=
operator|~
name|SF_SOOB
expr_stmt|;
name|sendalot
operator|=
literal|1
expr_stmt|;
name|spxstat
operator|.
name|spxs_sndurg
operator|++
expr_stmt|;
goto|goto
name|found
goto|;
block|}
if|if
condition|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_ACKNOW
condition|)
goto|goto
name|send
goto|;
if|if
condition|(
name|cb
operator|->
name|s_state
operator|<
name|TCPS_ESTABLISHED
condition|)
goto|goto
name|send
goto|;
comment|/* 	 * Silly window can't happen in spx.  Code from TCP deleted. 	 */
if|if
condition|(
name|len
condition|)
goto|goto
name|send
goto|;
comment|/* 	 * Compare available window to amount of window known to peer (as 	 * advertised window less next expected input.)  If the difference is 	 * at least two packets or at least 35% of the mximum possible 	 * window, then want to send a window update to peer. 	 */
if|if
condition|(
name|rcv_win
operator|>
literal|0
condition|)
block|{
name|u_short
name|delta
init|=
literal|1
operator|+
name|cb
operator|->
name|s_alo
operator|-
name|cb
operator|->
name|s_ack
decl_stmt|;
name|int
name|adv
init|=
name|rcv_win
operator|-
operator|(
name|delta
operator|*
name|cb
operator|->
name|s_mtu
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|==
literal|0
operator|&&
name|adv
operator|>=
operator|(
literal|2
operator|*
name|cb
operator|->
name|s_mtu
operator|)
operator|)
operator|||
operator|(
literal|100
operator|*
name|adv
operator|/
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|>=
literal|35
operator|)
condition|)
block|{
name|spxstat
operator|.
name|spxs_sndwinup
operator|++
expr_stmt|;
name|cb
operator|->
name|s_flags
operator||=
name|SF_ACKNOW
expr_stmt|;
goto|goto
name|send
goto|;
block|}
block|}
comment|/* 	 * Many comments from tcp_output.c are appropriate here including ... 	 * If send window is too small, there is data to transmit, and no 	 * retransmit or persist is pending, then go to persist state.  If 	 * nothing happens soon, send when timer expires: if window is 	 * nonzero, transmit what we can, otherwise send a probe. 	 */
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_cc
operator|&&
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|==
literal|0
operator|&&
name|cb
operator|->
name|s_timer
index|[
name|SPXT_PERSIST
index|]
operator|==
literal|0
condition|)
block|{
name|cb
operator|->
name|s_rxtshift
operator|=
literal|0
expr_stmt|;
name|spx_setpersist
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * No reason to send a packet, just return. 	 */
name|cb
operator|->
name|s_outx
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|send
label|:
comment|/* 	 * Find requested packet. 	 */
name|si
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|cb
operator|->
name|s_want
operator|=
name|cb
operator|->
name|s_snxt
expr_stmt|;
for|for
control|(
name|m
operator|=
name|sb
operator|->
name|sb_mb
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_act
control|)
block|{
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spx
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|SSEQ_LEQ
argument_list|(
name|cb
operator|->
name|s_snxt
argument_list|,
name|si
operator|->
name|si_seq
argument_list|)
condition|)
break|break;
block|}
name|found
label|:
if|if
condition|(
name|si
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|si
operator|->
name|si_seq
operator|==
name|cb
operator|->
name|s_snxt
condition|)
name|cb
operator|->
name|s_snxt
operator|++
expr_stmt|;
else|else
name|spxstat
operator|.
name|spxs_sndvoid
operator|++
operator|,
name|si
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * Update window. 	 */
if|if
condition|(
name|rcv_win
operator|<
literal|0
condition|)
name|rcv_win
operator|=
literal|0
expr_stmt|;
name|alo
operator|=
name|cb
operator|->
name|s_ack
operator|-
literal|1
operator|+
operator|(
name|rcv_win
operator|/
operator|(
operator|(
name|short
operator|)
name|cb
operator|->
name|s_mtu
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|alo
argument_list|,
name|cb
operator|->
name|s_alo
argument_list|)
condition|)
name|alo
operator|=
name|cb
operator|->
name|s_alo
expr_stmt|;
if|if
condition|(
name|si
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Must make a copy of this packet for ipx_output to monkey 		 * with. 		 */
name|m
operator|=
name|m_copy
argument_list|(
name|dtom
argument_list|(
name|si
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|M_COPYALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spx
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|cb
operator|->
name|s_smax
argument_list|)
condition|)
name|spxstat
operator|.
name|spxs_sndrexmitpack
operator|++
expr_stmt|;
else|else
name|spxstat
operator|.
name|spxs_sndpack
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cb
operator|->
name|s_force
operator|||
name|cb
operator|->
name|s_flags
operator|&
name|SF_ACKNOW
condition|)
block|{
comment|/* 		 * Must send an acknowledgement or a probe. 		 */
if|if
condition|(
name|cb
operator|->
name|s_force
condition|)
name|spxstat
operator|.
name|spxs_sndprobe
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_ACKNOW
condition|)
name|spxstat
operator|.
name|spxs_sndacks
operator|++
expr_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
comment|/* 		 * Fill in mbuf with extended SP header and addresses and 		 * length put into network format. 		 */
name|MH_ALIGN
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|spx
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
expr_stmt|;
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spx
operator|*
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_i
operator|=
operator|*
name|cb
operator|->
name|s_ipx
expr_stmt|;
name|si
operator|->
name|si_s
operator|=
name|cb
operator|->
name|s_shdr
expr_stmt|;
name|si
operator|->
name|si_seq
operator|=
name|cb
operator|->
name|s_smax
operator|+
literal|1
expr_stmt|;
name|si
operator|->
name|si_len
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_cc
operator||=
name|SPX_SP
expr_stmt|;
block|}
else|else
block|{
name|cb
operator|->
name|s_outx
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspxs
condition|)
name|spx_trace
argument_list|(
name|SA_OUTPUT
argument_list|,
name|cb
operator|->
name|s_state
argument_list|,
name|cb
argument_list|,
name|si
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Stuff checksum and output datagram. 	 */
if|if
condition|(
operator|(
name|si
operator|->
name|si_cc
operator|&
name|SPX_SP
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|s_force
operator|!=
operator|(
literal|1
operator|+
name|SPXT_PERSIST
operator|)
operator|||
name|cb
operator|->
name|s_timer
index|[
name|SPXT_PERSIST
index|]
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If this is a new packet and we are not currently 			 * timing anything, time this one. 			 */
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_smax
argument_list|,
name|si
operator|->
name|si_seq
argument_list|)
condition|)
block|{
name|cb
operator|->
name|s_smax
operator|=
name|si
operator|->
name|si_seq
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_rtt
operator|==
literal|0
condition|)
block|{
name|spxstat
operator|.
name|spxs_segstimed
operator|++
expr_stmt|;
name|cb
operator|->
name|s_rtseq
operator|=
name|si
operator|->
name|si_seq
expr_stmt|;
name|cb
operator|->
name|s_rtt
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 			 * Set rexmt timer if not currently set, initial 			 * value for retransmit timer is smoothed round-trip 			 * time + 2 * round-trip time variance.  Initialize 			 * shift counter which is used for backoff of 			 * retransmit time. 			 */
if|if
condition|(
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|==
literal|0
operator|&&
name|cb
operator|->
name|s_snxt
operator|!=
name|cb
operator|->
name|s_rack
condition|)
block|{
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|=
name|cb
operator|->
name|s_rxtcur
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_timer
index|[
name|SPXT_PERSIST
index|]
condition|)
block|{
name|cb
operator|->
name|s_timer
index|[
name|SPXT_PERSIST
index|]
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_rxtshift
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_smax
argument_list|,
name|si
operator|->
name|si_seq
argument_list|)
condition|)
name|cb
operator|->
name|s_smax
operator|=
name|si
operator|->
name|si_seq
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cb
operator|->
name|s_state
operator|<
name|TCPS_ESTABLISHED
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|s_rtt
operator|==
literal|0
condition|)
name|cb
operator|->
name|s_rtt
operator|=
literal|1
expr_stmt|;
comment|/* Time initial handshake */
if|if
condition|(
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|==
literal|0
condition|)
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|=
name|cb
operator|->
name|s_rxtcur
expr_stmt|;
block|}
comment|/* 	 * Do not request acks when we ack their data packets or when we do a 	 * gratuitous window update. 	 */
if|if
condition|(
operator|(
operator|(
name|si
operator|->
name|si_cc
operator|&
name|SPX_SP
operator|)
operator|==
literal|0
operator|)
operator|||
name|cb
operator|->
name|s_force
condition|)
name|si
operator|->
name|si_cc
operator||=
name|SPX_SA
expr_stmt|;
name|si
operator|->
name|si_seq
operator|=
name|htons
argument_list|(
name|si
operator|->
name|si_seq
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_alo
operator|=
name|htons
argument_list|(
name|alo
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_ack
operator|=
name|htons
argument_list|(
name|cb
operator|->
name|s_ack
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipxcksum
condition|)
name|si
operator|->
name|si_sum
operator|=
name|ipx_cksum
argument_list|(
name|m
argument_list|,
name|ntohs
argument_list|(
name|si
operator|->
name|si_len
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|si
operator|->
name|si_sum
operator|=
literal|0xffff
expr_stmt|;
name|cb
operator|->
name|s_outx
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspxs
condition|)
name|spx_trace
argument_list|(
name|SA_OUTPUT
argument_list|,
name|cb
operator|->
name|s_state
argument_list|,
name|cb
argument_list|,
name|si
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DONTROUTE
condition|)
name|error
operator|=
name|ipx_outputfl
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|,
name|IPX_ROUTETOIF
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ipx_outputfl
argument_list|(
name|m
argument_list|,
operator|&
name|cb
operator|->
name|s_ipxpcb
operator|->
name|ipxp_route
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|spxstat
operator|.
name|spxs_sndtotal
operator|++
expr_stmt|;
comment|/* 	 * Data sent (as far as we can tell).  If this advertises a larger 	 * window than any other segment, then remember the size of the 	 * advertized window.  Any pending ACK has now been sent. 	 */
name|cb
operator|->
name|s_force
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_flags
operator|&=
operator|~
operator|(
name|SF_ACKNOW
operator||
name|SF_DELACK
operator|)
expr_stmt|;
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|alo
argument_list|,
name|cb
operator|->
name|s_alo
argument_list|)
condition|)
name|cb
operator|->
name|s_alo
operator|=
name|alo
expr_stmt|;
if|if
condition|(
name|sendalot
condition|)
goto|goto
name|again
goto|;
name|cb
operator|->
name|s_outx
operator|=
literal|5
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|spx_do_persist_panics
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|spx_setpersist
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|)
block|{
name|int
name|t
init|=
operator|(
operator|(
name|cb
operator|->
name|s_srtt
operator|>>
literal|2
operator|)
operator|+
name|cb
operator|->
name|s_rttvar
operator|)
operator|>>
literal|1
decl_stmt|;
name|IPX_LOCK_ASSERT
argument_list|(
name|cb
operator|->
name|s_ipxpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|&&
name|spx_do_persist_panics
condition|)
name|panic
argument_list|(
literal|"spx_output REXMT"
argument_list|)
expr_stmt|;
comment|/* 	 * Start/restart persistance timer. 	 */
name|SPXT_RANGESET
argument_list|(
name|cb
operator|->
name|s_timer
index|[
name|SPXT_PERSIST
index|]
argument_list|,
name|t
operator|*
name|spx_backoff
index|[
name|cb
operator|->
name|s_rxtshift
index|]
argument_list|,
name|SPXTV_PERSMIN
argument_list|,
name|SPXTV_PERSMAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_rxtshift
operator|<
name|SPX_MAXRXTSHIFT
condition|)
name|cb
operator|->
name|s_rxtshift
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|int
name|spx_ctloutput
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|struct
name|spxhdr
name|spxhdr
decl_stmt|;
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|error
decl_stmt|;
name|short
name|soptval
decl_stmt|;
name|u_short
name|usoptval
decl_stmt|;
name|int
name|optval
decl_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ipxp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_ctloutput: ipxp == NULL"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * This will have to be changed when we do more general stacking of 	 * protocols. 	 */
if|if
condition|(
name|sopt
operator|->
name|sopt_level
operator|!=
name|IPXPROTO_SPX
condition|)
return|return
operator|(
name|ipx_ctloutput
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|)
operator|)
return|;
name|IPX_LOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipxp
operator|->
name|ipxp_flags
operator|&
name|IPXP_DROPPED
condition|)
block|{
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ECONNRESET
operator|)
return|;
block|}
name|IPX_LOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_ctloutput: cb == NULL"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_dir
condition|)
block|{
case|case
name|SOPT_GET
case|:
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|SO_HEADERS_ON_INPUT
case|:
name|mask
operator|=
name|SF_HI
expr_stmt|;
goto|goto
name|get_flags
goto|;
case|case
name|SO_HEADERS_ON_OUTPUT
case|:
name|mask
operator|=
name|SF_HO
expr_stmt|;
name|get_flags
label|:
name|soptval
operator|=
name|cb
operator|->
name|s_flags
operator|&
name|mask
expr_stmt|;
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|soptval
argument_list|,
sizeof|sizeof
argument_list|(
name|soptval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SO_MTU
case|:
name|usoptval
operator|=
name|cb
operator|->
name|s_mtu
expr_stmt|;
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|usoptval
argument_list|,
sizeof|sizeof
argument_list|(
name|usoptval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SO_LAST_HEADER
case|:
name|spxhdr
operator|=
name|cb
operator|->
name|s_rhdr
expr_stmt|;
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|spxhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|spxhdr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SO_DEFAULT_HEADERS
case|:
name|spxhdr
operator|=
name|cb
operator|->
name|s_shdr
expr_stmt|;
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|spxhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|spxhdr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
block|}
break|break;
case|case
name|SOPT_SET
case|:
comment|/* 		 * XXX Why are these shorts on get and ints on set?  That 		 * doesn't make any sense... 		 * 		 * XXXRW: Note, when we re-acquire the ipxp lock, we should 		 * re-check that it's not dropped. 		 */
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|SO_HEADERS_ON_INPUT
case|:
name|mask
operator|=
name|SF_HI
expr_stmt|;
goto|goto
name|set_head
goto|;
case|case
name|SO_HEADERS_ON_OUTPUT
case|:
name|mask
operator|=
name|SF_HO
expr_stmt|;
name|set_head
label|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|IPX_LOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_PI
condition|)
block|{
if|if
condition|(
name|optval
condition|)
name|cb
operator|->
name|s_flags
operator||=
name|mask
expr_stmt|;
else|else
name|cb
operator|->
name|s_flags
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SO_MTU
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|usoptval
argument_list|,
sizeof|sizeof
name|usoptval
argument_list|,
sizeof|sizeof
name|usoptval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* Unlocked write. */
name|cb
operator|->
name|s_mtu
operator|=
name|usoptval
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|SF_NEWCALL
case|case
name|SO_NEWCALL
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|IPX_LOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|optval
condition|)
block|{
name|cb
operator|->
name|s_flags2
operator||=
name|SF_NEWCALL
expr_stmt|;
name|spx_newchecks
index|[
literal|5
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
name|cb
operator|->
name|s_flags2
operator|&=
operator|~
name|SF_NEWCALL
expr_stmt|;
name|spx_newchecks
index|[
literal|6
index|]
operator|++
expr_stmt|;
block|}
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SO_DEFAULT_HEADERS
case|:
block|{
name|struct
name|spxhdr
name|sp
decl_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|sp
argument_list|,
sizeof|sizeof
name|sp
argument_list|,
sizeof|sizeof
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|IPX_LOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_dt
operator|=
name|sp
operator|.
name|spx_dt
expr_stmt|;
name|cb
operator|->
name|s_cc
operator|=
name|sp
operator|.
name|spx_cc
operator|&
name|SPX_EM
expr_stmt|;
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
block|}
break|break;
default|default:
name|panic
argument_list|(
literal|"spx_ctloutput: bad socket option direction"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|spx_usr_abort
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ipxp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_usr_abort: ipxp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_usr_abort: cb == NULL"
operator|)
argument_list|)
expr_stmt|;
name|IPX_LIST_LOCK
argument_list|()
expr_stmt|;
name|IPX_LOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|spx_drop
argument_list|(
name|cb
argument_list|,
name|ECONNABORTED
argument_list|)
expr_stmt|;
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|IPX_LIST_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Accept a connection.  Essentially all the work is done at higher levels;  * just return the address of the peer, storing through addr.  */
end_comment

begin_function
specifier|static
name|int
name|spx_accept
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|sockaddr_ipx
modifier|*
name|sipx
decl_stmt|,
name|ssipx
decl_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ipxp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_accept: ipxp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|sipx
operator|=
operator|&
name|ssipx
expr_stmt|;
name|bzero
argument_list|(
name|sipx
argument_list|,
sizeof|sizeof
expr|*
name|sipx
argument_list|)
expr_stmt|;
name|sipx
operator|->
name|sipx_len
operator|=
sizeof|sizeof
expr|*
name|sipx
expr_stmt|;
name|sipx
operator|->
name|sipx_family
operator|=
name|AF_IPX
expr_stmt|;
name|IPX_LOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|sipx
operator|->
name|sipx_addr
operator|=
name|ipxp
operator|->
name|ipxp_faddr
expr_stmt|;
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
operator|*
name|nam
operator|=
name|sodupsockaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sipx
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spx_attach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mm
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ipxp
operator|==
name|NULL
argument_list|,
operator|(
literal|"spx_attach: ipxp != NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|==
literal|0
operator|||
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
operator|(
name|u_long
operator|)
literal|3072
argument_list|,
operator|(
name|u_long
operator|)
literal|3072
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|MALLOC
argument_list|(
name|cb
argument_list|,
expr|struct
name|spxpcb
operator|*
argument_list|,
sizeof|sizeof
expr|*
name|cb
argument_list|,
name|M_PCB
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|mm
operator|=
name|m_getclr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mm
operator|==
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|cb
argument_list|,
name|M_PCB
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|IPX_LIST_LOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|ipx_pcballoc
argument_list|(
name|so
argument_list|,
operator|&
name|ipxpcb_list
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|IPX_LIST_UNLOCK
argument_list|()
expr_stmt|;
name|m_free
argument_list|(
name|mm
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cb
argument_list|,
name|M_PCB
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|ipxp
operator|->
name|ipxp_flags
operator||=
name|IPXP_SPX
expr_stmt|;
name|cb
operator|->
name|s_ipx
operator|=
name|mtod
argument_list|(
name|mm
argument_list|,
expr|struct
name|ipx
operator|*
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_LISTEN
expr_stmt|;
name|cb
operator|->
name|s_smax
operator|=
operator|-
literal|1
expr_stmt|;
name|cb
operator|->
name|s_swl1
operator|=
operator|-
literal|1
expr_stmt|;
name|cb
operator|->
name|s_q
operator|.
name|si_next
operator|=
name|cb
operator|->
name|s_q
operator|.
name|si_prev
operator|=
operator|&
name|cb
operator|->
name|s_q
expr_stmt|;
name|cb
operator|->
name|s_ipxpcb
operator|=
name|ipxp
expr_stmt|;
name|cb
operator|->
name|s_mtu
operator|=
literal|576
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|spx
argument_list|)
expr_stmt|;
name|sb
operator|=
operator|&
name|so
operator|->
name|so_snd
expr_stmt|;
name|cb
operator|->
name|s_cwnd
operator|=
name|sbspace
argument_list|(
name|sb
argument_list|)
operator|*
name|CUNIT
operator|/
name|cb
operator|->
name|s_mtu
expr_stmt|;
name|cb
operator|->
name|s_ssthresh
operator|=
name|cb
operator|->
name|s_cwnd
expr_stmt|;
name|cb
operator|->
name|s_cwmx
operator|=
name|sbspace
argument_list|(
name|sb
argument_list|)
operator|*
name|CUNIT
operator|/
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|spx
argument_list|)
operator|)
expr_stmt|;
comment|/* 	 * Above is recomputed when connecting to account for changed 	 * buffering or mtu's. 	 */
name|cb
operator|->
name|s_rtt
operator|=
name|SPXTV_SRTTBASE
expr_stmt|;
name|cb
operator|->
name|s_rttvar
operator|=
name|SPXTV_SRTTDFLT
operator|<<
literal|2
expr_stmt|;
name|SPXT_RANGESET
argument_list|(
name|cb
operator|->
name|s_rxtcur
argument_list|,
operator|(
operator|(
name|SPXTV_SRTTBASE
operator|>>
literal|2
operator|)
operator|+
operator|(
name|SPXTV_SRTTDFLT
operator|<<
literal|2
operator|)
operator|)
operator|>>
literal|1
argument_list|,
name|SPXTV_MIN
argument_list|,
name|SPXTV_REXMTMAX
argument_list|)
expr_stmt|;
name|ipxp
operator|->
name|ipxp_pcb
operator|=
operator|(
name|caddr_t
operator|)
name|cb
expr_stmt|;
name|IPX_LIST_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|spx_pcbdetach
parameter_list|(
name|struct
name|ipxpcb
modifier|*
name|ipxp
parameter_list|)
block|{
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|struct
name|spx_q
modifier|*
name|s
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|IPX_LOCK_ASSERT
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_pcbdetach: cb == NULL"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|cb
operator|->
name|s_q
operator|.
name|si_next
expr_stmt|;
while|while
condition|(
name|s
operator|!=
operator|&
operator|(
name|cb
operator|->
name|s_q
operator|)
condition|)
block|{
name|s
operator|=
name|s
operator|->
name|si_next
expr_stmt|;
name|remque
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|m
operator|=
name|dtom
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|m_free
argument_list|(
name|dtom
argument_list|(
name|cb
operator|->
name|s_ipx
argument_list|)
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cb
argument_list|,
name|M_PCB
argument_list|)
expr_stmt|;
name|ipxp
operator|->
name|ipxp_pcb
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|spx_bind
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ipxp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_bind: ipxp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|IPX_LIST_LOCK
argument_list|()
expr_stmt|;
name|IPX_LOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipxp
operator|->
name|ipxp_flags
operator|&
name|IPXP_DROPPED
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|ipx_pcbbind
argument_list|(
name|ipxp
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|out
label|:
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|IPX_LIST_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|spx_usr_close
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ipxp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_usr_close: ipxp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_usr_close: cb == NULL"
operator|)
argument_list|)
expr_stmt|;
name|IPX_LIST_LOCK
argument_list|()
expr_stmt|;
name|IPX_LOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_state
operator|>
name|TCPS_LISTEN
condition|)
name|spx_disconnect
argument_list|(
name|cb
argument_list|)
expr_stmt|;
else|else
name|spx_close
argument_list|(
name|cb
argument_list|)
expr_stmt|;
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|IPX_LIST_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initiate connection to peer.  Enter SYN_SENT state, and mark socket as  * connecting.  Start keep-alive timer, setup prototype header, send initial  * system packet requesting connection.  */
end_comment

begin_function
specifier|static
name|int
name|spx_connect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ipxp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_connect: ipxp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_connect: cb == NULL"
operator|)
argument_list|)
expr_stmt|;
name|IPX_LIST_LOCK
argument_list|()
expr_stmt|;
name|IPX_LOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipxp
operator|->
name|ipxp_flags
operator|&
name|IPXP_DROPPED
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|spx_connect_end
goto|;
block|}
if|if
condition|(
name|ipxp
operator|->
name|ipxp_lport
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ipx_pcbbind
argument_list|(
name|ipxp
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|spx_connect_end
goto|;
block|}
name|error
operator|=
name|ipx_pcbconnect
argument_list|(
name|ipxp
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|spx_connect_end
goto|;
name|soisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|spxstat
operator|.
name|spxs_connattempt
operator|++
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_SYN_SENT
expr_stmt|;
name|cb
operator|->
name|s_did
operator|=
literal|0
expr_stmt|;
name|spx_template
argument_list|(
name|cb
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPXT_KEEP
index|]
operator|=
name|SPXTV_KEEP
expr_stmt|;
name|cb
operator|->
name|s_force
operator|=
literal|1
operator|+
name|SPXTV_KEEP
expr_stmt|;
comment|/* 	 * Other party is required to respond to the port I send from, but he 	 * is not required to answer from where I am sending to, so allow 	 * wildcarding.  Original port I am sending to is still saved in 	 * cb->s_dport. 	 */
name|ipxp
operator|->
name|ipxp_fport
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|spx_output
argument_list|(
name|cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|spx_connect_end
label|:
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|IPX_LIST_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|spx_detach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
comment|/* 	 * XXXRW: Should assert appropriately detached. 	 */
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ipxp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_detach: ipxp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_detach: cb == NULL"
operator|)
argument_list|)
expr_stmt|;
name|IPX_LIST_LOCK
argument_list|()
expr_stmt|;
name|IPX_LOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|spx_pcbdetach
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|ipx_pcbfree
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|IPX_LIST_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We may decide later to implement connection closing handshaking at the spx  * level optionally.  Here is the hook to do it:  */
end_comment

begin_function
specifier|static
name|int
name|spx_usr_disconnect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ipxp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_usr_disconnect: ipxp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_usr_disconnect: cb == NULL"
operator|)
argument_list|)
expr_stmt|;
name|IPX_LIST_LOCK
argument_list|()
expr_stmt|;
name|IPX_LOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipxp
operator|->
name|ipxp_flags
operator|&
name|IPXP_DROPPED
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|spx_disconnect
argument_list|(
name|cb
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|IPX_LIST_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spx_listen
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|backlog
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ipxp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_listen: ipxp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_listen: cb == NULL"
operator|)
argument_list|)
expr_stmt|;
name|IPX_LIST_LOCK
argument_list|()
expr_stmt|;
name|IPX_LOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipxp
operator|->
name|ipxp_flags
operator|&
name|IPXP_DROPPED
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|error
operator|=
name|solisten_proto_check
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|ipxp
operator|->
name|ipxp_lport
operator|==
literal|0
condition|)
name|error
operator|=
name|ipx_pcbbind
argument_list|(
name|ipxp
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|cb
operator|->
name|s_state
operator|=
name|TCPS_LISTEN
expr_stmt|;
name|solisten_proto
argument_list|(
name|so
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
block|}
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|out
label|:
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|IPX_LIST_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * After a receive, possibly send acknowledgment updating allocation.  */
end_comment

begin_function
specifier|static
name|int
name|spx_rcvd
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ipxp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_rcvd: ipxp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_rcvd: cb == NULL"
operator|)
argument_list|)
expr_stmt|;
name|IPX_LOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipxp
operator|->
name|ipxp_flags
operator|&
name|IPXP_DROPPED
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cb
operator|->
name|s_flags
operator||=
name|SF_RVD
expr_stmt|;
name|spx_output
argument_list|(
name|cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_flags
operator|&=
operator|~
name|SF_RVD
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spx_rcvoob
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ipxp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_rcvoob: ipxp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_rcvoob: cb == NULL"
operator|)
argument_list|)
expr_stmt|;
name|IPX_LOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipxp
operator|->
name|ipxp_flags
operator|&
name|IPXP_DROPPED
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cb
operator|->
name|s_oobflags
operator|&
name|SF_IOOB
operator|)
operator|||
name|so
operator|->
name|so_oobmark
operator|||
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_RCVATMARK
operator|)
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|1
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|=
name|cb
operator|->
name|s_iobc
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
name|out
label|:
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spx_send
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|controlp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ipxp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_send: ipxp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_send: cb == NULL"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|IPX_LOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipxp
operator|->
name|ipxp_flags
operator|&
name|IPXP_DROPPED
condition|)
block|{
name|error
operator|=
name|ECONNRESET
expr_stmt|;
goto|goto
name|spx_send_end
goto|;
block|}
if|if
condition|(
name|flags
operator|&
name|PRUS_OOB
condition|)
block|{
if|if
condition|(
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
operator|<
operator|-
literal|512
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|spx_send_end
goto|;
block|}
name|cb
operator|->
name|s_oobflags
operator||=
name|SF_SOOB
expr_stmt|;
block|}
if|if
condition|(
name|controlp
operator|!=
name|NULL
condition|)
block|{
name|u_short
modifier|*
name|p
init|=
name|mtod
argument_list|(
name|controlp
argument_list|,
name|u_short
operator|*
argument_list|)
decl_stmt|;
name|spx_newchecks
index|[
literal|2
index|]
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|5
operator|)
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* XXXX, for testing */
name|cb
operator|->
name|s_shdr
operator|.
name|spx_dt
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
name|p
index|[
literal|2
index|]
operator|)
expr_stmt|;
name|spx_newchecks
index|[
literal|3
index|]
operator|++
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|controlp
argument_list|)
expr_stmt|;
block|}
name|controlp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|spx_output
argument_list|(
name|cb
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|spx_send_end
label|:
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|controlp
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|controlp
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spx_shutdown
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ipxp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_shutdown: ipxp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_shutdown: cb == NULL"
operator|)
argument_list|)
expr_stmt|;
name|socantsendmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|IPX_LIST_LOCK
argument_list|()
expr_stmt|;
name|IPX_LOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipxp
operator|->
name|ipxp_flags
operator|&
name|IPXP_DROPPED
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|spx_usrclosed
argument_list|(
name|cb
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|IPX_LIST_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spx_sp_attach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|so
operator|->
name|so_pcb
operator|==
name|NULL
argument_list|,
operator|(
literal|"spx_sp_attach: so_pcb != NULL"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|spx_attach
argument_list|(
name|so
argument_list|,
name|proto
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ipxp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_sp_attach: ipxp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_sp_attach: cb == NULL"
operator|)
argument_list|)
expr_stmt|;
name|IPX_LOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_flags
operator||=
operator|(
name|SF_HI
operator||
name|SF_HO
operator||
name|SF_PI
operator|)
expr_stmt|;
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create template to be used to send spx packets on a connection.  Called  * after host entry created, fills in a skeletal spx header (choosing  * connection id), minimizing the amount of work necessary when the  * connection is used.  */
end_comment

begin_function
specifier|static
name|void
name|spx_template
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|)
block|{
name|struct
name|ipxpcb
modifier|*
name|ipxp
init|=
name|cb
operator|->
name|s_ipxpcb
decl_stmt|;
name|struct
name|ipx
modifier|*
name|ipx
init|=
name|cb
operator|->
name|s_ipx
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
operator|(
name|ipxp
operator|->
name|ipxp_socket
operator|->
name|so_snd
operator|)
decl_stmt|;
name|IPX_LOCK_ASSERT
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|ipx
operator|->
name|ipx_pt
operator|=
name|IPXPROTO_SPX
expr_stmt|;
name|ipx
operator|->
name|ipx_sna
operator|=
name|ipxp
operator|->
name|ipxp_laddr
expr_stmt|;
name|ipx
operator|->
name|ipx_dna
operator|=
name|ipxp
operator|->
name|ipxp_faddr
expr_stmt|;
name|SPX_LOCK
argument_list|()
expr_stmt|;
name|cb
operator|->
name|s_sid
operator|=
name|htons
argument_list|(
name|spx_iss
argument_list|)
expr_stmt|;
name|spx_iss
operator|+=
name|SPX_ISSINCR
operator|/
literal|2
expr_stmt|;
name|SPX_UNLOCK
argument_list|()
expr_stmt|;
name|cb
operator|->
name|s_alo
operator|=
literal|1
expr_stmt|;
name|cb
operator|->
name|s_cwnd
operator|=
operator|(
name|sbspace
argument_list|(
name|sb
argument_list|)
operator|*
name|CUNIT
operator|)
operator|/
name|cb
operator|->
name|s_mtu
expr_stmt|;
comment|/* Try to expand fast to full complement of large packets. */
name|cb
operator|->
name|s_ssthresh
operator|=
name|cb
operator|->
name|s_cwnd
expr_stmt|;
name|cb
operator|->
name|s_cwmx
operator|=
operator|(
name|sbspace
argument_list|(
name|sb
argument_list|)
operator|*
name|CUNIT
operator|)
operator|/
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|spx
argument_list|)
operator|)
expr_stmt|;
comment|/* But allow for lots of little packets as well. */
name|cb
operator|->
name|s_cwmx
operator|=
name|max
argument_list|(
name|cb
operator|->
name|s_cwmx
argument_list|,
name|cb
operator|->
name|s_cwnd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Close a SPIP control block.  Wake up any sleepers.  We used to free any  * queued packets and cb->s_ipx here, but now we defer that until the pcb is  * discarded.  */
end_comment

begin_function
name|void
name|spx_close
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|)
block|{
name|struct
name|ipxpcb
modifier|*
name|ipxp
init|=
name|cb
operator|->
name|s_ipxpcb
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|ipxp
operator|->
name|ipxp_socket
decl_stmt|;
name|KASSERT
argument_list|(
name|ipxp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_close: ipxp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|IPX_LIST_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|IPX_LOCK_ASSERT
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|ipxp
operator|->
name|ipxp_flags
operator||=
name|IPXP_DROPPED
expr_stmt|;
name|soisdisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|spxstat
operator|.
name|spxs_closed
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Someday we may do level 3 handshaking to close a connection or send a  * xerox style error.  For now, just close.  cb will always be invalid after  * this call.  */
end_comment

begin_function
specifier|static
name|void
name|spx_usrclosed
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|)
block|{
name|IPX_LIST_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|IPX_LOCK_ASSERT
argument_list|(
name|cb
operator|->
name|s_ipxpcb
argument_list|)
expr_stmt|;
name|spx_close
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * cb will always be invalid after this call.  */
end_comment

begin_function
specifier|static
name|void
name|spx_disconnect
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|)
block|{
name|IPX_LIST_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|IPX_LOCK_ASSERT
argument_list|(
name|cb
operator|->
name|s_ipxpcb
argument_list|)
expr_stmt|;
name|spx_close
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Drop connection, reporting the specified error.  cb will always be invalid  * after this call.  */
end_comment

begin_function
specifier|static
name|void
name|spx_drop
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|,
name|int
name|errno
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|cb
operator|->
name|s_ipxpcb
operator|->
name|ipxp_socket
decl_stmt|;
name|IPX_LIST_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|IPX_LOCK_ASSERT
argument_list|(
name|cb
operator|->
name|s_ipxpcb
argument_list|)
expr_stmt|;
comment|/* 	 * Someday, in the xerox world we will generate error protocol 	 * packets announcing that the socket has gone away. 	 */
if|if
condition|(
name|TCPS_HAVERCVDSYN
argument_list|(
name|cb
operator|->
name|s_state
argument_list|)
condition|)
block|{
name|spxstat
operator|.
name|spxs_drops
operator|++
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_CLOSED
expr_stmt|;
comment|/*tcp_output(cb);*/
block|}
else|else
name|spxstat
operator|.
name|spxs_conndrops
operator|++
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
name|errno
expr_stmt|;
name|spx_close
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fast timeout routine for processing delayed acks.  */
end_comment

begin_function
name|void
name|spx_fasttimo
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|IPX_LIST_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ipxp
argument_list|,
argument|&ipxpcb_list
argument_list|,
argument|ipxp_list
argument_list|)
block|{
name|IPX_LOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ipxp
operator|->
name|ipxp_flags
operator|&
name|IPXP_SPX
operator|)
operator|||
operator|(
name|ipxp
operator|->
name|ipxp_flags
operator|&
name|IPXP_DROPPED
operator|)
condition|)
block|{
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_DELACK
condition|)
block|{
name|cb
operator|->
name|s_flags
operator|&=
operator|~
name|SF_DELACK
expr_stmt|;
name|cb
operator|->
name|s_flags
operator||=
name|SF_ACKNOW
expr_stmt|;
name|spxstat
operator|.
name|spxs_delack
operator|++
expr_stmt|;
name|spx_output
argument_list|(
name|cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
block|}
name|IPX_LIST_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * spx protocol timeout routine called every 500 ms.  Updates the timers in  * all active pcb's and causes finite state machine actions if timers expire.  */
end_comment

begin_function
name|void
name|spx_slowtimo
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Search through tcb's and update active timers.  Once, timers could 	 * free ipxp's, but now we do that only when detaching a socket. 	 */
name|IPX_LIST_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ipxp
argument_list|,
argument|&ipxpcb_list
argument_list|,
argument|ipxp_list
argument_list|)
block|{
name|IPX_LOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ipxp
operator|->
name|ipxp_flags
operator|&
name|IPXP_SPX
operator|)
operator|||
operator|(
name|ipxp
operator|->
name|ipxp_flags
operator|&
name|IPXP_DROPPED
operator|)
condition|)
block|{
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|cb
operator|=
operator|(
expr|struct
name|spxpcb
operator|*
operator|)
name|ipxp
operator|->
name|ipxp_pcb
expr_stmt|;
name|KASSERT
argument_list|(
name|cb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"spx_slowtimo: cb == NULL"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPXT_NTIMERS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cb
operator|->
name|s_timer
index|[
name|i
index|]
operator|&&
operator|--
name|cb
operator|->
name|s_timer
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|spx_timers
argument_list|(
name|cb
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipxp
operator|->
name|ipxp_flags
operator|&
name|IPXP_DROPPED
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|ipxp
operator|->
name|ipxp_flags
operator|&
name|IPXP_DROPPED
operator|)
condition|)
block|{
name|cb
operator|->
name|s_idle
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_rtt
condition|)
name|cb
operator|->
name|s_rtt
operator|++
expr_stmt|;
block|}
name|IPX_UNLOCK
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
block|}
name|IPX_LIST_UNLOCK
argument_list|()
expr_stmt|;
name|SPX_LOCK
argument_list|()
expr_stmt|;
name|spx_iss
operator|+=
name|SPX_ISSINCR
operator|/
name|PR_SLOWHZ
expr_stmt|;
comment|/* increment iss */
name|SPX_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SPX timer processing.  */
end_comment

begin_function
specifier|static
name|void
name|spx_timers
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|,
name|int
name|timer
parameter_list|)
block|{
name|long
name|rexmt
decl_stmt|;
name|int
name|win
decl_stmt|;
name|IPX_LIST_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|IPX_LOCK_ASSERT
argument_list|(
name|cb
operator|->
name|s_ipxpcb
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_force
operator|=
literal|1
operator|+
name|timer
expr_stmt|;
switch|switch
condition|(
name|timer
condition|)
block|{
case|case
name|SPXT_2MSL
case|:
comment|/* 		 * 2 MSL timeout in shutdown went off.  TCP deletes 		 * connection control block. 		 */
name|printf
argument_list|(
literal|"spx: SPXT_2MSL went off for no reason\n"
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|timer
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SPXT_REXMT
case|:
comment|/* 		 * Retransmission timer went off.  Message has not been acked 		 * within retransmit interval.  Back off to a longer 		 * retransmit interval and retransmit one packet. 		 */
if|if
condition|(
operator|++
name|cb
operator|->
name|s_rxtshift
operator|>
name|SPX_MAXRXTSHIFT
condition|)
block|{
name|cb
operator|->
name|s_rxtshift
operator|=
name|SPX_MAXRXTSHIFT
expr_stmt|;
name|spxstat
operator|.
name|spxs_timeoutdrop
operator|++
expr_stmt|;
name|spx_drop
argument_list|(
name|cb
argument_list|,
name|ETIMEDOUT
argument_list|)
expr_stmt|;
break|break;
block|}
name|spxstat
operator|.
name|spxs_rexmttimeo
operator|++
expr_stmt|;
name|rexmt
operator|=
operator|(
operator|(
name|cb
operator|->
name|s_srtt
operator|>>
literal|2
operator|)
operator|+
name|cb
operator|->
name|s_rttvar
operator|)
operator|>>
literal|1
expr_stmt|;
name|rexmt
operator|*=
name|spx_backoff
index|[
name|cb
operator|->
name|s_rxtshift
index|]
expr_stmt|;
name|SPXT_RANGESET
argument_list|(
name|cb
operator|->
name|s_rxtcur
argument_list|,
name|rexmt
argument_list|,
name|SPXTV_MIN
argument_list|,
name|SPXTV_REXMTMAX
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|=
name|cb
operator|->
name|s_rxtcur
expr_stmt|;
comment|/* 		 * If we have backed off fairly far, our srtt estimate is 		 * probably bogus.  Clobber it so we'll take the next rtt 		 * measurement as our srtt; move the current srtt into rttvar 		 * to keep the current retransmit times until then. 		 */
if|if
condition|(
name|cb
operator|->
name|s_rxtshift
operator|>
name|SPX_MAXRXTSHIFT
operator|/
literal|4
condition|)
block|{
name|cb
operator|->
name|s_rttvar
operator|+=
operator|(
name|cb
operator|->
name|s_srtt
operator|>>
literal|2
operator|)
expr_stmt|;
name|cb
operator|->
name|s_srtt
operator|=
literal|0
expr_stmt|;
block|}
name|cb
operator|->
name|s_snxt
operator|=
name|cb
operator|->
name|s_rack
expr_stmt|;
comment|/* 		 * If timing a packet, stop the timer. 		 */
name|cb
operator|->
name|s_rtt
operator|=
literal|0
expr_stmt|;
comment|/* 		 * See very long discussion in tcp_timer.c about congestion 		 * window and sstrhesh. 		 */
name|win
operator|=
name|min
argument_list|(
name|cb
operator|->
name|s_swnd
argument_list|,
operator|(
name|cb
operator|->
name|s_cwnd
operator|/
name|CUNIT
operator|)
argument_list|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|win
operator|<
literal|2
condition|)
name|win
operator|=
literal|2
expr_stmt|;
name|cb
operator|->
name|s_cwnd
operator|=
name|CUNIT
expr_stmt|;
name|cb
operator|->
name|s_ssthresh
operator|=
name|win
operator|*
name|CUNIT
expr_stmt|;
name|spx_output
argument_list|(
name|cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPXT_PERSIST
case|:
comment|/* 		 * Persistance timer into zero window.  Force a probe to be 		 * sent. 		 */
name|spxstat
operator|.
name|spxs_persisttimeo
operator|++
expr_stmt|;
name|spx_setpersist
argument_list|(
name|cb
argument_list|)
expr_stmt|;
name|spx_output
argument_list|(
name|cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|SPXT_KEEP
case|:
comment|/* 		 * Keep-alive timer went off; send something or drop 		 * connection if idle for too long. 		 */
name|spxstat
operator|.
name|spxs_keeptimeo
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_state
operator|<
name|TCPS_ESTABLISHED
condition|)
goto|goto
name|dropit
goto|;
if|if
condition|(
name|cb
operator|->
name|s_ipxpcb
operator|->
name|ipxp_socket
operator|->
name|so_options
operator|&
name|SO_KEEPALIVE
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|s_idle
operator|>=
name|SPXTV_MAXIDLE
condition|)
goto|goto
name|dropit
goto|;
name|spxstat
operator|.
name|spxs_keepprobe
operator|++
expr_stmt|;
name|spx_output
argument_list|(
name|cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|cb
operator|->
name|s_idle
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPXT_KEEP
index|]
operator|=
name|SPXTV_KEEP
expr_stmt|;
break|break;
name|dropit
label|:
name|spxstat
operator|.
name|spxs_keepdrops
operator|++
expr_stmt|;
name|spx_drop
argument_list|(
name|cb
argument_list|,
name|ETIMEDOUT
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"spx_timers: unknown timer %d"
argument_list|,
name|timer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

