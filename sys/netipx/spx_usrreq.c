begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995, Mike Mitchell  * Copyright (c) 1984, 1985, 1986, 1987, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)spx_usrreq.h  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netipx/ipx.h>
end_include

begin_include
include|#
directive|include
file|<netipx/ipx_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netipx/ipx_var.h>
end_include

begin_include
include|#
directive|include
file|<netipx/spx.h>
end_include

begin_include
include|#
directive|include
file|<netipx/spx_timer.h>
end_include

begin_include
include|#
directive|include
file|<netipx/spx_var.h>
end_include

begin_include
include|#
directive|include
file|<netipx/spx_debug.h>
end_include

begin_comment
comment|/*  * SPX protocol implementation.  */
end_comment

begin_decl_stmt
specifier|static
name|u_short
name|spx_iss
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|spx_newchecks
index|[
literal|50
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|spx_hardnosed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|spx_use_delack
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|traceallspxs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|spx
name|spx_savesi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|spx_istat
name|spx_istat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Following was struct spxstat spxstat; */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|spxstat
end_ifndef

begin_define
define|#
directive|define
name|spxstat
value|spx_istat.newstats
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|spx_backoff
index|[
name|SPX_MAXRXTSHIFT
operator|+
literal|1
index|]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|8
block|,
literal|16
block|,
literal|32
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|,
literal|64
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|spxpcb
modifier|*
name|spx_close
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|spxpcb
modifier|*
name|spx_disconnect
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|spxpcb
modifier|*
name|spx_drop
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|,
name|int
name|errno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_output
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_reass
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|,
name|struct
name|spx
modifier|*
name|si
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spx_setpersist
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spx_template
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|spxpcb
modifier|*
name|spx_timers
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|,
name|int
name|timer
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|spxpcb
modifier|*
name|spx_usrclosed
parameter_list|(
name|struct
name|spxpcb
modifier|*
name|cb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_usr_abort
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_accept
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_attach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_bind
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_connect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_detach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_usr_disconnect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_listen
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_rcvd
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_rcvoob
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_send
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_shutdown
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spx_sp_attach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|pr_usrreqs
name|spx_usrreqs
init|=
block|{
name|spx_usr_abort
block|,
name|spx_accept
block|,
name|spx_attach
block|,
name|spx_bind
block|,
name|spx_connect
block|,
name|pru_connect2_notsupp
block|,
name|ipx_control
block|,
name|spx_detach
block|,
name|spx_usr_disconnect
block|,
name|spx_listen
block|,
name|ipx_peeraddr
block|,
name|spx_rcvd
block|,
name|spx_rcvoob
block|,
name|spx_send
block|,
name|pru_sense_null
block|,
name|spx_shutdown
block|,
name|ipx_sockaddr
block|,
name|sosend
block|,
name|soreceive
block|,
name|sopoll
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pr_usrreqs
name|spx_usrreq_sps
init|=
block|{
name|spx_usr_abort
block|,
name|spx_accept
block|,
name|spx_sp_attach
block|,
name|spx_bind
block|,
name|spx_connect
block|,
name|pru_connect2_notsupp
block|,
name|ipx_control
block|,
name|spx_detach
block|,
name|spx_usr_disconnect
block|,
name|spx_listen
block|,
name|ipx_peeraddr
block|,
name|spx_rcvd
block|,
name|spx_rcvoob
block|,
name|spx_send
block|,
name|pru_sense_null
block|,
name|spx_shutdown
block|,
name|ipx_sockaddr
block|,
name|sosend
block|,
name|soreceive
block|,
name|sopoll
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|spx_init
parameter_list|()
block|{
name|spx_iss
operator|=
literal|1
expr_stmt|;
comment|/* WRONG !! should fish it out of TODR */
block|}
end_function

begin_function
name|void
name|spx_input
parameter_list|(
name|m
parameter_list|,
name|ipxp
parameter_list|)
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
block|{
specifier|register
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
specifier|register
name|struct
name|spx
modifier|*
name|si
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spx
operator|*
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|dropsocket
init|=
literal|0
decl_stmt|;
name|short
name|ostate
init|=
literal|0
decl_stmt|;
name|spxstat
operator|.
name|spxs_rcvtotal
operator|++
expr_stmt|;
if|if
condition|(
name|ipxp
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"No ipxpcb in spx_input\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|spxstat
operator|.
name|spxs_rcvshort
operator|++
expr_stmt|;
return|return;
block|}
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spx
operator|*
argument_list|)
expr_stmt|;
block|}
name|si
operator|->
name|si_seq
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_seq
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_ack
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_ack
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_alo
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_alo
argument_list|)
expr_stmt|;
name|so
operator|=
name|ipxp
operator|->
name|ipxp_socket
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspxs
condition|)
block|{
name|ostate
operator|=
name|cb
operator|->
name|s_state
expr_stmt|;
name|spx_savesi
operator|=
operator|*
name|si
expr_stmt|;
block|}
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_ACCEPTCONN
condition|)
block|{
name|struct
name|spxpcb
modifier|*
name|ocb
init|=
name|cb
decl_stmt|;
name|so
operator|=
name|sonewconn
argument_list|(
name|so
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
block|{
goto|goto
name|drop
goto|;
block|}
comment|/* 		 * This is ugly, but .... 		 * 		 * Mark socket as temporary until we're 		 * committed to keeping it.  The code at 		 * ``drop'' and ``dropwithreset'' check the 		 * flag dropsocket to see if the temporary 		 * socket created here should be discarded. 		 * We mark the socket as discardable until 		 * we're committed to it below in TCPS_LISTEN. 		 */
name|dropsocket
operator|++
expr_stmt|;
name|ipxp
operator|=
operator|(
expr|struct
name|ipxpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
name|ipxp
operator|->
name|ipxp_laddr
operator|=
name|si
operator|->
name|si_dna
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_mtu
operator|=
name|ocb
operator|->
name|s_mtu
expr_stmt|;
comment|/* preserve sockopts */
name|cb
operator|->
name|s_flags
operator|=
name|ocb
operator|->
name|s_flags
expr_stmt|;
comment|/* preserve sockopts */
name|cb
operator|->
name|s_flags2
operator|=
name|ocb
operator|->
name|s_flags2
expr_stmt|;
comment|/* preserve sockopts */
name|cb
operator|->
name|s_state
operator|=
name|TCPS_LISTEN
expr_stmt|;
block|}
comment|/* 	 * Packet received on connection. 	 * reset idle time and keep-alive timer; 	 */
name|cb
operator|->
name|s_idle
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPXT_KEEP
index|]
operator|=
name|SPXTV_KEEP
expr_stmt|;
switch|switch
condition|(
name|cb
operator|->
name|s_state
condition|)
block|{
case|case
name|TCPS_LISTEN
case|:
block|{
name|struct
name|sockaddr_ipx
modifier|*
name|sipx
decl_stmt|,
name|ssipx
decl_stmt|;
name|struct
name|ipx_addr
name|laddr
decl_stmt|;
comment|/* 		 * If somebody here was carying on a conversation 		 * and went away, and his pen pal thinks he can 		 * still talk, we get the misdirected packet. 		 */
if|if
condition|(
name|spx_hardnosed
operator|&&
operator|(
name|si
operator|->
name|si_did
operator|!=
literal|0
operator|||
name|si
operator|->
name|si_seq
operator|!=
literal|0
operator|)
condition|)
block|{
name|spx_istat
operator|.
name|gonawy
operator|++
expr_stmt|;
goto|goto
name|dropwithreset
goto|;
block|}
name|sipx
operator|=
operator|&
name|ssipx
expr_stmt|;
name|bzero
argument_list|(
name|sipx
argument_list|,
sizeof|sizeof
expr|*
name|sipx
argument_list|)
expr_stmt|;
name|sipx
operator|->
name|sipx_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sipx
argument_list|)
expr_stmt|;
name|sipx
operator|->
name|sipx_family
operator|=
name|AF_IPX
expr_stmt|;
name|sipx
operator|->
name|sipx_addr
operator|=
name|si
operator|->
name|si_sna
expr_stmt|;
name|laddr
operator|=
name|ipxp
operator|->
name|ipxp_laddr
expr_stmt|;
if|if
condition|(
name|ipx_nullhost
argument_list|(
name|laddr
argument_list|)
condition|)
name|ipxp
operator|->
name|ipxp_laddr
operator|=
name|si
operator|->
name|si_dna
expr_stmt|;
if|if
condition|(
name|ipx_pcbconnect
argument_list|(
name|ipxp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sipx
argument_list|,
operator|&
name|thread0
argument_list|)
condition|)
block|{
name|ipxp
operator|->
name|ipxp_laddr
operator|=
name|laddr
expr_stmt|;
name|spx_istat
operator|.
name|noconn
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|spx_template
argument_list|(
name|cb
argument_list|)
expr_stmt|;
name|dropsocket
operator|=
literal|0
expr_stmt|;
comment|/* committed to socket */
name|cb
operator|->
name|s_did
operator|=
name|si
operator|->
name|si_sid
expr_stmt|;
name|cb
operator|->
name|s_rack
operator|=
name|si
operator|->
name|si_ack
expr_stmt|;
name|cb
operator|->
name|s_ralo
operator|=
name|si
operator|->
name|si_alo
expr_stmt|;
define|#
directive|define
name|THREEWAYSHAKE
ifdef|#
directive|ifdef
name|THREEWAYSHAKE
name|cb
operator|->
name|s_state
operator|=
name|TCPS_SYN_RECEIVED
expr_stmt|;
name|cb
operator|->
name|s_force
operator|=
literal|1
operator|+
name|SPXT_KEEP
expr_stmt|;
name|spxstat
operator|.
name|spxs_accepts
operator|++
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPXT_KEEP
index|]
operator|=
name|SPXTV_KEEP
expr_stmt|;
block|}
break|break;
comment|/* 	 * This state means that we have heard a response 	 * to our acceptance of their connection 	 * It is probably logically unnecessary in this 	 * implementation. 	 */
case|case
name|TCPS_SYN_RECEIVED
case|:
block|{
if|if
condition|(
name|si
operator|->
name|si_did
operator|!=
name|cb
operator|->
name|s_sid
condition|)
block|{
name|spx_istat
operator|.
name|wrncon
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
endif|#
directive|endif
name|ipxp
operator|->
name|ipxp_fport
operator|=
name|si
operator|->
name|si_sport
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPXT_KEEP
index|]
operator|=
name|SPXTV_KEEP
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_ESTABLISHED
expr_stmt|;
name|spxstat
operator|.
name|spxs_accepts
operator|++
expr_stmt|;
block|}
break|break;
comment|/* 	 * This state means that we have gotten a response 	 * to our attempt to establish a connection. 	 * We fill in the data from the other side, 	 * telling us which port to respond to, instead of the well- 	 * known one we might have sent to in the first place. 	 * We also require that this is a response to our 	 * connection id. 	 */
case|case
name|TCPS_SYN_SENT
case|:
if|if
condition|(
name|si
operator|->
name|si_did
operator|!=
name|cb
operator|->
name|s_sid
condition|)
block|{
name|spx_istat
operator|.
name|notme
operator|++
expr_stmt|;
goto|goto
name|drop
goto|;
block|}
name|spxstat
operator|.
name|spxs_connects
operator|++
expr_stmt|;
name|cb
operator|->
name|s_did
operator|=
name|si
operator|->
name|si_sid
expr_stmt|;
name|cb
operator|->
name|s_rack
operator|=
name|si
operator|->
name|si_ack
expr_stmt|;
name|cb
operator|->
name|s_ralo
operator|=
name|si
operator|->
name|si_alo
expr_stmt|;
name|cb
operator|->
name|s_dport
operator|=
name|ipxp
operator|->
name|ipxp_fport
operator|=
name|si
operator|->
name|si_sport
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_flags
operator||=
name|SF_ACKNOW
expr_stmt|;
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_ESTABLISHED
expr_stmt|;
comment|/* Use roundtrip time of connection request for initial rtt */
if|if
condition|(
name|cb
operator|->
name|s_rtt
condition|)
block|{
name|cb
operator|->
name|s_srtt
operator|=
name|cb
operator|->
name|s_rtt
operator|<<
literal|3
expr_stmt|;
name|cb
operator|->
name|s_rttvar
operator|=
name|cb
operator|->
name|s_rtt
operator|<<
literal|1
expr_stmt|;
name|SPXT_RANGESET
argument_list|(
name|cb
operator|->
name|s_rxtcur
argument_list|,
operator|(
operator|(
name|cb
operator|->
name|s_srtt
operator|>>
literal|2
operator|)
operator|+
name|cb
operator|->
name|s_rttvar
operator|)
operator|>>
literal|1
argument_list|,
name|SPXTV_MIN
argument_list|,
name|SPXTV_REXMTMAX
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_rtt
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspxs
condition|)
name|spx_trace
argument_list|(
name|SA_INPUT
argument_list|,
operator|(
name|u_char
operator|)
name|ostate
argument_list|,
name|cb
argument_list|,
operator|&
name|spx_savesi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ipx
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ipx
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ipx
argument_list|)
expr_stmt|;
if|if
condition|(
name|spx_reass
argument_list|(
name|cb
argument_list|,
name|si
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|->
name|s_force
operator|||
operator|(
name|cb
operator|->
name|s_flags
operator|&
operator|(
name|SF_ACKNOW
operator||
name|SF_WIN
operator||
name|SF_RXT
operator|)
operator|)
condition|)
name|spx_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_flags
operator|&=
operator|~
operator|(
name|SF_WIN
operator||
name|SF_RXT
operator|)
expr_stmt|;
return|return;
name|dropwithreset
label|:
if|if
condition|(
name|dropsocket
condition|)
name|soabort
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_seq
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_seq
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_ack
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_ack
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_alo
operator|=
name|ntohs
argument_list|(
name|si
operator|->
name|si_alo
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_ipxpcb
operator|->
name|ipxp_socket
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspxs
condition|)
name|spx_trace
argument_list|(
name|SA_DROP
argument_list|,
operator|(
name|u_char
operator|)
name|ostate
argument_list|,
name|cb
argument_list|,
operator|&
name|spx_savesi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
name|drop
label|:
name|bad
label|:
if|if
condition|(
name|cb
operator|==
literal|0
operator|||
name|cb
operator|->
name|s_ipxpcb
operator|->
name|ipxp_socket
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspxs
condition|)
name|spx_trace
argument_list|(
name|SA_DROP
argument_list|,
operator|(
name|u_char
operator|)
name|ostate
argument_list|,
name|cb
argument_list|,
operator|&
name|spx_savesi
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|spxrexmtthresh
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is structurally similar to the tcp reassembly routine  * but its function is somewhat different:  It merely queues  * packets up, and suppresses duplicates.  */
end_comment

begin_function
specifier|static
name|int
name|spx_reass
parameter_list|(
name|cb
parameter_list|,
name|si
parameter_list|)
specifier|register
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
specifier|register
name|struct
name|spx
modifier|*
name|si
decl_stmt|;
block|{
specifier|register
name|struct
name|spx_q
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|socket
modifier|*
name|so
init|=
name|cb
operator|->
name|s_ipxpcb
operator|->
name|ipxp_socket
decl_stmt|;
name|char
name|packetp
init|=
name|cb
operator|->
name|s_flags
operator|&
name|SF_HI
decl_stmt|;
name|int
name|incr
decl_stmt|;
name|char
name|wakeup
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|si
operator|==
name|SI
argument_list|(
literal|0
argument_list|)
condition|)
goto|goto
name|present
goto|;
comment|/* 	 * Update our news from them. 	 */
if|if
condition|(
name|si
operator|->
name|si_cc
operator|&
name|SPX_SA
condition|)
name|cb
operator|->
name|s_flags
operator||=
operator|(
name|spx_use_delack
condition|?
name|SF_DELACK
else|:
name|SF_ACKNOW
operator|)
expr_stmt|;
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|si
operator|->
name|si_alo
argument_list|,
name|cb
operator|->
name|s_ralo
argument_list|)
condition|)
name|cb
operator|->
name|s_flags
operator||=
name|SF_WIN
expr_stmt|;
if|if
condition|(
name|SSEQ_LEQ
argument_list|(
name|si
operator|->
name|si_ack
argument_list|,
name|cb
operator|->
name|s_rack
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|si
operator|->
name|si_cc
operator|&
name|SPX_SP
operator|)
operator|&&
name|cb
operator|->
name|s_rack
operator|!=
operator|(
name|cb
operator|->
name|s_smax
operator|+
literal|1
operator|)
condition|)
block|{
name|spxstat
operator|.
name|spxs_rcvdupack
operator|++
expr_stmt|;
comment|/* 			 * If this is a completely duplicate ack 			 * and other conditions hold, we assume 			 * a packet has been dropped and retransmit 			 * it exactly as in tcp_input(). 			 */
if|if
condition|(
name|si
operator|->
name|si_ack
operator|!=
name|cb
operator|->
name|s_rack
operator|||
name|si
operator|->
name|si_alo
operator|!=
name|cb
operator|->
name|s_ralo
condition|)
name|cb
operator|->
name|s_dupacks
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|++
name|cb
operator|->
name|s_dupacks
operator|==
name|spxrexmtthresh
condition|)
block|{
name|u_short
name|onxt
init|=
name|cb
operator|->
name|s_snxt
decl_stmt|;
name|int
name|cwnd
init|=
name|cb
operator|->
name|s_cwnd
decl_stmt|;
name|cb
operator|->
name|s_snxt
operator|=
name|si
operator|->
name|si_ack
expr_stmt|;
name|cb
operator|->
name|s_cwnd
operator|=
name|CUNIT
expr_stmt|;
name|cb
operator|->
name|s_force
operator|=
literal|1
operator|+
name|SPXT_REXMT
expr_stmt|;
name|spx_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|=
name|cb
operator|->
name|s_rxtcur
expr_stmt|;
name|cb
operator|->
name|s_rtt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cwnd
operator|>=
literal|4
operator|*
name|CUNIT
condition|)
name|cb
operator|->
name|s_cwnd
operator|=
name|cwnd
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|onxt
argument_list|,
name|cb
operator|->
name|s_snxt
argument_list|)
condition|)
name|cb
operator|->
name|s_snxt
operator|=
name|onxt
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
name|cb
operator|->
name|s_dupacks
operator|=
literal|0
expr_stmt|;
goto|goto
name|update_window
goto|;
block|}
name|cb
operator|->
name|s_dupacks
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If our correspondent acknowledges data we haven't sent 	 * TCP would drop the packet after acking.  We'll be a little 	 * more permissive 	 */
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|si
operator|->
name|si_ack
argument_list|,
operator|(
name|cb
operator|->
name|s_smax
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|spxstat
operator|.
name|spxs_rcvacktoomuch
operator|++
expr_stmt|;
name|si
operator|->
name|si_ack
operator|=
name|cb
operator|->
name|s_smax
operator|+
literal|1
expr_stmt|;
block|}
name|spxstat
operator|.
name|spxs_rcvackpack
operator|++
expr_stmt|;
comment|/* 	 * If transmit timer is running and timed sequence 	 * number was acked, update smoothed round trip time. 	 * See discussion of algorithm in tcp_input.c 	 */
if|if
condition|(
name|cb
operator|->
name|s_rtt
operator|&&
name|SSEQ_GT
argument_list|(
name|si
operator|->
name|si_ack
argument_list|,
name|cb
operator|->
name|s_rtseq
argument_list|)
condition|)
block|{
name|spxstat
operator|.
name|spxs_rttupdated
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_srtt
operator|!=
literal|0
condition|)
block|{
specifier|register
name|short
name|delta
decl_stmt|;
name|delta
operator|=
name|cb
operator|->
name|s_rtt
operator|-
operator|(
name|cb
operator|->
name|s_srtt
operator|>>
literal|3
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cb
operator|->
name|s_srtt
operator|+=
name|delta
operator|)
operator|<=
literal|0
condition|)
name|cb
operator|->
name|s_srtt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|delta
operator|=
operator|-
name|delta
expr_stmt|;
name|delta
operator|-=
operator|(
name|cb
operator|->
name|s_rttvar
operator|>>
literal|2
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cb
operator|->
name|s_rttvar
operator|+=
name|delta
operator|)
operator|<=
literal|0
condition|)
name|cb
operator|->
name|s_rttvar
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * No rtt measurement yet 			 */
name|cb
operator|->
name|s_srtt
operator|=
name|cb
operator|->
name|s_rtt
operator|<<
literal|3
expr_stmt|;
name|cb
operator|->
name|s_rttvar
operator|=
name|cb
operator|->
name|s_rtt
operator|<<
literal|1
expr_stmt|;
block|}
name|cb
operator|->
name|s_rtt
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_rxtshift
operator|=
literal|0
expr_stmt|;
name|SPXT_RANGESET
argument_list|(
name|cb
operator|->
name|s_rxtcur
argument_list|,
operator|(
operator|(
name|cb
operator|->
name|s_srtt
operator|>>
literal|2
operator|)
operator|+
name|cb
operator|->
name|s_rttvar
operator|)
operator|>>
literal|1
argument_list|,
name|SPXTV_MIN
argument_list|,
name|SPXTV_REXMTMAX
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If all outstanding data is acked, stop retransmit 	 * timer and remember to restart (more output or persist). 	 * If there is more data to be acked, restart retransmit 	 * timer, using current (possibly backed-off) value; 	 */
if|if
condition|(
name|si
operator|->
name|si_ack
operator|==
name|cb
operator|->
name|s_smax
operator|+
literal|1
condition|)
block|{
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_flags
operator||=
name|SF_RXT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cb
operator|->
name|s_timer
index|[
name|SPXT_PERSIST
index|]
operator|==
literal|0
condition|)
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|=
name|cb
operator|->
name|s_rxtcur
expr_stmt|;
comment|/* 	 * When new data is acked, open the congestion window. 	 * If the window gives us less than ssthresh packets 	 * in flight, open exponentially (maxseg at a time). 	 * Otherwise open linearly (maxseg^2 / cwnd at a time). 	 */
name|incr
operator|=
name|CUNIT
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_cwnd
operator|>
name|cb
operator|->
name|s_ssthresh
condition|)
name|incr
operator|=
name|max
argument_list|(
name|incr
operator|*
name|incr
operator|/
name|cb
operator|->
name|s_cwnd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_cwnd
operator|=
name|min
argument_list|(
name|cb
operator|->
name|s_cwnd
operator|+
name|incr
argument_list|,
name|cb
operator|->
name|s_cwmx
argument_list|)
expr_stmt|;
comment|/* 	 * Trim Acked data from output queue. 	 */
while|while
condition|(
operator|(
name|m
operator|=
name|so
operator|->
name|so_snd
operator|.
name|sb_mb
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SSEQ_LT
argument_list|(
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spx
operator|*
argument_list|)
operator|)
operator|->
name|si_seq
argument_list|,
name|si
operator|->
name|si_ack
argument_list|)
condition|)
name|sbdroprecord
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
name|sowwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_rack
operator|=
name|si
operator|->
name|si_ack
expr_stmt|;
name|update_window
label|:
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_snxt
argument_list|,
name|cb
operator|->
name|s_rack
argument_list|)
condition|)
name|cb
operator|->
name|s_snxt
operator|=
name|cb
operator|->
name|s_rack
expr_stmt|;
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_swl1
argument_list|,
name|si
operator|->
name|si_seq
argument_list|)
operator|||
operator|(
operator|(
name|cb
operator|->
name|s_swl1
operator|==
name|si
operator|->
name|si_seq
operator|&&
operator|(
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_swl2
argument_list|,
name|si
operator|->
name|si_ack
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|cb
operator|->
name|s_swl2
operator|==
name|si
operator|->
name|si_ack
operator|&&
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_ralo
argument_list|,
name|si
operator|->
name|si_alo
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* keep track of pure window updates */
if|if
condition|(
operator|(
name|si
operator|->
name|si_cc
operator|&
name|SPX_SP
operator|)
operator|&&
name|cb
operator|->
name|s_swl2
operator|==
name|si
operator|->
name|si_ack
operator|&&
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_ralo
argument_list|,
name|si
operator|->
name|si_alo
argument_list|)
condition|)
block|{
name|spxstat
operator|.
name|spxs_rcvwinupd
operator|++
expr_stmt|;
name|spxstat
operator|.
name|spxs_rcvdupack
operator|--
expr_stmt|;
block|}
name|cb
operator|->
name|s_ralo
operator|=
name|si
operator|->
name|si_alo
expr_stmt|;
name|cb
operator|->
name|s_swl1
operator|=
name|si
operator|->
name|si_seq
expr_stmt|;
name|cb
operator|->
name|s_swl2
operator|=
name|si
operator|->
name|si_ack
expr_stmt|;
name|cb
operator|->
name|s_swnd
operator|=
operator|(
literal|1
operator|+
name|si
operator|->
name|si_alo
operator|-
name|si
operator|->
name|si_ack
operator|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_swnd
operator|>
name|cb
operator|->
name|s_smxw
condition|)
name|cb
operator|->
name|s_smxw
operator|=
name|cb
operator|->
name|s_swnd
expr_stmt|;
name|cb
operator|->
name|s_flags
operator||=
name|SF_WIN
expr_stmt|;
block|}
comment|/* 	 * If this packet number is higher than that which 	 * we have allocated refuse it, unless urgent 	 */
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|cb
operator|->
name|s_alo
argument_list|)
condition|)
block|{
if|if
condition|(
name|si
operator|->
name|si_cc
operator|&
name|SPX_SP
condition|)
block|{
name|spxstat
operator|.
name|spxs_rcvwinprobe
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
name|spxstat
operator|.
name|spxs_rcvpackafterwin
operator|++
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|si_cc
operator|&
name|SPX_OB
condition|)
block|{
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|cb
operator|->
name|s_alo
operator|+
literal|60
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* else queue this packet; */
block|}
else|else
block|{
comment|/*register struct socket *so = cb->s_ipxpcb->ipxp_socket; 			if (so->so_state&& SS_NOFDREF) { 				spx_close(cb); 			} else 				       would crash system*/
name|spx_istat
operator|.
name|notyet
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|dtom
argument_list|(
name|si
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * If this is a system packet, we don't need to 	 * queue it up, and won't update acknowledge # 	 */
if|if
condition|(
name|si
operator|->
name|si_cc
operator|&
name|SPX_SP
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * We have already seen this packet, so drop. 	 */
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|cb
operator|->
name|s_ack
argument_list|)
condition|)
block|{
name|spx_istat
operator|.
name|bdreas
operator|++
expr_stmt|;
name|spxstat
operator|.
name|spxs_rcvduppack
operator|++
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|si_seq
operator|==
name|cb
operator|->
name|s_ack
operator|-
literal|1
condition|)
name|spx_istat
operator|.
name|lstdup
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Loop through all packets queued up to insert in 	 * appropriate sequence. 	 */
for|for
control|(
name|q
operator|=
name|cb
operator|->
name|s_q
operator|.
name|si_next
init|;
name|q
operator|!=
operator|&
name|cb
operator|->
name|s_q
condition|;
name|q
operator|=
name|q
operator|->
name|si_next
control|)
block|{
if|if
condition|(
name|si
operator|->
name|si_seq
operator|==
name|SI
argument_list|(
name|q
argument_list|)
operator|->
name|si_seq
condition|)
block|{
name|spxstat
operator|.
name|spxs_rcvduppack
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|SI
argument_list|(
name|q
argument_list|)
operator|->
name|si_seq
argument_list|)
condition|)
block|{
name|spxstat
operator|.
name|spxs_rcvoopack
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|insque
argument_list|(
name|si
argument_list|,
name|q
operator|->
name|si_prev
argument_list|)
expr_stmt|;
comment|/* 	 * If this packet is urgent, inform process 	 */
if|if
condition|(
name|si
operator|->
name|si_cc
operator|&
name|SPX_OB
condition|)
block|{
name|cb
operator|->
name|s_iobc
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|si
operator|)
index|[
literal|1
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
index|]
expr_stmt|;
name|sohasoutofband
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_oobflags
operator||=
name|SF_IOOB
expr_stmt|;
block|}
name|present
label|:
define|#
directive|define
name|SPINC
value|sizeof(struct spxhdr)
comment|/* 	 * Loop through all packets queued up to update acknowledge 	 * number, and present all acknowledged data to user; 	 * If in packet interface mode, show packet headers. 	 */
for|for
control|(
name|q
operator|=
name|cb
operator|->
name|s_q
operator|.
name|si_next
init|;
name|q
operator|!=
operator|&
name|cb
operator|->
name|s_q
condition|;
name|q
operator|=
name|q
operator|->
name|si_next
control|)
block|{
if|if
condition|(
name|SI
argument_list|(
name|q
argument_list|)
operator|->
name|si_seq
operator|==
name|cb
operator|->
name|s_ack
condition|)
block|{
name|cb
operator|->
name|s_ack
operator|++
expr_stmt|;
name|m
operator|=
name|dtom
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|SI
argument_list|(
name|q
argument_list|)
operator|->
name|si_cc
operator|&
name|SPX_OB
condition|)
block|{
name|cb
operator|->
name|s_oobflags
operator|&=
operator|~
name|SF_IOOB
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
condition|)
name|so
operator|->
name|so_oobmark
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
expr_stmt|;
else|else
name|so
operator|->
name|so_state
operator||=
name|SS_RCVATMARK
expr_stmt|;
block|}
name|q
operator|=
name|q
operator|->
name|si_prev
expr_stmt|;
name|remque
argument_list|(
name|q
operator|->
name|si_next
argument_list|)
expr_stmt|;
name|wakeup
operator|=
literal|1
expr_stmt|;
name|spxstat
operator|.
name|spxs_rcvpack
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SF_NEWCALL
if|if
condition|(
name|cb
operator|->
name|s_flags2
operator|&
name|SF_NEWCALL
condition|)
block|{
name|struct
name|spxhdr
modifier|*
name|sp
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spxhdr
operator|*
argument_list|)
decl_stmt|;
name|u_char
name|dt
init|=
name|sp
operator|->
name|spx_dt
decl_stmt|;
name|spx_newchecks
index|[
literal|4
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|dt
operator|!=
name|cb
operator|->
name|s_rhdr
operator|.
name|spx_dt
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mm
init|=
name|m_getclr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_CONTROL
argument_list|)
decl_stmt|;
name|spx_newchecks
index|[
literal|0
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|mm
operator|!=
name|NULL
condition|)
block|{
name|u_short
modifier|*
name|s
init|=
name|mtod
argument_list|(
name|mm
argument_list|,
name|u_short
operator|*
argument_list|)
decl_stmt|;
name|cb
operator|->
name|s_rhdr
operator|.
name|spx_dt
operator|=
name|dt
expr_stmt|;
name|mm
operator|->
name|m_len
operator|=
literal|5
expr_stmt|;
comment|/*XXX*/
name|s
index|[
literal|0
index|]
operator|=
literal|5
expr_stmt|;
name|s
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
name|s
index|[
literal|2
index|]
operator|)
operator|=
name|dt
expr_stmt|;
name|sbappend
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|mm
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sp
operator|->
name|spx_cc
operator|&
name|SPX_OB
condition|)
block|{
name|MCHTYPE
argument_list|(
name|m
argument_list|,
name|MT_OOBDATA
argument_list|)
expr_stmt|;
name|spx_newchecks
index|[
literal|1
index|]
operator|++
expr_stmt|;
name|so
operator|->
name|so_oobmark
operator|=
literal|0
expr_stmt|;
name|so
operator|->
name|so_state
operator|&=
operator|~
name|SS_RCVATMARK
expr_stmt|;
block|}
if|if
condition|(
name|packetp
operator|==
literal|0
condition|)
block|{
name|m
operator|->
name|m_data
operator|+=
name|SPINC
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|SPINC
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|SPINC
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sp
operator|->
name|spx_cc
operator|&
name|SPX_EM
operator|)
operator|||
name|packetp
condition|)
block|{
name|sbappendrecord
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|spx_newchecks
index|[
literal|9
index|]
operator|++
expr_stmt|;
block|}
else|else
name|sbappend
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|packetp
condition|)
block|{
name|sbappendrecord
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cb
operator|->
name|s_rhdr
operator|=
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spxhdr
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|SPINC
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|SPINC
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|SPINC
expr_stmt|;
name|sbappend
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
break|break;
block|}
if|if
condition|(
name|wakeup
condition|)
name|sorwakeup
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spx_ctlinput
parameter_list|(
name|cmd
parameter_list|,
name|arg_as_sa
parameter_list|,
name|dummy
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|arg_as_sa
decl_stmt|;
comment|/* XXX should be swapped with dummy */
name|void
modifier|*
name|dummy
decl_stmt|;
block|{
name|caddr_t
name|arg
init|=
operator|(
comment|/* XXX */
name|caddr_t
operator|)
name|arg_as_sa
decl_stmt|;
name|struct
name|ipx_addr
modifier|*
name|na
decl_stmt|;
name|struct
name|sockaddr_ipx
modifier|*
name|sipx
decl_stmt|;
if|if
condition|(
name|cmd
operator|<
literal|0
operator|||
name|cmd
operator|>
name|PRC_NCMDS
condition|)
return|return;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PRC_ROUTEDEAD
case|:
return|return;
case|case
name|PRC_IFDOWN
case|:
case|case
name|PRC_HOSTDEAD
case|:
case|case
name|PRC_HOSTUNREACH
case|:
name|sipx
operator|=
operator|(
expr|struct
name|sockaddr_ipx
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|sipx
operator|->
name|sipx_family
operator|!=
name|AF_IPX
condition|)
return|return;
name|na
operator|=
operator|&
name|sipx
operator|->
name|sipx_addr
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_function
name|int
name|spx_fixmtu
parameter_list|(
name|ipxp
parameter_list|)
specifier|register
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
block|{
specifier|register
name|struct
name|spxpcb
modifier|*
name|cb
init|=
operator|(
expr|struct
name|spxpcb
operator|*
operator|)
operator|(
name|ipxp
operator|->
name|ipxp_pcb
operator|)
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|spx
modifier|*
name|si
decl_stmt|;
name|struct
name|ipx_errp
modifier|*
name|ep
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|badseq
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|firstbad
decl_stmt|,
modifier|*
name|m0
decl_stmt|;
if|if
condition|(
name|cb
operator|!=
name|NULL
condition|)
block|{
comment|/*  		 * The notification that we have sent 		 * too much is bad news -- we will 		 * have to go through queued up so far 		 * splitting ones which are too big and 		 * reassigning sequence numbers and checksums. 		 * we should then retransmit all packets from 		 * one above the offending packet to the last one 		 * we had sent (or our allocation) 		 * then the offending one so that the any queued 		 * data at our destination will be discarded. 		 */
name|ep
operator|=
operator|(
expr|struct
name|ipx_errp
operator|*
operator|)
name|ipxp
operator|->
name|ipxp_notify_param
expr_stmt|;
name|sb
operator|=
operator|&
name|ipxp
operator|->
name|ipxp_socket
operator|->
name|so_snd
expr_stmt|;
name|cb
operator|->
name|s_mtu
operator|=
name|ep
operator|->
name|ipx_err_param
expr_stmt|;
name|badseq
operator|=
name|SI
argument_list|(
operator|&
name|ep
operator|->
name|ipx_err_ipx
argument_list|)
operator|->
name|si_seq
expr_stmt|;
for|for
control|(
name|m
operator|=
name|sb
operator|->
name|sb_mb
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_act
control|)
block|{
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spx
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|si_seq
operator|==
name|badseq
condition|)
break|break;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
name|firstbad
operator|=
name|m
expr_stmt|;
comment|/*for (;;) {*/
comment|/* calculate length */
for|for
control|(
name|m0
operator|=
name|m
operator|,
name|len
operator|=
literal|0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|cb
operator|->
name|s_mtu
condition|)
block|{ 			}
comment|/* FINISH THIS 		} */
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|spx_output
parameter_list|(
name|cb
parameter_list|,
name|m0
parameter_list|)
specifier|register
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|cb
operator|->
name|s_ipxpcb
operator|->
name|ipxp_socket
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|spx
modifier|*
name|si
init|=
operator|(
expr|struct
name|spx
operator|*
operator|)
name|NULL
decl_stmt|;
specifier|register
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
name|so
operator|->
name|so_snd
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|,
name|win
decl_stmt|,
name|rcv_win
decl_stmt|;
name|short
name|span
decl_stmt|,
name|off
decl_stmt|,
name|recordp
init|=
literal|0
decl_stmt|;
name|u_short
name|alo
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|sendalot
decl_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|int
name|idle
decl_stmt|;
endif|#
directive|endif
name|struct
name|mbuf
modifier|*
name|mprev
decl_stmt|;
if|if
condition|(
name|m0
operator|!=
name|NULL
condition|)
block|{
name|int
name|mtu
init|=
name|cb
operator|->
name|s_mtu
decl_stmt|;
name|int
name|datalen
decl_stmt|;
comment|/* 		 * Make sure that packet isn't too big. 		 */
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|mprev
operator|=
name|m
expr_stmt|;
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_EOR
condition|)
name|recordp
operator|=
literal|1
expr_stmt|;
block|}
name|datalen
operator|=
operator|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_HO
operator|)
condition|?
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|spxhdr
argument_list|)
else|:
name|len
expr_stmt|;
if|if
condition|(
name|datalen
operator|>
name|mtu
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_PI
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
block|}
else|else
block|{
name|int
name|oldEM
init|=
name|cb
operator|->
name|s_cc
operator|&
name|SPX_EM
decl_stmt|;
name|cb
operator|->
name|s_cc
operator|&=
operator|~
name|SPX_EM
expr_stmt|;
while|while
condition|(
name|len
operator|>
name|mtu
condition|)
block|{
comment|/* 					 * Here we are only being called 					 * from usrreq(), so it is OK to 					 * block. 					 */
name|m
operator|=
name|m_copym
argument_list|(
name|m0
argument_list|,
literal|0
argument_list|,
name|mtu
argument_list|,
name|M_TRYWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_NEWCALL
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mm
init|=
name|m
decl_stmt|;
name|spx_newchecks
index|[
literal|7
index|]
operator|++
expr_stmt|;
while|while
condition|(
name|mm
operator|!=
name|NULL
condition|)
block|{
name|mm
operator|->
name|m_flags
operator|&=
operator|~
name|M_EOR
expr_stmt|;
name|mm
operator|=
name|mm
operator|->
name|m_next
expr_stmt|;
block|}
block|}
name|error
operator|=
name|spx_output
argument_list|(
name|cb
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|cb
operator|->
name|s_cc
operator||=
name|oldEM
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|m_adj
argument_list|(
name|m0
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
name|len
operator|-=
name|mtu
expr_stmt|;
block|}
name|cb
operator|->
name|s_cc
operator||=
name|oldEM
expr_stmt|;
block|}
block|}
comment|/* 		 * Force length even, by adding a "garbage byte" if 		 * necessary. 		 */
if|if
condition|(
name|len
operator|&
literal|1
condition|)
block|{
name|m
operator|=
name|mprev
expr_stmt|;
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
operator|>=
literal|1
condition|)
name|m
operator|->
name|m_len
operator|++
expr_stmt|;
else|else
block|{
name|struct
name|mbuf
modifier|*
name|m1
init|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
decl_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m1
operator|->
name|m_len
operator|=
literal|1
expr_stmt|;
operator|*
operator|(
name|mtod
argument_list|(
name|m1
argument_list|,
name|u_char
operator|*
argument_list|)
operator|)
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|m1
expr_stmt|;
block|}
block|}
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* 		 * Fill in mbuf with extended SP header 		 * and addresses and length put into network format. 		 */
name|MH_ALIGN
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|spx
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|spx
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spx
operator|*
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_i
operator|=
operator|*
name|cb
operator|->
name|s_ipx
expr_stmt|;
name|si
operator|->
name|si_s
operator|=
name|cb
operator|->
name|s_shdr
expr_stmt|;
if|if
condition|(
operator|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_PI
operator|)
operator|&&
operator|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_HO
operator|)
condition|)
block|{
specifier|register
name|struct
name|spxhdr
modifier|*
name|sh
decl_stmt|;
if|if
condition|(
name|m0
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|m0
operator|=
name|m_pullup
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|m
operator|->
name|m_next
operator|=
name|m0
expr_stmt|;
block|}
name|sh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|spxhdr
operator|*
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_dt
operator|=
name|sh
operator|->
name|spx_dt
expr_stmt|;
name|si
operator|->
name|si_cc
operator||=
name|sh
operator|->
name|spx_cc
operator|&
name|SPX_EM
expr_stmt|;
name|m0
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
expr_stmt|;
block|}
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cb
operator|->
name|s_flags2
operator|&
name|SF_NEWCALL
operator|)
operator|&&
name|recordp
condition|)
block|{
name|si
operator|->
name|si_cc
operator||=
name|SPX_EM
expr_stmt|;
name|spx_newchecks
index|[
literal|8
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|->
name|s_oobflags
operator|&
name|SF_SOOB
condition|)
block|{
comment|/* 			 * Per jqj@cornell: 			 * make sure OB packets convey exactly 1 byte. 			 * If the packet is 1 byte or larger, we 			 * have already guaranted there to be at least 			 * one garbage byte for the checksum, and 			 * extra bytes shouldn't hurt! 			 */
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
condition|)
block|{
name|si
operator|->
name|si_cc
operator||=
name|SPX_OB
expr_stmt|;
name|len
operator|=
operator|(
literal|1
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
name|si
operator|->
name|si_len
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
operator|(
operator|(
name|len
operator|-
literal|1
operator|)
operator||
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* 		 * queue stuff up for output 		 */
name|sbappendrecord
argument_list|(
name|sb
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_seq
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
name|idle
operator|=
operator|(
name|cb
operator|->
name|s_smax
operator|==
operator|(
name|cb
operator|->
name|s_rack
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|again
label|:
name|sendalot
operator|=
literal|0
expr_stmt|;
name|off
operator|=
name|cb
operator|->
name|s_snxt
operator|-
name|cb
operator|->
name|s_rack
expr_stmt|;
name|win
operator|=
name|min
argument_list|(
name|cb
operator|->
name|s_swnd
argument_list|,
operator|(
name|cb
operator|->
name|s_cwnd
operator|/
name|CUNIT
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If in persist timeout with window of 0, send a probe. 	 * Otherwise, if window is small but nonzero 	 * and timer expired, send what we can and go into 	 * transmit state. 	 */
if|if
condition|(
name|cb
operator|->
name|s_force
operator|==
literal|1
operator|+
name|SPXT_PERSIST
condition|)
block|{
if|if
condition|(
name|win
operator|!=
literal|0
condition|)
block|{
name|cb
operator|->
name|s_timer
index|[
name|SPXT_PERSIST
index|]
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_rxtshift
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|span
operator|=
name|cb
operator|->
name|s_seq
operator|-
name|cb
operator|->
name|s_rack
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|span
argument_list|,
name|win
argument_list|)
operator|-
name|off
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
comment|/* 		 * Window shrank after we went into it. 		 * If window shrank to 0, cancel pending 		 * restransmission and pull s_snxt back 		 * to (closed) window.  We will enter persist 		 * state below.  If the widndow didn't close completely, 		 * just wait for an ACK. 		 */
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|win
operator|==
literal|0
condition|)
block|{
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_snxt
operator|=
name|cb
operator|->
name|s_rack
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|>
literal|1
condition|)
name|sendalot
operator|=
literal|1
expr_stmt|;
name|rcv_win
operator|=
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* 	 * Send if we owe peer an ACK. 	 */
if|if
condition|(
name|cb
operator|->
name|s_oobflags
operator|&
name|SF_SOOB
condition|)
block|{
comment|/* 		 * must transmit this out of band packet 		 */
name|cb
operator|->
name|s_oobflags
operator|&=
operator|~
name|SF_SOOB
expr_stmt|;
name|sendalot
operator|=
literal|1
expr_stmt|;
name|spxstat
operator|.
name|spxs_sndurg
operator|++
expr_stmt|;
goto|goto
name|found
goto|;
block|}
if|if
condition|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_ACKNOW
condition|)
goto|goto
name|send
goto|;
if|if
condition|(
name|cb
operator|->
name|s_state
operator|<
name|TCPS_ESTABLISHED
condition|)
goto|goto
name|send
goto|;
comment|/* 	 * Silly window can't happen in spx. 	 * Code from tcp deleted. 	 */
if|if
condition|(
name|len
condition|)
goto|goto
name|send
goto|;
comment|/* 	 * Compare available window to amount of window 	 * known to peer (as advertised window less 	 * next expected input.)  If the difference is at least two 	 * packets or at least 35% of the mximum possible window, 	 * then want to send a window update to peer. 	 */
if|if
condition|(
name|rcv_win
operator|>
literal|0
condition|)
block|{
name|u_short
name|delta
init|=
literal|1
operator|+
name|cb
operator|->
name|s_alo
operator|-
name|cb
operator|->
name|s_ack
decl_stmt|;
name|int
name|adv
init|=
name|rcv_win
operator|-
operator|(
name|delta
operator|*
name|cb
operator|->
name|s_mtu
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|==
literal|0
operator|&&
name|adv
operator|>=
operator|(
literal|2
operator|*
name|cb
operator|->
name|s_mtu
operator|)
operator|)
operator|||
operator|(
literal|100
operator|*
name|adv
operator|/
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|>=
literal|35
operator|)
condition|)
block|{
name|spxstat
operator|.
name|spxs_sndwinup
operator|++
expr_stmt|;
name|cb
operator|->
name|s_flags
operator||=
name|SF_ACKNOW
expr_stmt|;
goto|goto
name|send
goto|;
block|}
block|}
comment|/* 	 * Many comments from tcp_output.c are appropriate here 	 * including . . . 	 * If send window is too small, there is data to transmit, and no 	 * retransmit or persist is pending, then go to persist state. 	 * If nothing happens soon, send when timer expires: 	 * if window is nonzero, transmit what we can, 	 * otherwise send a probe. 	 */
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_cc
operator|&&
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|==
literal|0
operator|&&
name|cb
operator|->
name|s_timer
index|[
name|SPXT_PERSIST
index|]
operator|==
literal|0
condition|)
block|{
name|cb
operator|->
name|s_rxtshift
operator|=
literal|0
expr_stmt|;
name|spx_setpersist
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * No reason to send a packet, just return. 	 */
name|cb
operator|->
name|s_outx
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|send
label|:
comment|/* 	 * Find requested packet. 	 */
name|si
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|cb
operator|->
name|s_want
operator|=
name|cb
operator|->
name|s_snxt
expr_stmt|;
for|for
control|(
name|m
operator|=
name|sb
operator|->
name|sb_mb
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_act
control|)
block|{
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spx
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|SSEQ_LEQ
argument_list|(
name|cb
operator|->
name|s_snxt
argument_list|,
name|si
operator|->
name|si_seq
argument_list|)
condition|)
break|break;
block|}
name|found
label|:
if|if
condition|(
name|si
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|si
operator|->
name|si_seq
operator|==
name|cb
operator|->
name|s_snxt
condition|)
name|cb
operator|->
name|s_snxt
operator|++
expr_stmt|;
else|else
name|spxstat
operator|.
name|spxs_sndvoid
operator|++
operator|,
name|si
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * update window 	 */
if|if
condition|(
name|rcv_win
operator|<
literal|0
condition|)
name|rcv_win
operator|=
literal|0
expr_stmt|;
name|alo
operator|=
name|cb
operator|->
name|s_ack
operator|-
literal|1
operator|+
operator|(
name|rcv_win
operator|/
operator|(
operator|(
name|short
operator|)
name|cb
operator|->
name|s_mtu
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|alo
argument_list|,
name|cb
operator|->
name|s_alo
argument_list|)
condition|)
name|alo
operator|=
name|cb
operator|->
name|s_alo
expr_stmt|;
if|if
condition|(
name|si
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * must make a copy of this packet for 		 * ipx_output to monkey with 		 */
name|m
operator|=
name|m_copy
argument_list|(
name|dtom
argument_list|(
name|si
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|M_COPYALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spx
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|si
operator|->
name|si_seq
argument_list|,
name|cb
operator|->
name|s_smax
argument_list|)
condition|)
name|spxstat
operator|.
name|spxs_sndrexmitpack
operator|++
expr_stmt|;
else|else
name|spxstat
operator|.
name|spxs_sndpack
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cb
operator|->
name|s_force
operator|||
name|cb
operator|->
name|s_flags
operator|&
name|SF_ACKNOW
condition|)
block|{
comment|/* 		 * Must send an acknowledgement or a probe 		 */
if|if
condition|(
name|cb
operator|->
name|s_force
condition|)
name|spxstat
operator|.
name|spxs_sndprobe
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_ACKNOW
condition|)
name|spxstat
operator|.
name|spxs_sndacks
operator|++
expr_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
comment|/* 		 * Fill in mbuf with extended SP header 		 * and addresses and length put into network format. 		 */
name|MH_ALIGN
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|spx
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
expr_stmt|;
name|si
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|spx
operator|*
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_i
operator|=
operator|*
name|cb
operator|->
name|s_ipx
expr_stmt|;
name|si
operator|->
name|si_s
operator|=
name|cb
operator|->
name|s_shdr
expr_stmt|;
name|si
operator|->
name|si_seq
operator|=
name|cb
operator|->
name|s_smax
operator|+
literal|1
expr_stmt|;
name|si
operator|->
name|si_len
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_cc
operator||=
name|SPX_SP
expr_stmt|;
block|}
else|else
block|{
name|cb
operator|->
name|s_outx
operator|=
literal|3
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspxs
condition|)
name|spx_trace
argument_list|(
name|SA_OUTPUT
argument_list|,
name|cb
operator|->
name|s_state
argument_list|,
name|cb
argument_list|,
name|si
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Stuff checksum and output datagram. 	 */
if|if
condition|(
operator|(
name|si
operator|->
name|si_cc
operator|&
name|SPX_SP
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|s_force
operator|!=
operator|(
literal|1
operator|+
name|SPXT_PERSIST
operator|)
operator|||
name|cb
operator|->
name|s_timer
index|[
name|SPXT_PERSIST
index|]
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If this is a new packet and we are not currently  			 * timing anything, time this one. 			 */
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_smax
argument_list|,
name|si
operator|->
name|si_seq
argument_list|)
condition|)
block|{
name|cb
operator|->
name|s_smax
operator|=
name|si
operator|->
name|si_seq
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_rtt
operator|==
literal|0
condition|)
block|{
name|spxstat
operator|.
name|spxs_segstimed
operator|++
expr_stmt|;
name|cb
operator|->
name|s_rtseq
operator|=
name|si
operator|->
name|si_seq
expr_stmt|;
name|cb
operator|->
name|s_rtt
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 			 * Set rexmt timer if not currently set, 			 * Initial value for retransmit timer is smoothed 			 * round-trip time + 2 * round-trip time variance. 			 * Initialize shift counter which is used for backoff 			 * of retransmit time. 			 */
if|if
condition|(
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|==
literal|0
operator|&&
name|cb
operator|->
name|s_snxt
operator|!=
name|cb
operator|->
name|s_rack
condition|)
block|{
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|=
name|cb
operator|->
name|s_rxtcur
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_timer
index|[
name|SPXT_PERSIST
index|]
condition|)
block|{
name|cb
operator|->
name|s_timer
index|[
name|SPXT_PERSIST
index|]
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_rxtshift
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|SSEQ_LT
argument_list|(
name|cb
operator|->
name|s_smax
argument_list|,
name|si
operator|->
name|si_seq
argument_list|)
condition|)
block|{
name|cb
operator|->
name|s_smax
operator|=
name|si
operator|->
name|si_seq
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cb
operator|->
name|s_state
operator|<
name|TCPS_ESTABLISHED
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|s_rtt
operator|==
literal|0
condition|)
name|cb
operator|->
name|s_rtt
operator|=
literal|1
expr_stmt|;
comment|/* Time initial handshake */
if|if
condition|(
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|==
literal|0
condition|)
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|=
name|cb
operator|->
name|s_rxtcur
expr_stmt|;
block|}
block|{
comment|/* 		 * Do not request acks when we ack their data packets or 		 * when we do a gratuitous window update. 		 */
if|if
condition|(
operator|(
operator|(
name|si
operator|->
name|si_cc
operator|&
name|SPX_SP
operator|)
operator|==
literal|0
operator|)
operator|||
name|cb
operator|->
name|s_force
condition|)
name|si
operator|->
name|si_cc
operator||=
name|SPX_SA
expr_stmt|;
name|si
operator|->
name|si_seq
operator|=
name|htons
argument_list|(
name|si
operator|->
name|si_seq
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_alo
operator|=
name|htons
argument_list|(
name|alo
argument_list|)
expr_stmt|;
name|si
operator|->
name|si_ack
operator|=
name|htons
argument_list|(
name|cb
operator|->
name|s_ack
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipxcksum
condition|)
block|{
name|si
operator|->
name|si_sum
operator|=
name|ipx_cksum
argument_list|(
name|m
argument_list|,
name|ntohs
argument_list|(
name|si
operator|->
name|si_len
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|si
operator|->
name|si_sum
operator|=
literal|0xffff
expr_stmt|;
name|cb
operator|->
name|s_outx
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DEBUG
operator|||
name|traceallspxs
condition|)
name|spx_trace
argument_list|(
name|SA_OUTPUT
argument_list|,
name|cb
operator|->
name|s_state
argument_list|,
name|cb
argument_list|,
name|si
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_DONTROUTE
condition|)
name|error
operator|=
name|ipx_outputfl
argument_list|(
name|m
argument_list|,
operator|(
expr|struct
name|route
operator|*
operator|)
name|NULL
argument_list|,
name|IPX_ROUTETOIF
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ipx_outputfl
argument_list|(
name|m
argument_list|,
operator|&
name|cb
operator|->
name|s_ipxpcb
operator|->
name|ipxp_route
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|spxstat
operator|.
name|spxs_sndtotal
operator|++
expr_stmt|;
comment|/* 	 * Data sent (as far as we can tell). 	 * If this advertises a larger window than any other segment, 	 * then remember the size of the advertized window. 	 * Any pending ACK has now been sent. 	 */
name|cb
operator|->
name|s_force
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_flags
operator|&=
operator|~
operator|(
name|SF_ACKNOW
operator||
name|SF_DELACK
operator|)
expr_stmt|;
if|if
condition|(
name|SSEQ_GT
argument_list|(
name|alo
argument_list|,
name|cb
operator|->
name|s_alo
argument_list|)
condition|)
name|cb
operator|->
name|s_alo
operator|=
name|alo
expr_stmt|;
if|if
condition|(
name|sendalot
condition|)
goto|goto
name|again
goto|;
name|cb
operator|->
name|s_outx
operator|=
literal|5
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|spx_do_persist_panics
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|spx_setpersist
parameter_list|(
name|cb
parameter_list|)
specifier|register
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
block|{
specifier|register
name|int
name|t
init|=
operator|(
operator|(
name|cb
operator|->
name|s_srtt
operator|>>
literal|2
operator|)
operator|+
name|cb
operator|->
name|s_rttvar
operator|)
operator|>>
literal|1
decl_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|&&
name|spx_do_persist_panics
condition|)
name|panic
argument_list|(
literal|"spx_output REXMT"
argument_list|)
expr_stmt|;
comment|/* 	 * Start/restart persistance timer. 	 */
name|SPXT_RANGESET
argument_list|(
name|cb
operator|->
name|s_timer
index|[
name|SPXT_PERSIST
index|]
argument_list|,
name|t
operator|*
name|spx_backoff
index|[
name|cb
operator|->
name|s_rxtshift
index|]
argument_list|,
name|SPXTV_PERSMIN
argument_list|,
name|SPXTV_PERSMAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_rxtshift
operator|<
name|SPX_MAXRXTSHIFT
condition|)
name|cb
operator|->
name|s_rxtshift
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|int
name|spx_ctloutput
parameter_list|(
name|so
parameter_list|,
name|sopt
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockopt
modifier|*
name|sopt
decl_stmt|;
block|{
name|struct
name|ipxpcb
modifier|*
name|ipxp
init|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|int
name|mask
decl_stmt|,
name|error
decl_stmt|;
name|short
name|soptval
decl_stmt|;
name|u_short
name|usoptval
decl_stmt|;
name|int
name|optval
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_level
operator|!=
name|IPXPROTO_SPX
condition|)
block|{
comment|/* This will have to be changed when we do more general 		   stacking of protocols */
return|return
operator|(
name|ipx_ctloutput
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|ipxp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
else|else
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_dir
condition|)
block|{
case|case
name|SOPT_GET
case|:
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|SO_HEADERS_ON_INPUT
case|:
name|mask
operator|=
name|SF_HI
expr_stmt|;
goto|goto
name|get_flags
goto|;
case|case
name|SO_HEADERS_ON_OUTPUT
case|:
name|mask
operator|=
name|SF_HO
expr_stmt|;
name|get_flags
label|:
name|soptval
operator|=
name|cb
operator|->
name|s_flags
operator|&
name|mask
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|soptval
argument_list|,
sizeof|sizeof
name|soptval
argument_list|)
expr_stmt|;
break|break;
case|case
name|SO_MTU
case|:
name|usoptval
operator|=
name|cb
operator|->
name|s_mtu
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|usoptval
argument_list|,
sizeof|sizeof
name|usoptval
argument_list|)
expr_stmt|;
break|break;
case|case
name|SO_LAST_HEADER
case|:
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|cb
operator|->
name|s_rhdr
argument_list|,
sizeof|sizeof
name|cb
operator|->
name|s_rhdr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SO_DEFAULT_HEADERS
case|:
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|cb
operator|->
name|s_shdr
argument_list|,
sizeof|sizeof
name|cb
operator|->
name|s_shdr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
block|}
break|break;
case|case
name|SOPT_SET
case|:
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
comment|/* XXX why are these shorts on get and ints on set? 			   that doesn't make any sense... */
case|case
name|SO_HEADERS_ON_INPUT
case|:
name|mask
operator|=
name|SF_HI
expr_stmt|;
goto|goto
name|set_head
goto|;
case|case
name|SO_HEADERS_ON_OUTPUT
case|:
name|mask
operator|=
name|SF_HO
expr_stmt|;
name|set_head
label|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_PI
condition|)
block|{
if|if
condition|(
name|optval
condition|)
name|cb
operator|->
name|s_flags
operator||=
name|mask
expr_stmt|;
else|else
name|cb
operator|->
name|s_flags
operator|&=
operator|~
name|mask
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|SO_MTU
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|usoptval
argument_list|,
sizeof|sizeof
name|usoptval
argument_list|,
sizeof|sizeof
name|usoptval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|cb
operator|->
name|s_mtu
operator|=
name|usoptval
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|SF_NEWCALL
case|case
name|SO_NEWCALL
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|optval
condition|)
block|{
name|cb
operator|->
name|s_flags2
operator||=
name|SF_NEWCALL
expr_stmt|;
name|spx_newchecks
index|[
literal|5
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
name|cb
operator|->
name|s_flags2
operator|&=
operator|~
name|SF_NEWCALL
expr_stmt|;
name|spx_newchecks
index|[
literal|6
index|]
operator|++
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|SO_DEFAULT_HEADERS
case|:
block|{
name|struct
name|spxhdr
name|sp
decl_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|sp
argument_list|,
sizeof|sizeof
name|sp
argument_list|,
sizeof|sizeof
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|cb
operator|->
name|s_dt
operator|=
name|sp
operator|.
name|spx_dt
expr_stmt|;
name|cb
operator|->
name|s_cc
operator|=
name|sp
operator|.
name|spx_cc
operator|&
name|SPX_EM
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spx_usr_abort
parameter_list|(
name|so
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|spx_drop
argument_list|(
name|cb
argument_list|,
name|ECONNABORTED
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Accept a connection.  Essentially all the work is  * done at higher levels; just return the address  * of the peer, storing through addr.  */
end_comment

begin_function
specifier|static
name|int
name|spx_accept
parameter_list|(
name|so
parameter_list|,
name|nam
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
decl_stmt|;
block|{
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|sockaddr_ipx
modifier|*
name|sipx
decl_stmt|,
name|ssipx
decl_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sipx
operator|=
operator|&
name|ssipx
expr_stmt|;
name|bzero
argument_list|(
name|sipx
argument_list|,
sizeof|sizeof
expr|*
name|sipx
argument_list|)
expr_stmt|;
name|sipx
operator|->
name|sipx_len
operator|=
sizeof|sizeof
expr|*
name|sipx
expr_stmt|;
name|sipx
operator|->
name|sipx_family
operator|=
name|AF_IPX
expr_stmt|;
name|sipx
operator|->
name|sipx_addr
operator|=
name|ipxp
operator|->
name|ipxp_faddr
expr_stmt|;
operator|*
name|nam
operator|=
name|dup_sockaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sipx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spx_attach
parameter_list|(
name|so
parameter_list|,
name|proto
parameter_list|,
name|td
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|proto
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mm
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipxp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EISCONN
operator|)
return|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|error
operator|=
name|ipx_pcballoc
argument_list|(
name|so
argument_list|,
operator|&
name|ipxpcb
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|spx_attach_end
goto|;
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|==
literal|0
operator|||
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
operator|(
name|u_long
operator|)
literal|3072
argument_list|,
operator|(
name|u_long
operator|)
literal|3072
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|spx_attach_end
goto|;
block|}
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|cb
argument_list|,
expr|struct
name|spxpcb
operator|*
argument_list|,
sizeof|sizeof
expr|*
name|cb
argument_list|,
name|M_PCB
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|spx_attach_end
goto|;
block|}
name|sb
operator|=
operator|&
name|so
operator|->
name|so_snd
expr_stmt|;
name|mm
operator|=
name|m_getclr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|mm
operator|==
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|cb
argument_list|,
name|M_PCB
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|spx_attach_end
goto|;
block|}
name|cb
operator|->
name|s_ipx
operator|=
name|mtod
argument_list|(
name|mm
argument_list|,
expr|struct
name|ipx
operator|*
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_LISTEN
expr_stmt|;
name|cb
operator|->
name|s_smax
operator|=
operator|-
literal|1
expr_stmt|;
name|cb
operator|->
name|s_swl1
operator|=
operator|-
literal|1
expr_stmt|;
name|cb
operator|->
name|s_q
operator|.
name|si_next
operator|=
name|cb
operator|->
name|s_q
operator|.
name|si_prev
operator|=
operator|&
name|cb
operator|->
name|s_q
expr_stmt|;
name|cb
operator|->
name|s_ipxpcb
operator|=
name|ipxp
expr_stmt|;
name|cb
operator|->
name|s_mtu
operator|=
literal|576
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|spx
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_cwnd
operator|=
name|sbspace
argument_list|(
name|sb
argument_list|)
operator|*
name|CUNIT
operator|/
name|cb
operator|->
name|s_mtu
expr_stmt|;
name|cb
operator|->
name|s_ssthresh
operator|=
name|cb
operator|->
name|s_cwnd
expr_stmt|;
name|cb
operator|->
name|s_cwmx
operator|=
name|sbspace
argument_list|(
name|sb
argument_list|)
operator|*
name|CUNIT
operator|/
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|spx
argument_list|)
operator|)
expr_stmt|;
comment|/* Above is recomputed when connecting to account 	   for changed buffering or mtu's */
name|cb
operator|->
name|s_rtt
operator|=
name|SPXTV_SRTTBASE
expr_stmt|;
name|cb
operator|->
name|s_rttvar
operator|=
name|SPXTV_SRTTDFLT
operator|<<
literal|2
expr_stmt|;
name|SPXT_RANGESET
argument_list|(
name|cb
operator|->
name|s_rxtcur
argument_list|,
operator|(
operator|(
name|SPXTV_SRTTBASE
operator|>>
literal|2
operator|)
operator|+
operator|(
name|SPXTV_SRTTDFLT
operator|<<
literal|2
operator|)
operator|)
operator|>>
literal|1
argument_list|,
name|SPXTV_MIN
argument_list|,
name|SPXTV_REXMTMAX
argument_list|)
expr_stmt|;
name|ipxp
operator|->
name|ipxp_pcb
operator|=
operator|(
name|caddr_t
operator|)
name|cb
expr_stmt|;
name|spx_attach_end
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spx_bind
parameter_list|(
name|so
parameter_list|,
name|nam
parameter_list|,
name|td
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|nam
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|ipx_pcbbind
argument_list|(
name|ipxp
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initiate connection to peer.  * Enter SYN_SENT state, and mark socket as connecting.  * Start keep-alive timer, setup prototype header,  * Send initial system packet requesting connection.  */
end_comment

begin_function
specifier|static
name|int
name|spx_connect
parameter_list|(
name|so
parameter_list|,
name|nam
parameter_list|,
name|td
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|nam
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
name|ipxp
operator|->
name|ipxp_lport
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ipx_pcbbind
argument_list|(
name|ipxp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|spx_connect_end
goto|;
block|}
name|error
operator|=
name|ipx_pcbconnect
argument_list|(
name|ipxp
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|spx_connect_end
goto|;
name|soisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|spxstat
operator|.
name|spxs_connattempt
operator|++
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_SYN_SENT
expr_stmt|;
name|cb
operator|->
name|s_did
operator|=
literal|0
expr_stmt|;
name|spx_template
argument_list|(
name|cb
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPXT_KEEP
index|]
operator|=
name|SPXTV_KEEP
expr_stmt|;
name|cb
operator|->
name|s_force
operator|=
literal|1
operator|+
name|SPXTV_KEEP
expr_stmt|;
comment|/* 	 * Other party is required to respond to 	 * the port I send from, but he is not 	 * required to answer from where I am sending to, 	 * so allow wildcarding. 	 * original port I am sending to is still saved in 	 * cb->s_dport. 	 */
name|ipxp
operator|->
name|ipxp_fport
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|spx_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|spx_connect_end
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spx_detach
parameter_list|(
name|so
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipxp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOTCONN
operator|)
return|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_state
operator|>
name|TCPS_LISTEN
condition|)
name|spx_disconnect
argument_list|(
name|cb
argument_list|)
expr_stmt|;
else|else
name|spx_close
argument_list|(
name|cb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We may decide later to implement connection closing  * handshaking at the spx level optionally.  * here is the hook to do it:  */
end_comment

begin_function
specifier|static
name|int
name|spx_usr_disconnect
parameter_list|(
name|so
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|spx_disconnect
argument_list|(
name|cb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spx_listen
parameter_list|(
name|so
parameter_list|,
name|td
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipxp
operator|->
name|ipxp_lport
operator|==
literal|0
condition|)
name|error
operator|=
name|ipx_pcbbind
argument_list|(
name|ipxp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|cb
operator|->
name|s_state
operator|=
name|TCPS_LISTEN
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * After a receive, possibly send acknowledgment  * updating allocation.  */
end_comment

begin_function
specifier|static
name|int
name|spx_rcvd
parameter_list|(
name|so
parameter_list|,
name|flags
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|cb
operator|->
name|s_flags
operator||=
name|SF_RVD
expr_stmt|;
name|spx_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_flags
operator|&=
operator|~
name|SF_RVD
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spx_rcvoob
parameter_list|(
name|so
parameter_list|,
name|m
parameter_list|,
name|flags
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cb
operator|->
name|s_oobflags
operator|&
name|SF_IOOB
operator|)
operator|||
name|so
operator|->
name|so_oobmark
operator|||
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_RCVATMARK
operator|)
condition|)
block|{
name|m
operator|->
name|m_len
operator|=
literal|1
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|=
name|cb
operator|->
name|s_iobc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spx_send
parameter_list|(
name|so
parameter_list|,
name|flags
parameter_list|,
name|m
parameter_list|,
name|addr
parameter_list|,
name|controlp
parameter_list|,
name|td
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|controlp
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PRUS_OOB
condition|)
block|{
if|if
condition|(
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
operator|<
operator|-
literal|512
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|spx_send_end
goto|;
block|}
name|cb
operator|->
name|s_oobflags
operator||=
name|SF_SOOB
expr_stmt|;
block|}
if|if
condition|(
name|controlp
operator|!=
name|NULL
condition|)
block|{
name|u_short
modifier|*
name|p
init|=
name|mtod
argument_list|(
name|controlp
argument_list|,
name|u_short
operator|*
argument_list|)
decl_stmt|;
name|spx_newchecks
index|[
literal|2
index|]
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|p
index|[
literal|0
index|]
operator|==
literal|5
operator|)
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* XXXX, for testing */
name|cb
operator|->
name|s_shdr
operator|.
name|spx_dt
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|&
name|p
index|[
literal|2
index|]
operator|)
expr_stmt|;
name|spx_newchecks
index|[
literal|3
index|]
operator|++
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|controlp
argument_list|)
expr_stmt|;
block|}
name|controlp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|spx_output
argument_list|(
name|cb
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|spx_send_end
label|:
if|if
condition|(
name|controlp
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|controlp
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spx_shutdown
parameter_list|(
name|so
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|socantsendmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|cb
operator|=
name|spx_usrclosed
argument_list|(
name|cb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|!=
name|NULL
condition|)
name|error
operator|=
name|spx_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spx_sp_attach
parameter_list|(
name|so
parameter_list|,
name|proto
parameter_list|,
name|td
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|proto
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
name|error
operator|=
name|spx_attach
argument_list|(
name|so
argument_list|,
name|proto
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|ipxp
operator|=
name|sotoipxpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|spxpcb
operator|*
operator|)
name|ipxp
operator|->
name|ipxp_pcb
operator|)
operator|->
name|s_flags
operator||=
operator|(
name|SF_HI
operator||
name|SF_HO
operator||
name|SF_PI
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create template to be used to send spx packets on a connection.  * Called after host entry created, fills  * in a skeletal spx header (choosing connection id),  * minimizing the amount of work necessary when the connection is used.  */
end_comment

begin_function
specifier|static
name|void
name|spx_template
parameter_list|(
name|cb
parameter_list|)
specifier|register
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
block|{
specifier|register
name|struct
name|ipxpcb
modifier|*
name|ipxp
init|=
name|cb
operator|->
name|s_ipxpcb
decl_stmt|;
specifier|register
name|struct
name|ipx
modifier|*
name|ipx
init|=
name|cb
operator|->
name|s_ipx
decl_stmt|;
specifier|register
name|struct
name|sockbuf
modifier|*
name|sb
init|=
operator|&
operator|(
name|ipxp
operator|->
name|ipxp_socket
operator|->
name|so_snd
operator|)
decl_stmt|;
name|ipx
operator|->
name|ipx_pt
operator|=
name|IPXPROTO_SPX
expr_stmt|;
name|ipx
operator|->
name|ipx_sna
operator|=
name|ipxp
operator|->
name|ipxp_laddr
expr_stmt|;
name|ipx
operator|->
name|ipx_dna
operator|=
name|ipxp
operator|->
name|ipxp_faddr
expr_stmt|;
name|cb
operator|->
name|s_sid
operator|=
name|htons
argument_list|(
name|spx_iss
argument_list|)
expr_stmt|;
name|spx_iss
operator|+=
name|SPX_ISSINCR
operator|/
literal|2
expr_stmt|;
name|cb
operator|->
name|s_alo
operator|=
literal|1
expr_stmt|;
name|cb
operator|->
name|s_cwnd
operator|=
operator|(
name|sbspace
argument_list|(
name|sb
argument_list|)
operator|*
name|CUNIT
operator|)
operator|/
name|cb
operator|->
name|s_mtu
expr_stmt|;
name|cb
operator|->
name|s_ssthresh
operator|=
name|cb
operator|->
name|s_cwnd
expr_stmt|;
comment|/* Try to expand fast to full complement 					of large packets */
name|cb
operator|->
name|s_cwmx
operator|=
operator|(
name|sbspace
argument_list|(
name|sb
argument_list|)
operator|*
name|CUNIT
operator|)
operator|/
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|spx
argument_list|)
operator|)
expr_stmt|;
name|cb
operator|->
name|s_cwmx
operator|=
name|max
argument_list|(
name|cb
operator|->
name|s_cwmx
argument_list|,
name|cb
operator|->
name|s_cwnd
argument_list|)
expr_stmt|;
comment|/* But allow for lots of little packets as well */
block|}
end_function

begin_comment
comment|/*  * Close a SPIP control block:  *	discard spx control block itself  *	discard ipx protocol control block  *	wake up any sleepers  */
end_comment

begin_function
specifier|static
name|struct
name|spxpcb
modifier|*
name|spx_close
parameter_list|(
name|cb
parameter_list|)
specifier|register
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
block|{
specifier|register
name|struct
name|spx_q
modifier|*
name|s
decl_stmt|;
name|struct
name|ipxpcb
modifier|*
name|ipxp
init|=
name|cb
operator|->
name|s_ipxpcb
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|ipxp
operator|->
name|ipxp_socket
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|s
operator|=
name|cb
operator|->
name|s_q
operator|.
name|si_next
expr_stmt|;
while|while
condition|(
name|s
operator|!=
operator|&
operator|(
name|cb
operator|->
name|s_q
operator|)
condition|)
block|{
name|s
operator|=
name|s
operator|->
name|si_next
expr_stmt|;
name|m
operator|=
name|dtom
argument_list|(
name|s
operator|->
name|si_prev
argument_list|)
expr_stmt|;
name|remque
argument_list|(
name|s
operator|->
name|si_prev
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|m_free
argument_list|(
name|dtom
argument_list|(
name|cb
operator|->
name|s_ipx
argument_list|)
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|cb
argument_list|,
name|M_PCB
argument_list|)
expr_stmt|;
name|ipxp
operator|->
name|ipxp_pcb
operator|=
literal|0
expr_stmt|;
name|soisdisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|ipx_pcbdetach
argument_list|(
name|ipxp
argument_list|)
expr_stmt|;
name|spxstat
operator|.
name|spxs_closed
operator|++
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|spxpcb
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Someday we may do level 3 handshaking  *	to close a connection or send a xerox style error.  *	For now, just close.  */
end_comment

begin_function
specifier|static
name|struct
name|spxpcb
modifier|*
name|spx_usrclosed
parameter_list|(
name|cb
parameter_list|)
specifier|register
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
block|{
return|return
operator|(
name|spx_close
argument_list|(
name|cb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|spxpcb
modifier|*
name|spx_disconnect
parameter_list|(
name|cb
parameter_list|)
specifier|register
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
block|{
return|return
operator|(
name|spx_close
argument_list|(
name|cb
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Drop connection, reporting  * the specified error.  */
end_comment

begin_function
specifier|static
name|struct
name|spxpcb
modifier|*
name|spx_drop
parameter_list|(
name|cb
parameter_list|,
name|errno
parameter_list|)
specifier|register
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|int
name|errno
decl_stmt|;
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|cb
operator|->
name|s_ipxpcb
operator|->
name|ipxp_socket
decl_stmt|;
comment|/* 	 * someday, in the xerox world 	 * we will generate error protocol packets 	 * announcing that the socket has gone away. 	 */
if|if
condition|(
name|TCPS_HAVERCVDSYN
argument_list|(
name|cb
operator|->
name|s_state
argument_list|)
condition|)
block|{
name|spxstat
operator|.
name|spxs_drops
operator|++
expr_stmt|;
name|cb
operator|->
name|s_state
operator|=
name|TCPS_CLOSED
expr_stmt|;
comment|/*tcp_output(cb);*/
block|}
else|else
name|spxstat
operator|.
name|spxs_conndrops
operator|++
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
name|errno
expr_stmt|;
return|return
operator|(
name|spx_close
argument_list|(
name|cb
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fast timeout routine for processing delayed acks  */
end_comment

begin_function
name|void
name|spx_fasttimo
parameter_list|()
block|{
specifier|register
name|struct
name|ipxpcb
modifier|*
name|ipxp
decl_stmt|;
specifier|register
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|ipxp
operator|=
name|ipxpcb
operator|.
name|ipxp_next
expr_stmt|;
if|if
condition|(
name|ipxp
operator|!=
name|NULL
condition|)
for|for
control|(
init|;
name|ipxp
operator|!=
operator|&
name|ipxpcb
condition|;
name|ipxp
operator|=
name|ipxp
operator|->
name|ipxp_next
control|)
if|if
condition|(
operator|(
name|cb
operator|=
operator|(
expr|struct
name|spxpcb
operator|*
operator|)
name|ipxp
operator|->
name|ipxp_pcb
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|cb
operator|->
name|s_flags
operator|&
name|SF_DELACK
operator|)
condition|)
block|{
name|cb
operator|->
name|s_flags
operator|&=
operator|~
name|SF_DELACK
expr_stmt|;
name|cb
operator|->
name|s_flags
operator||=
name|SF_ACKNOW
expr_stmt|;
name|spxstat
operator|.
name|spxs_delack
operator|++
expr_stmt|;
name|spx_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * spx protocol timeout routine called every 500 ms.  * Updates the timers in all active pcb's and  * causes finite state machine actions if timers expire.  */
end_comment

begin_function
name|void
name|spx_slowtimo
parameter_list|()
block|{
specifier|register
name|struct
name|ipxpcb
modifier|*
name|ip
decl_stmt|,
modifier|*
name|ipnxt
decl_stmt|;
specifier|register
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
comment|/* 	 * Search through tcb's and update active timers. 	 */
name|ip
operator|=
name|ipxpcb
operator|.
name|ipxp_next
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|ip
operator|!=
operator|&
name|ipxpcb
condition|)
block|{
name|cb
operator|=
name|ipxtospxpcb
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ipnxt
operator|=
name|ip
operator|->
name|ipxp_next
expr_stmt|;
if|if
condition|(
name|cb
operator|==
name|NULL
condition|)
goto|goto
name|tpgone
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPXT_NTIMERS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cb
operator|->
name|s_timer
index|[
name|i
index|]
operator|&&
operator|--
name|cb
operator|->
name|s_timer
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|spx_timers
argument_list|(
name|cb
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipnxt
operator|->
name|ipxp_prev
operator|!=
name|ip
condition|)
goto|goto
name|tpgone
goto|;
block|}
block|}
name|cb
operator|->
name|s_idle
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_rtt
condition|)
name|cb
operator|->
name|s_rtt
operator|++
expr_stmt|;
name|tpgone
label|:
name|ip
operator|=
name|ipnxt
expr_stmt|;
block|}
name|spx_iss
operator|+=
name|SPX_ISSINCR
operator|/
name|PR_SLOWHZ
expr_stmt|;
comment|/* increment iss */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * SPX timer processing.  */
end_comment

begin_function
specifier|static
name|struct
name|spxpcb
modifier|*
name|spx_timers
parameter_list|(
name|cb
parameter_list|,
name|timer
parameter_list|)
specifier|register
name|struct
name|spxpcb
modifier|*
name|cb
decl_stmt|;
name|int
name|timer
decl_stmt|;
block|{
name|long
name|rexmt
decl_stmt|;
name|int
name|win
decl_stmt|;
name|cb
operator|->
name|s_force
operator|=
literal|1
operator|+
name|timer
expr_stmt|;
switch|switch
condition|(
name|timer
condition|)
block|{
comment|/* 	 * 2 MSL timeout in shutdown went off.  TCP deletes connection 	 * control block. 	 */
case|case
name|SPXT_2MSL
case|:
name|printf
argument_list|(
literal|"spx: SPXT_2MSL went off for no reason\n"
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|timer
index|]
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* 	 * Retransmission timer went off.  Message has not 	 * been acked within retransmit interval.  Back off 	 * to a longer retransmit interval and retransmit one packet. 	 */
case|case
name|SPXT_REXMT
case|:
if|if
condition|(
operator|++
name|cb
operator|->
name|s_rxtshift
operator|>
name|SPX_MAXRXTSHIFT
condition|)
block|{
name|cb
operator|->
name|s_rxtshift
operator|=
name|SPX_MAXRXTSHIFT
expr_stmt|;
name|spxstat
operator|.
name|spxs_timeoutdrop
operator|++
expr_stmt|;
name|cb
operator|=
name|spx_drop
argument_list|(
name|cb
argument_list|,
name|ETIMEDOUT
argument_list|)
expr_stmt|;
break|break;
block|}
name|spxstat
operator|.
name|spxs_rexmttimeo
operator|++
expr_stmt|;
name|rexmt
operator|=
operator|(
operator|(
name|cb
operator|->
name|s_srtt
operator|>>
literal|2
operator|)
operator|+
name|cb
operator|->
name|s_rttvar
operator|)
operator|>>
literal|1
expr_stmt|;
name|rexmt
operator|*=
name|spx_backoff
index|[
name|cb
operator|->
name|s_rxtshift
index|]
expr_stmt|;
name|SPXT_RANGESET
argument_list|(
name|cb
operator|->
name|s_rxtcur
argument_list|,
name|rexmt
argument_list|,
name|SPXTV_MIN
argument_list|,
name|SPXTV_REXMTMAX
argument_list|)
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPXT_REXMT
index|]
operator|=
name|cb
operator|->
name|s_rxtcur
expr_stmt|;
comment|/* 		 * If we have backed off fairly far, our srtt 		 * estimate is probably bogus.  Clobber it 		 * so we'll take the next rtt measurement as our srtt; 		 * move the current srtt into rttvar to keep the current 		 * retransmit times until then. 		 */
if|if
condition|(
name|cb
operator|->
name|s_rxtshift
operator|>
name|SPX_MAXRXTSHIFT
operator|/
literal|4
condition|)
block|{
name|cb
operator|->
name|s_rttvar
operator|+=
operator|(
name|cb
operator|->
name|s_srtt
operator|>>
literal|2
operator|)
expr_stmt|;
name|cb
operator|->
name|s_srtt
operator|=
literal|0
expr_stmt|;
block|}
name|cb
operator|->
name|s_snxt
operator|=
name|cb
operator|->
name|s_rack
expr_stmt|;
comment|/* 		 * If timing a packet, stop the timer. 		 */
name|cb
operator|->
name|s_rtt
operator|=
literal|0
expr_stmt|;
comment|/* 		 * See very long discussion in tcp_timer.c about congestion 		 * window and sstrhesh 		 */
name|win
operator|=
name|min
argument_list|(
name|cb
operator|->
name|s_swnd
argument_list|,
operator|(
name|cb
operator|->
name|s_cwnd
operator|/
name|CUNIT
operator|)
argument_list|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|win
operator|<
literal|2
condition|)
name|win
operator|=
literal|2
expr_stmt|;
name|cb
operator|->
name|s_cwnd
operator|=
name|CUNIT
expr_stmt|;
name|cb
operator|->
name|s_ssthresh
operator|=
name|win
operator|*
name|CUNIT
expr_stmt|;
name|spx_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Persistance timer into zero window. 	 * Force a probe to be sent. 	 */
case|case
name|SPXT_PERSIST
case|:
name|spxstat
operator|.
name|spxs_persisttimeo
operator|++
expr_stmt|;
name|spx_setpersist
argument_list|(
name|cb
argument_list|)
expr_stmt|;
name|spx_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Keep-alive timer went off; send something 	 * or drop connection if idle for too long. 	 */
case|case
name|SPXT_KEEP
case|:
name|spxstat
operator|.
name|spxs_keeptimeo
operator|++
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|s_state
operator|<
name|TCPS_ESTABLISHED
condition|)
goto|goto
name|dropit
goto|;
if|if
condition|(
name|cb
operator|->
name|s_ipxpcb
operator|->
name|ipxp_socket
operator|->
name|so_options
operator|&
name|SO_KEEPALIVE
condition|)
block|{
if|if
condition|(
name|cb
operator|->
name|s_idle
operator|>=
name|SPXTV_MAXIDLE
condition|)
goto|goto
name|dropit
goto|;
name|spxstat
operator|.
name|spxs_keepprobe
operator|++
expr_stmt|;
name|spx_output
argument_list|(
name|cb
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|cb
operator|->
name|s_idle
operator|=
literal|0
expr_stmt|;
name|cb
operator|->
name|s_timer
index|[
name|SPXT_KEEP
index|]
operator|=
name|SPXTV_KEEP
expr_stmt|;
break|break;
name|dropit
label|:
name|spxstat
operator|.
name|spxs_keepdrops
operator|++
expr_stmt|;
name|cb
operator|=
name|spx_drop
argument_list|(
name|cb
argument_list|,
name|ETIMEDOUT
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|cb
operator|)
return|;
block|}
end_function

end_unit

