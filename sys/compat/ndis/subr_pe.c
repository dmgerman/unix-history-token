begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003  *	Bill Paul<wpaul@windriver.com>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Bill Paul.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This file contains routines for relocating and dynamically linking  * executable object code files in the Windows(r) PE (Portable Executable)  * format. In Windows, anything with a .EXE, .DLL or .SYS extention is  * considered an executable, and all such files have some structures in  * common. The PE format was apparently based largely on COFF but has  * mutated significantly over time. We are mainly concerned with .SYS files,  * so this module implements only enough routines to be able to parse the  * headers and sections of a .SYS object file and perform the necessary  * relocations and jump table patching to allow us to call into it  * (and to have it call back to us). Note that while this module  * can handle fixups for imported symbols, it knows nothing about  * exporting them.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<compat/ndis/pe_var.h>
end_include

begin_function_decl
specifier|static
name|vm_offset_t
name|pe_functbl_match
parameter_list|(
name|image_patch_table
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Check for an MS-DOS executable header. All Windows binaries  * have a small MS-DOS executable prepended to them to print out  * the "This program requires Windows" message. Even .SYS files  * have this header, in spite of the fact that you're can't actually  * run them directly.  */
end_comment

begin_function
name|int
name|pe_get_dos_header
parameter_list|(
name|imgbase
parameter_list|,
name|hdr
parameter_list|)
name|vm_offset_t
name|imgbase
decl_stmt|;
name|image_dos_header
modifier|*
name|hdr
decl_stmt|;
block|{
name|uint16_t
name|signature
decl_stmt|;
if|if
condition|(
name|imgbase
operator|==
literal|0
operator|||
name|hdr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|signature
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|imgbase
expr_stmt|;
if|if
condition|(
name|signature
operator|!=
name|IMAGE_DOS_SIGNATURE
condition|)
return|return
operator|(
name|ENOEXEC
operator|)
return|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|imgbase
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|image_dos_header
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Verify that this image has a Windows NT PE signature.  */
end_comment

begin_function
name|int
name|pe_is_nt_image
parameter_list|(
name|imgbase
parameter_list|)
name|vm_offset_t
name|imgbase
decl_stmt|;
block|{
name|uint32_t
name|signature
decl_stmt|;
name|image_dos_header
modifier|*
name|dos_hdr
decl_stmt|;
if|if
condition|(
name|imgbase
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|signature
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|imgbase
expr_stmt|;
if|if
condition|(
name|signature
operator|==
name|IMAGE_DOS_SIGNATURE
condition|)
block|{
name|dos_hdr
operator|=
operator|(
name|image_dos_header
operator|*
operator|)
name|imgbase
expr_stmt|;
name|signature
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|imgbase
operator|+
name|dos_hdr
operator|->
name|idh_lfanew
operator|)
expr_stmt|;
if|if
condition|(
name|signature
operator|==
name|IMAGE_NT_SIGNATURE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOEXEC
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a copy of the optional header. This contains the  * executable entry point and the directory listing which we  * need to find the relocations and imports later.  */
end_comment

begin_function
name|int
name|pe_get_optional_header
parameter_list|(
name|imgbase
parameter_list|,
name|hdr
parameter_list|)
name|vm_offset_t
name|imgbase
decl_stmt|;
name|image_optional_header
modifier|*
name|hdr
decl_stmt|;
block|{
name|image_dos_header
modifier|*
name|dos_hdr
decl_stmt|;
name|image_nt_header
modifier|*
name|nt_hdr
decl_stmt|;
if|if
condition|(
name|imgbase
operator|==
literal|0
operator|||
name|hdr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|pe_is_nt_image
argument_list|(
name|imgbase
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|dos_hdr
operator|=
operator|(
name|image_dos_header
operator|*
operator|)
operator|(
name|imgbase
operator|)
expr_stmt|;
name|nt_hdr
operator|=
operator|(
name|image_nt_header
operator|*
operator|)
operator|(
name|imgbase
operator|+
name|dos_hdr
operator|->
name|idh_lfanew
operator|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|nt_hdr
operator|->
name|inh_optionalhdr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hdr
argument_list|,
name|nt_hdr
operator|->
name|inh_filehdr
operator|.
name|ifh_optionalhdrlen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a copy of the file header. Contains the number of  * sections in this image.  */
end_comment

begin_function
name|int
name|pe_get_file_header
parameter_list|(
name|imgbase
parameter_list|,
name|hdr
parameter_list|)
name|vm_offset_t
name|imgbase
decl_stmt|;
name|image_file_header
modifier|*
name|hdr
decl_stmt|;
block|{
name|image_dos_header
modifier|*
name|dos_hdr
decl_stmt|;
name|image_nt_header
modifier|*
name|nt_hdr
decl_stmt|;
if|if
condition|(
name|imgbase
operator|==
literal|0
operator|||
name|hdr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|pe_is_nt_image
argument_list|(
name|imgbase
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|dos_hdr
operator|=
operator|(
name|image_dos_header
operator|*
operator|)
name|imgbase
expr_stmt|;
name|nt_hdr
operator|=
operator|(
name|image_nt_header
operator|*
operator|)
operator|(
name|imgbase
operator|+
name|dos_hdr
operator|->
name|idh_lfanew
operator|)
expr_stmt|;
comment|/* 	 * Note: the size of the nt_header is variable since it 	 * can contain optional fields, as indicated by ifh_optionalhdrlen. 	 * However it happens we're only interested in fields in the 	 * non-variant portion of the nt_header structure, so we don't 	 * bother copying the optional parts here. 	 */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|nt_hdr
operator|->
name|inh_filehdr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|image_file_header
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the header of the first section in this image (usually  * .text).  */
end_comment

begin_function
name|int
name|pe_get_section_header
parameter_list|(
name|imgbase
parameter_list|,
name|hdr
parameter_list|)
name|vm_offset_t
name|imgbase
decl_stmt|;
name|image_section_header
modifier|*
name|hdr
decl_stmt|;
block|{
name|image_dos_header
modifier|*
name|dos_hdr
decl_stmt|;
name|image_nt_header
modifier|*
name|nt_hdr
decl_stmt|;
name|image_section_header
modifier|*
name|sect_hdr
decl_stmt|;
if|if
condition|(
name|imgbase
operator|==
literal|0
operator|||
name|hdr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|pe_is_nt_image
argument_list|(
name|imgbase
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|dos_hdr
operator|=
operator|(
name|image_dos_header
operator|*
operator|)
name|imgbase
expr_stmt|;
name|nt_hdr
operator|=
operator|(
name|image_nt_header
operator|*
operator|)
operator|(
name|imgbase
operator|+
name|dos_hdr
operator|->
name|idh_lfanew
operator|)
expr_stmt|;
name|sect_hdr
operator|=
name|IMAGE_FIRST_SECTION
argument_list|(
name|nt_hdr
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sect_hdr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|image_section_header
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number of sections in this executable, or 0 on error.  */
end_comment

begin_function
name|int
name|pe_numsections
parameter_list|(
name|imgbase
parameter_list|)
name|vm_offset_t
name|imgbase
decl_stmt|;
block|{
name|image_file_header
name|file_hdr
decl_stmt|;
if|if
condition|(
name|pe_get_file_header
argument_list|(
name|imgbase
argument_list|,
operator|&
name|file_hdr
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|file_hdr
operator|.
name|ifh_numsections
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the base address that this image was linked for.  * This helps us calculate relocation addresses later.  */
end_comment

begin_function
name|vm_offset_t
name|pe_imagebase
parameter_list|(
name|imgbase
parameter_list|)
name|vm_offset_t
name|imgbase
decl_stmt|;
block|{
name|image_optional_header
name|optional_hdr
decl_stmt|;
if|if
condition|(
name|pe_get_optional_header
argument_list|(
name|imgbase
argument_list|,
operator|&
name|optional_hdr
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|optional_hdr
operator|.
name|ioh_imagebase
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the offset of a given directory structure within the  * image. Directories reside within sections.  */
end_comment

begin_function
name|vm_offset_t
name|pe_directory_offset
parameter_list|(
name|imgbase
parameter_list|,
name|diridx
parameter_list|)
name|vm_offset_t
name|imgbase
decl_stmt|;
name|uint32_t
name|diridx
decl_stmt|;
block|{
name|image_optional_header
name|opt_hdr
decl_stmt|;
name|vm_offset_t
name|dir
decl_stmt|;
if|if
condition|(
name|pe_get_optional_header
argument_list|(
name|imgbase
argument_list|,
operator|&
name|opt_hdr
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|diridx
operator|>=
name|opt_hdr
operator|.
name|ioh_rva_size_cnt
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dir
operator|=
name|opt_hdr
operator|.
name|ioh_datadir
index|[
name|diridx
index|]
operator|.
name|idd_vaddr
expr_stmt|;
return|return
operator|(
name|pe_translate_addr
argument_list|(
name|imgbase
argument_list|,
name|dir
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|vm_offset_t
name|pe_translate_addr
parameter_list|(
name|imgbase
parameter_list|,
name|rva
parameter_list|)
name|vm_offset_t
name|imgbase
decl_stmt|;
name|vm_offset_t
name|rva
decl_stmt|;
block|{
name|image_optional_header
name|opt_hdr
decl_stmt|;
name|image_section_header
modifier|*
name|sect_hdr
decl_stmt|;
name|image_dos_header
modifier|*
name|dos_hdr
decl_stmt|;
name|image_nt_header
modifier|*
name|nt_hdr
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|sections
decl_stmt|,
name|fixedlen
decl_stmt|;
if|if
condition|(
name|pe_get_optional_header
argument_list|(
name|imgbase
argument_list|,
operator|&
name|opt_hdr
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sections
operator|=
name|pe_numsections
argument_list|(
name|imgbase
argument_list|)
expr_stmt|;
name|dos_hdr
operator|=
operator|(
name|image_dos_header
operator|*
operator|)
name|imgbase
expr_stmt|;
name|nt_hdr
operator|=
operator|(
name|image_nt_header
operator|*
operator|)
operator|(
name|imgbase
operator|+
name|dos_hdr
operator|->
name|idh_lfanew
operator|)
expr_stmt|;
name|sect_hdr
operator|=
name|IMAGE_FIRST_SECTION
argument_list|(
name|nt_hdr
argument_list|)
expr_stmt|;
comment|/* 	 * The test here is to see if the RVA falls somewhere 	 * inside the section, based on the section's start RVA 	 * and its length. However it seems sometimes the 	 * virtual length isn't enough to cover the entire 	 * area of the section. We fudge by taking into account 	 * the section alignment and rounding the section length 	 * up to a page boundary. 	 */
while|while
condition|(
name|i
operator|++
operator|<
name|sections
condition|)
block|{
name|fixedlen
operator|=
name|sect_hdr
operator|->
name|ish_misc
operator|.
name|ish_vsize
expr_stmt|;
name|fixedlen
operator|+=
operator|(
operator|(
name|opt_hdr
operator|.
name|ioh_sectalign
operator|-
literal|1
operator|)
operator|-
name|sect_hdr
operator|->
name|ish_misc
operator|.
name|ish_vsize
operator|)
operator|&
operator|(
name|opt_hdr
operator|.
name|ioh_sectalign
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|sect_hdr
operator|->
name|ish_vaddr
operator|<=
operator|(
name|uint32_t
operator|)
name|rva
operator|&&
operator|(
name|sect_hdr
operator|->
name|ish_vaddr
operator|+
name|fixedlen
operator|)
operator|>
operator|(
name|uint32_t
operator|)
name|rva
condition|)
break|break;
name|sect_hdr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
name|sections
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
call|(
name|vm_offset_t
call|)
argument_list|(
name|imgbase
operator|+
name|rva
operator|-
name|sect_hdr
operator|->
name|ish_vaddr
operator|+
name|sect_hdr
operator|->
name|ish_rawdataaddr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the section header for a particular section. Note that  * section names can be anything, but there are some standard  * ones (.text, .data, .rdata, .reloc).  */
end_comment

begin_function
name|int
name|pe_get_section
parameter_list|(
name|imgbase
parameter_list|,
name|hdr
parameter_list|,
name|name
parameter_list|)
name|vm_offset_t
name|imgbase
decl_stmt|;
name|image_section_header
modifier|*
name|hdr
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|image_dos_header
modifier|*
name|dos_hdr
decl_stmt|;
name|image_nt_header
modifier|*
name|nt_hdr
decl_stmt|;
name|image_section_header
modifier|*
name|sect_hdr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|sections
decl_stmt|;
if|if
condition|(
name|imgbase
operator|==
literal|0
operator|||
name|hdr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|pe_is_nt_image
argument_list|(
name|imgbase
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sections
operator|=
name|pe_numsections
argument_list|(
name|imgbase
argument_list|)
expr_stmt|;
name|dos_hdr
operator|=
operator|(
name|image_dos_header
operator|*
operator|)
name|imgbase
expr_stmt|;
name|nt_hdr
operator|=
operator|(
name|image_nt_header
operator|*
operator|)
operator|(
name|imgbase
operator|+
name|dos_hdr
operator|->
name|idh_lfanew
operator|)
expr_stmt|;
name|sect_hdr
operator|=
name|IMAGE_FIRST_SECTION
argument_list|(
name|nt_hdr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sections
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sect_hdr
operator|->
name|ish_name
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sect_hdr
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|image_section_header
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|sect_hdr
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENOEXEC
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Apply the base relocations to this image. The relocation table  * resides within the .reloc section. Relocations are specified in  * blocks which refer to a particular page. We apply the relocations  * one page block at a time.  */
end_comment

begin_function
name|int
name|pe_relocate
parameter_list|(
name|imgbase
parameter_list|)
name|vm_offset_t
name|imgbase
decl_stmt|;
block|{
name|image_section_header
name|sect
decl_stmt|;
name|image_base_reloc
modifier|*
name|relhdr
decl_stmt|;
name|uint16_t
name|rel
decl_stmt|,
modifier|*
name|sloc
decl_stmt|;
name|vm_offset_t
name|base
decl_stmt|;
name|vm_size_t
name|delta
decl_stmt|;
name|uint32_t
modifier|*
name|lloc
decl_stmt|;
name|uint64_t
modifier|*
name|qloc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|vm_offset_t
name|txt
decl_stmt|;
name|base
operator|=
name|pe_imagebase
argument_list|(
name|imgbase
argument_list|)
expr_stmt|;
name|pe_get_section
argument_list|(
name|imgbase
argument_list|,
operator|&
name|sect
argument_list|,
literal|".text"
argument_list|)
expr_stmt|;
name|txt
operator|=
name|pe_translate_addr
argument_list|(
name|imgbase
argument_list|,
name|sect
operator|.
name|ish_vaddr
argument_list|)
expr_stmt|;
name|delta
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|txt
argument_list|)
operator|-
name|base
operator|-
name|sect
operator|.
name|ish_vaddr
expr_stmt|;
name|pe_get_section
argument_list|(
name|imgbase
argument_list|,
operator|&
name|sect
argument_list|,
literal|".reloc"
argument_list|)
expr_stmt|;
name|relhdr
operator|=
operator|(
name|image_base_reloc
operator|*
operator|)
operator|(
name|imgbase
operator|+
name|sect
operator|.
name|ish_rawdataaddr
operator|)
expr_stmt|;
do|do
block|{
name|count
operator|=
operator|(
name|relhdr
operator|->
name|ibr_blocksize
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
literal|2
operator|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|rel
operator|=
name|relhdr
operator|->
name|ibr_rel
index|[
name|i
index|]
expr_stmt|;
switch|switch
condition|(
name|IMR_RELTYPE
argument_list|(
name|rel
argument_list|)
condition|)
block|{
case|case
name|IMAGE_REL_BASED_ABSOLUTE
case|:
break|break;
case|case
name|IMAGE_REL_BASED_HIGHLOW
case|:
name|lloc
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|pe_translate_addr
argument_list|(
name|imgbase
argument_list|,
name|relhdr
operator|->
name|ibr_vaddr
operator|+
name|IMR_RELOFFSET
argument_list|(
name|rel
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|lloc
operator|=
name|pe_translate_addr
argument_list|(
name|imgbase
argument_list|,
operator|(
operator|*
name|lloc
operator|-
name|base
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IMAGE_REL_BASED_HIGH
case|:
name|sloc
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|pe_translate_addr
argument_list|(
name|imgbase
argument_list|,
name|relhdr
operator|->
name|ibr_vaddr
operator|+
name|IMR_RELOFFSET
argument_list|(
name|rel
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|sloc
operator|+=
operator|(
name|delta
operator|&
literal|0xFFFF0000
operator|)
operator|>>
literal|16
expr_stmt|;
break|break;
case|case
name|IMAGE_REL_BASED_LOW
case|:
name|sloc
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|pe_translate_addr
argument_list|(
name|imgbase
argument_list|,
name|relhdr
operator|->
name|ibr_vaddr
operator|+
name|IMR_RELOFFSET
argument_list|(
name|rel
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|sloc
operator|+=
operator|(
name|delta
operator|&
literal|0xFFFF
operator|)
expr_stmt|;
break|break;
case|case
name|IMAGE_REL_BASED_DIR64
case|:
name|qloc
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|pe_translate_addr
argument_list|(
name|imgbase
argument_list|,
name|relhdr
operator|->
name|ibr_vaddr
operator|+
name|IMR_RELOFFSET
argument_list|(
name|rel
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|qloc
operator|=
name|pe_translate_addr
argument_list|(
name|imgbase
argument_list|,
operator|(
operator|*
name|qloc
operator|-
name|base
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"[%d]reloc type: %d\n"
argument_list|,
name|i
argument_list|,
name|IMR_RELTYPE
argument_list|(
name|rel
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|relhdr
operator|=
operator|(
name|image_base_reloc
operator|*
operator|)
operator|(
operator|(
name|vm_offset_t
operator|)
name|relhdr
operator|+
name|relhdr
operator|->
name|ibr_blocksize
operator|)
expr_stmt|;
block|}
do|while
condition|(
name|relhdr
operator|->
name|ibr_blocksize
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the import descriptor for a particular module. An image  * may be linked against several modules, typically HAL.dll, ntoskrnl.exe  * and NDIS.SYS. For each module, there is a list of imported function  * names and their addresses.  *  * Note: module names are case insensitive!  */
end_comment

begin_function
name|int
name|pe_get_import_descriptor
parameter_list|(
name|imgbase
parameter_list|,
name|desc
parameter_list|,
name|module
parameter_list|)
name|vm_offset_t
name|imgbase
decl_stmt|;
name|image_import_descriptor
modifier|*
name|desc
decl_stmt|;
name|char
modifier|*
name|module
decl_stmt|;
block|{
name|vm_offset_t
name|offset
decl_stmt|;
name|image_import_descriptor
modifier|*
name|imp_desc
decl_stmt|;
name|char
modifier|*
name|modname
decl_stmt|;
if|if
condition|(
name|imgbase
operator|==
literal|0
operator|||
name|module
operator|==
name|NULL
operator|||
name|desc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|offset
operator|=
name|pe_directory_offset
argument_list|(
name|imgbase
argument_list|,
name|IMAGE_DIRECTORY_ENTRY_IMPORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|imp_desc
operator|=
operator|(
name|void
operator|*
operator|)
name|offset
expr_stmt|;
while|while
condition|(
name|imp_desc
operator|->
name|iid_nameaddr
condition|)
block|{
name|modname
operator|=
operator|(
name|char
operator|*
operator|)
name|pe_translate_addr
argument_list|(
name|imgbase
argument_list|,
name|imp_desc
operator|->
name|iid_nameaddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncasecmp
argument_list|(
name|module
argument_list|,
name|modname
argument_list|,
name|strlen
argument_list|(
name|module
argument_list|)
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|imp_desc
argument_list|,
operator|(
name|char
operator|*
operator|)
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|image_import_descriptor
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|imp_desc
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pe_get_messagetable
parameter_list|(
name|imgbase
parameter_list|,
name|md
parameter_list|)
name|vm_offset_t
name|imgbase
decl_stmt|;
name|message_resource_data
modifier|*
modifier|*
name|md
decl_stmt|;
block|{
name|image_resource_directory
modifier|*
name|rdir
decl_stmt|,
modifier|*
name|rtype
decl_stmt|;
name|image_resource_directory_entry
modifier|*
name|dent
decl_stmt|,
modifier|*
name|dent2
decl_stmt|;
name|image_resource_data_entry
modifier|*
name|rent
decl_stmt|;
name|vm_offset_t
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|imgbase
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|offset
operator|=
name|pe_directory_offset
argument_list|(
name|imgbase
argument_list|,
name|IMAGE_DIRECTORY_ENTRY_RESOURCE
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|rdir
operator|=
operator|(
name|image_resource_directory
operator|*
operator|)
name|offset
expr_stmt|;
name|dent
operator|=
operator|(
name|image_resource_directory_entry
operator|*
operator|)
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
name|image_resource_directory
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rdir
operator|->
name|ird_id_entries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dent
operator|->
name|irde_name
operator|!=
name|RT_MESSAGETABLE
condition|)
block|{
name|dent
operator|++
expr_stmt|;
continue|continue;
block|}
name|dent2
operator|=
name|dent
expr_stmt|;
while|while
condition|(
name|dent2
operator|->
name|irde_dataoff
operator|&
name|RESOURCE_DIR_FLAG
condition|)
block|{
name|rtype
operator|=
operator|(
name|image_resource_directory
operator|*
operator|)
operator|(
name|offset
operator|+
operator|(
name|dent2
operator|->
name|irde_dataoff
operator|&
operator|~
name|RESOURCE_DIR_FLAG
operator|)
operator|)
expr_stmt|;
name|dent2
operator|=
operator|(
name|image_resource_directory_entry
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|rtype
operator|+
sizeof|sizeof
argument_list|(
name|image_resource_directory
argument_list|)
operator|)
expr_stmt|;
block|}
name|rent
operator|=
operator|(
name|image_resource_data_entry
operator|*
operator|)
operator|(
name|offset
operator|+
name|dent2
operator|->
name|irde_dataoff
operator|)
expr_stmt|;
operator|*
name|md
operator|=
operator|(
name|message_resource_data
operator|*
operator|)
name|pe_translate_addr
argument_list|(
name|imgbase
argument_list|,
name|rent
operator|->
name|irde_offset
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pe_get_message
parameter_list|(
name|imgbase
parameter_list|,
name|id
parameter_list|,
name|str
parameter_list|,
name|len
parameter_list|,
name|flags
parameter_list|)
name|vm_offset_t
name|imgbase
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
name|int
modifier|*
name|len
decl_stmt|;
name|uint16_t
modifier|*
name|flags
decl_stmt|;
block|{
name|message_resource_data
modifier|*
name|md
init|=
name|NULL
decl_stmt|;
name|message_resource_block
modifier|*
name|mb
decl_stmt|;
name|message_resource_entry
modifier|*
name|me
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|pe_get_messagetable
argument_list|(
name|imgbase
argument_list|,
operator|&
name|md
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|mb
operator|=
operator|(
name|message_resource_block
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|md
operator|+
sizeof|sizeof
argument_list|(
name|message_resource_data
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|md
operator|->
name|mrd_numblocks
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|id
operator|>=
name|mb
operator|->
name|mrb_lowid
operator|&&
name|id
operator|<=
name|mb
operator|->
name|mrb_highid
condition|)
block|{
name|me
operator|=
operator|(
name|message_resource_entry
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|md
operator|+
name|mb
operator|->
name|mrb_entryoff
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|id
operator|-
name|mb
operator|->
name|mrb_lowid
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|me
operator|=
operator|(
name|message_resource_entry
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|me
operator|+
name|me
operator|->
name|mre_len
operator|)
expr_stmt|;
operator|*
name|str
operator|=
name|me
operator|->
name|mre_text
expr_stmt|;
operator|*
name|len
operator|=
name|me
operator|->
name|mre_len
expr_stmt|;
operator|*
name|flags
operator|=
name|me
operator|->
name|mre_flags
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mb
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the function that matches a particular name. This doesn't  * need to be particularly speedy since it's only run when loading  * a module for the first time.  */
end_comment

begin_function
specifier|static
name|vm_offset_t
name|pe_functbl_match
parameter_list|(
name|functbl
parameter_list|,
name|name
parameter_list|)
name|image_patch_table
modifier|*
name|functbl
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|image_patch_table
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|functbl
operator|==
name|NULL
operator|||
name|name
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|=
name|functbl
expr_stmt|;
while|while
condition|(
name|p
operator|->
name|ipt_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|p
operator|->
name|ipt_name
argument_list|,
name|name
argument_list|)
condition|)
return|return
operator|(
operator|(
name|vm_offset_t
operator|)
name|p
operator|->
name|ipt_wrap
operator|)
return|;
name|p
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"no match for %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Return the wrapper pointer for this routine. 	 * For x86, this is the same as the funcptr. 	 * For amd64, this points to a wrapper routine 	 * that does calling convention translation and 	 * then invokes the underlying routine. 	 */
return|return
operator|(
operator|(
name|vm_offset_t
operator|)
name|p
operator|->
name|ipt_wrap
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Patch the imported function addresses for a given module.  * The caller must specify the module name and provide a table  * of function pointers that will be patched into the jump table.  * Note that there are actually two copies of the jump table: one  * copy is left alone. In a .SYS file, the jump tables are usually  * merged into the INIT segment.  */
end_comment

begin_function
name|int
name|pe_patch_imports
parameter_list|(
name|imgbase
parameter_list|,
name|module
parameter_list|,
name|functbl
parameter_list|)
name|vm_offset_t
name|imgbase
decl_stmt|;
name|char
modifier|*
name|module
decl_stmt|;
name|image_patch_table
modifier|*
name|functbl
decl_stmt|;
block|{
name|image_import_descriptor
name|imp_desc
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|vm_offset_t
modifier|*
name|nptr
decl_stmt|,
modifier|*
name|fptr
decl_stmt|;
name|vm_offset_t
name|func
decl_stmt|;
if|if
condition|(
name|imgbase
operator|==
literal|0
operator|||
name|module
operator|==
name|NULL
operator|||
name|functbl
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|pe_get_import_descriptor
argument_list|(
name|imgbase
argument_list|,
operator|&
name|imp_desc
argument_list|,
name|module
argument_list|)
condition|)
return|return
operator|(
name|ENOEXEC
operator|)
return|;
name|nptr
operator|=
operator|(
name|vm_offset_t
operator|*
operator|)
name|pe_translate_addr
argument_list|(
name|imgbase
argument_list|,
name|imp_desc
operator|.
name|iid_import_name_table_addr
argument_list|)
expr_stmt|;
name|fptr
operator|=
operator|(
name|vm_offset_t
operator|*
operator|)
name|pe_translate_addr
argument_list|(
name|imgbase
argument_list|,
name|imp_desc
operator|.
name|iid_import_address_table_addr
argument_list|)
expr_stmt|;
while|while
condition|(
name|nptr
operator|!=
name|NULL
operator|&&
name|pe_translate_addr
argument_list|(
name|imgbase
argument_list|,
operator|*
name|nptr
argument_list|)
condition|)
block|{
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
name|pe_translate_addr
argument_list|(
name|imgbase
argument_list|,
operator|(
operator|*
name|nptr
operator|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|func
operator|=
name|pe_functbl_match
argument_list|(
name|functbl
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
condition|)
operator|*
name|fptr
operator|=
name|func
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
operator|*
name|fptr
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
endif|#
directive|endif
name|nptr
operator|++
expr_stmt|;
name|fptr
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

