begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005  *      Bill Paul<wpaul@windriver.com>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Bill Paul.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<legacy/dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<legacy/dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<legacy/dev/usb/usbdi_util.h>
end_include

begin_include
include|#
directive|include
file|<legacy/dev/usb/usbdivar.h>
end_include

begin_include
include|#
directive|include
file|<legacy/dev/usb/usb_quirks.h>
end_include

begin_include
include|#
directive|include
file|"usbdevs.h"
end_include

begin_include
include|#
directive|include
file|<compat/ndis/pe_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/cfg_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/resource_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/ntoskrnl_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/ndis_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/hal_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/usbd_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/if_ndis/if_ndisvar.h>
end_include

begin_decl_stmt
specifier|static
name|driver_object
name|usbd_driver
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int32_t
name|usbd_func_bulkintr
parameter_list|(
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|usbd_func_vendorclass
parameter_list|(
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|usbd_func_selconf
parameter_list|(
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|usbd_func_getdesc
parameter_list|(
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|usbd_get_desc_ndis
parameter_list|(
name|usbd_device_handle
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|union
name|usbd_urb
modifier|*
name|usbd_geturb
parameter_list|(
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_status
name|usbd_init_ndispipe
parameter_list|(
name|irp
modifier|*
parameter_list|,
name|usb_endpoint_descriptor_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usbd_xfer_handle
name|usbd_init_ndisxfer
parameter_list|(
name|irp
modifier|*
parameter_list|,
name|usb_endpoint_descriptor_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|usbd_iodispatch
parameter_list|(
name|device_object
modifier|*
parameter_list|,
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|usbd_ioinvalid
parameter_list|(
name|device_object
modifier|*
parameter_list|,
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|usbd_pnp
parameter_list|(
name|device_object
modifier|*
parameter_list|,
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|usbd_power
parameter_list|(
name|device_object
modifier|*
parameter_list|,
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usbd_irpcancel
parameter_list|(
name|device_object
modifier|*
parameter_list|,
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usbd_irpcancel_cb
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|usbd_submit_urb
parameter_list|(
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|usbd_urb2nt
parameter_list|(
name|int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usbd_xfereof
parameter_list|(
name|usbd_xfer_handle
parameter_list|,
name|usbd_private_handle
parameter_list|,
name|usbd_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usbd_xferadd
parameter_list|(
name|usbd_xfer_handle
parameter_list|,
name|usbd_private_handle
parameter_list|,
name|usbd_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usbd_xfertask
parameter_list|(
name|device_object
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dummy
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|union
name|usbd_urb
modifier|*
name|USBD_CreateConfigurationRequestEx
parameter_list|(
name|usb_config_descriptor_t
modifier|*
parameter_list|,
name|struct
name|usbd_interface_list_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|union
name|usbd_urb
modifier|*
name|USBD_CreateConfigurationRequest
parameter_list|(
name|usb_config_descriptor_t
modifier|*
parameter_list|,
name|uint16_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|USBD_GetUSBDIVersion
parameter_list|(
name|usbd_version_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb_interface_descriptor_t
modifier|*
name|USBD_ParseConfigurationDescriptorEx
parameter_list|(
name|usb_config_descriptor_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int32_t
parameter_list|,
name|int32_t
parameter_list|,
name|int32_t
parameter_list|,
name|int32_t
parameter_list|,
name|int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb_interface_descriptor_t
modifier|*
name|USBD_ParseConfigurationDescriptor
parameter_list|(
name|usb_config_descriptor_t
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * We need to wrap these functions because these need `context switch' from  * Windows to UNIX before it's called.  */
end_comment

begin_decl_stmt
specifier|static
name|funcptr
name|usbd_iodispatch_wrap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|funcptr
name|usbd_ioinvalid_wrap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|funcptr
name|usbd_pnp_wrap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|funcptr
name|usbd_power_wrap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|funcptr
name|usbd_irpcancel_wrap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|funcptr
name|usbd_xfertask_wrap
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|usbd_libinit
parameter_list|(
name|void
parameter_list|)
block|{
name|image_patch_table
modifier|*
name|patch
decl_stmt|;
name|int
name|i
decl_stmt|;
name|patch
operator|=
name|usbd_functbl
expr_stmt|;
while|while
condition|(
name|patch
operator|->
name|ipt_func
operator|!=
name|NULL
condition|)
block|{
name|windrv_wrap
argument_list|(
operator|(
name|funcptr
operator|)
name|patch
operator|->
name|ipt_func
argument_list|,
operator|(
name|funcptr
operator|*
operator|)
operator|&
name|patch
operator|->
name|ipt_wrap
argument_list|,
name|patch
operator|->
name|ipt_argcnt
argument_list|,
name|patch
operator|->
name|ipt_ftype
argument_list|)
expr_stmt|;
name|patch
operator|++
expr_stmt|;
block|}
name|windrv_wrap
argument_list|(
operator|(
name|funcptr
operator|)
name|usbd_ioinvalid
argument_list|,
operator|(
name|funcptr
operator|*
operator|)
operator|&
name|usbd_ioinvalid_wrap
argument_list|,
literal|2
argument_list|,
name|WINDRV_WRAP_STDCALL
argument_list|)
expr_stmt|;
name|windrv_wrap
argument_list|(
operator|(
name|funcptr
operator|)
name|usbd_iodispatch
argument_list|,
operator|(
name|funcptr
operator|*
operator|)
operator|&
name|usbd_iodispatch_wrap
argument_list|,
literal|2
argument_list|,
name|WINDRV_WRAP_STDCALL
argument_list|)
expr_stmt|;
name|windrv_wrap
argument_list|(
operator|(
name|funcptr
operator|)
name|usbd_pnp
argument_list|,
operator|(
name|funcptr
operator|*
operator|)
operator|&
name|usbd_pnp_wrap
argument_list|,
literal|2
argument_list|,
name|WINDRV_WRAP_STDCALL
argument_list|)
expr_stmt|;
name|windrv_wrap
argument_list|(
operator|(
name|funcptr
operator|)
name|usbd_power
argument_list|,
operator|(
name|funcptr
operator|*
operator|)
operator|&
name|usbd_power_wrap
argument_list|,
literal|2
argument_list|,
name|WINDRV_WRAP_STDCALL
argument_list|)
expr_stmt|;
name|windrv_wrap
argument_list|(
operator|(
name|funcptr
operator|)
name|usbd_irpcancel
argument_list|,
operator|(
name|funcptr
operator|*
operator|)
operator|&
name|usbd_irpcancel_wrap
argument_list|,
literal|2
argument_list|,
name|WINDRV_WRAP_STDCALL
argument_list|)
expr_stmt|;
name|windrv_wrap
argument_list|(
operator|(
name|funcptr
operator|)
name|usbd_xfertask
argument_list|,
operator|(
name|funcptr
operator|*
operator|)
operator|&
name|usbd_xfertask_wrap
argument_list|,
literal|2
argument_list|,
name|WINDRV_WRAP_STDCALL
argument_list|)
expr_stmt|;
comment|/* Create a fake USB driver instance. */
name|windrv_bus_attach
argument_list|(
operator|&
name|usbd_driver
argument_list|,
literal|"USB Bus"
argument_list|)
expr_stmt|;
comment|/* Set up our dipatch routine. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|IRP_MJ_MAXIMUM_FUNCTION
condition|;
name|i
operator|++
control|)
name|usbd_driver
operator|.
name|dro_dispatch
index|[
name|i
index|]
operator|=
operator|(
name|driver_dispatch
operator|)
name|usbd_ioinvalid_wrap
expr_stmt|;
name|usbd_driver
operator|.
name|dro_dispatch
index|[
name|IRP_MJ_INTERNAL_DEVICE_CONTROL
index|]
operator|=
operator|(
name|driver_dispatch
operator|)
name|usbd_iodispatch_wrap
expr_stmt|;
name|usbd_driver
operator|.
name|dro_dispatch
index|[
name|IRP_MJ_DEVICE_CONTROL
index|]
operator|=
operator|(
name|driver_dispatch
operator|)
name|usbd_iodispatch_wrap
expr_stmt|;
name|usbd_driver
operator|.
name|dro_dispatch
index|[
name|IRP_MJ_POWER
index|]
operator|=
operator|(
name|driver_dispatch
operator|)
name|usbd_power_wrap
expr_stmt|;
name|usbd_driver
operator|.
name|dro_dispatch
index|[
name|IRP_MJ_PNP
index|]
operator|=
operator|(
name|driver_dispatch
operator|)
name|usbd_pnp_wrap
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usbd_libfini
parameter_list|(
name|void
parameter_list|)
block|{
name|image_patch_table
modifier|*
name|patch
decl_stmt|;
name|patch
operator|=
name|usbd_functbl
expr_stmt|;
while|while
condition|(
name|patch
operator|->
name|ipt_func
operator|!=
name|NULL
condition|)
block|{
name|windrv_unwrap
argument_list|(
name|patch
operator|->
name|ipt_wrap
argument_list|)
expr_stmt|;
name|patch
operator|++
expr_stmt|;
block|}
name|windrv_unwrap
argument_list|(
name|usbd_ioinvalid_wrap
argument_list|)
expr_stmt|;
name|windrv_unwrap
argument_list|(
name|usbd_iodispatch_wrap
argument_list|)
expr_stmt|;
name|windrv_unwrap
argument_list|(
name|usbd_pnp_wrap
argument_list|)
expr_stmt|;
name|windrv_unwrap
argument_list|(
name|usbd_power_wrap
argument_list|)
expr_stmt|;
name|windrv_unwrap
argument_list|(
name|usbd_irpcancel_wrap
argument_list|)
expr_stmt|;
name|windrv_unwrap
argument_list|(
name|usbd_xfertask_wrap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|usbd_driver
operator|.
name|dro_drivername
operator|.
name|us_buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|usbd_iodispatch
parameter_list|(
name|dobj
parameter_list|,
name|ip
parameter_list|)
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|dobj
operator|->
name|do_devext
decl_stmt|;
name|int32_t
name|status
decl_stmt|;
name|struct
name|io_stack_location
modifier|*
name|irp_sl
decl_stmt|;
name|irp_sl
operator|=
name|IoGetCurrentIrpStackLocation
argument_list|(
name|ip
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|irp_sl
operator|->
name|isl_parameters
operator|.
name|isl_ioctl
operator|.
name|isl_iocode
condition|)
block|{
case|case
name|IOCTL_INTERNAL_USB_SUBMIT_URB
case|:
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
operator|=
name|dev
expr_stmt|;
name|status
operator|=
name|usbd_submit_urb
argument_list|(
name|ip
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ioctl 0x%x isn't supported\n"
argument_list|,
name|irp_sl
operator|->
name|isl_parameters
operator|.
name|isl_ioctl
operator|.
name|isl_iocode
argument_list|)
expr_stmt|;
name|status
operator|=
name|USBD_STATUS_NOT_SUPPORTED
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|status
operator|==
name|USBD_STATUS_PENDING
condition|)
return|return
operator|(
name|STATUS_PENDING
operator|)
return|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|=
name|usbd_urb2nt
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|USBD_STATUS_SUCCESS
condition|)
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_info
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|usbd_ioinvalid
parameter_list|(
name|dobj
parameter_list|,
name|ip
parameter_list|)
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|dobj
operator|->
name|do_devext
decl_stmt|;
name|struct
name|io_stack_location
modifier|*
name|irp_sl
decl_stmt|;
name|irp_sl
operator|=
name|IoGetCurrentIrpStackLocation
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"invalid I/O dispatch %d:%d\n"
argument_list|,
name|irp_sl
operator|->
name|isl_major
argument_list|,
name|irp_sl
operator|->
name|isl_minor
argument_list|)
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|=
name|STATUS_FAILURE
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_info
operator|=
literal|0
expr_stmt|;
name|IoCompleteRequest
argument_list|(
name|ip
argument_list|,
name|IO_NO_INCREMENT
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_FAILURE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|usbd_pnp
parameter_list|(
name|dobj
parameter_list|,
name|ip
parameter_list|)
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|dobj
operator|->
name|do_devext
decl_stmt|;
name|struct
name|io_stack_location
modifier|*
name|irp_sl
decl_stmt|;
name|irp_sl
operator|=
name|IoGetCurrentIrpStackLocation
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: unsupported I/O dispatch %d:%d\n"
argument_list|,
name|__func__
argument_list|,
name|irp_sl
operator|->
name|isl_major
argument_list|,
name|irp_sl
operator|->
name|isl_minor
argument_list|)
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|=
name|STATUS_FAILURE
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_info
operator|=
literal|0
expr_stmt|;
name|IoCompleteRequest
argument_list|(
name|ip
argument_list|,
name|IO_NO_INCREMENT
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_FAILURE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|usbd_power
parameter_list|(
name|dobj
parameter_list|,
name|ip
parameter_list|)
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|dobj
operator|->
name|do_devext
decl_stmt|;
name|struct
name|io_stack_location
modifier|*
name|irp_sl
decl_stmt|;
name|irp_sl
operator|=
name|IoGetCurrentIrpStackLocation
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: unsupported I/O dispatch %d:%d\n"
argument_list|,
name|__func__
argument_list|,
name|irp_sl
operator|->
name|isl_major
argument_list|,
name|irp_sl
operator|->
name|isl_minor
argument_list|)
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|=
name|STATUS_FAILURE
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_info
operator|=
literal|0
expr_stmt|;
name|IoCompleteRequest
argument_list|(
name|ip
argument_list|,
name|IO_NO_INCREMENT
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_FAILURE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert USBD_STATUS to NTSTATUS  */
end_comment

begin_function
specifier|static
name|int32_t
name|usbd_urb2nt
parameter_list|(
name|status
parameter_list|)
name|int32_t
name|status
decl_stmt|;
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|USBD_STATUS_SUCCESS
case|:
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
case|case
name|USBD_STATUS_DEVICE_GONE
case|:
return|return
operator|(
name|STATUS_DEVICE_NOT_CONNECTED
operator|)
return|;
case|case
name|USBD_STATUS_PENDING
case|:
return|return
operator|(
name|STATUS_PENDING
operator|)
return|;
case|case
name|USBD_STATUS_NOT_SUPPORTED
case|:
return|return
operator|(
name|STATUS_NOT_IMPLEMENTED
operator|)
return|;
case|case
name|USBD_STATUS_NO_MEMORY
case|:
return|return
operator|(
name|STATUS_NO_MEMORY
operator|)
return|;
case|case
name|USBD_STATUS_REQUEST_FAILED
case|:
return|return
operator|(
name|STATUS_NOT_SUPPORTED
operator|)
return|;
case|case
name|USBD_STATUS_CANCELED
case|:
return|return
operator|(
name|STATUS_CANCELLED
operator|)
return|;
default|default:
break|break;
block|}
return|return
operator|(
name|STATUS_FAILURE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert FreeBSD's usbd_status to USBD_STATUS  */
end_comment

begin_function
specifier|static
name|int32_t
name|usbd_usb2urb
parameter_list|(
name|int
name|status
parameter_list|)
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|USBD_NORMAL_COMPLETION
case|:
return|return
operator|(
name|USBD_STATUS_SUCCESS
operator|)
return|;
case|case
name|USBD_IN_PROGRESS
case|:
return|return
operator|(
name|USBD_STATUS_PENDING
operator|)
return|;
case|case
name|USBD_TIMEOUT
case|:
return|return
operator|(
name|USBD_STATUS_TIMEOUT
operator|)
return|;
case|case
name|USBD_SHORT_XFER
case|:
return|return
operator|(
name|USBD_STATUS_ERROR_SHORT_TRANSFER
operator|)
return|;
case|case
name|USBD_IOERROR
case|:
return|return
operator|(
name|USBD_STATUS_XACT_ERROR
operator|)
return|;
case|case
name|USBD_NOMEM
case|:
return|return
operator|(
name|USBD_STATUS_NO_MEMORY
operator|)
return|;
case|case
name|USBD_INVAL
case|:
return|return
operator|(
name|USBD_STATUS_REQUEST_FAILED
operator|)
return|;
case|case
name|USBD_NOT_STARTED
case|:
case|case
name|USBD_TOO_DEEP
case|:
case|case
name|USBD_NO_POWER
case|:
return|return
operator|(
name|USBD_STATUS_DEVICE_GONE
operator|)
return|;
case|case
name|USBD_CANCELLED
case|:
return|return
operator|(
name|USBD_STATUS_CANCELED
operator|)
return|;
default|default:
break|break;
block|}
return|return
operator|(
name|USBD_STATUS_NOT_SUPPORTED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|union
name|usbd_urb
modifier|*
name|usbd_geturb
parameter_list|(
name|ip
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|struct
name|io_stack_location
modifier|*
name|irp_sl
decl_stmt|;
name|irp_sl
operator|=
name|IoGetCurrentIrpStackLocation
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|irp_sl
operator|->
name|isl_parameters
operator|.
name|isl_others
operator|.
name|isl_arg1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|usbd_submit_urb
parameter_list|(
name|ip
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|int32_t
name|status
decl_stmt|;
name|union
name|usbd_urb
modifier|*
name|urb
decl_stmt|;
name|urb
operator|=
name|usbd_geturb
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* 	 * In a case of URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER, 	 * USBD_URB_STATUS(urb) would be set at callback functions like 	 * usbd_intr() or usbd_xfereof(). 	 */
switch|switch
condition|(
name|urb
operator|->
name|uu_hdr
operator|.
name|uuh_func
condition|)
block|{
case|case
name|URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER
case|:
name|status
operator|=
name|usbd_func_bulkintr
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|USBD_STATUS_SUCCESS
operator|&&
name|status
operator|!=
name|USBD_STATUS_PENDING
condition|)
name|USBD_URB_STATUS
argument_list|(
name|urb
argument_list|)
operator|=
name|status
expr_stmt|;
break|break;
case|case
name|URB_FUNCTION_VENDOR_DEVICE
case|:
case|case
name|URB_FUNCTION_VENDOR_INTERFACE
case|:
case|case
name|URB_FUNCTION_VENDOR_ENDPOINT
case|:
case|case
name|URB_FUNCTION_VENDOR_OTHER
case|:
case|case
name|URB_FUNCTION_CLASS_DEVICE
case|:
case|case
name|URB_FUNCTION_CLASS_INTERFACE
case|:
case|case
name|URB_FUNCTION_CLASS_ENDPOINT
case|:
case|case
name|URB_FUNCTION_CLASS_OTHER
case|:
name|status
operator|=
name|usbd_func_vendorclass
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|USBD_URB_STATUS
argument_list|(
name|urb
argument_list|)
operator|=
name|status
expr_stmt|;
break|break;
case|case
name|URB_FUNCTION_SELECT_CONFIGURATION
case|:
name|status
operator|=
name|usbd_func_selconf
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|USBD_URB_STATUS
argument_list|(
name|urb
argument_list|)
operator|=
name|status
expr_stmt|;
break|break;
case|case
name|URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE
case|:
name|status
operator|=
name|usbd_func_getdesc
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|USBD_URB_STATUS
argument_list|(
name|urb
argument_list|)
operator|=
name|status
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"func 0x%x isn't supported\n"
argument_list|,
name|urb
operator|->
name|uu_hdr
operator|.
name|uuh_func
argument_list|)
expr_stmt|;
name|USBD_URB_STATUS
argument_list|(
name|urb
argument_list|)
operator|=
name|status
operator|=
name|USBD_STATUS_NOT_SUPPORTED
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|usbd_func_getdesc
parameter_list|(
name|ip
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|int
name|actlen
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usbd_urb_control_descriptor_request
modifier|*
name|ctldesc
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|union
name|usbd_urb
modifier|*
name|urb
decl_stmt|;
name|usb_config_descriptor_t
name|cd
decl_stmt|,
modifier|*
name|cdp
decl_stmt|;
name|usbd_status
name|status
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|urb
operator|=
name|usbd_geturb
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ctldesc
operator|=
operator|&
name|urb
operator|->
name|uu_ctldesc
expr_stmt|;
if|if
condition|(
name|ctldesc
operator|->
name|ucd_desctype
operator|==
name|UDESC_CONFIG
condition|)
block|{
comment|/* Get the short config descriptor. */
name|status
operator|=
name|usbd_get_config_desc
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
name|ctldesc
operator|->
name|ucd_idx
argument_list|,
operator|&
name|cd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|ctldesc
operator|->
name|ucd_trans_buflen
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
name|usbd_usb2urb
argument_list|(
name|status
argument_list|)
return|;
block|}
comment|/* Get the full descriptor.  Try a few times for slow devices. */
name|len
operator|=
name|MIN
argument_list|(
name|ctldesc
operator|->
name|ucd_trans_buflen
argument_list|,
name|UGETW
argument_list|(
name|cd
operator|.
name|wTotalLength
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|usbd_get_desc_ndis
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
name|ctldesc
operator|->
name|ucd_desctype
argument_list|,
name|ctldesc
operator|->
name|ucd_idx
argument_list|,
name|len
argument_list|,
name|ctldesc
operator|->
name|ucd_trans_buf
argument_list|,
operator|&
name|actlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|USBD_NORMAL_COMPLETION
condition|)
break|break;
name|usbd_delay_ms
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
literal|200
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|ctldesc
operator|->
name|ucd_trans_buflen
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
name|usbd_usb2urb
argument_list|(
name|status
argument_list|)
return|;
block|}
name|cdp
operator|=
operator|(
name|usb_config_descriptor_t
operator|*
operator|)
name|ctldesc
operator|->
name|ucd_trans_buf
expr_stmt|;
if|if
condition|(
name|cdp
operator|->
name|bDescriptorType
operator|!=
name|UDESC_CONFIG
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bad desc %d\n"
argument_list|,
name|cdp
operator|->
name|bDescriptorType
argument_list|)
expr_stmt|;
name|status
operator|=
name|USBD_INVAL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ctldesc
operator|->
name|ucd_desctype
operator|==
name|UDESC_STRING
condition|)
block|{
comment|/* Try a few times for slow devices.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|status
operator|=
name|usbd_get_string_desc
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
operator|(
name|UDESC_STRING
operator|<<
literal|8
operator|)
operator|+
name|ctldesc
operator|->
name|ucd_idx
argument_list|,
name|ctldesc
operator|->
name|ucd_langid
argument_list|,
name|ctldesc
operator|->
name|ucd_trans_buf
argument_list|,
operator|&
name|actlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|actlen
operator|>
name|ctldesc
operator|->
name|ucd_trans_buflen
condition|)
name|panic
argument_list|(
literal|"small string buffer for UDESC_STRING"
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|USBD_NORMAL_COMPLETION
condition|)
break|break;
name|usbd_delay_ms
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
literal|200
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|status
operator|=
name|usbd_get_desc_ndis
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
name|ctldesc
operator|->
name|ucd_desctype
argument_list|,
name|ctldesc
operator|->
name|ucd_idx
argument_list|,
name|ctldesc
operator|->
name|ucd_trans_buflen
argument_list|,
name|ctldesc
operator|->
name|ucd_trans_buf
argument_list|,
operator|&
name|actlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|ctldesc
operator|->
name|ucd_trans_buflen
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
name|usbd_usb2urb
argument_list|(
name|status
argument_list|)
return|;
block|}
name|ctldesc
operator|->
name|ucd_trans_buflen
operator|=
name|actlen
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_info
operator|=
name|actlen
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_STATUS_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * FIXME: at USB1, not USB2, framework, there's no a interface to get `actlen'.  * However, we need it!!!  */
end_comment

begin_function
specifier|static
name|usbd_status
name|usbd_get_desc_ndis
parameter_list|(
name|usbd_device_handle
name|dev
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|index
parameter_list|,
name|int
name|len
parameter_list|,
name|void
modifier|*
name|desc
parameter_list|,
name|int
modifier|*
name|actlen
parameter_list|)
block|{
name|usb_device_request_t
name|req
decl_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|UT_READ_DEVICE
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|UR_GET_DESCRIPTOR
expr_stmt|;
name|USETW2
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|type
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|usbd_do_request_flags_pipe
argument_list|(
name|dev
argument_list|,
name|dev
operator|->
name|default_pipe
argument_list|,
operator|&
name|req
argument_list|,
name|desc
argument_list|,
literal|0
argument_list|,
name|actlen
argument_list|,
name|USBD_DEFAULT_TIMEOUT
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|usbd_func_selconf
parameter_list|(
name|ip
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usbd_interface_information
modifier|*
name|intf
decl_stmt|;
name|struct
name|usbd_pipe_information
modifier|*
name|pipe
decl_stmt|;
name|struct
name|usbd_urb_select_configuration
modifier|*
name|selconf
decl_stmt|;
name|union
name|usbd_urb
modifier|*
name|urb
decl_stmt|;
name|usb_config_descriptor_t
modifier|*
name|conf
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|edesc
decl_stmt|;
name|usbd_device_handle
name|udev
init|=
name|uaa
operator|->
name|device
decl_stmt|;
name|usbd_interface_handle
name|iface
decl_stmt|;
name|usbd_status
name|ret
decl_stmt|;
name|urb
operator|=
name|usbd_geturb
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|selconf
operator|=
operator|&
name|urb
operator|->
name|uu_selconf
expr_stmt|;
name|conf
operator|=
name|selconf
operator|->
name|usc_conf
expr_stmt|;
if|if
condition|(
name|conf
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"select configuration is NULL\n"
argument_list|)
expr_stmt|;
return|return
name|usbd_usb2urb
argument_list|(
name|USBD_NORMAL_COMPLETION
argument_list|)
return|;
block|}
if|if
condition|(
name|conf
operator|->
name|bConfigurationValue
operator|>
name|NDISUSB_CONFIG_NO
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"warning: config_no is larger than default"
argument_list|)
expr_stmt|;
name|intf
operator|=
operator|&
name|selconf
operator|->
name|usc_intf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|conf
operator|->
name|bNumInterface
operator|&&
name|intf
operator|->
name|uii_len
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|usbd_device2interface_handle
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
name|intf
operator|->
name|uii_intfnum
argument_list|,
operator|&
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"getting interface handle failed: %s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|usbd_usb2urb
argument_list|(
name|ret
argument_list|)
return|;
block|}
name|ret
operator|=
name|usbd_set_interface
argument_list|(
name|iface
argument_list|,
name|intf
operator|->
name|uii_altset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|USBD_NORMAL_COMPLETION
operator|&&
name|ret
operator|!=
name|USBD_IN_USE
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"setting alternate interface failed: %s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|usbd_usb2urb
argument_list|(
name|ret
argument_list|)
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|iface
operator|->
name|idesc
operator|->
name|bNumEndpoints
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
name|intf
operator|->
name|uii_numeps
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"endpoint %d and above are ignored"
argument_list|,
name|intf
operator|->
name|uii_numeps
argument_list|)
expr_stmt|;
break|break;
block|}
name|edesc
operator|=
name|iface
operator|->
name|endpoints
index|[
name|j
index|]
operator|.
name|edesc
expr_stmt|;
name|pipe
operator|=
operator|&
name|intf
operator|->
name|uii_pipes
index|[
name|j
index|]
expr_stmt|;
name|pipe
operator|->
name|upi_handle
operator|=
name|edesc
expr_stmt|;
name|pipe
operator|->
name|upi_epaddr
operator|=
name|edesc
operator|->
name|bEndpointAddress
expr_stmt|;
name|pipe
operator|->
name|upi_maxpktsize
operator|=
name|UGETW
argument_list|(
name|edesc
operator|->
name|wMaxPacketSize
argument_list|)
expr_stmt|;
name|pipe
operator|->
name|upi_type
operator|=
name|UE_GET_XFERTYPE
argument_list|(
name|edesc
operator|->
name|bmAttributes
argument_list|)
expr_stmt|;
if|if
condition|(
name|pipe
operator|->
name|upi_type
operator|!=
name|UE_INTERRUPT
condition|)
continue|continue;
comment|/* XXX we're following linux USB's interval policy.  */
if|if
condition|(
name|udev
operator|->
name|speed
operator|==
name|USB_SPEED_LOW
condition|)
name|pipe
operator|->
name|upi_interval
operator|=
name|edesc
operator|->
name|bInterval
operator|+
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|udev
operator|->
name|speed
operator|==
name|USB_SPEED_FULL
condition|)
name|pipe
operator|->
name|upi_interval
operator|=
name|edesc
operator|->
name|bInterval
expr_stmt|;
else|else
block|{
name|int
name|k0
init|=
literal|0
decl_stmt|,
name|k1
init|=
literal|1
decl_stmt|;
do|do
block|{
name|k1
operator|=
name|k1
operator|*
literal|2
expr_stmt|;
name|k0
operator|=
name|k0
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|k1
operator|<
name|edesc
operator|->
name|bInterval
condition|)
do|;
name|pipe
operator|->
name|upi_interval
operator|=
name|k0
expr_stmt|;
block|}
block|}
name|intf
operator|=
operator|(
expr|struct
name|usbd_interface_information
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|intf
operator|)
operator|+
name|intf
operator|->
name|uii_len
operator|)
expr_stmt|;
block|}
return|return
name|USBD_STATUS_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|usbd_func_vendorclass
parameter_list|(
name|ip
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usbd_urb_vendor_or_class_request
modifier|*
name|vcreq
decl_stmt|;
name|uint8_t
name|type
init|=
literal|0
decl_stmt|;
name|union
name|usbd_urb
modifier|*
name|urb
decl_stmt|;
name|usb_device_request_t
name|req
decl_stmt|;
name|usbd_status
name|status
decl_stmt|;
name|urb
operator|=
name|usbd_geturb
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|vcreq
operator|=
operator|&
name|urb
operator|->
name|uu_vcreq
expr_stmt|;
switch|switch
condition|(
name|urb
operator|->
name|uu_hdr
operator|.
name|uuh_func
condition|)
block|{
case|case
name|URB_FUNCTION_CLASS_DEVICE
case|:
name|type
operator|=
name|UT_CLASS
operator||
name|UT_DEVICE
expr_stmt|;
break|break;
case|case
name|URB_FUNCTION_CLASS_INTERFACE
case|:
name|type
operator|=
name|UT_CLASS
operator||
name|UT_INTERFACE
expr_stmt|;
break|break;
case|case
name|URB_FUNCTION_CLASS_OTHER
case|:
name|type
operator|=
name|UT_CLASS
operator||
name|UT_OTHER
expr_stmt|;
break|break;
case|case
name|URB_FUNCTION_CLASS_ENDPOINT
case|:
name|type
operator|=
name|UT_CLASS
operator||
name|UT_ENDPOINT
expr_stmt|;
break|break;
case|case
name|URB_FUNCTION_VENDOR_DEVICE
case|:
name|type
operator|=
name|UT_VENDOR
operator||
name|UT_DEVICE
expr_stmt|;
break|break;
case|case
name|URB_FUNCTION_VENDOR_INTERFACE
case|:
name|type
operator|=
name|UT_VENDOR
operator||
name|UT_INTERFACE
expr_stmt|;
break|break;
case|case
name|URB_FUNCTION_VENDOR_OTHER
case|:
name|type
operator|=
name|UT_VENDOR
operator||
name|UT_OTHER
expr_stmt|;
break|break;
case|case
name|URB_FUNCTION_VENDOR_ENDPOINT
case|:
name|type
operator|=
name|UT_VENDOR
operator||
name|UT_ENDPOINT
expr_stmt|;
break|break;
default|default:
comment|/* never reach.  */
break|break;
block|}
name|type
operator||=
operator|(
name|vcreq
operator|->
name|uvc_trans_flags
operator|&
name|USBD_TRANSFER_DIRECTION_IN
operator|)
condition|?
name|UT_READ
else|:
name|UT_WRITE
expr_stmt|;
name|type
operator||=
name|vcreq
operator|->
name|uvc_reserved1
expr_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|type
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|vcreq
operator|->
name|uvc_req
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|vcreq
operator|->
name|uvc_idx
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|vcreq
operator|->
name|uvc_value
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
name|vcreq
operator|->
name|uvc_trans_buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcreq
operator|->
name|uvc_trans_flags
operator|&
name|USBD_TRANSFER_DIRECTION_IN
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|status
operator|=
name|usbd_do_request
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
operator|&
name|req
argument_list|,
name|vcreq
operator|->
name|uvc_trans_buf
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
else|else
name|status
operator|=
name|usbd_do_request_async
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
operator|&
name|req
argument_list|,
name|vcreq
operator|->
name|uvc_trans_buf
argument_list|)
expr_stmt|;
return|return
name|usbd_usb2urb
argument_list|(
name|status
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|usbd_status
name|usbd_init_ndispipe
parameter_list|(
name|ip
parameter_list|,
name|ep
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|ep
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|usbd_interface_handle
name|iface
decl_stmt|;
name|usbd_status
name|status
decl_stmt|;
name|status
operator|=
name|usbd_device2interface_handle
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
name|NDISUSB_IFACE_INDEX
argument_list|,
operator|&
name|iface
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not get interface handle\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
switch|switch
condition|(
name|UE_GET_XFERTYPE
argument_list|(
name|ep
operator|->
name|bmAttributes
argument_list|)
condition|)
block|{
case|case
name|UE_BULK
case|:
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|ep
operator|->
name|bEndpointAddress
argument_list|)
operator|==
name|UE_DIR_IN
condition|)
block|{
comment|/* RX (bulk IN)  */
if|if
condition|(
name|sc
operator|->
name|ndisusb_ep
index|[
name|NDISUSB_ENDPT_BIN
index|]
operator|!=
name|NULL
condition|)
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|status
operator|=
name|usbd_open_pipe
argument_list|(
name|iface
argument_list|,
name|ep
operator|->
name|bEndpointAddress
argument_list|,
name|USBD_EXCLUSIVE_USE
argument_list|,
operator|&
name|sc
operator|->
name|ndisusb_ep
index|[
name|NDISUSB_ENDPT_BIN
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* TX (bulk OUT)  */
if|if
condition|(
name|sc
operator|->
name|ndisusb_ep
index|[
name|NDISUSB_ENDPT_BOUT
index|]
operator|!=
name|NULL
condition|)
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|status
operator|=
name|usbd_open_pipe
argument_list|(
name|iface
argument_list|,
name|ep
operator|->
name|bEndpointAddress
argument_list|,
name|USBD_EXCLUSIVE_USE
argument_list|,
operator|&
name|sc
operator|->
name|ndisusb_ep
index|[
name|NDISUSB_ENDPT_BOUT
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|UE_INTERRUPT
case|:
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|ep
operator|->
name|bEndpointAddress
argument_list|)
operator|==
name|UE_DIR_IN
condition|)
block|{
comment|/* Interrupt IN.  */
if|if
condition|(
name|sc
operator|->
name|ndisusb_ep
index|[
name|NDISUSB_ENDPT_IIN
index|]
operator|!=
name|NULL
condition|)
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|status
operator|=
name|usbd_open_pipe
argument_list|(
name|iface
argument_list|,
name|ep
operator|->
name|bEndpointAddress
argument_list|,
name|USBD_EXCLUSIVE_USE
argument_list|,
operator|&
name|sc
operator|->
name|ndisusb_ep
index|[
name|NDISUSB_ENDPT_IIN
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Interrupt OUT.  */
if|if
condition|(
name|sc
operator|->
name|ndisusb_ep
index|[
name|NDISUSB_ENDPT_IOUT
index|]
operator|!=
name|NULL
condition|)
return|return
operator|(
name|USBD_NORMAL_COMPLETION
operator|)
return|;
name|status
operator|=
name|usbd_open_pipe
argument_list|(
name|iface
argument_list|,
name|ep
operator|->
name|bEndpointAddress
argument_list|,
name|USBD_EXCLUSIVE_USE
argument_list|,
operator|&
name|sc
operator|->
name|ndisusb_ep
index|[
name|NDISUSB_ENDPT_IOUT
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can't handle xfertype 0x%x\n"
argument_list|,
name|UE_GET_XFERTYPE
argument_list|(
name|ep
operator|->
name|bmAttributes
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_INVAL
operator|)
return|;
block|}
if|if
condition|(
name|status
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"open pipe failed: (0x%x) %s\n"
argument_list|,
name|ep
operator|->
name|bEndpointAddress
argument_list|,
name|usbd_errstr
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usbd_irpcancel_cb
parameter_list|(
name|priv
parameter_list|)
name|void
modifier|*
name|priv
decl_stmt|;
block|{
name|struct
name|ndisusb_cancel
modifier|*
name|nc
init|=
name|priv
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|nc
operator|->
name|dev
argument_list|)
decl_stmt|;
name|usbd_status
name|status
decl_stmt|;
name|usbd_xfer_handle
name|xfer
init|=
name|nc
operator|->
name|xfer
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|ndisusb_status
operator|&
name|NDISUSB_STATUS_DETACH
condition|)
goto|goto
name|exit
goto|;
name|status
operator|=
name|usbd_abort_pipe
argument_list|(
name|xfer
operator|->
name|pipe
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
name|device_printf
argument_list|(
name|nc
operator|->
name|dev
argument_list|,
literal|"can't be canceld"
argument_list|)
expr_stmt|;
name|exit
label|:
name|free
argument_list|(
name|nc
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usbd_irpcancel
parameter_list|(
name|dobj
parameter_list|,
name|ip
parameter_list|)
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|struct
name|ndisusb_cancel
modifier|*
name|nc
decl_stmt|;
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|IRP_NDISUSB_XFER
argument_list|(
name|ip
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ip
operator|->
name|irp_cancel
operator|=
name|TRUE
expr_stmt|;
name|IoReleaseCancelSpinLock
argument_list|(
name|ip
operator|->
name|irp_cancelirql
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * XXX Since we're under DISPATCH_LEVEL during calling usbd_irpcancel(), 	 * we can't sleep at all.  However, currently FreeBSD's USB stack 	 * requires a sleep to abort a transfer.  It's inevitable! so it causes 	 * serveral fatal problems (e.g. kernel hangups or crashes).  I think 	 * that there are no ways to make this reliable.  In this implementation, 	 * I used usb_add_task() but it's not a perfect method to solve this 	 * because of as follows: NDIS drivers would expect that IRP's 	 * completely canceld when usbd_irpcancel() is returned but we need 	 * a sleep to do it.  During canceling XFERs, usbd_intr() would be 	 * called with a status, USBD_CANCELLED. 	 */
name|nc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ndisusb_cancel
argument_list|)
argument_list|,
name|M_USBDEV
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nc
operator|==
name|NULL
condition|)
block|{
name|ip
operator|->
name|irp_cancel
operator|=
name|FALSE
expr_stmt|;
name|IoReleaseCancelSpinLock
argument_list|(
name|ip
operator|->
name|irp_cancelirql
argument_list|)
expr_stmt|;
return|return;
block|}
name|nc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|nc
operator|->
name|xfer
operator|=
name|IRP_NDISUSB_XFER
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|usb_init_task
argument_list|(
operator|&
name|nc
operator|->
name|task
argument_list|,
name|usbd_irpcancel_cb
argument_list|,
name|nc
argument_list|)
expr_stmt|;
name|IRP_NDISUSB_XFER
argument_list|(
name|ip
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|usb_add_task
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
operator|&
name|nc
operator|->
name|task
argument_list|,
name|USB_TASKQ_DRIVER
argument_list|)
expr_stmt|;
name|ip
operator|->
name|irp_cancel
operator|=
name|TRUE
expr_stmt|;
name|IoReleaseCancelSpinLock
argument_list|(
name|ip
operator|->
name|irp_cancelirql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|usbd_xfer_handle
name|usbd_init_ndisxfer
parameter_list|(
name|ip
parameter_list|,
name|ep
parameter_list|,
name|buf
parameter_list|,
name|buflen
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|ep
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|uint32_t
name|buflen
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|usbd_xfer_handle
name|xfer
decl_stmt|;
name|xfer
operator|=
name|usbd_alloc_xfer
argument_list|(
name|uaa
operator|->
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|buf
operator|!=
name|NULL
operator|&&
name|MmIsAddressValid
argument_list|(
name|buf
argument_list|)
operator|==
name|FALSE
operator|&&
name|buflen
operator|>
literal|0
condition|)
block|{
name|xfer
operator|->
name|buffer
operator|=
name|usbd_alloc_buffer
argument_list|(
name|xfer
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|buffer
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|ep
operator|->
name|bEndpointAddress
argument_list|)
operator|==
name|UE_DIR_OUT
condition|)
name|memcpy
argument_list|(
name|xfer
operator|->
name|buffer
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
block|}
else|else
name|xfer
operator|->
name|buffer
operator|=
name|buf
expr_stmt|;
name|xfer
operator|->
name|length
operator|=
name|buflen
expr_stmt|;
name|IoAcquireCancelSpinLock
argument_list|(
operator|&
name|ip
operator|->
name|irp_cancelirql
argument_list|)
expr_stmt|;
name|IRP_NDISUSB_XFER
argument_list|(
name|ip
argument_list|)
operator|=
name|xfer
expr_stmt|;
name|ip
operator|->
name|irp_cancelfunc
operator|=
operator|(
name|cancel_func
operator|)
name|usbd_irpcancel_wrap
expr_stmt|;
name|IoReleaseCancelSpinLock
argument_list|(
name|ip
operator|->
name|irp_cancelirql
argument_list|)
expr_stmt|;
return|return
operator|(
name|xfer
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usbd_xferadd
parameter_list|(
name|xfer
parameter_list|,
name|priv
parameter_list|,
name|status
parameter_list|)
name|usbd_xfer_handle
name|xfer
decl_stmt|;
name|usbd_private_handle
name|priv
decl_stmt|;
name|usbd_status
name|status
decl_stmt|;
block|{
name|irp
modifier|*
name|ip
init|=
name|priv
decl_stmt|;
name|device_t
name|dev
init|=
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ndisusb_xfer
modifier|*
name|nx
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
name|nx
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ndisusb_xfer
argument_list|)
argument_list|,
name|M_USBDEV
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nx
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
name|nx
operator|->
name|nx_xfer
operator|=
name|xfer
expr_stmt|;
name|nx
operator|->
name|nx_priv
operator|=
name|priv
expr_stmt|;
name|nx
operator|->
name|nx_status
operator|=
name|status
expr_stmt|;
name|KeAcquireSpinLock
argument_list|(
operator|&
name|sc
operator|->
name|ndisusb_xferlock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
name|InsertTailList
argument_list|(
operator|(
operator|&
name|sc
operator|->
name|ndisusb_xferlist
operator|)
argument_list|,
operator|(
operator|&
name|nx
operator|->
name|nx_xferlist
operator|)
argument_list|)
expr_stmt|;
name|KeReleaseSpinLock
argument_list|(
operator|&
name|sc
operator|->
name|ndisusb_xferlock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
name|IoQueueWorkItem
argument_list|(
name|sc
operator|->
name|ndisusb_xferitem
argument_list|,
operator|(
name|io_workitem_func
operator|)
name|usbd_xfertask_wrap
argument_list|,
name|WORKQUEUE_CRITICAL
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usbd_xfereof
parameter_list|(
name|xfer
parameter_list|,
name|priv
parameter_list|,
name|status
parameter_list|)
name|usbd_xfer_handle
name|xfer
decl_stmt|;
name|usbd_private_handle
name|priv
decl_stmt|;
name|usbd_status
name|status
decl_stmt|;
block|{
name|usbd_xferadd
argument_list|(
name|xfer
argument_list|,
name|priv
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usbd_xfertask
parameter_list|(
name|dobj
parameter_list|,
name|arg
parameter_list|)
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|irp
modifier|*
name|ip
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|list_entry
modifier|*
name|l
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ndisusb_xfer
modifier|*
name|nx
decl_stmt|;
name|struct
name|usbd_urb_bulk_or_intr_transfer
modifier|*
name|ubi
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
name|union
name|usbd_urb
modifier|*
name|urb
decl_stmt|;
name|usbd_private_handle
name|priv
decl_stmt|;
name|usbd_status
name|status
decl_stmt|;
name|usbd_xfer_handle
name|xfer
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|ndis_dev
expr_stmt|;
if|if
condition|(
name|IsListEmpty
argument_list|(
operator|&
name|sc
operator|->
name|ndisusb_xferlist
argument_list|)
condition|)
return|return;
name|KeAcquireSpinLock
argument_list|(
operator|&
name|sc
operator|->
name|ndisusb_xferlock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
name|l
operator|=
name|sc
operator|->
name|ndisusb_xferlist
operator|.
name|nle_flink
expr_stmt|;
while|while
condition|(
name|l
operator|!=
operator|&
name|sc
operator|->
name|ndisusb_xferlist
condition|)
block|{
name|nx
operator|=
name|CONTAINING_RECORD
argument_list|(
name|l
argument_list|,
expr|struct
name|ndisusb_xfer
argument_list|,
name|nx_xferlist
argument_list|)
expr_stmt|;
name|xfer
operator|=
name|nx
operator|->
name|nx_xfer
expr_stmt|;
name|priv
operator|=
name|nx
operator|->
name|nx_priv
expr_stmt|;
name|status
operator|=
name|nx
operator|->
name|nx_status
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ip
operator|=
name|priv
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
block|{
if|if
condition|(
name|status
operator|==
name|USBD_NOT_STARTED
condition|)
block|{
name|error
operator|=
literal|1
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|status
operator|==
name|USBD_STALLED
condition|)
name|usbd_clear_endpoint_stall_async
argument_list|(
name|xfer
operator|->
name|pipe
argument_list|)
expr_stmt|;
comment|/* 			 * NB: just for notice.  We must handle error cases also 			 * because if we just return without notifying to the 			 * NDIS driver the driver never knows about that there 			 * was a error.  This can cause a lot of problems like 			 * system hangs. 			 */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"usb xfer warning (%s)\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|urb
operator|=
name|usbd_geturb
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|urb
operator|->
name|uu_hdr
operator|.
name|uuh_func
operator|==
name|URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER
argument_list|,
operator|(
literal|"function(%d) isn't for bulk or interrupt"
operator|,
name|urb
operator|->
name|uu_hdr
operator|.
name|uuh_func
operator|)
argument_list|)
expr_stmt|;
name|IoAcquireCancelSpinLock
argument_list|(
operator|&
name|ip
operator|->
name|irp_cancelirql
argument_list|)
expr_stmt|;
name|ip
operator|->
name|irp_cancelfunc
operator|=
name|NULL
expr_stmt|;
name|IRP_NDISUSB_XFER
argument_list|(
name|ip
argument_list|)
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|USBD_NORMAL_COMPLETION
case|:
name|ubi
operator|=
operator|&
name|urb
operator|->
name|uu_bulkintr
expr_stmt|;
name|ubi
operator|->
name|ubi_trans_buflen
operator|=
name|xfer
operator|->
name|actlen
expr_stmt|;
if|if
condition|(
name|ubi
operator|->
name|ubi_trans_flags
operator|&
name|USBD_TRANSFER_DIRECTION_IN
condition|)
name|memcpy
argument_list|(
name|ubi
operator|->
name|ubi_trans_buf
argument_list|,
name|xfer
operator|->
name|buffer
argument_list|,
name|xfer
operator|->
name|actlen
argument_list|)
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_info
operator|=
name|xfer
operator|->
name|actlen
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|=
name|STATUS_SUCCESS
expr_stmt|;
name|USBD_URB_STATUS
argument_list|(
name|urb
argument_list|)
operator|=
name|USBD_STATUS_SUCCESS
expr_stmt|;
break|break;
case|case
name|USBD_CANCELLED
case|:
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_info
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|=
name|STATUS_CANCELLED
expr_stmt|;
name|USBD_URB_STATUS
argument_list|(
name|urb
argument_list|)
operator|=
name|USBD_STATUS_CANCELED
expr_stmt|;
break|break;
default|default:
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_info
operator|=
literal|0
expr_stmt|;
name|USBD_URB_STATUS
argument_list|(
name|urb
argument_list|)
operator|=
name|usbd_usb2urb
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|=
name|usbd_urb2nt
argument_list|(
name|USBD_URB_STATUS
argument_list|(
name|urb
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|IoReleaseCancelSpinLock
argument_list|(
name|ip
operator|->
name|irp_cancelirql
argument_list|)
expr_stmt|;
name|next
label|:
name|l
operator|=
name|l
operator|->
name|nle_flink
expr_stmt|;
name|RemoveEntryList
argument_list|(
operator|&
name|nx
operator|->
name|nx_xferlist
argument_list|)
expr_stmt|;
name|usbd_free_xfer
argument_list|(
name|nx
operator|->
name|nx_xfer
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nx
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
continue|continue;
comment|/* NB: call after cleaning  */
name|IoCompleteRequest
argument_list|(
name|ip
argument_list|,
name|IO_NO_INCREMENT
argument_list|)
expr_stmt|;
block|}
name|KeReleaseSpinLock
argument_list|(
operator|&
name|sc
operator|->
name|ndisusb_xferlock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|usbd_func_bulkintr
parameter_list|(
name|ip
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usbd_urb_bulk_or_intr_transfer
modifier|*
name|ubi
decl_stmt|;
name|union
name|usbd_urb
modifier|*
name|urb
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|ep
decl_stmt|;
name|usbd_status
name|status
decl_stmt|;
name|usbd_xfer_handle
name|xfer
decl_stmt|;
name|urb
operator|=
name|usbd_geturb
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ubi
operator|=
operator|&
name|urb
operator|->
name|uu_bulkintr
expr_stmt|;
name|ep
operator|=
name|ubi
operator|->
name|ubi_epdesc
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
return|return
operator|(
name|USBD_STATUS_INVALID_PIPE_HANDLE
operator|)
return|;
name|status
operator|=
name|usbd_init_ndispipe
argument_list|(
name|ip
argument_list|,
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|USBD_NORMAL_COMPLETION
condition|)
return|return
name|usbd_usb2urb
argument_list|(
name|status
argument_list|)
return|;
name|xfer
operator|=
name|usbd_init_ndisxfer
argument_list|(
name|ip
argument_list|,
name|ep
argument_list|,
name|ubi
operator|->
name|ubi_trans_buf
argument_list|,
name|ubi
operator|->
name|ubi_trans_buflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
argument_list|,
literal|"can't allocate xfer\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_STATUS_NO_MEMORY
operator|)
return|;
block|}
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|ep
operator|->
name|bEndpointAddress
argument_list|)
operator|==
name|UE_DIR_IN
condition|)
block|{
name|xfer
operator|->
name|flags
operator||=
name|USBD_SHORT_XFER_OK
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ubi
operator|->
name|ubi_trans_flags
operator|&
name|USBD_SHORT_TRANSFER_OK
operator|)
condition|)
name|xfer
operator|->
name|flags
operator|&=
operator|~
name|USBD_SHORT_XFER_OK
expr_stmt|;
block|}
if|if
condition|(
name|UE_GET_XFERTYPE
argument_list|(
name|ep
operator|->
name|bmAttributes
argument_list|)
operator|==
name|UE_BULK
condition|)
block|{
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|ep
operator|->
name|bEndpointAddress
argument_list|)
operator|==
name|UE_DIR_IN
condition|)
comment|/* RX (bulk IN)  */
name|usbd_setup_xfer
argument_list|(
name|xfer
argument_list|,
name|sc
operator|->
name|ndisusb_ep
index|[
name|NDISUSB_ENDPT_BIN
index|]
argument_list|,
name|ip
argument_list|,
name|xfer
operator|->
name|buffer
argument_list|,
name|xfer
operator|->
name|length
argument_list|,
name|xfer
operator|->
name|flags
argument_list|,
name|USBD_NO_TIMEOUT
argument_list|,
name|usbd_xfereof
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* TX (bulk OUT)  */
name|xfer
operator|->
name|flags
operator||=
name|USBD_NO_COPY
expr_stmt|;
name|usbd_setup_xfer
argument_list|(
name|xfer
argument_list|,
name|sc
operator|->
name|ndisusb_ep
index|[
name|NDISUSB_ENDPT_BOUT
index|]
argument_list|,
name|ip
argument_list|,
name|xfer
operator|->
name|buffer
argument_list|,
name|xfer
operator|->
name|length
argument_list|,
name|xfer
operator|->
name|flags
argument_list|,
name|NDISUSB_TX_TIMEOUT
argument_list|,
name|usbd_xfereof
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|ep
operator|->
name|bEndpointAddress
argument_list|)
operator|==
name|UE_DIR_IN
condition|)
comment|/* Interrupt IN  */
name|usbd_setup_xfer
argument_list|(
name|xfer
argument_list|,
name|sc
operator|->
name|ndisusb_ep
index|[
name|NDISUSB_ENDPT_IIN
index|]
argument_list|,
name|ip
argument_list|,
name|xfer
operator|->
name|buffer
argument_list|,
name|xfer
operator|->
name|length
argument_list|,
name|xfer
operator|->
name|flags
argument_list|,
name|USBD_NO_TIMEOUT
argument_list|,
name|usbd_xfereof
argument_list|)
expr_stmt|;
else|else
comment|/* Interrupt OUT  */
name|usbd_setup_xfer
argument_list|(
name|xfer
argument_list|,
name|sc
operator|->
name|ndisusb_ep
index|[
name|NDISUSB_ENDPT_IOUT
index|]
argument_list|,
name|ip
argument_list|,
name|xfer
operator|->
name|buffer
argument_list|,
name|xfer
operator|->
name|length
argument_list|,
name|xfer
operator|->
name|flags
argument_list|,
name|NDISUSB_INTR_TIMEOUT
argument_list|,
name|usbd_xfereof
argument_list|)
expr_stmt|;
block|}
comment|/* we've done to setup xfer.  Let's transfer it.  */
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|=
name|STATUS_PENDING
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_info
operator|=
literal|0
expr_stmt|;
name|USBD_URB_STATUS
argument_list|(
name|urb
argument_list|)
operator|=
name|USBD_STATUS_PENDING
expr_stmt|;
name|IoMarkIrpPending
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|status
operator|=
name|usbd_transfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|USBD_IN_PROGRESS
condition|)
return|return
operator|(
name|USBD_STATUS_PENDING
operator|)
return|;
name|usbd_free_xfer
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|IRP_NDISUSB_XFER
argument_list|(
name|ip
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|IoUnmarkIrpPending
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|USBD_URB_STATUS
argument_list|(
name|urb
argument_list|)
operator|=
name|usbd_usb2urb
argument_list|(
name|status
argument_list|)
expr_stmt|;
return|return
name|USBD_URB_STATUS
argument_list|(
name|urb
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|union
name|usbd_urb
modifier|*
name|USBD_CreateConfigurationRequest
parameter_list|(
name|conf
parameter_list|,
name|len
parameter_list|)
name|usb_config_descriptor_t
modifier|*
name|conf
decl_stmt|;
name|uint16_t
modifier|*
name|len
decl_stmt|;
block|{
name|struct
name|usbd_interface_list_entry
name|list
index|[
literal|2
index|]
decl_stmt|;
name|union
name|usbd_urb
modifier|*
name|urb
decl_stmt|;
name|bzero
argument_list|(
name|list
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|usbd_interface_list_entry
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|list
index|[
literal|0
index|]
operator|.
name|uil_intfdesc
operator|=
name|USBD_ParseConfigurationDescriptorEx
argument_list|(
name|conf
argument_list|,
name|conf
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|urb
operator|=
name|USBD_CreateConfigurationRequestEx
argument_list|(
name|conf
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|urb
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|*
name|len
operator|=
name|urb
operator|->
name|uu_selconf
operator|.
name|usc_hdr
operator|.
name|uuh_len
expr_stmt|;
return|return
name|urb
return|;
block|}
end_function

begin_function
specifier|static
name|union
name|usbd_urb
modifier|*
name|USBD_CreateConfigurationRequestEx
parameter_list|(
name|conf
parameter_list|,
name|list
parameter_list|)
name|usb_config_descriptor_t
modifier|*
name|conf
decl_stmt|;
name|struct
name|usbd_interface_list_entry
modifier|*
name|list
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|size
decl_stmt|;
name|struct
name|usbd_interface_information
modifier|*
name|intf
decl_stmt|;
name|struct
name|usbd_pipe_information
modifier|*
name|pipe
decl_stmt|;
name|struct
name|usbd_urb_select_configuration
modifier|*
name|selconf
decl_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|desc
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|size
operator|=
literal|0
init|;
name|i
operator|<
name|conf
operator|->
name|bNumInterface
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|list
index|[
name|i
index|]
operator|.
name|uil_intfdesc
operator|->
name|bNumEndpoints
expr_stmt|;
name|size
operator|=
name|size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|usbd_interface_information
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|usbd_pipe_information
argument_list|)
operator|*
operator|(
name|j
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|usbd_urb_select_configuration
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|usbd_interface_information
argument_list|)
expr_stmt|;
name|selconf
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|selconf
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|selconf
operator|->
name|usc_hdr
operator|.
name|uuh_func
operator|=
name|URB_FUNCTION_SELECT_CONFIGURATION
expr_stmt|;
name|selconf
operator|->
name|usc_hdr
operator|.
name|uuh_len
operator|=
name|size
expr_stmt|;
name|selconf
operator|->
name|usc_handle
operator|=
name|conf
expr_stmt|;
name|selconf
operator|->
name|usc_conf
operator|=
name|conf
expr_stmt|;
name|intf
operator|=
operator|&
name|selconf
operator|->
name|usc_intf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|conf
operator|->
name|bNumInterface
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|list
index|[
name|i
index|]
operator|.
name|uil_intfdesc
operator|==
name|NULL
condition|)
break|break;
name|list
index|[
name|i
index|]
operator|.
name|uil_intf
operator|=
name|intf
expr_stmt|;
name|desc
operator|=
name|list
index|[
name|i
index|]
operator|.
name|uil_intfdesc
expr_stmt|;
name|intf
operator|->
name|uii_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usbd_interface_information
argument_list|)
operator|+
operator|(
name|desc
operator|->
name|bNumEndpoints
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|usbd_pipe_information
argument_list|)
expr_stmt|;
name|intf
operator|->
name|uii_intfnum
operator|=
name|desc
operator|->
name|bInterfaceNumber
expr_stmt|;
name|intf
operator|->
name|uii_altset
operator|=
name|desc
operator|->
name|bAlternateSetting
expr_stmt|;
name|intf
operator|->
name|uii_intfclass
operator|=
name|desc
operator|->
name|bInterfaceClass
expr_stmt|;
name|intf
operator|->
name|uii_intfsubclass
operator|=
name|desc
operator|->
name|bInterfaceSubClass
expr_stmt|;
name|intf
operator|->
name|uii_intfproto
operator|=
name|desc
operator|->
name|bInterfaceProtocol
expr_stmt|;
name|intf
operator|->
name|uii_handle
operator|=
name|desc
expr_stmt|;
name|intf
operator|->
name|uii_numeps
operator|=
name|desc
operator|->
name|bNumEndpoints
expr_stmt|;
name|pipe
operator|=
operator|&
name|intf
operator|->
name|uii_pipes
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|intf
operator|->
name|uii_numeps
condition|;
name|j
operator|++
control|)
name|pipe
index|[
name|j
index|]
operator|.
name|upi_maxtxsize
operator|=
name|USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE
expr_stmt|;
name|intf
operator|=
operator|(
expr|struct
name|usbd_interface_information
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|intf
operator|+
name|intf
operator|->
name|uii_len
operator|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
expr|union
name|usbd_urb
operator|*
operator|)
name|selconf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|USBD_GetUSBDIVersion
parameter_list|(
name|ui
parameter_list|)
name|usbd_version_info
modifier|*
name|ui
decl_stmt|;
block|{
comment|/* Pretend to be Windows XP. */
name|ui
operator|->
name|uvi_usbdi_vers
operator|=
name|USBDI_VERSION
expr_stmt|;
name|ui
operator|->
name|uvi_supported_vers
operator|=
name|USB_VER_2_0
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|usb_interface_descriptor_t
modifier|*
name|USBD_ParseConfigurationDescriptor
parameter_list|(
name|conf
parameter_list|,
name|intfnum
parameter_list|,
name|altset
parameter_list|)
name|usb_config_descriptor_t
modifier|*
name|conf
decl_stmt|;
name|uint8_t
name|intfnum
decl_stmt|;
name|uint8_t
name|altset
decl_stmt|;
block|{
return|return
name|USBD_ParseConfigurationDescriptorEx
argument_list|(
name|conf
argument_list|,
name|conf
argument_list|,
name|intfnum
argument_list|,
name|altset
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|usb_interface_descriptor_t
modifier|*
name|USBD_ParseConfigurationDescriptorEx
parameter_list|(
name|conf
parameter_list|,
name|start
parameter_list|,
name|intfnum
parameter_list|,
name|altset
parameter_list|,
name|intfclass
parameter_list|,
name|intfsubclass
parameter_list|,
name|intfproto
parameter_list|)
name|usb_config_descriptor_t
modifier|*
name|conf
decl_stmt|;
name|void
modifier|*
name|start
decl_stmt|;
name|int32_t
name|intfnum
decl_stmt|;
name|int32_t
name|altset
decl_stmt|;
name|int32_t
name|intfclass
decl_stmt|;
name|int32_t
name|intfsubclass
decl_stmt|;
name|int32_t
name|intfproto
decl_stmt|;
block|{
name|char
modifier|*
name|pos
decl_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|desc
decl_stmt|;
for|for
control|(
name|pos
operator|=
name|start
init|;
name|pos
operator|<
operator|(
operator|(
name|char
operator|*
operator|)
name|conf
operator|+
name|UGETW
argument_list|(
name|conf
operator|->
name|wTotalLength
argument_list|)
operator|)
condition|;
name|pos
operator|+=
name|desc
operator|->
name|bLength
control|)
block|{
name|desc
operator|=
operator|(
name|usb_interface_descriptor_t
operator|*
operator|)
name|pos
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|bDescriptorType
operator|!=
name|UDESC_INTERFACE
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|intfnum
operator|==
operator|-
literal|1
operator|||
name|desc
operator|->
name|bInterfaceNumber
operator|==
name|intfnum
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|altset
operator|==
operator|-
literal|1
operator|||
name|desc
operator|->
name|bAlternateSetting
operator|==
name|altset
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|intfclass
operator|==
operator|-
literal|1
operator|||
name|desc
operator|->
name|bInterfaceClass
operator|==
name|intfclass
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|intfsubclass
operator|==
operator|-
literal|1
operator|||
name|desc
operator|->
name|bInterfaceSubClass
operator|==
name|intfsubclass
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|intfproto
operator|==
operator|-
literal|1
operator|||
name|desc
operator|->
name|bInterfaceProtocol
operator|==
name|intfproto
operator|)
condition|)
continue|continue;
return|return
operator|(
name|desc
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dummy
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"USBD dummy called\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_decl_stmt
name|image_patch_table
name|usbd_functbl
index|[]
init|=
block|{
name|IMPORT_SFUNC
argument_list|(
name|USBD_CreateConfigurationRequest
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|USBD_CreateConfigurationRequestEx
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC_MAP
argument_list|(
name|_USBD_CreateConfigurationRequestEx
expr|@
literal|8
argument_list|,
name|USBD_CreateConfigurationRequestEx
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|USBD_GetUSBDIVersion
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|USBD_ParseConfigurationDescriptor
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|USBD_ParseConfigurationDescriptorEx
argument_list|,
literal|7
argument_list|)
block|,
name|IMPORT_SFUNC_MAP
argument_list|(
name|_USBD_ParseConfigurationDescriptorEx
expr|@
literal|28
argument_list|,
name|USBD_ParseConfigurationDescriptorEx
argument_list|,
literal|7
argument_list|)
block|,
comment|/* 	 * This last entry is a catch-all for any function we haven't 	 * implemented yet. The PE import list patching routine will 	 * use it for any function that doesn't have an explicit match 	 * in this table. 	 */
block|{
name|NULL
block|,
operator|(
name|FUNC
operator|)
name|dummy
block|,
name|NULL
block|,
literal|0
block|,
name|WINDRV_WRAP_STDCALL
block|}
block|,
comment|/* End of list. */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ndis
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

