begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005  *      Bill Paul<wpaul@windriver.com>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Bill Paul.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_request.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/pe_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/cfg_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/resource_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/ntoskrnl_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/ndis_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/hal_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/usbd_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/if_ndis/if_ndisvar.h>
end_include

begin_decl_stmt
specifier|static
name|driver_object
name|usbd_driver
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|usbd_non_isoc_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|usbd_ctrl_callback
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|USBD_CTRL_READ_PIPE
value|0
end_define

begin_define
define|#
directive|define
name|USBD_CTRL_WRITE_PIPE
value|1
end_define

begin_define
define|#
directive|define
name|USBD_CTRL_MAX_PIPE
value|2
end_define

begin_define
define|#
directive|define
name|USBD_CTRL_READ_BUFFER_SP
value|256
end_define

begin_define
define|#
directive|define
name|USBD_CTRL_READ_BUFFER_SIZE
define|\
value|(sizeof(struct usb_device_request) + USBD_CTRL_READ_BUFFER_SP)
end_define

begin_define
define|#
directive|define
name|USBD_CTRL_WRITE_BUFFER_SIZE
define|\
value|(sizeof(struct usb_device_request))
end_define

begin_decl_stmt
specifier|static
name|struct
name|usb_config
name|usbd_default_epconfig
index|[
name|USBD_CTRL_MAX_PIPE
index|]
init|=
block|{
index|[
name|USBD_CTRL_READ_PIPE
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_CONTROL
block|,
operator|.
name|endpoint
operator|=
literal|0x00
block|,
comment|/* control pipe */
operator|.
name|direction
operator|=
name|UE_DIR_ANY
block|,
operator|.
name|if_index
operator|=
literal|0
block|,
operator|.
name|bufsize
operator|=
name|USBD_CTRL_READ_BUFFER_SIZE
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|short_xfer_ok
operator|=
literal|1
block|, }
block|,
operator|.
name|callback
operator|=
operator|&
name|usbd_ctrl_callback
block|,
operator|.
name|timeout
operator|=
literal|5000
block|,
comment|/* 5 seconds */
block|}
block|,
index|[
name|USBD_CTRL_WRITE_PIPE
index|]
operator|=
block|{
operator|.
name|type
operator|=
name|UE_CONTROL
block|,
operator|.
name|endpoint
operator|=
literal|0x00
block|,
comment|/* control pipe */
operator|.
name|direction
operator|=
name|UE_DIR_ANY
block|,
operator|.
name|if_index
operator|=
literal|0
block|,
operator|.
name|bufsize
operator|=
name|USBD_CTRL_WRITE_BUFFER_SIZE
block|,
operator|.
name|flags
operator|=
block|{
operator|.
name|proxy_buffer
operator|=
literal|1
block|, }
block|,
operator|.
name|callback
operator|=
operator|&
name|usbd_ctrl_callback
block|,
operator|.
name|timeout
operator|=
literal|5000
block|,
comment|/* 5 seconds */
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int32_t
name|usbd_func_bulkintr
parameter_list|(
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|usbd_func_vendorclass
parameter_list|(
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|usbd_func_selconf
parameter_list|(
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|usbd_func_abort_pipe
parameter_list|(
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb_error_t
name|usbd_setup_endpoint
parameter_list|(
name|irp
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|struct
name|usb_endpoint_descriptor
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb_error_t
name|usbd_setup_endpoint_default
parameter_list|(
name|irp
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb_error_t
name|usbd_setup_endpoint_one
parameter_list|(
name|irp
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|struct
name|ndisusb_ep
modifier|*
parameter_list|,
name|struct
name|usb_config
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|usbd_func_getdesc
parameter_list|(
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|union
name|usbd_urb
modifier|*
name|usbd_geturb
parameter_list|(
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ndisusb_ep
modifier|*
name|usbd_get_ndisep
parameter_list|(
name|irp
modifier|*
parameter_list|,
name|usb_endpoint_descriptor_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|usbd_iodispatch
parameter_list|(
name|device_object
modifier|*
parameter_list|,
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|usbd_ioinvalid
parameter_list|(
name|device_object
modifier|*
parameter_list|,
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|usbd_pnp
parameter_list|(
name|device_object
modifier|*
parameter_list|,
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|usbd_power
parameter_list|(
name|device_object
modifier|*
parameter_list|,
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usbd_irpcancel
parameter_list|(
name|device_object
modifier|*
parameter_list|,
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|usbd_submit_urb
parameter_list|(
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|usbd_urb2nt
parameter_list|(
name|int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usbd_task
parameter_list|(
name|device_object
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|usbd_taskadd
parameter_list|(
name|irp
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usbd_xfertask
parameter_list|(
name|device_object
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dummy
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|union
name|usbd_urb
modifier|*
name|USBD_CreateConfigurationRequestEx
parameter_list|(
name|usb_config_descriptor_t
modifier|*
parameter_list|,
name|struct
name|usbd_interface_list_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|union
name|usbd_urb
modifier|*
name|USBD_CreateConfigurationRequest
parameter_list|(
name|usb_config_descriptor_t
modifier|*
parameter_list|,
name|uint16_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|USBD_GetUSBDIVersion
parameter_list|(
name|usbd_version_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb_interface_descriptor_t
modifier|*
name|USBD_ParseConfigurationDescriptorEx
parameter_list|(
name|usb_config_descriptor_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int32_t
parameter_list|,
name|int32_t
parameter_list|,
name|int32_t
parameter_list|,
name|int32_t
parameter_list|,
name|int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|usb_interface_descriptor_t
modifier|*
name|USBD_ParseConfigurationDescriptor
parameter_list|(
name|usb_config_descriptor_t
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * We need to wrap these functions because these need `context switch' from  * Windows to UNIX before it's called.  */
end_comment

begin_decl_stmt
specifier|static
name|funcptr
name|usbd_iodispatch_wrap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|funcptr
name|usbd_ioinvalid_wrap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|funcptr
name|usbd_pnp_wrap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|funcptr
name|usbd_power_wrap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|funcptr
name|usbd_irpcancel_wrap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|funcptr
name|usbd_task_wrap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|funcptr
name|usbd_xfertask_wrap
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|usbd_libinit
parameter_list|(
name|void
parameter_list|)
block|{
name|image_patch_table
modifier|*
name|patch
decl_stmt|;
name|int
name|i
decl_stmt|;
name|patch
operator|=
name|usbd_functbl
expr_stmt|;
while|while
condition|(
name|patch
operator|->
name|ipt_func
operator|!=
name|NULL
condition|)
block|{
name|windrv_wrap
argument_list|(
operator|(
name|funcptr
operator|)
name|patch
operator|->
name|ipt_func
argument_list|,
operator|(
name|funcptr
operator|*
operator|)
operator|&
name|patch
operator|->
name|ipt_wrap
argument_list|,
name|patch
operator|->
name|ipt_argcnt
argument_list|,
name|patch
operator|->
name|ipt_ftype
argument_list|)
expr_stmt|;
name|patch
operator|++
expr_stmt|;
block|}
name|windrv_wrap
argument_list|(
operator|(
name|funcptr
operator|)
name|usbd_ioinvalid
argument_list|,
operator|(
name|funcptr
operator|*
operator|)
operator|&
name|usbd_ioinvalid_wrap
argument_list|,
literal|2
argument_list|,
name|WINDRV_WRAP_STDCALL
argument_list|)
expr_stmt|;
name|windrv_wrap
argument_list|(
operator|(
name|funcptr
operator|)
name|usbd_iodispatch
argument_list|,
operator|(
name|funcptr
operator|*
operator|)
operator|&
name|usbd_iodispatch_wrap
argument_list|,
literal|2
argument_list|,
name|WINDRV_WRAP_STDCALL
argument_list|)
expr_stmt|;
name|windrv_wrap
argument_list|(
operator|(
name|funcptr
operator|)
name|usbd_pnp
argument_list|,
operator|(
name|funcptr
operator|*
operator|)
operator|&
name|usbd_pnp_wrap
argument_list|,
literal|2
argument_list|,
name|WINDRV_WRAP_STDCALL
argument_list|)
expr_stmt|;
name|windrv_wrap
argument_list|(
operator|(
name|funcptr
operator|)
name|usbd_power
argument_list|,
operator|(
name|funcptr
operator|*
operator|)
operator|&
name|usbd_power_wrap
argument_list|,
literal|2
argument_list|,
name|WINDRV_WRAP_STDCALL
argument_list|)
expr_stmt|;
name|windrv_wrap
argument_list|(
operator|(
name|funcptr
operator|)
name|usbd_irpcancel
argument_list|,
operator|(
name|funcptr
operator|*
operator|)
operator|&
name|usbd_irpcancel_wrap
argument_list|,
literal|2
argument_list|,
name|WINDRV_WRAP_STDCALL
argument_list|)
expr_stmt|;
name|windrv_wrap
argument_list|(
operator|(
name|funcptr
operator|)
name|usbd_task
argument_list|,
operator|(
name|funcptr
operator|*
operator|)
operator|&
name|usbd_task_wrap
argument_list|,
literal|2
argument_list|,
name|WINDRV_WRAP_STDCALL
argument_list|)
expr_stmt|;
name|windrv_wrap
argument_list|(
operator|(
name|funcptr
operator|)
name|usbd_xfertask
argument_list|,
operator|(
name|funcptr
operator|*
operator|)
operator|&
name|usbd_xfertask_wrap
argument_list|,
literal|2
argument_list|,
name|WINDRV_WRAP_STDCALL
argument_list|)
expr_stmt|;
comment|/* Create a fake USB driver instance. */
name|windrv_bus_attach
argument_list|(
operator|&
name|usbd_driver
argument_list|,
literal|"USB Bus"
argument_list|)
expr_stmt|;
comment|/* Set up our dipatch routine. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|IRP_MJ_MAXIMUM_FUNCTION
condition|;
name|i
operator|++
control|)
name|usbd_driver
operator|.
name|dro_dispatch
index|[
name|i
index|]
operator|=
operator|(
name|driver_dispatch
operator|)
name|usbd_ioinvalid_wrap
expr_stmt|;
name|usbd_driver
operator|.
name|dro_dispatch
index|[
name|IRP_MJ_INTERNAL_DEVICE_CONTROL
index|]
operator|=
operator|(
name|driver_dispatch
operator|)
name|usbd_iodispatch_wrap
expr_stmt|;
name|usbd_driver
operator|.
name|dro_dispatch
index|[
name|IRP_MJ_DEVICE_CONTROL
index|]
operator|=
operator|(
name|driver_dispatch
operator|)
name|usbd_iodispatch_wrap
expr_stmt|;
name|usbd_driver
operator|.
name|dro_dispatch
index|[
name|IRP_MJ_POWER
index|]
operator|=
operator|(
name|driver_dispatch
operator|)
name|usbd_power_wrap
expr_stmt|;
name|usbd_driver
operator|.
name|dro_dispatch
index|[
name|IRP_MJ_PNP
index|]
operator|=
operator|(
name|driver_dispatch
operator|)
name|usbd_pnp_wrap
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|usbd_libfini
parameter_list|(
name|void
parameter_list|)
block|{
name|image_patch_table
modifier|*
name|patch
decl_stmt|;
name|patch
operator|=
name|usbd_functbl
expr_stmt|;
while|while
condition|(
name|patch
operator|->
name|ipt_func
operator|!=
name|NULL
condition|)
block|{
name|windrv_unwrap
argument_list|(
name|patch
operator|->
name|ipt_wrap
argument_list|)
expr_stmt|;
name|patch
operator|++
expr_stmt|;
block|}
name|windrv_unwrap
argument_list|(
name|usbd_ioinvalid_wrap
argument_list|)
expr_stmt|;
name|windrv_unwrap
argument_list|(
name|usbd_iodispatch_wrap
argument_list|)
expr_stmt|;
name|windrv_unwrap
argument_list|(
name|usbd_pnp_wrap
argument_list|)
expr_stmt|;
name|windrv_unwrap
argument_list|(
name|usbd_power_wrap
argument_list|)
expr_stmt|;
name|windrv_unwrap
argument_list|(
name|usbd_irpcancel_wrap
argument_list|)
expr_stmt|;
name|windrv_unwrap
argument_list|(
name|usbd_task_wrap
argument_list|)
expr_stmt|;
name|windrv_unwrap
argument_list|(
name|usbd_xfertask_wrap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|usbd_driver
operator|.
name|dro_drivername
operator|.
name|us_buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|usbd_iodispatch
parameter_list|(
name|dobj
parameter_list|,
name|ip
parameter_list|)
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|dobj
operator|->
name|do_devext
decl_stmt|;
name|int32_t
name|status
decl_stmt|;
name|struct
name|io_stack_location
modifier|*
name|irp_sl
decl_stmt|;
name|irp_sl
operator|=
name|IoGetCurrentIrpStackLocation
argument_list|(
name|ip
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|irp_sl
operator|->
name|isl_parameters
operator|.
name|isl_ioctl
operator|.
name|isl_iocode
condition|)
block|{
case|case
name|IOCTL_INTERNAL_USB_SUBMIT_URB
case|:
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
operator|=
name|dev
expr_stmt|;
name|status
operator|=
name|usbd_submit_urb
argument_list|(
name|ip
argument_list|)
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ioctl 0x%x isn't supported\n"
argument_list|,
name|irp_sl
operator|->
name|isl_parameters
operator|.
name|isl_ioctl
operator|.
name|isl_iocode
argument_list|)
expr_stmt|;
name|status
operator|=
name|USBD_STATUS_NOT_SUPPORTED
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|status
operator|==
name|USBD_STATUS_PENDING
condition|)
return|return
operator|(
name|STATUS_PENDING
operator|)
return|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|=
name|usbd_urb2nt
argument_list|(
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|USBD_STATUS_SUCCESS
condition|)
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_info
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|usbd_ioinvalid
parameter_list|(
name|dobj
parameter_list|,
name|ip
parameter_list|)
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|dobj
operator|->
name|do_devext
decl_stmt|;
name|struct
name|io_stack_location
modifier|*
name|irp_sl
decl_stmt|;
name|irp_sl
operator|=
name|IoGetCurrentIrpStackLocation
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"invalid I/O dispatch %d:%d\n"
argument_list|,
name|irp_sl
operator|->
name|isl_major
argument_list|,
name|irp_sl
operator|->
name|isl_minor
argument_list|)
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|=
name|STATUS_FAILURE
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_info
operator|=
literal|0
expr_stmt|;
name|IoCompleteRequest
argument_list|(
name|ip
argument_list|,
name|IO_NO_INCREMENT
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_FAILURE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|usbd_pnp
parameter_list|(
name|dobj
parameter_list|,
name|ip
parameter_list|)
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|dobj
operator|->
name|do_devext
decl_stmt|;
name|struct
name|io_stack_location
modifier|*
name|irp_sl
decl_stmt|;
name|irp_sl
operator|=
name|IoGetCurrentIrpStackLocation
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: unsupported I/O dispatch %d:%d\n"
argument_list|,
name|__func__
argument_list|,
name|irp_sl
operator|->
name|isl_major
argument_list|,
name|irp_sl
operator|->
name|isl_minor
argument_list|)
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|=
name|STATUS_FAILURE
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_info
operator|=
literal|0
expr_stmt|;
name|IoCompleteRequest
argument_list|(
name|ip
argument_list|,
name|IO_NO_INCREMENT
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_FAILURE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|usbd_power
parameter_list|(
name|dobj
parameter_list|,
name|ip
parameter_list|)
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|dobj
operator|->
name|do_devext
decl_stmt|;
name|struct
name|io_stack_location
modifier|*
name|irp_sl
decl_stmt|;
name|irp_sl
operator|=
name|IoGetCurrentIrpStackLocation
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: unsupported I/O dispatch %d:%d\n"
argument_list|,
name|__func__
argument_list|,
name|irp_sl
operator|->
name|isl_major
argument_list|,
name|irp_sl
operator|->
name|isl_minor
argument_list|)
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|=
name|STATUS_FAILURE
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_info
operator|=
literal|0
expr_stmt|;
name|IoCompleteRequest
argument_list|(
name|ip
argument_list|,
name|IO_NO_INCREMENT
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_FAILURE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert USBD_STATUS to NTSTATUS  */
end_comment

begin_function
specifier|static
name|int32_t
name|usbd_urb2nt
parameter_list|(
name|status
parameter_list|)
name|int32_t
name|status
decl_stmt|;
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|USBD_STATUS_SUCCESS
case|:
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
case|case
name|USBD_STATUS_DEVICE_GONE
case|:
return|return
operator|(
name|STATUS_DEVICE_NOT_CONNECTED
operator|)
return|;
case|case
name|USBD_STATUS_PENDING
case|:
return|return
operator|(
name|STATUS_PENDING
operator|)
return|;
case|case
name|USBD_STATUS_NOT_SUPPORTED
case|:
return|return
operator|(
name|STATUS_NOT_IMPLEMENTED
operator|)
return|;
case|case
name|USBD_STATUS_NO_MEMORY
case|:
return|return
operator|(
name|STATUS_NO_MEMORY
operator|)
return|;
case|case
name|USBD_STATUS_REQUEST_FAILED
case|:
return|return
operator|(
name|STATUS_NOT_SUPPORTED
operator|)
return|;
case|case
name|USBD_STATUS_CANCELED
case|:
return|return
operator|(
name|STATUS_CANCELLED
operator|)
return|;
default|default:
break|break;
block|}
return|return
operator|(
name|STATUS_FAILURE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert FreeBSD's usb_error_t to USBD_STATUS  */
end_comment

begin_function
specifier|static
name|int32_t
name|usbd_usb2urb
parameter_list|(
name|int
name|status
parameter_list|)
block|{
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|USB_ERR_NORMAL_COMPLETION
case|:
return|return
operator|(
name|USBD_STATUS_SUCCESS
operator|)
return|;
case|case
name|USB_ERR_PENDING_REQUESTS
case|:
return|return
operator|(
name|USBD_STATUS_PENDING
operator|)
return|;
case|case
name|USB_ERR_TIMEOUT
case|:
return|return
operator|(
name|USBD_STATUS_TIMEOUT
operator|)
return|;
case|case
name|USB_ERR_SHORT_XFER
case|:
return|return
operator|(
name|USBD_STATUS_ERROR_SHORT_TRANSFER
operator|)
return|;
case|case
name|USB_ERR_IOERROR
case|:
return|return
operator|(
name|USBD_STATUS_XACT_ERROR
operator|)
return|;
case|case
name|USB_ERR_NOMEM
case|:
return|return
operator|(
name|USBD_STATUS_NO_MEMORY
operator|)
return|;
case|case
name|USB_ERR_INVAL
case|:
return|return
operator|(
name|USBD_STATUS_REQUEST_FAILED
operator|)
return|;
case|case
name|USB_ERR_NOT_STARTED
case|:
case|case
name|USB_ERR_TOO_DEEP
case|:
case|case
name|USB_ERR_NO_POWER
case|:
return|return
operator|(
name|USBD_STATUS_DEVICE_GONE
operator|)
return|;
case|case
name|USB_ERR_CANCELLED
case|:
return|return
operator|(
name|USBD_STATUS_CANCELED
operator|)
return|;
default|default:
break|break;
block|}
return|return
operator|(
name|USBD_STATUS_NOT_SUPPORTED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|union
name|usbd_urb
modifier|*
name|usbd_geturb
parameter_list|(
name|ip
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|struct
name|io_stack_location
modifier|*
name|irp_sl
decl_stmt|;
name|irp_sl
operator|=
name|IoGetCurrentIrpStackLocation
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|irp_sl
operator|->
name|isl_parameters
operator|.
name|isl_others
operator|.
name|isl_arg1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|usbd_submit_urb
parameter_list|(
name|ip
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|int32_t
name|status
decl_stmt|;
name|union
name|usbd_urb
modifier|*
name|urb
decl_stmt|;
name|urb
operator|=
name|usbd_geturb
argument_list|(
name|ip
argument_list|)
expr_stmt|;
comment|/* 	 * In a case of URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER, 	 * USBD_URB_STATUS(urb) would be set at callback functions like 	 * usbd_intr() or usbd_xfereof(). 	 */
switch|switch
condition|(
name|urb
operator|->
name|uu_hdr
operator|.
name|uuh_func
condition|)
block|{
case|case
name|URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER
case|:
name|status
operator|=
name|usbd_func_bulkintr
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|USBD_STATUS_SUCCESS
operator|&&
name|status
operator|!=
name|USBD_STATUS_PENDING
condition|)
name|USBD_URB_STATUS
argument_list|(
name|urb
argument_list|)
operator|=
name|status
expr_stmt|;
break|break;
case|case
name|URB_FUNCTION_VENDOR_DEVICE
case|:
case|case
name|URB_FUNCTION_VENDOR_INTERFACE
case|:
case|case
name|URB_FUNCTION_VENDOR_ENDPOINT
case|:
case|case
name|URB_FUNCTION_VENDOR_OTHER
case|:
case|case
name|URB_FUNCTION_CLASS_DEVICE
case|:
case|case
name|URB_FUNCTION_CLASS_INTERFACE
case|:
case|case
name|URB_FUNCTION_CLASS_ENDPOINT
case|:
case|case
name|URB_FUNCTION_CLASS_OTHER
case|:
name|status
operator|=
name|usbd_func_vendorclass
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|USBD_URB_STATUS
argument_list|(
name|urb
argument_list|)
operator|=
name|status
expr_stmt|;
break|break;
case|case
name|URB_FUNCTION_SELECT_CONFIGURATION
case|:
name|status
operator|=
name|usbd_func_selconf
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|USBD_URB_STATUS
argument_list|(
name|urb
argument_list|)
operator|=
name|status
expr_stmt|;
break|break;
case|case
name|URB_FUNCTION_ABORT_PIPE
case|:
name|status
operator|=
name|usbd_func_abort_pipe
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|USBD_URB_STATUS
argument_list|(
name|urb
argument_list|)
operator|=
name|status
expr_stmt|;
break|break;
case|case
name|URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE
case|:
name|status
operator|=
name|usbd_func_getdesc
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|USBD_URB_STATUS
argument_list|(
name|urb
argument_list|)
operator|=
name|status
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"func 0x%x isn't supported\n"
argument_list|,
name|urb
operator|->
name|uu_hdr
operator|.
name|uuh_func
argument_list|)
expr_stmt|;
name|USBD_URB_STATUS
argument_list|(
name|urb
argument_list|)
operator|=
name|status
operator|=
name|USBD_STATUS_NOT_SUPPORTED
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|usbd_func_getdesc
parameter_list|(
name|ip
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
define|#
directive|define
name|NDISUSB_GETDESC_MAXRETRIES
value|3
name|device_t
name|dev
init|=
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usbd_urb_control_descriptor_request
modifier|*
name|ctldesc
decl_stmt|;
name|uint16_t
name|actlen
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|union
name|usbd_urb
modifier|*
name|urb
decl_stmt|;
name|usb_config_descriptor_t
modifier|*
name|cdp
decl_stmt|;
name|usb_error_t
name|status
decl_stmt|;
name|urb
operator|=
name|usbd_geturb
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ctldesc
operator|=
operator|&
name|urb
operator|->
name|uu_ctldesc
expr_stmt|;
if|if
condition|(
name|ctldesc
operator|->
name|ucd_desctype
operator|==
name|UDESC_CONFIG
condition|)
block|{
comment|/* 		 * The NDIS driver is not allowed to change the 		 * config! There is only one choice! 		 */
name|cdp
operator|=
name|usbd_get_config_descriptor
argument_list|(
name|sc
operator|->
name|ndisusb_dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdp
operator|==
name|NULL
condition|)
block|{
name|status
operator|=
name|USB_ERR_INVAL
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
if|if
condition|(
name|cdp
operator|->
name|bDescriptorType
operator|!=
name|UDESC_CONFIG
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bad desc %d\n"
argument_list|,
name|cdp
operator|->
name|bDescriptorType
argument_list|)
expr_stmt|;
name|status
operator|=
name|USB_ERR_INVAL
expr_stmt|;
goto|goto
name|exit
goto|;
block|}
comment|/* get minimum length */
name|len
operator|=
name|MIN
argument_list|(
name|UGETW
argument_list|(
name|cdp
operator|->
name|wTotalLength
argument_list|)
argument_list|,
name|ctldesc
operator|->
name|ucd_trans_buflen
argument_list|)
expr_stmt|;
comment|/* copy out config descriptor */
name|memcpy
argument_list|(
name|ctldesc
operator|->
name|ucd_trans_buf
argument_list|,
name|cdp
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* set actual length */
name|actlen
operator|=
name|len
expr_stmt|;
name|status
operator|=
name|USB_ERR_NORMAL_COMPLETION
expr_stmt|;
block|}
else|else
block|{
name|NDISUSB_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|status
operator|=
name|usbd_req_get_desc
argument_list|(
name|sc
operator|->
name|ndisusb_dev
argument_list|,
operator|&
name|sc
operator|->
name|ndisusb_mtx
argument_list|,
operator|&
name|actlen
argument_list|,
name|ctldesc
operator|->
name|ucd_trans_buf
argument_list|,
literal|2
argument_list|,
name|ctldesc
operator|->
name|ucd_trans_buflen
argument_list|,
name|ctldesc
operator|->
name|ucd_langid
argument_list|,
name|ctldesc
operator|->
name|ucd_desctype
argument_list|,
name|ctldesc
operator|->
name|ucd_idx
argument_list|,
name|NDISUSB_GETDESC_MAXRETRIES
argument_list|)
expr_stmt|;
name|NDISUSB_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|exit
label|:
if|if
condition|(
name|status
operator|!=
name|USB_ERR_NORMAL_COMPLETION
condition|)
block|{
name|ctldesc
operator|->
name|ucd_trans_buflen
operator|=
literal|0
expr_stmt|;
return|return
name|usbd_usb2urb
argument_list|(
name|status
argument_list|)
return|;
block|}
name|ctldesc
operator|->
name|ucd_trans_buflen
operator|=
name|actlen
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_info
operator|=
name|actlen
expr_stmt|;
return|return
operator|(
name|USBD_STATUS_SUCCESS
operator|)
return|;
undef|#
directive|undef
name|NDISUSB_GETDESC_MAXRETRIES
block|}
end_function

begin_function
specifier|static
name|int32_t
name|usbd_func_selconf
parameter_list|(
name|ip
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_device
modifier|*
name|udev
init|=
name|sc
operator|->
name|ndisusb_dev
decl_stmt|;
name|struct
name|usb_endpoint
modifier|*
name|ep
init|=
name|NULL
decl_stmt|;
name|struct
name|usbd_interface_information
modifier|*
name|intf
decl_stmt|;
name|struct
name|usbd_pipe_information
modifier|*
name|pipe
decl_stmt|;
name|struct
name|usbd_urb_select_configuration
modifier|*
name|selconf
decl_stmt|;
name|union
name|usbd_urb
modifier|*
name|urb
decl_stmt|;
name|usb_config_descriptor_t
modifier|*
name|conf
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|edesc
decl_stmt|;
name|usb_error_t
name|ret
decl_stmt|;
name|urb
operator|=
name|usbd_geturb
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|selconf
operator|=
operator|&
name|urb
operator|->
name|uu_selconf
expr_stmt|;
name|conf
operator|=
name|selconf
operator|->
name|usc_conf
expr_stmt|;
if|if
condition|(
name|conf
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"select configuration is NULL\n"
argument_list|)
expr_stmt|;
return|return
name|usbd_usb2urb
argument_list|(
name|USB_ERR_NORMAL_COMPLETION
argument_list|)
return|;
block|}
name|intf
operator|=
operator|&
name|selconf
operator|->
name|usc_intf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|conf
operator|->
name|bNumInterface
operator|&&
name|intf
operator|->
name|uii_len
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|ret
operator|=
name|usbd_set_alt_interface_index
argument_list|(
name|udev
argument_list|,
name|intf
operator|->
name|uii_intfnum
argument_list|,
name|intf
operator|->
name|uii_altset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|USB_ERR_NORMAL_COMPLETION
operator|&&
name|ret
operator|!=
name|USB_ERR_IN_USE
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"setting alternate interface failed: %s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|ret
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|usbd_usb2urb
argument_list|(
name|ret
argument_list|)
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|ep
operator|=
name|usb_endpoint_foreach
argument_list|(
name|udev
argument_list|,
name|ep
argument_list|)
operator|)
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|>=
name|intf
operator|->
name|uii_numeps
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"endpoint %d and above are ignored"
argument_list|,
name|intf
operator|->
name|uii_numeps
argument_list|)
expr_stmt|;
break|break;
block|}
name|edesc
operator|=
name|ep
operator|->
name|edesc
expr_stmt|;
name|pipe
operator|=
operator|&
name|intf
operator|->
name|uii_pipes
index|[
name|j
index|]
expr_stmt|;
name|pipe
operator|->
name|upi_handle
operator|=
name|edesc
expr_stmt|;
name|pipe
operator|->
name|upi_epaddr
operator|=
name|edesc
operator|->
name|bEndpointAddress
expr_stmt|;
name|pipe
operator|->
name|upi_maxpktsize
operator|=
name|UGETW
argument_list|(
name|edesc
operator|->
name|wMaxPacketSize
argument_list|)
expr_stmt|;
name|pipe
operator|->
name|upi_type
operator|=
name|UE_GET_XFERTYPE
argument_list|(
name|edesc
operator|->
name|bmAttributes
argument_list|)
expr_stmt|;
name|ret
operator|=
name|usbd_setup_endpoint
argument_list|(
name|ip
argument_list|,
name|intf
operator|->
name|uii_intfnum
argument_list|,
name|edesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|USB_ERR_NORMAL_COMPLETION
condition|)
return|return
name|usbd_usb2urb
argument_list|(
name|ret
argument_list|)
return|;
if|if
condition|(
name|pipe
operator|->
name|upi_type
operator|!=
name|UE_INTERRUPT
condition|)
continue|continue;
comment|/* XXX we're following linux USB's interval policy.  */
if|if
condition|(
name|udev
operator|->
name|speed
operator|==
name|USB_SPEED_LOW
condition|)
name|pipe
operator|->
name|upi_interval
operator|=
name|edesc
operator|->
name|bInterval
operator|+
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|udev
operator|->
name|speed
operator|==
name|USB_SPEED_FULL
condition|)
name|pipe
operator|->
name|upi_interval
operator|=
name|edesc
operator|->
name|bInterval
expr_stmt|;
else|else
block|{
name|int
name|k0
init|=
literal|0
decl_stmt|,
name|k1
init|=
literal|1
decl_stmt|;
do|do
block|{
name|k1
operator|=
name|k1
operator|*
literal|2
expr_stmt|;
name|k0
operator|=
name|k0
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|k1
operator|<
name|edesc
operator|->
name|bInterval
condition|)
do|;
name|pipe
operator|->
name|upi_interval
operator|=
name|k0
expr_stmt|;
block|}
block|}
name|intf
operator|=
operator|(
expr|struct
name|usbd_interface_information
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|intf
operator|)
operator|+
name|intf
operator|->
name|uii_len
operator|)
expr_stmt|;
block|}
return|return
name|USBD_STATUS_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|usbd_setup_endpoint_one
parameter_list|(
name|ip
parameter_list|,
name|ifidx
parameter_list|,
name|ne
parameter_list|,
name|epconf
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
name|uint8_t
name|ifidx
decl_stmt|;
name|struct
name|ndisusb_ep
modifier|*
name|ne
decl_stmt|;
name|struct
name|usb_config
modifier|*
name|epconf
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|usb_error_t
name|status
decl_stmt|;
name|InitializeListHead
argument_list|(
operator|&
name|ne
operator|->
name|ne_active
argument_list|)
expr_stmt|;
name|InitializeListHead
argument_list|(
operator|&
name|ne
operator|->
name|ne_pending
argument_list|)
expr_stmt|;
name|KeInitializeSpinLock
argument_list|(
operator|&
name|ne
operator|->
name|ne_lock
argument_list|)
expr_stmt|;
name|status
operator|=
name|usbd_transfer_setup
argument_list|(
name|sc
operator|->
name|ndisusb_dev
argument_list|,
operator|&
name|ifidx
argument_list|,
name|ne
operator|->
name|ne_xfer
argument_list|,
name|epconf
argument_list|,
literal|1
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ndisusb_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|USB_ERR_NORMAL_COMPLETION
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't setup xfer: %s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
name|xfer
operator|=
name|ne
operator|->
name|ne_xfer
index|[
literal|0
index|]
expr_stmt|;
name|usbd_xfer_set_priv
argument_list|(
name|xfer
argument_list|,
name|ne
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|usbd_setup_endpoint_default
parameter_list|(
name|ip
parameter_list|,
name|ifidx
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
name|uint8_t
name|ifidx
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|usb_error_t
name|status
decl_stmt|;
if|if
condition|(
name|ifidx
operator|>
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"warning: ifidx> 0 isn't supported.\n"
argument_list|)
expr_stmt|;
name|status
operator|=
name|usbd_setup_endpoint_one
argument_list|(
name|ip
argument_list|,
name|ifidx
argument_list|,
operator|&
name|sc
operator|->
name|ndisusb_dread_ep
argument_list|,
operator|&
name|usbd_default_epconfig
index|[
name|USBD_CTRL_READ_PIPE
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|USB_ERR_NORMAL_COMPLETION
condition|)
return|return
operator|(
name|status
operator|)
return|;
name|status
operator|=
name|usbd_setup_endpoint_one
argument_list|(
name|ip
argument_list|,
name|ifidx
argument_list|,
operator|&
name|sc
operator|->
name|ndisusb_dwrite_ep
argument_list|,
operator|&
name|usbd_default_epconfig
index|[
name|USBD_CTRL_WRITE_PIPE
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|usb_error_t
name|usbd_setup_endpoint
parameter_list|(
name|ip
parameter_list|,
name|ifidx
parameter_list|,
name|ep
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
name|uint8_t
name|ifidx
decl_stmt|;
name|struct
name|usb_endpoint_descriptor
modifier|*
name|ep
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ndisusb_ep
modifier|*
name|ne
decl_stmt|;
name|struct
name|usb_config
name|cfg
decl_stmt|;
name|struct
name|usb_xfer
modifier|*
name|xfer
decl_stmt|;
name|usb_error_t
name|status
decl_stmt|;
comment|/* check for non-supported transfer types */
if|if
condition|(
name|UE_GET_XFERTYPE
argument_list|(
name|ep
operator|->
name|bmAttributes
argument_list|)
operator|==
name|UE_CONTROL
operator|||
name|UE_GET_XFERTYPE
argument_list|(
name|ep
operator|->
name|bmAttributes
argument_list|)
operator|==
name|UE_ISOCHRONOUS
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: unsuppotted transfer types %#x\n"
argument_list|,
name|__func__
argument_list|,
name|UE_GET_XFERTYPE
argument_list|(
name|ep
operator|->
name|bmAttributes
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|USB_ERR_INVAL
operator|)
return|;
block|}
name|ne
operator|=
operator|&
name|sc
operator|->
name|ndisusb_ep
index|[
name|NDISUSB_GET_ENDPT
argument_list|(
name|ep
operator|->
name|bEndpointAddress
argument_list|)
index|]
expr_stmt|;
name|InitializeListHead
argument_list|(
operator|&
name|ne
operator|->
name|ne_active
argument_list|)
expr_stmt|;
name|InitializeListHead
argument_list|(
operator|&
name|ne
operator|->
name|ne_pending
argument_list|)
expr_stmt|;
name|KeInitializeSpinLock
argument_list|(
operator|&
name|ne
operator|->
name|ne_lock
argument_list|)
expr_stmt|;
name|ne
operator|->
name|ne_dirin
operator|=
name|UE_GET_DIR
argument_list|(
name|ep
operator|->
name|bEndpointAddress
argument_list|)
operator|>>
literal|7
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cfg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|usb_config
argument_list|)
argument_list|)
expr_stmt|;
name|cfg
operator|.
name|type
operator|=
name|UE_GET_XFERTYPE
argument_list|(
name|ep
operator|->
name|bmAttributes
argument_list|)
expr_stmt|;
name|cfg
operator|.
name|endpoint
operator|=
name|UE_GET_ADDR
argument_list|(
name|ep
operator|->
name|bEndpointAddress
argument_list|)
expr_stmt|;
name|cfg
operator|.
name|direction
operator|=
name|UE_GET_DIR
argument_list|(
name|ep
operator|->
name|bEndpointAddress
argument_list|)
expr_stmt|;
name|cfg
operator|.
name|callback
operator|=
operator|&
name|usbd_non_isoc_callback
expr_stmt|;
name|cfg
operator|.
name|bufsize
operator|=
name|UGETW
argument_list|(
name|ep
operator|->
name|wMaxPacketSize
argument_list|)
expr_stmt|;
name|cfg
operator|.
name|flags
operator|.
name|proxy_buffer
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|ep
operator|->
name|bEndpointAddress
argument_list|)
operator|==
name|UE_DIR_IN
condition|)
name|cfg
operator|.
name|flags
operator|.
name|short_xfer_ok
operator|=
literal|1
expr_stmt|;
name|status
operator|=
name|usbd_transfer_setup
argument_list|(
name|sc
operator|->
name|ndisusb_dev
argument_list|,
operator|&
name|ifidx
argument_list|,
name|ne
operator|->
name|ne_xfer
argument_list|,
operator|&
name|cfg
argument_list|,
literal|1
argument_list|,
name|sc
argument_list|,
operator|&
name|sc
operator|->
name|ndisusb_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|USB_ERR_NORMAL_COMPLETION
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"couldn't setup xfer: %s\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
name|xfer
operator|=
name|ne
operator|->
name|ne_xfer
index|[
literal|0
index|]
expr_stmt|;
name|usbd_xfer_set_priv
argument_list|(
name|xfer
argument_list|,
name|ne
argument_list|)
expr_stmt|;
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|ep
operator|->
name|bEndpointAddress
argument_list|)
operator|==
name|UE_DIR_IN
condition|)
name|usbd_xfer_set_timeout
argument_list|(
name|xfer
argument_list|,
name|NDISUSB_NO_TIMEOUT
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|UE_GET_XFERTYPE
argument_list|(
name|ep
operator|->
name|bmAttributes
argument_list|)
operator|==
name|UE_BULK
condition|)
name|usbd_xfer_set_timeout
argument_list|(
name|xfer
argument_list|,
name|NDISUSB_TX_TIMEOUT
argument_list|)
expr_stmt|;
else|else
name|usbd_xfer_set_timeout
argument_list|(
name|xfer
argument_list|,
name|NDISUSB_INTR_TIMEOUT
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|usbd_func_abort_pipe
parameter_list|(
name|ip
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ndisusb_ep
modifier|*
name|ne
decl_stmt|;
name|union
name|usbd_urb
modifier|*
name|urb
decl_stmt|;
name|urb
operator|=
name|usbd_geturb
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ne
operator|=
name|usbd_get_ndisep
argument_list|(
name|ip
argument_list|,
name|urb
operator|->
name|uu_pipe
operator|.
name|upr_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ne
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
argument_list|,
literal|"get NULL endpoint info.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_STATUS_INVALID_PIPE_HANDLE
operator|)
return|;
block|}
name|NDISUSB_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|usbd_transfer_stop
argument_list|(
name|ne
operator|->
name|ne_xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|ne
operator|->
name|ne_xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|NDISUSB_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_STATUS_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|usbd_func_vendorclass
parameter_list|(
name|ip
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|int32_t
name|error
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ndisusb_ep
modifier|*
name|ne
decl_stmt|;
name|struct
name|ndisusb_xfer
modifier|*
name|nx
decl_stmt|;
name|struct
name|usbd_urb_vendor_or_class_request
modifier|*
name|vcreq
decl_stmt|;
name|union
name|usbd_urb
modifier|*
name|urb
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|ndisusb_status
operator|&
name|NDISUSB_STATUS_SETUP_EP
operator|)
condition|)
block|{
comment|/* 		 * XXX In some cases the interface number isn't 0.  However 		 * some driver (eg. RTL8187L NDIS driver) calls this function 		 * before calling URB_FUNCTION_SELECT_CONFIGURATION. 		 */
name|error
operator|=
name|usbd_setup_endpoint_default
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|USB_ERR_NORMAL_COMPLETION
condition|)
return|return
name|usbd_usb2urb
argument_list|(
name|error
argument_list|)
return|;
name|sc
operator|->
name|ndisusb_status
operator||=
name|NDISUSB_STATUS_SETUP_EP
expr_stmt|;
block|}
name|urb
operator|=
name|usbd_geturb
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|vcreq
operator|=
operator|&
name|urb
operator|->
name|uu_vcreq
expr_stmt|;
name|ne
operator|=
operator|(
name|vcreq
operator|->
name|uvc_trans_flags
operator|&
name|USBD_TRANSFER_DIRECTION_IN
operator|)
condition|?
operator|&
name|sc
operator|->
name|ndisusb_dread_ep
else|:
operator|&
name|sc
operator|->
name|ndisusb_dwrite_ep
expr_stmt|;
name|IRP_NDISUSB_EP
argument_list|(
name|ip
argument_list|)
operator|=
name|ne
expr_stmt|;
name|ip
operator|->
name|irp_cancelfunc
operator|=
operator|(
name|cancel_func
operator|)
name|usbd_irpcancel_wrap
expr_stmt|;
name|nx
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ndisusb_xfer
argument_list|)
argument_list|,
name|M_USBDEV
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nx
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
argument_list|,
literal|"out of memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_STATUS_NO_MEMORY
operator|)
return|;
block|}
name|nx
operator|->
name|nx_ep
operator|=
name|ne
expr_stmt|;
name|nx
operator|->
name|nx_priv
operator|=
name|ip
expr_stmt|;
name|KeAcquireSpinLockAtDpcLevel
argument_list|(
operator|&
name|ne
operator|->
name|ne_lock
argument_list|)
expr_stmt|;
name|InsertTailList
argument_list|(
operator|(
operator|&
name|ne
operator|->
name|ne_pending
operator|)
argument_list|,
operator|(
operator|&
name|nx
operator|->
name|nx_next
operator|)
argument_list|)
expr_stmt|;
name|KeReleaseSpinLockFromDpcLevel
argument_list|(
operator|&
name|ne
operator|->
name|ne_lock
argument_list|)
expr_stmt|;
comment|/* we've done to setup xfer.  Let's transfer it.  */
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|=
name|STATUS_PENDING
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_info
operator|=
literal|0
expr_stmt|;
name|USBD_URB_STATUS
argument_list|(
name|urb
argument_list|)
operator|=
name|USBD_STATUS_PENDING
expr_stmt|;
name|IoMarkIrpPending
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|error
operator|=
name|usbd_taskadd
argument_list|(
name|ip
argument_list|,
name|NDISUSB_TASK_VENDOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|USBD_STATUS_SUCCESS
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|USBD_STATUS_PENDING
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usbd_irpcancel
parameter_list|(
name|dobj
parameter_list|,
name|ip
parameter_list|)
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ndisusb_ep
modifier|*
name|ne
init|=
name|IRP_NDISUSB_EP
argument_list|(
name|ip
argument_list|)
decl_stmt|;
if|if
condition|(
name|ne
operator|==
name|NULL
condition|)
block|{
name|ip
operator|->
name|irp_cancel
operator|=
name|TRUE
expr_stmt|;
name|IoReleaseCancelSpinLock
argument_list|(
name|ip
operator|->
name|irp_cancelirql
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Make sure that the current USB transfer proxy is 	 * cancelled and then restarted. 	 */
name|NDISUSB_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|usbd_transfer_stop
argument_list|(
name|ne
operator|->
name|ne_xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|ne
operator|->
name|ne_xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|NDISUSB_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ip
operator|->
name|irp_cancel
operator|=
name|TRUE
expr_stmt|;
name|IoReleaseCancelSpinLock
argument_list|(
name|ip
operator|->
name|irp_cancelirql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usbd_xfer_complete
parameter_list|(
name|struct
name|ndis_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ndisusb_ep
modifier|*
name|ne
parameter_list|,
name|struct
name|ndisusb_xfer
modifier|*
name|nx
parameter_list|,
name|usb_error_t
name|status
parameter_list|)
block|{
name|struct
name|ndisusb_xferdone
modifier|*
name|nd
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
name|nd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ndisusb_xferdone
argument_list|)
argument_list|,
name|M_USBDEV
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|ndis_dev
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return;
block|}
name|nd
operator|->
name|nd_xfer
operator|=
name|nx
expr_stmt|;
name|nd
operator|->
name|nd_status
operator|=
name|status
expr_stmt|;
name|KeAcquireSpinLock
argument_list|(
operator|&
name|sc
operator|->
name|ndisusb_xferdonelock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
name|InsertTailList
argument_list|(
operator|(
operator|&
name|sc
operator|->
name|ndisusb_xferdonelist
operator|)
argument_list|,
operator|(
operator|&
name|nd
operator|->
name|nd_donelist
operator|)
argument_list|)
expr_stmt|;
name|KeReleaseSpinLock
argument_list|(
operator|&
name|sc
operator|->
name|ndisusb_xferdonelock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
name|IoQueueWorkItem
argument_list|(
name|sc
operator|->
name|ndisusb_xferdoneitem
argument_list|,
operator|(
name|io_workitem_func
operator|)
name|usbd_xfertask_wrap
argument_list|,
name|WORKQUEUE_CRITICAL
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ndisusb_xfer
modifier|*
name|usbd_aq_getfirst
parameter_list|(
name|struct
name|ndis_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ndisusb_ep
modifier|*
name|ne
parameter_list|)
block|{
name|struct
name|ndisusb_xfer
modifier|*
name|nx
decl_stmt|;
name|KeAcquireSpinLockAtDpcLevel
argument_list|(
operator|&
name|ne
operator|->
name|ne_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|IsListEmpty
argument_list|(
operator|&
name|ne
operator|->
name|ne_active
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|ndis_dev
argument_list|,
literal|"%s: the active queue can't be empty.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|KeReleaseSpinLockFromDpcLevel
argument_list|(
operator|&
name|ne
operator|->
name|ne_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|nx
operator|=
name|CONTAINING_RECORD
argument_list|(
name|ne
operator|->
name|ne_active
operator|.
name|nle_flink
argument_list|,
expr|struct
name|ndisusb_xfer
argument_list|,
name|nx_next
argument_list|)
expr_stmt|;
name|RemoveEntryList
argument_list|(
operator|&
name|nx
operator|->
name|nx_next
argument_list|)
expr_stmt|;
name|KeReleaseSpinLockFromDpcLevel
argument_list|(
operator|&
name|ne
operator|->
name|ne_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|nx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usbd_non_isoc_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|irp
modifier|*
name|ip
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|ndisusb_ep
modifier|*
name|ne
init|=
name|usbd_xfer_get_priv
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|ndisusb_xfer
modifier|*
name|nx
decl_stmt|;
name|struct
name|usbd_urb_bulk_or_intr_transfer
modifier|*
name|ubi
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|union
name|usbd_urb
modifier|*
name|urb
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|ep
decl_stmt|;
name|int
name|actlen
decl_stmt|,
name|sumlen
decl_stmt|;
name|usbd_xfer_status
argument_list|(
name|xfer
argument_list|,
operator|&
name|actlen
argument_list|,
operator|&
name|sumlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|nx
operator|=
name|usbd_aq_getfirst
argument_list|(
name|sc
argument_list|,
name|ne
argument_list|)
expr_stmt|;
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nx
operator|==
name|NULL
condition|)
return|return;
comment|/* copy in data with regard to the URB */
if|if
condition|(
name|ne
operator|->
name|ne_dirin
operator|!=
literal|0
condition|)
name|usbd_copy_out
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
name|nx
operator|->
name|nx_urbbuf
argument_list|,
name|actlen
argument_list|)
expr_stmt|;
name|nx
operator|->
name|nx_urbbuf
operator|+=
name|actlen
expr_stmt|;
name|nx
operator|->
name|nx_urbactlen
operator|+=
name|actlen
expr_stmt|;
name|nx
operator|->
name|nx_urblen
operator|-=
name|actlen
expr_stmt|;
comment|/* check for short transfer */
if|if
condition|(
name|actlen
operator|<
name|sumlen
condition|)
name|nx
operator|->
name|nx_urblen
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* check remainder */
if|if
condition|(
name|nx
operator|->
name|nx_urblen
operator|>
literal|0
condition|)
block|{
name|KeAcquireSpinLock
argument_list|(
operator|&
name|ne
operator|->
name|ne_lock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
name|InsertHeadList
argument_list|(
operator|(
operator|&
name|ne
operator|->
name|ne_active
operator|)
argument_list|,
operator|(
operator|&
name|nx
operator|->
name|nx_next
operator|)
argument_list|)
expr_stmt|;
name|KeReleaseSpinLock
argument_list|(
operator|&
name|ne
operator|->
name|ne_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
name|ip
operator|=
name|nx
operator|->
name|nx_priv
expr_stmt|;
name|urb
operator|=
name|usbd_geturb
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ubi
operator|=
operator|&
name|urb
operator|->
name|uu_bulkintr
expr_stmt|;
name|ep
operator|=
name|ubi
operator|->
name|ubi_epdesc
expr_stmt|;
goto|goto
name|extra
goto|;
block|}
block|}
name|usbd_xfer_complete
argument_list|(
name|sc
argument_list|,
name|ne
argument_list|,
name|nx
argument_list|,
operator|(
operator|(
name|actlen
operator|<
name|sumlen
operator|)
operator|&&
operator|(
name|nx
operator|->
name|nx_shortxfer
operator|==
literal|0
operator|)
operator|)
condition|?
name|USB_ERR_SHORT_XFER
else|:
name|USB_ERR_NORMAL_COMPLETION
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|USB_ST_SETUP
case|:
name|next
label|:
comment|/* get next transfer */
name|KeAcquireSpinLock
argument_list|(
operator|&
name|ne
operator|->
name|ne_lock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
if|if
condition|(
name|IsListEmpty
argument_list|(
operator|&
name|ne
operator|->
name|ne_pending
argument_list|)
condition|)
block|{
name|KeReleaseSpinLock
argument_list|(
operator|&
name|ne
operator|->
name|ne_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
return|return;
block|}
name|nx
operator|=
name|CONTAINING_RECORD
argument_list|(
name|ne
operator|->
name|ne_pending
operator|.
name|nle_flink
argument_list|,
expr|struct
name|ndisusb_xfer
argument_list|,
name|nx_next
argument_list|)
expr_stmt|;
name|RemoveEntryList
argument_list|(
operator|&
name|nx
operator|->
name|nx_next
argument_list|)
expr_stmt|;
comment|/* add a entry to the active queue's tail.  */
name|InsertTailList
argument_list|(
operator|(
operator|&
name|ne
operator|->
name|ne_active
operator|)
argument_list|,
operator|(
operator|&
name|nx
operator|->
name|nx_next
operator|)
argument_list|)
expr_stmt|;
name|KeReleaseSpinLock
argument_list|(
operator|&
name|ne
operator|->
name|ne_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
name|ip
operator|=
name|nx
operator|->
name|nx_priv
expr_stmt|;
name|urb
operator|=
name|usbd_geturb
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ubi
operator|=
operator|&
name|urb
operator|->
name|uu_bulkintr
expr_stmt|;
name|ep
operator|=
name|ubi
operator|->
name|ubi_epdesc
expr_stmt|;
name|nx
operator|->
name|nx_urbbuf
operator|=
name|ubi
operator|->
name|ubi_trans_buf
expr_stmt|;
name|nx
operator|->
name|nx_urbactlen
operator|=
literal|0
expr_stmt|;
name|nx
operator|->
name|nx_urblen
operator|=
name|ubi
operator|->
name|ubi_trans_buflen
expr_stmt|;
name|nx
operator|->
name|nx_shortxfer
operator|=
operator|(
name|ubi
operator|->
name|ubi_trans_flags
operator|&
name|USBD_SHORT_TRANSFER_OK
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|extra
label|:
name|len
operator|=
name|MIN
argument_list|(
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
argument_list|,
name|nx
operator|->
name|nx_urblen
argument_list|)
expr_stmt|;
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|UE_GET_DIR
argument_list|(
name|ep
operator|->
name|bEndpointAddress
argument_list|)
operator|==
name|UE_DIR_OUT
condition|)
name|usbd_copy_in
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
name|nx
operator|->
name|nx_urbbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frames
argument_list|(
name|xfer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
default|default:
name|nx
operator|=
name|usbd_aq_getfirst
argument_list|(
name|sc
argument_list|,
name|ne
argument_list|)
expr_stmt|;
if|if
condition|(
name|nx
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|ndis_dev
argument_list|,
literal|"usb xfer warning (%s)\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|usbd_xfer_complete
argument_list|(
name|sc
argument_list|,
name|ne
argument_list|,
name|nx
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
goto|goto
name|next
goto|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|usbd_ctrl_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|irp
modifier|*
name|ip
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|ndisusb_ep
modifier|*
name|ne
init|=
name|usbd_xfer_get_priv
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|ndisusb_xfer
modifier|*
name|nx
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
name|union
name|usbd_urb
modifier|*
name|urb
decl_stmt|;
name|struct
name|usbd_urb_vendor_or_class_request
modifier|*
name|vcreq
decl_stmt|;
name|struct
name|usb_page_cache
modifier|*
name|pc
decl_stmt|;
name|uint8_t
name|type
init|=
literal|0
decl_stmt|;
name|struct
name|usb_device_request
name|req
decl_stmt|;
name|int
name|len
decl_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
name|nx
operator|=
name|usbd_aq_getfirst
argument_list|(
name|sc
argument_list|,
name|ne
argument_list|)
expr_stmt|;
if|if
condition|(
name|nx
operator|==
name|NULL
condition|)
return|return;
name|ip
operator|=
name|nx
operator|->
name|nx_priv
expr_stmt|;
name|urb
operator|=
name|usbd_geturb
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|vcreq
operator|=
operator|&
name|urb
operator|->
name|uu_vcreq
expr_stmt|;
if|if
condition|(
name|vcreq
operator|->
name|uvc_trans_flags
operator|&
name|USBD_TRANSFER_DIRECTION_IN
condition|)
block|{
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|len
operator|=
name|usbd_xfer_frame_len
argument_list|(
name|xfer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|usbd_copy_out
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
name|vcreq
operator|->
name|uvc_trans_buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|nx
operator|->
name|nx_urbactlen
operator|+=
name|len
expr_stmt|;
block|}
name|usbd_xfer_complete
argument_list|(
name|sc
argument_list|,
name|ne
argument_list|,
name|nx
argument_list|,
name|USB_ERR_NORMAL_COMPLETION
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|USB_ST_SETUP
case|:
name|next
label|:
comment|/* get next transfer */
name|KeAcquireSpinLock
argument_list|(
operator|&
name|ne
operator|->
name|ne_lock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
if|if
condition|(
name|IsListEmpty
argument_list|(
operator|&
name|ne
operator|->
name|ne_pending
argument_list|)
condition|)
block|{
name|KeReleaseSpinLock
argument_list|(
operator|&
name|ne
operator|->
name|ne_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
return|return;
block|}
name|nx
operator|=
name|CONTAINING_RECORD
argument_list|(
name|ne
operator|->
name|ne_pending
operator|.
name|nle_flink
argument_list|,
expr|struct
name|ndisusb_xfer
argument_list|,
name|nx_next
argument_list|)
expr_stmt|;
name|RemoveEntryList
argument_list|(
operator|&
name|nx
operator|->
name|nx_next
argument_list|)
expr_stmt|;
comment|/* add a entry to the active queue's tail.  */
name|InsertTailList
argument_list|(
operator|(
operator|&
name|ne
operator|->
name|ne_active
operator|)
argument_list|,
operator|(
operator|&
name|nx
operator|->
name|nx_next
operator|)
argument_list|)
expr_stmt|;
name|KeReleaseSpinLock
argument_list|(
operator|&
name|ne
operator|->
name|ne_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
name|ip
operator|=
name|nx
operator|->
name|nx_priv
expr_stmt|;
name|urb
operator|=
name|usbd_geturb
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|vcreq
operator|=
operator|&
name|urb
operator|->
name|uu_vcreq
expr_stmt|;
switch|switch
condition|(
name|urb
operator|->
name|uu_hdr
operator|.
name|uuh_func
condition|)
block|{
case|case
name|URB_FUNCTION_CLASS_DEVICE
case|:
name|type
operator|=
name|UT_CLASS
operator||
name|UT_DEVICE
expr_stmt|;
break|break;
case|case
name|URB_FUNCTION_CLASS_INTERFACE
case|:
name|type
operator|=
name|UT_CLASS
operator||
name|UT_INTERFACE
expr_stmt|;
break|break;
case|case
name|URB_FUNCTION_CLASS_OTHER
case|:
name|type
operator|=
name|UT_CLASS
operator||
name|UT_OTHER
expr_stmt|;
break|break;
case|case
name|URB_FUNCTION_CLASS_ENDPOINT
case|:
name|type
operator|=
name|UT_CLASS
operator||
name|UT_ENDPOINT
expr_stmt|;
break|break;
case|case
name|URB_FUNCTION_VENDOR_DEVICE
case|:
name|type
operator|=
name|UT_VENDOR
operator||
name|UT_DEVICE
expr_stmt|;
break|break;
case|case
name|URB_FUNCTION_VENDOR_INTERFACE
case|:
name|type
operator|=
name|UT_VENDOR
operator||
name|UT_INTERFACE
expr_stmt|;
break|break;
case|case
name|URB_FUNCTION_VENDOR_OTHER
case|:
name|type
operator|=
name|UT_VENDOR
operator||
name|UT_OTHER
expr_stmt|;
break|break;
case|case
name|URB_FUNCTION_VENDOR_ENDPOINT
case|:
name|type
operator|=
name|UT_VENDOR
operator||
name|UT_ENDPOINT
expr_stmt|;
break|break;
default|default:
comment|/* never reached.  */
break|break;
block|}
name|type
operator||=
operator|(
name|vcreq
operator|->
name|uvc_trans_flags
operator|&
name|USBD_TRANSFER_DIRECTION_IN
operator|)
condition|?
name|UT_READ
else|:
name|UT_WRITE
expr_stmt|;
name|type
operator||=
name|vcreq
operator|->
name|uvc_reserved1
expr_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|type
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|vcreq
operator|->
name|uvc_req
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|vcreq
operator|->
name|uvc_idx
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|vcreq
operator|->
name|uvc_value
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
name|vcreq
operator|->
name|uvc_trans_buflen
argument_list|)
expr_stmt|;
name|nx
operator|->
name|nx_urbbuf
operator|=
name|vcreq
operator|->
name|uvc_trans_buf
expr_stmt|;
name|nx
operator|->
name|nx_urblen
operator|=
name|vcreq
operator|->
name|uvc_trans_buflen
expr_stmt|;
name|nx
operator|->
name|nx_urbactlen
operator|=
literal|0
expr_stmt|;
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|usbd_copy_in
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frames
argument_list|(
name|xfer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|vcreq
operator|->
name|uvc_trans_flags
operator|&
name|USBD_TRANSFER_DIRECTION_IN
condition|)
block|{
if|if
condition|(
name|vcreq
operator|->
name|uvc_trans_buflen
operator|>=
name|USBD_CTRL_READ_BUFFER_SP
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|ndis_dev
argument_list|,
literal|"warning: not enough buffer space (%d).\n"
argument_list|,
name|vcreq
operator|->
name|uvc_trans_buflen
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|1
argument_list|,
name|MIN
argument_list|(
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
argument_list|,
name|vcreq
operator|->
name|uvc_trans_buflen
argument_list|)
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frames
argument_list|(
name|xfer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|nx
operator|->
name|nx_urblen
operator|>
literal|0
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|ndis_dev
argument_list|,
literal|"warning: not enough write buffer space"
literal|" (%d).\n"
argument_list|,
name|nx
operator|->
name|nx_urblen
argument_list|)
expr_stmt|;
comment|/* 			 * XXX with my local tests there was no cases to require 			 * a extra buffer until now but it'd need to update in 			 * the future if it needs to be. 			 */
if|if
condition|(
name|nx
operator|->
name|nx_urblen
operator|>
literal|0
condition|)
block|{
name|pc
operator|=
name|usbd_xfer_get_frame
argument_list|(
name|xfer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|usbd_copy_in
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|,
name|nx
operator|->
name|nx_urbbuf
argument_list|,
name|nx
operator|->
name|nx_urblen
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|1
argument_list|,
name|nx
operator|->
name|nx_urblen
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frames
argument_list|(
name|xfer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
break|break;
default|default:
name|nx
operator|=
name|usbd_aq_getfirst
argument_list|(
name|sc
argument_list|,
name|ne
argument_list|)
expr_stmt|;
if|if
condition|(
name|nx
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
block|{
name|usbd_xfer_set_stall
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|ndis_dev
argument_list|,
literal|"usb xfer warning (%s)\n"
argument_list|,
name|usbd_errstr
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|usbd_xfer_complete
argument_list|(
name|sc
argument_list|,
name|ne
argument_list|,
name|nx
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|USB_ERR_CANCELLED
condition|)
goto|goto
name|next
goto|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|ndisusb_ep
modifier|*
name|usbd_get_ndisep
parameter_list|(
name|ip
parameter_list|,
name|ep
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|ep
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ndisusb_ep
modifier|*
name|ne
decl_stmt|;
name|ne
operator|=
operator|&
name|sc
operator|->
name|ndisusb_ep
index|[
name|NDISUSB_GET_ENDPT
argument_list|(
name|ep
operator|->
name|bEndpointAddress
argument_list|)
index|]
expr_stmt|;
name|IRP_NDISUSB_EP
argument_list|(
name|ip
argument_list|)
operator|=
name|ne
expr_stmt|;
name|ip
operator|->
name|irp_cancelfunc
operator|=
operator|(
name|cancel_func
operator|)
name|usbd_irpcancel_wrap
expr_stmt|;
return|return
operator|(
name|ne
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usbd_xfertask
parameter_list|(
name|dobj
parameter_list|,
name|arg
parameter_list|)
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|irp
modifier|*
name|ip
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|list_entry
modifier|*
name|l
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ndisusb_xferdone
modifier|*
name|nd
decl_stmt|;
name|struct
name|ndisusb_xfer
modifier|*
name|nq
decl_stmt|;
name|struct
name|usbd_urb_bulk_or_intr_transfer
modifier|*
name|ubi
decl_stmt|;
name|struct
name|usbd_urb_vendor_or_class_request
modifier|*
name|vcreq
decl_stmt|;
name|union
name|usbd_urb
modifier|*
name|urb
decl_stmt|;
name|usb_error_t
name|status
decl_stmt|;
name|void
modifier|*
name|priv
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|ndis_dev
expr_stmt|;
if|if
condition|(
name|IsListEmpty
argument_list|(
operator|&
name|sc
operator|->
name|ndisusb_xferdonelist
argument_list|)
condition|)
return|return;
name|KeAcquireSpinLockAtDpcLevel
argument_list|(
operator|&
name|sc
operator|->
name|ndisusb_xferdonelock
argument_list|)
expr_stmt|;
name|l
operator|=
name|sc
operator|->
name|ndisusb_xferdonelist
operator|.
name|nle_flink
expr_stmt|;
while|while
condition|(
name|l
operator|!=
operator|&
name|sc
operator|->
name|ndisusb_xferdonelist
condition|)
block|{
name|nd
operator|=
name|CONTAINING_RECORD
argument_list|(
name|l
argument_list|,
expr|struct
name|ndisusb_xferdone
argument_list|,
name|nd_donelist
argument_list|)
expr_stmt|;
name|nq
operator|=
name|nd
operator|->
name|nd_xfer
expr_stmt|;
name|priv
operator|=
name|nq
operator|->
name|nx_priv
expr_stmt|;
name|status
operator|=
name|nd
operator|->
name|nd_status
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ip
operator|=
name|priv
expr_stmt|;
name|urb
operator|=
name|usbd_geturb
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ip
operator|->
name|irp_cancelfunc
operator|=
name|NULL
expr_stmt|;
name|IRP_NDISUSB_EP
argument_list|(
name|ip
argument_list|)
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|status
condition|)
block|{
case|case
name|USB_ERR_NORMAL_COMPLETION
case|:
if|if
condition|(
name|urb
operator|->
name|uu_hdr
operator|.
name|uuh_func
operator|==
name|URB_FUNCTION_BULK_OR_INTERRUPT_TRANSFER
condition|)
block|{
name|ubi
operator|=
operator|&
name|urb
operator|->
name|uu_bulkintr
expr_stmt|;
name|ubi
operator|->
name|ubi_trans_buflen
operator|=
name|nq
operator|->
name|nx_urbactlen
expr_stmt|;
block|}
else|else
block|{
name|vcreq
operator|=
operator|&
name|urb
operator|->
name|uu_vcreq
expr_stmt|;
name|vcreq
operator|->
name|uvc_trans_buflen
operator|=
name|nq
operator|->
name|nx_urbactlen
expr_stmt|;
block|}
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_info
operator|=
name|nq
operator|->
name|nx_urbactlen
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|=
name|STATUS_SUCCESS
expr_stmt|;
name|USBD_URB_STATUS
argument_list|(
name|urb
argument_list|)
operator|=
name|USBD_STATUS_SUCCESS
expr_stmt|;
break|break;
case|case
name|USB_ERR_CANCELLED
case|:
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_info
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|=
name|STATUS_CANCELLED
expr_stmt|;
name|USBD_URB_STATUS
argument_list|(
name|urb
argument_list|)
operator|=
name|USBD_STATUS_CANCELED
expr_stmt|;
break|break;
default|default:
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_info
operator|=
literal|0
expr_stmt|;
name|USBD_URB_STATUS
argument_list|(
name|urb
argument_list|)
operator|=
name|usbd_usb2urb
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|=
name|usbd_urb2nt
argument_list|(
name|USBD_URB_STATUS
argument_list|(
name|urb
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|l
operator|=
name|l
operator|->
name|nle_flink
expr_stmt|;
name|RemoveEntryList
argument_list|(
operator|&
name|nd
operator|->
name|nd_donelist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nq
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nd
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
continue|continue;
name|KeReleaseSpinLockFromDpcLevel
argument_list|(
operator|&
name|sc
operator|->
name|ndisusb_xferdonelock
argument_list|)
expr_stmt|;
comment|/* NB: call after cleaning  */
name|IoCompleteRequest
argument_list|(
name|ip
argument_list|,
name|IO_NO_INCREMENT
argument_list|)
expr_stmt|;
name|KeAcquireSpinLockAtDpcLevel
argument_list|(
operator|&
name|sc
operator|->
name|ndisusb_xferdonelock
argument_list|)
expr_stmt|;
block|}
name|KeReleaseSpinLockFromDpcLevel
argument_list|(
operator|&
name|sc
operator|->
name|ndisusb_xferdonelock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this function is for mainly deferring a task to the another thread because  * we don't want to be in the scope of HAL lock.  */
end_comment

begin_function
specifier|static
name|int32_t
name|usbd_taskadd
parameter_list|(
name|ip
parameter_list|,
name|type
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
name|unsigned
name|type
decl_stmt|;
block|{
name|device_t
name|dev
init|=
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|ndisusb_task
modifier|*
name|nt
decl_stmt|;
name|nt
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ndisusb_task
argument_list|)
argument_list|,
name|M_USBDEV
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|==
name|NULL
condition|)
return|return
operator|(
name|USBD_STATUS_NO_MEMORY
operator|)
return|;
name|nt
operator|->
name|nt_type
operator|=
name|type
expr_stmt|;
name|nt
operator|->
name|nt_ctx
operator|=
name|ip
expr_stmt|;
name|KeAcquireSpinLockAtDpcLevel
argument_list|(
operator|&
name|sc
operator|->
name|ndisusb_tasklock
argument_list|)
expr_stmt|;
name|InsertTailList
argument_list|(
operator|(
operator|&
name|sc
operator|->
name|ndisusb_tasklist
operator|)
argument_list|,
operator|(
operator|&
name|nt
operator|->
name|nt_tasklist
operator|)
argument_list|)
expr_stmt|;
name|KeReleaseSpinLockFromDpcLevel
argument_list|(
operator|&
name|sc
operator|->
name|ndisusb_tasklock
argument_list|)
expr_stmt|;
name|IoQueueWorkItem
argument_list|(
name|sc
operator|->
name|ndisusb_taskitem
argument_list|,
operator|(
name|io_workitem_func
operator|)
name|usbd_task_wrap
argument_list|,
name|WORKQUEUE_CRITICAL
argument_list|,
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_STATUS_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usbd_task
parameter_list|(
name|dobj
parameter_list|,
name|arg
parameter_list|)
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|irp
modifier|*
name|ip
decl_stmt|;
name|list_entry
modifier|*
name|l
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ndisusb_ep
modifier|*
name|ne
decl_stmt|;
name|struct
name|ndisusb_task
modifier|*
name|nt
decl_stmt|;
name|union
name|usbd_urb
modifier|*
name|urb
decl_stmt|;
if|if
condition|(
name|IsListEmpty
argument_list|(
operator|&
name|sc
operator|->
name|ndisusb_tasklist
argument_list|)
condition|)
return|return;
name|KeAcquireSpinLockAtDpcLevel
argument_list|(
operator|&
name|sc
operator|->
name|ndisusb_tasklock
argument_list|)
expr_stmt|;
name|l
operator|=
name|sc
operator|->
name|ndisusb_tasklist
operator|.
name|nle_flink
expr_stmt|;
while|while
condition|(
name|l
operator|!=
operator|&
name|sc
operator|->
name|ndisusb_tasklist
condition|)
block|{
name|nt
operator|=
name|CONTAINING_RECORD
argument_list|(
name|l
argument_list|,
expr|struct
name|ndisusb_task
argument_list|,
name|nt_tasklist
argument_list|)
expr_stmt|;
name|ip
operator|=
name|nt
operator|->
name|nt_ctx
expr_stmt|;
name|urb
operator|=
name|usbd_geturb
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|KeReleaseSpinLockFromDpcLevel
argument_list|(
operator|&
name|sc
operator|->
name|ndisusb_tasklock
argument_list|)
expr_stmt|;
name|NDISUSB_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nt
operator|->
name|nt_type
condition|)
block|{
case|case
name|NDISUSB_TASK_TSTART
case|:
name|ne
operator|=
name|usbd_get_ndisep
argument_list|(
name|ip
argument_list|,
name|urb
operator|->
name|uu_bulkintr
operator|.
name|ubi_epdesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ne
operator|==
name|NULL
condition|)
goto|goto
name|exit
goto|;
name|usbd_transfer_start
argument_list|(
name|ne
operator|->
name|ne_xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|NDISUSB_TASK_IRPCANCEL
case|:
name|ne
operator|=
name|usbd_get_ndisep
argument_list|(
name|ip
argument_list|,
operator|(
name|nt
operator|->
name|nt_type
operator|==
name|NDISUSB_TASK_IRPCANCEL
operator|)
condition|?
name|urb
operator|->
name|uu_bulkintr
operator|.
name|ubi_epdesc
else|:
name|urb
operator|->
name|uu_pipe
operator|.
name|upr_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ne
operator|==
name|NULL
condition|)
goto|goto
name|exit
goto|;
name|usbd_transfer_stop
argument_list|(
name|ne
operator|->
name|ne_xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|ne
operator|->
name|ne_xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|NDISUSB_TASK_VENDOR
case|:
name|ne
operator|=
operator|(
name|urb
operator|->
name|uu_vcreq
operator|.
name|uvc_trans_flags
operator|&
name|USBD_TRANSFER_DIRECTION_IN
operator|)
condition|?
operator|&
name|sc
operator|->
name|ndisusb_dread_ep
else|:
operator|&
name|sc
operator|->
name|ndisusb_dwrite_ep
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|ne
operator|->
name|ne_xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|exit
label|:
name|NDISUSB_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KeAcquireSpinLockAtDpcLevel
argument_list|(
operator|&
name|sc
operator|->
name|ndisusb_tasklock
argument_list|)
expr_stmt|;
name|l
operator|=
name|l
operator|->
name|nle_flink
expr_stmt|;
name|RemoveEntryList
argument_list|(
operator|&
name|nt
operator|->
name|nt_tasklist
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nt
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
block|}
name|KeReleaseSpinLockFromDpcLevel
argument_list|(
operator|&
name|sc
operator|->
name|ndisusb_tasklock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|usbd_func_bulkintr
parameter_list|(
name|ip
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|int32_t
name|error
decl_stmt|;
name|struct
name|ndisusb_ep
modifier|*
name|ne
decl_stmt|;
name|struct
name|ndisusb_xfer
modifier|*
name|nx
decl_stmt|;
name|struct
name|usbd_urb_bulk_or_intr_transfer
modifier|*
name|ubi
decl_stmt|;
name|union
name|usbd_urb
modifier|*
name|urb
decl_stmt|;
name|usb_endpoint_descriptor_t
modifier|*
name|ep
decl_stmt|;
name|urb
operator|=
name|usbd_geturb
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ubi
operator|=
operator|&
name|urb
operator|->
name|uu_bulkintr
expr_stmt|;
name|ep
operator|=
name|ubi
operator|->
name|ubi_epdesc
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
return|return
operator|(
name|USBD_STATUS_INVALID_PIPE_HANDLE
operator|)
return|;
name|ne
operator|=
name|usbd_get_ndisep
argument_list|(
name|ip
argument_list|,
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|ne
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
argument_list|,
literal|"get NULL endpoint info.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_STATUS_INVALID_PIPE_HANDLE
operator|)
return|;
block|}
name|nx
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ndisusb_xfer
argument_list|)
argument_list|,
name|M_USBDEV
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nx
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|IRP_NDIS_DEV
argument_list|(
name|ip
argument_list|)
argument_list|,
literal|"out of memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|USBD_STATUS_NO_MEMORY
operator|)
return|;
block|}
name|nx
operator|->
name|nx_ep
operator|=
name|ne
expr_stmt|;
name|nx
operator|->
name|nx_priv
operator|=
name|ip
expr_stmt|;
name|KeAcquireSpinLockAtDpcLevel
argument_list|(
operator|&
name|ne
operator|->
name|ne_lock
argument_list|)
expr_stmt|;
name|InsertTailList
argument_list|(
operator|(
operator|&
name|ne
operator|->
name|ne_pending
operator|)
argument_list|,
operator|(
operator|&
name|nx
operator|->
name|nx_next
operator|)
argument_list|)
expr_stmt|;
name|KeReleaseSpinLockFromDpcLevel
argument_list|(
operator|&
name|ne
operator|->
name|ne_lock
argument_list|)
expr_stmt|;
comment|/* we've done to setup xfer.  Let's transfer it.  */
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|=
name|STATUS_PENDING
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_info
operator|=
literal|0
expr_stmt|;
name|USBD_URB_STATUS
argument_list|(
name|urb
argument_list|)
operator|=
name|USBD_STATUS_PENDING
expr_stmt|;
name|IoMarkIrpPending
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|error
operator|=
name|usbd_taskadd
argument_list|(
name|ip
argument_list|,
name|NDISUSB_TASK_TSTART
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|USBD_STATUS_SUCCESS
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|USBD_STATUS_PENDING
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|union
name|usbd_urb
modifier|*
name|USBD_CreateConfigurationRequest
parameter_list|(
name|conf
parameter_list|,
name|len
parameter_list|)
name|usb_config_descriptor_t
modifier|*
name|conf
decl_stmt|;
name|uint16_t
modifier|*
name|len
decl_stmt|;
block|{
name|struct
name|usbd_interface_list_entry
name|list
index|[
literal|2
index|]
decl_stmt|;
name|union
name|usbd_urb
modifier|*
name|urb
decl_stmt|;
name|bzero
argument_list|(
name|list
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|usbd_interface_list_entry
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|list
index|[
literal|0
index|]
operator|.
name|uil_intfdesc
operator|=
name|USBD_ParseConfigurationDescriptorEx
argument_list|(
name|conf
argument_list|,
name|conf
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|urb
operator|=
name|USBD_CreateConfigurationRequestEx
argument_list|(
name|conf
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|urb
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|*
name|len
operator|=
name|urb
operator|->
name|uu_selconf
operator|.
name|usc_hdr
operator|.
name|uuh_len
expr_stmt|;
return|return
name|urb
return|;
block|}
end_function

begin_function
specifier|static
name|union
name|usbd_urb
modifier|*
name|USBD_CreateConfigurationRequestEx
parameter_list|(
name|conf
parameter_list|,
name|list
parameter_list|)
name|usb_config_descriptor_t
modifier|*
name|conf
decl_stmt|;
name|struct
name|usbd_interface_list_entry
modifier|*
name|list
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|size
decl_stmt|;
name|struct
name|usbd_interface_information
modifier|*
name|intf
decl_stmt|;
name|struct
name|usbd_pipe_information
modifier|*
name|pipe
decl_stmt|;
name|struct
name|usbd_urb_select_configuration
modifier|*
name|selconf
decl_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|desc
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|size
operator|=
literal|0
init|;
name|i
operator|<
name|conf
operator|->
name|bNumInterface
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|list
index|[
name|i
index|]
operator|.
name|uil_intfdesc
operator|->
name|bNumEndpoints
expr_stmt|;
name|size
operator|=
name|size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|usbd_interface_information
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|usbd_pipe_information
argument_list|)
operator|*
operator|(
name|j
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|usbd_urb_select_configuration
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|usbd_interface_information
argument_list|)
expr_stmt|;
name|selconf
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|selconf
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|selconf
operator|->
name|usc_hdr
operator|.
name|uuh_func
operator|=
name|URB_FUNCTION_SELECT_CONFIGURATION
expr_stmt|;
name|selconf
operator|->
name|usc_hdr
operator|.
name|uuh_len
operator|=
name|size
expr_stmt|;
name|selconf
operator|->
name|usc_handle
operator|=
name|conf
expr_stmt|;
name|selconf
operator|->
name|usc_conf
operator|=
name|conf
expr_stmt|;
name|intf
operator|=
operator|&
name|selconf
operator|->
name|usc_intf
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|conf
operator|->
name|bNumInterface
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|list
index|[
name|i
index|]
operator|.
name|uil_intfdesc
operator|==
name|NULL
condition|)
break|break;
name|list
index|[
name|i
index|]
operator|.
name|uil_intf
operator|=
name|intf
expr_stmt|;
name|desc
operator|=
name|list
index|[
name|i
index|]
operator|.
name|uil_intfdesc
expr_stmt|;
name|intf
operator|->
name|uii_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usbd_interface_information
argument_list|)
operator|+
operator|(
name|desc
operator|->
name|bNumEndpoints
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|usbd_pipe_information
argument_list|)
expr_stmt|;
name|intf
operator|->
name|uii_intfnum
operator|=
name|desc
operator|->
name|bInterfaceNumber
expr_stmt|;
name|intf
operator|->
name|uii_altset
operator|=
name|desc
operator|->
name|bAlternateSetting
expr_stmt|;
name|intf
operator|->
name|uii_intfclass
operator|=
name|desc
operator|->
name|bInterfaceClass
expr_stmt|;
name|intf
operator|->
name|uii_intfsubclass
operator|=
name|desc
operator|->
name|bInterfaceSubClass
expr_stmt|;
name|intf
operator|->
name|uii_intfproto
operator|=
name|desc
operator|->
name|bInterfaceProtocol
expr_stmt|;
name|intf
operator|->
name|uii_handle
operator|=
name|desc
expr_stmt|;
name|intf
operator|->
name|uii_numeps
operator|=
name|desc
operator|->
name|bNumEndpoints
expr_stmt|;
name|pipe
operator|=
operator|&
name|intf
operator|->
name|uii_pipes
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|intf
operator|->
name|uii_numeps
condition|;
name|j
operator|++
control|)
name|pipe
index|[
name|j
index|]
operator|.
name|upi_maxtxsize
operator|=
name|USBD_DEFAULT_MAXIMUM_TRANSFER_SIZE
expr_stmt|;
name|intf
operator|=
operator|(
expr|struct
name|usbd_interface_information
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|intf
operator|+
name|intf
operator|->
name|uii_len
operator|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
expr|union
name|usbd_urb
operator|*
operator|)
name|selconf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|USBD_GetUSBDIVersion
parameter_list|(
name|ui
parameter_list|)
name|usbd_version_info
modifier|*
name|ui
decl_stmt|;
block|{
comment|/* Pretend to be Windows XP. */
name|ui
operator|->
name|uvi_usbdi_vers
operator|=
name|USBDI_VERSION
expr_stmt|;
name|ui
operator|->
name|uvi_supported_vers
operator|=
name|USB_VER_2_0
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|usb_interface_descriptor_t
modifier|*
name|USBD_ParseConfigurationDescriptor
parameter_list|(
name|usb_config_descriptor_t
modifier|*
name|conf
parameter_list|,
name|uint8_t
name|intfnum
parameter_list|,
name|uint8_t
name|altset
parameter_list|)
block|{
return|return
name|USBD_ParseConfigurationDescriptorEx
argument_list|(
name|conf
argument_list|,
name|conf
argument_list|,
name|intfnum
argument_list|,
name|altset
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|usb_interface_descriptor_t
modifier|*
name|USBD_ParseConfigurationDescriptorEx
parameter_list|(
name|conf
parameter_list|,
name|start
parameter_list|,
name|intfnum
parameter_list|,
name|altset
parameter_list|,
name|intfclass
parameter_list|,
name|intfsubclass
parameter_list|,
name|intfproto
parameter_list|)
name|usb_config_descriptor_t
modifier|*
name|conf
decl_stmt|;
name|void
modifier|*
name|start
decl_stmt|;
name|int32_t
name|intfnum
decl_stmt|;
name|int32_t
name|altset
decl_stmt|;
name|int32_t
name|intfclass
decl_stmt|;
name|int32_t
name|intfsubclass
decl_stmt|;
name|int32_t
name|intfproto
decl_stmt|;
block|{
name|struct
name|usb_descriptor
modifier|*
name|next
init|=
name|NULL
decl_stmt|;
name|usb_interface_descriptor_t
modifier|*
name|desc
decl_stmt|;
while|while
condition|(
operator|(
name|next
operator|=
name|usb_desc_foreach
argument_list|(
name|conf
argument_list|,
name|next
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|desc
operator|=
operator|(
name|usb_interface_descriptor_t
operator|*
operator|)
name|next
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|bDescriptorType
operator|!=
name|UDESC_INTERFACE
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|intfnum
operator|==
operator|-
literal|1
operator|||
name|desc
operator|->
name|bInterfaceNumber
operator|==
name|intfnum
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|altset
operator|==
operator|-
literal|1
operator|||
name|desc
operator|->
name|bAlternateSetting
operator|==
name|altset
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|intfclass
operator|==
operator|-
literal|1
operator|||
name|desc
operator|->
name|bInterfaceClass
operator|==
name|intfclass
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|intfsubclass
operator|==
operator|-
literal|1
operator|||
name|desc
operator|->
name|bInterfaceSubClass
operator|==
name|intfsubclass
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|intfproto
operator|==
operator|-
literal|1
operator|||
name|desc
operator|->
name|bInterfaceProtocol
operator|==
name|intfproto
operator|)
condition|)
continue|continue;
return|return
operator|(
name|desc
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dummy
parameter_list|(
name|void
parameter_list|)
block|{
name|printf
argument_list|(
literal|"USBD dummy called\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_decl_stmt
name|image_patch_table
name|usbd_functbl
index|[]
init|=
block|{
name|IMPORT_SFUNC
argument_list|(
name|USBD_CreateConfigurationRequest
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|USBD_CreateConfigurationRequestEx
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC_MAP
argument_list|(
name|_USBD_CreateConfigurationRequestEx
expr|@
literal|8
argument_list|,
name|USBD_CreateConfigurationRequestEx
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|USBD_GetUSBDIVersion
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|USBD_ParseConfigurationDescriptor
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|USBD_ParseConfigurationDescriptorEx
argument_list|,
literal|7
argument_list|)
block|,
name|IMPORT_SFUNC_MAP
argument_list|(
name|_USBD_ParseConfigurationDescriptorEx
expr|@
literal|28
argument_list|,
name|USBD_ParseConfigurationDescriptorEx
argument_list|,
literal|7
argument_list|)
block|,
comment|/* 	 * This last entry is a catch-all for any function we haven't 	 * implemented yet. The PE import list patching routine will 	 * use it for any function that doesn't have an explicit match 	 * in this table. 	 */
block|{
name|NULL
block|,
operator|(
name|FUNC
operator|)
name|dummy
block|,
name|NULL
block|,
literal|0
block|,
name|WINDRV_WRAP_STDCALL
block|}
block|,
comment|/* End of list. */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ndis
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

