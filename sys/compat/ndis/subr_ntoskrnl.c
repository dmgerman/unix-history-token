begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003  *	Bill Paul<wpaul@windriver.com>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Bill Paul.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|502113
end_if

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/pe_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/cfg_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/resource_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/ntoskrnl_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/hal_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/ndis_var.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NTOSKRNL_DEBUG_TIMERS
end_ifdef

begin_function_decl
specifier|static
name|int
name|sysctl_show_timers
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|ntoskrnl_timers
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_show_timers
argument_list|,
literal|"I"
argument_list|,
literal|"Show ntoskrnl timer stats"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|kdpc_queue
block|{
name|list_entry
name|kq_disp
decl_stmt|;
name|struct
name|thread
modifier|*
name|kq_td
decl_stmt|;
name|int
name|kq_cpu
decl_stmt|;
name|int
name|kq_exit
decl_stmt|;
name|int
name|kq_running
decl_stmt|;
name|kspin_lock
name|kq_lock
decl_stmt|;
name|nt_kevent
name|kq_proc
decl_stmt|;
name|nt_kevent
name|kq_done
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|kdpc_queue
name|kdpc_queue
typedef|;
end_typedef

begin_struct
struct|struct
name|wb_ext
block|{
name|struct
name|cv
name|we_cv
decl_stmt|;
name|struct
name|thread
modifier|*
name|we_td
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|wb_ext
name|wb_ext
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NTOSKRNL_TIMEOUTS
value|256
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|NTOSKRNL_DEBUG_TIMERS
end_ifdef

begin_decl_stmt
specifier|static
name|uint64_t
name|ntoskrnl_timer_fires
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|ntoskrnl_timer_sets
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|ntoskrnl_timer_reloads
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|ntoskrnl_timer_cancels
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|callout_entry
block|{
name|struct
name|callout
name|ce_callout
decl_stmt|;
name|list_entry
name|ce_list
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|callout_entry
name|callout_entry
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|struct
name|list_entry
name|ntoskrnl_calllist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|ntoskrnl_calllock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|list_entry
name|ntoskrnl_intlist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kspin_lock
name|ntoskrnl_intlock
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|uint8_t
name|RtlEqualUnicodeString
parameter_list|(
name|unicode_string
modifier|*
parameter_list|,
name|unicode_string
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|RtlCopyUnicodeString
parameter_list|(
name|unicode_string
modifier|*
parameter_list|,
name|unicode_string
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|irp
modifier|*
name|IoBuildSynchronousFsdRequest
parameter_list|(
name|uint32_t
parameter_list|,
name|device_object
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint64_t
modifier|*
parameter_list|,
name|nt_kevent
modifier|*
parameter_list|,
name|io_status_block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|irp
modifier|*
name|IoBuildAsynchronousFsdRequest
parameter_list|(
name|uint32_t
parameter_list|,
name|device_object
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint64_t
modifier|*
parameter_list|,
name|io_status_block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|irp
modifier|*
name|IoBuildDeviceIoControlRequest
parameter_list|(
name|uint32_t
parameter_list|,
name|device_object
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint8_t
parameter_list|,
name|nt_kevent
modifier|*
parameter_list|,
name|io_status_block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|irp
modifier|*
name|IoAllocateIrp
parameter_list|(
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|IoReuseIrp
parameter_list|(
name|irp
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|IoFreeIrp
parameter_list|(
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|IoInitializeIrp
parameter_list|(
name|irp
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|irp
modifier|*
name|IoMakeAssociatedIrp
parameter_list|(
name|irp
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|KeWaitForMultipleObjects
parameter_list|(
name|uint32_t
parameter_list|,
name|nt_dispatch_header
modifier|*
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|,
name|uint8_t
parameter_list|,
name|int64_t
modifier|*
parameter_list|,
name|wait_block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntoskrnl_waittest
parameter_list|(
name|nt_dispatch_header
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntoskrnl_satisfy_wait
parameter_list|(
name|nt_dispatch_header
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntoskrnl_satisfy_multiple_waits
parameter_list|(
name|wait_block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntoskrnl_is_signalled
parameter_list|(
name|nt_dispatch_header
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntoskrnl_insert_timer
parameter_list|(
name|ktimer
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntoskrnl_remove_timer
parameter_list|(
name|ktimer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|NTOSKRNL_DEBUG_TIMERS
end_ifdef

begin_function_decl
specifier|static
name|void
name|ntoskrnl_show_timers
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ntoskrnl_timercall
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntoskrnl_dpc_thread
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntoskrnl_destroy_dpc_threads
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntoskrnl_destroy_workitem_threads
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntoskrnl_workitem_thread
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntoskrnl_workitem
parameter_list|(
name|device_object
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntoskrnl_unicode_to_ascii
parameter_list|(
name|uint16_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntoskrnl_ascii_to_unicode
parameter_list|(
name|char
modifier|*
parameter_list|,
name|uint16_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|ntoskrnl_insert_dpc
parameter_list|(
name|list_entry
modifier|*
parameter_list|,
name|kdpc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|WRITE_REGISTER_USHORT
parameter_list|(
name|uint16_t
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|READ_REGISTER_USHORT
parameter_list|(
name|uint16_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|WRITE_REGISTER_ULONG
parameter_list|(
name|uint32_t
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|READ_REGISTER_ULONG
parameter_list|(
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|WRITE_REGISTER_UCHAR
parameter_list|(
name|uint8_t
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|READ_REGISTER_UCHAR
parameter_list|(
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|_allmul
parameter_list|(
name|int64_t
parameter_list|,
name|int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|_alldiv
parameter_list|(
name|int64_t
parameter_list|,
name|int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|_allrem
parameter_list|(
name|int64_t
parameter_list|,
name|int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|_allshr
parameter_list|(
name|int64_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|_allshl
parameter_list|(
name|int64_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|_aullmul
parameter_list|(
name|uint64_t
parameter_list|,
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|_aulldiv
parameter_list|(
name|uint64_t
parameter_list|,
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|_aullrem
parameter_list|(
name|uint64_t
parameter_list|,
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|_aullshr
parameter_list|(
name|uint64_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|_aullshl
parameter_list|(
name|uint64_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|slist_entry
modifier|*
name|ntoskrnl_pushsl
parameter_list|(
name|slist_header
modifier|*
parameter_list|,
name|slist_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|slist_entry
modifier|*
name|ntoskrnl_popsl
parameter_list|(
name|slist_header
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ExInitializePagedLookasideList
parameter_list|(
name|paged_lookaside_list
modifier|*
parameter_list|,
name|lookaside_alloc_func
modifier|*
parameter_list|,
name|lookaside_free_func
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|size_t
parameter_list|,
name|uint32_t
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ExDeletePagedLookasideList
parameter_list|(
name|paged_lookaside_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ExInitializeNPagedLookasideList
parameter_list|(
name|npaged_lookaside_list
modifier|*
parameter_list|,
name|lookaside_alloc_func
modifier|*
parameter_list|,
name|lookaside_free_func
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|size_t
parameter_list|,
name|uint32_t
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ExDeleteNPagedLookasideList
parameter_list|(
name|npaged_lookaside_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|slist_entry
modifier|*
name|ExInterlockedPushEntrySList
parameter_list|(
name|slist_header
modifier|*
parameter_list|,
name|slist_entry
modifier|*
parameter_list|,
name|kspin_lock
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|slist_entry
modifier|*
name|ExInterlockedPopEntrySList
parameter_list|(
name|slist_header
modifier|*
parameter_list|,
name|kspin_lock
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|InterlockedIncrement
parameter_list|(
specifier|volatile
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|InterlockedDecrement
parameter_list|(
specifier|volatile
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ExInterlockedAddLargeStatistic
parameter_list|(
name|uint64_t
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|MmAllocateContiguousMemory
parameter_list|(
name|uint32_t
parameter_list|,
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|MmAllocateContiguousMemorySpecifyCache
parameter_list|(
name|uint32_t
parameter_list|,
name|uint64_t
parameter_list|,
name|uint64_t
parameter_list|,
name|uint64_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|MmFreeContiguousMemory
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|MmFreeContiguousMemorySpecifyCache
parameter_list|(
name|void
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|MmSizeOfMdl
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|MmMapLockedPages
parameter_list|(
name|mdl
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|MmMapLockedPagesSpecifyCache
parameter_list|(
name|mdl
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint32_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|MmUnmapLockedPages
parameter_list|(
name|void
modifier|*
parameter_list|,
name|mdl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|device_t
name|ntoskrnl_finddev
parameter_list|(
name|device_t
parameter_list|,
name|uint64_t
parameter_list|,
name|struct
name|resource
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|RtlZeroMemory
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|RtlCopyMemory
parameter_list|(
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|RtlCompareMemory
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ndis_status
name|RtlUnicodeStringToInteger
parameter_list|(
name|unicode_string
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atoi
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|atol
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rand
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|srand
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|KeQuerySystemTime
parameter_list|(
name|uint64_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|KeTickCount
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|IoIsWdmVersionAvailable
parameter_list|(
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntoskrnl_thrfunc
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ndis_status
name|PsCreateSystemThread
parameter_list|(
name|ndis_handle
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|ndis_handle
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ndis_status
name|PsTerminateSystemThread
parameter_list|(
name|ndis_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ndis_status
name|IoGetDeviceObjectPointer
parameter_list|(
name|unicode_string
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|device_object
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ndis_status
name|IoGetDeviceProperty
parameter_list|(
name|device_object
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|KeInitializeMutex
parameter_list|(
name|kmutant
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|KeReleaseMutex
parameter_list|(
name|kmutant
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|KeReadStateMutex
parameter_list|(
name|kmutant
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ndis_status
name|ObReferenceObjectByHandle
parameter_list|(
name|ndis_handle
parameter_list|,
name|uint32_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ObfDereferenceObject
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|ZwClose
parameter_list|(
name|ndis_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|WmiQueryTraceInformation
parameter_list|(
name|uint32_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|WmiTraceMessage
parameter_list|(
name|uint64_t
parameter_list|,
name|uint32_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|IoWMIRegistrationControl
parameter_list|(
name|device_object
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|ntoskrnl_memset
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|ntoskrnl_memmove
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|ntoskrnl_memchr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|unsigned
name|char
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|ntoskrnl_strstr
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|ntoskrnl_strncat
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntoskrnl_toupper
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ntoskrnl_tolower
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|funcptr
name|ntoskrnl_findwrap
parameter_list|(
name|funcptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|DbgPrint
parameter_list|(
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|DbgBreakPoint
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|KeBugCheckEx
parameter_list|(
name|uint32_t
parameter_list|,
name|u_long
parameter_list|,
name|u_long
parameter_list|,
name|u_long
parameter_list|,
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|KeDelayExecutionThread
parameter_list|(
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|,
name|int64_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
name|KeSetPriorityThread
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dummy
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|ntoskrnl_dispatchlock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|ntoskrnl_interlock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kspin_lock
name|ntoskrnl_cancellock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ntoskrnl_kth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nt_objref_head
name|ntoskrnl_reflist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|mdl_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|iw_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kdpc_queue
modifier|*
name|kq_queues
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kdpc_queue
modifier|*
name|wq_queues
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|wq_idx
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|ntoskrnl_libinit
parameter_list|()
block|{
name|image_patch_table
modifier|*
name|patch
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|kdpc_queue
modifier|*
name|kq
decl_stmt|;
name|callout_entry
modifier|*
name|e
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|name
index|[
literal|64
index|]
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|,
literal|"ntoskrnl dispatch lock"
argument_list|,
name|MTX_NDIS_LOCK
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ntoskrnl_interlock
argument_list|,
name|MTX_NTOSKRNL_SPIN_LOCK
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|KeInitializeSpinLock
argument_list|(
operator|&
name|ntoskrnl_cancellock
argument_list|)
expr_stmt|;
name|KeInitializeSpinLock
argument_list|(
operator|&
name|ntoskrnl_intlock
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ntoskrnl_reflist
argument_list|)
expr_stmt|;
name|InitializeListHead
argument_list|(
operator|&
name|ntoskrnl_calllist
argument_list|)
expr_stmt|;
name|InitializeListHead
argument_list|(
operator|&
name|ntoskrnl_intlist
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ntoskrnl_calllock
argument_list|,
name|MTX_NTOSKRNL_SPIN_LOCK
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|kq_queues
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
ifdef|#
directive|ifdef
name|NTOSKRNL_MULTIPLE_DPCS
sizeof|sizeof
argument_list|(
name|kdpc_queue
argument_list|)
operator|*
name|mp_ncpus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
sizeof|sizeof
argument_list|(
name|kdpc_queue
argument_list|)
operator|,
literal|0
block|)
function|;
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|kq_queues
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
end_if

begin_expr_stmt
name|wq_queues
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
sizeof|sizeof
argument_list|(
name|kdpc_queue
argument_list|)
operator|*
name|WORKITEM_THREADS
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|wq_queues
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|NTOSKRNL_MULTIPLE_DPCS
end_ifdef

begin_expr_stmt
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|kq_queues
argument_list|,
sizeof|sizeof
argument_list|(
name|kdpc_queue
argument_list|)
operator|*
name|mp_ncpus
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|kq_queues
argument_list|,
sizeof|sizeof
argument_list|(
name|kdpc_queue
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wq_queues
argument_list|,
sizeof|sizeof
argument_list|(
name|kdpc_queue
argument_list|)
operator|*
name|WORKITEM_THREADS
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 	 * Launch the DPC threads. 	 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NTOSKRNL_MULTIPLE_DPCS
end_ifdef

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp_ncpus
condition|;
name|i
operator|++
control|)
block|{
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1
condition|;
name|i
operator|++
control|)
block|{
endif|#
directive|endif
name|kq
operator|=
name|kq_queues
operator|+
name|i
expr_stmt|;
name|kq
operator|->
name|kq_cpu
operator|=
name|i
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"Windows DPC %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|error
operator|=
name|kproc_create
argument_list|(
name|ntoskrnl_dpc_thread
argument_list|,
name|kq
argument_list|,
operator|&
name|p
argument_list|,
name|RFHIGHPID
argument_list|,
name|NDIS_KSTACK_PAGES
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"failed to launch DPC thread"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Launch the workitem threads. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WORKITEM_THREADS
condition|;
name|i
operator|++
control|)
block|{
name|kq
operator|=
name|wq_queues
operator|+
name|i
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"Windows Workitem %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|error
operator|=
name|kproc_create
argument_list|(
name|ntoskrnl_workitem_thread
argument_list|,
name|kq
argument_list|,
operator|&
name|p
argument_list|,
name|RFHIGHPID
argument_list|,
name|NDIS_KSTACK_PAGES
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"failed to launch workitem thread"
argument_list|)
expr_stmt|;
block|}
name|patch
operator|=
name|ntoskrnl_functbl
expr_stmt|;
while|while
condition|(
name|patch
operator|->
name|ipt_func
operator|!=
name|NULL
condition|)
block|{
name|windrv_wrap
argument_list|(
operator|(
name|funcptr
operator|)
name|patch
operator|->
name|ipt_func
argument_list|,
operator|(
name|funcptr
operator|*
operator|)
operator|&
name|patch
operator|->
name|ipt_wrap
argument_list|,
name|patch
operator|->
name|ipt_argcnt
argument_list|,
name|patch
operator|->
name|ipt_ftype
argument_list|)
expr_stmt|;
name|patch
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTOSKRNL_TIMEOUTS
condition|;
name|i
operator|++
control|)
block|{
name|e
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
sizeof|sizeof
argument_list|(
name|callout_entry
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"failed to allocate timeouts"
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|ntoskrnl_calllock
argument_list|)
expr_stmt|;
name|InsertHeadList
argument_list|(
operator|(
operator|&
name|ntoskrnl_calllist
operator|)
argument_list|,
operator|(
operator|&
name|e
operator|->
name|ce_list
operator|)
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|ntoskrnl_calllock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * MDLs are supposed to be variable size (they describe 	 * buffers containing some number of pages, but we don't 	 * know ahead of time how many pages that will be). But 	 * always allocating them off the heap is very slow. As 	 * a compromise, we create an MDL UMA zone big enough to 	 * handle any buffer requiring up to 16 pages, and we 	 * use those for any MDLs for buffers of 16 pages or less 	 * in size. For buffers larger than that (which we assume 	 * will be few and far between, we allocate the MDLs off 	 * the heap. 	 */
name|mdl_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"Windows MDL"
argument_list|,
name|MDL_ZONE_SIZE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iw_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"Windows WorkItem"
argument_list|,
sizeof|sizeof
argument_list|(
name|io_workitem
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_for

begin_function
name|int
name|ntoskrnl_libfini
parameter_list|()
block|{
name|image_patch_table
modifier|*
name|patch
decl_stmt|;
name|callout_entry
modifier|*
name|e
decl_stmt|;
name|list_entry
modifier|*
name|l
decl_stmt|;
name|patch
operator|=
name|ntoskrnl_functbl
expr_stmt|;
while|while
condition|(
name|patch
operator|->
name|ipt_func
operator|!=
name|NULL
condition|)
block|{
name|windrv_unwrap
argument_list|(
name|patch
operator|->
name|ipt_wrap
argument_list|)
expr_stmt|;
name|patch
operator|++
expr_stmt|;
block|}
comment|/* Stop the workitem queues. */
name|ntoskrnl_destroy_workitem_threads
argument_list|()
expr_stmt|;
comment|/* Stop the DPC queues. */
name|ntoskrnl_destroy_dpc_threads
argument_list|()
expr_stmt|;
name|ExFreePool
argument_list|(
name|kq_queues
argument_list|)
expr_stmt|;
name|ExFreePool
argument_list|(
name|wq_queues
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|mdl_zone
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|iw_zone
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|ntoskrnl_calllock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|IsListEmpty
argument_list|(
operator|&
name|ntoskrnl_calllist
argument_list|)
condition|)
block|{
name|l
operator|=
name|RemoveHeadList
argument_list|(
operator|&
name|ntoskrnl_calllist
argument_list|)
expr_stmt|;
name|e
operator|=
name|CONTAINING_RECORD
argument_list|(
name|l
argument_list|,
name|callout_entry
argument_list|,
name|ce_list
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|ntoskrnl_calllock
argument_list|)
expr_stmt|;
name|ExFreePool
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|ntoskrnl_calllock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|ntoskrnl_calllock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ntoskrnl_interlock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ntoskrnl_calllock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We need to be able to reference this externally from the wrapper;  * GCC only generates a local implementation of memset.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|ntoskrnl_memset
parameter_list|(
name|buf
parameter_list|,
name|ch
parameter_list|,
name|size
parameter_list|)
name|void
modifier|*
name|buf
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
return|return
operator|(
name|memset
argument_list|(
name|buf
argument_list|,
name|ch
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|ntoskrnl_memmove
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|size
parameter_list|)
name|void
modifier|*
name|src
decl_stmt|;
name|void
modifier|*
name|dst
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|dst
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|ntoskrnl_memchr
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|unsigned
name|char
name|ch
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|p
operator|++
operator|==
name|ch
condition|)
return|return
operator|(
name|p
operator|-
literal|1
operator|)
return|;
block|}
do|while
condition|(
operator|--
name|len
operator|!=
literal|0
condition|)
do|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|ntoskrnl_strstr
parameter_list|(
name|s
parameter_list|,
name|find
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|find
decl_stmt|;
end_function

begin_block
block|{
name|char
name|c
decl_stmt|,
name|sc
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|find
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|find
argument_list|)
expr_stmt|;
do|do
block|{
do|do
block|{
if|if
condition|(
operator|(
name|sc
operator|=
operator|*
name|s
operator|++
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
do|while
condition|(
name|sc
operator|!=
name|c
condition|)
do|;
block|}
do|while
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
name|find
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
do|;
name|s
operator|--
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|s
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Taken from libc */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|ntoskrnl_strncat
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|dst
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
name|size_t
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
name|char
modifier|*
name|d
init|=
name|dst
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
name|src
decl_stmt|;
while|while
condition|(
operator|*
name|d
operator|!=
literal|0
condition|)
name|d
operator|++
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
operator|*
name|d
operator|=
operator|*
name|s
operator|++
operator|)
operator|==
literal|0
condition|)
break|break;
name|d
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
operator|!=
literal|0
condition|)
do|;
operator|*
name|d
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|dst
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntoskrnl_toupper
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
return|return
operator|(
name|toupper
argument_list|(
name|c
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ntoskrnl_tolower
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
return|return
operator|(
name|tolower
argument_list|(
name|c
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|RtlEqualUnicodeString
parameter_list|(
name|unicode_string
modifier|*
name|str1
parameter_list|,
name|unicode_string
modifier|*
name|str2
parameter_list|,
name|uint8_t
name|caseinsensitive
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|str1
operator|->
name|us_len
operator|!=
name|str2
operator|->
name|us_len
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|str1
operator|->
name|us_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|caseinsensitive
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
name|toupper
argument_list|(
call|(
name|char
call|)
argument_list|(
name|str1
operator|->
name|us_buf
index|[
name|i
index|]
operator|&
literal|0xFF
argument_list|)
argument_list|)
operator|!=
name|toupper
argument_list|(
call|(
name|char
call|)
argument_list|(
name|str2
operator|->
name|us_buf
index|[
name|i
index|]
operator|&
literal|0xFF
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|str1
operator|->
name|us_buf
index|[
name|i
index|]
operator|!=
name|str2
operator|->
name|us_buf
index|[
name|i
index|]
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|RtlCopyUnicodeString
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|unicode_string
modifier|*
name|dest
decl_stmt|;
name|unicode_string
modifier|*
name|src
decl_stmt|;
block|{
if|if
condition|(
name|dest
operator|->
name|us_maxlen
operator|>=
name|src
operator|->
name|us_len
condition|)
name|dest
operator|->
name|us_len
operator|=
name|src
operator|->
name|us_len
expr_stmt|;
else|else
name|dest
operator|->
name|us_len
operator|=
name|dest
operator|->
name|us_maxlen
expr_stmt|;
name|memcpy
argument_list|(
name|dest
operator|->
name|us_buf
argument_list|,
name|src
operator|->
name|us_buf
argument_list|,
name|dest
operator|->
name|us_len
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ntoskrnl_ascii_to_unicode
parameter_list|(
name|ascii
parameter_list|,
name|unicode
parameter_list|,
name|len
parameter_list|)
name|char
modifier|*
name|ascii
decl_stmt|;
name|uint16_t
modifier|*
name|unicode
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|uint16_t
modifier|*
name|ustr
decl_stmt|;
name|ustr
operator|=
name|unicode
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|ustr
operator|=
operator|(
name|uint16_t
operator|)
name|ascii
index|[
name|i
index|]
expr_stmt|;
name|ustr
operator|++
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ntoskrnl_unicode_to_ascii
parameter_list|(
name|unicode
parameter_list|,
name|ascii
parameter_list|,
name|len
parameter_list|)
name|uint16_t
modifier|*
name|unicode
decl_stmt|;
name|char
modifier|*
name|ascii
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|uint8_t
modifier|*
name|astr
decl_stmt|;
name|astr
operator|=
name|ascii
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|astr
operator|=
operator|(
name|uint8_t
operator|)
name|unicode
index|[
name|i
index|]
expr_stmt|;
name|astr
operator|++
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|uint32_t
name|RtlUnicodeStringToAnsiString
parameter_list|(
name|ansi_string
modifier|*
name|dest
parameter_list|,
name|unicode_string
modifier|*
name|src
parameter_list|,
name|uint8_t
name|allocate
parameter_list|)
block|{
if|if
condition|(
name|dest
operator|==
name|NULL
operator|||
name|src
operator|==
name|NULL
condition|)
return|return
operator|(
name|STATUS_INVALID_PARAMETER
operator|)
return|;
name|dest
operator|->
name|as_len
operator|=
name|src
operator|->
name|us_len
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|as_maxlen
operator|<
name|dest
operator|->
name|as_len
condition|)
name|dest
operator|->
name|as_len
operator|=
name|dest
operator|->
name|as_maxlen
expr_stmt|;
if|if
condition|(
name|allocate
operator|==
name|TRUE
condition|)
block|{
name|dest
operator|->
name|as_buf
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
operator|(
name|src
operator|->
name|us_len
operator|/
literal|2
operator|)
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|as_buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|STATUS_INSUFFICIENT_RESOURCES
operator|)
return|;
name|dest
operator|->
name|as_len
operator|=
name|dest
operator|->
name|as_maxlen
operator|=
name|src
operator|->
name|us_len
operator|/
literal|2
expr_stmt|;
block|}
else|else
block|{
name|dest
operator|->
name|as_len
operator|=
name|src
operator|->
name|us_len
operator|/
literal|2
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|dest
operator|->
name|as_maxlen
operator|<
name|dest
operator|->
name|as_len
condition|)
name|dest
operator|->
name|as_len
operator|=
name|dest
operator|->
name|as_maxlen
expr_stmt|;
block|}
name|ntoskrnl_unicode_to_ascii
argument_list|(
name|src
operator|->
name|us_buf
argument_list|,
name|dest
operator|->
name|as_buf
argument_list|,
name|dest
operator|->
name|as_len
operator|*
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|RtlAnsiStringToUnicodeString
parameter_list|(
name|unicode_string
modifier|*
name|dest
parameter_list|,
name|ansi_string
modifier|*
name|src
parameter_list|,
name|uint8_t
name|allocate
parameter_list|)
block|{
if|if
condition|(
name|dest
operator|==
name|NULL
operator|||
name|src
operator|==
name|NULL
condition|)
return|return
operator|(
name|STATUS_INVALID_PARAMETER
operator|)
return|;
if|if
condition|(
name|allocate
operator|==
name|TRUE
condition|)
block|{
name|dest
operator|->
name|us_buf
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
name|src
operator|->
name|as_len
operator|*
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest
operator|->
name|us_buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|STATUS_INSUFFICIENT_RESOURCES
operator|)
return|;
name|dest
operator|->
name|us_len
operator|=
name|dest
operator|->
name|us_maxlen
operator|=
name|strlen
argument_list|(
name|src
operator|->
name|as_buf
argument_list|)
operator|*
literal|2
expr_stmt|;
block|}
else|else
block|{
name|dest
operator|->
name|us_len
operator|=
name|src
operator|->
name|as_len
operator|*
literal|2
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|dest
operator|->
name|us_maxlen
operator|<
name|dest
operator|->
name|us_len
condition|)
name|dest
operator|->
name|us_len
operator|=
name|dest
operator|->
name|us_maxlen
expr_stmt|;
block|}
name|ntoskrnl_ascii_to_unicode
argument_list|(
name|src
operator|->
name|as_buf
argument_list|,
name|dest
operator|->
name|us_buf
argument_list|,
name|dest
operator|->
name|us_len
operator|/
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|ExAllocatePoolWithTag
parameter_list|(
name|pooltype
parameter_list|,
name|len
parameter_list|,
name|tag
parameter_list|)
name|uint32_t
name|pooltype
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|uint32_t
name|tag
decl_stmt|;
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ExFreePool
parameter_list|(
name|buf
parameter_list|)
name|void
modifier|*
name|buf
decl_stmt|;
block|{
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|uint32_t
name|IoAllocateDriverObjectExtension
parameter_list|(
name|drv
parameter_list|,
name|clid
parameter_list|,
name|extlen
parameter_list|,
name|ext
parameter_list|)
name|driver_object
modifier|*
name|drv
decl_stmt|;
name|void
modifier|*
name|clid
decl_stmt|;
name|uint32_t
name|extlen
decl_stmt|;
name|void
modifier|*
modifier|*
name|ext
decl_stmt|;
block|{
name|custom_extension
modifier|*
name|ce
decl_stmt|;
name|ce
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
sizeof|sizeof
argument_list|(
name|custom_extension
argument_list|)
operator|+
name|extlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce
operator|==
name|NULL
condition|)
return|return
operator|(
name|STATUS_INSUFFICIENT_RESOURCES
operator|)
return|;
name|ce
operator|->
name|ce_clid
operator|=
name|clid
expr_stmt|;
name|InsertTailList
argument_list|(
operator|(
operator|&
name|drv
operator|->
name|dro_driverext
operator|->
name|dre_usrext
operator|)
argument_list|,
operator|(
operator|&
name|ce
operator|->
name|ce_list
operator|)
argument_list|)
expr_stmt|;
operator|*
name|ext
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|ce
operator|+
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|IoGetDriverObjectExtension
parameter_list|(
name|drv
parameter_list|,
name|clid
parameter_list|)
name|driver_object
modifier|*
name|drv
decl_stmt|;
name|void
modifier|*
name|clid
decl_stmt|;
block|{
name|list_entry
modifier|*
name|e
decl_stmt|;
name|custom_extension
modifier|*
name|ce
decl_stmt|;
comment|/* 	 * Sanity check. Our dummy bus drivers don't have 	 * any driver extentions. 	 */
if|if
condition|(
name|drv
operator|->
name|dro_driverext
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|e
operator|=
name|drv
operator|->
name|dro_driverext
operator|->
name|dre_usrext
operator|.
name|nle_flink
expr_stmt|;
while|while
condition|(
name|e
operator|!=
operator|&
name|drv
operator|->
name|dro_driverext
operator|->
name|dre_usrext
condition|)
block|{
name|ce
operator|=
operator|(
name|custom_extension
operator|*
operator|)
name|e
expr_stmt|;
if|if
condition|(
name|ce
operator|->
name|ce_clid
operator|==
name|clid
condition|)
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|(
name|ce
operator|+
literal|1
operator|)
operator|)
return|;
name|e
operator|=
name|e
operator|->
name|nle_flink
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|IoCreateDevice
parameter_list|(
name|driver_object
modifier|*
name|drv
parameter_list|,
name|uint32_t
name|devextlen
parameter_list|,
name|unicode_string
modifier|*
name|devname
parameter_list|,
name|uint32_t
name|devtype
parameter_list|,
name|uint32_t
name|devchars
parameter_list|,
name|uint8_t
name|exclusive
parameter_list|,
name|device_object
modifier|*
modifier|*
name|newdev
parameter_list|)
block|{
name|device_object
modifier|*
name|dev
decl_stmt|;
name|dev
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
sizeof|sizeof
argument_list|(
name|device_object
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|STATUS_INSUFFICIENT_RESOURCES
operator|)
return|;
name|dev
operator|->
name|do_type
operator|=
name|devtype
expr_stmt|;
name|dev
operator|->
name|do_drvobj
operator|=
name|drv
expr_stmt|;
name|dev
operator|->
name|do_currirp
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|do_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|devextlen
condition|)
block|{
name|dev
operator|->
name|do_devext
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
name|devextlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|do_devext
operator|==
name|NULL
condition|)
block|{
name|ExFreePool
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_INSUFFICIENT_RESOURCES
operator|)
return|;
block|}
name|bzero
argument_list|(
name|dev
operator|->
name|do_devext
argument_list|,
name|devextlen
argument_list|)
expr_stmt|;
block|}
else|else
name|dev
operator|->
name|do_devext
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|do_size
operator|=
sizeof|sizeof
argument_list|(
name|device_object
argument_list|)
operator|+
name|devextlen
expr_stmt|;
name|dev
operator|->
name|do_refcnt
operator|=
literal|1
expr_stmt|;
name|dev
operator|->
name|do_attacheddev
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|do_nextdev
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|do_devtype
operator|=
name|devtype
expr_stmt|;
name|dev
operator|->
name|do_stacksize
operator|=
literal|1
expr_stmt|;
name|dev
operator|->
name|do_alignreq
operator|=
literal|1
expr_stmt|;
name|dev
operator|->
name|do_characteristics
operator|=
name|devchars
expr_stmt|;
name|dev
operator|->
name|do_iotimer
operator|=
name|NULL
expr_stmt|;
name|KeInitializeEvent
argument_list|(
operator|&
name|dev
operator|->
name|do_devlock
argument_list|,
name|EVENT_TYPE_SYNC
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * Vpd is used for disk/tape devices, 	 * but we don't support those. (Yet.) 	 */
name|dev
operator|->
name|do_vpb
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|do_devobj_ext
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
sizeof|sizeof
argument_list|(
name|devobj_extension
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|do_devobj_ext
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|dev
operator|->
name|do_devext
operator|!=
name|NULL
condition|)
name|ExFreePool
argument_list|(
name|dev
operator|->
name|do_devext
argument_list|)
expr_stmt|;
name|ExFreePool
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_INSUFFICIENT_RESOURCES
operator|)
return|;
block|}
name|dev
operator|->
name|do_devobj_ext
operator|->
name|dve_type
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|do_devobj_ext
operator|->
name|dve_size
operator|=
sizeof|sizeof
argument_list|(
name|devobj_extension
argument_list|)
expr_stmt|;
name|dev
operator|->
name|do_devobj_ext
operator|->
name|dve_devobj
operator|=
name|dev
expr_stmt|;
comment|/* 	 * Attach this device to the driver object's list 	 * of devices. Note: this is not the same as attaching 	 * the device to the device stack. The driver's AddDevice 	 * routine must explicitly call IoAddDeviceToDeviceStack() 	 * to do that. 	 */
if|if
condition|(
name|drv
operator|->
name|dro_devobj
operator|==
name|NULL
condition|)
block|{
name|drv
operator|->
name|dro_devobj
operator|=
name|dev
expr_stmt|;
name|dev
operator|->
name|do_nextdev
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|do_nextdev
operator|=
name|drv
operator|->
name|dro_devobj
expr_stmt|;
name|drv
operator|->
name|dro_devobj
operator|=
name|dev
expr_stmt|;
block|}
operator|*
name|newdev
operator|=
name|dev
expr_stmt|;
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|IoDeleteDevice
parameter_list|(
name|dev
parameter_list|)
name|device_object
modifier|*
name|dev
decl_stmt|;
block|{
name|device_object
modifier|*
name|prev
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|dev
operator|->
name|do_devobj_ext
operator|!=
name|NULL
condition|)
name|ExFreePool
argument_list|(
name|dev
operator|->
name|do_devobj_ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|do_devext
operator|!=
name|NULL
condition|)
name|ExFreePool
argument_list|(
name|dev
operator|->
name|do_devext
argument_list|)
expr_stmt|;
comment|/* Unlink the device from the driver's device list. */
name|prev
operator|=
name|dev
operator|->
name|do_drvobj
operator|->
name|dro_devobj
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|dev
condition|)
name|dev
operator|->
name|do_drvobj
operator|->
name|dro_devobj
operator|=
name|dev
operator|->
name|do_nextdev
expr_stmt|;
else|else
block|{
while|while
condition|(
name|prev
operator|->
name|do_nextdev
operator|!=
name|dev
condition|)
name|prev
operator|=
name|prev
operator|->
name|do_nextdev
expr_stmt|;
name|prev
operator|->
name|do_nextdev
operator|=
name|dev
operator|->
name|do_nextdev
expr_stmt|;
block|}
name|ExFreePool
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|device_object
modifier|*
name|IoGetAttachedDevice
parameter_list|(
name|dev
parameter_list|)
name|device_object
modifier|*
name|dev
decl_stmt|;
block|{
name|device_object
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|d
operator|=
name|dev
expr_stmt|;
while|while
condition|(
name|d
operator|->
name|do_attacheddev
operator|!=
name|NULL
condition|)
name|d
operator|=
name|d
operator|->
name|do_attacheddev
expr_stmt|;
return|return
operator|(
name|d
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|irp
modifier|*
name|IoBuildSynchronousFsdRequest
parameter_list|(
name|func
parameter_list|,
name|dobj
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|off
parameter_list|,
name|event
parameter_list|,
name|status
parameter_list|)
name|uint32_t
name|func
decl_stmt|;
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|uint64_t
modifier|*
name|off
decl_stmt|;
name|nt_kevent
modifier|*
name|event
decl_stmt|;
name|io_status_block
modifier|*
name|status
decl_stmt|;
block|{
name|irp
modifier|*
name|ip
decl_stmt|;
name|ip
operator|=
name|IoBuildAsynchronousFsdRequest
argument_list|(
name|func
argument_list|,
name|dobj
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|off
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ip
operator|->
name|irp_usrevent
operator|=
name|event
expr_stmt|;
return|return
operator|(
name|ip
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|irp
modifier|*
name|IoBuildAsynchronousFsdRequest
parameter_list|(
name|func
parameter_list|,
name|dobj
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|off
parameter_list|,
name|status
parameter_list|)
name|uint32_t
name|func
decl_stmt|;
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|uint64_t
modifier|*
name|off
decl_stmt|;
name|io_status_block
modifier|*
name|status
decl_stmt|;
block|{
name|irp
modifier|*
name|ip
decl_stmt|;
name|io_stack_location
modifier|*
name|sl
decl_stmt|;
name|ip
operator|=
name|IoAllocateIrp
argument_list|(
name|dobj
operator|->
name|do_stacksize
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ip
operator|->
name|irp_usriostat
operator|=
name|status
expr_stmt|;
name|ip
operator|->
name|irp_tail
operator|.
name|irp_overlay
operator|.
name|irp_thread
operator|=
name|NULL
expr_stmt|;
name|sl
operator|=
name|IoGetNextIrpStackLocation
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|sl
operator|->
name|isl_major
operator|=
name|func
expr_stmt|;
name|sl
operator|->
name|isl_minor
operator|=
literal|0
expr_stmt|;
name|sl
operator|->
name|isl_flags
operator|=
literal|0
expr_stmt|;
name|sl
operator|->
name|isl_ctl
operator|=
literal|0
expr_stmt|;
name|sl
operator|->
name|isl_devobj
operator|=
name|dobj
expr_stmt|;
name|sl
operator|->
name|isl_fileobj
operator|=
name|NULL
expr_stmt|;
name|sl
operator|->
name|isl_completionfunc
operator|=
name|NULL
expr_stmt|;
name|ip
operator|->
name|irp_userbuf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|dobj
operator|->
name|do_flags
operator|&
name|DO_BUFFERED_IO
condition|)
block|{
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
operator|==
name|NULL
condition|)
block|{
name|IoFreeIrp
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|buf
argument_list|,
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dobj
operator|->
name|do_flags
operator|&
name|DO_DIRECT_IO
condition|)
block|{
name|ip
operator|->
name|irp_mdl
operator|=
name|IoAllocateMdl
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|irp_mdl
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
operator|!=
name|NULL
condition|)
name|ExFreePool
argument_list|(
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
argument_list|)
expr_stmt|;
name|IoFreeIrp
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ip
operator|->
name|irp_userbuf
operator|=
name|NULL
expr_stmt|;
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|func
operator|==
name|IRP_MJ_READ
condition|)
block|{
name|sl
operator|->
name|isl_parameters
operator|.
name|isl_read
operator|.
name|isl_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|off
operator|!=
name|NULL
condition|)
name|sl
operator|->
name|isl_parameters
operator|.
name|isl_read
operator|.
name|isl_byteoff
operator|=
operator|*
name|off
expr_stmt|;
else|else
name|sl
operator|->
name|isl_parameters
operator|.
name|isl_read
operator|.
name|isl_byteoff
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|func
operator|==
name|IRP_MJ_WRITE
condition|)
block|{
name|sl
operator|->
name|isl_parameters
operator|.
name|isl_write
operator|.
name|isl_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|off
operator|!=
name|NULL
condition|)
name|sl
operator|->
name|isl_parameters
operator|.
name|isl_write
operator|.
name|isl_byteoff
operator|=
operator|*
name|off
expr_stmt|;
else|else
name|sl
operator|->
name|isl_parameters
operator|.
name|isl_write
operator|.
name|isl_byteoff
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|ip
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|irp
modifier|*
name|IoBuildDeviceIoControlRequest
parameter_list|(
name|uint32_t
name|iocode
parameter_list|,
name|device_object
modifier|*
name|dobj
parameter_list|,
name|void
modifier|*
name|ibuf
parameter_list|,
name|uint32_t
name|ilen
parameter_list|,
name|void
modifier|*
name|obuf
parameter_list|,
name|uint32_t
name|olen
parameter_list|,
name|uint8_t
name|isinternal
parameter_list|,
name|nt_kevent
modifier|*
name|event
parameter_list|,
name|io_status_block
modifier|*
name|status
parameter_list|)
block|{
name|irp
modifier|*
name|ip
decl_stmt|;
name|io_stack_location
modifier|*
name|sl
decl_stmt|;
name|uint32_t
name|buflen
decl_stmt|;
name|ip
operator|=
name|IoAllocateIrp
argument_list|(
name|dobj
operator|->
name|do_stacksize
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ip
operator|->
name|irp_usrevent
operator|=
name|event
expr_stmt|;
name|ip
operator|->
name|irp_usriostat
operator|=
name|status
expr_stmt|;
name|ip
operator|->
name|irp_tail
operator|.
name|irp_overlay
operator|.
name|irp_thread
operator|=
name|NULL
expr_stmt|;
name|sl
operator|=
name|IoGetNextIrpStackLocation
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|sl
operator|->
name|isl_major
operator|=
name|isinternal
operator|==
name|TRUE
condition|?
name|IRP_MJ_INTERNAL_DEVICE_CONTROL
else|:
name|IRP_MJ_DEVICE_CONTROL
expr_stmt|;
name|sl
operator|->
name|isl_minor
operator|=
literal|0
expr_stmt|;
name|sl
operator|->
name|isl_flags
operator|=
literal|0
expr_stmt|;
name|sl
operator|->
name|isl_ctl
operator|=
literal|0
expr_stmt|;
name|sl
operator|->
name|isl_devobj
operator|=
name|dobj
expr_stmt|;
name|sl
operator|->
name|isl_fileobj
operator|=
name|NULL
expr_stmt|;
name|sl
operator|->
name|isl_completionfunc
operator|=
name|NULL
expr_stmt|;
name|sl
operator|->
name|isl_parameters
operator|.
name|isl_ioctl
operator|.
name|isl_iocode
operator|=
name|iocode
expr_stmt|;
name|sl
operator|->
name|isl_parameters
operator|.
name|isl_ioctl
operator|.
name|isl_ibuflen
operator|=
name|ilen
expr_stmt|;
name|sl
operator|->
name|isl_parameters
operator|.
name|isl_ioctl
operator|.
name|isl_obuflen
operator|=
name|olen
expr_stmt|;
switch|switch
condition|(
name|IO_METHOD
argument_list|(
name|iocode
argument_list|)
condition|)
block|{
case|case
name|METHOD_BUFFERED
case|:
if|if
condition|(
name|ilen
operator|>
name|olen
condition|)
name|buflen
operator|=
name|ilen
expr_stmt|;
else|else
name|buflen
operator|=
name|olen
expr_stmt|;
if|if
condition|(
name|buflen
condition|)
block|{
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
name|buflen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
operator|==
name|NULL
condition|)
block|{
name|IoFreeIrp
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ilen
operator|&&
name|ibuf
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|ibuf
argument_list|,
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
operator|+
name|ilen
argument_list|,
name|buflen
operator|-
name|ilen
argument_list|)
expr_stmt|;
block|}
else|else
name|bzero
argument_list|(
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
name|ip
operator|->
name|irp_userbuf
operator|=
name|obuf
expr_stmt|;
break|break;
case|case
name|METHOD_IN_DIRECT
case|:
case|case
name|METHOD_OUT_DIRECT
case|:
if|if
condition|(
name|ilen
operator|&&
name|ibuf
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
name|ilen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
operator|==
name|NULL
condition|)
block|{
name|IoFreeIrp
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|ibuf
argument_list|,
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|olen
operator|&&
name|obuf
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|->
name|irp_mdl
operator|=
name|IoAllocateMdl
argument_list|(
name|obuf
argument_list|,
name|olen
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|ip
argument_list|)
expr_stmt|;
comment|/* 			 * Normally we would MmProbeAndLockPages() 			 * here, but we don't have to in our 			 * imlementation. 			 */
block|}
break|break;
case|case
name|METHOD_NEITHER
case|:
name|ip
operator|->
name|irp_userbuf
operator|=
name|obuf
expr_stmt|;
name|sl
operator|->
name|isl_parameters
operator|.
name|isl_ioctl
operator|.
name|isl_type3ibuf
operator|=
name|ibuf
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 * Ideally, we should associate this IRP with the calling 	 * thread here. 	 */
return|return
operator|(
name|ip
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|irp
modifier|*
name|IoAllocateIrp
parameter_list|(
name|uint8_t
name|stsize
parameter_list|,
name|uint8_t
name|chargequota
parameter_list|)
block|{
name|irp
modifier|*
name|i
decl_stmt|;
name|i
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
name|IoSizeOfIrp
argument_list|(
name|stsize
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|IoInitializeIrp
argument_list|(
name|i
argument_list|,
name|IoSizeOfIrp
argument_list|(
name|stsize
argument_list|)
argument_list|,
name|stsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|irp
modifier|*
name|IoMakeAssociatedIrp
parameter_list|(
name|irp
modifier|*
name|ip
parameter_list|,
name|uint8_t
name|stsize
parameter_list|)
block|{
name|irp
modifier|*
name|associrp
decl_stmt|;
name|associrp
operator|=
name|IoAllocateIrp
argument_list|(
name|stsize
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|associrp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|associrp
operator|->
name|irp_flags
operator||=
name|IRP_ASSOCIATED_IRP
expr_stmt|;
name|associrp
operator|->
name|irp_tail
operator|.
name|irp_overlay
operator|.
name|irp_thread
operator|=
name|ip
operator|->
name|irp_tail
operator|.
name|irp_overlay
operator|.
name|irp_thread
expr_stmt|;
name|associrp
operator|->
name|irp_assoc
operator|.
name|irp_master
operator|=
name|ip
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|associrp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|IoFreeIrp
parameter_list|(
name|ip
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|ExFreePool
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|IoInitializeIrp
parameter_list|(
name|irp
modifier|*
name|io
parameter_list|,
name|uint16_t
name|psize
parameter_list|,
name|uint8_t
name|ssize
parameter_list|)
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|io
argument_list|,
name|IoSizeOfIrp
argument_list|(
name|ssize
argument_list|)
argument_list|)
expr_stmt|;
name|io
operator|->
name|irp_size
operator|=
name|psize
expr_stmt|;
name|io
operator|->
name|irp_stackcnt
operator|=
name|ssize
expr_stmt|;
name|io
operator|->
name|irp_currentstackloc
operator|=
name|ssize
expr_stmt|;
name|InitializeListHead
argument_list|(
operator|&
name|io
operator|->
name|irp_thlist
argument_list|)
expr_stmt|;
name|io
operator|->
name|irp_tail
operator|.
name|irp_overlay
operator|.
name|irp_csl
operator|=
operator|(
name|io_stack_location
operator|*
operator|)
operator|(
name|io
operator|+
literal|1
operator|)
operator|+
name|ssize
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|IoReuseIrp
parameter_list|(
name|ip
parameter_list|,
name|status
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
block|{
name|uint8_t
name|allocflags
decl_stmt|;
name|allocflags
operator|=
name|ip
operator|->
name|irp_allocflags
expr_stmt|;
name|IoInitializeIrp
argument_list|(
name|ip
argument_list|,
name|ip
operator|->
name|irp_size
argument_list|,
name|ip
operator|->
name|irp_stackcnt
argument_list|)
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|=
name|status
expr_stmt|;
name|ip
operator|->
name|irp_allocflags
operator|=
name|allocflags
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|IoAcquireCancelSpinLock
parameter_list|(
name|uint8_t
modifier|*
name|irql
parameter_list|)
block|{
name|KeAcquireSpinLock
argument_list|(
operator|&
name|ntoskrnl_cancellock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|IoReleaseCancelSpinLock
parameter_list|(
name|uint8_t
name|irql
parameter_list|)
block|{
name|KeReleaseSpinLock
argument_list|(
operator|&
name|ntoskrnl_cancellock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|uint8_t
name|IoCancelIrp
parameter_list|(
name|irp
modifier|*
name|ip
parameter_list|)
block|{
name|cancel_func
name|cfunc
decl_stmt|;
name|uint8_t
name|cancelirql
decl_stmt|;
name|IoAcquireCancelSpinLock
argument_list|(
operator|&
name|cancelirql
argument_list|)
expr_stmt|;
name|cfunc
operator|=
name|IoSetCancelRoutine
argument_list|(
name|ip
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ip
operator|->
name|irp_cancel
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|cfunc
operator|==
name|NULL
condition|)
block|{
name|IoReleaseCancelSpinLock
argument_list|(
name|cancelirql
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|ip
operator|->
name|irp_cancelirql
operator|=
name|cancelirql
expr_stmt|;
name|MSCALL2
argument_list|(
name|cfunc
argument_list|,
name|IoGetCurrentIrpStackLocation
argument_list|(
name|ip
argument_list|)
operator|->
name|isl_devobj
argument_list|,
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|uint8_t
operator|)
name|IoSetCancelValue
argument_list|(
name|ip
argument_list|,
name|TRUE
argument_list|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|IofCallDriver
parameter_list|(
name|dobj
parameter_list|,
name|ip
parameter_list|)
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|driver_object
modifier|*
name|drvobj
decl_stmt|;
name|io_stack_location
modifier|*
name|sl
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|driver_dispatch
name|disp
decl_stmt|;
name|drvobj
operator|=
name|dobj
operator|->
name|do_drvobj
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|irp_currentstackloc
operator|<=
literal|0
condition|)
name|panic
argument_list|(
literal|"IoCallDriver(): out of stack locations"
argument_list|)
expr_stmt|;
name|IoSetNextIrpStackLocation
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|sl
operator|=
name|IoGetCurrentIrpStackLocation
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|sl
operator|->
name|isl_devobj
operator|=
name|dobj
expr_stmt|;
name|disp
operator|=
name|drvobj
operator|->
name|dro_dispatch
index|[
name|sl
operator|->
name|isl_major
index|]
expr_stmt|;
name|status
operator|=
name|MSCALL2
argument_list|(
name|disp
argument_list|,
name|dobj
argument_list|,
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|void
name|IofCompleteRequest
parameter_list|(
name|irp
modifier|*
name|ip
parameter_list|,
name|uint8_t
name|prioboost
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|io_stack_location
modifier|*
name|sl
decl_stmt|;
name|completion_func
name|cf
decl_stmt|;
name|KASSERT
argument_list|(
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|!=
name|STATUS_PENDING
argument_list|,
operator|(
literal|"incorrect IRP(%p) status (STATUS_PENDING)"
operator|,
name|ip
operator|)
argument_list|)
expr_stmt|;
name|sl
operator|=
name|IoGetCurrentIrpStackLocation
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|IoSkipCurrentIrpStackLocation
argument_list|(
name|ip
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|sl
operator|->
name|isl_ctl
operator|&
name|SL_PENDING_RETURNED
condition|)
name|ip
operator|->
name|irp_pendingreturned
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|irp_currentstackloc
operator|!=
operator|(
name|ip
operator|->
name|irp_stackcnt
operator|+
literal|1
operator|)
condition|)
name|dobj
operator|=
name|IoGetCurrentIrpStackLocation
argument_list|(
name|ip
argument_list|)
operator|->
name|isl_devobj
expr_stmt|;
else|else
name|dobj
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sl
operator|->
name|isl_completionfunc
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|==
name|STATUS_SUCCESS
operator|&&
name|sl
operator|->
name|isl_ctl
operator|&
name|SL_INVOKE_ON_SUCCESS
operator|)
operator|||
operator|(
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|!=
name|STATUS_SUCCESS
operator|&&
name|sl
operator|->
name|isl_ctl
operator|&
name|SL_INVOKE_ON_ERROR
operator|)
operator|||
operator|(
name|ip
operator|->
name|irp_cancel
operator|==
name|TRUE
operator|&&
name|sl
operator|->
name|isl_ctl
operator|&
name|SL_INVOKE_ON_CANCEL
operator|)
operator|)
condition|)
block|{
name|cf
operator|=
name|sl
operator|->
name|isl_completionfunc
expr_stmt|;
name|status
operator|=
name|MSCALL3
argument_list|(
name|cf
argument_list|,
name|dobj
argument_list|,
name|ip
argument_list|,
name|sl
operator|->
name|isl_completionctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|STATUS_MORE_PROCESSING_REQUIRED
condition|)
return|return;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ip
operator|->
name|irp_currentstackloc
operator|<=
name|ip
operator|->
name|irp_stackcnt
operator|)
operator|&&
operator|(
name|ip
operator|->
name|irp_pendingreturned
operator|==
name|TRUE
operator|)
condition|)
name|IoMarkIrpPending
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
comment|/* move to the next.  */
name|IoSkipCurrentIrpStackLocation
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|sl
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|ip
operator|->
name|irp_currentstackloc
operator|<=
operator|(
name|ip
operator|->
name|irp_stackcnt
operator|+
literal|1
operator|)
condition|)
do|;
comment|/* Handle any associated IRPs. */
if|if
condition|(
name|ip
operator|->
name|irp_flags
operator|&
name|IRP_ASSOCIATED_IRP
condition|)
block|{
name|uint32_t
name|masterirpcnt
decl_stmt|;
name|irp
modifier|*
name|masterirp
decl_stmt|;
name|mdl
modifier|*
name|m
decl_stmt|;
name|masterirp
operator|=
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_master
expr_stmt|;
name|masterirpcnt
operator|=
name|InterlockedDecrement
argument_list|(
operator|&
name|masterirp
operator|->
name|irp_assoc
operator|.
name|irp_irpcnt
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|ip
operator|->
name|irp_mdl
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|->
name|irp_mdl
operator|=
name|m
operator|->
name|mdl_next
expr_stmt|;
name|IoFreeMdl
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|IoFreeIrp
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterirpcnt
operator|==
literal|0
condition|)
name|IoCompleteRequest
argument_list|(
name|masterirp
argument_list|,
name|IO_NO_INCREMENT
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* With any luck, these conditions will never arise. */
if|if
condition|(
name|ip
operator|->
name|irp_flags
operator|&
operator|(
name|IRP_PAGING_IO
operator||
name|IRP_CLOSE_OPERATION
operator|)
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|irp_usriostat
operator|!=
name|NULL
condition|)
operator|*
name|ip
operator|->
name|irp_usriostat
operator|=
name|ip
operator|->
name|irp_iostat
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|irp_usrevent
operator|!=
name|NULL
condition|)
name|KeSetEvent
argument_list|(
name|ip
operator|->
name|irp_usrevent
argument_list|,
name|prioboost
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|irp_flags
operator|&
name|IRP_PAGING_IO
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|irp_mdl
operator|!=
name|NULL
condition|)
name|IoFreeMdl
argument_list|(
name|ip
operator|->
name|irp_mdl
argument_list|)
expr_stmt|;
name|IoFreeIrp
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
name|void
name|ntoskrnl_intr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|kinterrupt
modifier|*
name|iobj
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
name|uint8_t
name|claimed
decl_stmt|;
name|list_entry
modifier|*
name|l
decl_stmt|;
name|KeAcquireSpinLock
argument_list|(
operator|&
name|ntoskrnl_intlock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
name|l
operator|=
name|ntoskrnl_intlist
operator|.
name|nle_flink
expr_stmt|;
while|while
condition|(
name|l
operator|!=
operator|&
name|ntoskrnl_intlist
condition|)
block|{
name|iobj
operator|=
name|CONTAINING_RECORD
argument_list|(
name|l
argument_list|,
name|kinterrupt
argument_list|,
name|ki_list
argument_list|)
expr_stmt|;
name|claimed
operator|=
name|MSCALL2
argument_list|(
name|iobj
operator|->
name|ki_svcfunc
argument_list|,
name|iobj
argument_list|,
name|iobj
operator|->
name|ki_svcctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|claimed
operator|==
name|TRUE
condition|)
break|break;
name|l
operator|=
name|l
operator|->
name|nle_flink
expr_stmt|;
block|}
name|KeReleaseSpinLock
argument_list|(
operator|&
name|ntoskrnl_intlock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|uint8_t
name|KeAcquireInterruptSpinLock
parameter_list|(
name|iobj
parameter_list|)
name|kinterrupt
modifier|*
name|iobj
decl_stmt|;
block|{
name|uint8_t
name|irql
decl_stmt|;
name|KeAcquireSpinLock
argument_list|(
operator|&
name|ntoskrnl_intlock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
return|return
operator|(
name|irql
operator|)
return|;
block|}
end_function

begin_function
name|void
name|KeReleaseInterruptSpinLock
parameter_list|(
name|kinterrupt
modifier|*
name|iobj
parameter_list|,
name|uint8_t
name|irql
parameter_list|)
block|{
name|KeReleaseSpinLock
argument_list|(
operator|&
name|ntoskrnl_intlock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|uint8_t
name|KeSynchronizeExecution
parameter_list|(
name|iobj
parameter_list|,
name|syncfunc
parameter_list|,
name|syncctx
parameter_list|)
name|kinterrupt
modifier|*
name|iobj
decl_stmt|;
name|void
modifier|*
name|syncfunc
decl_stmt|;
name|void
modifier|*
name|syncctx
decl_stmt|;
block|{
name|uint8_t
name|irql
decl_stmt|;
name|KeAcquireSpinLock
argument_list|(
operator|&
name|ntoskrnl_intlock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
name|MSCALL1
argument_list|(
name|syncfunc
argument_list|,
name|syncctx
argument_list|)
expr_stmt|;
name|KeReleaseSpinLock
argument_list|(
operator|&
name|ntoskrnl_intlock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * IoConnectInterrupt() is passed only the interrupt vector and  * irql that a device wants to use, but no device-specific tag  * of any kind. This conflicts rather badly with FreeBSD's  * bus_setup_intr(), which needs the device_t for the device  * requesting interrupt delivery. In order to bypass this  * inconsistency, we implement a second level of interrupt  * dispatching on top of bus_setup_intr(). All devices use  * ntoskrnl_intr() as their ISR, and any device requesting  * interrupts will be registered with ntoskrnl_intr()'s interrupt  * dispatch list. When an interrupt arrives, we walk the list  * and invoke all the registered ISRs. This effectively makes all  * interrupts shared, but it's the only way to duplicate the  * semantics of IoConnectInterrupt() and IoDisconnectInterrupt() properly.  */
end_comment

begin_function
name|uint32_t
name|IoConnectInterrupt
parameter_list|(
name|kinterrupt
modifier|*
modifier|*
name|iobj
parameter_list|,
name|void
modifier|*
name|svcfunc
parameter_list|,
name|void
modifier|*
name|svcctx
parameter_list|,
name|kspin_lock
modifier|*
name|lock
parameter_list|,
name|uint32_t
name|vector
parameter_list|,
name|uint8_t
name|irql
parameter_list|,
name|uint8_t
name|syncirql
parameter_list|,
name|uint8_t
name|imode
parameter_list|,
name|uint8_t
name|shared
parameter_list|,
name|uint32_t
name|affinity
parameter_list|,
name|uint8_t
name|savefloat
parameter_list|)
block|{
name|uint8_t
name|curirql
decl_stmt|;
operator|*
name|iobj
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
sizeof|sizeof
argument_list|(
name|kinterrupt
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|iobj
operator|==
name|NULL
condition|)
return|return
operator|(
name|STATUS_INSUFFICIENT_RESOURCES
operator|)
return|;
operator|(
operator|*
name|iobj
operator|)
operator|->
name|ki_svcfunc
operator|=
name|svcfunc
expr_stmt|;
operator|(
operator|*
name|iobj
operator|)
operator|->
name|ki_svcctx
operator|=
name|svcctx
expr_stmt|;
if|if
condition|(
name|lock
operator|==
name|NULL
condition|)
block|{
name|KeInitializeSpinLock
argument_list|(
operator|&
operator|(
operator|*
name|iobj
operator|)
operator|->
name|ki_lock_priv
argument_list|)
expr_stmt|;
operator|(
operator|*
name|iobj
operator|)
operator|->
name|ki_lock
operator|=
operator|&
operator|(
operator|*
name|iobj
operator|)
operator|->
name|ki_lock_priv
expr_stmt|;
block|}
else|else
operator|(
operator|*
name|iobj
operator|)
operator|->
name|ki_lock
operator|=
name|lock
expr_stmt|;
name|KeAcquireSpinLock
argument_list|(
operator|&
name|ntoskrnl_intlock
argument_list|,
operator|&
name|curirql
argument_list|)
expr_stmt|;
name|InsertHeadList
argument_list|(
operator|(
operator|&
name|ntoskrnl_intlist
operator|)
argument_list|,
operator|(
operator|&
operator|(
operator|*
name|iobj
operator|)
operator|->
name|ki_list
operator|)
argument_list|)
expr_stmt|;
name|KeReleaseSpinLock
argument_list|(
operator|&
name|ntoskrnl_intlock
argument_list|,
name|curirql
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|IoDisconnectInterrupt
parameter_list|(
name|iobj
parameter_list|)
name|kinterrupt
modifier|*
name|iobj
decl_stmt|;
block|{
name|uint8_t
name|irql
decl_stmt|;
if|if
condition|(
name|iobj
operator|==
name|NULL
condition|)
return|return;
name|KeAcquireSpinLock
argument_list|(
operator|&
name|ntoskrnl_intlock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
name|RemoveEntryList
argument_list|(
operator|(
operator|&
name|iobj
operator|->
name|ki_list
operator|)
argument_list|)
expr_stmt|;
name|KeReleaseSpinLock
argument_list|(
operator|&
name|ntoskrnl_intlock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
name|ExFreePool
argument_list|(
name|iobj
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|device_object
modifier|*
name|IoAttachDeviceToDeviceStack
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
name|device_object
modifier|*
name|src
decl_stmt|;
name|device_object
modifier|*
name|dst
decl_stmt|;
block|{
name|device_object
modifier|*
name|attached
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|attached
operator|=
name|IoGetAttachedDevice
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|attached
operator|->
name|do_attacheddev
operator|=
name|src
expr_stmt|;
name|src
operator|->
name|do_attacheddev
operator|=
name|NULL
expr_stmt|;
name|src
operator|->
name|do_stacksize
operator|=
name|attached
operator|->
name|do_stacksize
operator|+
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|attached
operator|)
return|;
block|}
end_function

begin_function
name|void
name|IoDetachDevice
parameter_list|(
name|topdev
parameter_list|)
name|device_object
modifier|*
name|topdev
decl_stmt|;
block|{
name|device_object
modifier|*
name|tail
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
comment|/* First, break the chain. */
name|tail
operator|=
name|topdev
operator|->
name|do_attacheddev
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return;
block|}
name|topdev
operator|->
name|do_attacheddev
operator|=
name|tail
operator|->
name|do_attacheddev
expr_stmt|;
name|topdev
operator|->
name|do_refcnt
operator|--
expr_stmt|;
comment|/* Now reduce the stacksize count for the takm_il objects. */
name|tail
operator|=
name|topdev
operator|->
name|do_attacheddev
expr_stmt|;
while|while
condition|(
name|tail
operator|!=
name|NULL
condition|)
block|{
name|tail
operator|->
name|do_stacksize
operator|--
expr_stmt|;
name|tail
operator|=
name|tail
operator|->
name|do_attacheddev
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * For the most part, an object is considered signalled if  * dh_sigstate == TRUE. The exception is for mutant objects  * (mutexes), where the logic works like this:  *  * - If the thread already owns the object and sigstate is  *   less than or equal to 0, then the object is considered  *   signalled (recursive acquisition).  * - If dh_sigstate == 1, the object is also considered  *   signalled.  */
end_comment

begin_function
specifier|static
name|int
name|ntoskrnl_is_signalled
parameter_list|(
name|obj
parameter_list|,
name|td
parameter_list|)
name|nt_dispatch_header
modifier|*
name|obj
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|kmutant
modifier|*
name|km
decl_stmt|;
if|if
condition|(
name|obj
operator|->
name|dh_type
operator|==
name|DISP_TYPE_MUTANT
condition|)
block|{
name|km
operator|=
operator|(
name|kmutant
operator|*
operator|)
name|obj
expr_stmt|;
if|if
condition|(
operator|(
name|obj
operator|->
name|dh_sigstate
operator|<=
literal|0
operator|&&
name|km
operator|->
name|km_ownerthread
operator|==
name|td
operator|)
operator|||
name|obj
operator|->
name|dh_sigstate
operator|==
literal|1
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|obj
operator|->
name|dh_sigstate
operator|>
literal|0
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ntoskrnl_satisfy_wait
parameter_list|(
name|obj
parameter_list|,
name|td
parameter_list|)
name|nt_dispatch_header
modifier|*
name|obj
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|kmutant
modifier|*
name|km
decl_stmt|;
switch|switch
condition|(
name|obj
operator|->
name|dh_type
condition|)
block|{
case|case
name|DISP_TYPE_MUTANT
case|:
name|km
operator|=
operator|(
expr|struct
name|kmutant
operator|*
operator|)
name|obj
expr_stmt|;
name|obj
operator|->
name|dh_sigstate
operator|--
expr_stmt|;
comment|/* 		 * If sigstate reaches 0, the mutex is now 		 * non-signalled (the new thread owns it). 		 */
if|if
condition|(
name|obj
operator|->
name|dh_sigstate
operator|==
literal|0
condition|)
block|{
name|km
operator|->
name|km_ownerthread
operator|=
name|td
expr_stmt|;
if|if
condition|(
name|km
operator|->
name|km_abandoned
operator|==
name|TRUE
condition|)
name|km
operator|->
name|km_abandoned
operator|=
name|FALSE
expr_stmt|;
block|}
break|break;
comment|/* Synchronization objects get reset to unsignalled. */
case|case
name|DISP_TYPE_SYNCHRONIZATION_EVENT
case|:
case|case
name|DISP_TYPE_SYNCHRONIZATION_TIMER
case|:
name|obj
operator|->
name|dh_sigstate
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DISP_TYPE_SEMAPHORE
case|:
name|obj
operator|->
name|dh_sigstate
operator|--
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ntoskrnl_satisfy_multiple_waits
parameter_list|(
name|wb
parameter_list|)
name|wait_block
modifier|*
name|wb
decl_stmt|;
block|{
name|wait_block
modifier|*
name|cur
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|cur
operator|=
name|wb
expr_stmt|;
name|td
operator|=
name|wb
operator|->
name|wb_kthread
expr_stmt|;
do|do
block|{
name|ntoskrnl_satisfy_wait
argument_list|(
name|wb
operator|->
name|wb_object
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|cur
operator|->
name|wb_awakened
operator|=
name|TRUE
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|wb_next
expr_stmt|;
block|}
do|while
condition|(
name|cur
operator|!=
name|wb
condition|)
do|;
return|return;
block|}
end_function

begin_comment
comment|/* Always called with dispatcher lock held. */
end_comment

begin_function
specifier|static
name|void
name|ntoskrnl_waittest
parameter_list|(
name|obj
parameter_list|,
name|increment
parameter_list|)
name|nt_dispatch_header
modifier|*
name|obj
decl_stmt|;
name|uint32_t
name|increment
decl_stmt|;
block|{
name|wait_block
modifier|*
name|w
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|list_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|wb_ext
modifier|*
name|we
decl_stmt|;
name|int
name|satisfied
decl_stmt|;
comment|/* 	 * Once an object has been signalled, we walk its list of 	 * wait blocks. If a wait block can be awakened, then satisfy 	 * waits as necessary and wake the thread. 	 * 	 * The rules work like this: 	 * 	 * If a wait block is marked as WAITTYPE_ANY, then 	 * we can satisfy the wait conditions on the current 	 * object and wake the thread right away. Satisfying 	 * the wait also has the effect of breaking us out 	 * of the search loop. 	 * 	 * If the object is marked as WAITTYLE_ALL, then the 	 * wait block will be part of a circularly linked 	 * list of wait blocks belonging to a waiting thread 	 * that's sleeping in KeWaitForMultipleObjects(). In 	 * order to wake the thread, all the objects in the 	 * wait list must be in the signalled state. If they 	 * are, we then satisfy all of them and wake the 	 * thread. 	 * 	 */
name|e
operator|=
name|obj
operator|->
name|dh_waitlisthead
operator|.
name|nle_flink
expr_stmt|;
while|while
condition|(
name|e
operator|!=
operator|&
name|obj
operator|->
name|dh_waitlisthead
operator|&&
name|obj
operator|->
name|dh_sigstate
operator|>
literal|0
condition|)
block|{
name|w
operator|=
name|CONTAINING_RECORD
argument_list|(
name|e
argument_list|,
name|wait_block
argument_list|,
name|wb_waitlist
argument_list|)
expr_stmt|;
name|we
operator|=
name|w
operator|->
name|wb_ext
expr_stmt|;
name|td
operator|=
name|we
operator|->
name|we_td
expr_stmt|;
name|satisfied
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|wb_waittype
operator|==
name|WAITTYPE_ANY
condition|)
block|{
comment|/* 			 * Thread can be awakened if 			 * any wait is satisfied. 			 */
name|ntoskrnl_satisfy_wait
argument_list|(
name|obj
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|satisfied
operator|=
name|TRUE
expr_stmt|;
name|w
operator|->
name|wb_awakened
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Thread can only be woken up 			 * if all waits are satisfied. 			 * If the thread is waiting on multiple 			 * objects, they should all be linked 			 * through the wb_next pointers in the 			 * wait blocks. 			 */
name|satisfied
operator|=
name|TRUE
expr_stmt|;
name|next
operator|=
name|w
operator|->
name|wb_next
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|w
condition|)
block|{
if|if
condition|(
name|ntoskrnl_is_signalled
argument_list|(
name|obj
argument_list|,
name|td
argument_list|)
operator|==
name|FALSE
condition|)
block|{
name|satisfied
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
name|next
operator|=
name|next
operator|->
name|wb_next
expr_stmt|;
block|}
name|ntoskrnl_satisfy_multiple_waits
argument_list|(
name|w
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|satisfied
operator|==
name|TRUE
condition|)
name|cv_broadcastpri
argument_list|(
operator|&
name|we
operator|->
name|we_cv
argument_list|,
operator|(
name|w
operator|->
name|wb_oldpri
operator|-
operator|(
name|increment
operator|*
literal|4
operator|)
operator|)
operator|>
name|PRI_MIN_KERN
condition|?
name|w
operator|->
name|wb_oldpri
operator|-
operator|(
name|increment
operator|*
literal|4
operator|)
else|:
name|PRI_MIN_KERN
argument_list|)
expr_stmt|;
name|e
operator|=
name|e
operator|->
name|nle_flink
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Return the number of 100 nanosecond intervals since  * January 1, 1601. (?!?!)  */
end_comment

begin_function
name|void
name|ntoskrnl_time
parameter_list|(
name|tval
parameter_list|)
name|uint64_t
modifier|*
name|tval
decl_stmt|;
block|{
name|struct
name|timespec
name|ts
decl_stmt|;
name|nanotime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
operator|*
name|tval
operator|=
operator|(
name|uint64_t
operator|)
name|ts
operator|.
name|tv_nsec
operator|/
literal|100
operator|+
operator|(
name|uint64_t
operator|)
name|ts
operator|.
name|tv_sec
operator|*
literal|10000000
operator|+
literal|11644473600
operator|*
literal|10000000
expr_stmt|;
comment|/* 100ns ticks from 1601 to 1970 */
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|KeQuerySystemTime
parameter_list|(
name|current_time
parameter_list|)
name|uint64_t
modifier|*
name|current_time
decl_stmt|;
block|{
name|ntoskrnl_time
argument_list|(
name|current_time
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|KeTickCount
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|getmicrouptime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
return|return
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * KeWaitForSingleObject() is a tricky beast, because it can be used  * with several different object types: semaphores, timers, events,  * mutexes and threads. Semaphores don't appear very often, but the  * other object types are quite common. KeWaitForSingleObject() is  * what's normally used to acquire a mutex, and it can be used to  * wait for a thread termination.  *  * The Windows NDIS API is implemented in terms of Windows kernel  * primitives, and some of the object manipulation is duplicated in  * NDIS. For example, NDIS has timers and events, which are actually  * Windows kevents and ktimers. Now, you're supposed to only use the  * NDIS variants of these objects within the confines of the NDIS API,  * but there are some naughty developers out there who will use  * KeWaitForSingleObject() on NDIS timer and event objects, so we  * have to support that as well. Conseqently, our NDIS timer and event  * code has to be closely tied into our ntoskrnl timer and event code,  * just as it is in Windows.  *  * KeWaitForSingleObject() may do different things for different kinds  * of objects:  *  * - For events, we check if the event has been signalled. If the  *   event is already in the signalled state, we just return immediately,  *   otherwise we wait for it to be set to the signalled state by someone  *   else calling KeSetEvent(). Events can be either synchronization or  *   notification events.  *  * - For timers, if the timer has already fired and the timer is in  *   the signalled state, we just return, otherwise we wait on the  *   timer. Unlike an event, timers get signalled automatically when  *   they expire rather than someone having to trip them manually.  *   Timers initialized with KeInitializeTimer() are always notification  *   events: KeInitializeTimerEx() lets you initialize a timer as  *   either a notification or synchronization event.  *  * - For mutexes, we try to acquire the mutex and if we can't, we wait  *   on the mutex until it's available and then grab it. When a mutex is  *   released, it enters the signalled state, which wakes up one of the  *   threads waiting to acquire it. Mutexes are always synchronization  *   events.  *  * - For threads, the only thing we do is wait until the thread object  *   enters a signalled state, which occurs when the thread terminates.  *   Threads are always notification events.  *  * A notification event wakes up all threads waiting on an object. A  * synchronization event wakes up just one. Also, a synchronization event  * is auto-clearing, which means we automatically set the event back to  * the non-signalled state once the wakeup is done.  */
end_comment

begin_function
name|uint32_t
name|KeWaitForSingleObject
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint32_t
name|reason
parameter_list|,
name|uint32_t
name|mode
parameter_list|,
name|uint8_t
name|alertable
parameter_list|,
name|int64_t
modifier|*
name|duetime
parameter_list|)
block|{
name|wait_block
name|w
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint64_t
name|curtime
decl_stmt|;
name|wb_ext
name|we
decl_stmt|;
name|nt_dispatch_header
modifier|*
name|obj
decl_stmt|;
name|obj
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
return|return
operator|(
name|STATUS_INVALID_PARAMETER
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|we
operator|.
name|we_cv
argument_list|,
literal|"KeWFS"
argument_list|)
expr_stmt|;
name|we
operator|.
name|we_td
operator|=
name|td
expr_stmt|;
comment|/* 	 * Check to see if this object is already signalled, 	 * and just return without waiting if it is. 	 */
if|if
condition|(
name|ntoskrnl_is_signalled
argument_list|(
name|obj
argument_list|,
name|td
argument_list|)
operator|==
name|TRUE
condition|)
block|{
comment|/* Sanity check the signal state value. */
if|if
condition|(
name|obj
operator|->
name|dh_sigstate
operator|!=
name|INT32_MIN
condition|)
block|{
name|ntoskrnl_satisfy_wait
argument_list|(
name|obj
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
else|else
block|{
comment|/* 			 * There's a limit to how many times we can 			 * recursively acquire a mutant. If we hit 			 * the limit, something is very wrong. 			 */
if|if
condition|(
name|obj
operator|->
name|dh_type
operator|==
name|DISP_TYPE_MUTANT
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"mutant limit exceeded"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|w
argument_list|,
sizeof|sizeof
argument_list|(
name|wait_block
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|.
name|wb_object
operator|=
name|obj
expr_stmt|;
name|w
operator|.
name|wb_ext
operator|=
operator|&
name|we
expr_stmt|;
name|w
operator|.
name|wb_waittype
operator|=
name|WAITTYPE_ANY
expr_stmt|;
name|w
operator|.
name|wb_next
operator|=
operator|&
name|w
expr_stmt|;
name|w
operator|.
name|wb_waitkey
operator|=
literal|0
expr_stmt|;
name|w
operator|.
name|wb_awakened
operator|=
name|FALSE
expr_stmt|;
name|w
operator|.
name|wb_oldpri
operator|=
name|td
operator|->
name|td_priority
expr_stmt|;
name|InsertTailList
argument_list|(
operator|(
operator|&
name|obj
operator|->
name|dh_waitlisthead
operator|)
argument_list|,
operator|(
operator|&
name|w
operator|.
name|wb_waitlist
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * The timeout value is specified in 100 nanosecond units 	 * and can be a positive or negative number. If it's positive, 	 * then the duetime is absolute, and we need to convert it 	 * to an absolute offset relative to now in order to use it. 	 * If it's negative, then the duetime is relative and we 	 * just have to convert the units. 	 */
if|if
condition|(
name|duetime
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|duetime
operator|<
literal|0
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|=
operator|-
operator|(
operator|*
name|duetime
operator|)
operator|/
literal|10000000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
operator|-
operator|(
operator|*
name|duetime
operator|)
operator|/
literal|10
operator|)
operator|-
operator|(
name|tv
operator|.
name|tv_sec
operator|*
literal|1000000
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ntoskrnl_time
argument_list|(
operator|&
name|curtime
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|duetime
operator|<
name|curtime
condition|)
name|tv
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|tv
operator|.
name|tv_sec
operator|=
operator|(
operator|(
operator|*
name|duetime
operator|)
operator|-
name|curtime
operator|)
operator|/
literal|10000000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
operator|(
operator|*
name|duetime
operator|)
operator|-
name|curtime
operator|)
operator|/
literal|10
operator|-
operator|(
name|tv
operator|.
name|tv_sec
operator|*
literal|1000000
operator|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|duetime
operator|==
name|NULL
condition|)
name|cv_wait
argument_list|(
operator|&
name|we
operator|.
name|we_cv
argument_list|,
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|cv_timedwait
argument_list|(
operator|&
name|we
operator|.
name|we_cv
argument_list|,
operator|&
name|ntoskrnl_dispatchlock
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|)
expr_stmt|;
name|RemoveEntryList
argument_list|(
operator|&
name|w
operator|.
name|wb_waitlist
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|we
operator|.
name|we_cv
argument_list|)
expr_stmt|;
comment|/* We timed out. Leave the object alone and return status. */
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_TIMEOUT
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
comment|/* 	return(KeWaitForMultipleObjects(1,&obj, WAITTYPE_ALL, reason, 	    mode, alertable, duetime,&w)); */
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|KeWaitForMultipleObjects
parameter_list|(
name|uint32_t
name|cnt
parameter_list|,
name|nt_dispatch_header
modifier|*
name|obj
index|[]
parameter_list|,
name|uint32_t
name|wtype
parameter_list|,
name|uint32_t
name|reason
parameter_list|,
name|uint32_t
name|mode
parameter_list|,
name|uint8_t
name|alertable
parameter_list|,
name|int64_t
modifier|*
name|duetime
parameter_list|,
name|wait_block
modifier|*
name|wb_array
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|wait_block
modifier|*
name|whead
decl_stmt|,
modifier|*
name|w
decl_stmt|;
name|wait_block
name|_wb_array
index|[
name|MAX_WAIT_OBJECTS
index|]
decl_stmt|;
name|nt_dispatch_header
modifier|*
name|cur
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|i
decl_stmt|,
name|wcnt
init|=
literal|0
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|uint64_t
name|curtime
decl_stmt|;
name|struct
name|timespec
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|uint32_t
name|status
init|=
name|STATUS_SUCCESS
decl_stmt|;
name|wb_ext
name|we
decl_stmt|;
if|if
condition|(
name|cnt
operator|>
name|MAX_WAIT_OBJECTS
condition|)
return|return
operator|(
name|STATUS_INVALID_PARAMETER
operator|)
return|;
if|if
condition|(
name|cnt
operator|>
name|THREAD_WAIT_OBJECTS
operator|&&
name|wb_array
operator|==
name|NULL
condition|)
return|return
operator|(
name|STATUS_INVALID_PARAMETER
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|we
operator|.
name|we_cv
argument_list|,
literal|"KeWFM"
argument_list|)
expr_stmt|;
name|we
operator|.
name|we_td
operator|=
name|td
expr_stmt|;
if|if
condition|(
name|wb_array
operator|==
name|NULL
condition|)
name|whead
operator|=
name|_wb_array
expr_stmt|;
else|else
name|whead
operator|=
name|wb_array
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|whead
argument_list|,
sizeof|sizeof
argument_list|(
name|wait_block
argument_list|)
operator|*
name|cnt
argument_list|)
expr_stmt|;
comment|/* First pass: see if we can satisfy any waits immediately. */
name|wcnt
operator|=
literal|0
expr_stmt|;
name|w
operator|=
name|whead
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|InsertTailList
argument_list|(
operator|(
operator|&
name|obj
index|[
name|i
index|]
operator|->
name|dh_waitlisthead
operator|)
argument_list|,
operator|(
operator|&
name|w
operator|->
name|wb_waitlist
operator|)
argument_list|)
expr_stmt|;
name|w
operator|->
name|wb_ext
operator|=
operator|&
name|we
expr_stmt|;
name|w
operator|->
name|wb_object
operator|=
name|obj
index|[
name|i
index|]
expr_stmt|;
name|w
operator|->
name|wb_waittype
operator|=
name|wtype
expr_stmt|;
name|w
operator|->
name|wb_waitkey
operator|=
name|i
expr_stmt|;
name|w
operator|->
name|wb_awakened
operator|=
name|FALSE
expr_stmt|;
name|w
operator|->
name|wb_oldpri
operator|=
name|td
operator|->
name|td_priority
expr_stmt|;
name|w
operator|->
name|wb_next
operator|=
name|w
operator|+
literal|1
expr_stmt|;
name|w
operator|++
expr_stmt|;
name|wcnt
operator|++
expr_stmt|;
if|if
condition|(
name|ntoskrnl_is_signalled
argument_list|(
name|obj
index|[
name|i
index|]
argument_list|,
name|td
argument_list|)
condition|)
block|{
comment|/* 			 * There's a limit to how many times 			 * we can recursively acquire a mutant. 			 * If we hit the limit, something 			 * is very wrong. 			 */
if|if
condition|(
name|obj
index|[
name|i
index|]
operator|->
name|dh_sigstate
operator|==
name|INT32_MIN
operator|&&
name|obj
index|[
name|i
index|]
operator|->
name|dh_type
operator|==
name|DISP_TYPE_MUTANT
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"mutant limit exceeded"
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * If this is a WAITTYPE_ANY wait, then 			 * satisfy the waited object and exit 			 * right now. 			 */
if|if
condition|(
name|wtype
operator|==
name|WAITTYPE_ANY
condition|)
block|{
name|ntoskrnl_satisfy_wait
argument_list|(
name|obj
index|[
name|i
index|]
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|status
operator|=
name|STATUS_WAIT_0
operator|+
name|i
expr_stmt|;
goto|goto
name|wait_done
goto|;
block|}
else|else
block|{
name|w
operator|--
expr_stmt|;
name|wcnt
operator|--
expr_stmt|;
name|w
operator|->
name|wb_object
operator|=
name|NULL
expr_stmt|;
name|RemoveEntryList
argument_list|(
operator|&
name|w
operator|->
name|wb_waitlist
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * If this is a WAITTYPE_ALL wait and all objects are 	 * already signalled, satisfy the waits and exit now. 	 */
if|if
condition|(
name|wtype
operator|==
name|WAITTYPE_ALL
operator|&&
name|wcnt
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
name|ntoskrnl_satisfy_wait
argument_list|(
name|obj
index|[
name|i
index|]
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|status
operator|=
name|STATUS_SUCCESS
expr_stmt|;
goto|goto
name|wait_done
goto|;
block|}
comment|/* 	 * Create a circular waitblock list. The waitcount 	 * must always be non-zero when we get here. 	 */
operator|(
name|w
operator|-
literal|1
operator|)
operator|->
name|wb_next
operator|=
name|whead
expr_stmt|;
comment|/* Wait on any objects that aren't yet signalled. */
comment|/* Calculate timeout, if any. */
if|if
condition|(
name|duetime
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|duetime
operator|<
literal|0
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|=
operator|-
operator|(
operator|*
name|duetime
operator|)
operator|/
literal|10000000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
operator|-
operator|(
operator|*
name|duetime
operator|)
operator|/
literal|10
operator|)
operator|-
operator|(
name|tv
operator|.
name|tv_sec
operator|*
literal|1000000
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ntoskrnl_time
argument_list|(
operator|&
name|curtime
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|duetime
operator|<
name|curtime
condition|)
name|tv
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|tv
operator|.
name|tv_sec
operator|=
operator|(
operator|(
operator|*
name|duetime
operator|)
operator|-
name|curtime
operator|)
operator|/
literal|10000000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
operator|(
operator|*
name|duetime
operator|)
operator|-
name|curtime
operator|)
operator|/
literal|10
operator|-
operator|(
name|tv
operator|.
name|tv_sec
operator|*
literal|1000000
operator|)
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
name|wcnt
condition|)
block|{
name|nanotime
argument_list|(
operator|&
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|duetime
operator|==
name|NULL
condition|)
name|cv_wait
argument_list|(
operator|&
name|we
operator|.
name|we_cv
argument_list|,
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|cv_timedwait
argument_list|(
operator|&
name|we
operator|.
name|we_cv
argument_list|,
operator|&
name|ntoskrnl_dispatchlock
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Wait with timeout expired. */
if|if
condition|(
name|error
condition|)
block|{
name|status
operator|=
name|STATUS_TIMEOUT
expr_stmt|;
goto|goto
name|wait_done
goto|;
block|}
name|nanotime
argument_list|(
operator|&
name|t2
argument_list|)
expr_stmt|;
comment|/* See what's been signalled. */
name|w
operator|=
name|whead
expr_stmt|;
do|do
block|{
name|cur
operator|=
name|w
operator|->
name|wb_object
expr_stmt|;
if|if
condition|(
name|ntoskrnl_is_signalled
argument_list|(
name|cur
argument_list|,
name|td
argument_list|)
operator|==
name|TRUE
operator|||
name|w
operator|->
name|wb_awakened
operator|==
name|TRUE
condition|)
block|{
comment|/* Sanity check the signal state value. */
if|if
condition|(
name|cur
operator|->
name|dh_sigstate
operator|==
name|INT32_MIN
operator|&&
name|cur
operator|->
name|dh_type
operator|==
name|DISP_TYPE_MUTANT
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"mutant limit exceeded"
argument_list|)
expr_stmt|;
block|}
name|wcnt
operator|--
expr_stmt|;
if|if
condition|(
name|wtype
operator|==
name|WAITTYPE_ANY
condition|)
block|{
name|status
operator|=
name|w
operator|->
name|wb_waitkey
operator|&
name|STATUS_WAIT_0
expr_stmt|;
goto|goto
name|wait_done
goto|;
block|}
block|}
name|w
operator|=
name|w
operator|->
name|wb_next
expr_stmt|;
block|}
do|while
condition|(
name|w
operator|!=
name|whead
condition|)
do|;
comment|/* 		 * If all objects have been signalled, or if this 		 * is a WAITTYPE_ANY wait and we were woke up by 		 * someone, we can bail. 		 */
if|if
condition|(
name|wcnt
operator|==
literal|0
condition|)
block|{
name|status
operator|=
name|STATUS_SUCCESS
expr_stmt|;
goto|goto
name|wait_done
goto|;
block|}
comment|/* 		 * If this is WAITTYPE_ALL wait, and there's still 		 * objects that haven't been signalled, deduct the 		 * time that's elapsed so far from the timeout and 		 * wait again (or continue waiting indefinitely if 		 * there's no timeout). 		 */
if|if
condition|(
name|duetime
operator|!=
name|NULL
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|-=
operator|(
name|t2
operator|.
name|tv_sec
operator|-
name|t1
operator|.
name|tv_sec
operator|)
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|-=
operator|(
name|t2
operator|.
name|tv_nsec
operator|-
name|t1
operator|.
name|tv_nsec
operator|)
operator|/
literal|1000
expr_stmt|;
block|}
block|}
name|wait_done
label|:
name|cv_destroy
argument_list|(
operator|&
name|we
operator|.
name|we_cv
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|whead
index|[
name|i
index|]
operator|.
name|wb_object
operator|!=
name|NULL
condition|)
name|RemoveEntryList
argument_list|(
operator|&
name|whead
index|[
name|i
index|]
operator|.
name|wb_waitlist
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|WRITE_REGISTER_USHORT
parameter_list|(
name|uint16_t
modifier|*
name|reg
parameter_list|,
name|uint16_t
name|val
parameter_list|)
block|{
name|bus_space_write_2
argument_list|(
name|NDIS_BUS_SPACE_MEM
argument_list|,
literal|0x0
argument_list|,
operator|(
name|bus_size_t
operator|)
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|READ_REGISTER_USHORT
parameter_list|(
name|reg
parameter_list|)
name|uint16_t
modifier|*
name|reg
decl_stmt|;
block|{
return|return
operator|(
name|bus_space_read_2
argument_list|(
name|NDIS_BUS_SPACE_MEM
argument_list|,
literal|0x0
argument_list|,
operator|(
name|bus_size_t
operator|)
name|reg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|WRITE_REGISTER_ULONG
parameter_list|(
name|reg
parameter_list|,
name|val
parameter_list|)
name|uint32_t
modifier|*
name|reg
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
block|{
name|bus_space_write_4
argument_list|(
name|NDIS_BUS_SPACE_MEM
argument_list|,
literal|0x0
argument_list|,
operator|(
name|bus_size_t
operator|)
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|READ_REGISTER_ULONG
parameter_list|(
name|reg
parameter_list|)
name|uint32_t
modifier|*
name|reg
decl_stmt|;
block|{
return|return
operator|(
name|bus_space_read_4
argument_list|(
name|NDIS_BUS_SPACE_MEM
argument_list|,
literal|0x0
argument_list|,
operator|(
name|bus_size_t
operator|)
name|reg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|READ_REGISTER_UCHAR
parameter_list|(
name|uint8_t
modifier|*
name|reg
parameter_list|)
block|{
return|return
operator|(
name|bus_space_read_1
argument_list|(
name|NDIS_BUS_SPACE_MEM
argument_list|,
literal|0x0
argument_list|,
operator|(
name|bus_size_t
operator|)
name|reg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|WRITE_REGISTER_UCHAR
parameter_list|(
name|uint8_t
modifier|*
name|reg
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|bus_space_write_1
argument_list|(
name|NDIS_BUS_SPACE_MEM
argument_list|,
literal|0x0
argument_list|,
operator|(
name|bus_size_t
operator|)
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|_allmul
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|int64_t
name|a
decl_stmt|;
name|int64_t
name|b
decl_stmt|;
block|{
return|return
operator|(
name|a
operator|*
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|_alldiv
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|int64_t
name|a
decl_stmt|;
name|int64_t
name|b
decl_stmt|;
block|{
return|return
operator|(
name|a
operator|/
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|_allrem
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|int64_t
name|a
decl_stmt|;
name|int64_t
name|b
decl_stmt|;
block|{
return|return
operator|(
name|a
operator|%
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|_aullmul
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|uint64_t
name|a
decl_stmt|;
name|uint64_t
name|b
decl_stmt|;
block|{
return|return
operator|(
name|a
operator|*
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|_aulldiv
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|uint64_t
name|a
decl_stmt|;
name|uint64_t
name|b
decl_stmt|;
block|{
return|return
operator|(
name|a
operator|/
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|_aullrem
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|uint64_t
name|a
decl_stmt|;
name|uint64_t
name|b
decl_stmt|;
block|{
return|return
operator|(
name|a
operator|%
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|_allshl
parameter_list|(
name|int64_t
name|a
parameter_list|,
name|uint8_t
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|<<
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|_aullshl
parameter_list|(
name|uint64_t
name|a
parameter_list|,
name|uint8_t
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|<<
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|_allshr
parameter_list|(
name|int64_t
name|a
parameter_list|,
name|uint8_t
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|>>
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|_aullshr
parameter_list|(
name|uint64_t
name|a
parameter_list|,
name|uint8_t
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|>>
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|slist_entry
modifier|*
name|ntoskrnl_pushsl
parameter_list|(
name|head
parameter_list|,
name|entry
parameter_list|)
name|slist_header
modifier|*
name|head
decl_stmt|;
name|slist_entry
modifier|*
name|entry
decl_stmt|;
block|{
name|slist_entry
modifier|*
name|oldhead
decl_stmt|;
name|oldhead
operator|=
name|head
operator|->
name|slh_list
operator|.
name|slh_next
expr_stmt|;
name|entry
operator|->
name|sl_next
operator|=
name|head
operator|->
name|slh_list
operator|.
name|slh_next
expr_stmt|;
name|head
operator|->
name|slh_list
operator|.
name|slh_next
operator|=
name|entry
expr_stmt|;
name|head
operator|->
name|slh_list
operator|.
name|slh_depth
operator|++
expr_stmt|;
name|head
operator|->
name|slh_list
operator|.
name|slh_seq
operator|++
expr_stmt|;
return|return
operator|(
name|oldhead
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|slist_entry
modifier|*
name|ntoskrnl_popsl
parameter_list|(
name|head
parameter_list|)
name|slist_header
modifier|*
name|head
decl_stmt|;
block|{
name|slist_entry
modifier|*
name|first
decl_stmt|;
name|first
operator|=
name|head
operator|->
name|slh_list
operator|.
name|slh_next
expr_stmt|;
if|if
condition|(
name|first
operator|!=
name|NULL
condition|)
block|{
name|head
operator|->
name|slh_list
operator|.
name|slh_next
operator|=
name|first
operator|->
name|sl_next
expr_stmt|;
name|head
operator|->
name|slh_list
operator|.
name|slh_depth
operator|--
expr_stmt|;
name|head
operator|->
name|slh_list
operator|.
name|slh_seq
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|first
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We need this to make lookaside lists work for amd64.  * We pass a pointer to ExAllocatePoolWithTag() the lookaside  * list structure. For amd64 to work right, this has to be a  * pointer to the wrapped version of the routine, not the  * original. Letting the Windows driver invoke the original  * function directly will result in a convention calling  * mismatch and a pretty crash. On x86, this effectively  * becomes a no-op since ipt_func and ipt_wrap are the same.  */
end_comment

begin_function
specifier|static
name|funcptr
name|ntoskrnl_findwrap
parameter_list|(
name|func
parameter_list|)
name|funcptr
name|func
decl_stmt|;
block|{
name|image_patch_table
modifier|*
name|patch
decl_stmt|;
name|patch
operator|=
name|ntoskrnl_functbl
expr_stmt|;
while|while
condition|(
name|patch
operator|->
name|ipt_func
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|funcptr
operator|)
name|patch
operator|->
name|ipt_func
operator|==
name|func
condition|)
return|return
operator|(
operator|(
name|funcptr
operator|)
name|patch
operator|->
name|ipt_wrap
operator|)
return|;
name|patch
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ExInitializePagedLookasideList
parameter_list|(
name|paged_lookaside_list
modifier|*
name|lookaside
parameter_list|,
name|lookaside_alloc_func
modifier|*
name|allocfunc
parameter_list|,
name|lookaside_free_func
modifier|*
name|freefunc
parameter_list|,
name|uint32_t
name|flags
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint32_t
name|tag
parameter_list|,
name|uint16_t
name|depth
parameter_list|)
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lookaside
argument_list|,
sizeof|sizeof
argument_list|(
name|paged_lookaside_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
sizeof|sizeof
argument_list|(
name|slist_entry
argument_list|)
condition|)
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_size
operator|=
sizeof|sizeof
argument_list|(
name|slist_entry
argument_list|)
expr_stmt|;
else|else
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_size
operator|=
name|size
expr_stmt|;
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_tag
operator|=
name|tag
expr_stmt|;
if|if
condition|(
name|allocfunc
operator|==
name|NULL
condition|)
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_allocfunc
operator|=
name|ntoskrnl_findwrap
argument_list|(
operator|(
name|funcptr
operator|)
name|ExAllocatePoolWithTag
argument_list|)
expr_stmt|;
else|else
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_allocfunc
operator|=
name|allocfunc
expr_stmt|;
if|if
condition|(
name|freefunc
operator|==
name|NULL
condition|)
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_freefunc
operator|=
name|ntoskrnl_findwrap
argument_list|(
operator|(
name|funcptr
operator|)
name|ExFreePool
argument_list|)
expr_stmt|;
else|else
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_freefunc
operator|=
name|freefunc
expr_stmt|;
ifdef|#
directive|ifdef
name|__i386__
name|KeInitializeSpinLock
argument_list|(
operator|&
name|lookaside
operator|->
name|nll_obsoletelock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_type
operator|=
name|NonPagedPool
expr_stmt|;
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_depth
operator|=
name|depth
expr_stmt|;
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_maxdepth
operator|=
name|LOOKASIDE_DEPTH
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ExDeletePagedLookasideList
parameter_list|(
name|lookaside
parameter_list|)
name|paged_lookaside_list
modifier|*
name|lookaside
decl_stmt|;
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|void
function_decl|(
modifier|*
name|freefunc
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|freefunc
operator|=
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_freefunc
expr_stmt|;
while|while
condition|(
operator|(
name|buf
operator|=
name|ntoskrnl_popsl
argument_list|(
operator|&
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_listhead
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|MSCALL1
argument_list|(
name|freefunc
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ExInitializeNPagedLookasideList
parameter_list|(
name|npaged_lookaside_list
modifier|*
name|lookaside
parameter_list|,
name|lookaside_alloc_func
modifier|*
name|allocfunc
parameter_list|,
name|lookaside_free_func
modifier|*
name|freefunc
parameter_list|,
name|uint32_t
name|flags
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint32_t
name|tag
parameter_list|,
name|uint16_t
name|depth
parameter_list|)
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lookaside
argument_list|,
sizeof|sizeof
argument_list|(
name|npaged_lookaside_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
sizeof|sizeof
argument_list|(
name|slist_entry
argument_list|)
condition|)
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_size
operator|=
sizeof|sizeof
argument_list|(
name|slist_entry
argument_list|)
expr_stmt|;
else|else
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_size
operator|=
name|size
expr_stmt|;
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_tag
operator|=
name|tag
expr_stmt|;
if|if
condition|(
name|allocfunc
operator|==
name|NULL
condition|)
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_allocfunc
operator|=
name|ntoskrnl_findwrap
argument_list|(
operator|(
name|funcptr
operator|)
name|ExAllocatePoolWithTag
argument_list|)
expr_stmt|;
else|else
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_allocfunc
operator|=
name|allocfunc
expr_stmt|;
if|if
condition|(
name|freefunc
operator|==
name|NULL
condition|)
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_freefunc
operator|=
name|ntoskrnl_findwrap
argument_list|(
operator|(
name|funcptr
operator|)
name|ExFreePool
argument_list|)
expr_stmt|;
else|else
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_freefunc
operator|=
name|freefunc
expr_stmt|;
ifdef|#
directive|ifdef
name|__i386__
name|KeInitializeSpinLock
argument_list|(
operator|&
name|lookaside
operator|->
name|nll_obsoletelock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_type
operator|=
name|NonPagedPool
expr_stmt|;
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_depth
operator|=
name|depth
expr_stmt|;
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_maxdepth
operator|=
name|LOOKASIDE_DEPTH
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ExDeleteNPagedLookasideList
parameter_list|(
name|lookaside
parameter_list|)
name|npaged_lookaside_list
modifier|*
name|lookaside
decl_stmt|;
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|void
function_decl|(
modifier|*
name|freefunc
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|freefunc
operator|=
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_freefunc
expr_stmt|;
while|while
condition|(
operator|(
name|buf
operator|=
name|ntoskrnl_popsl
argument_list|(
operator|&
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_listhead
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|MSCALL1
argument_list|(
name|freefunc
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|slist_entry
modifier|*
name|InterlockedPushEntrySList
parameter_list|(
name|head
parameter_list|,
name|entry
parameter_list|)
name|slist_header
modifier|*
name|head
decl_stmt|;
name|slist_entry
modifier|*
name|entry
decl_stmt|;
block|{
name|slist_entry
modifier|*
name|oldhead
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|ntoskrnl_interlock
argument_list|)
expr_stmt|;
name|oldhead
operator|=
name|ntoskrnl_pushsl
argument_list|(
name|head
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|ntoskrnl_interlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|oldhead
operator|)
return|;
block|}
end_function

begin_function
name|slist_entry
modifier|*
name|InterlockedPopEntrySList
parameter_list|(
name|head
parameter_list|)
name|slist_header
modifier|*
name|head
decl_stmt|;
block|{
name|slist_entry
modifier|*
name|first
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|ntoskrnl_interlock
argument_list|)
expr_stmt|;
name|first
operator|=
name|ntoskrnl_popsl
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|ntoskrnl_interlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|first
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|slist_entry
modifier|*
name|ExInterlockedPushEntrySList
parameter_list|(
name|head
parameter_list|,
name|entry
parameter_list|,
name|lock
parameter_list|)
name|slist_header
modifier|*
name|head
decl_stmt|;
name|slist_entry
modifier|*
name|entry
decl_stmt|;
name|kspin_lock
modifier|*
name|lock
decl_stmt|;
block|{
return|return
operator|(
name|InterlockedPushEntrySList
argument_list|(
name|head
argument_list|,
name|entry
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|slist_entry
modifier|*
name|ExInterlockedPopEntrySList
parameter_list|(
name|head
parameter_list|,
name|lock
parameter_list|)
name|slist_header
modifier|*
name|head
decl_stmt|;
name|kspin_lock
modifier|*
name|lock
decl_stmt|;
block|{
return|return
operator|(
name|InterlockedPopEntrySList
argument_list|(
name|head
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint16_t
name|ExQueryDepthSList
parameter_list|(
name|head
parameter_list|)
name|slist_header
modifier|*
name|head
decl_stmt|;
block|{
name|uint16_t
name|depth
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|ntoskrnl_interlock
argument_list|)
expr_stmt|;
name|depth
operator|=
name|head
operator|->
name|slh_list
operator|.
name|slh_depth
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|ntoskrnl_interlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|depth
operator|)
return|;
block|}
end_function

begin_function
name|void
name|KeInitializeSpinLock
parameter_list|(
name|lock
parameter_list|)
name|kspin_lock
modifier|*
name|lock
decl_stmt|;
block|{
operator|*
name|lock
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_function
name|void
name|KefAcquireSpinLockAtDpcLevel
parameter_list|(
name|lock
parameter_list|)
name|kspin_lock
modifier|*
name|lock
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|NTOSKRNL_DEBUG_SPINLOCKS
name|int
name|i
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
while|while
condition|(
name|atomic_cmpset_acq_int
argument_list|(
operator|(
specifier|volatile
name|u_int
operator|*
operator|)
name|lock
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* sit and spin */
empty_stmt|;
ifdef|#
directive|ifdef
name|NTOSKRNL_DEBUG_SPINLOCKS
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|200000000
condition|)
name|panic
argument_list|(
literal|"DEADLOCK!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return;
block|}
end_function

begin_function
name|void
name|KefReleaseSpinLockFromDpcLevel
parameter_list|(
name|lock
parameter_list|)
name|kspin_lock
modifier|*
name|lock
decl_stmt|;
block|{
name|atomic_store_rel_int
argument_list|(
operator|(
specifier|volatile
name|u_int
operator|*
operator|)
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|uint8_t
name|KeAcquireSpinLockRaiseToDpc
parameter_list|(
name|kspin_lock
modifier|*
name|lock
parameter_list|)
block|{
name|uint8_t
name|oldirql
decl_stmt|;
if|if
condition|(
name|KeGetCurrentIrql
argument_list|()
operator|>
name|DISPATCH_LEVEL
condition|)
name|panic
argument_list|(
literal|"IRQL_NOT_LESS_THAN_OR_EQUAL"
argument_list|)
expr_stmt|;
name|KeRaiseIrql
argument_list|(
name|DISPATCH_LEVEL
argument_list|,
operator|&
name|oldirql
argument_list|)
expr_stmt|;
name|KeAcquireSpinLockAtDpcLevel
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|oldirql
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|KeAcquireSpinLockAtDpcLevel
parameter_list|(
name|kspin_lock
modifier|*
name|lock
parameter_list|)
block|{
while|while
condition|(
name|atomic_cmpset_acq_int
argument_list|(
operator|(
specifier|volatile
name|u_int
operator|*
operator|)
name|lock
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
comment|/* sit and spin */
empty_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|KeReleaseSpinLockFromDpcLevel
parameter_list|(
name|kspin_lock
modifier|*
name|lock
parameter_list|)
block|{
name|atomic_store_rel_int
argument_list|(
operator|(
specifier|volatile
name|u_int
operator|*
operator|)
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __i386__ */
end_comment

begin_function
name|uintptr_t
name|InterlockedExchange
parameter_list|(
name|dst
parameter_list|,
name|val
parameter_list|)
specifier|volatile
name|uint32_t
modifier|*
name|dst
decl_stmt|;
name|uintptr_t
name|val
decl_stmt|;
block|{
name|uintptr_t
name|r
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|ntoskrnl_interlock
argument_list|)
expr_stmt|;
name|r
operator|=
operator|*
name|dst
expr_stmt|;
operator|*
name|dst
operator|=
name|val
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|ntoskrnl_interlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|InterlockedIncrement
parameter_list|(
name|addend
parameter_list|)
specifier|volatile
name|uint32_t
modifier|*
name|addend
decl_stmt|;
block|{
name|atomic_add_long
argument_list|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|addend
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|addend
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|InterlockedDecrement
parameter_list|(
name|addend
parameter_list|)
specifier|volatile
name|uint32_t
modifier|*
name|addend
decl_stmt|;
block|{
name|atomic_subtract_long
argument_list|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|addend
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|addend
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ExInterlockedAddLargeStatistic
parameter_list|(
name|addend
parameter_list|,
name|inc
parameter_list|)
name|uint64_t
modifier|*
name|addend
decl_stmt|;
name|uint32_t
name|inc
decl_stmt|;
block|{
name|mtx_lock_spin
argument_list|(
operator|&
name|ntoskrnl_interlock
argument_list|)
expr_stmt|;
operator|*
name|addend
operator|+=
name|inc
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|ntoskrnl_interlock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
name|mdl
modifier|*
name|IoAllocateMdl
parameter_list|(
name|void
modifier|*
name|vaddr
parameter_list|,
name|uint32_t
name|len
parameter_list|,
name|uint8_t
name|secondarybuf
parameter_list|,
name|uint8_t
name|chargequota
parameter_list|,
name|irp
modifier|*
name|iopkt
parameter_list|)
block|{
name|mdl
modifier|*
name|m
decl_stmt|;
name|int
name|zone
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|MmSizeOfMdl
argument_list|(
name|vaddr
argument_list|,
name|len
argument_list|)
operator|>
name|MDL_ZONE_SIZE
condition|)
name|m
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
name|MmSizeOfMdl
argument_list|(
name|vaddr
argument_list|,
name|len
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|m
operator|=
name|uma_zalloc
argument_list|(
name|mdl_zone
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|zone
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|MmInitializeMdl
argument_list|(
name|m
argument_list|,
name|vaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * MmInitializMdl() clears the flags field, so we 	 * have to set this here. If the MDL came from the 	 * MDL UMA zone, tag it so we can release it to 	 * the right place later. 	 */
if|if
condition|(
name|zone
condition|)
name|m
operator|->
name|mdl_flags
operator|=
name|MDL_ZONE_ALLOCED
expr_stmt|;
if|if
condition|(
name|iopkt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|secondarybuf
operator|==
name|TRUE
condition|)
block|{
name|mdl
modifier|*
name|last
decl_stmt|;
name|last
operator|=
name|iopkt
operator|->
name|irp_mdl
expr_stmt|;
while|while
condition|(
name|last
operator|->
name|mdl_next
operator|!=
name|NULL
condition|)
name|last
operator|=
name|last
operator|->
name|mdl_next
expr_stmt|;
name|last
operator|->
name|mdl_next
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|iopkt
operator|->
name|irp_mdl
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"leaking an MDL in IoAllocateMdl()"
argument_list|)
expr_stmt|;
name|iopkt
operator|->
name|irp_mdl
operator|=
name|m
expr_stmt|;
block|}
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
name|void
name|IoFreeMdl
parameter_list|(
name|m
parameter_list|)
name|mdl
modifier|*
name|m
decl_stmt|;
block|{
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|m
operator|->
name|mdl_flags
operator|&
name|MDL_ZONE_ALLOCED
condition|)
name|uma_zfree
argument_list|(
name|mdl_zone
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|else
name|ExFreePool
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|MmAllocateContiguousMemory
parameter_list|(
name|size
parameter_list|,
name|highest
parameter_list|)
name|uint32_t
name|size
decl_stmt|;
name|uint64_t
name|highest
decl_stmt|;
block|{
name|void
modifier|*
name|addr
decl_stmt|;
name|size_t
name|pagelength
init|=
name|roundup
argument_list|(
name|size
argument_list|,
name|PAGE_SIZE
argument_list|)
decl_stmt|;
name|addr
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
name|pagelength
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|MmAllocateContiguousMemorySpecifyCache
parameter_list|(
name|size
parameter_list|,
name|lowest
parameter_list|,
name|highest
parameter_list|,
name|boundary
parameter_list|,
name|cachetype
parameter_list|)
name|uint32_t
name|size
decl_stmt|;
name|uint64_t
name|lowest
decl_stmt|;
name|uint64_t
name|highest
decl_stmt|;
name|uint64_t
name|boundary
decl_stmt|;
name|uint32_t
name|cachetype
decl_stmt|;
block|{
name|void
modifier|*
name|addr
decl_stmt|;
name|size_t
name|pagelength
init|=
name|roundup
argument_list|(
name|size
argument_list|,
name|PAGE_SIZE
argument_list|)
decl_stmt|;
name|addr
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
name|pagelength
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|MmFreeContiguousMemory
parameter_list|(
name|base
parameter_list|)
name|void
modifier|*
name|base
decl_stmt|;
block|{
name|ExFreePool
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|MmFreeContiguousMemorySpecifyCache
parameter_list|(
name|base
parameter_list|,
name|size
parameter_list|,
name|cachetype
parameter_list|)
name|void
modifier|*
name|base
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|uint32_t
name|cachetype
decl_stmt|;
block|{
name|ExFreePool
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|MmSizeOfMdl
parameter_list|(
name|vaddr
parameter_list|,
name|len
parameter_list|)
name|void
modifier|*
name|vaddr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|uint32_t
name|l
decl_stmt|;
name|l
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mdl
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|vm_offset_t
operator|*
argument_list|)
operator|*
name|SPAN_PAGES
argument_list|(
name|vaddr
argument_list|,
name|len
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The Microsoft documentation says this routine fills in the  * page array of an MDL with the _physical_ page addresses that  * comprise the buffer, but we don't really want to do that here.  * Instead, we just fill in the page array with the kernel virtual  * addresses of the buffers.  */
end_comment

begin_function
name|void
name|MmBuildMdlForNonPagedPool
parameter_list|(
name|m
parameter_list|)
name|mdl
modifier|*
name|m
decl_stmt|;
block|{
name|vm_offset_t
modifier|*
name|mdl_pages
decl_stmt|;
name|int
name|pagecnt
decl_stmt|,
name|i
decl_stmt|;
name|pagecnt
operator|=
name|SPAN_PAGES
argument_list|(
name|m
operator|->
name|mdl_byteoffset
argument_list|,
name|m
operator|->
name|mdl_bytecount
argument_list|)
expr_stmt|;
if|if
condition|(
name|pagecnt
operator|>
operator|(
name|m
operator|->
name|mdl_size
operator|-
sizeof|sizeof
argument_list|(
name|mdl
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|vm_offset_t
operator|*
argument_list|)
condition|)
name|panic
argument_list|(
literal|"not enough pages in MDL to describe buffer"
argument_list|)
expr_stmt|;
name|mdl_pages
operator|=
name|MmGetMdlPfnArray
argument_list|(
name|m
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pagecnt
condition|;
name|i
operator|++
control|)
operator|*
name|mdl_pages
operator|=
operator|(
name|vm_offset_t
operator|)
name|m
operator|->
name|mdl_startva
operator|+
operator|(
name|i
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
name|m
operator|->
name|mdl_flags
operator||=
name|MDL_SOURCE_IS_NONPAGED_POOL
expr_stmt|;
name|m
operator|->
name|mdl_mappedsystemva
operator|=
name|MmGetMdlVirtualAddress
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|MmMapLockedPages
parameter_list|(
name|mdl
modifier|*
name|buf
parameter_list|,
name|uint8_t
name|accessmode
parameter_list|)
block|{
name|buf
operator|->
name|mdl_flags
operator||=
name|MDL_MAPPED_TO_SYSTEM_VA
expr_stmt|;
return|return
operator|(
name|MmGetMdlVirtualAddress
argument_list|(
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|MmMapLockedPagesSpecifyCache
parameter_list|(
name|mdl
modifier|*
name|buf
parameter_list|,
name|uint8_t
name|accessmode
parameter_list|,
name|uint32_t
name|cachetype
parameter_list|,
name|void
modifier|*
name|vaddr
parameter_list|,
name|uint32_t
name|bugcheck
parameter_list|,
name|uint32_t
name|prio
parameter_list|)
block|{
return|return
operator|(
name|MmMapLockedPages
argument_list|(
name|buf
argument_list|,
name|accessmode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|MmUnmapLockedPages
parameter_list|(
name|vaddr
parameter_list|,
name|buf
parameter_list|)
name|void
modifier|*
name|vaddr
decl_stmt|;
name|mdl
modifier|*
name|buf
decl_stmt|;
block|{
name|buf
operator|->
name|mdl_flags
operator|&=
operator|~
name|MDL_MAPPED_TO_SYSTEM_VA
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * This function has a problem in that it will break if you  * compile this module without PAE and try to use it on a PAE  * kernel. Unfortunately, there's no way around this at the  * moment. It's slightly less broken that using pmap_kextract().  * You'd think the virtual memory subsystem would help us out  * here, but it doesn't.  */
end_comment

begin_function
name|uint8_t
name|MmIsAddressValid
parameter_list|(
name|vaddr
parameter_list|)
name|void
modifier|*
name|vaddr
decl_stmt|;
block|{
if|if
condition|(
name|pmap_extract
argument_list|(
name|kernel_map
operator|->
name|pmap
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|vaddr
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|MmMapIoSpace
parameter_list|(
name|paddr
parameter_list|,
name|len
parameter_list|,
name|cachetype
parameter_list|)
name|uint64_t
name|paddr
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|uint32_t
name|cachetype
decl_stmt|;
block|{
name|devclass_t
name|nexus_class
decl_stmt|;
name|device_t
modifier|*
name|nexus_devs
decl_stmt|,
name|devp
decl_stmt|;
name|int
name|nexus_count
init|=
literal|0
decl_stmt|;
name|device_t
name|matching_dev
init|=
name|NULL
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vm_offset_t
name|v
decl_stmt|;
comment|/* There will always be at least one nexus. */
name|nexus_class
operator|=
name|devclass_find
argument_list|(
literal|"nexus"
argument_list|)
expr_stmt|;
name|devclass_get_devices
argument_list|(
name|nexus_class
argument_list|,
operator|&
name|nexus_devs
argument_list|,
operator|&
name|nexus_count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nexus_count
condition|;
name|i
operator|++
control|)
block|{
name|devp
operator|=
name|nexus_devs
index|[
name|i
index|]
expr_stmt|;
name|matching_dev
operator|=
name|ntoskrnl_finddev
argument_list|(
name|devp
argument_list|,
name|paddr
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|matching_dev
condition|)
break|break;
block|}
name|free
argument_list|(
name|nexus_devs
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|matching_dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|v
operator|=
operator|(
name|vm_offset_t
operator|)
name|rman_get_virtual
argument_list|(
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|paddr
operator|>
name|rman_get_start
argument_list|(
name|res
argument_list|)
condition|)
name|v
operator|+=
name|paddr
operator|-
name|rman_get_start
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|v
operator|)
return|;
block|}
end_function

begin_function
name|void
name|MmUnmapIoSpace
parameter_list|(
name|vaddr
parameter_list|,
name|len
parameter_list|)
name|void
modifier|*
name|vaddr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
return|return;
block|}
end_function

begin_function
specifier|static
name|device_t
name|ntoskrnl_finddev
parameter_list|(
name|dev
parameter_list|,
name|paddr
parameter_list|,
name|res
parameter_list|)
name|device_t
name|dev
decl_stmt|;
name|uint64_t
name|paddr
decl_stmt|;
name|struct
name|resource
modifier|*
modifier|*
name|res
decl_stmt|;
block|{
name|device_t
modifier|*
name|children
init|=
name|NULL
decl_stmt|;
name|device_t
name|matching_dev
decl_stmt|;
name|int
name|childcnt
decl_stmt|;
name|struct
name|resource
modifier|*
name|r
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* We only want devices that have been successfully probed. */
if|if
condition|(
name|device_is_alive
argument_list|(
name|dev
argument_list|)
operator|==
name|FALSE
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|rl
operator|=
name|BUS_GET_RESOURCE_LIST
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|600022
name|SLIST_FOREACH
argument_list|(
argument|rle
argument_list|,
argument|rl
argument_list|,
argument|link
argument_list|)
block|{
else|#
directive|else
name|STAILQ_FOREACH
argument_list|(
argument|rle
argument_list|,
argument|rl
argument_list|,
argument|link
argument_list|)
block|{
endif|#
directive|endif
name|r
operator|=
name|rle
operator|->
name|res
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
continue|continue;
name|flags
operator|=
name|rman_get_flags
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
operator|->
name|type
operator|==
name|SYS_RES_MEMORY
operator|&&
name|paddr
operator|>=
name|rman_get_start
argument_list|(
name|r
argument_list|)
operator|&&
name|paddr
operator|<=
name|rman_get_end
argument_list|(
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|RF_ACTIVE
operator|)
condition|)
name|bus_activate_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
literal|0
argument_list|,
name|r
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|r
expr_stmt|;
return|return
operator|(
name|dev
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 * If this device has children, do another 	 * level of recursion to inspect them. 	 */
name|device_get_children
argument_list|(
name|dev
argument_list|,
operator|&
name|children
argument_list|,
operator|&
name|childcnt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|childcnt
condition|;
name|i
operator|++
control|)
block|{
name|matching_dev
operator|=
name|ntoskrnl_finddev
argument_list|(
name|children
index|[
name|i
index|]
argument_list|,
name|paddr
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|matching_dev
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|children
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|matching_dev
operator|)
return|;
block|}
block|}
comment|/* Won't somebody please think of the children! */
if|if
condition|(
name|children
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|children
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/*  * Workitems are unlike DPCs, in that they run in a user-mode thread  * context rather than at DISPATCH_LEVEL in kernel context. In our  * case we run them in kernel context anyway.  */
specifier|static
name|void
name|ntoskrnl_workitem_thread
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|kdpc_queue
modifier|*
name|kq
decl_stmt|;
name|list_entry
modifier|*
name|l
decl_stmt|;
name|io_workitem
modifier|*
name|iw
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
name|kq
operator|=
name|arg
expr_stmt|;
name|InitializeListHead
argument_list|(
operator|&
name|kq
operator|->
name|kq_disp
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_td
operator|=
name|curthread
expr_stmt|;
name|kq
operator|->
name|kq_exit
operator|=
literal|0
expr_stmt|;
name|KeInitializeSpinLock
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
name|KeInitializeEvent
argument_list|(
operator|&
name|kq
operator|->
name|kq_proc
argument_list|,
name|EVENT_TYPE_SYNC
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|KeWaitForSingleObject
argument_list|(
operator|&
name|kq
operator|->
name|kq_proc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|KeAcquireSpinLock
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
if|if
condition|(
name|kq
operator|->
name|kq_exit
condition|)
block|{
name|kq
operator|->
name|kq_exit
operator|=
literal|0
expr_stmt|;
name|KeReleaseSpinLock
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|!
name|IsListEmpty
argument_list|(
operator|&
name|kq
operator|->
name|kq_disp
argument_list|)
condition|)
block|{
name|l
operator|=
name|RemoveHeadList
argument_list|(
operator|&
name|kq
operator|->
name|kq_disp
argument_list|)
expr_stmt|;
name|iw
operator|=
name|CONTAINING_RECORD
argument_list|(
name|l
argument_list|,
name|io_workitem
argument_list|,
name|iw_listentry
argument_list|)
expr_stmt|;
name|InitializeListHead
argument_list|(
operator|(
operator|&
name|iw
operator|->
name|iw_listentry
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iw
operator|->
name|iw_func
operator|==
name|NULL
condition|)
continue|continue;
name|KeReleaseSpinLock
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
name|MSCALL2
argument_list|(
name|iw
operator|->
name|iw_func
argument_list|,
name|iw
operator|->
name|iw_dobj
argument_list|,
name|iw
operator|->
name|iw_ctx
argument_list|)
expr_stmt|;
name|KeAcquireSpinLock
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
block|}
name|KeReleaseSpinLock
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|502113
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kproc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
comment|/* notreached */
block|}
specifier|static
name|void
name|ntoskrnl_destroy_workitem_threads
parameter_list|(
name|void
parameter_list|)
block|{
name|kdpc_queue
modifier|*
name|kq
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WORKITEM_THREADS
condition|;
name|i
operator|++
control|)
block|{
name|kq
operator|=
name|wq_queues
operator|+
name|i
expr_stmt|;
name|kq
operator|->
name|kq_exit
operator|=
literal|1
expr_stmt|;
name|KeSetEvent
argument_list|(
operator|&
name|kq
operator|->
name|kq_proc
argument_list|,
name|IO_NO_INCREMENT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
while|while
condition|(
name|kq
operator|->
name|kq_exit
condition|)
name|tsleep
argument_list|(
name|kq
operator|->
name|kq_td
operator|->
name|td_proc
argument_list|,
name|PWAIT
argument_list|,
literal|"waitiw"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|io_workitem
modifier|*
name|IoAllocateWorkItem
parameter_list|(
name|dobj
parameter_list|)
name|device_object
modifier|*
name|dobj
decl_stmt|;
block|{
name|io_workitem
modifier|*
name|iw
decl_stmt|;
name|iw
operator|=
name|uma_zalloc
argument_list|(
name|iw_zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|iw
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|InitializeListHead
argument_list|(
operator|&
name|iw
operator|->
name|iw_listentry
argument_list|)
expr_stmt|;
name|iw
operator|->
name|iw_dobj
operator|=
name|dobj
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|iw
operator|->
name|iw_idx
operator|=
name|wq_idx
expr_stmt|;
name|WORKIDX_INC
argument_list|(
name|wq_idx
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|iw
operator|)
return|;
block|}
name|void
name|IoFreeWorkItem
parameter_list|(
name|iw
parameter_list|)
name|io_workitem
modifier|*
name|iw
decl_stmt|;
block|{
name|uma_zfree
argument_list|(
name|iw_zone
argument_list|,
name|iw
argument_list|)
expr_stmt|;
return|return;
block|}
name|void
name|IoQueueWorkItem
parameter_list|(
name|iw
parameter_list|,
name|iw_func
parameter_list|,
name|qtype
parameter_list|,
name|ctx
parameter_list|)
name|io_workitem
modifier|*
name|iw
decl_stmt|;
name|io_workitem_func
name|iw_func
decl_stmt|;
name|uint32_t
name|qtype
decl_stmt|;
name|void
modifier|*
name|ctx
decl_stmt|;
block|{
name|kdpc_queue
modifier|*
name|kq
decl_stmt|;
name|list_entry
modifier|*
name|l
decl_stmt|;
name|io_workitem
modifier|*
name|cur
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
name|kq
operator|=
name|wq_queues
operator|+
name|iw
operator|->
name|iw_idx
expr_stmt|;
name|KeAcquireSpinLock
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
comment|/* 	 * Traverse the list and make sure this workitem hasn't 	 * already been inserted. Queuing the same workitem 	 * twice will hose the list but good. 	 */
name|l
operator|=
name|kq
operator|->
name|kq_disp
operator|.
name|nle_flink
expr_stmt|;
while|while
condition|(
name|l
operator|!=
operator|&
name|kq
operator|->
name|kq_disp
condition|)
block|{
name|cur
operator|=
name|CONTAINING_RECORD
argument_list|(
name|l
argument_list|,
name|io_workitem
argument_list|,
name|iw_listentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|iw
condition|)
block|{
comment|/* Already queued -- do nothing. */
name|KeReleaseSpinLock
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
return|return;
block|}
name|l
operator|=
name|l
operator|->
name|nle_flink
expr_stmt|;
block|}
name|iw
operator|->
name|iw_func
operator|=
name|iw_func
expr_stmt|;
name|iw
operator|->
name|iw_ctx
operator|=
name|ctx
expr_stmt|;
name|InsertTailList
argument_list|(
operator|(
operator|&
name|kq
operator|->
name|kq_disp
operator|)
argument_list|,
operator|(
operator|&
name|iw
operator|->
name|iw_listentry
operator|)
argument_list|)
expr_stmt|;
name|KeReleaseSpinLock
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
name|KeSetEvent
argument_list|(
operator|&
name|kq
operator|->
name|kq_proc
argument_list|,
name|IO_NO_INCREMENT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|static
name|void
name|ntoskrnl_workitem
parameter_list|(
name|dobj
parameter_list|,
name|arg
parameter_list|)
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|io_workitem
modifier|*
name|iw
decl_stmt|;
name|work_queue_item
modifier|*
name|w
decl_stmt|;
name|work_item_func
name|f
decl_stmt|;
name|iw
operator|=
name|arg
expr_stmt|;
name|w
operator|=
operator|(
name|work_queue_item
operator|*
operator|)
name|dobj
expr_stmt|;
name|f
operator|=
operator|(
name|work_item_func
operator|)
name|w
operator|->
name|wqi_func
expr_stmt|;
name|uma_zfree
argument_list|(
name|iw_zone
argument_list|,
name|iw
argument_list|)
expr_stmt|;
name|MSCALL2
argument_list|(
name|f
argument_list|,
name|w
argument_list|,
name|w
operator|->
name|wqi_ctx
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  * The ExQueueWorkItem() API is deprecated in Windows XP. Microsoft  * warns that it's unsafe and to use IoQueueWorkItem() instead. The  * problem with ExQueueWorkItem() is that it can't guard against  * the condition where a driver submits a job to the work queue and  * is then unloaded before the job is able to run. IoQueueWorkItem()  * acquires a reference to the device's device_object via the  * object manager and retains it until after the job has completed,  * which prevents the driver from being unloaded before the job  * runs. (We don't currently support this behavior, though hopefully  * that will change once the object manager API is fleshed out a bit.)  *  * Having said all that, the ExQueueWorkItem() API remains, because  * there are still other parts of Windows that use it, including  * NDIS itself: NdisScheduleWorkItem() calls ExQueueWorkItem().  * We fake up the ExQueueWorkItem() API on top of our implementation  * of IoQueueWorkItem(). Workitem thread #3 is reserved exclusively  * for ExQueueWorkItem() jobs, and we pass a pointer to the work  * queue item (provided by the caller) in to IoAllocateWorkItem()  * instead of the device_object. We need to save this pointer so  * we can apply a sanity check: as with the DPC queue and other  * workitem queues, we can't allow the same work queue item to  * be queued twice. If it's already pending, we silently return  */
name|void
name|ExQueueWorkItem
parameter_list|(
name|w
parameter_list|,
name|qtype
parameter_list|)
name|work_queue_item
modifier|*
name|w
decl_stmt|;
name|uint32_t
name|qtype
decl_stmt|;
block|{
name|io_workitem
modifier|*
name|iw
decl_stmt|;
name|io_workitem_func
name|iwf
decl_stmt|;
name|kdpc_queue
modifier|*
name|kq
decl_stmt|;
name|list_entry
modifier|*
name|l
decl_stmt|;
name|io_workitem
modifier|*
name|cur
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
comment|/* 	 * We need to do a special sanity test to make sure 	 * the ExQueueWorkItem() API isn't used to queue 	 * the same workitem twice. Rather than checking the 	 * io_workitem pointer itself, we test the attached 	 * device object, which is really a pointer to the 	 * legacy work queue item structure. 	 */
name|kq
operator|=
name|wq_queues
operator|+
name|WORKITEM_LEGACY_THREAD
expr_stmt|;
name|KeAcquireSpinLock
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
name|l
operator|=
name|kq
operator|->
name|kq_disp
operator|.
name|nle_flink
expr_stmt|;
while|while
condition|(
name|l
operator|!=
operator|&
name|kq
operator|->
name|kq_disp
condition|)
block|{
name|cur
operator|=
name|CONTAINING_RECORD
argument_list|(
name|l
argument_list|,
name|io_workitem
argument_list|,
name|iw_listentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|iw_dobj
operator|==
operator|(
name|device_object
operator|*
operator|)
name|w
condition|)
block|{
comment|/* Already queued -- do nothing. */
name|KeReleaseSpinLock
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
return|return;
block|}
name|l
operator|=
name|l
operator|->
name|nle_flink
expr_stmt|;
block|}
name|KeReleaseSpinLock
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
name|iw
operator|=
name|IoAllocateWorkItem
argument_list|(
operator|(
name|device_object
operator|*
operator|)
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|iw
operator|==
name|NULL
condition|)
return|return;
name|iw
operator|->
name|iw_idx
operator|=
name|WORKITEM_LEGACY_THREAD
expr_stmt|;
name|iwf
operator|=
operator|(
name|io_workitem_func
operator|)
name|ntoskrnl_findwrap
argument_list|(
operator|(
name|funcptr
operator|)
name|ntoskrnl_workitem
argument_list|)
expr_stmt|;
name|IoQueueWorkItem
argument_list|(
name|iw
argument_list|,
name|iwf
argument_list|,
name|qtype
argument_list|,
name|iw
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|static
name|void
name|RtlZeroMemory
parameter_list|(
name|dst
parameter_list|,
name|len
parameter_list|)
name|void
modifier|*
name|dst
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|bzero
argument_list|(
name|dst
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|static
name|void
name|RtlCopyMemory
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|len
parameter_list|)
name|void
modifier|*
name|dst
decl_stmt|;
specifier|const
name|void
modifier|*
name|src
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|static
name|size_t
name|RtlCompareMemory
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|len
parameter_list|)
specifier|const
name|void
modifier|*
name|s1
decl_stmt|;
specifier|const
name|void
modifier|*
name|s2
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|size_t
name|i
decl_stmt|,
name|total
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|m1
decl_stmt|,
modifier|*
name|m2
decl_stmt|;
name|m1
operator|=
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|m2
operator|=
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|s2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|m1
index|[
name|i
index|]
operator|==
name|m2
index|[
name|i
index|]
condition|)
name|total
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|total
operator|)
return|;
block|}
name|void
name|RtlInitAnsiString
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
name|ansi_string
modifier|*
name|dst
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
block|{
name|ansi_string
modifier|*
name|a
decl_stmt|;
name|a
operator|=
name|dst
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
block|{
name|a
operator|->
name|as_len
operator|=
name|a
operator|->
name|as_maxlen
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|as_buf
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|a
operator|->
name|as_buf
operator|=
name|src
expr_stmt|;
name|a
operator|->
name|as_len
operator|=
name|a
operator|->
name|as_maxlen
operator|=
name|strlen
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|void
name|RtlInitUnicodeString
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
name|unicode_string
modifier|*
name|dst
decl_stmt|;
name|uint16_t
modifier|*
name|src
decl_stmt|;
block|{
name|unicode_string
modifier|*
name|u
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u
operator|=
name|dst
expr_stmt|;
if|if
condition|(
name|u
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
block|{
name|u
operator|->
name|us_len
operator|=
name|u
operator|->
name|us_maxlen
operator|=
literal|0
expr_stmt|;
name|u
operator|->
name|us_buf
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|src
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|i
operator|++
expr_stmt|;
name|u
operator|->
name|us_buf
operator|=
name|src
expr_stmt|;
name|u
operator|->
name|us_len
operator|=
name|u
operator|->
name|us_maxlen
operator|=
name|i
operator|*
literal|2
expr_stmt|;
block|}
return|return;
block|}
name|ndis_status
name|RtlUnicodeStringToInteger
parameter_list|(
name|ustr
parameter_list|,
name|base
parameter_list|,
name|val
parameter_list|)
name|unicode_string
modifier|*
name|ustr
decl_stmt|;
name|uint32_t
name|base
decl_stmt|;
name|uint32_t
modifier|*
name|val
decl_stmt|;
block|{
name|uint16_t
modifier|*
name|uchr
decl_stmt|;
name|int
name|len
decl_stmt|,
name|neg
init|=
literal|0
decl_stmt|;
name|char
name|abuf
index|[
literal|64
index|]
decl_stmt|;
name|char
modifier|*
name|astr
decl_stmt|;
name|uchr
operator|=
name|ustr
operator|->
name|us_buf
expr_stmt|;
name|len
operator|=
name|ustr
operator|->
name|us_len
expr_stmt|;
name|bzero
argument_list|(
name|abuf
argument_list|,
sizeof|sizeof
argument_list|(
name|abuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|char
call|)
argument_list|(
operator|(
operator|*
name|uchr
operator|)
operator|&
literal|0xFF
argument_list|)
operator|==
literal|'-'
condition|)
block|{
name|neg
operator|=
literal|1
expr_stmt|;
name|uchr
operator|++
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
call|(
name|char
call|)
argument_list|(
operator|(
operator|*
name|uchr
operator|)
operator|&
literal|0xFF
argument_list|)
operator|==
literal|'+'
condition|)
block|{
name|neg
operator|=
literal|0
expr_stmt|;
name|uchr
operator|++
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|==
literal|0
condition|)
block|{
if|if
condition|(
call|(
name|char
call|)
argument_list|(
operator|(
operator|*
name|uchr
operator|)
operator|&
literal|0xFF
argument_list|)
operator|==
literal|'b'
condition|)
block|{
name|base
operator|=
literal|2
expr_stmt|;
name|uchr
operator|++
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
call|(
name|char
call|)
argument_list|(
operator|(
operator|*
name|uchr
operator|)
operator|&
literal|0xFF
argument_list|)
operator|==
literal|'o'
condition|)
block|{
name|base
operator|=
literal|8
expr_stmt|;
name|uchr
operator|++
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
call|(
name|char
call|)
argument_list|(
operator|(
operator|*
name|uchr
operator|)
operator|&
literal|0xFF
argument_list|)
operator|==
literal|'x'
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
name|uchr
operator|++
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
else|else
name|base
operator|=
literal|10
expr_stmt|;
block|}
name|astr
operator|=
name|abuf
expr_stmt|;
if|if
condition|(
name|neg
condition|)
block|{
name|strcpy
argument_list|(
name|astr
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|astr
operator|++
expr_stmt|;
block|}
name|ntoskrnl_unicode_to_ascii
argument_list|(
name|uchr
argument_list|,
name|astr
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
name|strtoul
argument_list|(
name|abuf
argument_list|,
name|NULL
argument_list|,
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
name|void
name|RtlFreeUnicodeString
parameter_list|(
name|ustr
parameter_list|)
name|unicode_string
modifier|*
name|ustr
decl_stmt|;
block|{
if|if
condition|(
name|ustr
operator|->
name|us_buf
operator|==
name|NULL
condition|)
return|return;
name|ExFreePool
argument_list|(
name|ustr
operator|->
name|us_buf
argument_list|)
expr_stmt|;
name|ustr
operator|->
name|us_buf
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|void
name|RtlFreeAnsiString
parameter_list|(
name|astr
parameter_list|)
name|ansi_string
modifier|*
name|astr
decl_stmt|;
block|{
if|if
condition|(
name|astr
operator|->
name|as_buf
operator|==
name|NULL
condition|)
return|return;
name|ExFreePool
argument_list|(
name|astr
operator|->
name|as_buf
argument_list|)
expr_stmt|;
name|astr
operator|->
name|as_buf
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
specifier|static
name|int
name|atoi
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
return|return
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|str
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
return|;
block|}
specifier|static
name|long
name|atol
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
return|return
name|strtol
argument_list|(
name|str
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
return|;
block|}
specifier|static
name|int
name|rand
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|srandom
argument_list|(
name|tv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|random
argument_list|()
operator|)
return|;
block|}
specifier|static
name|void
name|srand
parameter_list|(
name|seed
parameter_list|)
name|unsigned
name|int
name|seed
decl_stmt|;
block|{
name|srandom
argument_list|(
name|seed
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|static
name|uint8_t
name|IoIsWdmVersionAvailable
parameter_list|(
name|uint8_t
name|major
parameter_list|,
name|uint8_t
name|minor
parameter_list|)
block|{
if|if
condition|(
name|major
operator|==
name|WDM_MAJOR
operator|&&
name|minor
operator|==
name|WDM_MINOR_WINXP
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
specifier|static
name|ndis_status
name|IoGetDeviceObjectPointer
parameter_list|(
name|name
parameter_list|,
name|reqaccess
parameter_list|,
name|fileobj
parameter_list|,
name|devobj
parameter_list|)
name|unicode_string
modifier|*
name|name
decl_stmt|;
name|uint32_t
name|reqaccess
decl_stmt|;
name|void
modifier|*
name|fileobj
decl_stmt|;
name|device_object
modifier|*
name|devobj
decl_stmt|;
block|{
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
specifier|static
name|ndis_status
name|IoGetDeviceProperty
parameter_list|(
name|devobj
parameter_list|,
name|regprop
parameter_list|,
name|buflen
parameter_list|,
name|prop
parameter_list|,
name|reslen
parameter_list|)
name|device_object
modifier|*
name|devobj
decl_stmt|;
name|uint32_t
name|regprop
decl_stmt|;
name|uint32_t
name|buflen
decl_stmt|;
name|void
modifier|*
name|prop
decl_stmt|;
name|uint32_t
modifier|*
name|reslen
decl_stmt|;
block|{
name|driver_object
modifier|*
name|drv
decl_stmt|;
name|uint16_t
modifier|*
modifier|*
name|name
decl_stmt|;
name|drv
operator|=
name|devobj
operator|->
name|do_drvobj
expr_stmt|;
switch|switch
condition|(
name|regprop
condition|)
block|{
case|case
name|DEVPROP_DRIVER_KEYNAME
case|:
name|name
operator|=
name|prop
expr_stmt|;
operator|*
name|name
operator|=
name|drv
operator|->
name|dro_drivername
operator|.
name|us_buf
expr_stmt|;
operator|*
name|reslen
operator|=
name|drv
operator|->
name|dro_drivername
operator|.
name|us_len
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|STATUS_INVALID_PARAMETER_2
operator|)
return|;
break|break;
block|}
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
specifier|static
name|void
name|KeInitializeMutex
parameter_list|(
name|kmutex
parameter_list|,
name|level
parameter_list|)
name|kmutant
modifier|*
name|kmutex
decl_stmt|;
name|uint32_t
name|level
decl_stmt|;
block|{
name|InitializeListHead
argument_list|(
operator|(
operator|&
name|kmutex
operator|->
name|km_header
operator|.
name|dh_waitlisthead
operator|)
argument_list|)
expr_stmt|;
name|kmutex
operator|->
name|km_abandoned
operator|=
name|FALSE
expr_stmt|;
name|kmutex
operator|->
name|km_apcdisable
operator|=
literal|1
expr_stmt|;
name|kmutex
operator|->
name|km_header
operator|.
name|dh_sigstate
operator|=
literal|1
expr_stmt|;
name|kmutex
operator|->
name|km_header
operator|.
name|dh_type
operator|=
name|DISP_TYPE_MUTANT
expr_stmt|;
name|kmutex
operator|->
name|km_header
operator|.
name|dh_size
operator|=
sizeof|sizeof
argument_list|(
name|kmutant
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|kmutex
operator|->
name|km_ownerthread
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
specifier|static
name|uint32_t
name|KeReleaseMutex
parameter_list|(
name|kmutant
modifier|*
name|kmutex
parameter_list|,
name|uint8_t
name|kwait
parameter_list|)
block|{
name|uint32_t
name|prevstate
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|prevstate
operator|=
name|kmutex
operator|->
name|km_header
operator|.
name|dh_sigstate
expr_stmt|;
if|if
condition|(
name|kmutex
operator|->
name|km_ownerthread
operator|!=
name|curthread
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_MUTANT_NOT_OWNED
operator|)
return|;
block|}
name|kmutex
operator|->
name|km_header
operator|.
name|dh_sigstate
operator|++
expr_stmt|;
name|kmutex
operator|->
name|km_abandoned
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|kmutex
operator|->
name|km_header
operator|.
name|dh_sigstate
operator|==
literal|1
condition|)
block|{
name|kmutex
operator|->
name|km_ownerthread
operator|=
name|NULL
expr_stmt|;
name|ntoskrnl_waittest
argument_list|(
operator|&
name|kmutex
operator|->
name|km_header
argument_list|,
name|IO_NO_INCREMENT
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|prevstate
operator|)
return|;
block|}
specifier|static
name|uint32_t
name|KeReadStateMutex
parameter_list|(
name|kmutex
parameter_list|)
name|kmutant
modifier|*
name|kmutex
decl_stmt|;
block|{
return|return
operator|(
name|kmutex
operator|->
name|km_header
operator|.
name|dh_sigstate
operator|)
return|;
block|}
name|void
name|KeInitializeEvent
parameter_list|(
name|nt_kevent
modifier|*
name|kevent
parameter_list|,
name|uint32_t
name|type
parameter_list|,
name|uint8_t
name|state
parameter_list|)
block|{
name|InitializeListHead
argument_list|(
operator|(
operator|&
name|kevent
operator|->
name|k_header
operator|.
name|dh_waitlisthead
operator|)
argument_list|)
expr_stmt|;
name|kevent
operator|->
name|k_header
operator|.
name|dh_sigstate
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|EVENT_TYPE_NOTIFY
condition|)
name|kevent
operator|->
name|k_header
operator|.
name|dh_type
operator|=
name|DISP_TYPE_NOTIFICATION_EVENT
expr_stmt|;
else|else
name|kevent
operator|->
name|k_header
operator|.
name|dh_type
operator|=
name|DISP_TYPE_SYNCHRONIZATION_EVENT
expr_stmt|;
name|kevent
operator|->
name|k_header
operator|.
name|dh_size
operator|=
sizeof|sizeof
argument_list|(
name|nt_kevent
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
return|return;
block|}
name|uint32_t
name|KeResetEvent
parameter_list|(
name|kevent
parameter_list|)
name|nt_kevent
modifier|*
name|kevent
decl_stmt|;
block|{
name|uint32_t
name|prevstate
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|prevstate
operator|=
name|kevent
operator|->
name|k_header
operator|.
name|dh_sigstate
expr_stmt|;
name|kevent
operator|->
name|k_header
operator|.
name|dh_sigstate
operator|=
name|FALSE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|prevstate
operator|)
return|;
block|}
name|uint32_t
name|KeSetEvent
parameter_list|(
name|nt_kevent
modifier|*
name|kevent
parameter_list|,
name|uint32_t
name|increment
parameter_list|,
name|uint8_t
name|kwait
parameter_list|)
block|{
name|uint32_t
name|prevstate
decl_stmt|;
name|wait_block
modifier|*
name|w
decl_stmt|;
name|nt_dispatch_header
modifier|*
name|dh
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|wb_ext
modifier|*
name|we
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|prevstate
operator|=
name|kevent
operator|->
name|k_header
operator|.
name|dh_sigstate
expr_stmt|;
name|dh
operator|=
operator|&
name|kevent
operator|->
name|k_header
expr_stmt|;
if|if
condition|(
name|IsListEmpty
argument_list|(
operator|&
name|dh
operator|->
name|dh_waitlisthead
argument_list|)
condition|)
comment|/* 		 * If there's nobody in the waitlist, just set 		 * the state to signalled. 		 */
name|dh
operator|->
name|dh_sigstate
operator|=
literal|1
expr_stmt|;
else|else
block|{
comment|/* 		 * Get the first waiter. If this is a synchronization 		 * event, just wake up that one thread (don't bother 		 * setting the state to signalled since we're supposed 		 * to automatically clear synchronization events anyway). 		 * 		 * If it's a notification event, or the the first 		 * waiter is doing a WAITTYPE_ALL wait, go through 		 * the full wait satisfaction process. 		 */
name|w
operator|=
name|CONTAINING_RECORD
argument_list|(
name|dh
operator|->
name|dh_waitlisthead
operator|.
name|nle_flink
argument_list|,
name|wait_block
argument_list|,
name|wb_waitlist
argument_list|)
expr_stmt|;
name|we
operator|=
name|w
operator|->
name|wb_ext
expr_stmt|;
name|td
operator|=
name|we
operator|->
name|we_td
expr_stmt|;
if|if
condition|(
name|kevent
operator|->
name|k_header
operator|.
name|dh_type
operator|==
name|DISP_TYPE_NOTIFICATION_EVENT
operator|||
name|w
operator|->
name|wb_waittype
operator|==
name|WAITTYPE_ALL
condition|)
block|{
if|if
condition|(
name|prevstate
operator|==
literal|0
condition|)
block|{
name|dh
operator|->
name|dh_sigstate
operator|=
literal|1
expr_stmt|;
name|ntoskrnl_waittest
argument_list|(
name|dh
argument_list|,
name|increment
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|w
operator|->
name|wb_awakened
operator||=
name|TRUE
expr_stmt|;
name|cv_broadcastpri
argument_list|(
operator|&
name|we
operator|->
name|we_cv
argument_list|,
operator|(
name|w
operator|->
name|wb_oldpri
operator|-
operator|(
name|increment
operator|*
literal|4
operator|)
operator|)
operator|>
name|PRI_MIN_KERN
condition|?
name|w
operator|->
name|wb_oldpri
operator|-
operator|(
name|increment
operator|*
literal|4
operator|)
else|:
name|PRI_MIN_KERN
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|prevstate
operator|)
return|;
block|}
name|void
name|KeClearEvent
parameter_list|(
name|kevent
parameter_list|)
name|nt_kevent
modifier|*
name|kevent
decl_stmt|;
block|{
name|kevent
operator|->
name|k_header
operator|.
name|dh_sigstate
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|uint32_t
name|KeReadStateEvent
parameter_list|(
name|kevent
parameter_list|)
name|nt_kevent
modifier|*
name|kevent
decl_stmt|;
block|{
return|return
operator|(
name|kevent
operator|->
name|k_header
operator|.
name|dh_sigstate
operator|)
return|;
block|}
comment|/*  * The object manager in Windows is responsible for managing  * references and access to various types of objects, including  * device_objects, events, threads, timers and so on. However,  * there's a difference in the way objects are handled in user  * mode versus kernel mode.  *  * In user mode (i.e. Win32 applications), all objects are  * managed by the object manager. For example, when you create  * a timer or event object, you actually end up with an   * object_header (for the object manager's bookkeeping  * purposes) and an object body (which contains the actual object  * structure, e.g. ktimer, kevent, etc...). This allows Windows  * to manage resource quotas and to enforce access restrictions  * on basically every kind of system object handled by the kernel.  *  * However, in kernel mode, you only end up using the object  * manager some of the time. For example, in a driver, you create  * a timer object by simply allocating the memory for a ktimer  * structure and initializing it with KeInitializeTimer(). Hence,  * the timer has no object_header and no reference counting or  * security/resource checks are done on it. The assumption in  * this case is that if you're running in kernel mode, you know  * what you're doing, and you're already at an elevated privilege  * anyway.  *  * There are some exceptions to this. The two most important ones  * for our purposes are device_objects and threads. We need to use  * the object manager to do reference counting on device_objects,  * and for threads, you can only get a pointer to a thread's  * dispatch header by using ObReferenceObjectByHandle() on the  * handle returned by PsCreateSystemThread().  */
specifier|static
name|ndis_status
name|ObReferenceObjectByHandle
parameter_list|(
name|ndis_handle
name|handle
parameter_list|,
name|uint32_t
name|reqaccess
parameter_list|,
name|void
modifier|*
name|otype
parameter_list|,
name|uint8_t
name|accessmode
parameter_list|,
name|void
modifier|*
modifier|*
name|object
parameter_list|,
name|void
modifier|*
modifier|*
name|handleinfo
parameter_list|)
block|{
name|nt_objref
modifier|*
name|nr
decl_stmt|;
name|nr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|nt_objref
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr
operator|==
name|NULL
condition|)
return|return
operator|(
name|STATUS_INSUFFICIENT_RESOURCES
operator|)
return|;
name|InitializeListHead
argument_list|(
operator|(
operator|&
name|nr
operator|->
name|no_dh
operator|.
name|dh_waitlisthead
operator|)
argument_list|)
expr_stmt|;
name|nr
operator|->
name|no_obj
operator|=
name|handle
expr_stmt|;
name|nr
operator|->
name|no_dh
operator|.
name|dh_type
operator|=
name|DISP_TYPE_THREAD
expr_stmt|;
name|nr
operator|->
name|no_dh
operator|.
name|dh_sigstate
operator|=
literal|0
expr_stmt|;
name|nr
operator|->
name|no_dh
operator|.
name|dh_size
operator|=
call|(
name|uint8_t
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|thread
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ntoskrnl_reflist
argument_list|,
name|nr
argument_list|,
name|link
argument_list|)
expr_stmt|;
operator|*
name|object
operator|=
name|nr
expr_stmt|;
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
specifier|static
name|void
name|ObfDereferenceObject
parameter_list|(
name|object
parameter_list|)
name|void
modifier|*
name|object
decl_stmt|;
block|{
name|nt_objref
modifier|*
name|nr
decl_stmt|;
name|nr
operator|=
name|object
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ntoskrnl_reflist
argument_list|,
name|nr
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|static
name|uint32_t
name|ZwClose
parameter_list|(
name|handle
parameter_list|)
name|ndis_handle
name|handle
decl_stmt|;
block|{
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
specifier|static
name|uint32_t
name|WmiQueryTraceInformation
parameter_list|(
name|traceclass
parameter_list|,
name|traceinfo
parameter_list|,
name|infolen
parameter_list|,
name|reqlen
parameter_list|,
name|buf
parameter_list|)
name|uint32_t
name|traceclass
decl_stmt|;
name|void
modifier|*
name|traceinfo
decl_stmt|;
name|uint32_t
name|infolen
decl_stmt|;
name|uint32_t
name|reqlen
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
block|{
return|return
operator|(
name|STATUS_NOT_FOUND
operator|)
return|;
block|}
specifier|static
name|uint32_t
name|WmiTraceMessage
parameter_list|(
name|uint64_t
name|loghandle
parameter_list|,
name|uint32_t
name|messageflags
parameter_list|,
name|void
modifier|*
name|guid
parameter_list|,
name|uint16_t
name|messagenum
parameter_list|,
modifier|...
parameter_list|)
block|{
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
specifier|static
name|uint32_t
name|IoWMIRegistrationControl
parameter_list|(
name|dobj
parameter_list|,
name|action
parameter_list|)
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|uint32_t
name|action
decl_stmt|;
block|{
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
comment|/*  * This is here just in case the thread returns without calling  * PsTerminateSystemThread().  */
specifier|static
name|void
name|ntoskrnl_thrfunc
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|thread_context
modifier|*
name|thrctx
decl_stmt|;
name|uint32_t
function_decl|(
modifier|*
name|tfunc
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|tctx
decl_stmt|;
name|uint32_t
name|rval
decl_stmt|;
name|thrctx
operator|=
name|arg
expr_stmt|;
name|tfunc
operator|=
name|thrctx
operator|->
name|tc_thrfunc
expr_stmt|;
name|tctx
operator|=
name|thrctx
operator|->
name|tc_thrctx
expr_stmt|;
name|free
argument_list|(
name|thrctx
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|rval
operator|=
name|MSCALL1
argument_list|(
name|tfunc
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
name|PsTerminateSystemThread
argument_list|(
name|rval
argument_list|)
expr_stmt|;
return|return;
comment|/* notreached */
block|}
specifier|static
name|ndis_status
name|PsCreateSystemThread
parameter_list|(
name|handle
parameter_list|,
name|reqaccess
parameter_list|,
name|objattrs
parameter_list|,
name|phandle
parameter_list|,
name|clientid
parameter_list|,
name|thrfunc
parameter_list|,
name|thrctx
parameter_list|)
name|ndis_handle
modifier|*
name|handle
decl_stmt|;
name|uint32_t
name|reqaccess
decl_stmt|;
name|void
modifier|*
name|objattrs
decl_stmt|;
name|ndis_handle
name|phandle
decl_stmt|;
name|void
modifier|*
name|clientid
decl_stmt|;
name|void
modifier|*
name|thrfunc
decl_stmt|;
name|void
modifier|*
name|thrctx
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|char
name|tname
index|[
literal|128
index|]
decl_stmt|;
name|thread_context
modifier|*
name|tc
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|tc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|thread_context
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tc
operator|==
name|NULL
condition|)
return|return
operator|(
name|STATUS_INSUFFICIENT_RESOURCES
operator|)
return|;
name|tc
operator|->
name|tc_thrctx
operator|=
name|thrctx
expr_stmt|;
name|tc
operator|->
name|tc_thrfunc
operator|=
name|thrfunc
expr_stmt|;
name|sprintf
argument_list|(
name|tname
argument_list|,
literal|"windows kthread %d"
argument_list|,
name|ntoskrnl_kth
argument_list|)
expr_stmt|;
name|error
operator|=
name|kproc_create
argument_list|(
name|ntoskrnl_thrfunc
argument_list|,
name|tc
argument_list|,
operator|&
name|p
argument_list|,
name|RFHIGHPID
argument_list|,
name|NDIS_KSTACK_PAGES
argument_list|,
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|tc
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_INSUFFICIENT_RESOURCES
operator|)
return|;
block|}
operator|*
name|handle
operator|=
name|p
expr_stmt|;
name|ntoskrnl_kth
operator|++
expr_stmt|;
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
comment|/*  * In Windows, the exit of a thread is an event that you're allowed  * to wait on, assuming you've obtained a reference to the thread using  * ObReferenceObjectByHandle(). Unfortunately, the only way we can  * simulate this behavior is to register each thread we create in a  * reference list, and if someone holds a reference to us, we poke  * them.  */
specifier|static
name|ndis_status
name|PsTerminateSystemThread
parameter_list|(
name|status
parameter_list|)
name|ndis_status
name|status
decl_stmt|;
block|{
name|struct
name|nt_objref
modifier|*
name|nr
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|nr
argument_list|,
argument|&ntoskrnl_reflist
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|nr
operator|->
name|no_obj
operator|!=
name|curthread
operator|->
name|td_proc
condition|)
continue|continue;
name|nr
operator|->
name|no_dh
operator|.
name|dh_sigstate
operator|=
literal|1
expr_stmt|;
name|ntoskrnl_waittest
argument_list|(
operator|&
name|nr
operator|->
name|no_dh
argument_list|,
name|IO_NO_INCREMENT
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|ntoskrnl_kth
operator|--
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|502113
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kproc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* notreached */
block|}
specifier|static
name|uint32_t
name|DbgPrint
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
specifier|static
name|void
name|DbgBreakPoint
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|502113
name|Debugger
argument_list|(
literal|"DbgBreakPoint(): breakpoint"
argument_list|)
expr_stmt|;
else|#
directive|else
name|kdb_enter
argument_list|(
name|KDB_WHY_NDIS
argument_list|,
literal|"DbgBreakPoint(): breakpoint"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
specifier|static
name|void
name|KeBugCheckEx
parameter_list|(
name|code
parameter_list|,
name|param1
parameter_list|,
name|param2
parameter_list|,
name|param3
parameter_list|,
name|param4
parameter_list|)
name|uint32_t
name|code
decl_stmt|;
name|u_long
name|param1
decl_stmt|;
name|u_long
name|param2
decl_stmt|;
name|u_long
name|param3
decl_stmt|;
name|u_long
name|param4
decl_stmt|;
block|{
name|panic
argument_list|(
literal|"KeBugCheckEx: STOP 0x%X"
argument_list|,
name|code
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|ntoskrnl_timercall
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|ktimer
modifier|*
name|timer
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|kdpc
modifier|*
name|dpc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|timer
operator|=
name|arg
expr_stmt|;
ifdef|#
directive|ifdef
name|NTOSKRNL_DEBUG_TIMERS
name|ntoskrnl_timer_fires
operator|++
expr_stmt|;
endif|#
directive|endif
name|ntoskrnl_remove_timer
argument_list|(
name|timer
argument_list|)
expr_stmt|;
comment|/* 	 * This should never happen, but complain 	 * if it does. 	 */
if|if
condition|(
name|timer
operator|->
name|k_header
operator|.
name|dh_inserted
operator|==
name|FALSE
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"NTOS: timer %p fired even though "
literal|"it was canceled\n"
argument_list|,
name|timer
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Mark the timer as no longer being on the timer queue. */
name|timer
operator|->
name|k_header
operator|.
name|dh_inserted
operator|=
name|FALSE
expr_stmt|;
comment|/* Now signal the object and satisfy any waits on it. */
name|timer
operator|->
name|k_header
operator|.
name|dh_sigstate
operator|=
literal|1
expr_stmt|;
name|ntoskrnl_waittest
argument_list|(
operator|&
name|timer
operator|->
name|k_header
argument_list|,
name|IO_NO_INCREMENT
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a periodic timer, re-arm it 	 * so it will fire again. We do this before 	 * calling any deferred procedure calls because 	 * it's possible the DPC might cancel the timer, 	 * in which case it would be wrong for us to 	 * re-arm it again afterwards. 	 */
if|if
condition|(
name|timer
operator|->
name|k_period
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|timer
operator|->
name|k_period
operator|*
literal|1000
expr_stmt|;
name|timer
operator|->
name|k_header
operator|.
name|dh_inserted
operator|=
name|TRUE
expr_stmt|;
name|ntoskrnl_insert_timer
argument_list|(
name|timer
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NTOSKRNL_DEBUG_TIMERS
name|ntoskrnl_timer_reloads
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
name|dpc
operator|=
name|timer
operator|->
name|k_dpc
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
comment|/* If there's a DPC associated with the timer, queue it up. */
if|if
condition|(
name|dpc
operator|!=
name|NULL
condition|)
name|KeInsertQueueDpc
argument_list|(
name|dpc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|NTOSKRNL_DEBUG_TIMERS
specifier|static
name|int
name|sysctl_show_timers
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|ntoskrnl_show_timers
argument_list|()
expr_stmt|;
return|return
operator|(
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|ret
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
specifier|static
name|void
name|ntoskrnl_show_timers
parameter_list|()
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|list_entry
modifier|*
name|l
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|ntoskrnl_calllock
argument_list|)
expr_stmt|;
name|l
operator|=
name|ntoskrnl_calllist
operator|.
name|nle_flink
expr_stmt|;
while|while
condition|(
name|l
operator|!=
operator|&
name|ntoskrnl_calllist
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|l
operator|=
name|l
operator|->
name|nle_flink
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|ntoskrnl_calllock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d timers available (out of %d)\n"
argument_list|,
name|i
argument_list|,
name|NTOSKRNL_TIMEOUTS
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"timer sets: %qu\n"
argument_list|,
name|ntoskrnl_timer_sets
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"timer reloads: %qu\n"
argument_list|,
name|ntoskrnl_timer_reloads
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"timer cancels: %qu\n"
argument_list|,
name|ntoskrnl_timer_cancels
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"timer fires: %qu\n"
argument_list|,
name|ntoskrnl_timer_fires
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/*  * Must be called with dispatcher lock held.  */
specifier|static
name|void
name|ntoskrnl_insert_timer
parameter_list|(
name|timer
parameter_list|,
name|ticks
parameter_list|)
name|ktimer
modifier|*
name|timer
decl_stmt|;
name|int
name|ticks
decl_stmt|;
block|{
name|callout_entry
modifier|*
name|e
decl_stmt|;
name|list_entry
modifier|*
name|l
decl_stmt|;
name|struct
name|callout
modifier|*
name|c
decl_stmt|;
comment|/* 	 * Try and allocate a timer. 	 */
name|mtx_lock_spin
argument_list|(
operator|&
name|ntoskrnl_calllock
argument_list|)
expr_stmt|;
if|if
condition|(
name|IsListEmpty
argument_list|(
operator|&
name|ntoskrnl_calllist
argument_list|)
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|ntoskrnl_calllock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NTOSKRNL_DEBUG_TIMERS
name|ntoskrnl_show_timers
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|panic
argument_list|(
literal|"out of timers!"
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
name|RemoveHeadList
argument_list|(
operator|&
name|ntoskrnl_calllist
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|ntoskrnl_calllock
argument_list|)
expr_stmt|;
name|e
operator|=
name|CONTAINING_RECORD
argument_list|(
name|l
argument_list|,
name|callout_entry
argument_list|,
name|ce_list
argument_list|)
expr_stmt|;
name|c
operator|=
operator|&
name|e
operator|->
name|ce_callout
expr_stmt|;
name|timer
operator|->
name|k_callout
operator|=
name|c
expr_stmt|;
name|callout_init
argument_list|(
name|c
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
name|c
argument_list|,
name|ticks
argument_list|,
name|ntoskrnl_timercall
argument_list|,
name|timer
argument_list|)
expr_stmt|;
return|return;
block|}
specifier|static
name|void
name|ntoskrnl_remove_timer
parameter_list|(
name|timer
parameter_list|)
name|ktimer
modifier|*
name|timer
decl_stmt|;
block|{
name|callout_entry
modifier|*
name|e
decl_stmt|;
name|e
operator|=
operator|(
name|callout_entry
operator|*
operator|)
name|timer
operator|->
name|k_callout
expr_stmt|;
name|callout_stop
argument_list|(
name|timer
operator|->
name|k_callout
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|ntoskrnl_calllock
argument_list|)
expr_stmt|;
name|InsertHeadList
argument_list|(
operator|(
operator|&
name|ntoskrnl_calllist
operator|)
argument_list|,
operator|(
operator|&
name|e
operator|->
name|ce_list
operator|)
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|ntoskrnl_calllock
argument_list|)
expr_stmt|;
return|return;
block|}
name|void
name|KeInitializeTimer
parameter_list|(
name|timer
parameter_list|)
name|ktimer
modifier|*
name|timer
decl_stmt|;
block|{
if|if
condition|(
name|timer
operator|==
name|NULL
condition|)
return|return;
name|KeInitializeTimerEx
argument_list|(
name|timer
argument_list|,
name|EVENT_TYPE_NOTIFY
argument_list|)
expr_stmt|;
return|return;
block|}
name|void
name|KeInitializeTimerEx
parameter_list|(
name|timer
parameter_list|,
name|type
parameter_list|)
name|ktimer
modifier|*
name|timer
decl_stmt|;
name|uint32_t
name|type
decl_stmt|;
block|{
if|if
condition|(
name|timer
operator|==
name|NULL
condition|)
return|return;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|timer
argument_list|,
sizeof|sizeof
argument_list|(
name|ktimer
argument_list|)
argument_list|)
expr_stmt|;
name|InitializeListHead
argument_list|(
operator|(
operator|&
name|timer
operator|->
name|k_header
operator|.
name|dh_waitlisthead
operator|)
argument_list|)
expr_stmt|;
name|timer
operator|->
name|k_header
operator|.
name|dh_sigstate
operator|=
name|FALSE
expr_stmt|;
name|timer
operator|->
name|k_header
operator|.
name|dh_inserted
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|EVENT_TYPE_NOTIFY
condition|)
name|timer
operator|->
name|k_header
operator|.
name|dh_type
operator|=
name|DISP_TYPE_NOTIFICATION_TIMER
expr_stmt|;
else|else
name|timer
operator|->
name|k_header
operator|.
name|dh_type
operator|=
name|DISP_TYPE_SYNCHRONIZATION_TIMER
expr_stmt|;
name|timer
operator|->
name|k_header
operator|.
name|dh_size
operator|=
sizeof|sizeof
argument_list|(
name|ktimer
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*  * DPC subsystem. A Windows Defered Procedure Call has the following  * properties:  * - It runs at DISPATCH_LEVEL.  * - It can have one of 3 importance values that control when it  *   runs relative to other DPCs in the queue.  * - On SMP systems, it can be set to run on a specific processor.  * In order to satisfy the last property, we create a DPC thread for  * each CPU in the system and bind it to that CPU. Each thread  * maintains three queues with different importance levels, which  * will be processed in order from lowest to highest.  *  * In Windows, interrupt handlers run as DPCs. (Not to be confused  * with ISRs, which run in interrupt context and can preempt DPCs.)  * ISRs are given the highest importance so that they'll take  * precedence over timers and other things.  */
specifier|static
name|void
name|ntoskrnl_dpc_thread
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|kdpc_queue
modifier|*
name|kq
decl_stmt|;
name|kdpc
modifier|*
name|d
decl_stmt|;
name|list_entry
modifier|*
name|l
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
name|kq
operator|=
name|arg
expr_stmt|;
name|InitializeListHead
argument_list|(
operator|&
name|kq
operator|->
name|kq_disp
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_td
operator|=
name|curthread
expr_stmt|;
name|kq
operator|->
name|kq_exit
operator|=
literal|0
expr_stmt|;
name|kq
operator|->
name|kq_running
operator|=
name|FALSE
expr_stmt|;
name|KeInitializeSpinLock
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
name|KeInitializeEvent
argument_list|(
operator|&
name|kq
operator|->
name|kq_proc
argument_list|,
name|EVENT_TYPE_SYNC
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|KeInitializeEvent
argument_list|(
operator|&
name|kq
operator|->
name|kq_done
argument_list|,
name|EVENT_TYPE_SYNC
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* 	 * Elevate our priority. DPCs are used to run interrupt 	 * handlers, and they should trigger as soon as possible 	 * once scheduled by an ISR. 	 */
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NTOSKRNL_MULTIPLE_DPCS
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|502102
name|sched_bind
argument_list|(
name|curthread
argument_list|,
name|kq
operator|->
name|kq_cpu
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|sched_prio
argument_list|(
name|curthread
argument_list|,
name|PRI_MIN_KERN
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|600000
name|curthread
operator|->
name|td_base_pri
operator|=
name|PRI_MIN_KERN
expr_stmt|;
endif|#
directive|endif
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|KeWaitForSingleObject
argument_list|(
operator|&
name|kq
operator|->
name|kq_proc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|KeAcquireSpinLock
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
if|if
condition|(
name|kq
operator|->
name|kq_exit
condition|)
block|{
name|kq
operator|->
name|kq_exit
operator|=
literal|0
expr_stmt|;
name|KeReleaseSpinLock
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
break|break;
block|}
name|kq
operator|->
name|kq_running
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
operator|!
name|IsListEmpty
argument_list|(
operator|&
name|kq
operator|->
name|kq_disp
argument_list|)
condition|)
block|{
name|l
operator|=
name|RemoveHeadList
argument_list|(
operator|(
operator|&
name|kq
operator|->
name|kq_disp
operator|)
argument_list|)
expr_stmt|;
name|d
operator|=
name|CONTAINING_RECORD
argument_list|(
name|l
argument_list|,
name|kdpc
argument_list|,
name|k_dpclistentry
argument_list|)
expr_stmt|;
name|InitializeListHead
argument_list|(
operator|(
operator|&
name|d
operator|->
name|k_dpclistentry
operator|)
argument_list|)
expr_stmt|;
name|KeReleaseSpinLockFromDpcLevel
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
name|MSCALL4
argument_list|(
name|d
operator|->
name|k_deferedfunc
argument_list|,
name|d
argument_list|,
name|d
operator|->
name|k_deferredctx
argument_list|,
name|d
operator|->
name|k_sysarg1
argument_list|,
name|d
operator|->
name|k_sysarg2
argument_list|)
expr_stmt|;
name|KeAcquireSpinLockAtDpcLevel
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
block|}
name|kq
operator|->
name|kq_running
operator|=
name|FALSE
expr_stmt|;
name|KeReleaseSpinLock
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
name|KeSetEvent
argument_list|(
operator|&
name|kq
operator|->
name|kq_done
argument_list|,
name|IO_NO_INCREMENT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|502113
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kproc_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
comment|/* notreached */
block|}
specifier|static
name|void
name|ntoskrnl_destroy_dpc_threads
parameter_list|(
name|void
parameter_list|)
block|{
name|kdpc_queue
modifier|*
name|kq
decl_stmt|;
name|kdpc
name|dpc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|kq
operator|=
name|kq_queues
expr_stmt|;
ifdef|#
directive|ifdef
name|NTOSKRNL_MULTIPLE_DPCS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp_ncpus
condition|;
name|i
operator|++
control|)
block|{
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1
condition|;
name|i
operator|++
control|)
block|{
endif|#
directive|endif
name|kq
operator|+=
name|i
expr_stmt|;
name|kq
operator|->
name|kq_exit
operator|=
literal|1
expr_stmt|;
name|KeInitializeDpc
argument_list|(
operator|&
name|dpc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|KeSetTargetProcessorDpc
argument_list|(
operator|&
name|dpc
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|KeInsertQueueDpc
argument_list|(
operator|&
name|dpc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|kq
operator|->
name|kq_exit
condition|)
name|tsleep
argument_list|(
name|kq
operator|->
name|kq_td
operator|->
name|td_proc
argument_list|,
name|PWAIT
argument_list|,
literal|"dpcw"
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
specifier|static
name|uint8_t
name|ntoskrnl_insert_dpc
parameter_list|(
name|head
parameter_list|,
name|dpc
parameter_list|)
name|list_entry
modifier|*
name|head
decl_stmt|;
name|kdpc
modifier|*
name|dpc
decl_stmt|;
block|{
name|list_entry
modifier|*
name|l
decl_stmt|;
name|kdpc
modifier|*
name|d
decl_stmt|;
name|l
operator|=
name|head
operator|->
name|nle_flink
expr_stmt|;
while|while
condition|(
name|l
operator|!=
name|head
condition|)
block|{
name|d
operator|=
name|CONTAINING_RECORD
argument_list|(
name|l
argument_list|,
name|kdpc
argument_list|,
name|k_dpclistentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|dpc
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|l
operator|=
name|l
operator|->
name|nle_flink
expr_stmt|;
block|}
if|if
condition|(
name|dpc
operator|->
name|k_importance
operator|==
name|KDPC_IMPORTANCE_LOW
condition|)
name|InsertTailList
argument_list|(
operator|(
name|head
operator|)
argument_list|,
operator|(
operator|&
name|dpc
operator|->
name|k_dpclistentry
operator|)
argument_list|)
expr_stmt|;
else|else
name|InsertHeadList
argument_list|(
operator|(
name|head
operator|)
argument_list|,
operator|(
operator|&
name|dpc
operator|->
name|k_dpclistentry
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|void
name|KeInitializeDpc
parameter_list|(
name|dpc
parameter_list|,
name|dpcfunc
parameter_list|,
name|dpcctx
parameter_list|)
name|kdpc
modifier|*
name|dpc
decl_stmt|;
name|void
modifier|*
name|dpcfunc
decl_stmt|;
name|void
modifier|*
name|dpcctx
decl_stmt|;
block|{
if|if
condition|(
name|dpc
operator|==
name|NULL
condition|)
return|return;
name|dpc
operator|->
name|k_deferedfunc
operator|=
name|dpcfunc
expr_stmt|;
name|dpc
operator|->
name|k_deferredctx
operator|=
name|dpcctx
expr_stmt|;
name|dpc
operator|->
name|k_num
operator|=
name|KDPC_CPU_DEFAULT
expr_stmt|;
name|dpc
operator|->
name|k_importance
operator|=
name|KDPC_IMPORTANCE_MEDIUM
expr_stmt|;
name|InitializeListHead
argument_list|(
operator|(
operator|&
name|dpc
operator|->
name|k_dpclistentry
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|uint8_t
name|KeInsertQueueDpc
parameter_list|(
name|dpc
parameter_list|,
name|sysarg1
parameter_list|,
name|sysarg2
parameter_list|)
name|kdpc
modifier|*
name|dpc
decl_stmt|;
name|void
modifier|*
name|sysarg1
decl_stmt|;
name|void
modifier|*
name|sysarg2
decl_stmt|;
block|{
name|kdpc_queue
modifier|*
name|kq
decl_stmt|;
name|uint8_t
name|r
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
if|if
condition|(
name|dpc
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|kq
operator|=
name|kq_queues
expr_stmt|;
ifdef|#
directive|ifdef
name|NTOSKRNL_MULTIPLE_DPCS
name|KeRaiseIrql
argument_list|(
name|DISPATCH_LEVEL
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
comment|/* 	 * By default, the DPC is queued to run on the same CPU 	 * that scheduled it. 	 */
if|if
condition|(
name|dpc
operator|->
name|k_num
operator|==
name|KDPC_CPU_DEFAULT
condition|)
name|kq
operator|+=
name|curthread
operator|->
name|td_oncpu
expr_stmt|;
else|else
name|kq
operator|+=
name|dpc
operator|->
name|k_num
expr_stmt|;
name|KeAcquireSpinLockAtDpcLevel
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
else|#
directive|else
name|KeAcquireSpinLock
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|r
operator|=
name|ntoskrnl_insert_dpc
argument_list|(
operator|&
name|kq
operator|->
name|kq_disp
argument_list|,
name|dpc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|TRUE
condition|)
block|{
name|dpc
operator|->
name|k_sysarg1
operator|=
name|sysarg1
expr_stmt|;
name|dpc
operator|->
name|k_sysarg2
operator|=
name|sysarg2
expr_stmt|;
block|}
name|KeReleaseSpinLock
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|FALSE
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|KeSetEvent
argument_list|(
operator|&
name|kq
operator|->
name|kq_proc
argument_list|,
name|IO_NO_INCREMENT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
name|uint8_t
name|KeRemoveQueueDpc
parameter_list|(
name|dpc
parameter_list|)
name|kdpc
modifier|*
name|dpc
decl_stmt|;
block|{
name|kdpc_queue
modifier|*
name|kq
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
if|if
condition|(
name|dpc
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
ifdef|#
directive|ifdef
name|NTOSKRNL_MULTIPLE_DPCS
name|KeRaiseIrql
argument_list|(
name|DISPATCH_LEVEL
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
name|kq
operator|=
name|kq_queues
operator|+
name|dpc
operator|->
name|k_num
expr_stmt|;
name|KeAcquireSpinLockAtDpcLevel
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
else|#
directive|else
name|kq
operator|=
name|kq_queues
expr_stmt|;
name|KeAcquireSpinLock
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dpc
operator|->
name|k_dpclistentry
operator|.
name|nle_flink
operator|==
operator|&
name|dpc
operator|->
name|k_dpclistentry
condition|)
block|{
name|KeReleaseSpinLockFromDpcLevel
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
name|KeLowerIrql
argument_list|(
name|irql
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|RemoveEntryList
argument_list|(
operator|(
operator|&
name|dpc
operator|->
name|k_dpclistentry
operator|)
argument_list|)
expr_stmt|;
name|InitializeListHead
argument_list|(
operator|(
operator|&
name|dpc
operator|->
name|k_dpclistentry
operator|)
argument_list|)
expr_stmt|;
name|KeReleaseSpinLock
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
name|void
name|KeSetImportanceDpc
parameter_list|(
name|dpc
parameter_list|,
name|imp
parameter_list|)
name|kdpc
modifier|*
name|dpc
decl_stmt|;
name|uint32_t
name|imp
decl_stmt|;
block|{
if|if
condition|(
name|imp
operator|!=
name|KDPC_IMPORTANCE_LOW
operator|&&
name|imp
operator|!=
name|KDPC_IMPORTANCE_MEDIUM
operator|&&
name|imp
operator|!=
name|KDPC_IMPORTANCE_HIGH
condition|)
return|return;
name|dpc
operator|->
name|k_importance
operator|=
operator|(
name|uint8_t
operator|)
name|imp
expr_stmt|;
return|return;
block|}
name|void
name|KeSetTargetProcessorDpc
parameter_list|(
name|kdpc
modifier|*
name|dpc
parameter_list|,
name|uint8_t
name|cpu
parameter_list|)
block|{
if|if
condition|(
name|cpu
operator|>
name|mp_ncpus
condition|)
return|return;
name|dpc
operator|->
name|k_num
operator|=
name|cpu
expr_stmt|;
return|return;
block|}
name|void
name|KeFlushQueuedDpcs
parameter_list|(
name|void
parameter_list|)
block|{
name|kdpc_queue
modifier|*
name|kq
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Poke each DPC queue and wait 	 * for them to drain. 	 */
ifdef|#
directive|ifdef
name|NTOSKRNL_MULTIPLE_DPCS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp_ncpus
condition|;
name|i
operator|++
control|)
block|{
else|#
directive|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1
condition|;
name|i
operator|++
control|)
block|{
endif|#
directive|endif
name|kq
operator|=
name|kq_queues
operator|+
name|i
expr_stmt|;
name|KeSetEvent
argument_list|(
operator|&
name|kq
operator|->
name|kq_proc
argument_list|,
name|IO_NO_INCREMENT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|KeWaitForSingleObject
argument_list|(
operator|&
name|kq
operator|->
name|kq_done
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|uint32_t
name|KeGetCurrentProcessorNumber
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|(
name|uint32_t
operator|)
name|curthread
operator|->
name|td_oncpu
operator|)
return|;
block|}
name|uint8_t
name|KeSetTimerEx
parameter_list|(
name|timer
parameter_list|,
name|duetime
parameter_list|,
name|period
parameter_list|,
name|dpc
parameter_list|)
name|ktimer
modifier|*
name|timer
decl_stmt|;
name|int64_t
name|duetime
decl_stmt|;
name|uint32_t
name|period
decl_stmt|;
name|kdpc
modifier|*
name|dpc
decl_stmt|;
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|uint64_t
name|curtime
decl_stmt|;
name|uint8_t
name|pending
decl_stmt|;
if|if
condition|(
name|timer
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|timer
operator|->
name|k_header
operator|.
name|dh_inserted
operator|==
name|TRUE
condition|)
block|{
name|ntoskrnl_remove_timer
argument_list|(
name|timer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NTOSKRNL_DEBUG_TIMERS
name|ntoskrnl_timer_cancels
operator|++
expr_stmt|;
endif|#
directive|endif
name|timer
operator|->
name|k_header
operator|.
name|dh_inserted
operator|=
name|FALSE
expr_stmt|;
name|pending
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|pending
operator|=
name|FALSE
expr_stmt|;
name|timer
operator|->
name|k_duetime
operator|=
name|duetime
expr_stmt|;
name|timer
operator|->
name|k_period
operator|=
name|period
expr_stmt|;
name|timer
operator|->
name|k_header
operator|.
name|dh_sigstate
operator|=
name|FALSE
expr_stmt|;
name|timer
operator|->
name|k_dpc
operator|=
name|dpc
expr_stmt|;
if|if
condition|(
name|duetime
operator|<
literal|0
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|=
operator|-
operator|(
name|duetime
operator|)
operator|/
literal|10000000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
operator|-
operator|(
name|duetime
operator|)
operator|/
literal|10
operator|)
operator|-
operator|(
name|tv
operator|.
name|tv_sec
operator|*
literal|1000000
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ntoskrnl_time
argument_list|(
operator|&
name|curtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|duetime
operator|<
name|curtime
condition|)
name|tv
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|tv
operator|.
name|tv_sec
operator|=
operator|(
operator|(
name|duetime
operator|)
operator|-
name|curtime
operator|)
operator|/
literal|10000000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
operator|(
name|duetime
operator|)
operator|-
name|curtime
operator|)
operator|/
literal|10
operator|-
operator|(
name|tv
operator|.
name|tv_sec
operator|*
literal|1000000
operator|)
expr_stmt|;
block|}
block|}
name|timer
operator|->
name|k_header
operator|.
name|dh_inserted
operator|=
name|TRUE
expr_stmt|;
name|ntoskrnl_insert_timer
argument_list|(
name|timer
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NTOSKRNL_DEBUG_TIMERS
name|ntoskrnl_timer_sets
operator|++
expr_stmt|;
endif|#
directive|endif
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|pending
operator|)
return|;
block|}
name|uint8_t
name|KeSetTimer
parameter_list|(
name|timer
parameter_list|,
name|duetime
parameter_list|,
name|dpc
parameter_list|)
name|ktimer
modifier|*
name|timer
decl_stmt|;
name|int64_t
name|duetime
decl_stmt|;
name|kdpc
modifier|*
name|dpc
decl_stmt|;
block|{
return|return
operator|(
name|KeSetTimerEx
argument_list|(
name|timer
argument_list|,
name|duetime
argument_list|,
literal|0
argument_list|,
name|dpc
argument_list|)
operator|)
return|;
block|}
comment|/*  * The Windows DDK documentation seems to say that cancelling  * a timer that has a DPC will result in the DPC also being  * cancelled, but this isn't really the case.  */
name|uint8_t
name|KeCancelTimer
parameter_list|(
name|timer
parameter_list|)
name|ktimer
modifier|*
name|timer
decl_stmt|;
block|{
name|uint8_t
name|pending
decl_stmt|;
if|if
condition|(
name|timer
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|pending
operator|=
name|timer
operator|->
name|k_header
operator|.
name|dh_inserted
expr_stmt|;
if|if
condition|(
name|timer
operator|->
name|k_header
operator|.
name|dh_inserted
operator|==
name|TRUE
condition|)
block|{
name|timer
operator|->
name|k_header
operator|.
name|dh_inserted
operator|=
name|FALSE
expr_stmt|;
name|ntoskrnl_remove_timer
argument_list|(
name|timer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NTOSKRNL_DEBUG_TIMERS
name|ntoskrnl_timer_cancels
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|pending
operator|)
return|;
block|}
name|uint8_t
name|KeReadStateTimer
parameter_list|(
name|timer
parameter_list|)
name|ktimer
modifier|*
name|timer
decl_stmt|;
block|{
return|return
operator|(
name|timer
operator|->
name|k_header
operator|.
name|dh_sigstate
operator|)
return|;
block|}
specifier|static
name|int32_t
name|KeDelayExecutionThread
parameter_list|(
name|uint8_t
name|wait_mode
parameter_list|,
name|uint8_t
name|alertable
parameter_list|,
name|int64_t
modifier|*
name|interval
parameter_list|)
block|{
name|ktimer
name|timer
decl_stmt|;
if|if
condition|(
name|wait_mode
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"invalid wait_mode %d"
argument_list|,
name|wait_mode
argument_list|)
expr_stmt|;
name|KeInitializeTimer
argument_list|(
operator|&
name|timer
argument_list|)
expr_stmt|;
name|KeSetTimer
argument_list|(
operator|&
name|timer
argument_list|,
operator|*
name|interval
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|KeWaitForSingleObject
argument_list|(
operator|&
name|timer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|alertable
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|STATUS_SUCCESS
return|;
block|}
specifier|static
name|uint64_t
name|KeQueryInterruptTime
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ticks
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|getmicrouptime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|ticks
operator|=
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
return|return
name|ticks
operator|*
operator|(
operator|(
literal|10000000
operator|+
name|hz
operator|-
literal|1
operator|)
operator|/
name|hz
operator|)
return|;
block|}
specifier|static
name|struct
name|thread
modifier|*
name|KeGetCurrentThread
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|curthread
return|;
block|}
specifier|static
name|int32_t
name|KeSetPriorityThread
parameter_list|(
name|td
parameter_list|,
name|pri
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int32_t
name|pri
decl_stmt|;
block|{
name|int32_t
name|old
decl_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
return|return
name|LOW_REALTIME_PRIORITY
return|;
if|if
condition|(
name|td
operator|->
name|td_priority
operator|<=
name|PRI_MIN_KERN
condition|)
name|old
operator|=
name|HIGH_PRIORITY
expr_stmt|;
elseif|else
if|if
condition|(
name|td
operator|->
name|td_priority
operator|>=
name|PRI_MAX_KERN
condition|)
name|old
operator|=
name|LOW_PRIORITY
expr_stmt|;
else|else
name|old
operator|=
name|LOW_REALTIME_PRIORITY
expr_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|pri
operator|==
name|HIGH_PRIORITY
condition|)
name|sched_prio
argument_list|(
name|td
argument_list|,
name|PRI_MIN_KERN
argument_list|)
expr_stmt|;
if|if
condition|(
name|pri
operator|==
name|LOW_REALTIME_PRIORITY
condition|)
name|sched_prio
argument_list|(
name|td
argument_list|,
name|PRI_MIN_KERN
operator|+
operator|(
name|PRI_MAX_KERN
operator|-
name|PRI_MIN_KERN
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pri
operator|==
name|LOW_PRIORITY
condition|)
name|sched_prio
argument_list|(
name|td
argument_list|,
name|PRI_MAX_KERN
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
return|return
name|old
return|;
block|}
specifier|static
name|void
name|dummy
parameter_list|()
block|{
name|printf
argument_list|(
literal|"ntoskrnl dummy called...\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|image_patch_table
name|ntoskrnl_functbl
index|[]
init|=
block|{
name|IMPORT_SFUNC
argument_list|(
name|RtlZeroMemory
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|RtlCopyMemory
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|RtlCompareMemory
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|RtlEqualUnicodeString
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|RtlCopyUnicodeString
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|RtlUnicodeStringToAnsiString
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|RtlAnsiStringToUnicodeString
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|RtlInitAnsiString
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC_MAP
argument_list|(
name|RtlInitString
argument_list|,
name|RtlInitAnsiString
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|RtlInitUnicodeString
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|RtlFreeAnsiString
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|RtlFreeUnicodeString
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|RtlUnicodeStringToInteger
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|sprintf
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|vsprintf
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC_MAP
argument_list|(
name|_snprintf
argument_list|,
name|snprintf
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC_MAP
argument_list|(
name|_vsnprintf
argument_list|,
name|vsnprintf
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|DbgPrint
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|DbgBreakPoint
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeBugCheckEx
argument_list|,
literal|5
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|strncmp
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|strcmp
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC_MAP
argument_list|(
name|stricmp
argument_list|,
name|strcasecmp
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|strncpy
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|strcpy
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|strlen
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC_MAP
argument_list|(
name|toupper
argument_list|,
name|ntoskrnl_toupper
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC_MAP
argument_list|(
name|tolower
argument_list|,
name|ntoskrnl_tolower
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC_MAP
argument_list|(
name|strstr
argument_list|,
name|ntoskrnl_strstr
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC_MAP
argument_list|(
name|strncat
argument_list|,
name|ntoskrnl_strncat
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC_MAP
argument_list|(
name|strchr
argument_list|,
name|index
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC_MAP
argument_list|(
name|strrchr
argument_list|,
name|rindex
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|memcpy
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC_MAP
argument_list|(
name|memmove
argument_list|,
name|ntoskrnl_memmove
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC_MAP
argument_list|(
name|memset
argument_list|,
name|ntoskrnl_memset
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC_MAP
argument_list|(
name|memchr
argument_list|,
name|ntoskrnl_memchr
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoAllocateDriverObjectExtension
argument_list|,
literal|4
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoGetDriverObjectExtension
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|IofCallDriver
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|IofCompleteRequest
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoAcquireCancelSpinLock
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoReleaseCancelSpinLock
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoCancelIrp
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoConnectInterrupt
argument_list|,
literal|11
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoDisconnectInterrupt
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoCreateDevice
argument_list|,
literal|7
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoDeleteDevice
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoGetAttachedDevice
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoAttachDeviceToDeviceStack
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoDetachDevice
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoBuildSynchronousFsdRequest
argument_list|,
literal|7
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoBuildAsynchronousFsdRequest
argument_list|,
literal|6
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoBuildDeviceIoControlRequest
argument_list|,
literal|9
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoAllocateIrp
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoReuseIrp
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoMakeAssociatedIrp
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoFreeIrp
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoInitializeIrp
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeAcquireInterruptSpinLock
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeReleaseInterruptSpinLock
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeSynchronizeExecution
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeWaitForSingleObject
argument_list|,
literal|5
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeWaitForMultipleObjects
argument_list|,
literal|8
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|_allmul
argument_list|,
literal|4
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|_alldiv
argument_list|,
literal|4
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|_allrem
argument_list|,
literal|4
argument_list|)
block|,
name|IMPORT_RFUNC
argument_list|(
name|_allshr
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_RFUNC
argument_list|(
name|_allshl
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|_aullmul
argument_list|,
literal|4
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|_aulldiv
argument_list|,
literal|4
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|_aullrem
argument_list|,
literal|4
argument_list|)
block|,
name|IMPORT_RFUNC
argument_list|(
name|_aullshr
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_RFUNC
argument_list|(
name|_aullshl
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|atoi
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|atol
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|rand
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|srand
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|WRITE_REGISTER_USHORT
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|READ_REGISTER_USHORT
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|WRITE_REGISTER_ULONG
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|READ_REGISTER_ULONG
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|READ_REGISTER_UCHAR
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|WRITE_REGISTER_UCHAR
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ExInitializePagedLookasideList
argument_list|,
literal|7
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ExDeletePagedLookasideList
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ExInitializeNPagedLookasideList
argument_list|,
literal|7
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ExDeleteNPagedLookasideList
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|InterlockedPopEntrySList
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|InterlockedPushEntrySList
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ExQueryDepthSList
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_FFUNC_MAP
argument_list|(
name|ExpInterlockedPopEntrySList
argument_list|,
name|InterlockedPopEntrySList
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_FFUNC_MAP
argument_list|(
name|ExpInterlockedPushEntrySList
argument_list|,
name|InterlockedPushEntrySList
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|ExInterlockedPopEntrySList
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|ExInterlockedPushEntrySList
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ExAllocatePoolWithTag
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ExFreePool
argument_list|,
literal|1
argument_list|)
block|,
ifdef|#
directive|ifdef
name|__i386__
name|IMPORT_FFUNC
argument_list|(
name|KefAcquireSpinLockAtDpcLevel
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|KefReleaseSpinLockFromDpcLevel
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|KeAcquireSpinLockRaiseToDpc
argument_list|,
literal|1
argument_list|)
block|,
else|#
directive|else
comment|/* 	 * For AMD64, we can get away with just mapping 	 * KeAcquireSpinLockRaiseToDpc() directly to KfAcquireSpinLock() 	 * because the calling conventions end up being the same. 	 * On i386, we have to be careful because KfAcquireSpinLock() 	 * is _fastcall but KeAcquireSpinLockRaiseToDpc() isn't. 	 */
name|IMPORT_SFUNC
argument_list|(
name|KeAcquireSpinLockAtDpcLevel
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeReleaseSpinLockFromDpcLevel
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC_MAP
argument_list|(
name|KeAcquireSpinLockRaiseToDpc
argument_list|,
name|KfAcquireSpinLock
argument_list|,
literal|1
argument_list|)
block|,
endif|#
directive|endif
name|IMPORT_SFUNC_MAP
argument_list|(
name|KeReleaseSpinLock
argument_list|,
name|KfReleaseSpinLock
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|InterlockedIncrement
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|InterlockedDecrement
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|InterlockedExchange
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|ExInterlockedAddLargeStatistic
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoAllocateMdl
argument_list|,
literal|5
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoFreeMdl
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|MmAllocateContiguousMemory
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|MmAllocateContiguousMemorySpecifyCache
argument_list|,
literal|5
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|MmFreeContiguousMemory
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|MmFreeContiguousMemorySpecifyCache
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC_MAP
argument_list|(
name|MmGetPhysicalAddress
argument_list|,
name|pmap_kextract
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|MmSizeOfMdl
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|MmMapLockedPages
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|MmMapLockedPagesSpecifyCache
argument_list|,
literal|6
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|MmUnmapLockedPages
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|MmBuildMdlForNonPagedPool
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|MmIsAddressValid
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|MmMapIoSpace
argument_list|,
literal|3
operator|+
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|MmUnmapIoSpace
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeInitializeSpinLock
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoIsWdmVersionAvailable
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoGetDeviceObjectPointer
argument_list|,
literal|4
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoGetDeviceProperty
argument_list|,
literal|5
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoAllocateWorkItem
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoFreeWorkItem
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoQueueWorkItem
argument_list|,
literal|4
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ExQueueWorkItem
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ntoskrnl_workitem
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeInitializeMutex
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeReleaseMutex
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeReadStateMutex
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeInitializeEvent
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeSetEvent
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeResetEvent
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeClearEvent
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeReadStateEvent
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeInitializeTimer
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeInitializeTimerEx
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeSetTimer
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeSetTimerEx
argument_list|,
literal|4
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeCancelTimer
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeReadStateTimer
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeInitializeDpc
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeInsertQueueDpc
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeRemoveQueueDpc
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeSetImportanceDpc
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeSetTargetProcessorDpc
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeFlushQueuedDpcs
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeGetCurrentProcessorNumber
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ObReferenceObjectByHandle
argument_list|,
literal|6
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|ObfDereferenceObject
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ZwClose
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|PsCreateSystemThread
argument_list|,
literal|7
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|PsTerminateSystemThread
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoWMIRegistrationControl
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|WmiQueryTraceInformation
argument_list|,
literal|5
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|WmiTraceMessage
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeQuerySystemTime
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|KeTickCount
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeDelayExecutionThread
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeQueryInterruptTime
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeGetCurrentThread
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeSetPriorityThread
argument_list|,
literal|2
argument_list|)
block|,
comment|/* 	 * This last entry is a catch-all for any function we haven't 	 * implemented yet. The PE import list patching routine will 	 * use it for any function that doesn't have an explicit match 	 * in this table. 	 */
block|{
name|NULL
block|,
operator|(
name|FUNC
operator|)
name|dummy
block|,
name|NULL
block|,
literal|0
block|,
name|WINDRV_WRAP_STDCALL
block|}
block|,
comment|/* End of list. */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_function

end_unit

