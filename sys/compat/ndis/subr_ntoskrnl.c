begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003  *	Bill Paul<wpaul@windriver.com>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Bill Paul.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>
literal|502113
end_if

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_memio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_pio.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/pe_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/cfg_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/resource_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/ntoskrnl_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/hal_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/ndis_var.h>
end_include

begin_struct
struct|struct
name|kdpc_queue
block|{
name|list_entry
name|kq_high
decl_stmt|;
name|list_entry
name|kq_low
decl_stmt|;
name|list_entry
name|kq_med
decl_stmt|;
name|struct
name|thread
modifier|*
name|kq_td
decl_stmt|;
name|int
name|kq_state
decl_stmt|;
name|int
name|kq_cpu
decl_stmt|;
name|int
name|kq_exit
decl_stmt|;
name|struct
name|mtx
name|kq_lock
decl_stmt|;
name|nt_kevent
name|kq_proc
decl_stmt|;
name|nt_kevent
name|kq_done
decl_stmt|;
name|nt_kevent
name|kq_dead
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|kdpc_queue
name|kdpc_queue
typedef|;
end_typedef

begin_function_decl
specifier|static
name|uint8_t
name|RtlEqualUnicodeString
parameter_list|(
name|ndis_unicode_string
modifier|*
parameter_list|,
name|ndis_unicode_string
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|RtlCopyUnicodeString
parameter_list|(
name|ndis_unicode_string
modifier|*
parameter_list|,
name|ndis_unicode_string
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ndis_status
name|RtlUnicodeStringToAnsiString
parameter_list|(
name|ndis_ansi_string
modifier|*
parameter_list|,
name|ndis_unicode_string
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ndis_status
name|RtlAnsiStringToUnicodeString
parameter_list|(
name|ndis_unicode_string
modifier|*
parameter_list|,
name|ndis_ansi_string
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|irp
modifier|*
name|IoBuildSynchronousFsdRequest
parameter_list|(
name|uint32_t
parameter_list|,
name|device_object
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint64_t
modifier|*
parameter_list|,
name|nt_kevent
modifier|*
parameter_list|,
name|io_status_block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|irp
modifier|*
name|IoBuildAsynchronousFsdRequest
parameter_list|(
name|uint32_t
parameter_list|,
name|device_object
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint64_t
modifier|*
parameter_list|,
name|io_status_block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|irp
modifier|*
name|IoBuildDeviceIoControlRequest
parameter_list|(
name|uint32_t
parameter_list|,
name|device_object
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint8_t
parameter_list|,
name|nt_kevent
modifier|*
parameter_list|,
name|io_status_block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|irp
modifier|*
name|IoAllocateIrp
parameter_list|(
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|IoReuseIrp
parameter_list|(
name|irp
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|IoFreeIrp
parameter_list|(
name|irp
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|IoInitializeIrp
parameter_list|(
name|irp
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|irp
modifier|*
name|IoMakeAssociatedIrp
parameter_list|(
name|irp
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|KeWaitForMultipleObjects
parameter_list|(
name|uint32_t
parameter_list|,
name|nt_dispatch_header
modifier|*
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|,
name|uint8_t
parameter_list|,
name|int64_t
modifier|*
parameter_list|,
name|wait_block
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntoskrnl_wakeup
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntoskrnl_timercall
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntoskrnl_run_dpc
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntoskrnl_dpc_thread
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntoskrnl_destroy_dpc_threads
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntoskrnl_workitem_thread
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntoskrnl_workitem
parameter_list|(
name|device_object
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|ntoskrnl_insert_dpc
parameter_list|(
name|list_entry
modifier|*
parameter_list|,
name|kdpc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|WRITE_REGISTER_USHORT
parameter_list|(
name|uint16_t
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|READ_REGISTER_USHORT
parameter_list|(
name|uint16_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|WRITE_REGISTER_ULONG
parameter_list|(
name|uint32_t
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|READ_REGISTER_ULONG
parameter_list|(
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|WRITE_REGISTER_UCHAR
parameter_list|(
name|uint8_t
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|READ_REGISTER_UCHAR
parameter_list|(
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|_allmul
parameter_list|(
name|int64_t
parameter_list|,
name|int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|_alldiv
parameter_list|(
name|int64_t
parameter_list|,
name|int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|_allrem
parameter_list|(
name|int64_t
parameter_list|,
name|int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|_allshr
parameter_list|(
name|int64_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|_allshl
parameter_list|(
name|int64_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|_aullmul
parameter_list|(
name|uint64_t
parameter_list|,
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|_aulldiv
parameter_list|(
name|uint64_t
parameter_list|,
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|_aullrem
parameter_list|(
name|uint64_t
parameter_list|,
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|_aullshr
parameter_list|(
name|uint64_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|_aullshl
parameter_list|(
name|uint64_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|slist_entry
modifier|*
name|ntoskrnl_pushsl
parameter_list|(
name|slist_header
modifier|*
parameter_list|,
name|slist_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|slist_entry
modifier|*
name|ntoskrnl_popsl
parameter_list|(
name|slist_header
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ExInitializePagedLookasideList
parameter_list|(
name|paged_lookaside_list
modifier|*
parameter_list|,
name|lookaside_alloc_func
modifier|*
parameter_list|,
name|lookaside_free_func
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|size_t
parameter_list|,
name|uint32_t
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ExDeletePagedLookasideList
parameter_list|(
name|paged_lookaside_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ExInitializeNPagedLookasideList
parameter_list|(
name|npaged_lookaside_list
modifier|*
parameter_list|,
name|lookaside_alloc_func
modifier|*
parameter_list|,
name|lookaside_free_func
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|size_t
parameter_list|,
name|uint32_t
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ExDeleteNPagedLookasideList
parameter_list|(
name|npaged_lookaside_list
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|slist_entry
modifier|*
name|InterlockedPushEntrySList
parameter_list|(
name|slist_header
modifier|*
parameter_list|,
name|slist_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|slist_entry
modifier|*
name|InterlockedPopEntrySList
parameter_list|(
name|slist_header
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|slist_entry
modifier|*
name|ExInterlockedPushEntrySList
parameter_list|(
name|slist_header
modifier|*
parameter_list|,
name|slist_entry
modifier|*
parameter_list|,
name|kspin_lock
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|slist_entry
modifier|*
name|ExInterlockedPopEntrySList
parameter_list|(
name|slist_header
modifier|*
parameter_list|,
name|kspin_lock
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint16_t
name|ExQueryDepthSList
parameter_list|(
name|slist_header
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|InterlockedIncrement
parameter_list|(
specifier|volatile
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|InterlockedDecrement
parameter_list|(
specifier|volatile
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ExInterlockedAddLargeStatistic
parameter_list|(
name|uint64_t
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|MmSizeOfMdl
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|MmBuildMdlForNonPagedPool
parameter_list|(
name|mdl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|MmMapLockedPages
parameter_list|(
name|mdl
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|MmMapLockedPagesSpecifyCache
parameter_list|(
name|mdl
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|uint32_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|MmUnmapLockedPages
parameter_list|(
name|void
modifier|*
parameter_list|,
name|mdl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|MmIsAddressValid
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|RtlCompareMemory
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|RtlInitAnsiString
parameter_list|(
name|ndis_ansi_string
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|RtlInitUnicodeString
parameter_list|(
name|ndis_unicode_string
modifier|*
parameter_list|,
name|uint16_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|RtlFreeUnicodeString
parameter_list|(
name|ndis_unicode_string
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|RtlFreeAnsiString
parameter_list|(
name|ndis_ansi_string
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ndis_status
name|RtlUnicodeStringToInteger
parameter_list|(
name|ndis_unicode_string
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|atoi
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|atol
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rand
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|srand
parameter_list|(
name|unsigned
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntoskrnl_time
parameter_list|(
name|uint64_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint8_t
name|IoIsWdmVersionAvailable
parameter_list|(
name|uint8_t
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ntoskrnl_thrfunc
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ndis_status
name|PsCreateSystemThread
parameter_list|(
name|ndis_handle
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|ndis_handle
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ndis_status
name|PsTerminateSystemThread
parameter_list|(
name|ndis_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ndis_status
name|IoGetDeviceProperty
parameter_list|(
name|device_object
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|KeInitializeMutex
parameter_list|(
name|kmutant
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|KeReleaseMutex
parameter_list|(
name|kmutant
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|KeReadStateMutex
parameter_list|(
name|kmutant
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ndis_status
name|ObReferenceObjectByHandle
parameter_list|(
name|ndis_handle
parameter_list|,
name|uint32_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ObfDereferenceObject
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|ZwClose
parameter_list|(
name|ndis_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|ntoskrnl_memset
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|ntoskrnl_strstr
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|funcptr
name|ntoskrnl_findwrap
parameter_list|(
name|funcptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|DbgPrint
parameter_list|(
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|DbgBreakPoint
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dummy
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|ntoskrnl_dispatchlock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kspin_lock
name|ntoskrnl_global
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kspin_lock
name|ntoskrnl_cancellock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ntoskrnl_kth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nt_objref_head
name|ntoskrnl_reflist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|mdl_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|iw_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kdpc_queue
modifier|*
name|kq_queues
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kdpc_queue
modifier|*
name|wq_queue
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|ntoskrnl_libinit
parameter_list|()
block|{
name|image_patch_table
modifier|*
name|patch
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|kdpc_queue
modifier|*
name|kq
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|name
index|[
literal|64
index|]
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|,
literal|"ntoskrnl dispatch lock"
argument_list|,
name|MTX_NDIS_LOCK
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
name|KeInitializeSpinLock
argument_list|(
operator|&
name|ntoskrnl_global
argument_list|)
expr_stmt|;
name|KeInitializeSpinLock
argument_list|(
operator|&
name|ntoskrnl_cancellock
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ntoskrnl_reflist
argument_list|)
expr_stmt|;
name|kq_queues
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
sizeof|sizeof
argument_list|(
name|kdpc_queue
argument_list|)
operator|*
name|mp_ncpus
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|kq_queues
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|wq_queue
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
sizeof|sizeof
argument_list|(
name|kdpc_queue
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|wq_queue
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|kq_queues
argument_list|,
sizeof|sizeof
argument_list|(
name|kdpc_queue
argument_list|)
operator|*
name|mp_ncpus
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|wq_queue
argument_list|,
sizeof|sizeof
argument_list|(
name|kdpc_queue
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp_ncpus
condition|;
name|i
operator|++
control|)
block|{
name|kq
operator|=
name|kq_queues
operator|+
name|i
expr_stmt|;
name|kq
operator|->
name|kq_cpu
operator|=
name|i
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"Windows DPC %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|error
operator|=
name|kthread_create
argument_list|(
name|ntoskrnl_dpc_thread
argument_list|,
name|kq
argument_list|,
operator|&
name|p
argument_list|,
name|RFHIGHPID
argument_list|,
name|NDIS_KSTACK_PAGES
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"failed to launch DPC thread"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Launch the workitem thread. 	 */
name|error
operator|=
name|kthread_create
argument_list|(
name|ntoskrnl_workitem_thread
argument_list|,
name|wq_queue
argument_list|,
operator|&
name|p
argument_list|,
name|RFHIGHPID
argument_list|,
name|NDIS_KSTACK_PAGES
argument_list|,
literal|"Windows WorkItem"
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"failed to launch workitem thread"
argument_list|)
expr_stmt|;
name|patch
operator|=
name|ntoskrnl_functbl
expr_stmt|;
while|while
condition|(
name|patch
operator|->
name|ipt_func
operator|!=
name|NULL
condition|)
block|{
name|windrv_wrap
argument_list|(
operator|(
name|funcptr
operator|)
name|patch
operator|->
name|ipt_func
argument_list|,
operator|(
name|funcptr
operator|*
operator|)
operator|&
name|patch
operator|->
name|ipt_wrap
argument_list|,
name|patch
operator|->
name|ipt_argcnt
argument_list|,
name|patch
operator|->
name|ipt_ftype
argument_list|)
expr_stmt|;
name|patch
operator|++
expr_stmt|;
block|}
comment|/* 	 * MDLs are supposed to be variable size (they describe 	 * buffers containing some number of pages, but we don't 	 * know ahead of time how many pages that will be). But 	 * always allocating them off the heap is very slow. As 	 * a compromise, we create an MDL UMA zone big enough to 	 * handle any buffer requiring up to 16 pages, and we 	 * use those for any MDLs for buffers of 16 pages or less 	 * in size. For buffers larger than that (which we assume 	 * will be few and far between, we allocate the MDLs off 	 * the heap. 	 */
name|mdl_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"Windows MDL"
argument_list|,
name|MDL_ZONE_SIZE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iw_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"Windows WorkItem"
argument_list|,
sizeof|sizeof
argument_list|(
name|io_workitem
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ntoskrnl_libfini
parameter_list|()
block|{
name|image_patch_table
modifier|*
name|patch
decl_stmt|;
name|patch
operator|=
name|ntoskrnl_functbl
expr_stmt|;
while|while
condition|(
name|patch
operator|->
name|ipt_func
operator|!=
name|NULL
condition|)
block|{
name|windrv_unwrap
argument_list|(
name|patch
operator|->
name|ipt_wrap
argument_list|)
expr_stmt|;
name|patch
operator|++
expr_stmt|;
block|}
comment|/* Stop the DPC queues. */
name|ntoskrnl_destroy_dpc_threads
argument_list|()
expr_stmt|;
comment|/* Stop the workitem queue. */
name|wq_queue
operator|->
name|kq_exit
operator|=
literal|1
expr_stmt|;
name|KeSetEvent
argument_list|(
operator|&
name|wq_queue
operator|->
name|kq_proc
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|KeWaitForSingleObject
argument_list|(
operator|(
name|nt_dispatch_header
operator|*
operator|)
operator|&
name|wq_queue
operator|->
name|kq_dead
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ExFreePool
argument_list|(
name|kq_queues
argument_list|)
expr_stmt|;
name|ExFreePool
argument_list|(
name|wq_queue
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|mdl_zone
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|iw_zone
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We need to be able to reference this externally from the wrapper;  * GCC only generates a local implementation of memset.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|ntoskrnl_memset
parameter_list|(
name|buf
parameter_list|,
name|ch
parameter_list|,
name|size
parameter_list|)
name|void
modifier|*
name|buf
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|{
return|return
operator|(
name|memset
argument_list|(
name|buf
argument_list|,
name|ch
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|ntoskrnl_strstr
parameter_list|(
name|s
parameter_list|,
name|find
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|find
decl_stmt|;
end_function

begin_block
block|{
name|char
name|c
decl_stmt|,
name|sc
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|*
name|find
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|find
argument_list|)
expr_stmt|;
do|do
block|{
do|do
block|{
if|if
condition|(
operator|(
name|sc
operator|=
operator|*
name|s
operator|++
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
do|while
condition|(
name|sc
operator|!=
name|c
condition|)
do|;
block|}
do|while
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
name|find
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
do|;
name|s
operator|--
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|s
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|uint8_t
name|RtlEqualUnicodeString
parameter_list|(
name|str1
parameter_list|,
name|str2
parameter_list|,
name|caseinsensitive
parameter_list|)
name|ndis_unicode_string
modifier|*
name|str1
decl_stmt|;
name|ndis_unicode_string
modifier|*
name|str2
decl_stmt|;
name|uint8_t
name|caseinsensitive
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|str1
operator|->
name|us_len
operator|!=
name|str2
operator|->
name|us_len
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|str1
operator|->
name|us_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|caseinsensitive
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
name|toupper
argument_list|(
call|(
name|char
call|)
argument_list|(
name|str1
operator|->
name|us_buf
index|[
name|i
index|]
operator|&
literal|0xFF
argument_list|)
argument_list|)
operator|!=
name|toupper
argument_list|(
call|(
name|char
call|)
argument_list|(
name|str2
operator|->
name|us_buf
index|[
name|i
index|]
operator|&
literal|0xFF
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|str1
operator|->
name|us_buf
index|[
name|i
index|]
operator|!=
name|str2
operator|->
name|us_buf
index|[
name|i
index|]
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|RtlCopyUnicodeString
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|ndis_unicode_string
modifier|*
name|dest
decl_stmt|;
name|ndis_unicode_string
modifier|*
name|src
decl_stmt|;
block|{
if|if
condition|(
name|dest
operator|->
name|us_maxlen
operator|>=
name|src
operator|->
name|us_len
condition|)
name|dest
operator|->
name|us_len
operator|=
name|src
operator|->
name|us_len
expr_stmt|;
else|else
name|dest
operator|->
name|us_len
operator|=
name|dest
operator|->
name|us_maxlen
expr_stmt|;
name|memcpy
argument_list|(
name|dest
operator|->
name|us_buf
argument_list|,
name|src
operator|->
name|us_buf
argument_list|,
name|dest
operator|->
name|us_len
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|ndis_status
name|RtlUnicodeStringToAnsiString
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|,
name|allocate
parameter_list|)
name|ndis_ansi_string
modifier|*
name|dest
decl_stmt|;
name|ndis_unicode_string
modifier|*
name|src
decl_stmt|;
name|uint8_t
name|allocate
decl_stmt|;
block|{
name|char
modifier|*
name|astr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dest
operator|==
name|NULL
operator|||
name|src
operator|==
name|NULL
condition|)
return|return
operator|(
name|NDIS_STATUS_FAILURE
operator|)
return|;
if|if
condition|(
name|allocate
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
name|ndis_unicode_to_ascii
argument_list|(
name|src
operator|->
name|us_buf
argument_list|,
name|src
operator|->
name|us_len
argument_list|,
operator|&
name|astr
argument_list|)
condition|)
return|return
operator|(
name|NDIS_STATUS_FAILURE
operator|)
return|;
name|dest
operator|->
name|nas_buf
operator|=
name|astr
expr_stmt|;
name|dest
operator|->
name|nas_len
operator|=
name|dest
operator|->
name|nas_maxlen
operator|=
name|strlen
argument_list|(
name|astr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dest
operator|->
name|nas_len
operator|=
name|src
operator|->
name|us_len
operator|/
literal|2
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|dest
operator|->
name|nas_maxlen
operator|<
name|dest
operator|->
name|nas_len
condition|)
name|dest
operator|->
name|nas_len
operator|=
name|dest
operator|->
name|nas_maxlen
expr_stmt|;
name|ndis_unicode_to_ascii
argument_list|(
name|src
operator|->
name|us_buf
argument_list|,
name|dest
operator|->
name|nas_len
operator|*
literal|2
argument_list|,
operator|&
name|dest
operator|->
name|nas_buf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NDIS_STATUS_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ndis_status
name|RtlAnsiStringToUnicodeString
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|,
name|allocate
parameter_list|)
name|ndis_unicode_string
modifier|*
name|dest
decl_stmt|;
name|ndis_ansi_string
modifier|*
name|src
decl_stmt|;
name|uint8_t
name|allocate
decl_stmt|;
block|{
name|uint16_t
modifier|*
name|ustr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dest
operator|==
name|NULL
operator|||
name|src
operator|==
name|NULL
condition|)
return|return
operator|(
name|NDIS_STATUS_FAILURE
operator|)
return|;
if|if
condition|(
name|allocate
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
name|ndis_ascii_to_unicode
argument_list|(
name|src
operator|->
name|nas_buf
argument_list|,
operator|&
name|ustr
argument_list|)
condition|)
return|return
operator|(
name|NDIS_STATUS_FAILURE
operator|)
return|;
name|dest
operator|->
name|us_buf
operator|=
name|ustr
expr_stmt|;
name|dest
operator|->
name|us_len
operator|=
name|dest
operator|->
name|us_maxlen
operator|=
name|strlen
argument_list|(
name|src
operator|->
name|nas_buf
argument_list|)
operator|*
literal|2
expr_stmt|;
block|}
else|else
block|{
name|dest
operator|->
name|us_len
operator|=
name|src
operator|->
name|nas_len
operator|*
literal|2
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|dest
operator|->
name|us_maxlen
operator|<
name|dest
operator|->
name|us_len
condition|)
name|dest
operator|->
name|us_len
operator|=
name|dest
operator|->
name|us_maxlen
expr_stmt|;
name|ndis_ascii_to_unicode
argument_list|(
name|src
operator|->
name|nas_buf
argument_list|,
operator|&
name|dest
operator|->
name|us_buf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NDIS_STATUS_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|ExAllocatePoolWithTag
parameter_list|(
name|pooltype
parameter_list|,
name|len
parameter_list|,
name|tag
parameter_list|)
name|uint32_t
name|pooltype
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|uint32_t
name|tag
decl_stmt|;
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ExFreePool
parameter_list|(
name|buf
parameter_list|)
name|void
modifier|*
name|buf
decl_stmt|;
block|{
name|free
argument_list|(
name|buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|uint32_t
name|IoAllocateDriverObjectExtension
parameter_list|(
name|drv
parameter_list|,
name|clid
parameter_list|,
name|extlen
parameter_list|,
name|ext
parameter_list|)
name|driver_object
modifier|*
name|drv
decl_stmt|;
name|void
modifier|*
name|clid
decl_stmt|;
name|uint32_t
name|extlen
decl_stmt|;
name|void
modifier|*
modifier|*
name|ext
decl_stmt|;
block|{
name|custom_extension
modifier|*
name|ce
decl_stmt|;
name|ce
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
sizeof|sizeof
argument_list|(
name|custom_extension
argument_list|)
operator|+
name|extlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ce
operator|==
name|NULL
condition|)
return|return
operator|(
name|STATUS_INSUFFICIENT_RESOURCES
operator|)
return|;
name|ce
operator|->
name|ce_clid
operator|=
name|clid
expr_stmt|;
name|INSERT_LIST_TAIL
argument_list|(
operator|(
operator|&
name|drv
operator|->
name|dro_driverext
operator|->
name|dre_usrext
operator|)
argument_list|,
operator|(
operator|&
name|ce
operator|->
name|ce_list
operator|)
argument_list|)
expr_stmt|;
operator|*
name|ext
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|ce
operator|+
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|IoGetDriverObjectExtension
parameter_list|(
name|drv
parameter_list|,
name|clid
parameter_list|)
name|driver_object
modifier|*
name|drv
decl_stmt|;
name|void
modifier|*
name|clid
decl_stmt|;
block|{
name|list_entry
modifier|*
name|e
decl_stmt|;
name|custom_extension
modifier|*
name|ce
decl_stmt|;
comment|/* 	 * Sanity check. Our dummy bus drivers don't have 	 * any driver extentions. 	 */
if|if
condition|(
name|drv
operator|->
name|dro_driverext
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|e
operator|=
name|drv
operator|->
name|dro_driverext
operator|->
name|dre_usrext
operator|.
name|nle_flink
expr_stmt|;
while|while
condition|(
name|e
operator|!=
operator|&
name|drv
operator|->
name|dro_driverext
operator|->
name|dre_usrext
condition|)
block|{
name|ce
operator|=
operator|(
name|custom_extension
operator|*
operator|)
name|e
expr_stmt|;
if|if
condition|(
name|ce
operator|->
name|ce_clid
operator|==
name|clid
condition|)
return|return
operator|(
operator|(
name|void
operator|*
operator|)
operator|(
name|ce
operator|+
literal|1
operator|)
operator|)
return|;
name|e
operator|=
name|e
operator|->
name|nle_flink
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|IoCreateDevice
parameter_list|(
name|drv
parameter_list|,
name|devextlen
parameter_list|,
name|devname
parameter_list|,
name|devtype
parameter_list|,
name|devchars
parameter_list|,
name|exclusive
parameter_list|,
name|newdev
parameter_list|)
name|driver_object
modifier|*
name|drv
decl_stmt|;
name|uint32_t
name|devextlen
decl_stmt|;
name|unicode_string
modifier|*
name|devname
decl_stmt|;
name|uint32_t
name|devtype
decl_stmt|;
name|uint32_t
name|devchars
decl_stmt|;
name|uint8_t
name|exclusive
decl_stmt|;
name|device_object
modifier|*
modifier|*
name|newdev
decl_stmt|;
block|{
name|device_object
modifier|*
name|dev
decl_stmt|;
name|dev
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
sizeof|sizeof
argument_list|(
name|device_object
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|STATUS_INSUFFICIENT_RESOURCES
operator|)
return|;
name|dev
operator|->
name|do_type
operator|=
name|devtype
expr_stmt|;
name|dev
operator|->
name|do_drvobj
operator|=
name|drv
expr_stmt|;
name|dev
operator|->
name|do_currirp
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|do_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|devextlen
condition|)
block|{
name|dev
operator|->
name|do_devext
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
name|devextlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|do_devext
operator|==
name|NULL
condition|)
block|{
name|ExFreePool
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_INSUFFICIENT_RESOURCES
operator|)
return|;
block|}
name|bzero
argument_list|(
name|dev
operator|->
name|do_devext
argument_list|,
name|devextlen
argument_list|)
expr_stmt|;
block|}
else|else
name|dev
operator|->
name|do_devext
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|do_size
operator|=
sizeof|sizeof
argument_list|(
name|device_object
argument_list|)
operator|+
name|devextlen
expr_stmt|;
name|dev
operator|->
name|do_refcnt
operator|=
literal|1
expr_stmt|;
name|dev
operator|->
name|do_attacheddev
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|do_nextdev
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|do_devtype
operator|=
name|devtype
expr_stmt|;
name|dev
operator|->
name|do_stacksize
operator|=
literal|1
expr_stmt|;
name|dev
operator|->
name|do_alignreq
operator|=
literal|1
expr_stmt|;
name|dev
operator|->
name|do_characteristics
operator|=
name|devchars
expr_stmt|;
name|dev
operator|->
name|do_iotimer
operator|=
name|NULL
expr_stmt|;
name|KeInitializeEvent
argument_list|(
operator|&
name|dev
operator|->
name|do_devlock
argument_list|,
name|EVENT_TYPE_SYNC
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * Vpd is used for disk/tape devices, 	 * but we don't support those. (Yet.) 	 */
name|dev
operator|->
name|do_vpb
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|do_devobj_ext
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
sizeof|sizeof
argument_list|(
name|devobj_extension
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|do_devobj_ext
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|dev
operator|->
name|do_devext
operator|!=
name|NULL
condition|)
name|ExFreePool
argument_list|(
name|dev
operator|->
name|do_devext
argument_list|)
expr_stmt|;
name|ExFreePool
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_INSUFFICIENT_RESOURCES
operator|)
return|;
block|}
name|dev
operator|->
name|do_devobj_ext
operator|->
name|dve_type
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|do_devobj_ext
operator|->
name|dve_size
operator|=
sizeof|sizeof
argument_list|(
name|devobj_extension
argument_list|)
expr_stmt|;
name|dev
operator|->
name|do_devobj_ext
operator|->
name|dve_devobj
operator|=
name|dev
expr_stmt|;
comment|/* 	 * Attach this device to the driver object's list 	 * of devices. Note: this is not the same as attaching 	 * the device to the device stack. The driver's AddDevice 	 * routine must explicitly call IoAddDeviceToDeviceStack() 	 * to do that. 	 */
if|if
condition|(
name|drv
operator|->
name|dro_devobj
operator|==
name|NULL
condition|)
block|{
name|drv
operator|->
name|dro_devobj
operator|=
name|dev
expr_stmt|;
name|dev
operator|->
name|do_nextdev
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|do_nextdev
operator|=
name|drv
operator|->
name|dro_devobj
expr_stmt|;
name|drv
operator|->
name|dro_devobj
operator|=
name|dev
expr_stmt|;
block|}
operator|*
name|newdev
operator|=
name|dev
expr_stmt|;
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|IoDeleteDevice
parameter_list|(
name|dev
parameter_list|)
name|device_object
modifier|*
name|dev
decl_stmt|;
block|{
name|device_object
modifier|*
name|prev
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|dev
operator|->
name|do_devobj_ext
operator|!=
name|NULL
condition|)
name|ExFreePool
argument_list|(
name|dev
operator|->
name|do_devobj_ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|do_devext
operator|!=
name|NULL
condition|)
name|ExFreePool
argument_list|(
name|dev
operator|->
name|do_devext
argument_list|)
expr_stmt|;
comment|/* Unlink the device from the driver's device list. */
name|prev
operator|=
name|dev
operator|->
name|do_drvobj
operator|->
name|dro_devobj
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|dev
condition|)
name|dev
operator|->
name|do_drvobj
operator|->
name|dro_devobj
operator|=
name|dev
operator|->
name|do_nextdev
expr_stmt|;
else|else
block|{
while|while
condition|(
name|prev
operator|->
name|do_nextdev
operator|!=
name|dev
condition|)
name|prev
operator|=
name|prev
operator|->
name|do_nextdev
expr_stmt|;
name|prev
operator|->
name|do_nextdev
operator|=
name|dev
operator|->
name|do_nextdev
expr_stmt|;
block|}
name|ExFreePool
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|device_object
modifier|*
name|IoGetAttachedDevice
parameter_list|(
name|dev
parameter_list|)
name|device_object
modifier|*
name|dev
decl_stmt|;
block|{
name|device_object
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|d
operator|=
name|dev
expr_stmt|;
while|while
condition|(
name|d
operator|->
name|do_attacheddev
operator|!=
name|NULL
condition|)
name|d
operator|=
name|d
operator|->
name|do_attacheddev
expr_stmt|;
return|return
operator|(
name|d
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|irp
modifier|*
name|IoBuildSynchronousFsdRequest
parameter_list|(
name|func
parameter_list|,
name|dobj
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|off
parameter_list|,
name|event
parameter_list|,
name|status
parameter_list|)
name|uint32_t
name|func
decl_stmt|;
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|uint64_t
modifier|*
name|off
decl_stmt|;
name|nt_kevent
modifier|*
name|event
decl_stmt|;
name|io_status_block
modifier|*
name|status
decl_stmt|;
block|{
name|irp
modifier|*
name|ip
decl_stmt|;
name|ip
operator|=
name|IoBuildAsynchronousFsdRequest
argument_list|(
name|func
argument_list|,
name|dobj
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|off
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ip
operator|->
name|irp_usrevent
operator|=
name|event
expr_stmt|;
return|return
operator|(
name|ip
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|irp
modifier|*
name|IoBuildAsynchronousFsdRequest
parameter_list|(
name|func
parameter_list|,
name|dobj
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|off
parameter_list|,
name|status
parameter_list|)
name|uint32_t
name|func
decl_stmt|;
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|uint64_t
modifier|*
name|off
decl_stmt|;
name|io_status_block
modifier|*
name|status
decl_stmt|;
block|{
name|irp
modifier|*
name|ip
decl_stmt|;
name|io_stack_location
modifier|*
name|sl
decl_stmt|;
name|ip
operator|=
name|IoAllocateIrp
argument_list|(
name|dobj
operator|->
name|do_stacksize
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ip
operator|->
name|irp_usriostat
operator|=
name|status
expr_stmt|;
name|ip
operator|->
name|irp_tail
operator|.
name|irp_overlay
operator|.
name|irp_thread
operator|=
name|NULL
expr_stmt|;
name|sl
operator|=
name|IoGetNextIrpStackLocation
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|sl
operator|->
name|isl_major
operator|=
name|func
expr_stmt|;
name|sl
operator|->
name|isl_minor
operator|=
literal|0
expr_stmt|;
name|sl
operator|->
name|isl_flags
operator|=
literal|0
expr_stmt|;
name|sl
operator|->
name|isl_ctl
operator|=
literal|0
expr_stmt|;
name|sl
operator|->
name|isl_devobj
operator|=
name|dobj
expr_stmt|;
name|sl
operator|->
name|isl_fileobj
operator|=
name|NULL
expr_stmt|;
name|sl
operator|->
name|isl_completionfunc
operator|=
name|NULL
expr_stmt|;
name|ip
operator|->
name|irp_userbuf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|dobj
operator|->
name|do_flags
operator|&
name|DO_BUFFERED_IO
condition|)
block|{
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
operator|==
name|NULL
condition|)
block|{
name|IoFreeIrp
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|buf
argument_list|,
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dobj
operator|->
name|do_flags
operator|&
name|DO_DIRECT_IO
condition|)
block|{
name|ip
operator|->
name|irp_mdl
operator|=
name|IoAllocateMdl
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|irp_mdl
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
operator|!=
name|NULL
condition|)
name|ExFreePool
argument_list|(
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
argument_list|)
expr_stmt|;
name|IoFreeIrp
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ip
operator|->
name|irp_userbuf
operator|=
name|NULL
expr_stmt|;
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|func
operator|==
name|IRP_MJ_READ
condition|)
block|{
name|sl
operator|->
name|isl_parameters
operator|.
name|isl_read
operator|.
name|isl_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|off
operator|!=
name|NULL
condition|)
name|sl
operator|->
name|isl_parameters
operator|.
name|isl_read
operator|.
name|isl_byteoff
operator|=
operator|*
name|off
expr_stmt|;
else|else
name|sl
operator|->
name|isl_parameters
operator|.
name|isl_read
operator|.
name|isl_byteoff
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|func
operator|==
name|IRP_MJ_WRITE
condition|)
block|{
name|sl
operator|->
name|isl_parameters
operator|.
name|isl_write
operator|.
name|isl_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|off
operator|!=
name|NULL
condition|)
name|sl
operator|->
name|isl_parameters
operator|.
name|isl_write
operator|.
name|isl_byteoff
operator|=
operator|*
name|off
expr_stmt|;
else|else
name|sl
operator|->
name|isl_parameters
operator|.
name|isl_write
operator|.
name|isl_byteoff
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|ip
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|irp
modifier|*
name|IoBuildDeviceIoControlRequest
parameter_list|(
name|iocode
parameter_list|,
name|dobj
parameter_list|,
name|ibuf
parameter_list|,
name|ilen
parameter_list|,
name|obuf
parameter_list|,
name|olen
parameter_list|,
name|isinternal
parameter_list|,
name|event
parameter_list|,
name|status
parameter_list|)
name|uint32_t
name|iocode
decl_stmt|;
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|void
modifier|*
name|ibuf
decl_stmt|;
name|uint32_t
name|ilen
decl_stmt|;
name|void
modifier|*
name|obuf
decl_stmt|;
name|uint32_t
name|olen
decl_stmt|;
name|uint8_t
name|isinternal
decl_stmt|;
name|nt_kevent
modifier|*
name|event
decl_stmt|;
name|io_status_block
modifier|*
name|status
decl_stmt|;
block|{
name|irp
modifier|*
name|ip
decl_stmt|;
name|io_stack_location
modifier|*
name|sl
decl_stmt|;
name|uint32_t
name|buflen
decl_stmt|;
name|ip
operator|=
name|IoAllocateIrp
argument_list|(
name|dobj
operator|->
name|do_stacksize
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ip
operator|->
name|irp_usrevent
operator|=
name|event
expr_stmt|;
name|ip
operator|->
name|irp_usriostat
operator|=
name|status
expr_stmt|;
name|ip
operator|->
name|irp_tail
operator|.
name|irp_overlay
operator|.
name|irp_thread
operator|=
name|NULL
expr_stmt|;
name|sl
operator|=
name|IoGetNextIrpStackLocation
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|sl
operator|->
name|isl_major
operator|=
name|isinternal
operator|==
name|TRUE
condition|?
name|IRP_MJ_INTERNAL_DEVICE_CONTROL
else|:
name|IRP_MJ_DEVICE_CONTROL
expr_stmt|;
name|sl
operator|->
name|isl_minor
operator|=
literal|0
expr_stmt|;
name|sl
operator|->
name|isl_flags
operator|=
literal|0
expr_stmt|;
name|sl
operator|->
name|isl_ctl
operator|=
literal|0
expr_stmt|;
name|sl
operator|->
name|isl_devobj
operator|=
name|dobj
expr_stmt|;
name|sl
operator|->
name|isl_fileobj
operator|=
name|NULL
expr_stmt|;
name|sl
operator|->
name|isl_completionfunc
operator|=
name|NULL
expr_stmt|;
name|sl
operator|->
name|isl_parameters
operator|.
name|isl_ioctl
operator|.
name|isl_iocode
operator|=
name|iocode
expr_stmt|;
name|sl
operator|->
name|isl_parameters
operator|.
name|isl_ioctl
operator|.
name|isl_ibuflen
operator|=
name|ilen
expr_stmt|;
name|sl
operator|->
name|isl_parameters
operator|.
name|isl_ioctl
operator|.
name|isl_obuflen
operator|=
name|olen
expr_stmt|;
switch|switch
condition|(
name|IO_METHOD
argument_list|(
name|iocode
argument_list|)
condition|)
block|{
case|case
name|METHOD_BUFFERED
case|:
if|if
condition|(
name|ilen
operator|>
name|olen
condition|)
name|buflen
operator|=
name|ilen
expr_stmt|;
else|else
name|buflen
operator|=
name|olen
expr_stmt|;
if|if
condition|(
name|buflen
condition|)
block|{
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
name|buflen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
operator|==
name|NULL
condition|)
block|{
name|IoFreeIrp
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ilen
operator|&&
name|ibuf
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|ibuf
argument_list|,
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
operator|+
name|ilen
argument_list|,
name|buflen
operator|-
name|ilen
argument_list|)
expr_stmt|;
block|}
else|else
name|bzero
argument_list|(
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
name|ip
operator|->
name|irp_userbuf
operator|=
name|obuf
expr_stmt|;
break|break;
case|case
name|METHOD_IN_DIRECT
case|:
case|case
name|METHOD_OUT_DIRECT
case|:
if|if
condition|(
name|ilen
operator|&&
name|ibuf
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
name|ilen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
operator|==
name|NULL
condition|)
block|{
name|IoFreeIrp
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|ibuf
argument_list|,
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_sysbuf
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|olen
operator|&&
name|obuf
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|->
name|irp_mdl
operator|=
name|IoAllocateMdl
argument_list|(
name|obuf
argument_list|,
name|olen
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|ip
argument_list|)
expr_stmt|;
comment|/* 			 * Normally we would MmProbeAndLockPages() 			 * here, but we don't have to in our 			 * imlementation. 			 */
block|}
break|break;
case|case
name|METHOD_NEITHER
case|:
name|ip
operator|->
name|irp_userbuf
operator|=
name|obuf
expr_stmt|;
name|sl
operator|->
name|isl_parameters
operator|.
name|isl_ioctl
operator|.
name|isl_type3ibuf
operator|=
name|ibuf
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 	 * Ideally, we should associate this IRP with the calling 	 * thread here. 	 */
return|return
operator|(
name|ip
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|irp
modifier|*
name|IoAllocateIrp
parameter_list|(
name|stsize
parameter_list|,
name|chargequota
parameter_list|)
name|uint8_t
name|stsize
decl_stmt|;
name|uint8_t
name|chargequota
decl_stmt|;
block|{
name|irp
modifier|*
name|i
decl_stmt|;
name|i
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
name|IoSizeOfIrp
argument_list|(
name|stsize
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|IoInitializeIrp
argument_list|(
name|i
argument_list|,
name|IoSizeOfIrp
argument_list|(
name|stsize
argument_list|)
argument_list|,
name|stsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|irp
modifier|*
name|IoMakeAssociatedIrp
parameter_list|(
name|ip
parameter_list|,
name|stsize
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
name|uint8_t
name|stsize
decl_stmt|;
block|{
name|irp
modifier|*
name|associrp
decl_stmt|;
name|associrp
operator|=
name|IoAllocateIrp
argument_list|(
name|stsize
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|associrp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|associrp
operator|->
name|irp_flags
operator||=
name|IRP_ASSOCIATED_IRP
expr_stmt|;
name|associrp
operator|->
name|irp_tail
operator|.
name|irp_overlay
operator|.
name|irp_thread
operator|=
name|ip
operator|->
name|irp_tail
operator|.
name|irp_overlay
operator|.
name|irp_thread
expr_stmt|;
name|associrp
operator|->
name|irp_assoc
operator|.
name|irp_master
operator|=
name|ip
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|associrp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|IoFreeIrp
parameter_list|(
name|ip
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|ExFreePool
argument_list|(
name|ip
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|IoInitializeIrp
parameter_list|(
name|io
parameter_list|,
name|psize
parameter_list|,
name|ssize
parameter_list|)
name|irp
modifier|*
name|io
decl_stmt|;
name|uint16_t
name|psize
decl_stmt|;
name|uint8_t
name|ssize
decl_stmt|;
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|io
argument_list|,
name|IoSizeOfIrp
argument_list|(
name|ssize
argument_list|)
argument_list|)
expr_stmt|;
name|io
operator|->
name|irp_size
operator|=
name|psize
expr_stmt|;
name|io
operator|->
name|irp_stackcnt
operator|=
name|ssize
expr_stmt|;
name|io
operator|->
name|irp_currentstackloc
operator|=
name|ssize
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|io
operator|->
name|irp_thlist
argument_list|)
expr_stmt|;
name|io
operator|->
name|irp_tail
operator|.
name|irp_overlay
operator|.
name|irp_csl
operator|=
operator|(
name|io_stack_location
operator|*
operator|)
operator|(
name|io
operator|+
literal|1
operator|)
operator|+
name|ssize
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|IoReuseIrp
parameter_list|(
name|ip
parameter_list|,
name|status
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
block|{
name|uint8_t
name|allocflags
decl_stmt|;
name|allocflags
operator|=
name|ip
operator|->
name|irp_allocflags
expr_stmt|;
name|IoInitializeIrp
argument_list|(
name|ip
argument_list|,
name|ip
operator|->
name|irp_size
argument_list|,
name|ip
operator|->
name|irp_stackcnt
argument_list|)
expr_stmt|;
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|=
name|status
expr_stmt|;
name|ip
operator|->
name|irp_allocflags
operator|=
name|allocflags
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|IoAcquireCancelSpinLock
parameter_list|(
name|irql
parameter_list|)
name|uint8_t
modifier|*
name|irql
decl_stmt|;
block|{
name|KeAcquireSpinLock
argument_list|(
operator|&
name|ntoskrnl_cancellock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|IoReleaseCancelSpinLock
parameter_list|(
name|irql
parameter_list|)
name|uint8_t
name|irql
decl_stmt|;
block|{
name|KeReleaseSpinLock
argument_list|(
operator|&
name|ntoskrnl_cancellock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|uint8_t
name|IoCancelIrp
parameter_list|(
name|irp
modifier|*
name|ip
parameter_list|)
block|{
name|cancel_func
name|cfunc
decl_stmt|;
name|IoAcquireCancelSpinLock
argument_list|(
operator|&
name|ip
operator|->
name|irp_cancelirql
argument_list|)
expr_stmt|;
name|cfunc
operator|=
name|IoSetCancelRoutine
argument_list|(
name|ip
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ip
operator|->
name|irp_cancel
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|irp_cancelfunc
operator|==
name|NULL
condition|)
block|{
name|IoReleaseCancelSpinLock
argument_list|(
name|ip
operator|->
name|irp_cancelirql
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|MSCALL2
argument_list|(
name|cfunc
argument_list|,
name|IoGetCurrentIrpStackLocation
argument_list|(
name|ip
argument_list|)
operator|->
name|isl_devobj
argument_list|,
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|IofCallDriver
parameter_list|(
name|dobj
parameter_list|,
name|ip
parameter_list|)
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|irp
modifier|*
name|ip
decl_stmt|;
block|{
name|driver_object
modifier|*
name|drvobj
decl_stmt|;
name|io_stack_location
modifier|*
name|sl
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|driver_dispatch
name|disp
decl_stmt|;
name|drvobj
operator|=
name|dobj
operator|->
name|do_drvobj
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|irp_currentstackloc
operator|<=
literal|0
condition|)
name|panic
argument_list|(
literal|"IoCallDriver(): out of stack locations"
argument_list|)
expr_stmt|;
name|IoSetNextIrpStackLocation
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|sl
operator|=
name|IoGetCurrentIrpStackLocation
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|sl
operator|->
name|isl_devobj
operator|=
name|dobj
expr_stmt|;
name|disp
operator|=
name|drvobj
operator|->
name|dro_dispatch
index|[
name|sl
operator|->
name|isl_major
index|]
expr_stmt|;
name|status
operator|=
name|MSCALL2
argument_list|(
name|disp
argument_list|,
name|dobj
argument_list|,
name|ip
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
name|void
name|IofCompleteRequest
parameter_list|(
name|ip
parameter_list|,
name|prioboost
parameter_list|)
name|irp
modifier|*
name|ip
decl_stmt|;
name|uint8_t
name|prioboost
decl_stmt|;
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|io_stack_location
modifier|*
name|sl
decl_stmt|;
name|completion_func
name|cf
decl_stmt|;
name|ip
operator|->
name|irp_pendingreturned
operator|=
name|IoGetCurrentIrpStackLocation
argument_list|(
name|ip
argument_list|)
operator|->
name|isl_ctl
operator|&
name|SL_PENDING_RETURNED
expr_stmt|;
name|sl
operator|=
operator|(
name|io_stack_location
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ip
operator|->
name|irp_currentstackloc
init|;
name|i
operator|<
operator|(
name|uint32_t
operator|)
name|ip
operator|->
name|irp_stackcnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ip
operator|->
name|irp_currentstackloc
operator|<
name|ip
operator|->
name|irp_stackcnt
operator|-
literal|1
condition|)
block|{
name|IoSkipCurrentIrpStackLocation
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|dobj
operator|=
name|IoGetCurrentIrpStackLocation
argument_list|(
name|ip
argument_list|)
operator|->
name|isl_devobj
expr_stmt|;
block|}
else|else
name|dobj
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sl
index|[
name|i
index|]
operator|.
name|isl_completionfunc
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|==
name|STATUS_SUCCESS
operator|&&
name|sl
operator|->
name|isl_ctl
operator|&
name|SL_INVOKE_ON_SUCCESS
operator|)
operator|||
operator|(
name|ip
operator|->
name|irp_iostat
operator|.
name|isb_status
operator|!=
name|STATUS_SUCCESS
operator|&&
name|sl
operator|->
name|isl_ctl
operator|&
name|SL_INVOKE_ON_ERROR
operator|)
operator|||
operator|(
name|ip
operator|->
name|irp_cancel
operator|==
name|TRUE
operator|&&
name|sl
operator|->
name|isl_ctl
operator|&
name|SL_INVOKE_ON_CANCEL
operator|)
operator|)
condition|)
block|{
name|cf
operator|=
name|sl
operator|->
name|isl_completionfunc
expr_stmt|;
name|status
operator|=
name|MSCALL3
argument_list|(
name|cf
argument_list|,
name|dobj
argument_list|,
name|ip
argument_list|,
name|sl
operator|->
name|isl_completionctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|STATUS_MORE_PROCESSING_REQUIRED
condition|)
return|return;
block|}
if|if
condition|(
name|IoGetCurrentIrpStackLocation
argument_list|(
name|ip
argument_list|)
operator|->
name|isl_ctl
operator|&
name|SL_PENDING_RETURNED
condition|)
name|ip
operator|->
name|irp_pendingreturned
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Handle any associated IRPs. */
if|if
condition|(
name|ip
operator|->
name|irp_flags
operator|&
name|IRP_ASSOCIATED_IRP
condition|)
block|{
name|uint32_t
name|masterirpcnt
decl_stmt|;
name|irp
modifier|*
name|masterirp
decl_stmt|;
name|mdl
modifier|*
name|m
decl_stmt|;
name|masterirp
operator|=
name|ip
operator|->
name|irp_assoc
operator|.
name|irp_master
expr_stmt|;
name|masterirpcnt
operator|=
name|InterlockedDecrement
argument_list|(
operator|&
name|masterirp
operator|->
name|irp_assoc
operator|.
name|irp_irpcnt
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|ip
operator|->
name|irp_mdl
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|->
name|irp_mdl
operator|=
name|m
operator|->
name|mdl_next
expr_stmt|;
name|IoFreeMdl
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|IoFreeIrp
argument_list|(
name|ip
argument_list|)
expr_stmt|;
if|if
condition|(
name|masterirpcnt
operator|==
literal|0
condition|)
name|IoCompleteRequest
argument_list|(
name|masterirp
argument_list|,
name|IO_NO_INCREMENT
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* With any luck, these conditions will never arise. */
if|if
condition|(
name|ip
operator|->
name|irp_flags
operator|&
operator|(
name|IRP_PAGING_IO
operator||
name|IRP_CLOSE_OPERATION
operator|)
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|irp_usriostat
operator|!=
name|NULL
condition|)
operator|*
name|ip
operator|->
name|irp_usriostat
operator|=
name|ip
operator|->
name|irp_iostat
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|irp_usrevent
operator|!=
name|NULL
condition|)
name|KeSetEvent
argument_list|(
name|ip
operator|->
name|irp_usrevent
argument_list|,
name|prioboost
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|irp_flags
operator|&
name|IRP_PAGING_IO
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|irp_mdl
operator|!=
name|NULL
condition|)
name|IoFreeMdl
argument_list|(
name|ip
operator|->
name|irp_mdl
argument_list|)
expr_stmt|;
name|IoFreeIrp
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
name|device_object
modifier|*
name|IoAttachDeviceToDeviceStack
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
name|device_object
modifier|*
name|src
decl_stmt|;
name|device_object
modifier|*
name|dst
decl_stmt|;
block|{
name|device_object
modifier|*
name|attached
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|attached
operator|=
name|IoGetAttachedDevice
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|attached
operator|->
name|do_attacheddev
operator|=
name|src
expr_stmt|;
name|src
operator|->
name|do_attacheddev
operator|=
name|NULL
expr_stmt|;
name|src
operator|->
name|do_stacksize
operator|=
name|attached
operator|->
name|do_stacksize
operator|+
literal|1
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|attached
operator|)
return|;
block|}
end_function

begin_function
name|void
name|IoDetachDevice
parameter_list|(
name|topdev
parameter_list|)
name|device_object
modifier|*
name|topdev
decl_stmt|;
block|{
name|device_object
modifier|*
name|tail
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
comment|/* First, break the chain. */
name|tail
operator|=
name|topdev
operator|->
name|do_attacheddev
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return;
block|}
name|topdev
operator|->
name|do_attacheddev
operator|=
name|tail
operator|->
name|do_attacheddev
expr_stmt|;
name|topdev
operator|->
name|do_refcnt
operator|--
expr_stmt|;
comment|/* Now reduce the stacksize count for the tail objects. */
name|tail
operator|=
name|topdev
operator|->
name|do_attacheddev
expr_stmt|;
while|while
condition|(
name|tail
operator|!=
name|NULL
condition|)
block|{
name|tail
operator|->
name|do_stacksize
operator|--
expr_stmt|;
name|tail
operator|=
name|tail
operator|->
name|do_attacheddev
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Always called with dispatcher lock held. */
end_comment

begin_function
specifier|static
name|void
name|ntoskrnl_wakeup
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|nt_dispatch_header
modifier|*
name|obj
decl_stmt|;
name|wait_block
modifier|*
name|w
decl_stmt|;
name|list_entry
modifier|*
name|e
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|obj
operator|=
name|arg
expr_stmt|;
name|e
operator|=
name|obj
operator|->
name|dh_waitlisthead
operator|.
name|nle_flink
expr_stmt|;
comment|/* 	 * What happens if someone tells us to wake up 	 * threads waiting on an object, but nobody's 	 * waiting on it at the moment? For sync events, 	 * the signal state is supposed to be automatically 	 * reset, but this only happens in the KeWaitXXX() 	 * functions. If nobody is waiting, the state never 	 * gets cleared. 	 */
if|if
condition|(
name|e
operator|==
operator|&
name|obj
operator|->
name|dh_waitlisthead
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|dh_type
operator|==
name|EVENT_TYPE_SYNC
condition|)
name|obj
operator|->
name|dh_sigstate
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
name|obj
operator|->
name|dh_sigstate
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
name|e
operator|!=
operator|&
name|obj
operator|->
name|dh_waitlisthead
condition|)
block|{
name|w
operator|=
operator|(
name|wait_block
operator|*
operator|)
name|e
expr_stmt|;
name|td
operator|=
name|w
operator|->
name|wb_kthread
expr_stmt|;
name|ndis_thresume
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
comment|/* 		 * For synchronization objects, only wake up 		 * the first waiter. 		 */
if|if
condition|(
name|obj
operator|->
name|dh_type
operator|==
name|EVENT_TYPE_SYNC
condition|)
break|break;
name|e
operator|=
name|e
operator|->
name|nle_flink
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ntoskrnl_time
parameter_list|(
name|tval
parameter_list|)
name|uint64_t
modifier|*
name|tval
decl_stmt|;
block|{
name|struct
name|timespec
name|ts
decl_stmt|;
name|nanotime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
operator|*
name|tval
operator|=
operator|(
name|uint64_t
operator|)
name|ts
operator|.
name|tv_nsec
operator|/
literal|100
operator|+
operator|(
name|uint64_t
operator|)
name|ts
operator|.
name|tv_sec
operator|*
literal|10000000
operator|+
literal|11644473600
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * KeWaitForSingleObject() is a tricky beast, because it can be used  * with several different object types: semaphores, timers, events,  * mutexes and threads. Semaphores don't appear very often, but the  * other object types are quite common. KeWaitForSingleObject() is  * what's normally used to acquire a mutex, and it can be used to  * wait for a thread termination.  *  * The Windows NDIS API is implemented in terms of Windows kernel  * primitives, and some of the object manipulation is duplicated in  * NDIS. For example, NDIS has timers and events, which are actually  * Windows kevents and ktimers. Now, you're supposed to only use the  * NDIS variants of these objects within the confines of the NDIS API,  * but there are some naughty developers out there who will use  * KeWaitForSingleObject() on NDIS timer and event objects, so we  * have to support that as well. Conseqently, our NDIS timer and event  * code has to be closely tied into our ntoskrnl timer and event code,  * just as it is in Windows.  *  * KeWaitForSingleObject() may do different things for different kinds  * of objects:  *  * - For events, we check if the event has been signalled. If the  *   event is already in the signalled state, we just return immediately,  *   otherwise we wait for it to be set to the signalled state by someone  *   else calling KeSetEvent(). Events can be either synchronization or  *   notification events.  *  * - For timers, if the timer has already fired and the timer is in  *   the signalled state, we just return, otherwise we wait on the  *   timer. Unlike an event, timers get signalled automatically when  *   they expire rather than someone having to trip them manually.  *   Timers initialized with KeInitializeTimer() are always notification  *   events: KeInitializeTimerEx() lets you initialize a timer as  *   either a notification or synchronization event.  *  * - For mutexes, we try to acquire the mutex and if we can't, we wait  *   on the mutex until it's available and then grab it. When a mutex is  *   released, it enters the signaled state, which wakes up one of the  *   threads waiting to acquire it. Mutexes are always synchronization  *   events.  *  * - For threads, the only thing we do is wait until the thread object  *   enters a signalled state, which occurs when the thread terminates.  *   Threads are always notification events.  *  * A notification event wakes up all threads waiting on an object. A  * synchronization event wakes up just one. Also, a synchronization event  * is auto-clearing, which means we automatically set the event back to  * the non-signalled state once the wakeup is done.  */
end_comment

begin_function
name|uint32_t
name|KeWaitForSingleObject
parameter_list|(
name|obj
parameter_list|,
name|reason
parameter_list|,
name|mode
parameter_list|,
name|alertable
parameter_list|,
name|duetime
parameter_list|)
name|nt_dispatch_header
modifier|*
name|obj
decl_stmt|;
name|uint32_t
name|reason
decl_stmt|;
name|uint32_t
name|mode
decl_stmt|;
name|uint8_t
name|alertable
decl_stmt|;
name|int64_t
modifier|*
name|duetime
decl_stmt|;
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|kmutant
modifier|*
name|km
decl_stmt|;
name|wait_block
name|w
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint64_t
name|curtime
decl_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
return|return
operator|(
name|STATUS_INVALID_PARAMETER
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
comment|/* 	 * See if the object is a mutex. If so, and we already own 	 * it, then just increment the acquisition count and return.          *          * For any other kind of object, see if it's already in the 	 * signalled state, and if it is, just return. If the object          * is marked as a synchronization event, reset the state to          * unsignalled. 	 */
if|if
condition|(
name|obj
operator|->
name|dh_size
operator|==
name|OTYPE_MUTEX
condition|)
block|{
name|km
operator|=
operator|(
name|kmutant
operator|*
operator|)
name|obj
expr_stmt|;
if|if
condition|(
name|km
operator|->
name|km_ownerthread
operator|==
name|NULL
operator|||
name|km
operator|->
name|km_ownerthread
operator|==
name|curthread
operator|->
name|td_proc
condition|)
block|{
name|obj
operator|->
name|dh_sigstate
operator|=
name|FALSE
expr_stmt|;
name|km
operator|->
name|km_acquirecnt
operator|++
expr_stmt|;
name|km
operator|->
name|km_ownerthread
operator|=
name|curthread
operator|->
name|td_proc
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|obj
operator|->
name|dh_sigstate
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|dh_type
operator|==
name|EVENT_TYPE_SYNC
condition|)
name|obj
operator|->
name|dh_sigstate
operator|=
name|FALSE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
name|w
operator|.
name|wb_object
operator|=
name|obj
expr_stmt|;
name|w
operator|.
name|wb_kthread
operator|=
name|td
expr_stmt|;
name|INSERT_LIST_TAIL
argument_list|(
operator|(
operator|&
name|obj
operator|->
name|dh_waitlisthead
operator|)
argument_list|,
operator|(
operator|&
name|w
operator|.
name|wb_waitlist
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * The timeout value is specified in 100 nanosecond units 	 * and can be a positive or negative number. If it's positive, 	 * then the duetime is absolute, and we need to convert it 	 * to an absolute offset relative to now in order to use it. 	 * If it's negative, then the duetime is relative and we 	 * just have to convert the units. 	 */
if|if
condition|(
name|duetime
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|duetime
operator|<
literal|0
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|=
operator|-
operator|(
operator|*
name|duetime
operator|)
operator|/
literal|10000000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
operator|-
operator|(
operator|*
name|duetime
operator|)
operator|/
literal|10
operator|)
operator|-
operator|(
name|tv
operator|.
name|tv_sec
operator|*
literal|1000000
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ntoskrnl_time
argument_list|(
operator|&
name|curtime
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|duetime
operator|<
name|curtime
condition|)
name|tv
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|tv
operator|.
name|tv_sec
operator|=
operator|(
operator|(
operator|*
name|duetime
operator|)
operator|-
name|curtime
operator|)
operator|/
literal|10000000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
operator|(
operator|*
name|duetime
operator|)
operator|-
name|curtime
operator|)
operator|/
literal|10
operator|-
operator|(
name|tv
operator|.
name|tv_sec
operator|*
literal|1000000
operator|)
expr_stmt|;
block|}
block|}
block|}
name|error
operator|=
name|ndis_thsuspend
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
operator|&
name|ntoskrnl_dispatchlock
argument_list|,
name|duetime
operator|==
name|NULL
condition|?
literal|0
else|:
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We timed out. Leave the object alone and return status. */
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|REMOVE_LIST_ENTRY
argument_list|(
operator|(
operator|&
name|w
operator|.
name|wb_waitlist
operator|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_TIMEOUT
operator|)
return|;
block|}
comment|/* 	 * Mutexes are always synchronization objects, which means          * if several threads are waiting to acquire it, only one will          * be woken up. If that one is us, and the mutex is up for grabs,          * grab it. 	 */
if|if
condition|(
name|obj
operator|->
name|dh_size
operator|==
name|OTYPE_MUTEX
condition|)
block|{
name|km
operator|=
operator|(
name|kmutant
operator|*
operator|)
name|obj
expr_stmt|;
if|if
condition|(
name|km
operator|->
name|km_ownerthread
operator|==
name|NULL
condition|)
block|{
name|km
operator|->
name|km_ownerthread
operator|=
name|curthread
operator|->
name|td_proc
expr_stmt|;
name|km
operator|->
name|km_acquirecnt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|obj
operator|->
name|dh_type
operator|==
name|EVENT_TYPE_SYNC
condition|)
name|obj
operator|->
name|dh_sigstate
operator|=
name|FALSE
expr_stmt|;
name|REMOVE_LIST_ENTRY
argument_list|(
operator|(
operator|&
name|w
operator|.
name|wb_waitlist
operator|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|KeWaitForMultipleObjects
parameter_list|(
name|cnt
parameter_list|,
name|obj
parameter_list|,
name|wtype
parameter_list|,
name|reason
parameter_list|,
name|mode
parameter_list|,
name|alertable
parameter_list|,
name|duetime
parameter_list|,
name|wb_array
parameter_list|)
name|uint32_t
name|cnt
decl_stmt|;
name|nt_dispatch_header
modifier|*
name|obj
index|[]
decl_stmt|;
name|uint32_t
name|wtype
decl_stmt|;
name|uint32_t
name|reason
decl_stmt|;
name|uint32_t
name|mode
decl_stmt|;
name|uint8_t
name|alertable
decl_stmt|;
name|int64_t
modifier|*
name|duetime
decl_stmt|;
name|wait_block
modifier|*
name|wb_array
decl_stmt|;
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|kmutant
modifier|*
name|km
decl_stmt|;
name|wait_block
name|_wb_array
index|[
name|THREAD_WAIT_OBJECTS
index|]
decl_stmt|;
name|wait_block
modifier|*
name|w
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|i
decl_stmt|,
name|wcnt
init|=
literal|0
decl_stmt|,
name|widx
init|=
literal|0
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|uint64_t
name|curtime
decl_stmt|;
name|struct
name|timespec
name|t1
decl_stmt|,
name|t2
decl_stmt|;
if|if
condition|(
name|cnt
operator|>
name|MAX_WAIT_OBJECTS
condition|)
return|return
operator|(
name|STATUS_INVALID_PARAMETER
operator|)
return|;
if|if
condition|(
name|cnt
operator|>
name|THREAD_WAIT_OBJECTS
operator|&&
name|wb_array
operator|==
name|NULL
condition|)
return|return
operator|(
name|STATUS_INVALID_PARAMETER
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|wb_array
operator|==
name|NULL
condition|)
name|w
operator|=
operator|&
name|_wb_array
index|[
literal|0
index|]
expr_stmt|;
else|else
name|w
operator|=
name|wb_array
expr_stmt|;
comment|/* First pass: see if we can satisfy any waits immediately. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|obj
index|[
name|i
index|]
operator|->
name|dh_size
operator|==
name|OTYPE_MUTEX
condition|)
block|{
name|km
operator|=
operator|(
name|kmutant
operator|*
operator|)
name|obj
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|km
operator|->
name|km_ownerthread
operator|==
name|NULL
operator|||
name|km
operator|->
name|km_ownerthread
operator|==
name|curthread
operator|->
name|td_proc
condition|)
block|{
name|obj
index|[
name|i
index|]
operator|->
name|dh_sigstate
operator|=
name|FALSE
expr_stmt|;
name|km
operator|->
name|km_acquirecnt
operator|++
expr_stmt|;
name|km
operator|->
name|km_ownerthread
operator|=
name|curthread
operator|->
name|td_proc
expr_stmt|;
if|if
condition|(
name|wtype
operator|==
name|WAITTYPE_ANY
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_WAIT_0
operator|+
name|i
operator|)
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|obj
index|[
name|i
index|]
operator|->
name|dh_sigstate
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
name|obj
index|[
name|i
index|]
operator|->
name|dh_type
operator|==
name|EVENT_TYPE_SYNC
condition|)
name|obj
index|[
name|i
index|]
operator|->
name|dh_sigstate
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|wtype
operator|==
name|WAITTYPE_ANY
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_WAIT_0
operator|+
name|i
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 * Second pass: set up wait for anything we can't 	 * satisfy immediately. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|obj
index|[
name|i
index|]
operator|->
name|dh_sigstate
operator|==
name|TRUE
condition|)
continue|continue;
name|INSERT_LIST_TAIL
argument_list|(
operator|(
operator|&
name|obj
index|[
name|i
index|]
operator|->
name|dh_waitlisthead
operator|)
argument_list|,
operator|(
operator|&
name|w
index|[
name|i
index|]
operator|.
name|wb_waitlist
operator|)
argument_list|)
expr_stmt|;
name|w
index|[
name|i
index|]
operator|.
name|wb_kthread
operator|=
name|td
expr_stmt|;
name|w
index|[
name|i
index|]
operator|.
name|wb_object
operator|=
name|obj
index|[
name|i
index|]
expr_stmt|;
name|wcnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|duetime
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|duetime
operator|<
literal|0
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|=
operator|-
operator|(
operator|*
name|duetime
operator|)
operator|/
literal|10000000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
operator|-
operator|(
operator|*
name|duetime
operator|)
operator|/
literal|10
operator|)
operator|-
operator|(
name|tv
operator|.
name|tv_sec
operator|*
literal|1000000
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ntoskrnl_time
argument_list|(
operator|&
name|curtime
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|duetime
operator|<
name|curtime
condition|)
name|tv
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|tv
operator|.
name|tv_sec
operator|=
operator|(
operator|(
operator|*
name|duetime
operator|)
operator|-
name|curtime
operator|)
operator|/
literal|10000000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
operator|(
operator|*
name|duetime
operator|)
operator|-
name|curtime
operator|)
operator|/
literal|10
operator|-
operator|(
name|tv
operator|.
name|tv_sec
operator|*
literal|1000000
operator|)
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
name|wcnt
condition|)
block|{
name|nanotime
argument_list|(
operator|&
name|t1
argument_list|)
expr_stmt|;
name|error
operator|=
name|ndis_thsuspend
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
operator|&
name|ntoskrnl_dispatchlock
argument_list|,
name|duetime
operator|==
name|NULL
condition|?
literal|0
else|:
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|)
expr_stmt|;
name|nanotime
argument_list|(
operator|&
name|t2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|obj
index|[
name|i
index|]
operator|->
name|dh_size
operator|==
name|OTYPE_MUTEX
condition|)
block|{
name|km
operator|=
operator|(
name|kmutant
operator|*
operator|)
name|obj
expr_stmt|;
if|if
condition|(
name|km
operator|->
name|km_ownerthread
operator|==
name|NULL
condition|)
block|{
name|km
operator|->
name|km_ownerthread
operator|=
name|curthread
operator|->
name|td_proc
expr_stmt|;
name|km
operator|->
name|km_acquirecnt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|obj
index|[
name|i
index|]
operator|->
name|dh_sigstate
operator|==
name|TRUE
condition|)
block|{
name|widx
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|obj
index|[
name|i
index|]
operator|->
name|dh_type
operator|==
name|EVENT_TYPE_SYNC
condition|)
name|obj
index|[
name|i
index|]
operator|->
name|dh_sigstate
operator|=
name|FALSE
expr_stmt|;
name|REMOVE_LIST_ENTRY
argument_list|(
operator|(
operator|&
name|w
index|[
name|i
index|]
operator|.
name|wb_waitlist
operator|)
argument_list|)
expr_stmt|;
name|wcnt
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|||
name|wtype
operator|==
name|WAITTYPE_ANY
condition|)
break|break;
if|if
condition|(
name|duetime
operator|!=
name|NULL
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|-=
operator|(
name|t2
operator|.
name|tv_sec
operator|-
name|t1
operator|.
name|tv_sec
operator|)
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|-=
operator|(
name|t2
operator|.
name|tv_nsec
operator|-
name|t1
operator|.
name|tv_nsec
operator|)
operator|/
literal|1000
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wcnt
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
name|REMOVE_LIST_ENTRY
argument_list|(
operator|(
operator|&
name|w
index|[
name|i
index|]
operator|.
name|wb_waitlist
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_TIMEOUT
operator|)
return|;
block|}
if|if
condition|(
name|wtype
operator|==
name|WAITTYPE_ANY
operator|&&
name|wcnt
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_WAIT_0
operator|+
name|widx
operator|)
return|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|WRITE_REGISTER_USHORT
parameter_list|(
name|reg
parameter_list|,
name|val
parameter_list|)
name|uint16_t
modifier|*
name|reg
decl_stmt|;
name|uint16_t
name|val
decl_stmt|;
block|{
name|bus_space_write_2
argument_list|(
name|NDIS_BUS_SPACE_MEM
argument_list|,
literal|0x0
argument_list|,
operator|(
name|bus_size_t
operator|)
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|READ_REGISTER_USHORT
parameter_list|(
name|reg
parameter_list|)
name|uint16_t
modifier|*
name|reg
decl_stmt|;
block|{
return|return
operator|(
name|bus_space_read_2
argument_list|(
name|NDIS_BUS_SPACE_MEM
argument_list|,
literal|0x0
argument_list|,
operator|(
name|bus_size_t
operator|)
name|reg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|WRITE_REGISTER_ULONG
parameter_list|(
name|reg
parameter_list|,
name|val
parameter_list|)
name|uint32_t
modifier|*
name|reg
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
block|{
name|bus_space_write_4
argument_list|(
name|NDIS_BUS_SPACE_MEM
argument_list|,
literal|0x0
argument_list|,
operator|(
name|bus_size_t
operator|)
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|READ_REGISTER_ULONG
parameter_list|(
name|reg
parameter_list|)
name|uint32_t
modifier|*
name|reg
decl_stmt|;
block|{
return|return
operator|(
name|bus_space_read_4
argument_list|(
name|NDIS_BUS_SPACE_MEM
argument_list|,
literal|0x0
argument_list|,
operator|(
name|bus_size_t
operator|)
name|reg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|READ_REGISTER_UCHAR
parameter_list|(
name|reg
parameter_list|)
name|uint8_t
modifier|*
name|reg
decl_stmt|;
block|{
return|return
operator|(
name|bus_space_read_1
argument_list|(
name|NDIS_BUS_SPACE_MEM
argument_list|,
literal|0x0
argument_list|,
operator|(
name|bus_size_t
operator|)
name|reg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|WRITE_REGISTER_UCHAR
parameter_list|(
name|reg
parameter_list|,
name|val
parameter_list|)
name|uint8_t
modifier|*
name|reg
decl_stmt|;
name|uint8_t
name|val
decl_stmt|;
block|{
name|bus_space_write_1
argument_list|(
name|NDIS_BUS_SPACE_MEM
argument_list|,
literal|0x0
argument_list|,
operator|(
name|bus_size_t
operator|)
name|reg
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|_allmul
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|int64_t
name|a
decl_stmt|;
name|int64_t
name|b
decl_stmt|;
block|{
return|return
operator|(
name|a
operator|*
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|_alldiv
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|int64_t
name|a
decl_stmt|;
name|int64_t
name|b
decl_stmt|;
block|{
return|return
operator|(
name|a
operator|/
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|_allrem
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|int64_t
name|a
decl_stmt|;
name|int64_t
name|b
decl_stmt|;
block|{
return|return
operator|(
name|a
operator|%
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|_aullmul
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|uint64_t
name|a
decl_stmt|;
name|uint64_t
name|b
decl_stmt|;
block|{
return|return
operator|(
name|a
operator|*
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|_aulldiv
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|uint64_t
name|a
decl_stmt|;
name|uint64_t
name|b
decl_stmt|;
block|{
return|return
operator|(
name|a
operator|/
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|_aullrem
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|uint64_t
name|a
decl_stmt|;
name|uint64_t
name|b
decl_stmt|;
block|{
return|return
operator|(
name|a
operator|%
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|_allshl
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|int64_t
name|a
decl_stmt|;
name|uint8_t
name|b
decl_stmt|;
block|{
return|return
operator|(
name|a
operator|<<
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|_aullshl
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|uint64_t
name|a
decl_stmt|;
name|uint8_t
name|b
decl_stmt|;
block|{
return|return
operator|(
name|a
operator|<<
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int64_t
name|_allshr
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|int64_t
name|a
decl_stmt|;
name|uint8_t
name|b
decl_stmt|;
block|{
return|return
operator|(
name|a
operator|>>
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|_aullshr
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|uint64_t
name|a
decl_stmt|;
name|uint8_t
name|b
decl_stmt|;
block|{
return|return
operator|(
name|a
operator|>>
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|slist_entry
modifier|*
name|ntoskrnl_pushsl
parameter_list|(
name|head
parameter_list|,
name|entry
parameter_list|)
name|slist_header
modifier|*
name|head
decl_stmt|;
name|slist_entry
modifier|*
name|entry
decl_stmt|;
block|{
name|slist_entry
modifier|*
name|oldhead
decl_stmt|;
name|oldhead
operator|=
name|head
operator|->
name|slh_list
operator|.
name|slh_next
expr_stmt|;
name|entry
operator|->
name|sl_next
operator|=
name|head
operator|->
name|slh_list
operator|.
name|slh_next
expr_stmt|;
name|head
operator|->
name|slh_list
operator|.
name|slh_next
operator|=
name|entry
expr_stmt|;
name|head
operator|->
name|slh_list
operator|.
name|slh_depth
operator|++
expr_stmt|;
name|head
operator|->
name|slh_list
operator|.
name|slh_seq
operator|++
expr_stmt|;
return|return
operator|(
name|oldhead
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|slist_entry
modifier|*
name|ntoskrnl_popsl
parameter_list|(
name|head
parameter_list|)
name|slist_header
modifier|*
name|head
decl_stmt|;
block|{
name|slist_entry
modifier|*
name|first
decl_stmt|;
name|first
operator|=
name|head
operator|->
name|slh_list
operator|.
name|slh_next
expr_stmt|;
if|if
condition|(
name|first
operator|!=
name|NULL
condition|)
block|{
name|head
operator|->
name|slh_list
operator|.
name|slh_next
operator|=
name|first
operator|->
name|sl_next
expr_stmt|;
name|head
operator|->
name|slh_list
operator|.
name|slh_depth
operator|--
expr_stmt|;
name|head
operator|->
name|slh_list
operator|.
name|slh_seq
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|first
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We need this to make lookaside lists work for amd64.  * We pass a pointer to ExAllocatePoolWithTag() the lookaside  * list structure. For amd64 to work right, this has to be a  * pointer to the wrapped version of the routine, not the  * original. Letting the Windows driver invoke the original  * function directly will result in a convention calling  * mismatch and a pretty crash. On x86, this effectively  * becomes a no-op since ipt_func and ipt_wrap are the same.  */
end_comment

begin_function
specifier|static
name|funcptr
name|ntoskrnl_findwrap
parameter_list|(
name|func
parameter_list|)
name|funcptr
name|func
decl_stmt|;
block|{
name|image_patch_table
modifier|*
name|patch
decl_stmt|;
name|patch
operator|=
name|ntoskrnl_functbl
expr_stmt|;
while|while
condition|(
name|patch
operator|->
name|ipt_func
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|funcptr
operator|)
name|patch
operator|->
name|ipt_func
operator|==
name|func
condition|)
return|return
operator|(
operator|(
name|funcptr
operator|)
name|patch
operator|->
name|ipt_wrap
operator|)
return|;
name|patch
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ExInitializePagedLookasideList
parameter_list|(
name|lookaside
parameter_list|,
name|allocfunc
parameter_list|,
name|freefunc
parameter_list|,
name|flags
parameter_list|,
name|size
parameter_list|,
name|tag
parameter_list|,
name|depth
parameter_list|)
name|paged_lookaside_list
modifier|*
name|lookaside
decl_stmt|;
name|lookaside_alloc_func
modifier|*
name|allocfunc
decl_stmt|;
name|lookaside_free_func
modifier|*
name|freefunc
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|uint32_t
name|tag
decl_stmt|;
name|uint16_t
name|depth
decl_stmt|;
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lookaside
argument_list|,
sizeof|sizeof
argument_list|(
name|paged_lookaside_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
sizeof|sizeof
argument_list|(
name|slist_entry
argument_list|)
condition|)
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_size
operator|=
sizeof|sizeof
argument_list|(
name|slist_entry
argument_list|)
expr_stmt|;
else|else
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_size
operator|=
name|size
expr_stmt|;
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_tag
operator|=
name|tag
expr_stmt|;
if|if
condition|(
name|allocfunc
operator|==
name|NULL
condition|)
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_allocfunc
operator|=
name|ntoskrnl_findwrap
argument_list|(
operator|(
name|funcptr
operator|)
name|ExAllocatePoolWithTag
argument_list|)
expr_stmt|;
else|else
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_allocfunc
operator|=
name|allocfunc
expr_stmt|;
if|if
condition|(
name|freefunc
operator|==
name|NULL
condition|)
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_freefunc
operator|=
name|ntoskrnl_findwrap
argument_list|(
operator|(
name|funcptr
operator|)
name|ExFreePool
argument_list|)
expr_stmt|;
else|else
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_freefunc
operator|=
name|freefunc
expr_stmt|;
ifdef|#
directive|ifdef
name|__i386__
name|KeInitializeSpinLock
argument_list|(
operator|&
name|lookaside
operator|->
name|nll_obsoletelock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_type
operator|=
name|NonPagedPool
expr_stmt|;
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_depth
operator|=
name|depth
expr_stmt|;
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_maxdepth
operator|=
name|LOOKASIDE_DEPTH
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ExDeletePagedLookasideList
parameter_list|(
name|lookaside
parameter_list|)
name|paged_lookaside_list
modifier|*
name|lookaside
decl_stmt|;
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|void
function_decl|(
modifier|*
name|freefunc
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|freefunc
operator|=
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_freefunc
expr_stmt|;
while|while
condition|(
operator|(
name|buf
operator|=
name|ntoskrnl_popsl
argument_list|(
operator|&
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_listhead
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|MSCALL1
argument_list|(
name|freefunc
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ExInitializeNPagedLookasideList
parameter_list|(
name|lookaside
parameter_list|,
name|allocfunc
parameter_list|,
name|freefunc
parameter_list|,
name|flags
parameter_list|,
name|size
parameter_list|,
name|tag
parameter_list|,
name|depth
parameter_list|)
name|npaged_lookaside_list
modifier|*
name|lookaside
decl_stmt|;
name|lookaside_alloc_func
modifier|*
name|allocfunc
decl_stmt|;
name|lookaside_free_func
modifier|*
name|freefunc
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|uint32_t
name|tag
decl_stmt|;
name|uint16_t
name|depth
decl_stmt|;
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|lookaside
argument_list|,
sizeof|sizeof
argument_list|(
name|npaged_lookaside_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
sizeof|sizeof
argument_list|(
name|slist_entry
argument_list|)
condition|)
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_size
operator|=
sizeof|sizeof
argument_list|(
name|slist_entry
argument_list|)
expr_stmt|;
else|else
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_size
operator|=
name|size
expr_stmt|;
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_tag
operator|=
name|tag
expr_stmt|;
if|if
condition|(
name|allocfunc
operator|==
name|NULL
condition|)
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_allocfunc
operator|=
name|ntoskrnl_findwrap
argument_list|(
operator|(
name|funcptr
operator|)
name|ExAllocatePoolWithTag
argument_list|)
expr_stmt|;
else|else
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_allocfunc
operator|=
name|allocfunc
expr_stmt|;
if|if
condition|(
name|freefunc
operator|==
name|NULL
condition|)
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_freefunc
operator|=
name|ntoskrnl_findwrap
argument_list|(
operator|(
name|funcptr
operator|)
name|ExFreePool
argument_list|)
expr_stmt|;
else|else
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_freefunc
operator|=
name|freefunc
expr_stmt|;
ifdef|#
directive|ifdef
name|__i386__
name|KeInitializeSpinLock
argument_list|(
operator|&
name|lookaside
operator|->
name|nll_obsoletelock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_type
operator|=
name|NonPagedPool
expr_stmt|;
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_depth
operator|=
name|depth
expr_stmt|;
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_maxdepth
operator|=
name|LOOKASIDE_DEPTH
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ExDeleteNPagedLookasideList
parameter_list|(
name|lookaside
parameter_list|)
name|npaged_lookaside_list
modifier|*
name|lookaside
decl_stmt|;
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|void
function_decl|(
modifier|*
name|freefunc
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|freefunc
operator|=
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_freefunc
expr_stmt|;
while|while
condition|(
operator|(
name|buf
operator|=
name|ntoskrnl_popsl
argument_list|(
operator|&
name|lookaside
operator|->
name|nll_l
operator|.
name|gl_listhead
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|MSCALL1
argument_list|(
name|freefunc
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|slist_entry
modifier|*
name|InterlockedPushEntrySList
parameter_list|(
name|head
parameter_list|,
name|entry
parameter_list|)
name|slist_header
modifier|*
name|head
decl_stmt|;
name|slist_entry
modifier|*
name|entry
decl_stmt|;
block|{
name|slist_entry
modifier|*
name|oldhead
decl_stmt|;
name|oldhead
operator|=
name|ExInterlockedPushEntrySList
argument_list|(
name|head
argument_list|,
name|entry
argument_list|,
operator|&
name|ntoskrnl_global
argument_list|)
expr_stmt|;
return|return
operator|(
name|oldhead
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|slist_entry
modifier|*
name|InterlockedPopEntrySList
parameter_list|(
name|head
parameter_list|)
name|slist_header
modifier|*
name|head
decl_stmt|;
block|{
name|slist_entry
modifier|*
name|first
decl_stmt|;
name|first
operator|=
name|ExInterlockedPopEntrySList
argument_list|(
name|head
argument_list|,
operator|&
name|ntoskrnl_global
argument_list|)
expr_stmt|;
return|return
operator|(
name|first
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|slist_entry
modifier|*
name|ExInterlockedPushEntrySList
parameter_list|(
name|head
parameter_list|,
name|entry
parameter_list|,
name|lock
parameter_list|)
name|slist_header
modifier|*
name|head
decl_stmt|;
name|slist_entry
modifier|*
name|entry
decl_stmt|;
name|kspin_lock
modifier|*
name|lock
decl_stmt|;
block|{
name|slist_entry
modifier|*
name|oldhead
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
name|KeAcquireSpinLock
argument_list|(
name|lock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
name|oldhead
operator|=
name|ntoskrnl_pushsl
argument_list|(
name|head
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|KeReleaseSpinLock
argument_list|(
name|lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
return|return
operator|(
name|oldhead
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|slist_entry
modifier|*
name|ExInterlockedPopEntrySList
parameter_list|(
name|head
parameter_list|,
name|lock
parameter_list|)
name|slist_header
modifier|*
name|head
decl_stmt|;
name|kspin_lock
modifier|*
name|lock
decl_stmt|;
block|{
name|slist_entry
modifier|*
name|first
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
name|KeAcquireSpinLock
argument_list|(
name|lock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
name|first
operator|=
name|ntoskrnl_popsl
argument_list|(
name|head
argument_list|)
expr_stmt|;
name|KeReleaseSpinLock
argument_list|(
name|lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
return|return
operator|(
name|first
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint16_t
name|ExQueryDepthSList
parameter_list|(
name|head
parameter_list|)
name|slist_header
modifier|*
name|head
decl_stmt|;
block|{
name|uint16_t
name|depth
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
name|KeAcquireSpinLock
argument_list|(
operator|&
name|ntoskrnl_global
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
name|depth
operator|=
name|head
operator|->
name|slh_list
operator|.
name|slh_depth
expr_stmt|;
name|KeReleaseSpinLock
argument_list|(
operator|&
name|ntoskrnl_global
argument_list|,
name|irql
argument_list|)
expr_stmt|;
return|return
operator|(
name|depth
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The KeInitializeSpinLock(), KefAcquireSpinLockAtDpcLevel()  * and KefReleaseSpinLockFromDpcLevel() appear to be analagous  * to splnet()/splx() in their use. We can't create a new mutex  * lock here because there is no complimentary KeFreeSpinLock()  * function. Instead, we grab a mutex from the mutex pool.  */
end_comment

begin_function
name|void
name|KeInitializeSpinLock
parameter_list|(
name|lock
parameter_list|)
name|kspin_lock
modifier|*
name|lock
decl_stmt|;
block|{
operator|*
name|lock
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_function
name|void
name|KefAcquireSpinLockAtDpcLevel
parameter_list|(
name|lock
parameter_list|)
name|kspin_lock
modifier|*
name|lock
decl_stmt|;
block|{
while|while
condition|(
name|atomic_cmpset_acq_int
argument_list|(
operator|(
specifier|volatile
name|u_int
operator|*
operator|)
name|lock
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
comment|/* sit and spin */
empty_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|KefReleaseSpinLockFromDpcLevel
parameter_list|(
name|lock
parameter_list|)
name|kspin_lock
modifier|*
name|lock
decl_stmt|;
block|{
name|atomic_store_rel_int
argument_list|(
operator|(
specifier|volatile
name|u_int
operator|*
operator|)
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|uint8_t
name|KeAcquireSpinLockRaiseToDpc
parameter_list|(
name|kspin_lock
modifier|*
name|lock
parameter_list|)
block|{
name|uint8_t
name|oldirql
decl_stmt|;
if|if
condition|(
name|KeGetCurrentIrql
argument_list|()
operator|>
name|DISPATCH_LEVEL
condition|)
name|panic
argument_list|(
literal|"IRQL_NOT_LESS_THAN_OR_EQUAL"
argument_list|)
expr_stmt|;
name|oldirql
operator|=
name|KeRaiseIrql
argument_list|(
name|DISPATCH_LEVEL
argument_list|)
expr_stmt|;
name|KeAcquireSpinLockAtDpcLevel
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|oldirql
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
name|void
name|KeAcquireSpinLockAtDpcLevel
parameter_list|(
name|kspin_lock
modifier|*
name|lock
parameter_list|)
block|{
while|while
condition|(
name|atomic_cmpset_acq_int
argument_list|(
operator|(
specifier|volatile
name|u_int
operator|*
operator|)
name|lock
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
comment|/* sit and spin */
empty_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|KeReleaseSpinLockFromDpcLevel
parameter_list|(
name|kspin_lock
modifier|*
name|lock
parameter_list|)
block|{
name|atomic_store_rel_int
argument_list|(
operator|(
specifier|volatile
name|u_int
operator|*
operator|)
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __i386__ */
end_comment

begin_function
name|uintptr_t
name|InterlockedExchange
parameter_list|(
name|dst
parameter_list|,
name|val
parameter_list|)
specifier|volatile
name|uint32_t
modifier|*
name|dst
decl_stmt|;
name|uintptr_t
name|val
decl_stmt|;
block|{
name|uint8_t
name|irql
decl_stmt|;
name|uintptr_t
name|r
decl_stmt|;
name|KeAcquireSpinLock
argument_list|(
operator|&
name|ntoskrnl_global
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
name|r
operator|=
operator|*
name|dst
expr_stmt|;
operator|*
name|dst
operator|=
name|val
expr_stmt|;
name|KeReleaseSpinLock
argument_list|(
operator|&
name|ntoskrnl_global
argument_list|,
name|irql
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|InterlockedIncrement
parameter_list|(
name|addend
parameter_list|)
specifier|volatile
name|uint32_t
modifier|*
name|addend
decl_stmt|;
block|{
name|atomic_add_long
argument_list|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|addend
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|addend
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|InterlockedDecrement
parameter_list|(
name|addend
parameter_list|)
specifier|volatile
name|uint32_t
modifier|*
name|addend
decl_stmt|;
block|{
name|atomic_subtract_long
argument_list|(
operator|(
specifier|volatile
name|u_long
operator|*
operator|)
name|addend
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|addend
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ExInterlockedAddLargeStatistic
parameter_list|(
name|addend
parameter_list|,
name|inc
parameter_list|)
name|uint64_t
modifier|*
name|addend
decl_stmt|;
name|uint32_t
name|inc
decl_stmt|;
block|{
name|uint8_t
name|irql
decl_stmt|;
name|KeAcquireSpinLock
argument_list|(
operator|&
name|ntoskrnl_global
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
operator|*
name|addend
operator|+=
name|inc
expr_stmt|;
name|KeReleaseSpinLock
argument_list|(
operator|&
name|ntoskrnl_global
argument_list|,
name|irql
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
name|mdl
modifier|*
name|IoAllocateMdl
parameter_list|(
name|vaddr
parameter_list|,
name|len
parameter_list|,
name|secondarybuf
parameter_list|,
name|chargequota
parameter_list|,
name|iopkt
parameter_list|)
name|void
modifier|*
name|vaddr
decl_stmt|;
name|uint32_t
name|len
decl_stmt|;
name|uint8_t
name|secondarybuf
decl_stmt|;
name|uint8_t
name|chargequota
decl_stmt|;
name|irp
modifier|*
name|iopkt
decl_stmt|;
block|{
name|mdl
modifier|*
name|m
decl_stmt|;
name|int
name|zone
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|MmSizeOfMdl
argument_list|(
name|vaddr
argument_list|,
name|len
argument_list|)
operator|>
name|MDL_ZONE_SIZE
condition|)
name|m
operator|=
name|ExAllocatePoolWithTag
argument_list|(
name|NonPagedPool
argument_list|,
name|MmSizeOfMdl
argument_list|(
name|vaddr
argument_list|,
name|len
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|m
operator|=
name|uma_zalloc
argument_list|(
name|mdl_zone
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|zone
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|MmInitializeMdl
argument_list|(
name|m
argument_list|,
name|vaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * MmInitializMdl() clears the flags field, so we 	 * have to set this here. If the MDL came from the 	 * MDL UMA zone, tag it so we can release it to 	 * the right place later. 	 */
if|if
condition|(
name|zone
condition|)
name|m
operator|->
name|mdl_flags
operator|=
name|MDL_ZONE_ALLOCED
expr_stmt|;
if|if
condition|(
name|iopkt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|secondarybuf
operator|==
name|TRUE
condition|)
block|{
name|mdl
modifier|*
name|last
decl_stmt|;
name|last
operator|=
name|iopkt
operator|->
name|irp_mdl
expr_stmt|;
while|while
condition|(
name|last
operator|->
name|mdl_next
operator|!=
name|NULL
condition|)
name|last
operator|=
name|last
operator|->
name|mdl_next
expr_stmt|;
name|last
operator|->
name|mdl_next
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|iopkt
operator|->
name|irp_mdl
operator|!=
name|NULL
condition|)
name|panic
argument_list|(
literal|"leaking an MDL in IoAllocateMdl()"
argument_list|)
expr_stmt|;
name|iopkt
operator|->
name|irp_mdl
operator|=
name|m
expr_stmt|;
block|}
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
name|void
name|IoFreeMdl
parameter_list|(
name|m
parameter_list|)
name|mdl
modifier|*
name|m
decl_stmt|;
block|{
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|m
operator|->
name|mdl_flags
operator|&
name|MDL_ZONE_ALLOCED
condition|)
name|uma_zfree
argument_list|(
name|mdl_zone
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|else
name|ExFreePool
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|MmSizeOfMdl
parameter_list|(
name|vaddr
parameter_list|,
name|len
parameter_list|)
name|void
modifier|*
name|vaddr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|uint32_t
name|l
decl_stmt|;
name|l
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mdl
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|vm_offset_t
operator|*
argument_list|)
operator|*
name|SPAN_PAGES
argument_list|(
name|vaddr
argument_list|,
name|len
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The Microsoft documentation says this routine fills in the  * page array of an MDL with the _physical_ page addresses that  * comprise the buffer, but we don't really want to do that here.  * Instead, we just fill in the page array with the kernel virtual  * addresses of the buffers.  */
end_comment

begin_function
specifier|static
name|void
name|MmBuildMdlForNonPagedPool
parameter_list|(
name|m
parameter_list|)
name|mdl
modifier|*
name|m
decl_stmt|;
block|{
name|vm_offset_t
modifier|*
name|mdl_pages
decl_stmt|;
name|int
name|pagecnt
decl_stmt|,
name|i
decl_stmt|;
name|pagecnt
operator|=
name|SPAN_PAGES
argument_list|(
name|m
operator|->
name|mdl_byteoffset
argument_list|,
name|m
operator|->
name|mdl_bytecount
argument_list|)
expr_stmt|;
if|if
condition|(
name|pagecnt
operator|>
operator|(
name|m
operator|->
name|mdl_size
operator|-
sizeof|sizeof
argument_list|(
name|mdl
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|vm_offset_t
operator|*
argument_list|)
condition|)
name|panic
argument_list|(
literal|"not enough pages in MDL to describe buffer"
argument_list|)
expr_stmt|;
name|mdl_pages
operator|=
name|MmGetMdlPfnArray
argument_list|(
name|m
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pagecnt
condition|;
name|i
operator|++
control|)
operator|*
name|mdl_pages
operator|=
operator|(
name|vm_offset_t
operator|)
name|m
operator|->
name|mdl_startva
operator|+
operator|(
name|i
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
name|m
operator|->
name|mdl_flags
operator||=
name|MDL_SOURCE_IS_NONPAGED_POOL
expr_stmt|;
name|m
operator|->
name|mdl_mappedsystemva
operator|=
name|MmGetMdlVirtualAddress
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|MmMapLockedPages
parameter_list|(
name|buf
parameter_list|,
name|accessmode
parameter_list|)
name|mdl
modifier|*
name|buf
decl_stmt|;
name|uint8_t
name|accessmode
decl_stmt|;
block|{
name|buf
operator|->
name|mdl_flags
operator||=
name|MDL_MAPPED_TO_SYSTEM_VA
expr_stmt|;
return|return
operator|(
name|MmGetMdlVirtualAddress
argument_list|(
name|buf
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|MmMapLockedPagesSpecifyCache
parameter_list|(
name|buf
parameter_list|,
name|accessmode
parameter_list|,
name|cachetype
parameter_list|,
name|vaddr
parameter_list|,
name|bugcheck
parameter_list|,
name|prio
parameter_list|)
name|mdl
modifier|*
name|buf
decl_stmt|;
name|uint8_t
name|accessmode
decl_stmt|;
name|uint32_t
name|cachetype
decl_stmt|;
name|void
modifier|*
name|vaddr
decl_stmt|;
name|uint32_t
name|bugcheck
decl_stmt|;
name|uint32_t
name|prio
decl_stmt|;
block|{
return|return
operator|(
name|MmMapLockedPages
argument_list|(
name|buf
argument_list|,
name|accessmode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|MmUnmapLockedPages
parameter_list|(
name|vaddr
parameter_list|,
name|buf
parameter_list|)
name|void
modifier|*
name|vaddr
decl_stmt|;
name|mdl
modifier|*
name|buf
decl_stmt|;
block|{
name|buf
operator|->
name|mdl_flags
operator|&=
operator|~
name|MDL_MAPPED_TO_SYSTEM_VA
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * This function has a problem in that it will break if you  * compile this module without PAE and try to use it on a PAE  * kernel. Unfortunately, there's no way around this at the  * moment. It's slightly less broken that using pmap_kextract().  * You'd think the virtual memory subsystem would help us out  * here, but it doesn't.  */
end_comment

begin_function
specifier|static
name|uint8_t
name|MmIsAddressValid
parameter_list|(
name|vaddr
parameter_list|)
name|void
modifier|*
name|vaddr
decl_stmt|;
block|{
if|if
condition|(
name|pmap_extract
argument_list|(
name|kernel_map
operator|->
name|pmap
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|vaddr
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Workitems are unlike DPCs, in that they run in a user-mode thread  * context rather than at DISPATCH_LEVEL in kernel context. In our  * case we run them in kernel context anyway.  */
end_comment

begin_function
specifier|static
name|void
name|ntoskrnl_workitem_thread
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|kdpc_queue
modifier|*
name|kq
decl_stmt|;
name|list_entry
modifier|*
name|l
decl_stmt|;
name|io_workitem
modifier|*
name|iw
decl_stmt|;
name|kq
operator|=
name|arg
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|kq
operator|->
name|kq_med
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_td
operator|=
name|curthread
expr_stmt|;
name|kq
operator|->
name|kq_exit
operator|=
literal|0
expr_stmt|;
name|kq
operator|->
name|kq_state
operator|=
name|NDIS_PSTATE_SLEEPING
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
literal|"NDIS thread lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|KeInitializeEvent
argument_list|(
operator|&
name|kq
operator|->
name|kq_proc
argument_list|,
name|EVENT_TYPE_SYNC
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|KeInitializeEvent
argument_list|(
operator|&
name|kq
operator|->
name|kq_dead
argument_list|,
name|EVENT_TYPE_SYNC
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|KeWaitForSingleObject
argument_list|(
operator|(
name|nt_dispatch_header
operator|*
operator|)
operator|&
name|kq
operator|->
name|kq_proc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|kq
operator|->
name|kq_exit
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
name|KeSetEvent
argument_list|(
operator|&
name|kq
operator|->
name|kq_dead
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
name|kq
operator|->
name|kq_state
operator|=
name|NDIS_PSTATE_RUNNING
expr_stmt|;
name|l
operator|=
name|kq
operator|->
name|kq_med
operator|.
name|nle_flink
expr_stmt|;
while|while
condition|(
name|l
operator|!=
operator|&
name|kq
operator|->
name|kq_med
condition|)
block|{
name|iw
operator|=
name|CONTAINING_RECORD
argument_list|(
name|l
argument_list|,
name|io_workitem
argument_list|,
name|iw_listentry
argument_list|)
expr_stmt|;
name|REMOVE_LIST_HEAD
argument_list|(
operator|(
operator|&
name|kq
operator|->
name|kq_med
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iw
operator|->
name|iw_func
operator|==
name|NULL
condition|)
block|{
name|l
operator|=
name|kq
operator|->
name|kq_med
operator|.
name|nle_flink
expr_stmt|;
continue|continue;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
name|MSCALL2
argument_list|(
name|iw
operator|->
name|iw_func
argument_list|,
name|iw
operator|->
name|iw_dobj
argument_list|,
name|iw
operator|->
name|iw_ctx
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
name|l
operator|=
name|kq
operator|->
name|kq_med
operator|.
name|nle_flink
expr_stmt|;
block|}
name|kq
operator|->
name|kq_state
operator|=
name|NDIS_PSTATE_SLEEPING
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|502113
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
comment|/* notreached */
block|}
end_function

begin_function
name|io_workitem
modifier|*
name|IoAllocateWorkItem
parameter_list|(
name|dobj
parameter_list|)
name|device_object
modifier|*
name|dobj
decl_stmt|;
block|{
name|io_workitem
modifier|*
name|iw
decl_stmt|;
name|iw
operator|=
name|uma_zalloc
argument_list|(
name|iw_zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|iw
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|iw
operator|->
name|iw_listentry
argument_list|)
expr_stmt|;
name|iw
operator|->
name|iw_dobj
operator|=
name|dobj
expr_stmt|;
return|return
operator|(
name|iw
operator|)
return|;
block|}
end_function

begin_function
name|void
name|IoFreeWorkItem
parameter_list|(
name|iw
parameter_list|)
name|io_workitem
modifier|*
name|iw
decl_stmt|;
block|{
name|uma_zfree
argument_list|(
name|iw_zone
argument_list|,
name|iw
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|IoQueueWorkItem
parameter_list|(
name|iw
parameter_list|,
name|iw_func
parameter_list|,
name|qtype
parameter_list|,
name|ctx
parameter_list|)
name|io_workitem
modifier|*
name|iw
decl_stmt|;
name|io_workitem_func
name|iw_func
decl_stmt|;
name|uint32_t
name|qtype
decl_stmt|;
name|void
modifier|*
name|ctx
decl_stmt|;
block|{
name|int
name|state
decl_stmt|;
name|iw
operator|->
name|iw_func
operator|=
name|iw_func
expr_stmt|;
name|iw
operator|->
name|iw_ctx
operator|=
name|ctx
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|wq_queue
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
name|INSERT_LIST_TAIL
argument_list|(
operator|(
operator|&
name|wq_queue
operator|->
name|kq_med
operator|)
argument_list|,
operator|(
operator|&
name|iw
operator|->
name|iw_listentry
operator|)
argument_list|)
expr_stmt|;
name|state
operator|=
name|wq_queue
operator|->
name|kq_state
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|wq_queue
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|NDIS_PSTATE_SLEEPING
condition|)
name|KeSetEvent
argument_list|(
operator|&
name|wq_queue
operator|->
name|kq_proc
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ntoskrnl_workitem
parameter_list|(
name|dobj
parameter_list|,
name|arg
parameter_list|)
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|io_workitem
modifier|*
name|iw
decl_stmt|;
name|work_queue_item
modifier|*
name|w
decl_stmt|;
name|work_item_func
name|f
decl_stmt|;
name|iw
operator|=
name|arg
expr_stmt|;
name|w
operator|=
operator|(
name|work_queue_item
operator|*
operator|)
name|dobj
expr_stmt|;
name|f
operator|=
operator|(
name|work_item_func
operator|)
name|w
operator|->
name|wqi_func
expr_stmt|;
name|uma_zfree
argument_list|(
name|iw_zone
argument_list|,
name|iw
argument_list|)
expr_stmt|;
name|MSCALL2
argument_list|(
name|f
argument_list|,
name|w
argument_list|,
name|w
operator|->
name|wqi_ctx
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ExQueueWorkItem
parameter_list|(
name|w
parameter_list|,
name|qtype
parameter_list|)
name|work_queue_item
modifier|*
name|w
decl_stmt|;
name|uint32_t
name|qtype
decl_stmt|;
block|{
name|io_workitem
modifier|*
name|iw
decl_stmt|;
name|io_workitem_func
name|iwf
decl_stmt|;
name|iw
operator|=
name|IoAllocateWorkItem
argument_list|(
operator|(
name|device_object
operator|*
operator|)
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|iw
operator|==
name|NULL
condition|)
return|return;
name|iwf
operator|=
operator|(
name|io_workitem_func
operator|)
name|ntoskrnl_findwrap
argument_list|(
operator|(
name|funcptr
operator|)
name|ntoskrnl_workitem
argument_list|)
expr_stmt|;
name|IoQueueWorkItem
argument_list|(
name|iw
argument_list|,
name|iwf
argument_list|,
name|qtype
argument_list|,
name|iw
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|size_t
name|RtlCompareMemory
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|len
parameter_list|)
specifier|const
name|void
modifier|*
name|s1
decl_stmt|;
specifier|const
name|void
modifier|*
name|s2
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|{
name|size_t
name|i
decl_stmt|,
name|total
init|=
literal|0
decl_stmt|;
name|uint8_t
modifier|*
name|m1
decl_stmt|,
modifier|*
name|m2
decl_stmt|;
name|m1
operator|=
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|m2
operator|=
name|__DECONST
argument_list|(
name|char
operator|*
argument_list|,
name|s2
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|m1
index|[
name|i
index|]
operator|==
name|m2
index|[
name|i
index|]
condition|)
name|total
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|total
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|RtlInitAnsiString
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
name|ndis_ansi_string
modifier|*
name|dst
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|;
block|{
name|ndis_ansi_string
modifier|*
name|a
decl_stmt|;
name|a
operator|=
name|dst
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
block|{
name|a
operator|->
name|nas_len
operator|=
name|a
operator|->
name|nas_maxlen
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|nas_buf
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|a
operator|->
name|nas_buf
operator|=
name|src
expr_stmt|;
name|a
operator|->
name|nas_len
operator|=
name|a
operator|->
name|nas_maxlen
operator|=
name|strlen
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|RtlInitUnicodeString
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
name|ndis_unicode_string
modifier|*
name|dst
decl_stmt|;
name|uint16_t
modifier|*
name|src
decl_stmt|;
block|{
name|ndis_unicode_string
modifier|*
name|u
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u
operator|=
name|dst
expr_stmt|;
if|if
condition|(
name|u
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
block|{
name|u
operator|->
name|us_len
operator|=
name|u
operator|->
name|us_maxlen
operator|=
literal|0
expr_stmt|;
name|u
operator|->
name|us_buf
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|src
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|i
operator|++
expr_stmt|;
name|u
operator|->
name|us_buf
operator|=
name|src
expr_stmt|;
name|u
operator|->
name|us_len
operator|=
name|u
operator|->
name|us_maxlen
operator|=
name|i
operator|*
literal|2
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|ndis_status
name|RtlUnicodeStringToInteger
parameter_list|(
name|ustr
parameter_list|,
name|base
parameter_list|,
name|val
parameter_list|)
name|ndis_unicode_string
modifier|*
name|ustr
decl_stmt|;
name|uint32_t
name|base
decl_stmt|;
name|uint32_t
modifier|*
name|val
decl_stmt|;
block|{
name|uint16_t
modifier|*
name|uchr
decl_stmt|;
name|int
name|len
decl_stmt|,
name|neg
init|=
literal|0
decl_stmt|;
name|char
name|abuf
index|[
literal|64
index|]
decl_stmt|;
name|char
modifier|*
name|astr
decl_stmt|;
name|uchr
operator|=
name|ustr
operator|->
name|us_buf
expr_stmt|;
name|len
operator|=
name|ustr
operator|->
name|us_len
expr_stmt|;
name|bzero
argument_list|(
name|abuf
argument_list|,
sizeof|sizeof
argument_list|(
name|abuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|char
call|)
argument_list|(
operator|(
operator|*
name|uchr
operator|)
operator|&
literal|0xFF
argument_list|)
operator|==
literal|'-'
condition|)
block|{
name|neg
operator|=
literal|1
expr_stmt|;
name|uchr
operator|++
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
call|(
name|char
call|)
argument_list|(
operator|(
operator|*
name|uchr
operator|)
operator|&
literal|0xFF
argument_list|)
operator|==
literal|'+'
condition|)
block|{
name|neg
operator|=
literal|0
expr_stmt|;
name|uchr
operator|++
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|==
literal|0
condition|)
block|{
if|if
condition|(
call|(
name|char
call|)
argument_list|(
operator|(
operator|*
name|uchr
operator|)
operator|&
literal|0xFF
argument_list|)
operator|==
literal|'b'
condition|)
block|{
name|base
operator|=
literal|2
expr_stmt|;
name|uchr
operator|++
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
call|(
name|char
call|)
argument_list|(
operator|(
operator|*
name|uchr
operator|)
operator|&
literal|0xFF
argument_list|)
operator|==
literal|'o'
condition|)
block|{
name|base
operator|=
literal|8
expr_stmt|;
name|uchr
operator|++
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
call|(
name|char
call|)
argument_list|(
operator|(
operator|*
name|uchr
operator|)
operator|&
literal|0xFF
argument_list|)
operator|==
literal|'x'
condition|)
block|{
name|base
operator|=
literal|16
expr_stmt|;
name|uchr
operator|++
expr_stmt|;
name|len
operator|-=
literal|2
expr_stmt|;
block|}
else|else
name|base
operator|=
literal|10
expr_stmt|;
block|}
name|astr
operator|=
name|abuf
expr_stmt|;
if|if
condition|(
name|neg
condition|)
block|{
name|strcpy
argument_list|(
name|astr
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|astr
operator|++
expr_stmt|;
block|}
name|ndis_unicode_to_ascii
argument_list|(
name|uchr
argument_list|,
name|len
argument_list|,
operator|&
name|astr
argument_list|)
expr_stmt|;
operator|*
name|val
operator|=
name|strtoul
argument_list|(
name|abuf
argument_list|,
name|NULL
argument_list|,
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
name|NDIS_STATUS_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|RtlFreeUnicodeString
parameter_list|(
name|ustr
parameter_list|)
name|ndis_unicode_string
modifier|*
name|ustr
decl_stmt|;
block|{
if|if
condition|(
name|ustr
operator|->
name|us_buf
operator|==
name|NULL
condition|)
return|return;
name|free
argument_list|(
name|ustr
operator|->
name|us_buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ustr
operator|->
name|us_buf
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|RtlFreeAnsiString
parameter_list|(
name|astr
parameter_list|)
name|ndis_ansi_string
modifier|*
name|astr
decl_stmt|;
block|{
if|if
condition|(
name|astr
operator|->
name|nas_buf
operator|==
name|NULL
condition|)
return|return;
name|free
argument_list|(
name|astr
operator|->
name|nas_buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|astr
operator|->
name|nas_buf
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|atoi
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
return|return
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|str
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|long
name|atol
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
return|return
name|strtol
argument_list|(
name|str
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rand
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|srandom
argument_list|(
name|tv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|random
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|srand
parameter_list|(
name|seed
parameter_list|)
name|unsigned
name|int
name|seed
decl_stmt|;
block|{
name|srandom
argument_list|(
name|seed
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|IoIsWdmVersionAvailable
parameter_list|(
name|major
parameter_list|,
name|minor
parameter_list|)
name|uint8_t
name|major
decl_stmt|;
name|uint8_t
name|minor
decl_stmt|;
block|{
if|if
condition|(
name|major
operator|==
name|WDM_MAJOR
operator|&&
name|minor
operator|==
name|WDM_MINOR_WINXP
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ndis_status
name|IoGetDeviceProperty
parameter_list|(
name|devobj
parameter_list|,
name|regprop
parameter_list|,
name|buflen
parameter_list|,
name|prop
parameter_list|,
name|reslen
parameter_list|)
name|device_object
modifier|*
name|devobj
decl_stmt|;
name|uint32_t
name|regprop
decl_stmt|;
name|uint32_t
name|buflen
decl_stmt|;
name|void
modifier|*
name|prop
decl_stmt|;
name|uint32_t
modifier|*
name|reslen
decl_stmt|;
block|{
name|driver_object
modifier|*
name|drv
decl_stmt|;
name|uint16_t
modifier|*
modifier|*
name|name
decl_stmt|;
name|drv
operator|=
name|devobj
operator|->
name|do_drvobj
expr_stmt|;
switch|switch
condition|(
name|regprop
condition|)
block|{
case|case
name|DEVPROP_DRIVER_KEYNAME
case|:
name|name
operator|=
name|prop
expr_stmt|;
operator|*
name|name
operator|=
name|drv
operator|->
name|dro_drivername
operator|.
name|us_buf
expr_stmt|;
operator|*
name|reslen
operator|=
name|drv
operator|->
name|dro_drivername
operator|.
name|us_len
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|STATUS_INVALID_PARAMETER_2
operator|)
return|;
break|break;
block|}
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|KeInitializeMutex
parameter_list|(
name|kmutex
parameter_list|,
name|level
parameter_list|)
name|kmutant
modifier|*
name|kmutex
decl_stmt|;
name|uint32_t
name|level
decl_stmt|;
block|{
name|INIT_LIST_HEAD
argument_list|(
operator|(
operator|&
name|kmutex
operator|->
name|km_header
operator|.
name|dh_waitlisthead
operator|)
argument_list|)
expr_stmt|;
name|kmutex
operator|->
name|km_abandoned
operator|=
name|FALSE
expr_stmt|;
name|kmutex
operator|->
name|km_apcdisable
operator|=
literal|1
expr_stmt|;
name|kmutex
operator|->
name|km_header
operator|.
name|dh_sigstate
operator|=
name|TRUE
expr_stmt|;
name|kmutex
operator|->
name|km_header
operator|.
name|dh_type
operator|=
name|EVENT_TYPE_SYNC
expr_stmt|;
name|kmutex
operator|->
name|km_header
operator|.
name|dh_size
operator|=
name|OTYPE_MUTEX
expr_stmt|;
name|kmutex
operator|->
name|km_acquirecnt
operator|=
literal|0
expr_stmt|;
name|kmutex
operator|->
name|km_ownerthread
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|KeReleaseMutex
parameter_list|(
name|kmutex
parameter_list|,
name|kwait
parameter_list|)
name|kmutant
modifier|*
name|kmutex
decl_stmt|;
name|uint8_t
name|kwait
decl_stmt|;
block|{
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|kmutex
operator|->
name|km_ownerthread
operator|!=
name|curthread
operator|->
name|td_proc
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_MUTANT_NOT_OWNED
operator|)
return|;
block|}
name|kmutex
operator|->
name|km_acquirecnt
operator|--
expr_stmt|;
if|if
condition|(
name|kmutex
operator|->
name|km_acquirecnt
operator|==
literal|0
condition|)
block|{
name|kmutex
operator|->
name|km_ownerthread
operator|=
name|NULL
expr_stmt|;
name|ntoskrnl_wakeup
argument_list|(
operator|&
name|kmutex
operator|->
name|km_header
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|kmutex
operator|->
name|km_acquirecnt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|KeReadStateMutex
parameter_list|(
name|kmutex
parameter_list|)
name|kmutant
modifier|*
name|kmutex
decl_stmt|;
block|{
return|return
operator|(
name|kmutex
operator|->
name|km_header
operator|.
name|dh_sigstate
operator|)
return|;
block|}
end_function

begin_function
name|void
name|KeInitializeEvent
parameter_list|(
name|kevent
parameter_list|,
name|type
parameter_list|,
name|state
parameter_list|)
name|nt_kevent
modifier|*
name|kevent
decl_stmt|;
name|uint32_t
name|type
decl_stmt|;
name|uint8_t
name|state
decl_stmt|;
block|{
name|INIT_LIST_HEAD
argument_list|(
operator|(
operator|&
name|kevent
operator|->
name|k_header
operator|.
name|dh_waitlisthead
operator|)
argument_list|)
expr_stmt|;
name|kevent
operator|->
name|k_header
operator|.
name|dh_sigstate
operator|=
name|state
expr_stmt|;
name|kevent
operator|->
name|k_header
operator|.
name|dh_type
operator|=
name|type
expr_stmt|;
name|kevent
operator|->
name|k_header
operator|.
name|dh_size
operator|=
name|OTYPE_EVENT
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|uint32_t
name|KeResetEvent
parameter_list|(
name|kevent
parameter_list|)
name|nt_kevent
modifier|*
name|kevent
decl_stmt|;
block|{
name|uint32_t
name|prevstate
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|prevstate
operator|=
name|kevent
operator|->
name|k_header
operator|.
name|dh_sigstate
expr_stmt|;
name|kevent
operator|->
name|k_header
operator|.
name|dh_sigstate
operator|=
name|FALSE
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|prevstate
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|KeSetEvent
parameter_list|(
name|kevent
parameter_list|,
name|increment
parameter_list|,
name|kwait
parameter_list|)
name|nt_kevent
modifier|*
name|kevent
decl_stmt|;
name|uint32_t
name|increment
decl_stmt|;
name|uint8_t
name|kwait
decl_stmt|;
block|{
name|uint32_t
name|prevstate
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|prevstate
operator|=
name|kevent
operator|->
name|k_header
operator|.
name|dh_sigstate
expr_stmt|;
name|ntoskrnl_wakeup
argument_list|(
operator|&
name|kevent
operator|->
name|k_header
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|prevstate
operator|)
return|;
block|}
end_function

begin_function
name|void
name|KeClearEvent
parameter_list|(
name|kevent
parameter_list|)
name|nt_kevent
modifier|*
name|kevent
decl_stmt|;
block|{
name|kevent
operator|->
name|k_header
operator|.
name|dh_sigstate
operator|=
name|FALSE
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|uint32_t
name|KeReadStateEvent
parameter_list|(
name|kevent
parameter_list|)
name|nt_kevent
modifier|*
name|kevent
decl_stmt|;
block|{
return|return
operator|(
name|kevent
operator|->
name|k_header
operator|.
name|dh_sigstate
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ndis_status
name|ObReferenceObjectByHandle
parameter_list|(
name|handle
parameter_list|,
name|reqaccess
parameter_list|,
name|otype
parameter_list|,
name|accessmode
parameter_list|,
name|object
parameter_list|,
name|handleinfo
parameter_list|)
name|ndis_handle
name|handle
decl_stmt|;
name|uint32_t
name|reqaccess
decl_stmt|;
name|void
modifier|*
name|otype
decl_stmt|;
name|uint8_t
name|accessmode
decl_stmt|;
name|void
modifier|*
modifier|*
name|object
decl_stmt|;
name|void
modifier|*
modifier|*
name|handleinfo
decl_stmt|;
block|{
name|nt_objref
modifier|*
name|nr
decl_stmt|;
name|nr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|nt_objref
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr
operator|==
name|NULL
condition|)
return|return
operator|(
name|NDIS_STATUS_FAILURE
operator|)
return|;
name|INIT_LIST_HEAD
argument_list|(
operator|(
operator|&
name|nr
operator|->
name|no_dh
operator|.
name|dh_waitlisthead
operator|)
argument_list|)
expr_stmt|;
name|nr
operator|->
name|no_obj
operator|=
name|handle
expr_stmt|;
name|nr
operator|->
name|no_dh
operator|.
name|dh_size
operator|=
name|OTYPE_THREAD
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ntoskrnl_reflist
argument_list|,
name|nr
argument_list|,
name|link
argument_list|)
expr_stmt|;
operator|*
name|object
operator|=
name|nr
expr_stmt|;
return|return
operator|(
name|NDIS_STATUS_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ObfDereferenceObject
parameter_list|(
name|object
parameter_list|)
name|void
modifier|*
name|object
decl_stmt|;
block|{
name|nt_objref
modifier|*
name|nr
decl_stmt|;
name|nr
operator|=
name|object
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ntoskrnl_reflist
argument_list|,
name|nr
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|ZwClose
parameter_list|(
name|handle
parameter_list|)
name|ndis_handle
name|handle
decl_stmt|;
block|{
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is here just in case the thread returns without calling  * PsTerminateSystemThread().  */
end_comment

begin_function
specifier|static
name|void
name|ntoskrnl_thrfunc
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|thread_context
modifier|*
name|thrctx
decl_stmt|;
name|uint32_t
function_decl|(
modifier|*
name|tfunc
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|tctx
decl_stmt|;
name|uint32_t
name|rval
decl_stmt|;
name|thrctx
operator|=
name|arg
expr_stmt|;
name|tfunc
operator|=
name|thrctx
operator|->
name|tc_thrfunc
expr_stmt|;
name|tctx
operator|=
name|thrctx
operator|->
name|tc_thrctx
expr_stmt|;
name|free
argument_list|(
name|thrctx
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|rval
operator|=
name|MSCALL1
argument_list|(
name|tfunc
argument_list|,
name|tctx
argument_list|)
expr_stmt|;
name|PsTerminateSystemThread
argument_list|(
name|rval
argument_list|)
expr_stmt|;
return|return;
comment|/* notreached */
block|}
end_function

begin_function
specifier|static
name|ndis_status
name|PsCreateSystemThread
parameter_list|(
name|handle
parameter_list|,
name|reqaccess
parameter_list|,
name|objattrs
parameter_list|,
name|phandle
parameter_list|,
name|clientid
parameter_list|,
name|thrfunc
parameter_list|,
name|thrctx
parameter_list|)
name|ndis_handle
modifier|*
name|handle
decl_stmt|;
name|uint32_t
name|reqaccess
decl_stmt|;
name|void
modifier|*
name|objattrs
decl_stmt|;
name|ndis_handle
name|phandle
decl_stmt|;
name|void
modifier|*
name|clientid
decl_stmt|;
name|void
modifier|*
name|thrfunc
decl_stmt|;
name|void
modifier|*
name|thrctx
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|char
name|tname
index|[
literal|128
index|]
decl_stmt|;
name|thread_context
modifier|*
name|tc
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|tc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|thread_context
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tc
operator|==
name|NULL
condition|)
return|return
operator|(
name|NDIS_STATUS_FAILURE
operator|)
return|;
name|tc
operator|->
name|tc_thrctx
operator|=
name|thrctx
expr_stmt|;
name|tc
operator|->
name|tc_thrfunc
operator|=
name|thrfunc
expr_stmt|;
name|sprintf
argument_list|(
name|tname
argument_list|,
literal|"windows kthread %d"
argument_list|,
name|ntoskrnl_kth
argument_list|)
expr_stmt|;
name|error
operator|=
name|kthread_create
argument_list|(
name|ntoskrnl_thrfunc
argument_list|,
name|tc
argument_list|,
operator|&
name|p
argument_list|,
name|RFHIGHPID
argument_list|,
name|NDIS_KSTACK_PAGES
argument_list|,
name|tname
argument_list|)
expr_stmt|;
operator|*
name|handle
operator|=
name|p
expr_stmt|;
name|ntoskrnl_kth
operator|++
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * In Windows, the exit of a thread is an event that you're allowed  * to wait on, assuming you've obtained a reference to the thread using  * ObReferenceObjectByHandle(). Unfortunately, the only way we can  * simulate this behavior is to register each thread we create in a  * reference list, and if someone holds a reference to us, we poke  * them.  */
end_comment

begin_function
specifier|static
name|ndis_status
name|PsTerminateSystemThread
parameter_list|(
name|status
parameter_list|)
name|ndis_status
name|status
decl_stmt|;
block|{
name|struct
name|nt_objref
modifier|*
name|nr
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|nr
argument_list|,
argument|&ntoskrnl_reflist
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|nr
operator|->
name|no_obj
operator|!=
name|curthread
operator|->
name|td_proc
condition|)
continue|continue;
name|ntoskrnl_wakeup
argument_list|(
operator|&
name|nr
operator|->
name|no_dh
argument_list|)
expr_stmt|;
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|ntoskrnl_kth
operator|--
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|502113
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* notreached */
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|DbgPrint
parameter_list|(
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|DbgBreakPoint
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|502113
name|Debugger
argument_list|(
literal|"DbgBreakPoint(): breakpoint"
argument_list|)
expr_stmt|;
else|#
directive|else
name|kdb_enter
argument_list|(
literal|"DbgBreakPoint(): breakpoint"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|ntoskrnl_timercall
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|ktimer
modifier|*
name|timer
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|timer
operator|=
name|arg
expr_stmt|;
name|timer
operator|->
name|k_header
operator|.
name|dh_inserted
operator|=
name|FALSE
expr_stmt|;
comment|/* 	 * If this is a periodic timer, re-arm it 	 * so it will fire again. We do this before 	 * calling any deferred procedure calls because 	 * it's possible the DPC might cancel the timer, 	 * in which case it would be wrong for us to 	 * re-arm it again afterwards. 	 */
if|if
condition|(
name|timer
operator|->
name|k_period
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|timer
operator|->
name|k_period
operator|*
literal|1000
expr_stmt|;
name|timer
operator|->
name|k_header
operator|.
name|dh_inserted
operator|=
name|TRUE
expr_stmt|;
name|timer
operator|->
name|k_handle
operator|=
name|timeout
argument_list|(
name|ntoskrnl_timercall
argument_list|,
name|timer
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|timer
operator|->
name|k_dpc
operator|!=
name|NULL
condition|)
name|KeInsertQueueDpc
argument_list|(
name|timer
operator|->
name|k_dpc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ntoskrnl_wakeup
argument_list|(
operator|&
name|timer
operator|->
name|k_header
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|KeInitializeTimer
parameter_list|(
name|timer
parameter_list|)
name|ktimer
modifier|*
name|timer
decl_stmt|;
block|{
if|if
condition|(
name|timer
operator|==
name|NULL
condition|)
return|return;
name|KeInitializeTimerEx
argument_list|(
name|timer
argument_list|,
name|EVENT_TYPE_NOTIFY
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|KeInitializeTimerEx
parameter_list|(
name|timer
parameter_list|,
name|type
parameter_list|)
name|ktimer
modifier|*
name|timer
decl_stmt|;
name|uint32_t
name|type
decl_stmt|;
block|{
if|if
condition|(
name|timer
operator|==
name|NULL
condition|)
return|return;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|timer
argument_list|,
sizeof|sizeof
argument_list|(
name|ktimer
argument_list|)
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|(
operator|&
name|timer
operator|->
name|k_header
operator|.
name|dh_waitlisthead
operator|)
argument_list|)
expr_stmt|;
name|timer
operator|->
name|k_header
operator|.
name|dh_sigstate
operator|=
name|FALSE
expr_stmt|;
name|timer
operator|->
name|k_header
operator|.
name|dh_inserted
operator|=
name|FALSE
expr_stmt|;
name|timer
operator|->
name|k_header
operator|.
name|dh_type
operator|=
name|type
expr_stmt|;
name|timer
operator|->
name|k_header
operator|.
name|dh_size
operator|=
name|OTYPE_TIMER
expr_stmt|;
name|callout_handle_init
argument_list|(
operator|&
name|timer
operator|->
name|k_handle
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * DPC subsystem. A Windows Defered Procedure Call has the following  * properties:  * - It runs at DISPATCH_LEVEL.  * - It can have one of 3 importance values that control when it  *   runs relative to other DPCs in the queue.  * - On SMP systems, it can be set to run on a specific processor.  * In order to satisfy the last property, we create a DPC thread for  * each CPU in the system and bind it to that CPU. Each thread  * maintains three queues with different importance levels, which  * will be processed in order from lowest to highest.  *  * In Windows, interrupt handlers run as DPCs. (Not to be confused  * with ISRs, which run in interrupt context and can preempt DPCs.)  * ISRs are given the highest importance so that they'll take  * precedence over timers and other things.  */
end_comment

begin_function
specifier|static
name|void
name|ntoskrnl_dpc_thread
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|kdpc_queue
modifier|*
name|kq
decl_stmt|;
name|kdpc
modifier|*
name|d
decl_stmt|;
name|list_entry
modifier|*
name|l
decl_stmt|;
name|kq
operator|=
name|arg
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|kq
operator|->
name|kq_high
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|kq
operator|->
name|kq_low
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|kq
operator|->
name|kq_med
argument_list|)
expr_stmt|;
name|kq
operator|->
name|kq_td
operator|=
name|curthread
expr_stmt|;
name|kq
operator|->
name|kq_exit
operator|=
literal|0
expr_stmt|;
name|kq
operator|->
name|kq_state
operator|=
name|NDIS_PSTATE_SLEEPING
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|,
literal|"NDIS thread lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|KeInitializeEvent
argument_list|(
operator|&
name|kq
operator|->
name|kq_proc
argument_list|,
name|EVENT_TYPE_SYNC
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|KeInitializeEvent
argument_list|(
operator|&
name|kq
operator|->
name|kq_done
argument_list|,
name|EVENT_TYPE_SYNC
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|KeInitializeEvent
argument_list|(
operator|&
name|kq
operator|->
name|kq_dead
argument_list|,
name|EVENT_TYPE_SYNC
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|sched_pin
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|KeWaitForSingleObject
argument_list|(
operator|(
name|nt_dispatch_header
operator|*
operator|)
operator|&
name|kq
operator|->
name|kq_proc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|kq
operator|->
name|kq_exit
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
name|KeSetEvent
argument_list|(
operator|&
name|kq
operator|->
name|kq_dead
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
name|kq
operator|->
name|kq_state
operator|=
name|NDIS_PSTATE_RUNNING
expr_stmt|;
comment|/* Process high importance list first. */
name|l
operator|=
name|kq
operator|->
name|kq_high
operator|.
name|nle_flink
expr_stmt|;
while|while
condition|(
name|l
operator|!=
operator|&
name|kq
operator|->
name|kq_high
condition|)
block|{
name|d
operator|=
name|CONTAINING_RECORD
argument_list|(
name|l
argument_list|,
name|kdpc
argument_list|,
name|k_dpclistentry
argument_list|)
expr_stmt|;
name|REMOVE_LIST_ENTRY
argument_list|(
operator|(
operator|&
name|d
operator|->
name|k_dpclistentry
operator|)
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
name|ntoskrnl_run_dpc
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
name|l
operator|=
name|kq
operator|->
name|kq_high
operator|.
name|nle_flink
expr_stmt|;
block|}
comment|/* Now the medium importance list. */
name|l
operator|=
name|kq
operator|->
name|kq_med
operator|.
name|nle_flink
expr_stmt|;
while|while
condition|(
name|l
operator|!=
operator|&
name|kq
operator|->
name|kq_med
condition|)
block|{
name|d
operator|=
name|CONTAINING_RECORD
argument_list|(
name|l
argument_list|,
name|kdpc
argument_list|,
name|k_dpclistentry
argument_list|)
expr_stmt|;
name|REMOVE_LIST_ENTRY
argument_list|(
operator|(
operator|&
name|d
operator|->
name|k_dpclistentry
operator|)
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
name|ntoskrnl_run_dpc
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
name|l
operator|=
name|kq
operator|->
name|kq_med
operator|.
name|nle_flink
expr_stmt|;
block|}
comment|/* And finally the low importance list. */
name|l
operator|=
name|kq
operator|->
name|kq_low
operator|.
name|nle_flink
expr_stmt|;
while|while
condition|(
name|l
operator|!=
operator|&
name|kq
operator|->
name|kq_low
condition|)
block|{
name|d
operator|=
name|CONTAINING_RECORD
argument_list|(
name|l
argument_list|,
name|kdpc
argument_list|,
name|k_dpclistentry
argument_list|)
expr_stmt|;
name|REMOVE_LIST_ENTRY
argument_list|(
operator|(
operator|&
name|d
operator|->
name|k_dpclistentry
operator|)
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
name|ntoskrnl_run_dpc
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
name|l
operator|=
name|kq
operator|->
name|kq_low
operator|.
name|nle_flink
expr_stmt|;
block|}
name|kq
operator|->
name|kq_state
operator|=
name|NDIS_PSTATE_SLEEPING
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
name|KeSetEvent
argument_list|(
operator|&
name|kq
operator|->
name|kq_done
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|502113
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
comment|/* notreached */
block|}
end_function

begin_comment
comment|/*  * This is a wrapper for Windows deferred procedure calls that  * have been placed on an NDIS thread work queue. We need it  * since the DPC could be a _stdcall function. Also, as far as  * I can tell, defered procedure calls must run at DISPATCH_LEVEL.  */
end_comment

begin_function
specifier|static
name|void
name|ntoskrnl_run_dpc
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|kdpc_func
name|dpcfunc
decl_stmt|;
name|kdpc
modifier|*
name|dpc
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
name|dpc
operator|=
name|arg
expr_stmt|;
name|dpcfunc
operator|=
name|dpc
operator|->
name|k_deferedfunc
expr_stmt|;
if|if
condition|(
name|dpcfunc
operator|==
name|NULL
condition|)
return|return;
name|irql
operator|=
name|KeRaiseIrql
argument_list|(
name|DISPATCH_LEVEL
argument_list|)
expr_stmt|;
name|MSCALL4
argument_list|(
name|dpcfunc
argument_list|,
name|dpc
argument_list|,
name|dpc
operator|->
name|k_deferredctx
argument_list|,
name|dpc
operator|->
name|k_sysarg1
argument_list|,
name|dpc
operator|->
name|k_sysarg2
argument_list|)
expr_stmt|;
name|KeLowerIrql
argument_list|(
name|irql
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ntoskrnl_destroy_dpc_threads
parameter_list|(
name|void
parameter_list|)
block|{
name|kdpc_queue
modifier|*
name|kq
decl_stmt|;
name|kdpc
name|dpc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|kq
operator|=
name|kq_queues
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp_ncpus
condition|;
name|i
operator|++
control|)
block|{
name|kq
operator|+=
name|i
expr_stmt|;
name|kq
operator|->
name|kq_exit
operator|=
literal|1
expr_stmt|;
name|KeInitializeDpc
argument_list|(
operator|&
name|dpc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|KeSetTargetProcessorDpc
argument_list|(
operator|&
name|dpc
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|KeInsertQueueDpc
argument_list|(
operator|&
name|dpc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|KeWaitForSingleObject
argument_list|(
operator|(
name|nt_dispatch_header
operator|*
operator|)
operator|&
name|kq
operator|->
name|kq_dead
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|ntoskrnl_insert_dpc
parameter_list|(
name|head
parameter_list|,
name|dpc
parameter_list|)
name|list_entry
modifier|*
name|head
decl_stmt|;
name|kdpc
modifier|*
name|dpc
decl_stmt|;
block|{
name|list_entry
modifier|*
name|l
decl_stmt|;
name|kdpc
modifier|*
name|d
decl_stmt|;
name|l
operator|=
name|head
operator|->
name|nle_flink
expr_stmt|;
while|while
condition|(
name|l
operator|!=
name|head
condition|)
block|{
name|d
operator|=
name|CONTAINING_RECORD
argument_list|(
name|l
argument_list|,
name|kdpc
argument_list|,
name|k_dpclistentry
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|dpc
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|l
operator|=
name|l
operator|->
name|nle_flink
expr_stmt|;
block|}
name|INSERT_LIST_TAIL
argument_list|(
operator|(
name|head
operator|)
argument_list|,
operator|(
operator|&
name|dpc
operator|->
name|k_dpclistentry
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|KeInitializeDpc
parameter_list|(
name|dpc
parameter_list|,
name|dpcfunc
parameter_list|,
name|dpcctx
parameter_list|)
name|kdpc
modifier|*
name|dpc
decl_stmt|;
name|void
modifier|*
name|dpcfunc
decl_stmt|;
name|void
modifier|*
name|dpcctx
decl_stmt|;
block|{
if|if
condition|(
name|dpc
operator|==
name|NULL
condition|)
return|return;
name|dpc
operator|->
name|k_deferedfunc
operator|=
name|dpcfunc
expr_stmt|;
name|dpc
operator|->
name|k_deferredctx
operator|=
name|dpcctx
expr_stmt|;
name|dpc
operator|->
name|k_num
operator|=
name|KDPC_CPU_DEFAULT
expr_stmt|;
name|dpc
operator|->
name|k_importance
operator|=
name|KDPC_IMPORTANCE_MEDIUM
expr_stmt|;
name|dpc
operator|->
name|k_num
operator|=
name|KeGetCurrentProcessorNumber
argument_list|()
expr_stmt|;
comment|/* 	 * In case someone tries to dequeue a DPC that 	 * hasn't been queued yet. 	 */
name|dpc
operator|->
name|k_lock
operator|=
name|NULL
comment|/*&ntoskrnl_dispatchlock*/
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|(
operator|&
name|dpc
operator|->
name|k_dpclistentry
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|uint8_t
name|KeInsertQueueDpc
parameter_list|(
name|dpc
parameter_list|,
name|sysarg1
parameter_list|,
name|sysarg2
parameter_list|)
name|kdpc
modifier|*
name|dpc
decl_stmt|;
name|void
modifier|*
name|sysarg1
decl_stmt|;
name|void
modifier|*
name|sysarg2
decl_stmt|;
block|{
name|kdpc_queue
modifier|*
name|kq
decl_stmt|;
name|uint8_t
name|r
decl_stmt|;
name|int
name|state
decl_stmt|;
if|if
condition|(
name|dpc
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|dpc
operator|->
name|k_sysarg1
operator|=
name|sysarg1
expr_stmt|;
name|dpc
operator|->
name|k_sysarg2
operator|=
name|sysarg2
expr_stmt|;
comment|/* 	 * By default, the DPC is queued to run on the same CPU 	 * that scheduled it. 	 */
name|kq
operator|=
name|kq_queues
expr_stmt|;
if|if
condition|(
name|dpc
operator|->
name|k_num
operator|==
name|KDPC_CPU_DEFAULT
condition|)
name|kq
operator|+=
name|curthread
operator|->
name|td_oncpu
expr_stmt|;
else|else
name|kq
operator|+=
name|dpc
operator|->
name|k_num
expr_stmt|;
comment|/* 	 * Also by default, we put the DPC on the medium 	 * priority queue. 	 */
name|mtx_lock_spin
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpc
operator|->
name|k_importance
operator|==
name|KDPC_IMPORTANCE_HIGH
condition|)
name|r
operator|=
name|ntoskrnl_insert_dpc
argument_list|(
operator|&
name|kq
operator|->
name|kq_high
argument_list|,
name|dpc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dpc
operator|->
name|k_importance
operator|==
name|KDPC_IMPORTANCE_LOW
condition|)
name|r
operator|=
name|ntoskrnl_insert_dpc
argument_list|(
operator|&
name|kq
operator|->
name|kq_low
argument_list|,
name|dpc
argument_list|)
expr_stmt|;
else|else
name|r
operator|=
name|ntoskrnl_insert_dpc
argument_list|(
operator|&
name|kq
operator|->
name|kq_med
argument_list|,
name|dpc
argument_list|)
expr_stmt|;
name|dpc
operator|->
name|k_lock
operator|=
operator|&
name|kq
operator|->
name|kq_lock
expr_stmt|;
name|state
operator|=
name|kq
operator|->
name|kq_state
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|kq
operator|->
name|kq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|TRUE
operator|&&
name|state
operator|==
name|NDIS_PSTATE_SLEEPING
condition|)
name|KeSetEvent
argument_list|(
operator|&
name|kq
operator|->
name|kq_proc
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|KeRemoveQueueDpc
parameter_list|(
name|dpc
parameter_list|)
name|kdpc
modifier|*
name|dpc
decl_stmt|;
block|{
if|if
condition|(
name|dpc
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
name|dpc
operator|->
name|k_lock
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|mtx_lock_spin
argument_list|(
name|dpc
operator|->
name|k_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dpc
operator|->
name|k_dpclistentry
operator|.
name|nle_flink
operator|==
operator|&
name|dpc
operator|->
name|k_dpclistentry
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
name|dpc
operator|->
name|k_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|REMOVE_LIST_ENTRY
argument_list|(
operator|(
operator|&
name|dpc
operator|->
name|k_dpclistentry
operator|)
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
name|dpc
operator|->
name|k_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|KeSetImportanceDpc
parameter_list|(
name|dpc
parameter_list|,
name|imp
parameter_list|)
name|kdpc
modifier|*
name|dpc
decl_stmt|;
name|uint32_t
name|imp
decl_stmt|;
block|{
if|if
condition|(
name|imp
operator|!=
name|KDPC_IMPORTANCE_LOW
operator|&&
name|imp
operator|!=
name|KDPC_IMPORTANCE_MEDIUM
operator|&&
name|imp
operator|!=
name|KDPC_IMPORTANCE_HIGH
condition|)
return|return;
name|dpc
operator|->
name|k_importance
operator|=
operator|(
name|uint8_t
operator|)
name|imp
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|KeSetTargetProcessorDpc
parameter_list|(
name|dpc
parameter_list|,
name|cpu
parameter_list|)
name|kdpc
modifier|*
name|dpc
decl_stmt|;
name|uint8_t
name|cpu
decl_stmt|;
block|{
if|if
condition|(
name|cpu
operator|>
name|mp_ncpus
condition|)
return|return;
name|dpc
operator|->
name|k_num
operator|=
name|cpu
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|KeFlushQueuedDpcs
parameter_list|(
name|void
parameter_list|)
block|{
name|kdpc_queue
modifier|*
name|kq
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Poke each DPC queue and wait 	 * for them to drain. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp_ncpus
condition|;
name|i
operator|++
control|)
block|{
name|kq
operator|=
name|kq_queues
operator|+
name|i
expr_stmt|;
name|KeSetEvent
argument_list|(
operator|&
name|kq
operator|->
name|kq_proc
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|KeWaitForSingleObject
argument_list|(
operator|(
name|nt_dispatch_header
operator|*
operator|)
operator|&
name|kq
operator|->
name|kq_done
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|uint32_t
name|KeGetCurrentProcessorNumber
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
operator|(
name|uint32_t
operator|)
name|curthread
operator|->
name|td_oncpu
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|KeSetTimerEx
parameter_list|(
name|timer
parameter_list|,
name|duetime
parameter_list|,
name|period
parameter_list|,
name|dpc
parameter_list|)
name|ktimer
modifier|*
name|timer
decl_stmt|;
name|int64_t
name|duetime
decl_stmt|;
name|uint32_t
name|period
decl_stmt|;
name|kdpc
modifier|*
name|dpc
decl_stmt|;
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|uint64_t
name|curtime
decl_stmt|;
name|uint8_t
name|pending
decl_stmt|;
if|if
condition|(
name|timer
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|timer
operator|->
name|k_header
operator|.
name|dh_inserted
operator|==
name|TRUE
condition|)
block|{
name|untimeout
argument_list|(
name|ntoskrnl_timercall
argument_list|,
name|timer
argument_list|,
name|timer
operator|->
name|k_handle
argument_list|)
expr_stmt|;
name|timer
operator|->
name|k_header
operator|.
name|dh_inserted
operator|=
name|FALSE
expr_stmt|;
name|pending
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|pending
operator|=
name|FALSE
expr_stmt|;
name|timer
operator|->
name|k_duetime
operator|=
name|duetime
expr_stmt|;
name|timer
operator|->
name|k_period
operator|=
name|period
expr_stmt|;
name|timer
operator|->
name|k_header
operator|.
name|dh_sigstate
operator|=
name|FALSE
expr_stmt|;
name|timer
operator|->
name|k_dpc
operator|=
name|dpc
expr_stmt|;
if|if
condition|(
name|duetime
operator|<
literal|0
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|=
operator|-
operator|(
name|duetime
operator|)
operator|/
literal|10000000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
operator|-
operator|(
name|duetime
operator|)
operator|/
literal|10
operator|)
operator|-
operator|(
name|tv
operator|.
name|tv_sec
operator|*
literal|1000000
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ntoskrnl_time
argument_list|(
operator|&
name|curtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|duetime
operator|<
name|curtime
condition|)
name|tv
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|tv
operator|.
name|tv_sec
operator|=
operator|(
operator|(
name|duetime
operator|)
operator|-
name|curtime
operator|)
operator|/
literal|10000000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
operator|(
name|duetime
operator|)
operator|-
name|curtime
operator|)
operator|/
literal|10
operator|-
operator|(
name|tv
operator|.
name|tv_sec
operator|*
literal|1000000
operator|)
expr_stmt|;
block|}
block|}
name|timer
operator|->
name|k_header
operator|.
name|dh_inserted
operator|=
name|TRUE
expr_stmt|;
name|timer
operator|->
name|k_handle
operator|=
name|timeout
argument_list|(
name|ntoskrnl_timercall
argument_list|,
name|timer
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|pending
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|KeSetTimer
parameter_list|(
name|timer
parameter_list|,
name|duetime
parameter_list|,
name|dpc
parameter_list|)
name|ktimer
modifier|*
name|timer
decl_stmt|;
name|int64_t
name|duetime
decl_stmt|;
name|kdpc
modifier|*
name|dpc
decl_stmt|;
block|{
return|return
operator|(
name|KeSetTimerEx
argument_list|(
name|timer
argument_list|,
name|duetime
argument_list|,
literal|0
argument_list|,
name|dpc
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|KeCancelTimer
parameter_list|(
name|timer
parameter_list|)
name|ktimer
modifier|*
name|timer
decl_stmt|;
block|{
name|uint8_t
name|pending
decl_stmt|;
if|if
condition|(
name|timer
operator|==
name|NULL
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|timer
operator|->
name|k_header
operator|.
name|dh_inserted
operator|==
name|TRUE
condition|)
block|{
name|untimeout
argument_list|(
name|ntoskrnl_timercall
argument_list|,
name|timer
argument_list|,
name|timer
operator|->
name|k_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|timer
operator|->
name|k_dpc
operator|!=
name|NULL
condition|)
name|KeRemoveQueueDpc
argument_list|(
name|timer
operator|->
name|k_dpc
argument_list|)
expr_stmt|;
name|pending
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|pending
operator|=
name|KeRemoveQueueDpc
argument_list|(
name|timer
operator|->
name|k_dpc
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ntoskrnl_dispatchlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|pending
operator|)
return|;
block|}
end_function

begin_function
name|uint8_t
name|KeReadStateTimer
parameter_list|(
name|timer
parameter_list|)
name|ktimer
modifier|*
name|timer
decl_stmt|;
block|{
return|return
operator|(
name|timer
operator|->
name|k_header
operator|.
name|dh_sigstate
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dummy
parameter_list|()
block|{
name|printf
argument_list|(
literal|"ntoskrnl dummy called...\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_decl_stmt
name|image_patch_table
name|ntoskrnl_functbl
index|[]
init|=
block|{
name|IMPORT_SFUNC
argument_list|(
name|RtlCompareMemory
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|RtlEqualUnicodeString
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|RtlCopyUnicodeString
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|RtlUnicodeStringToAnsiString
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|RtlAnsiStringToUnicodeString
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|RtlInitAnsiString
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC_MAP
argument_list|(
name|RtlInitString
argument_list|,
name|RtlInitAnsiString
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|RtlInitUnicodeString
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|RtlFreeAnsiString
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|RtlFreeUnicodeString
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|RtlUnicodeStringToInteger
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|sprintf
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|vsprintf
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC_MAP
argument_list|(
name|_snprintf
argument_list|,
name|snprintf
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC_MAP
argument_list|(
name|_vsnprintf
argument_list|,
name|vsnprintf
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|DbgPrint
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|DbgBreakPoint
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|strncmp
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|strcmp
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|strncpy
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|strcpy
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|strlen
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC_MAP
argument_list|(
name|strstr
argument_list|,
name|ntoskrnl_strstr
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC_MAP
argument_list|(
name|strchr
argument_list|,
name|index
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|memcpy
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC_MAP
argument_list|(
name|memmove
argument_list|,
name|ntoskrnl_memset
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC_MAP
argument_list|(
name|memset
argument_list|,
name|ntoskrnl_memset
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoAllocateDriverObjectExtension
argument_list|,
literal|4
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoGetDriverObjectExtension
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|IofCallDriver
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|IofCompleteRequest
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoAcquireCancelSpinLock
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoReleaseCancelSpinLock
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoCancelIrp
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoCreateDevice
argument_list|,
literal|7
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoDeleteDevice
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoGetAttachedDevice
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoAttachDeviceToDeviceStack
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoDetachDevice
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoBuildSynchronousFsdRequest
argument_list|,
literal|7
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoBuildAsynchronousFsdRequest
argument_list|,
literal|6
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoBuildDeviceIoControlRequest
argument_list|,
literal|9
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoAllocateIrp
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoReuseIrp
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoMakeAssociatedIrp
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoFreeIrp
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoInitializeIrp
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeWaitForSingleObject
argument_list|,
literal|5
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeWaitForMultipleObjects
argument_list|,
literal|8
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|_allmul
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|_alldiv
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|_allrem
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_RFUNC
argument_list|(
name|_allshr
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_RFUNC
argument_list|(
name|_allshl
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|_aullmul
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|_aulldiv
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|_aullrem
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_RFUNC
argument_list|(
name|_aullshr
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_RFUNC
argument_list|(
name|_aullshl
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|atoi
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|atol
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|rand
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_CFUNC
argument_list|(
name|srand
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|WRITE_REGISTER_USHORT
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|READ_REGISTER_USHORT
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|WRITE_REGISTER_ULONG
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|READ_REGISTER_ULONG
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|READ_REGISTER_UCHAR
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|WRITE_REGISTER_UCHAR
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ExInitializePagedLookasideList
argument_list|,
literal|7
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ExDeletePagedLookasideList
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ExInitializeNPagedLookasideList
argument_list|,
literal|7
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ExDeleteNPagedLookasideList
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|InterlockedPopEntrySList
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|InterlockedPushEntrySList
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ExQueryDepthSList
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_FFUNC_MAP
argument_list|(
name|ExpInterlockedPopEntrySList
argument_list|,
name|InterlockedPopEntrySList
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_FFUNC_MAP
argument_list|(
name|ExpInterlockedPushEntrySList
argument_list|,
name|InterlockedPushEntrySList
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|ExInterlockedPopEntrySList
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|ExInterlockedPushEntrySList
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ExAllocatePoolWithTag
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ExFreePool
argument_list|,
literal|1
argument_list|)
block|,
ifdef|#
directive|ifdef
name|__i386__
name|IMPORT_FFUNC
argument_list|(
name|KefAcquireSpinLockAtDpcLevel
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|KefReleaseSpinLockFromDpcLevel
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|KeAcquireSpinLockRaiseToDpc
argument_list|,
literal|1
argument_list|)
block|,
else|#
directive|else
comment|/* 	 * For AMD64, we can get away with just mapping 	 * KeAcquireSpinLockRaiseToDpc() directly to KfAcquireSpinLock() 	 * because the calling conventions end up being the same. 	 * On i386, we have to be careful because KfAcquireSpinLock() 	 * is _fastcall but KeAcquireSpinLockRaiseToDpc() isn't. 	 */
name|IMPORT_SFUNC
argument_list|(
name|KeAcquireSpinLockAtDpcLevel
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeReleaseSpinLockFromDpcLevel
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC_MAP
argument_list|(
name|KeAcquireSpinLockRaiseToDpc
argument_list|,
name|KfAcquireSpinLock
argument_list|,
literal|1
argument_list|)
block|,
endif|#
directive|endif
name|IMPORT_SFUNC_MAP
argument_list|(
name|KeReleaseSpinLock
argument_list|,
name|KfReleaseSpinLock
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|InterlockedIncrement
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|InterlockedDecrement
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|InterlockedExchange
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|ExInterlockedAddLargeStatistic
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoAllocateMdl
argument_list|,
literal|5
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoFreeMdl
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|MmSizeOfMdl
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|MmMapLockedPages
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|MmMapLockedPagesSpecifyCache
argument_list|,
literal|6
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|MmUnmapLockedPages
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|MmBuildMdlForNonPagedPool
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|MmIsAddressValid
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeInitializeSpinLock
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoIsWdmVersionAvailable
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoGetDeviceProperty
argument_list|,
literal|5
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoAllocateWorkItem
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoFreeWorkItem
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|IoQueueWorkItem
argument_list|,
literal|4
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ExQueueWorkItem
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ntoskrnl_workitem
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeInitializeMutex
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeReleaseMutex
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeReadStateMutex
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeInitializeEvent
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeSetEvent
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeResetEvent
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeClearEvent
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeReadStateEvent
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeInitializeTimer
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeInitializeTimerEx
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeSetTimer
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeSetTimerEx
argument_list|,
literal|4
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeCancelTimer
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeReadStateTimer
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeInitializeDpc
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeInsertQueueDpc
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeRemoveQueueDpc
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeSetImportanceDpc
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeSetTargetProcessorDpc
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeFlushQueuedDpcs
argument_list|,
literal|0
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|KeGetCurrentProcessorNumber
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ObReferenceObjectByHandle
argument_list|,
literal|6
argument_list|)
block|,
name|IMPORT_FFUNC
argument_list|(
name|ObfDereferenceObject
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ZwClose
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|PsCreateSystemThread
argument_list|,
literal|7
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|PsTerminateSystemThread
argument_list|,
literal|1
argument_list|)
block|,
comment|/* 	 * This last entry is a catch-all for any function we haven't 	 * implemented yet. The PE import list patching routine will 	 * use it for any function that doesn't have an explicit match 	 * in this table. 	 */
block|{
name|NULL
block|,
operator|(
name|FUNC
operator|)
name|dummy
block|,
name|NULL
block|,
literal|0
block|,
name|WINDRV_WRAP_STDCALL
block|}
block|,
comment|/* End of list. */
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

end_unit

