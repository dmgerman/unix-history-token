begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2003  *	Bill Paul<wpaul@windriver.com>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Bill Paul.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/pccard/pccardvar.h>
end_include

begin_include
include|#
directive|include
file|"card_if.h"
end_include

begin_include
include|#
directive|include
file|<compat/ndis/pe_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/resource_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/ndis_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/hal_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/ntoskrnl_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/cfg_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/if_ndis/if_ndisvar.h>
end_include

begin_define
define|#
directive|define
name|__stdcall
value|__attribute__((__stdcall__))
end_define

begin_define
define|#
directive|define
name|NDIS_DUMMY_PATH
value|"\\\\some\\bogus\\path"
end_define

begin_function_decl
name|__stdcall
specifier|static
name|void
name|ndis_status_func
parameter_list|(
name|ndis_handle
parameter_list|,
name|ndis_status
parameter_list|,
name|void
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__stdcall
specifier|static
name|void
name|ndis_statusdone_func
parameter_list|(
name|ndis_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__stdcall
specifier|static
name|void
name|ndis_setdone_func
parameter_list|(
name|ndis_handle
parameter_list|,
name|ndis_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__stdcall
specifier|static
name|void
name|ndis_getdone_func
parameter_list|(
name|ndis_handle
parameter_list|,
name|ndis_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__stdcall
specifier|static
name|void
name|ndis_resetdone_func
parameter_list|(
name|ndis_handle
parameter_list|,
name|ndis_status
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * This allows us to export our symbols to other modules.  * Note that we call ourselves 'ndisapi' to avoid a namespace  * collision with if_ndis.ko, which internally calls itself  * 'ndis.'  */
end_comment

begin_function
specifier|static
name|int
name|ndis_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DEV_MODULE
argument_list|(
name|ndisapi
argument_list|,
name|ndis_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ndisapi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|__stdcall
specifier|static
name|void
name|ndis_status_func
parameter_list|(
name|adapter
parameter_list|,
name|status
parameter_list|,
name|sbuf
parameter_list|,
name|slen
parameter_list|)
name|ndis_handle
name|adapter
decl_stmt|;
name|ndis_status
name|status
decl_stmt|;
name|void
modifier|*
name|sbuf
decl_stmt|;
name|uint32_t
name|slen
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"status: %x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|__stdcall
specifier|static
name|void
name|ndis_statusdone_func
parameter_list|(
name|adapter
parameter_list|)
name|ndis_handle
name|adapter
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"status complete\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|__stdcall
specifier|static
name|void
name|ndis_setdone_func
parameter_list|(
name|adapter
parameter_list|,
name|status
parameter_list|)
name|ndis_handle
name|adapter
decl_stmt|;
name|ndis_status
name|status
decl_stmt|;
block|{
name|ndis_miniport_block
modifier|*
name|block
decl_stmt|;
name|block
operator|=
name|adapter
expr_stmt|;
name|block
operator|->
name|nmb_setstat
operator|=
name|status
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|block
operator|->
name|nmb_wkupdpctimer
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|__stdcall
specifier|static
name|void
name|ndis_getdone_func
parameter_list|(
name|adapter
parameter_list|,
name|status
parameter_list|)
name|ndis_handle
name|adapter
decl_stmt|;
name|ndis_status
name|status
decl_stmt|;
block|{
name|ndis_miniport_block
modifier|*
name|block
decl_stmt|;
name|block
operator|=
name|adapter
expr_stmt|;
name|block
operator|->
name|nmb_getstat
operator|=
name|status
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|block
operator|->
name|nmb_wkupdpctimer
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|__stdcall
specifier|static
name|void
name|ndis_resetdone_func
parameter_list|(
name|adapter
parameter_list|,
name|status
parameter_list|,
name|addressingreset
parameter_list|)
name|ndis_handle
name|adapter
decl_stmt|;
name|ndis_status
name|status
decl_stmt|;
name|uint8_t
name|addressingreset
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"reset done...\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_define
define|#
directive|define
name|NDIS_AM_RID
value|3
end_define

begin_function
name|int
name|ndis_alloc_amem
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|=
name|arg
expr_stmt|;
name|rid
operator|=
name|NDIS_AM_RID
expr_stmt|;
name|sc
operator|->
name|ndis_res_am
operator|=
name|bus_alloc_resource
argument_list|(
name|sc
operator|->
name|ndis_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
literal|0UL
argument_list|,
operator|~
literal|0UL
argument_list|,
literal|0x1000
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ndis_res_am
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ndis%d: failed to allocate attribute memory\n"
argument_list|,
name|sc
operator|->
name|ndis_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|error
operator|=
name|CARD_SET_MEMORY_OFFSET
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|ndis_dev
argument_list|)
argument_list|,
name|sc
operator|->
name|ndis_dev
argument_list|,
name|rid
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"ndis%d: CARD_SET_MEMORY_OFFSET() returned 0x%x\n"
argument_list|,
name|sc
operator|->
name|ndis_unit
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|CARD_SET_RES_FLAGS
argument_list|(
name|device_get_parent
argument_list|(
name|sc
operator|->
name|ndis_dev
argument_list|)
argument_list|,
name|sc
operator|->
name|ndis_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|PCCARD_A_MEM_ATTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"ndis%d: CARD_SET_RES_FLAGS() returned 0x%x\n"
argument_list|,
name|sc
operator|->
name|ndis_unit
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_create_sysctls
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_cfg
modifier|*
name|vals
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|=
name|arg
expr_stmt|;
name|vals
operator|=
name|sc
operator|->
name|ndis_regvals
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|ndis_cfglist_head
argument_list|)
expr_stmt|;
comment|/* Create the sysctl tree. */
name|sc
operator|->
name|ndis_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|sc
operator|->
name|ndis_ctx
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_hw
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|ndis_dev
argument_list|)
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
name|device_get_desc
argument_list|(
name|sc
operator|->
name|ndis_dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add the driver-specific registry keys. */
name|vals
operator|=
name|sc
operator|->
name|ndis_regvals
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|vals
operator|->
name|nc_cfgkey
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|vals
operator|->
name|nc_idx
operator|!=
name|sc
operator|->
name|ndis_devidx
condition|)
block|{
name|vals
operator|++
expr_stmt|;
continue|continue;
block|}
name|SYSCTL_ADD_STRING
argument_list|(
operator|&
name|sc
operator|->
name|ndis_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|ndis_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|vals
operator|->
name|nc_cfgkey
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|vals
operator|->
name|nc_val
argument_list|,
sizeof|sizeof
argument_list|(
name|vals
operator|->
name|nc_val
argument_list|)
argument_list|,
name|vals
operator|->
name|nc_cfgdesc
argument_list|)
expr_stmt|;
name|vals
operator|++
expr_stmt|;
block|}
comment|/* Now add a couple of builtin keys. */
comment|/* 	 * Environment can be either Windows (0) or WindowsNT (1). 	 * We qualify as the latter. 	 */
name|ndis_add_sysctl
argument_list|(
name|sc
argument_list|,
literal|"Environment"
argument_list|,
literal|"Windows environment"
argument_list|,
literal|"1"
argument_list|,
name|CTLFLAG_RD
argument_list|)
expr_stmt|;
comment|/* NDIS version should be 5.1. */
name|ndis_add_sysctl
argument_list|(
name|sc
argument_list|,
literal|"NdisVersion"
argument_list|,
literal|"NDIS API Version"
argument_list|,
literal|"0x00050001"
argument_list|,
name|CTLFLAG_RD
argument_list|)
expr_stmt|;
comment|/* Bus type (PCI, PCMCIA, etc...) */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d\n"
argument_list|,
operator|(
name|int
operator|)
name|sc
operator|->
name|ndis_iftype
argument_list|)
expr_stmt|;
name|ndis_add_sysctl
argument_list|(
name|sc
argument_list|,
literal|"BusType"
argument_list|,
literal|"Bus Type"
argument_list|,
name|buf
argument_list|,
name|CTLFLAG_RD
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ndis_res_io
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x%lx\n"
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|ndis_res_io
argument_list|)
argument_list|)
expr_stmt|;
name|ndis_add_sysctl
argument_list|(
name|sc
argument_list|,
literal|"IOBaseAddress"
argument_list|,
literal|"Base I/O Address"
argument_list|,
name|buf
argument_list|,
name|CTLFLAG_RD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|ndis_irq
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%lu\n"
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|ndis_irq
argument_list|)
argument_list|)
expr_stmt|;
name|ndis_add_sysctl
argument_list|(
name|sc
argument_list|,
literal|"InterruptNumber"
argument_list|,
literal|"Interrupt Number"
argument_list|,
name|buf
argument_list|,
name|CTLFLAG_RD
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_add_sysctl
parameter_list|(
name|arg
parameter_list|,
name|key
parameter_list|,
name|desc
parameter_list|,
name|val
parameter_list|,
name|flag
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ndis_cfglist
modifier|*
name|cfg
decl_stmt|;
name|char
name|descstr
index|[
literal|256
index|]
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|cfg
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ndis_cfglist
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_cfgkey
operator|=
name|strdup
argument_list|(
name|key
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|descstr
argument_list|,
sizeof|sizeof
argument_list|(
name|descstr
argument_list|)
argument_list|,
literal|"%s (dynamic)"
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_cfgdesc
operator|=
name|strdup
argument_list|(
name|descstr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
else|else
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_cfgdesc
operator|=
name|strdup
argument_list|(
name|desc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_val
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|ndis_cfglist_head
argument_list|,
name|cfg
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
operator|&
name|sc
operator|->
name|ndis_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|ndis_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_cfgkey
argument_list|,
name|flag
argument_list|,
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_val
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_val
argument_list|)
argument_list|,
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_cfgdesc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_flush_sysctls
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ndis_cfglist
modifier|*
name|cfg
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|ndis_cfglist_head
argument_list|)
condition|)
block|{
name|cfg
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|ndis_cfglist_head
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|ndis_cfglist_head
argument_list|,
name|cfg
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_cfgkey
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_cfgdesc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cfg
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ndis_return_packet
parameter_list|(
name|buf
parameter_list|,
name|arg
parameter_list|)
name|void
modifier|*
name|buf
decl_stmt|;
comment|/* not used */
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|ndis_packet
modifier|*
name|p
decl_stmt|;
name|__stdcall
name|ndis_return_handler
name|returnfunc
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
return|return;
name|p
operator|=
name|arg
expr_stmt|;
comment|/* Decrement refcount. */
name|p
operator|->
name|np_refcnt
operator|--
expr_stmt|;
comment|/* Release packet when refcount hits zero, otherwise return. */
if|if
condition|(
name|p
operator|->
name|np_refcnt
condition|)
return|return;
name|sc
operator|=
name|p
operator|->
name|np_softc
expr_stmt|;
name|returnfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_return_packet_func
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
expr_stmt|;
if|if
condition|(
name|returnfunc
operator|!=
name|NULL
condition|)
name|returnfunc
argument_list|(
name|adapter
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ndis_free_bufs
parameter_list|(
name|b0
parameter_list|)
name|ndis_buffer
modifier|*
name|b0
decl_stmt|;
block|{
name|ndis_buffer
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|b0
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
name|b0
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|b0
operator|->
name|nb_next
expr_stmt|;
name|free
argument_list|(
name|b0
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|b0
operator|=
name|next
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|ndis_free_packet
parameter_list|(
name|p
parameter_list|)
name|ndis_packet
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
name|ndis_free_bufs
argument_list|(
name|p
operator|->
name|np_private
operator|.
name|npp_head
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|ndis_convert_res
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_resource_list
modifier|*
name|rl
init|=
name|NULL
decl_stmt|;
name|cm_partial_resource_desc
modifier|*
name|prd
init|=
name|NULL
decl_stmt|;
name|ndis_miniport_block
modifier|*
name|block
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|block
operator|=
operator|&
name|sc
operator|->
name|ndis_block
expr_stmt|;
name|rl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ndis_resource_list
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|cm_partial_resource_desc
argument_list|)
operator|*
operator|(
name|sc
operator|->
name|ndis_rescnt
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|rl
operator|->
name|cprl_version
operator|=
literal|5
expr_stmt|;
name|rl
operator|->
name|cprl_version
operator|=
literal|1
expr_stmt|;
name|rl
operator|->
name|cprl_count
operator|=
name|sc
operator|->
name|ndis_rescnt
expr_stmt|;
name|prd
operator|=
name|rl
operator|->
name|cprl_partial_descs
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ndis_res_io
condition|)
block|{
name|prd
operator|->
name|cprd_type
operator|=
name|CmResourceTypePort
expr_stmt|;
name|prd
operator|->
name|u
operator|.
name|cprd_port
operator|.
name|cprd_start
operator|.
name|np_quad
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|ndis_res_io
argument_list|)
expr_stmt|;
name|prd
operator|->
name|u
operator|.
name|cprd_port
operator|.
name|cprd_len
operator|=
name|rman_get_size
argument_list|(
name|sc
operator|->
name|ndis_res_io
argument_list|)
expr_stmt|;
name|prd
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|ndis_res_mem
condition|)
block|{
name|prd
operator|->
name|cprd_type
operator|=
name|CmResourceTypeMemory
expr_stmt|;
name|prd
operator|->
name|u
operator|.
name|cprd_mem
operator|.
name|cprd_start
operator|.
name|np_quad
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|ndis_res_mem
argument_list|)
expr_stmt|;
name|prd
operator|->
name|u
operator|.
name|cprd_mem
operator|.
name|cprd_len
operator|=
name|rman_get_size
argument_list|(
name|sc
operator|->
name|ndis_res_mem
argument_list|)
expr_stmt|;
name|prd
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|ndis_irq
condition|)
block|{
name|prd
operator|->
name|cprd_type
operator|=
name|CmResourceTypeInterrupt
expr_stmt|;
name|prd
operator|->
name|u
operator|.
name|cprd_intr
operator|.
name|cprd_level
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|ndis_irq
argument_list|)
expr_stmt|;
name|prd
operator|->
name|u
operator|.
name|cprd_intr
operator|.
name|cprd_vector
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|ndis_irq
argument_list|)
expr_stmt|;
name|prd
operator|->
name|u
operator|.
name|cprd_intr
operator|.
name|cprd_affinity
operator|=
literal|0
expr_stmt|;
block|}
name|block
operator|->
name|nmb_rlist
operator|=
name|rl
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map an NDIS packet to an mbuf list. When an NDIS driver receives a  * packet, it will hand it to us in the form of an ndis_packet,  * which we need to convert to an mbuf that is then handed off  * to the stack. Note: we configure the mbuf list so that it uses  * the memory regions specified by the ndis_buffer structures in  * the ndis_packet as external storage. In most cases, this will  * point to a memory region allocated by the driver (either by  * ndis_malloc_withtag() or ndis_alloc_sharedmem()). We expect  * the driver to handle free()ing this region for is, so we set up  * a dummy no-op free handler for it.  */
end_comment

begin_function
name|int
name|ndis_ptom
parameter_list|(
name|m0
parameter_list|,
name|p
parameter_list|)
name|struct
name|mbuf
modifier|*
modifier|*
name|m0
decl_stmt|;
name|ndis_packet
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|ndis_buffer
modifier|*
name|buf
decl_stmt|;
name|ndis_packet_private
modifier|*
name|priv
decl_stmt|;
name|uint32_t
name|totlen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|m0
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|priv
operator|=
operator|&
name|p
operator|->
name|np_private
expr_stmt|;
name|buf
operator|=
name|priv
operator|->
name|npp_head
expr_stmt|;
name|p
operator|->
name|np_refcnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|buf
operator|=
name|priv
operator|->
name|npp_head
init|;
name|buf
operator|!=
name|NULL
condition|;
name|buf
operator|=
name|buf
operator|->
name|nb_next
control|)
block|{
if|if
condition|(
name|buf
operator|==
name|priv
operator|->
name|npp_head
condition|)
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
else|else
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m0
argument_list|)
expr_stmt|;
operator|*
name|m0
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|buf
operator|->
name|nb_bytecount
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|MDL_VA
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|MEXTADD
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|ndis_return_packet
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
name|EXT_NDIS
argument_list|)
expr_stmt|;
name|p
operator|->
name|np_refcnt
operator|++
expr_stmt|;
name|totlen
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|MT_HEADER
condition|)
operator|*
name|m0
operator|=
name|m
expr_stmt|;
else|else
name|prev
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|prev
operator|=
name|m
expr_stmt|;
block|}
operator|(
operator|*
name|m0
operator|)
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|totlen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create an mbuf chain from an NDIS packet chain.  * This is used mainly when transmitting packets, where we need  * to turn an mbuf off an interface's send queue and transform it  * into an NDIS packet which will be fed into the NDIS driver's  * send routine.  *  * NDIS packets consist of two parts: an ndis_packet structure,  * which is vaguely analagous to the pkthdr portion of an mbuf,  * and one or more ndis_buffer structures, which define the  * actual memory segments in which the packet data resides.  * We need to allocate one ndis_buffer for each mbuf in a chain,  * plus one ndis_packet as the header.  */
end_comment

begin_function
name|int
name|ndis_mtop
parameter_list|(
name|m0
parameter_list|,
name|p
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|ndis_packet
modifier|*
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|ndis_buffer
modifier|*
name|buf
init|=
name|NULL
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|ndis_packet_private
modifier|*
name|priv
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|m0
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* If caller didn't supply a packet, make one. */
if|if
condition|(
operator|*
name|p
operator|==
name|NULL
condition|)
block|{
operator|*
name|p
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ndis_packet
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|priv
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|np_private
expr_stmt|;
name|priv
operator|->
name|npp_totlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|priv
operator|->
name|npp_packetooboffset
operator|=
name|offsetof
argument_list|(
name|ndis_packet
argument_list|,
name|np_oob
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|==
literal|0
condition|)
continue|continue;
name|buf
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ndis_buffer
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|ndis_free_packet
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|MDL_INIT
argument_list|(
name|buf
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|npp_head
operator|==
name|NULL
condition|)
name|priv
operator|->
name|npp_head
operator|=
name|buf
expr_stmt|;
else|else
name|prev
operator|->
name|nb_next
operator|=
name|buf
expr_stmt|;
name|prev
operator|=
name|buf
expr_stmt|;
block|}
name|priv
operator|->
name|npp_tail
operator|=
name|buf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_get_supported_oids
parameter_list|(
name|arg
parameter_list|,
name|oids
parameter_list|,
name|oidcnt
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|ndis_oid
modifier|*
modifier|*
name|oids
decl_stmt|;
name|int
modifier|*
name|oidcnt
decl_stmt|;
block|{
name|int
name|len
decl_stmt|,
name|rval
decl_stmt|;
name|ndis_oid
modifier|*
name|o
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
operator|||
name|oids
operator|==
name|NULL
operator|||
name|oidcnt
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|len
operator|=
literal|0
expr_stmt|;
name|ndis_get_info
argument_list|(
name|arg
argument_list|,
name|OID_GEN_SUPPORTED_LIST
argument_list|,
name|NULL
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|o
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|rval
operator|=
name|ndis_get_info
argument_list|(
name|arg
argument_list|,
name|OID_GEN_SUPPORTED_LIST
argument_list|,
name|o
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
name|free
argument_list|(
name|o
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
operator|*
name|oids
operator|=
name|o
expr_stmt|;
operator|*
name|oidcnt
operator|=
name|len
operator|/
literal|4
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_set_info
parameter_list|(
name|arg
parameter_list|,
name|oid
parameter_list|,
name|buf
parameter_list|,
name|buflen
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|ndis_oid
name|oid
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|int
modifier|*
name|buflen
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_status
name|rval
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|__stdcall
name|ndis_setinfo_handler
name|setfunc
decl_stmt|;
name|uint32_t
name|byteswritten
init|=
literal|0
decl_stmt|,
name|bytesneeded
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|setfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_setinfo_func
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
expr_stmt|;
name|rval
operator|=
name|setfunc
argument_list|(
name|adapter
argument_list|,
name|oid
argument_list|,
name|buf
argument_list|,
operator|*
name|buflen
argument_list|,
operator|&
name|byteswritten
argument_list|,
operator|&
name|bytesneeded
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_PENDING
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|=
literal|60
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_wkupdpctimer
argument_list|,
name|PPAUSE
operator||
name|PCATCH
argument_list|,
literal|"ndisset"
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_setstat
expr_stmt|;
block|}
if|if
condition|(
name|byteswritten
condition|)
operator|*
name|buflen
operator|=
name|byteswritten
expr_stmt|;
if|if
condition|(
name|bytesneeded
condition|)
operator|*
name|buflen
operator|=
name|bytesneeded
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_INVALID_LENGTH
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_INVALID_OID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_NOT_SUPPORTED
operator|||
name|rval
operator|==
name|NDIS_STATUS_NOT_ACCEPTED
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_send_packets
parameter_list|(
name|arg
parameter_list|,
name|packets
parameter_list|,
name|cnt
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|ndis_packet
modifier|*
modifier|*
name|packets
decl_stmt|;
name|int
name|cnt
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|__stdcall
name|ndis_sendmulti_handler
name|sendfunc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|idx
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|ndis_packet
modifier|*
name|p
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
expr_stmt|;
name|sendfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_sendmulti_func
expr_stmt|;
name|sendfunc
argument_list|(
name|adapter
argument_list|,
name|packets
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|packets
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|np_oob
operator|.
name|npo_status
operator|==
name|NDIS_STATUS_PENDING
condition|)
continue|continue;
name|idx
operator|=
name|p
operator|->
name|np_txidx
expr_stmt|;
name|m
operator|=
name|p
operator|->
name|np_m0
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ndis_sc
condition|)
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|ndis_ttag
argument_list|,
name|sc
operator|->
name|ndis_tmaps
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ndis_txarray
index|[
name|idx
index|]
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|ndis_txpending
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ndis_free_packet
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|np_oob
operator|.
name|npo_status
operator|==
name|NDIS_STATUS_SUCCESS
condition|)
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
else|else
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_init_dma
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|sc
operator|->
name|ndis_tmaps
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bus_dmamap_t
argument_list|)
operator|*
name|sc
operator|->
name|ndis_maxpkts
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ndis_tmaps
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|ndis_maxpkts
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|ndis_ttag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|ndis_tmaps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|ndis_tmaps
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_destroy_dma
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|ndis_packet
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|ndis_maxpkts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|ndis_txarray
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|sc
operator|->
name|ndis_txarray
index|[
name|i
index|]
expr_stmt|;
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|p
operator|->
name|np_rsvd
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ndis_free_packet
argument_list|(
name|sc
operator|->
name|ndis_txarray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|ndis_ttag
argument_list|,
name|sc
operator|->
name|ndis_tmaps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|ndis_tmaps
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|ndis_ttag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_reset_nic
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|__stdcall
name|ndis_reset_handler
name|resetfunc
decl_stmt|;
name|uint8_t
name|addressing_reset
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|resetfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_reset_func
expr_stmt|;
if|if
condition|(
name|resetfunc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|resetfunc
argument_list|(
operator|&
name|addressing_reset
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_halt_nic
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|__stdcall
name|ndis_halt_handler
name|haltfunc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ndis_timer_entry
modifier|*
name|ne
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|haltfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_halt_func
expr_stmt|;
if|if
condition|(
name|haltfunc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|haltfunc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
comment|/* 	 * The adapter context is only valid after the init 	 * handler has been called, and is invalid once the 	 * halt handler has been called. 	 */
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
operator|=
name|NULL
expr_stmt|;
comment|/* Clobber all the timers in case the driver left one running. */
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_timerlist
argument_list|)
condition|)
block|{
name|ne
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_timerlist
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_timerlist
argument_list|,
name|ne
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|ne
operator|->
name|nte_ch
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ne
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_shutdown_nic
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|__stdcall
name|ndis_shutdown_handler
name|shutdownfunc
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|shutdownfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_shutdown_handler
expr_stmt|;
if|if
condition|(
name|shutdownfunc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_rsvd0
operator|==
name|NULL
condition|)
name|shutdownfunc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
else|else
name|shutdownfunc
argument_list|(
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_rsvd0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_init_nic
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_miniport_block
modifier|*
name|block
decl_stmt|;
name|__stdcall
name|ndis_init_handler
name|initfunc
decl_stmt|;
name|ndis_status
name|status
decl_stmt|,
name|openstatus
init|=
literal|0
decl_stmt|;
name|ndis_medium
name|mediumarray
index|[
name|NdisMediumMax
index|]
decl_stmt|;
name|uint32_t
name|chosenmedium
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|=
name|arg
expr_stmt|;
name|block
operator|=
operator|&
name|sc
operator|->
name|ndis_block
expr_stmt|;
name|initfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_init_func
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|block
operator|->
name|nmb_timerlist
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NdisMediumMax
condition|;
name|i
operator|++
control|)
name|mediumarray
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|status
operator|=
name|initfunc
argument_list|(
operator|&
name|openstatus
argument_list|,
operator|&
name|chosenmedium
argument_list|,
name|mediumarray
argument_list|,
name|NdisMediumMax
argument_list|,
name|block
argument_list|,
name|block
argument_list|)
expr_stmt|;
comment|/* 	 * If the init fails, blow away the other exported routines 	 * we obtained from the driver so we can't call them later. 	 * If the init failed, none of these will work. 	 */
if|if
condition|(
name|status
operator|!=
name|NDIS_STATUS_SUCCESS
condition|)
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|ndis_chars
argument_list|,
sizeof|sizeof
argument_list|(
name|ndis_miniport_characteristics
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ndis_enable_intr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|__stdcall
name|ndis_enable_interrupts_handler
name|intrenbfunc
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
condition|)
return|return;
name|intrenbfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_enable_interrupts_func
expr_stmt|;
if|if
condition|(
name|intrenbfunc
operator|==
name|NULL
condition|)
return|return;
name|intrenbfunc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ndis_disable_intr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|__stdcall
name|ndis_disable_interrupts_handler
name|intrdisfunc
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
condition|)
return|return;
name|intrdisfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_disable_interrupts_func
expr_stmt|;
if|if
condition|(
name|intrdisfunc
operator|==
name|NULL
condition|)
return|return;
name|intrdisfunc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|ndis_isr
parameter_list|(
name|arg
parameter_list|,
name|ourintr
parameter_list|,
name|callhandler
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|int
modifier|*
name|ourintr
decl_stmt|;
name|int
modifier|*
name|callhandler
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|__stdcall
name|ndis_isr_handler
name|isrfunc
decl_stmt|;
name|uint8_t
name|accepted
decl_stmt|,
name|queue
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
operator|||
name|ourintr
operator|==
name|NULL
operator|||
name|callhandler
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|=
name|arg
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
expr_stmt|;
name|isrfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_isr_func
expr_stmt|;
name|isrfunc
argument_list|(
operator|&
name|accepted
argument_list|,
operator|&
name|queue
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
operator|*
name|ourintr
operator|=
name|accepted
expr_stmt|;
operator|*
name|callhandler
operator|=
name|queue
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_intrhand
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|__stdcall
name|ndis_interrupt_handler
name|intrfunc
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|=
name|arg
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
expr_stmt|;
name|intrfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_interrupt_func
expr_stmt|;
name|intrfunc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_get_info
parameter_list|(
name|arg
parameter_list|,
name|oid
parameter_list|,
name|buf
parameter_list|,
name|buflen
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|ndis_oid
name|oid
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|int
modifier|*
name|buflen
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_status
name|rval
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|__stdcall
name|ndis_queryinfo_handler
name|queryfunc
decl_stmt|;
name|uint32_t
name|byteswritten
init|=
literal|0
decl_stmt|,
name|bytesneeded
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|queryfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_queryinfo_func
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
expr_stmt|;
name|rval
operator|=
name|queryfunc
argument_list|(
name|adapter
argument_list|,
name|oid
argument_list|,
name|buf
argument_list|,
operator|*
name|buflen
argument_list|,
operator|&
name|byteswritten
argument_list|,
operator|&
name|bytesneeded
argument_list|)
expr_stmt|;
comment|/* Wait for requests that block. */
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_PENDING
condition|)
block|{
name|tv
operator|.
name|tv_sec
operator|=
literal|60
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_wkupdpctimer
argument_list|,
name|PPAUSE
operator||
name|PCATCH
argument_list|,
literal|"ndisget"
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|)
expr_stmt|;
name|rval
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_getstat
expr_stmt|;
block|}
if|if
condition|(
name|byteswritten
condition|)
operator|*
name|buflen
operator|=
name|byteswritten
expr_stmt|;
if|if
condition|(
name|bytesneeded
condition|)
operator|*
name|buflen
operator|=
name|bytesneeded
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_INVALID_LENGTH
operator|||
name|rval
operator|==
name|NDIS_STATUS_BUFFER_TOO_SHORT
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_INVALID_OID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_NOT_SUPPORTED
operator|||
name|rval
operator|==
name|NDIS_STATUS_NOT_ACCEPTED
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_unload_driver
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_rlist
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ndis_flush_sysctls
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ndis_libfini
argument_list|()
expr_stmt|;
name|ntoskrnl_libfini
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_load_driver
parameter_list|(
name|img
parameter_list|,
name|arg
parameter_list|)
name|vm_offset_t
name|img
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|__stdcall
name|driver_entry
name|entry
decl_stmt|;
name|image_optional_header
name|opt_hdr
decl_stmt|;
name|image_import_descriptor
name|imp_desc
decl_stmt|;
name|ndis_unicode_string
name|dummystr
decl_stmt|;
name|ndis_driver_object
name|drv
decl_stmt|;
name|ndis_miniport_block
modifier|*
name|block
decl_stmt|;
name|ndis_status
name|status
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|uint32_t
modifier|*
name|ptr
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
comment|/* Perform text relocation */
if|if
condition|(
name|pe_relocate
argument_list|(
name|img
argument_list|)
condition|)
return|return
operator|(
name|ENOEXEC
operator|)
return|;
comment|/* Dynamically link the NDIS.SYS routines -- required. */
if|if
condition|(
name|pe_patch_imports
argument_list|(
name|img
argument_list|,
literal|"NDIS"
argument_list|,
name|ndis_functbl
argument_list|)
condition|)
return|return
operator|(
name|ENOEXEC
operator|)
return|;
comment|/* Dynamically link the HAL.dll routines -- also required. */
if|if
condition|(
name|pe_patch_imports
argument_list|(
name|img
argument_list|,
literal|"HAL"
argument_list|,
name|hal_functbl
argument_list|)
condition|)
return|return
operator|(
name|ENOEXEC
operator|)
return|;
comment|/* Dynamically link ntoskrnl.exe -- optional. */
if|if
condition|(
name|pe_get_import_descriptor
argument_list|(
name|img
argument_list|,
operator|&
name|imp_desc
argument_list|,
literal|"ntoskrnl"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pe_patch_imports
argument_list|(
name|img
argument_list|,
literal|"ntoskrnl"
argument_list|,
name|ntoskrnl_functbl
argument_list|)
condition|)
return|return
operator|(
name|ENOEXEC
operator|)
return|;
block|}
comment|/* Initialize subsystems */
name|ndis_libinit
argument_list|()
expr_stmt|;
name|ntoskrnl_libinit
argument_list|()
expr_stmt|;
comment|/* Locate the driver entry point */
name|pe_get_optional_header
argument_list|(
name|img
argument_list|,
operator|&
name|opt_hdr
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|(
name|driver_entry
operator|)
name|pe_translate_addr
argument_list|(
name|img
argument_list|,
name|opt_hdr
operator|.
name|ioh_entryaddr
argument_list|)
expr_stmt|;
comment|/* 	 * Now call the DriverEntry() routine. This will cause 	 * a callout to the NdisInitializeWrapper() and 	 * NdisMRegisterMiniport() routines. 	 */
name|dummystr
operator|.
name|nus_len
operator|=
name|strlen
argument_list|(
name|NDIS_DUMMY_PATH
argument_list|)
expr_stmt|;
name|dummystr
operator|.
name|nus_maxlen
operator|=
name|strlen
argument_list|(
name|NDIS_DUMMY_PATH
argument_list|)
expr_stmt|;
name|dummystr
operator|.
name|nus_buf
operator|=
name|NULL
expr_stmt|;
name|ndis_ascii_to_unicode
argument_list|(
name|NDIS_DUMMY_PATH
argument_list|,
operator|&
name|dummystr
operator|.
name|nus_buf
argument_list|)
expr_stmt|;
name|drv
operator|.
name|ndo_ifname
operator|=
literal|"ndis0"
expr_stmt|;
name|status
operator|=
name|entry
argument_list|(
operator|&
name|drv
argument_list|,
operator|&
name|dummystr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dummystr
operator|.
name|nus_buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|NDIS_STATUS_SUCCESS
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
comment|/* 	 * Now that we have the miniport driver characteristics, 	 * create an NDIS block and call the init handler. 	 * This will cause the driver to try to probe for 	 * a device. 	 */
name|block
operator|=
operator|&
name|sc
operator|->
name|ndis_block
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|drv
operator|.
name|ndo_chars
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|ndis_chars
argument_list|,
sizeof|sizeof
argument_list|(
name|ndis_miniport_characteristics
argument_list|)
argument_list|)
expr_stmt|;
comment|/*block->nmb_signature = 0xcafebabe;*/
name|ptr
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|block
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
sizeof|sizeof
argument_list|(
name|ndis_miniport_block
argument_list|)
operator|/
literal|4
condition|;
name|idx
operator|++
control|)
block|{
operator|*
name|ptr
operator|=
name|idx
operator||
literal|0xdead0000
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
name|block
operator|->
name|nmb_signature
operator|=
operator|(
name|void
operator|*
operator|)
literal|0xcafebabe
expr_stmt|;
name|block
operator|->
name|nmb_setdone_func
operator|=
name|ndis_setdone_func
expr_stmt|;
name|block
operator|->
name|nmb_querydone_func
operator|=
name|ndis_getdone_func
expr_stmt|;
name|block
operator|->
name|nmb_status_func
operator|=
name|ndis_status_func
expr_stmt|;
name|block
operator|->
name|nmb_statusdone_func
operator|=
name|ndis_statusdone_func
expr_stmt|;
name|block
operator|->
name|nmb_resetdone_func
operator|=
name|ndis_resetdone_func
expr_stmt|;
name|block
operator|->
name|nmb_ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|block
operator|->
name|nmb_dev
operator|=
name|sc
operator|->
name|ndis_dev
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

