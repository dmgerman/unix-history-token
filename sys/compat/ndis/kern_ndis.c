begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2003  *	Bill Paul<wpaul@windriver.com>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Bill Paul.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/pe_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/resource_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/ntoskrnl_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/ndis_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/hal_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/cfg_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/if_ndis/if_ndisvar.h>
end_include

begin_define
define|#
directive|define
name|NDIS_DUMMY_PATH
value|"\\\\some\\bogus\\path"
end_define

begin_function_decl
name|__stdcall
specifier|static
name|void
name|ndis_status_func
parameter_list|(
name|ndis_handle
parameter_list|,
name|ndis_status
parameter_list|,
name|void
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__stdcall
specifier|static
name|void
name|ndis_statusdone_func
parameter_list|(
name|ndis_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__stdcall
specifier|static
name|void
name|ndis_setdone_func
parameter_list|(
name|ndis_handle
parameter_list|,
name|ndis_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__stdcall
specifier|static
name|void
name|ndis_getdone_func
parameter_list|(
name|ndis_handle
parameter_list|,
name|ndis_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__stdcall
specifier|static
name|void
name|ndis_resetdone_func
parameter_list|(
name|ndis_handle
parameter_list|,
name|ndis_status
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|__stdcall
specifier|static
name|void
name|ndis_sendrsrcavail_func
parameter_list|(
name|ndis_handle
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|nd_head
name|ndis_devhead
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ndis_req
block|{
name|void
function_decl|(
modifier|*
name|nr_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|nr_arg
decl_stmt|;
name|int
name|nr_exit
decl_stmt|;
name|STAILQ_ENTRY
argument_list|(
argument|ndis_req
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ndisproc
block|{
name|struct
name|ndisqhead
modifier|*
name|np_q
decl_stmt|;
name|struct
name|proc
modifier|*
name|np_p
decl_stmt|;
name|int
name|np_state
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|ndis_return
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ndis_create_kthreads
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ndis_destroy_kthreads
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ndis_stop_thread
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ndis_enlarge_thrqueue
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ndis_shrink_thrqueue
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ndis_runq
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|uma_zone_t
name|ndis_packet_zone
decl_stmt|,
name|ndis_buffer_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mtx
name|ndis_thr_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|STAILQ_HEAD
argument_list|(
argument|ndisqhead
argument_list|,
argument|ndis_req
argument_list|)
name|ndis_ttodo
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|ndisqhead
name|ndis_itodo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ndisqhead
name|ndis_free
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ndis_jobs
init|=
literal|32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ndisproc
name|ndis_tproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ndisproc
name|ndis_iproc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This allows us to export our symbols to other modules.  * Note that we call ourselves 'ndisapi' to avoid a namespace  * collision with if_ndis.ko, which internally calls itself  * 'ndis.'  */
end_comment

begin_function
specifier|static
name|int
name|ndis_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
comment|/* Initialize subsystems */
name|ndis_libinit
argument_list|()
expr_stmt|;
name|ntoskrnl_libinit
argument_list|()
expr_stmt|;
comment|/* Initialize TX buffer UMA zone. */
name|ndis_packet_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"NDIS packet"
argument_list|,
sizeof|sizeof
argument_list|(
name|ndis_packet
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ndis_buffer_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"NDIS buffer"
argument_list|,
sizeof|sizeof
argument_list|(
name|ndis_buffer
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ndis_create_kthreads
argument_list|()
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ndis_devhead
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_SHUTDOWN
case|:
comment|/* stop kthreads */
name|ndis_destroy_kthreads
argument_list|()
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|ndis_devhead
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* Shut down subsystems */
name|ndis_libfini
argument_list|()
expr_stmt|;
name|ntoskrnl_libfini
argument_list|()
expr_stmt|;
comment|/* Remove zones */
name|uma_zdestroy
argument_list|(
name|ndis_packet_zone
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|ndis_buffer_zone
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MOD_UNLOAD
case|:
comment|/* stop kthreads */
name|ndis_destroy_kthreads
argument_list|()
expr_stmt|;
comment|/* Shut down subsystems */
name|ndis_libfini
argument_list|()
expr_stmt|;
name|ntoskrnl_libfini
argument_list|()
expr_stmt|;
comment|/* Remove zones */
name|uma_zdestroy
argument_list|(
name|ndis_packet_zone
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|ndis_buffer_zone
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DEV_MODULE
argument_list|(
name|ndisapi
argument_list|,
name|ndis_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ndisapi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * We create two kthreads for the NDIS subsystem. One of them is a task  * queue for performing various odd jobs. The other is an swi thread  * reserved exclusively for running interrupt handlers. The reason we  * have our own task queue is that there are some cases where we may  * need to sleep for a significant amount of time, and if we were to  * use one of the taskqueue threads, we might delay the processing  * of other pending tasks which might need to run right away. We have  * a separate swi thread because we don't want our interrupt handling  * to be delayed either.  *  * By default there are 32 jobs available to start, and another 8  * are added to the free list each time a new device is created.  */
end_comment

begin_function
specifier|static
name|void
name|ndis_runq
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_req
modifier|*
name|r
init|=
name|NULL
decl_stmt|,
modifier|*
name|die
init|=
name|NULL
decl_stmt|;
name|struct
name|ndisproc
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|arg
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Sleep, but preserve our original priority. */
name|ndis_thsuspend
argument_list|(
name|p
operator|->
name|np_p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Look for any jobs on the work queue. */
name|mtx_lock
argument_list|(
operator|&
name|ndis_thr_mtx
argument_list|)
expr_stmt|;
name|p
operator|->
name|np_state
operator|=
name|NDIS_PSTATE_RUNNING
expr_stmt|;
while|while
condition|(
name|STAILQ_FIRST
argument_list|(
name|p
operator|->
name|np_q
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|r
operator|=
name|STAILQ_FIRST
argument_list|(
name|p
operator|->
name|np_q
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
name|p
operator|->
name|np_q
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ndis_thr_mtx
argument_list|)
expr_stmt|;
comment|/* Do the work. */
if|if
condition|(
name|r
operator|->
name|nr_func
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|r
operator|->
name|nr_func
call|)
argument_list|(
name|r
operator|->
name|nr_arg
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ndis_thr_mtx
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ndis_free
argument_list|,
name|r
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* Check for a shutdown request */
if|if
condition|(
name|r
operator|->
name|nr_exit
operator|==
name|TRUE
condition|)
name|die
operator|=
name|r
expr_stmt|;
block|}
name|p
operator|->
name|np_state
operator|=
name|NDIS_PSTATE_SLEEPING
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ndis_thr_mtx
argument_list|)
expr_stmt|;
comment|/* Bail if we were told to shut down. */
if|if
condition|(
name|die
operator|!=
name|NULL
condition|)
break|break;
block|}
name|wakeup
argument_list|(
name|die
argument_list|)
expr_stmt|;
name|kthread_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
comment|/* notreached */
block|}
end_function

begin_function
specifier|static
name|int
name|ndis_create_kthreads
parameter_list|()
block|{
name|struct
name|ndis_req
modifier|*
name|r
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ndis_thr_mtx
argument_list|,
literal|"NDIS thread lock"
argument_list|,
name|MTX_NDIS_LOCK
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|ndis_ttodo
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|ndis_itodo
argument_list|)
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|ndis_free
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndis_jobs
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ndis_req
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ndis_free
argument_list|,
name|r
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|ndis_tproc
operator|.
name|np_q
operator|=
operator|&
name|ndis_ttodo
expr_stmt|;
name|ndis_tproc
operator|.
name|np_state
operator|=
name|NDIS_PSTATE_SLEEPING
expr_stmt|;
name|error
operator|=
name|kthread_create
argument_list|(
name|ndis_runq
argument_list|,
operator|&
name|ndis_tproc
argument_list|,
operator|&
name|ndis_tproc
operator|.
name|np_p
argument_list|,
name|RFHIGHPID
argument_list|,
name|NDIS_KSTACK_PAGES
argument_list|,
literal|"ndis taskqueue"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|ndis_iproc
operator|.
name|np_q
operator|=
operator|&
name|ndis_itodo
expr_stmt|;
name|ndis_iproc
operator|.
name|np_state
operator|=
name|NDIS_PSTATE_SLEEPING
expr_stmt|;
name|error
operator|=
name|kthread_create
argument_list|(
name|ndis_runq
argument_list|,
operator|&
name|ndis_iproc
argument_list|,
operator|&
name|ndis_iproc
operator|.
name|np_p
argument_list|,
name|RFHIGHPID
argument_list|,
name|NDIS_KSTACK_PAGES
argument_list|,
literal|"ndis swi"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
while|while
condition|(
operator|(
name|r
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|ndis_free
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ndis_free
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ndis_destroy_kthreads
parameter_list|()
block|{
name|struct
name|ndis_req
modifier|*
name|r
decl_stmt|;
comment|/* Stop the threads. */
name|ndis_stop_thread
argument_list|(
name|NDIS_TASKQUEUE
argument_list|)
expr_stmt|;
name|ndis_stop_thread
argument_list|(
name|NDIS_SWI
argument_list|)
expr_stmt|;
comment|/* Destroy request structures. */
while|while
condition|(
operator|(
name|r
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|ndis_free
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ndis_free
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
name|mtx_destroy
argument_list|(
operator|&
name|ndis_thr_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ndis_stop_thread
parameter_list|(
name|t
parameter_list|)
name|int
name|t
decl_stmt|;
block|{
name|struct
name|ndis_req
modifier|*
name|r
decl_stmt|;
name|struct
name|ndisqhead
modifier|*
name|q
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NDIS_TASKQUEUE
condition|)
block|{
name|q
operator|=
operator|&
name|ndis_ttodo
expr_stmt|;
name|p
operator|=
name|ndis_tproc
operator|.
name|np_p
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
operator|&
name|ndis_itodo
expr_stmt|;
name|p
operator|=
name|ndis_iproc
operator|.
name|np_p
expr_stmt|;
block|}
comment|/* Create and post a special 'exit' job. */
name|mtx_lock
argument_list|(
operator|&
name|ndis_thr_mtx
argument_list|)
expr_stmt|;
name|r
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|ndis_free
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ndis_free
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|r
operator|->
name|nr_func
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|nr_arg
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|nr_exit
operator|=
name|TRUE
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
name|q
argument_list|,
name|r
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ndis_thr_mtx
argument_list|)
expr_stmt|;
name|ndis_thresume
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* wait for thread exit */
name|tsleep
argument_list|(
name|r
argument_list|,
name|curthread
operator|->
name|td_priority
operator||
name|PCATCH
argument_list|,
literal|"ndisthexit"
argument_list|,
name|hz
operator|*
literal|60
argument_list|)
expr_stmt|;
comment|/* Now empty the job list. */
name|mtx_lock
argument_list|(
operator|&
name|ndis_thr_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|STAILQ_FIRST
argument_list|(
name|q
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
name|q
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ndis_free
argument_list|,
name|r
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ndis_thr_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|ndis_enlarge_thrqueue
parameter_list|(
name|cnt
parameter_list|)
name|int
name|cnt
decl_stmt|;
block|{
name|struct
name|ndis_req
modifier|*
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ndis_req
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|ndis_thr_mtx
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ndis_free
argument_list|,
name|r
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ndis_jobs
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ndis_thr_mtx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ndis_shrink_thrqueue
parameter_list|(
name|cnt
parameter_list|)
name|int
name|cnt
decl_stmt|;
block|{
name|struct
name|ndis_req
modifier|*
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|ndis_thr_mtx
argument_list|)
expr_stmt|;
name|r
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|ndis_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ndis_thr_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ndis_free
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ndis_jobs
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ndis_thr_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int
name|ndis_unsched
argument_list|(
name|func
argument_list|,
name|arg
argument_list|,
name|t
argument_list|)
name|void
argument_list|(
operator|*
name|func
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|ndis_req
modifier|*
name|r
decl_stmt|;
name|struct
name|ndisqhead
modifier|*
name|q
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NDIS_TASKQUEUE
condition|)
block|{
name|q
operator|=
operator|&
name|ndis_ttodo
expr_stmt|;
name|p
operator|=
name|ndis_tproc
operator|.
name|np_p
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
operator|&
name|ndis_itodo
expr_stmt|;
name|p
operator|=
name|ndis_iproc
operator|.
name|np_p
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|ndis_thr_mtx
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|r
argument_list|,
argument|q
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|r
operator|->
name|nr_func
operator|==
name|func
operator|&&
name|r
operator|->
name|nr_arg
operator|==
name|arg
condition|)
block|{
name|STAILQ_REMOVE
argument_list|(
name|q
argument_list|,
name|r
argument_list|,
name|ndis_req
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|ndis_free
argument_list|,
name|r
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ndis_thr_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ndis_thr_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|int
name|ndis_sched
argument_list|(
name|func
argument_list|,
name|arg
argument_list|,
name|t
argument_list|)
name|void
argument_list|(
operator|*
name|func
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|ndis_req
modifier|*
name|r
decl_stmt|;
name|struct
name|ndisqhead
modifier|*
name|q
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NDIS_TASKQUEUE
condition|)
block|{
name|q
operator|=
operator|&
name|ndis_ttodo
expr_stmt|;
name|p
operator|=
name|ndis_tproc
operator|.
name|np_p
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
operator|&
name|ndis_itodo
expr_stmt|;
name|p
operator|=
name|ndis_iproc
operator|.
name|np_p
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|ndis_thr_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Check to see if an instance of this job is already 	 * pending. If so, don't bother queuing it again. 	 */
name|STAILQ_FOREACH
argument_list|(
argument|r
argument_list|,
argument|q
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|r
operator|->
name|nr_func
operator|==
name|func
operator|&&
name|r
operator|->
name|nr_arg
operator|==
name|arg
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ndis_thr_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|r
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|ndis_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|ndis_thr_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|ndis_free
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|r
operator|->
name|nr_func
operator|=
name|func
expr_stmt|;
name|r
operator|->
name|nr_arg
operator|=
name|arg
expr_stmt|;
name|r
operator|->
name|nr_exit
operator|=
name|FALSE
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
name|q
argument_list|,
name|r
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NDIS_TASKQUEUE
condition|)
name|s
operator|=
name|ndis_tproc
operator|.
name|np_state
expr_stmt|;
else|else
name|s
operator|=
name|ndis_iproc
operator|.
name|np_state
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ndis_thr_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Post the job, but only if the thread is actually blocked 	 * on its own suspend call. If a driver queues up a job with 	 * NdisScheduleWorkItem() which happens to do a KeWaitForObject(), 	 * it may suspend there, and in that case we don't want to wake 	 * it up until KeWaitForObject() gets woken up on its own. 	 */
if|if
condition|(
name|s
operator|==
name|NDIS_PSTATE_SLEEPING
condition|)
name|ndis_thresume
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_function
name|int
name|ndis_thsuspend
parameter_list|(
name|p
parameter_list|,
name|timo
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|timo
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
operator|&
name|p
operator|->
name|p_siglist
argument_list|,
operator|&
name|p
operator|->
name|p_mtx
argument_list|,
name|curthread
operator|->
name|td_priority
operator||
name|PDROP
argument_list|,
literal|"ndissp"
argument_list|,
name|timo
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ndis_thresume
parameter_list|(
name|p
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|wakeup
argument_list|(
operator|&
name|p
operator|->
name|p_siglist
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|__stdcall
specifier|static
name|void
name|ndis_sendrsrcavail_func
parameter_list|(
name|adapter
parameter_list|)
name|ndis_handle
name|adapter
decl_stmt|;
block|{
return|return;
block|}
end_function

begin_function
name|__stdcall
specifier|static
name|void
name|ndis_status_func
parameter_list|(
name|adapter
parameter_list|,
name|status
parameter_list|,
name|sbuf
parameter_list|,
name|slen
parameter_list|)
name|ndis_handle
name|adapter
decl_stmt|;
name|ndis_status
name|status
decl_stmt|;
name|void
modifier|*
name|sbuf
decl_stmt|;
name|uint32_t
name|slen
decl_stmt|;
block|{
name|ndis_miniport_block
modifier|*
name|block
decl_stmt|;
name|block
operator|=
name|adapter
expr_stmt|;
if|if
condition|(
name|block
operator|->
name|nmb_ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|device_printf
argument_list|(
name|block
operator|->
name|nmb_dev
argument_list|,
literal|"status: %x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|__stdcall
specifier|static
name|void
name|ndis_statusdone_func
parameter_list|(
name|adapter
parameter_list|)
name|ndis_handle
name|adapter
decl_stmt|;
block|{
name|ndis_miniport_block
modifier|*
name|block
decl_stmt|;
name|block
operator|=
name|adapter
expr_stmt|;
if|if
condition|(
name|block
operator|->
name|nmb_ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|device_printf
argument_list|(
name|block
operator|->
name|nmb_dev
argument_list|,
literal|"status complete\n"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|__stdcall
specifier|static
name|void
name|ndis_setdone_func
parameter_list|(
name|adapter
parameter_list|,
name|status
parameter_list|)
name|ndis_handle
name|adapter
decl_stmt|;
name|ndis_status
name|status
decl_stmt|;
block|{
name|ndis_miniport_block
modifier|*
name|block
decl_stmt|;
name|block
operator|=
name|adapter
expr_stmt|;
name|block
operator|->
name|nmb_setstat
operator|=
name|status
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|block
operator|->
name|nmb_wkupdpctimer
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|__stdcall
specifier|static
name|void
name|ndis_getdone_func
parameter_list|(
name|adapter
parameter_list|,
name|status
parameter_list|)
name|ndis_handle
name|adapter
decl_stmt|;
name|ndis_status
name|status
decl_stmt|;
block|{
name|ndis_miniport_block
modifier|*
name|block
decl_stmt|;
name|block
operator|=
name|adapter
expr_stmt|;
name|block
operator|->
name|nmb_getstat
operator|=
name|status
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|block
operator|->
name|nmb_wkupdpctimer
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|__stdcall
specifier|static
name|void
name|ndis_resetdone_func
parameter_list|(
name|adapter
parameter_list|,
name|status
parameter_list|,
name|addressingreset
parameter_list|)
name|ndis_handle
name|adapter
decl_stmt|;
name|ndis_status
name|status
decl_stmt|;
name|uint8_t
name|addressingreset
decl_stmt|;
block|{
name|ndis_miniport_block
modifier|*
name|block
decl_stmt|;
name|block
operator|=
name|adapter
expr_stmt|;
if|if
condition|(
name|block
operator|->
name|nmb_ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|device_printf
argument_list|(
name|block
operator|->
name|nmb_dev
argument_list|,
literal|"reset done...\n"
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|block
operator|->
name|nmb_ifp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|ndis_create_sysctls
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_cfg
modifier|*
name|vals
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|=
name|arg
expr_stmt|;
name|vals
operator|=
name|sc
operator|->
name|ndis_regvals
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|ndis_cfglist_head
argument_list|)
expr_stmt|;
comment|/* Create the sysctl tree. */
name|sc
operator|->
name|ndis_tree
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|sc
operator|->
name|ndis_ctx
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_hw
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|ndis_dev
argument_list|)
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
name|device_get_desc
argument_list|(
name|sc
operator|->
name|ndis_dev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add the driver-specific registry keys. */
name|vals
operator|=
name|sc
operator|->
name|ndis_regvals
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|vals
operator|->
name|nc_cfgkey
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|vals
operator|->
name|nc_idx
operator|!=
name|sc
operator|->
name|ndis_devidx
condition|)
block|{
name|vals
operator|++
expr_stmt|;
continue|continue;
block|}
name|SYSCTL_ADD_STRING
argument_list|(
operator|&
name|sc
operator|->
name|ndis_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|ndis_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|vals
operator|->
name|nc_cfgkey
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|vals
operator|->
name|nc_val
argument_list|,
sizeof|sizeof
argument_list|(
name|vals
operator|->
name|nc_val
argument_list|)
argument_list|,
name|vals
operator|->
name|nc_cfgdesc
argument_list|)
expr_stmt|;
name|vals
operator|++
expr_stmt|;
block|}
comment|/* Now add a couple of builtin keys. */
comment|/* 	 * Environment can be either Windows (0) or WindowsNT (1). 	 * We qualify as the latter. 	 */
name|ndis_add_sysctl
argument_list|(
name|sc
argument_list|,
literal|"Environment"
argument_list|,
literal|"Windows environment"
argument_list|,
literal|"1"
argument_list|,
name|CTLFLAG_RD
argument_list|)
expr_stmt|;
comment|/* NDIS version should be 5.1. */
name|ndis_add_sysctl
argument_list|(
name|sc
argument_list|,
literal|"NdisVersion"
argument_list|,
literal|"NDIS API Version"
argument_list|,
literal|"0x00050001"
argument_list|,
name|CTLFLAG_RD
argument_list|)
expr_stmt|;
comment|/* Bus type (PCI, PCMCIA, etc...) */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|sc
operator|->
name|ndis_iftype
argument_list|)
expr_stmt|;
name|ndis_add_sysctl
argument_list|(
name|sc
argument_list|,
literal|"BusType"
argument_list|,
literal|"Bus Type"
argument_list|,
name|buf
argument_list|,
name|CTLFLAG_RD
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ndis_res_io
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x%lx"
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|ndis_res_io
argument_list|)
argument_list|)
expr_stmt|;
name|ndis_add_sysctl
argument_list|(
name|sc
argument_list|,
literal|"IOBaseAddress"
argument_list|,
literal|"Base I/O Address"
argument_list|,
name|buf
argument_list|,
name|CTLFLAG_RD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|ndis_irq
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%lu"
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|ndis_irq
argument_list|)
argument_list|)
expr_stmt|;
name|ndis_add_sysctl
argument_list|(
name|sc
argument_list|,
literal|"InterruptNumber"
argument_list|,
literal|"Interrupt Number"
argument_list|,
name|buf
argument_list|,
name|CTLFLAG_RD
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_add_sysctl
parameter_list|(
name|arg
parameter_list|,
name|key
parameter_list|,
name|desc
parameter_list|,
name|val
parameter_list|,
name|flag
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ndis_cfglist
modifier|*
name|cfg
decl_stmt|;
name|char
name|descstr
index|[
literal|256
index|]
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|cfg
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ndis_cfglist
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_cfgkey
operator|=
name|strdup
argument_list|(
name|key
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|descstr
argument_list|,
sizeof|sizeof
argument_list|(
name|descstr
argument_list|)
argument_list|,
literal|"%s (dynamic)"
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_cfgdesc
operator|=
name|strdup
argument_list|(
name|descstr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
else|else
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_cfgdesc
operator|=
name|strdup
argument_list|(
name|desc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_val
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|ndis_cfglist_head
argument_list|,
name|cfg
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
operator|&
name|sc
operator|->
name|ndis_ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|sc
operator|->
name|ndis_tree
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_cfgkey
argument_list|,
name|flag
argument_list|,
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_val
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_val
argument_list|)
argument_list|,
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_cfgdesc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_flush_sysctls
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ndis_cfglist
modifier|*
name|cfg
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|ndis_cfglist_head
argument_list|)
condition|)
block|{
name|cfg
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|ndis_cfglist_head
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|ndis_cfglist_head
argument_list|,
name|cfg
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_cfgkey
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_cfgdesc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cfg
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ndis_return
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|__stdcall
name|ndis_return_handler
name|returnfunc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|ndis_packet
modifier|*
name|p
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
name|p
operator|=
name|arg
expr_stmt|;
name|sc
operator|=
name|p
operator|->
name|np_softc
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
condition|)
return|return;
name|returnfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_return_packet_func
expr_stmt|;
name|irql
operator|=
name|FASTCALL1
argument_list|(
name|hal_raise_irql
argument_list|,
name|DISPATCH_LEVEL
argument_list|)
expr_stmt|;
name|returnfunc
argument_list|(
name|adapter
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|FASTCALL1
argument_list|(
name|hal_lower_irql
argument_list|,
name|irql
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ndis_return_packet
parameter_list|(
name|buf
parameter_list|,
name|arg
parameter_list|)
name|void
modifier|*
name|buf
decl_stmt|;
comment|/* not used */
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|ndis_packet
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
return|return;
name|p
operator|=
name|arg
expr_stmt|;
comment|/* Decrement refcount. */
name|p
operator|->
name|np_refcnt
operator|--
expr_stmt|;
comment|/* Release packet when refcount hits zero, otherwise return. */
if|if
condition|(
name|p
operator|->
name|np_refcnt
condition|)
return|return;
name|ndis_sched
argument_list|(
name|ndis_return
argument_list|,
name|p
argument_list|,
name|NDIS_SWI
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ndis_free_bufs
parameter_list|(
name|b0
parameter_list|)
name|ndis_buffer
modifier|*
name|b0
decl_stmt|;
block|{
name|ndis_buffer
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|b0
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
name|b0
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|b0
operator|->
name|nb_next
expr_stmt|;
name|uma_zfree
argument_list|(
name|ndis_buffer_zone
argument_list|,
name|b0
argument_list|)
expr_stmt|;
name|b0
operator|=
name|next
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|ndis_free_packet
parameter_list|(
name|p
parameter_list|)
name|ndis_packet
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
name|ndis_free_bufs
argument_list|(
name|p
operator|->
name|np_private
operator|.
name|npp_head
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|ndis_packet_zone
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|ndis_convert_res
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_resource_list
modifier|*
name|rl
init|=
name|NULL
decl_stmt|;
name|cm_partial_resource_desc
modifier|*
name|prd
init|=
name|NULL
decl_stmt|;
name|ndis_miniport_block
modifier|*
name|block
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|brl
decl_stmt|;
name|struct
name|resource_list
name|brl_rev
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|brle
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|block
operator|=
operator|&
name|sc
operator|->
name|ndis_block
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|ndis_dev
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|brl_rev
argument_list|)
expr_stmt|;
name|rl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ndis_resource_list
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|cm_partial_resource_desc
argument_list|)
operator|*
operator|(
name|sc
operator|->
name|ndis_rescnt
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|rl
operator|->
name|cprl_version
operator|=
literal|5
expr_stmt|;
name|rl
operator|->
name|cprl_version
operator|=
literal|1
expr_stmt|;
name|rl
operator|->
name|cprl_count
operator|=
name|sc
operator|->
name|ndis_rescnt
expr_stmt|;
name|prd
operator|=
name|rl
operator|->
name|cprl_partial_descs
expr_stmt|;
name|brl
operator|=
name|BUS_GET_RESOURCE_LIST
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|brl
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We have a small problem. Some PCI devices have 		 * multiple I/O ranges. Windows orders them starting 		 * from lowest numbered BAR to highest. We discover 		 * them in that order too, but insert them into a singly 		 * linked list head first, which means when time comes 		 * to traverse the list, we enumerate them in reverse 		 * order. This screws up some drivers which expect the 		 * BARs to be in ascending order so that they can choose 		 * the "first" one as their register space. Unfortunately, 		 * in order to fix this, we have to create our own 		 * temporary list with the entries in reverse order. 		 */
name|SLIST_FOREACH
argument_list|(
argument|brle
argument_list|,
argument|brl
argument_list|,
argument|link
argument_list|)
block|{
name|n
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|resource_list_entry
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|brle
argument_list|,
operator|(
name|char
operator|*
operator|)
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|resource_list_entry
argument_list|)
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|brl_rev
argument_list|,
name|n
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|SLIST_FOREACH
argument_list|(
argument|brle
argument_list|,
argument|&brl_rev
argument_list|,
argument|link
argument_list|)
block|{
switch|switch
condition|(
name|brle
operator|->
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
name|prd
operator|->
name|cprd_type
operator|=
name|CmResourceTypePort
expr_stmt|;
name|prd
operator|->
name|cprd_flags
operator|=
name|CM_RESOURCE_PORT_IO
expr_stmt|;
name|prd
operator|->
name|cprd_sharedisp
operator|=
name|CmResourceShareDeviceExclusive
expr_stmt|;
name|prd
operator|->
name|u
operator|.
name|cprd_port
operator|.
name|cprd_start
operator|.
name|np_quad
operator|=
name|brle
operator|->
name|start
expr_stmt|;
name|prd
operator|->
name|u
operator|.
name|cprd_port
operator|.
name|cprd_len
operator|=
name|brle
operator|->
name|count
expr_stmt|;
break|break;
case|case
name|SYS_RES_MEMORY
case|:
name|prd
operator|->
name|cprd_type
operator|=
name|CmResourceTypeMemory
expr_stmt|;
name|prd
operator|->
name|cprd_flags
operator|=
name|CM_RESOURCE_MEMORY_READ_WRITE
expr_stmt|;
name|prd
operator|->
name|cprd_sharedisp
operator|=
name|CmResourceShareDeviceExclusive
expr_stmt|;
name|prd
operator|->
name|u
operator|.
name|cprd_port
operator|.
name|cprd_start
operator|.
name|np_quad
operator|=
name|brle
operator|->
name|start
expr_stmt|;
name|prd
operator|->
name|u
operator|.
name|cprd_port
operator|.
name|cprd_len
operator|=
name|brle
operator|->
name|count
expr_stmt|;
break|break;
case|case
name|SYS_RES_IRQ
case|:
name|prd
operator|->
name|cprd_type
operator|=
name|CmResourceTypeInterrupt
expr_stmt|;
name|prd
operator|->
name|cprd_flags
operator|=
literal|0
expr_stmt|;
name|prd
operator|->
name|cprd_sharedisp
operator|=
name|CmResourceShareDeviceExclusive
expr_stmt|;
name|prd
operator|->
name|u
operator|.
name|cprd_intr
operator|.
name|cprd_level
operator|=
name|brle
operator|->
name|start
expr_stmt|;
name|prd
operator|->
name|u
operator|.
name|cprd_intr
operator|.
name|cprd_vector
operator|=
name|brle
operator|->
name|start
expr_stmt|;
name|prd
operator|->
name|u
operator|.
name|cprd_intr
operator|.
name|cprd_affinity
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|prd
operator|++
expr_stmt|;
block|}
block|}
name|block
operator|->
name|nmb_rlist
operator|=
name|rl
expr_stmt|;
name|bad
label|:
while|while
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|brl_rev
argument_list|)
condition|)
block|{
name|n
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|brl_rev
argument_list|)
expr_stmt|;
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|brl_rev
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|n
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map an NDIS packet to an mbuf list. When an NDIS driver receives a  * packet, it will hand it to us in the form of an ndis_packet,  * which we need to convert to an mbuf that is then handed off  * to the stack. Note: we configure the mbuf list so that it uses  * the memory regions specified by the ndis_buffer structures in  * the ndis_packet as external storage. In most cases, this will  * point to a memory region allocated by the driver (either by  * ndis_malloc_withtag() or ndis_alloc_sharedmem()). We expect  * the driver to handle free()ing this region for is, so we set up  * a dummy no-op free handler for it.  */
end_comment

begin_function
name|int
name|ndis_ptom
parameter_list|(
name|m0
parameter_list|,
name|p
parameter_list|)
name|struct
name|mbuf
modifier|*
modifier|*
name|m0
decl_stmt|;
name|ndis_packet
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|ndis_buffer
modifier|*
name|buf
decl_stmt|;
name|ndis_packet_private
modifier|*
name|priv
decl_stmt|;
name|uint32_t
name|totlen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|m0
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|priv
operator|=
operator|&
name|p
operator|->
name|np_private
expr_stmt|;
name|buf
operator|=
name|priv
operator|->
name|npp_head
expr_stmt|;
name|p
operator|->
name|np_refcnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|buf
operator|=
name|priv
operator|->
name|npp_head
init|;
name|buf
operator|!=
name|NULL
condition|;
name|buf
operator|=
name|buf
operator|->
name|nb_next
control|)
block|{
if|if
condition|(
name|buf
operator|==
name|priv
operator|->
name|npp_head
condition|)
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
else|else
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m0
argument_list|)
expr_stmt|;
operator|*
name|m0
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|buf
operator|->
name|nb_bytecount
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|MDL_VA
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|MEXTADD
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|ndis_return_packet
argument_list|,
name|p
argument_list|,
literal|0
argument_list|,
name|EXT_NDIS
argument_list|)
expr_stmt|;
name|p
operator|->
name|np_refcnt
operator|++
expr_stmt|;
name|totlen
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|MT_HEADER
condition|)
operator|*
name|m0
operator|=
name|m
expr_stmt|;
else|else
name|prev
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|prev
operator|=
name|m
expr_stmt|;
block|}
operator|(
operator|*
name|m0
operator|)
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|totlen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create an mbuf chain from an NDIS packet chain.  * This is used mainly when transmitting packets, where we need  * to turn an mbuf off an interface's send queue and transform it  * into an NDIS packet which will be fed into the NDIS driver's  * send routine.  *  * NDIS packets consist of two parts: an ndis_packet structure,  * which is vaguely analagous to the pkthdr portion of an mbuf,  * and one or more ndis_buffer structures, which define the  * actual memory segments in which the packet data resides.  * We need to allocate one ndis_buffer for each mbuf in a chain,  * plus one ndis_packet as the header.  */
end_comment

begin_function
name|int
name|ndis_mtop
parameter_list|(
name|m0
parameter_list|,
name|p
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|ndis_packet
modifier|*
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|ndis_buffer
modifier|*
name|buf
init|=
name|NULL
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|ndis_packet_private
modifier|*
name|priv
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|m0
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* If caller didn't supply a packet, make one. */
if|if
condition|(
operator|*
name|p
operator|==
name|NULL
condition|)
block|{
operator|*
name|p
operator|=
name|uma_zalloc
argument_list|(
name|ndis_packet_zone
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|priv
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|np_private
expr_stmt|;
name|priv
operator|->
name|npp_totlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|priv
operator|->
name|npp_packetooboffset
operator|=
name|offsetof
argument_list|(
name|ndis_packet
argument_list|,
name|np_oob
argument_list|)
expr_stmt|;
name|priv
operator|->
name|npp_ndispktflags
operator|=
name|NDIS_PACKET_ALLOCATED_BY_NDIS
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|==
literal|0
condition|)
continue|continue;
name|buf
operator|=
name|uma_zalloc
argument_list|(
name|ndis_buffer_zone
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|ndis_free_packet
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|MDL_INIT
argument_list|(
name|buf
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|npp_head
operator|==
name|NULL
condition|)
name|priv
operator|->
name|npp_head
operator|=
name|buf
expr_stmt|;
else|else
name|prev
operator|->
name|nb_next
operator|=
name|buf
expr_stmt|;
name|prev
operator|=
name|buf
expr_stmt|;
block|}
name|priv
operator|->
name|npp_tail
operator|=
name|buf
expr_stmt|;
name|priv
operator|->
name|npp_totlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_get_supported_oids
parameter_list|(
name|arg
parameter_list|,
name|oids
parameter_list|,
name|oidcnt
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|ndis_oid
modifier|*
modifier|*
name|oids
decl_stmt|;
name|int
modifier|*
name|oidcnt
decl_stmt|;
block|{
name|int
name|len
decl_stmt|,
name|rval
decl_stmt|;
name|ndis_oid
modifier|*
name|o
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
operator|||
name|oids
operator|==
name|NULL
operator|||
name|oidcnt
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|len
operator|=
literal|0
expr_stmt|;
name|ndis_get_info
argument_list|(
name|arg
argument_list|,
name|OID_GEN_SUPPORTED_LIST
argument_list|,
name|NULL
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|o
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|rval
operator|=
name|ndis_get_info
argument_list|(
name|arg
argument_list|,
name|OID_GEN_SUPPORTED_LIST
argument_list|,
name|o
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
name|free
argument_list|(
name|o
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
operator|*
name|oids
operator|=
name|o
expr_stmt|;
operator|*
name|oidcnt
operator|=
name|len
operator|/
literal|4
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_set_info
parameter_list|(
name|arg
parameter_list|,
name|oid
parameter_list|,
name|buf
parameter_list|,
name|buflen
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|ndis_oid
name|oid
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|int
modifier|*
name|buflen
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_status
name|rval
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|__stdcall
name|ndis_setinfo_handler
name|setfunc
decl_stmt|;
name|uint32_t
name|byteswritten
init|=
literal|0
decl_stmt|,
name|bytesneeded
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|NDIS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|setfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_setinfo_func
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
expr_stmt|;
name|NDIS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
operator|||
name|setfunc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|irql
operator|=
name|FASTCALL1
argument_list|(
name|hal_raise_irql
argument_list|,
name|DISPATCH_LEVEL
argument_list|)
expr_stmt|;
name|rval
operator|=
name|setfunc
argument_list|(
name|adapter
argument_list|,
name|oid
argument_list|,
name|buf
argument_list|,
operator|*
name|buflen
argument_list|,
operator|&
name|byteswritten
argument_list|,
operator|&
name|bytesneeded
argument_list|)
expr_stmt|;
name|FASTCALL1
argument_list|(
name|hal_lower_irql
argument_list|,
name|irql
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_PENDING
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|curthread
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_wkupdpctimer
argument_list|,
operator|&
name|curthread
operator|->
name|td_proc
operator|->
name|p_mtx
argument_list|,
name|curthread
operator|->
name|td_priority
operator||
name|PDROP
argument_list|,
literal|"ndisset"
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
name|rval
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_setstat
expr_stmt|;
block|}
if|if
condition|(
name|byteswritten
condition|)
operator|*
name|buflen
operator|=
name|byteswritten
expr_stmt|;
if|if
condition|(
name|bytesneeded
condition|)
operator|*
name|buflen
operator|=
name|bytesneeded
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_INVALID_LENGTH
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_INVALID_OID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_NOT_SUPPORTED
operator|||
name|rval
operator|==
name|NDIS_STATUS_NOT_ACCEPTED
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
if|if
condition|(
name|rval
operator|!=
name|NDIS_STATUS_SUCCESS
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|ndis_senddone_func
function_decl|)
parameter_list|(
name|ndis_handle
parameter_list|,
name|ndis_packet
modifier|*
parameter_list|,
name|ndis_status
parameter_list|)
function_decl|;
end_typedef

begin_function
name|int
name|ndis_send_packets
parameter_list|(
name|arg
parameter_list|,
name|packets
parameter_list|,
name|cnt
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|ndis_packet
modifier|*
modifier|*
name|packets
decl_stmt|;
name|int
name|cnt
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|__stdcall
name|ndis_sendmulti_handler
name|sendfunc
decl_stmt|;
name|__stdcall
name|ndis_senddone_func
name|senddonefunc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ndis_packet
modifier|*
name|p
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sendfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_sendmulti_func
expr_stmt|;
name|senddonefunc
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_senddone_func
expr_stmt|;
name|irql
operator|=
name|FASTCALL1
argument_list|(
name|hal_raise_irql
argument_list|,
name|DISPATCH_LEVEL
argument_list|)
expr_stmt|;
name|sendfunc
argument_list|(
name|adapter
argument_list|,
name|packets
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|FASTCALL1
argument_list|(
name|hal_lower_irql
argument_list|,
name|irql
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|packets
index|[
name|i
index|]
expr_stmt|;
comment|/* 		 * Either the driver already handed the packet to 		 * ndis_txeof() due to a failure, or it wants to keep 		 * it and release it asynchronously later. Skip to the 		 * next one. 		 */
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|->
name|np_oob
operator|.
name|npo_status
operator|==
name|NDIS_STATUS_PENDING
condition|)
continue|continue;
name|senddonefunc
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|np_oob
operator|.
name|npo_status
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_send_packet
parameter_list|(
name|arg
parameter_list|,
name|packet
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|ndis_packet
modifier|*
name|packet
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|ndis_status
name|status
decl_stmt|;
name|__stdcall
name|ndis_sendsingle_handler
name|sendfunc
decl_stmt|;
name|__stdcall
name|ndis_senddone_func
name|senddonefunc
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sendfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_sendsingle_func
expr_stmt|;
name|senddonefunc
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_senddone_func
expr_stmt|;
name|irql
operator|=
name|FASTCALL1
argument_list|(
name|hal_raise_irql
argument_list|,
name|DISPATCH_LEVEL
argument_list|)
expr_stmt|;
name|status
operator|=
name|sendfunc
argument_list|(
name|adapter
argument_list|,
name|packet
argument_list|,
name|packet
operator|->
name|np_private
operator|.
name|npp_flags
argument_list|)
expr_stmt|;
name|FASTCALL1
argument_list|(
name|hal_lower_irql
argument_list|,
name|irql
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|NDIS_STATUS_PENDING
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|senddonefunc
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
argument_list|,
name|packet
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_init_dma
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|sc
operator|->
name|ndis_tmaps
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bus_dmamap_t
argument_list|)
operator|*
name|sc
operator|->
name|ndis_maxpkts
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ndis_tmaps
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|ndis_maxpkts
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|ndis_ttag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|ndis_tmaps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|ndis_tmaps
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_destroy_dma
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|ndis_packet
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|ndis_maxpkts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|ndis_txarray
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|sc
operator|->
name|ndis_txarray
index|[
name|i
index|]
expr_stmt|;
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|p
operator|->
name|np_rsvd
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ndis_free_packet
argument_list|(
name|sc
operator|->
name|ndis_txarray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|ndis_ttag
argument_list|,
name|sc
operator|->
name|ndis_tmaps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|ndis_tmaps
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|ndis_ttag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_reset_nic
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|__stdcall
name|ndis_reset_handler
name|resetfunc
decl_stmt|;
name|uint8_t
name|addressing_reset
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|NDIS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
expr_stmt|;
name|resetfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_reset_func
expr_stmt|;
name|NDIS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
operator|||
name|resetfunc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|irql
operator|=
name|FASTCALL1
argument_list|(
name|hal_raise_irql
argument_list|,
name|DISPATCH_LEVEL
argument_list|)
expr_stmt|;
name|rval
operator|=
name|resetfunc
argument_list|(
operator|&
name|addressing_reset
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|FASTCALL1
argument_list|(
name|hal_lower_irql
argument_list|,
name|irql
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_PENDING
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|curthread
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
name|sc
argument_list|,
operator|&
name|curthread
operator|->
name|td_proc
operator|->
name|p_mtx
argument_list|,
name|curthread
operator|->
name|td_priority
operator||
name|PDROP
argument_list|,
literal|"ndisrst"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_halt_nic
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|__stdcall
name|ndis_halt_handler
name|haltfunc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|NDIS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
condition|)
block|{
name|NDIS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 	 * The adapter context is only valid after the init 	 * handler has been called, and is invalid once the 	 * halt handler has been called. 	 */
name|haltfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_halt_func
expr_stmt|;
name|NDIS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|haltfunc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
name|NDIS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
operator|=
name|NULL
expr_stmt|;
name|NDIS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_shutdown_nic
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|__stdcall
name|ndis_shutdown_handler
name|shutdownfunc
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|NDIS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
expr_stmt|;
name|shutdownfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_shutdown_handler
expr_stmt|;
name|NDIS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
operator|||
name|shutdownfunc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_rsvd0
operator|==
name|NULL
condition|)
name|shutdownfunc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
else|else
name|shutdownfunc
argument_list|(
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_rsvd0
argument_list|)
expr_stmt|;
name|ndis_shrink_thrqueue
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ndis_devhead
argument_list|,
operator|&
name|sc
operator|->
name|ndis_block
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_init_nic
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_miniport_block
modifier|*
name|block
decl_stmt|;
name|__stdcall
name|ndis_init_handler
name|initfunc
decl_stmt|;
name|ndis_status
name|status
decl_stmt|,
name|openstatus
init|=
literal|0
decl_stmt|;
name|ndis_medium
name|mediumarray
index|[
name|NdisMediumMax
index|]
decl_stmt|;
name|uint32_t
name|chosenmedium
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|=
name|arg
expr_stmt|;
name|NDIS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|block
operator|=
operator|&
name|sc
operator|->
name|ndis_block
expr_stmt|;
name|initfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_init_func
expr_stmt|;
name|NDIS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|block
operator|->
name|nmb_timerlist
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NdisMediumMax
condition|;
name|i
operator|++
control|)
name|mediumarray
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|status
operator|=
name|initfunc
argument_list|(
operator|&
name|openstatus
argument_list|,
operator|&
name|chosenmedium
argument_list|,
name|mediumarray
argument_list|,
name|NdisMediumMax
argument_list|,
name|block
argument_list|,
name|block
argument_list|)
expr_stmt|;
comment|/* 	 * If the init fails, blow away the other exported routines 	 * we obtained from the driver so we can't call them later. 	 * If the init failed, none of these will work. 	 */
if|if
condition|(
name|status
operator|!=
name|NDIS_STATUS_SUCCESS
condition|)
block|{
name|NDIS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
operator|=
name|NULL
expr_stmt|;
name|NDIS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ndis_enable_intr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|__stdcall
name|ndis_enable_interrupts_handler
name|intrenbfunc
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
expr_stmt|;
name|intrenbfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_enable_interrupts_func
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
operator|||
name|intrenbfunc
operator|==
name|NULL
condition|)
return|return;
name|intrenbfunc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|ndis_disable_intr
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|__stdcall
name|ndis_disable_interrupts_handler
name|intrdisfunc
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|NDIS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
expr_stmt|;
name|intrdisfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_disable_interrupts_func
expr_stmt|;
name|NDIS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
operator|||
name|intrdisfunc
operator|==
name|NULL
condition|)
return|return;
name|intrdisfunc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|ndis_isr
parameter_list|(
name|arg
parameter_list|,
name|ourintr
parameter_list|,
name|callhandler
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|int
modifier|*
name|ourintr
decl_stmt|;
name|int
modifier|*
name|callhandler
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|__stdcall
name|ndis_isr_handler
name|isrfunc
decl_stmt|;
name|uint8_t
name|accepted
decl_stmt|,
name|queue
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
operator|||
name|ourintr
operator|==
name|NULL
operator|||
name|callhandler
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|=
name|arg
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
expr_stmt|;
name|isrfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_isr_func
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
operator|||
name|isrfunc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|isrfunc
argument_list|(
operator|&
name|accepted
argument_list|,
operator|&
name|queue
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
operator|*
name|ourintr
operator|=
name|accepted
expr_stmt|;
operator|*
name|callhandler
operator|=
name|queue
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_intrhand
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|__stdcall
name|ndis_interrupt_handler
name|intrfunc
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|=
name|arg
expr_stmt|;
name|NDIS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
expr_stmt|;
name|intrfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_interrupt_func
expr_stmt|;
name|NDIS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
operator|||
name|intrfunc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|intrfunc
argument_list|(
name|adapter
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_get_info
parameter_list|(
name|arg
parameter_list|,
name|oid
parameter_list|,
name|buf
parameter_list|,
name|buflen
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|ndis_oid
name|oid
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|int
modifier|*
name|buflen
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_status
name|rval
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|__stdcall
name|ndis_queryinfo_handler
name|queryfunc
decl_stmt|;
name|uint32_t
name|byteswritten
init|=
literal|0
decl_stmt|,
name|bytesneeded
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|NDIS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|queryfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|.
name|nmc_queryinfo_func
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_miniportadapterctx
expr_stmt|;
name|NDIS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
operator|||
name|queryfunc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|irql
operator|=
name|FASTCALL1
argument_list|(
name|hal_raise_irql
argument_list|,
name|DISPATCH_LEVEL
argument_list|)
expr_stmt|;
name|rval
operator|=
name|queryfunc
argument_list|(
name|adapter
argument_list|,
name|oid
argument_list|,
name|buf
argument_list|,
operator|*
name|buflen
argument_list|,
operator|&
name|byteswritten
argument_list|,
operator|&
name|bytesneeded
argument_list|)
expr_stmt|;
name|FASTCALL1
argument_list|(
name|hal_lower_irql
argument_list|,
name|irql
argument_list|)
expr_stmt|;
comment|/* Wait for requests that block. */
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_PENDING
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|curthread
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|error
operator|=
name|msleep
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_wkupdpctimer
argument_list|,
operator|&
name|curthread
operator|->
name|td_proc
operator|->
name|p_mtx
argument_list|,
name|curthread
operator|->
name|td_priority
operator||
name|PDROP
argument_list|,
literal|"ndisget"
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
name|rval
operator|=
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_getstat
expr_stmt|;
block|}
if|if
condition|(
name|byteswritten
condition|)
operator|*
name|buflen
operator|=
name|byteswritten
expr_stmt|;
if|if
condition|(
name|bytesneeded
condition|)
operator|*
name|buflen
operator|=
name|bytesneeded
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_INVALID_LENGTH
operator|||
name|rval
operator|==
name|NDIS_STATUS_BUFFER_TOO_SHORT
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_INVALID_OID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_NOT_SUPPORTED
operator|||
name|rval
operator|==
name|NDIS_STATUS_NOT_ACCEPTED
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
if|if
condition|(
name|rval
operator|!=
name|NDIS_STATUS_SUCCESS
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_unload_driver
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|ndis_block
operator|.
name|nmb_rlist
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ndis_flush_sysctls
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ndis_shrink_thrqueue
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ndis_devhead
argument_list|,
operator|&
name|sc
operator|->
name|ndis_block
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NDIS_LOADED
value|htonl(0x42534F44)
end_define

begin_function
name|int
name|ndis_load_driver
parameter_list|(
name|img
parameter_list|,
name|arg
parameter_list|)
name|vm_offset_t
name|img
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|__stdcall
name|driver_entry
name|entry
decl_stmt|;
name|image_optional_header
name|opt_hdr
decl_stmt|;
name|image_import_descriptor
name|imp_desc
decl_stmt|;
name|ndis_unicode_string
name|dummystr
decl_stmt|;
name|ndis_miniport_block
modifier|*
name|block
decl_stmt|;
name|ndis_status
name|status
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|uint32_t
modifier|*
name|ptr
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
comment|/* 	 * Only perform the relocation/linking phase once 	 * since the binary image may be shared among multiple 	 * device instances. 	 */
name|ptr
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|img
operator|+
literal|8
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|ptr
operator|!=
name|NDIS_LOADED
condition|)
block|{
comment|/* Perform text relocation */
if|if
condition|(
name|pe_relocate
argument_list|(
name|img
argument_list|)
condition|)
return|return
operator|(
name|ENOEXEC
operator|)
return|;
comment|/* Dynamically link the NDIS.SYS routines -- required. */
if|if
condition|(
name|pe_patch_imports
argument_list|(
name|img
argument_list|,
literal|"NDIS"
argument_list|,
name|ndis_functbl
argument_list|)
condition|)
return|return
operator|(
name|ENOEXEC
operator|)
return|;
comment|/* Dynamically link the HAL.dll routines -- also required. */
if|if
condition|(
name|pe_patch_imports
argument_list|(
name|img
argument_list|,
literal|"HAL"
argument_list|,
name|hal_functbl
argument_list|)
condition|)
return|return
operator|(
name|ENOEXEC
operator|)
return|;
comment|/* Dynamically link ntoskrnl.exe -- optional. */
if|if
condition|(
name|pe_get_import_descriptor
argument_list|(
name|img
argument_list|,
operator|&
name|imp_desc
argument_list|,
literal|"ntoskrnl"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pe_patch_imports
argument_list|(
name|img
argument_list|,
literal|"ntoskrnl"
argument_list|,
name|ntoskrnl_functbl
argument_list|)
condition|)
return|return
operator|(
name|ENOEXEC
operator|)
return|;
block|}
operator|*
name|ptr
operator|=
name|NDIS_LOADED
expr_stmt|;
block|}
comment|/* Locate the driver entry point */
name|pe_get_optional_header
argument_list|(
name|img
argument_list|,
operator|&
name|opt_hdr
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|(
name|driver_entry
operator|)
name|pe_translate_addr
argument_list|(
name|img
argument_list|,
name|opt_hdr
operator|.
name|ioh_entryaddr
argument_list|)
expr_stmt|;
name|dummystr
operator|.
name|nus_len
operator|=
name|strlen
argument_list|(
name|NDIS_DUMMY_PATH
argument_list|)
operator|*
literal|2
expr_stmt|;
name|dummystr
operator|.
name|nus_maxlen
operator|=
name|strlen
argument_list|(
name|NDIS_DUMMY_PATH
argument_list|)
operator|*
literal|2
expr_stmt|;
name|dummystr
operator|.
name|nus_buf
operator|=
name|NULL
expr_stmt|;
name|ndis_ascii_to_unicode
argument_list|(
name|NDIS_DUMMY_PATH
argument_list|,
operator|&
name|dummystr
operator|.
name|nus_buf
argument_list|)
expr_stmt|;
comment|/* 	 * Now that we have the miniport driver characteristics, 	 * create an NDIS block and call the init handler. 	 * This will cause the driver to try to probe for 	 * a device. 	 */
name|block
operator|=
operator|&
name|sc
operator|->
name|ndis_block
expr_stmt|;
name|ptr
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|block
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
sizeof|sizeof
argument_list|(
name|ndis_miniport_block
argument_list|)
operator|/
literal|4
condition|;
name|idx
operator|++
control|)
block|{
operator|*
name|ptr
operator|=
name|idx
operator||
literal|0xdead0000
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
block|}
name|block
operator|->
name|nmb_signature
operator|=
operator|(
name|void
operator|*
operator|)
literal|0xcafebabe
expr_stmt|;
name|block
operator|->
name|nmb_setdone_func
operator|=
name|ndis_setdone_func
expr_stmt|;
name|block
operator|->
name|nmb_querydone_func
operator|=
name|ndis_getdone_func
expr_stmt|;
name|block
operator|->
name|nmb_status_func
operator|=
name|ndis_status_func
expr_stmt|;
name|block
operator|->
name|nmb_statusdone_func
operator|=
name|ndis_statusdone_func
expr_stmt|;
name|block
operator|->
name|nmb_resetdone_func
operator|=
name|ndis_resetdone_func
expr_stmt|;
name|block
operator|->
name|nmb_sendrsrc_func
operator|=
name|ndis_sendrsrcavail_func
expr_stmt|;
name|block
operator|->
name|nmb_ifp
operator|=
operator|&
name|sc
operator|->
name|arpcom
operator|.
name|ac_if
expr_stmt|;
name|block
operator|->
name|nmb_dev
operator|=
name|sc
operator|->
name|ndis_dev
expr_stmt|;
name|block
operator|->
name|nmb_img
operator|=
name|img
expr_stmt|;
name|block
operator|->
name|nmb_devobj
operator|.
name|do_rsvd
operator|=
name|block
expr_stmt|;
comment|/* 	 * Now call the DriverEntry() routine. This will cause 	 * a callout to the NdisInitializeWrapper() and 	 * NdisMRegisterMiniport() routines. 	 */
name|status
operator|=
name|entry
argument_list|(
operator|&
name|block
operator|->
name|nmb_devobj
argument_list|,
operator|&
name|dummystr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dummystr
operator|.
name|nus_buf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|NDIS_STATUS_SUCCESS
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|ndis_enlarge_thrqueue
argument_list|(
literal|8
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ndis_devhead
argument_list|,
name|block
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

