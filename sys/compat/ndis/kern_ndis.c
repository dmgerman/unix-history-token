begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003  *	Bill Paul<wpaul@windriver.com>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Bill Paul.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/pe_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/cfg_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/resource_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/ntoskrnl_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/ndis_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/hal_var.h>
end_include

begin_include
include|#
directive|include
file|<compat/ndis/usbd_var.h>
end_include

begin_include
include|#
directive|include
file|<dev/if_ndis/if_ndisvar.h>
end_include

begin_define
define|#
directive|define
name|NDIS_DUMMY_PATH
value|"\\\\some\\bogus\\path"
end_define

begin_define
define|#
directive|define
name|NDIS_FLAG_RDONLY
value|1
end_define

begin_function_decl
specifier|static
name|void
name|ndis_status_func
parameter_list|(
name|ndis_handle
parameter_list|,
name|ndis_status
parameter_list|,
name|void
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ndis_statusdone_func
parameter_list|(
name|ndis_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ndis_setdone_func
parameter_list|(
name|ndis_handle
parameter_list|,
name|ndis_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ndis_getdone_func
parameter_list|(
name|ndis_handle
parameter_list|,
name|ndis_status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ndis_resetdone_func
parameter_list|(
name|ndis_handle
parameter_list|,
name|ndis_status
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ndis_sendrsrcavail_func
parameter_list|(
name|ndis_handle
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ndis_intrsetup
parameter_list|(
name|kdpc
modifier|*
parameter_list|,
name|device_object
modifier|*
parameter_list|,
name|irp
modifier|*
parameter_list|,
name|struct
name|ndis_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ndis_return
parameter_list|(
name|device_object
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|image_patch_table
name|kernndis_functbl
index|[]
init|=
block|{
name|IMPORT_SFUNC
argument_list|(
name|ndis_status_func
argument_list|,
literal|4
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ndis_statusdone_func
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ndis_setdone_func
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ndis_getdone_func
argument_list|,
literal|2
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ndis_resetdone_func
argument_list|,
literal|3
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ndis_sendrsrcavail_func
argument_list|,
literal|1
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ndis_intrsetup
argument_list|,
literal|4
argument_list|)
block|,
name|IMPORT_SFUNC
argument_list|(
name|ndis_return
argument_list|,
literal|1
argument_list|)
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|nd_head
name|ndis_devhead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This allows us to export our symbols to other modules.  * Note that we call ourselves 'ndisapi' to avoid a namespace  * collision with if_ndis.ko, which internally calls itself  * 'ndis.'  *  * Note: some of the subsystems depend on each other, so the  * order in which they're started is important. The order of  * importance is:  *  * HAL - spinlocks and IRQL manipulation  * ntoskrnl - DPC and workitem threads, object waiting  * windrv - driver/device registration  *  * The HAL should also be the last thing shut down, since  * the ntoskrnl subsystem will use spinlocks right up until  * the DPC and workitem threads are terminated.  */
end_comment

begin_function
specifier|static
name|int
name|ndis_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|image_patch_table
modifier|*
name|patch
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
comment|/* Initialize subsystems */
name|hal_libinit
argument_list|()
expr_stmt|;
name|ntoskrnl_libinit
argument_list|()
expr_stmt|;
name|windrv_libinit
argument_list|()
expr_stmt|;
name|ndis_libinit
argument_list|()
expr_stmt|;
name|usbd_libinit
argument_list|()
expr_stmt|;
name|patch
operator|=
name|kernndis_functbl
expr_stmt|;
while|while
condition|(
name|patch
operator|->
name|ipt_func
operator|!=
name|NULL
condition|)
block|{
name|windrv_wrap
argument_list|(
operator|(
name|funcptr
operator|)
name|patch
operator|->
name|ipt_func
argument_list|,
operator|(
name|funcptr
operator|*
operator|)
operator|&
name|patch
operator|->
name|ipt_wrap
argument_list|,
name|patch
operator|->
name|ipt_argcnt
argument_list|,
name|patch
operator|->
name|ipt_ftype
argument_list|)
expr_stmt|;
name|patch
operator|++
expr_stmt|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|ndis_devhead
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_SHUTDOWN
case|:
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|ndis_devhead
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* Shut down subsystems */
name|ndis_libfini
argument_list|()
expr_stmt|;
name|usbd_libfini
argument_list|()
expr_stmt|;
name|windrv_libfini
argument_list|()
expr_stmt|;
name|ntoskrnl_libfini
argument_list|()
expr_stmt|;
name|hal_libfini
argument_list|()
expr_stmt|;
name|patch
operator|=
name|kernndis_functbl
expr_stmt|;
while|while
condition|(
name|patch
operator|->
name|ipt_func
operator|!=
name|NULL
condition|)
block|{
name|windrv_unwrap
argument_list|(
name|patch
operator|->
name|ipt_wrap
argument_list|)
expr_stmt|;
name|patch
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
name|MOD_UNLOAD
case|:
comment|/* Shut down subsystems */
name|ndis_libfini
argument_list|()
expr_stmt|;
name|usbd_libfini
argument_list|()
expr_stmt|;
name|windrv_libfini
argument_list|()
expr_stmt|;
name|ntoskrnl_libfini
argument_list|()
expr_stmt|;
name|hal_libfini
argument_list|()
expr_stmt|;
name|patch
operator|=
name|kernndis_functbl
expr_stmt|;
while|while
condition|(
name|patch
operator|->
name|ipt_func
operator|!=
name|NULL
condition|)
block|{
name|windrv_unwrap
argument_list|(
name|patch
operator|->
name|ipt_wrap
argument_list|)
expr_stmt|;
name|patch
operator|++
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|DEV_MODULE
argument_list|(
name|ndisapi
argument_list|,
name|ndis_modevent
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ndisapi
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|ndis_sendrsrcavail_func
parameter_list|(
name|adapter
parameter_list|)
name|ndis_handle
name|adapter
decl_stmt|;
block|{ }
end_function

begin_function
specifier|static
name|void
name|ndis_status_func
parameter_list|(
name|adapter
parameter_list|,
name|status
parameter_list|,
name|sbuf
parameter_list|,
name|slen
parameter_list|)
name|ndis_handle
name|adapter
decl_stmt|;
name|ndis_status
name|status
decl_stmt|;
name|void
modifier|*
name|sbuf
decl_stmt|;
name|uint32_t
name|slen
decl_stmt|;
block|{
name|ndis_miniport_block
modifier|*
name|block
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|block
operator|=
name|adapter
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|block
operator|->
name|nmb_physdeviceobj
operator|->
name|do_devext
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|NDISUSB_GET_IFNET
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|ndis_dev
argument_list|,
literal|"status: %x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ndis_statusdone_func
parameter_list|(
name|adapter
parameter_list|)
name|ndis_handle
name|adapter
decl_stmt|;
block|{
name|ndis_miniport_block
modifier|*
name|block
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|block
operator|=
name|adapter
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|block
operator|->
name|nmb_physdeviceobj
operator|->
name|do_devext
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|NDISUSB_GET_IFNET
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|ndis_dev
argument_list|,
literal|"status complete\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ndis_setdone_func
parameter_list|(
name|adapter
parameter_list|,
name|status
parameter_list|)
name|ndis_handle
name|adapter
decl_stmt|;
name|ndis_status
name|status
decl_stmt|;
block|{
name|ndis_miniport_block
modifier|*
name|block
decl_stmt|;
name|block
operator|=
name|adapter
expr_stmt|;
name|block
operator|->
name|nmb_setstat
operator|=
name|status
expr_stmt|;
name|KeSetEvent
argument_list|(
operator|&
name|block
operator|->
name|nmb_setevent
argument_list|,
name|IO_NO_INCREMENT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ndis_getdone_func
parameter_list|(
name|adapter
parameter_list|,
name|status
parameter_list|)
name|ndis_handle
name|adapter
decl_stmt|;
name|ndis_status
name|status
decl_stmt|;
block|{
name|ndis_miniport_block
modifier|*
name|block
decl_stmt|;
name|block
operator|=
name|adapter
expr_stmt|;
name|block
operator|->
name|nmb_getstat
operator|=
name|status
expr_stmt|;
name|KeSetEvent
argument_list|(
operator|&
name|block
operator|->
name|nmb_getevent
argument_list|,
name|IO_NO_INCREMENT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ndis_resetdone_func
parameter_list|(
name|ndis_handle
name|adapter
parameter_list|,
name|ndis_status
name|status
parameter_list|,
name|uint8_t
name|addressingreset
parameter_list|)
block|{
name|ndis_miniport_block
modifier|*
name|block
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|block
operator|=
name|adapter
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|block
operator|->
name|nmb_physdeviceobj
operator|->
name|do_devext
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|NDISUSB_GET_IFNET
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|device_printf
argument_list|(
name|sc
operator|->
name|ndis_dev
argument_list|,
literal|"reset done...\n"
argument_list|)
expr_stmt|;
name|KeSetEvent
argument_list|(
operator|&
name|block
operator|->
name|nmb_resetevent
argument_list|,
name|IO_NO_INCREMENT
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ndis_create_sysctls
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_cfg
modifier|*
name|vals
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|oidp
decl_stmt|;
name|struct
name|sysctl_ctx_entry
modifier|*
name|e
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|=
name|arg
expr_stmt|;
comment|/* 	device_printf(sc->ndis_dev, "ndis_create_sysctls() sc=%p\n", sc); 	*/
name|vals
operator|=
name|sc
operator|->
name|ndis_regvals
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|ndis_cfglist_head
argument_list|)
expr_stmt|;
comment|/* Add the driver-specific registry keys. */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|vals
operator|->
name|nc_cfgkey
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|vals
operator|->
name|nc_idx
operator|!=
name|sc
operator|->
name|ndis_devidx
condition|)
block|{
name|vals
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* See if we already have a sysctl with this name */
name|oidp
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|e
argument_list|,
argument|device_get_sysctl_ctx(sc->ndis_dev)
argument_list|,
argument|link
argument_list|)
block|{
name|oidp
operator|=
name|e
operator|->
name|entry
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|oidp
operator|->
name|oid_name
argument_list|,
name|vals
operator|->
name|nc_cfgkey
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|oidp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|oidp
operator|!=
name|NULL
condition|)
block|{
name|vals
operator|++
expr_stmt|;
continue|continue;
block|}
name|ndis_add_sysctl
argument_list|(
name|sc
argument_list|,
name|vals
operator|->
name|nc_cfgkey
argument_list|,
name|vals
operator|->
name|nc_cfgdesc
argument_list|,
name|vals
operator|->
name|nc_val
argument_list|,
name|CTLFLAG_RW
argument_list|)
expr_stmt|;
name|vals
operator|++
expr_stmt|;
block|}
comment|/* Now add a couple of builtin keys. */
comment|/* 	 * Environment can be either Windows (0) or WindowsNT (1). 	 * We qualify as the latter. 	 */
name|ndis_add_sysctl
argument_list|(
name|sc
argument_list|,
literal|"Environment"
argument_list|,
literal|"Windows environment"
argument_list|,
literal|"1"
argument_list|,
name|NDIS_FLAG_RDONLY
argument_list|)
expr_stmt|;
comment|/* NDIS version should be 5.1. */
name|ndis_add_sysctl
argument_list|(
name|sc
argument_list|,
literal|"NdisVersion"
argument_list|,
literal|"NDIS API Version"
argument_list|,
literal|"0x00050001"
argument_list|,
name|NDIS_FLAG_RDONLY
argument_list|)
expr_stmt|;
comment|/* 	 * Some miniport drivers rely on the existence of the SlotNumber, 	 * NetCfgInstanceId and DriverDesc keys. 	 */
name|ndis_add_sysctl
argument_list|(
name|sc
argument_list|,
literal|"SlotNumber"
argument_list|,
literal|"Slot Numer"
argument_list|,
literal|"01"
argument_list|,
name|NDIS_FLAG_RDONLY
argument_list|)
expr_stmt|;
name|ndis_add_sysctl
argument_list|(
name|sc
argument_list|,
literal|"NetCfgInstanceId"
argument_list|,
literal|"NetCfgInstanceId"
argument_list|,
literal|"{12345678-1234-5678-CAFE0-123456789ABC}"
argument_list|,
name|NDIS_FLAG_RDONLY
argument_list|)
expr_stmt|;
name|ndis_add_sysctl
argument_list|(
name|sc
argument_list|,
literal|"DriverDesc"
argument_list|,
literal|"Driver Description"
argument_list|,
literal|"NDIS Network Adapter"
argument_list|,
name|NDIS_FLAG_RDONLY
argument_list|)
expr_stmt|;
comment|/* Bus type (PCI, PCMCIA, etc...) */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|sc
operator|->
name|ndis_iftype
argument_list|)
expr_stmt|;
name|ndis_add_sysctl
argument_list|(
name|sc
argument_list|,
literal|"BusType"
argument_list|,
literal|"Bus Type"
argument_list|,
name|buf
argument_list|,
name|NDIS_FLAG_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ndis_res_io
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x%jx"
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|ndis_res_io
argument_list|)
argument_list|)
expr_stmt|;
name|ndis_add_sysctl
argument_list|(
name|sc
argument_list|,
literal|"IOBaseAddress"
argument_list|,
literal|"Base I/O Address"
argument_list|,
name|buf
argument_list|,
name|NDIS_FLAG_RDONLY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|ndis_irq
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ju"
argument_list|,
name|rman_get_start
argument_list|(
name|sc
operator|->
name|ndis_irq
argument_list|)
argument_list|)
expr_stmt|;
name|ndis_add_sysctl
argument_list|(
name|sc
argument_list|,
literal|"InterruptNumber"
argument_list|,
literal|"Interrupt Number"
argument_list|,
name|buf
argument_list|,
name|NDIS_FLAG_RDONLY
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_add_sysctl
parameter_list|(
name|arg
parameter_list|,
name|key
parameter_list|,
name|desc
parameter_list|,
name|val
parameter_list|,
name|flag_rdonly
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|flag_rdonly
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ndis_cfglist
modifier|*
name|cfg
decl_stmt|;
name|char
name|descstr
index|[
literal|256
index|]
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|cfg
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ndis_cfglist
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"failed for %s\n"
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_cfgkey
operator|=
name|strdup
argument_list|(
name|key
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|descstr
argument_list|,
sizeof|sizeof
argument_list|(
name|descstr
argument_list|)
argument_list|,
literal|"%s (dynamic)"
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_cfgdesc
operator|=
name|strdup
argument_list|(
name|descstr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
else|else
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_cfgdesc
operator|=
name|strdup
argument_list|(
name|desc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_val
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|ndis_cfglist_head
argument_list|,
name|cfg
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_rdonly
operator|!=
literal|0
condition|)
block|{
name|cfg
operator|->
name|ndis_oid
operator|=
name|SYSCTL_ADD_STRING
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|ndis_dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|ndis_dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_cfgkey
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_val
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_val
argument_list|)
argument_list|,
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_cfgdesc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cfg
operator|->
name|ndis_oid
operator|=
name|SYSCTL_ADD_STRING
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|ndis_dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|sc
operator|->
name|ndis_dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_cfgkey
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_val
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_val
argument_list|)
argument_list|,
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_cfgdesc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Somewhere, somebody decided "hey, let's automatically create  * a sysctl tree for each device instance as it's created -- it'll  * make life so much easier!" Lies. Why must they turn the kernel  * into a house of lies?  */
end_comment

begin_function
name|int
name|ndis_flush_sysctls
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ndis_cfglist
modifier|*
name|cfg
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|clist
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|clist
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|sc
operator|->
name|ndis_dev
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|ndis_cfglist_head
argument_list|)
condition|)
block|{
name|cfg
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|ndis_cfglist_head
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|ndis_cfglist_head
argument_list|,
name|cfg
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|sysctl_ctx_entry_del
argument_list|(
name|clist
argument_list|,
name|cfg
operator|->
name|ndis_oid
argument_list|)
expr_stmt|;
name|sysctl_remove_oid
argument_list|(
name|cfg
operator|->
name|ndis_oid
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_cfgkey
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cfg
operator|->
name|ndis_cfg
operator|.
name|nc_cfgdesc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cfg
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|ndis_get_routine_address
parameter_list|(
name|functbl
parameter_list|,
name|name
parameter_list|)
name|struct
name|image_patch_table
modifier|*
name|functbl
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|functbl
index|[
name|i
index|]
operator|.
name|ipt_name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|functbl
index|[
name|i
index|]
operator|.
name|ipt_name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|functbl
index|[
name|i
index|]
operator|.
name|ipt_wrap
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ndis_return
parameter_list|(
name|dobj
parameter_list|,
name|arg
parameter_list|)
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|ndis_miniport_block
modifier|*
name|block
decl_stmt|;
name|ndis_miniport_characteristics
modifier|*
name|ch
decl_stmt|;
name|ndis_return_handler
name|returnfunc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|ndis_packet
modifier|*
name|p
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
name|list_entry
modifier|*
name|l
decl_stmt|;
name|block
operator|=
name|arg
expr_stmt|;
name|ch
operator|=
name|IoGetDriverObjectExtension
argument_list|(
name|dobj
operator|->
name|do_drvobj
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|arg
expr_stmt|;
name|adapter
operator|=
name|block
operator|->
name|nmb_miniportadapterctx
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
condition|)
return|return;
name|returnfunc
operator|=
name|ch
operator|->
name|nmc_return_packet_func
expr_stmt|;
name|KeAcquireSpinLock
argument_list|(
operator|&
name|block
operator|->
name|nmb_returnlock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|IsListEmpty
argument_list|(
operator|&
name|block
operator|->
name|nmb_returnlist
argument_list|)
condition|)
block|{
name|l
operator|=
name|RemoveHeadList
argument_list|(
operator|(
operator|&
name|block
operator|->
name|nmb_returnlist
operator|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|CONTAINING_RECORD
argument_list|(
name|l
argument_list|,
name|ndis_packet
argument_list|,
name|np_list
argument_list|)
expr_stmt|;
name|InitializeListHead
argument_list|(
operator|(
operator|&
name|p
operator|->
name|np_list
operator|)
argument_list|)
expr_stmt|;
name|KeReleaseSpinLock
argument_list|(
operator|&
name|block
operator|->
name|nmb_returnlock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
name|MSCALL2
argument_list|(
name|returnfunc
argument_list|,
name|adapter
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|KeAcquireSpinLock
argument_list|(
operator|&
name|block
operator|->
name|nmb_returnlock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
block|}
name|KeReleaseSpinLock
argument_list|(
operator|&
name|block
operator|->
name|nmb_returnlock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ndis_ext_free
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
operator|(
name|ndis_return_packet
argument_list|(
name|m
operator|->
name|m_ext
operator|.
name|ext_arg1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ndis_return_packet
parameter_list|(
name|ndis_packet
modifier|*
name|p
parameter_list|)
block|{
name|ndis_miniport_block
modifier|*
name|block
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
comment|/* Decrement refcount. */
name|p
operator|->
name|np_refcnt
operator|--
expr_stmt|;
comment|/* Release packet when refcount hits zero, otherwise return. */
if|if
condition|(
name|p
operator|->
name|np_refcnt
condition|)
return|return;
name|block
operator|=
operator|(
operator|(
expr|struct
name|ndis_softc
operator|*
operator|)
name|p
operator|->
name|np_softc
operator|)
operator|->
name|ndis_block
expr_stmt|;
name|KeAcquireSpinLockAtDpcLevel
argument_list|(
operator|&
name|block
operator|->
name|nmb_returnlock
argument_list|)
expr_stmt|;
name|InitializeListHead
argument_list|(
operator|(
operator|&
name|p
operator|->
name|np_list
operator|)
argument_list|)
expr_stmt|;
name|InsertHeadList
argument_list|(
operator|(
operator|&
name|block
operator|->
name|nmb_returnlist
operator|)
argument_list|,
operator|(
operator|&
name|p
operator|->
name|np_list
operator|)
argument_list|)
expr_stmt|;
name|KeReleaseSpinLockFromDpcLevel
argument_list|(
operator|&
name|block
operator|->
name|nmb_returnlock
argument_list|)
expr_stmt|;
name|IoQueueWorkItem
argument_list|(
name|block
operator|->
name|nmb_returnitem
argument_list|,
operator|(
name|io_workitem_func
operator|)
name|kernndis_functbl
index|[
literal|7
index|]
operator|.
name|ipt_wrap
argument_list|,
name|WORKQUEUE_CRITICAL
argument_list|,
name|block
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ndis_free_bufs
parameter_list|(
name|b0
parameter_list|)
name|ndis_buffer
modifier|*
name|b0
decl_stmt|;
block|{
name|ndis_buffer
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|b0
operator|==
name|NULL
condition|)
return|return;
while|while
condition|(
name|b0
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|b0
operator|->
name|mdl_next
expr_stmt|;
name|IoFreeMdl
argument_list|(
name|b0
argument_list|)
expr_stmt|;
name|b0
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ndis_free_packet
parameter_list|(
name|p
parameter_list|)
name|ndis_packet
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
name|ndis_free_bufs
argument_list|(
name|p
operator|->
name|np_private
operator|.
name|npp_head
argument_list|)
expr_stmt|;
name|NdisFreePacket
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ndis_convert_res
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_resource_list
modifier|*
name|rl
init|=
name|NULL
decl_stmt|;
name|cm_partial_resource_desc
modifier|*
name|prd
init|=
name|NULL
decl_stmt|;
name|ndis_miniport_block
modifier|*
name|block
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|brl
decl_stmt|;
name|struct
name|resource_list_entry
modifier|*
name|brle
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|block
operator|=
name|sc
operator|->
name|ndis_block
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|ndis_dev
expr_stmt|;
name|rl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ndis_resource_list
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|cm_partial_resource_desc
argument_list|)
operator|*
operator|(
name|sc
operator|->
name|ndis_rescnt
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|rl
operator|->
name|cprl_version
operator|=
literal|5
expr_stmt|;
name|rl
operator|->
name|cprl_revision
operator|=
literal|1
expr_stmt|;
name|rl
operator|->
name|cprl_count
operator|=
name|sc
operator|->
name|ndis_rescnt
expr_stmt|;
name|prd
operator|=
name|rl
operator|->
name|cprl_partial_descs
expr_stmt|;
name|brl
operator|=
name|BUS_GET_RESOURCE_LIST
argument_list|(
name|dev
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|brl
operator|!=
name|NULL
condition|)
block|{
name|STAILQ_FOREACH
argument_list|(
argument|brle
argument_list|,
argument|brl
argument_list|,
argument|link
argument_list|)
block|{
switch|switch
condition|(
name|brle
operator|->
name|type
condition|)
block|{
case|case
name|SYS_RES_IOPORT
case|:
name|prd
operator|->
name|cprd_type
operator|=
name|CmResourceTypePort
expr_stmt|;
name|prd
operator|->
name|cprd_flags
operator|=
name|CM_RESOURCE_PORT_IO
expr_stmt|;
name|prd
operator|->
name|cprd_sharedisp
operator|=
name|CmResourceShareDeviceExclusive
expr_stmt|;
name|prd
operator|->
name|u
operator|.
name|cprd_port
operator|.
name|cprd_start
operator|.
name|np_quad
operator|=
name|brle
operator|->
name|start
expr_stmt|;
name|prd
operator|->
name|u
operator|.
name|cprd_port
operator|.
name|cprd_len
operator|=
name|brle
operator|->
name|count
expr_stmt|;
break|break;
case|case
name|SYS_RES_MEMORY
case|:
name|prd
operator|->
name|cprd_type
operator|=
name|CmResourceTypeMemory
expr_stmt|;
name|prd
operator|->
name|cprd_flags
operator|=
name|CM_RESOURCE_MEMORY_READ_WRITE
expr_stmt|;
name|prd
operator|->
name|cprd_sharedisp
operator|=
name|CmResourceShareDeviceExclusive
expr_stmt|;
name|prd
operator|->
name|u
operator|.
name|cprd_mem
operator|.
name|cprd_start
operator|.
name|np_quad
operator|=
name|brle
operator|->
name|start
expr_stmt|;
name|prd
operator|->
name|u
operator|.
name|cprd_mem
operator|.
name|cprd_len
operator|=
name|brle
operator|->
name|count
expr_stmt|;
break|break;
case|case
name|SYS_RES_IRQ
case|:
name|prd
operator|->
name|cprd_type
operator|=
name|CmResourceTypeInterrupt
expr_stmt|;
name|prd
operator|->
name|cprd_flags
operator|=
literal|0
expr_stmt|;
comment|/* 				 * Always mark interrupt resources as 				 * shared, since in our implementation, 				 * they will be. 				 */
name|prd
operator|->
name|cprd_sharedisp
operator|=
name|CmResourceShareShared
expr_stmt|;
name|prd
operator|->
name|u
operator|.
name|cprd_intr
operator|.
name|cprd_level
operator|=
name|brle
operator|->
name|start
expr_stmt|;
name|prd
operator|->
name|u
operator|.
name|cprd_intr
operator|.
name|cprd_vector
operator|=
name|brle
operator|->
name|start
expr_stmt|;
name|prd
operator|->
name|u
operator|.
name|cprd_intr
operator|.
name|cprd_affinity
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|prd
operator|++
expr_stmt|;
block|}
block|}
name|block
operator|->
name|nmb_rlist
operator|=
name|rl
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map an NDIS packet to an mbuf list. When an NDIS driver receives a  * packet, it will hand it to us in the form of an ndis_packet,  * which we need to convert to an mbuf that is then handed off  * to the stack. Note: we configure the mbuf list so that it uses  * the memory regions specified by the ndis_buffer structures in  * the ndis_packet as external storage. In most cases, this will  * point to a memory region allocated by the driver (either by  * ndis_malloc_withtag() or ndis_alloc_sharedmem()). We expect  * the driver to handle free()ing this region for is, so we set up  * a dummy no-op free handler for it.  */
end_comment

begin_function
name|int
name|ndis_ptom
parameter_list|(
name|m0
parameter_list|,
name|p
parameter_list|)
name|struct
name|mbuf
modifier|*
modifier|*
name|m0
decl_stmt|;
name|ndis_packet
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|ndis_buffer
modifier|*
name|buf
decl_stmt|;
name|ndis_packet_private
modifier|*
name|priv
decl_stmt|;
name|uint32_t
name|totlen
init|=
literal|0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|int
name|diff
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|m0
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|priv
operator|=
operator|&
name|p
operator|->
name|np_private
expr_stmt|;
name|buf
operator|=
name|priv
operator|->
name|npp_head
expr_stmt|;
name|p
operator|->
name|np_refcnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|buf
operator|=
name|priv
operator|->
name|npp_head
init|;
name|buf
operator|!=
name|NULL
condition|;
name|buf
operator|=
name|buf
operator|->
name|mdl_next
control|)
block|{
if|if
condition|(
name|buf
operator|==
name|priv
operator|->
name|npp_head
condition|)
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
else|else
name|m
operator|=
name|m_get
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|m0
argument_list|)
expr_stmt|;
operator|*
name|m0
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|MmGetMdlByteCount
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|m_extadd
argument_list|(
name|m
argument_list|,
name|MmGetMdlVirtualAddress
argument_list|(
name|buf
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|ndis_ext_free
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|EXT_NDIS
argument_list|)
expr_stmt|;
name|p
operator|->
name|np_refcnt
operator|++
expr_stmt|;
name|totlen
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
operator|*
name|m0
operator|=
name|m
expr_stmt|;
else|else
name|prev
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|prev
operator|=
name|m
expr_stmt|;
block|}
comment|/* 	 * This is a hack to deal with the Marvell 8335 driver 	 * which, when associated with an AP in WPA-PSK mode, 	 * seems to overpad its frames by 8 bytes. I don't know 	 * that the extra 8 bytes are for, and they're not there 	 * in open mode, so for now clamp the frame size at 1514 	 * until I can figure out how to deal with this properly, 	 * otherwise if_ethersubr() will spank us by discarding 	 * the 'oversize' frames. 	 */
name|eh
operator|=
name|mtod
argument_list|(
operator|(
operator|*
name|m0
operator|)
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|NDISUSB_GET_IFNET
argument_list|(
operator|(
expr|struct
name|ndis_softc
operator|*
operator|)
name|p
operator|->
name|np_softc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|&&
name|totlen
operator|>
name|ETHER_MAX_FRAME
argument_list|(
name|ifp
argument_list|,
name|eh
operator|->
name|ether_type
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|diff
operator|=
name|totlen
operator|-
name|ETHER_MAX_FRAME
argument_list|(
name|ifp
argument_list|,
name|eh
operator|->
name|ether_type
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|totlen
operator|-=
name|diff
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|diff
expr_stmt|;
block|}
operator|(
operator|*
name|m0
operator|)
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|totlen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create an NDIS packet from an mbuf chain.  * This is used mainly when transmitting packets, where we need  * to turn an mbuf off an interface's send queue and transform it  * into an NDIS packet which will be fed into the NDIS driver's  * send routine.  *  * NDIS packets consist of two parts: an ndis_packet structure,  * which is vaguely analogous to the pkthdr portion of an mbuf,  * and one or more ndis_buffer structures, which define the  * actual memory segments in which the packet data resides.  * We need to allocate one ndis_buffer for each mbuf in a chain,  * plus one ndis_packet as the header.  */
end_comment

begin_function
name|int
name|ndis_mtop
parameter_list|(
name|m0
parameter_list|,
name|p
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|ndis_packet
modifier|*
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|ndis_buffer
modifier|*
name|buf
init|=
name|NULL
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|ndis_packet_private
modifier|*
name|priv
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
operator|*
name|p
operator|==
name|NULL
operator|||
name|m0
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|priv
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|np_private
expr_stmt|;
name|priv
operator|->
name|npp_totlen
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|==
literal|0
condition|)
continue|continue;
name|buf
operator|=
name|IoAllocateMdl
argument_list|(
name|m
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|ndis_free_packet
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|MmBuildMdlForNonPagedPool
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|npp_head
operator|==
name|NULL
condition|)
name|priv
operator|->
name|npp_head
operator|=
name|buf
expr_stmt|;
else|else
name|prev
operator|->
name|mdl_next
operator|=
name|buf
expr_stmt|;
name|prev
operator|=
name|buf
expr_stmt|;
block|}
name|priv
operator|->
name|npp_tail
operator|=
name|buf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_get_supported_oids
parameter_list|(
name|arg
parameter_list|,
name|oids
parameter_list|,
name|oidcnt
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|ndis_oid
modifier|*
modifier|*
name|oids
decl_stmt|;
name|int
modifier|*
name|oidcnt
decl_stmt|;
block|{
name|int
name|len
decl_stmt|,
name|rval
decl_stmt|;
name|ndis_oid
modifier|*
name|o
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
operator|||
name|oids
operator|==
name|NULL
operator|||
name|oidcnt
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|len
operator|=
literal|0
expr_stmt|;
name|ndis_get_info
argument_list|(
name|arg
argument_list|,
name|OID_GEN_SUPPORTED_LIST
argument_list|,
name|NULL
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|o
operator|=
name|malloc
argument_list|(
name|len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|rval
operator|=
name|ndis_get_info
argument_list|(
name|arg
argument_list|,
name|OID_GEN_SUPPORTED_LIST
argument_list|,
name|o
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
condition|)
block|{
name|free
argument_list|(
name|o
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
operator|*
name|oids
operator|=
name|o
expr_stmt|;
operator|*
name|oidcnt
operator|=
name|len
operator|/
literal|4
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_set_info
parameter_list|(
name|arg
parameter_list|,
name|oid
parameter_list|,
name|buf
parameter_list|,
name|buflen
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|ndis_oid
name|oid
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|int
modifier|*
name|buflen
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_status
name|rval
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|ndis_setinfo_handler
name|setfunc
decl_stmt|;
name|uint32_t
name|byteswritten
init|=
literal|0
decl_stmt|,
name|bytesneeded
init|=
literal|0
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
name|uint64_t
name|duetime
decl_stmt|;
comment|/* 	 * According to the NDIS spec, MiniportQueryInformation() 	 * and MiniportSetInformation() requests are handled serially: 	 * once one request has been issued, we must wait for it to  	 * finish before allowing another request to proceed. 	 */
name|sc
operator|=
name|arg
expr_stmt|;
name|KeResetEvent
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_setevent
argument_list|)
expr_stmt|;
name|KeAcquireSpinLock
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_lock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_pendingreq
operator|!=
name|NULL
condition|)
block|{
name|KeReleaseSpinLock
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"ndis_set_info() called while other request pending"
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_pendingreq
operator|=
operator|(
name|ndis_request
operator|*
operator|)
name|sc
expr_stmt|;
name|setfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|->
name|nmc_setinfo_func
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_miniportadapterctx
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
operator|||
name|setfunc
operator|==
name|NULL
operator|||
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_devicectx
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_pendingreq
operator|=
name|NULL
expr_stmt|;
name|KeReleaseSpinLock
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rval
operator|=
name|MSCALL6
argument_list|(
name|setfunc
argument_list|,
name|adapter
argument_list|,
name|oid
argument_list|,
name|buf
argument_list|,
operator|*
name|buflen
argument_list|,
operator|&
name|byteswritten
argument_list|,
operator|&
name|bytesneeded
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_pendingreq
operator|=
name|NULL
expr_stmt|;
name|KeReleaseSpinLock
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_PENDING
condition|)
block|{
comment|/* Wait up to 5 seconds. */
name|duetime
operator|=
operator|(
literal|5
operator|*
literal|1000000
operator|)
operator|*
operator|-
literal|10
expr_stmt|;
name|KeWaitForSingleObject
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_setevent
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
operator|&
name|duetime
argument_list|)
expr_stmt|;
name|rval
operator|=
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_setstat
expr_stmt|;
block|}
if|if
condition|(
name|byteswritten
condition|)
operator|*
name|buflen
operator|=
name|byteswritten
expr_stmt|;
if|if
condition|(
name|bytesneeded
condition|)
operator|*
name|buflen
operator|=
name|bytesneeded
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_INVALID_LENGTH
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_INVALID_OID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_NOT_SUPPORTED
operator|||
name|rval
operator|==
name|NDIS_STATUS_NOT_ACCEPTED
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
if|if
condition|(
name|rval
operator|!=
name|NDIS_STATUS_SUCCESS
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|ndis_senddone_func
function_decl|)
parameter_list|(
name|ndis_handle
parameter_list|,
name|ndis_packet
modifier|*
parameter_list|,
name|ndis_status
parameter_list|)
function_decl|;
end_typedef

begin_function
name|int
name|ndis_send_packets
parameter_list|(
name|arg
parameter_list|,
name|packets
parameter_list|,
name|cnt
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|ndis_packet
modifier|*
modifier|*
name|packets
decl_stmt|;
name|int
name|cnt
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|ndis_sendmulti_handler
name|sendfunc
decl_stmt|;
name|ndis_senddone_func
name|senddonefunc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ndis_packet
modifier|*
name|p
decl_stmt|;
name|uint8_t
name|irql
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_miniportadapterctx
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sendfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|->
name|nmc_sendmulti_func
expr_stmt|;
name|senddonefunc
operator|=
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_senddone_func
expr_stmt|;
if|if
condition|(
name|NDIS_SERIALIZED
argument_list|(
name|sc
operator|->
name|ndis_block
argument_list|)
condition|)
name|KeAcquireSpinLock
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_lock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
name|MSCALL3
argument_list|(
name|sendfunc
argument_list|,
name|adapter
argument_list|,
name|packets
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|=
name|packets
index|[
name|i
index|]
expr_stmt|;
comment|/* 		 * Either the driver already handed the packet to 		 * ndis_txeof() due to a failure, or it wants to keep 		 * it and release it asynchronously later. Skip to the 		 * next one. 		 */
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|->
name|np_oob
operator|.
name|npo_status
operator|==
name|NDIS_STATUS_PENDING
condition|)
continue|continue;
name|MSCALL3
argument_list|(
name|senddonefunc
argument_list|,
name|sc
operator|->
name|ndis_block
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|np_oob
operator|.
name|npo_status
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NDIS_SERIALIZED
argument_list|(
name|sc
operator|->
name|ndis_block
argument_list|)
condition|)
name|KeReleaseSpinLock
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_send_packet
parameter_list|(
name|arg
parameter_list|,
name|packet
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|ndis_packet
modifier|*
name|packet
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|ndis_status
name|status
decl_stmt|;
name|ndis_sendsingle_handler
name|sendfunc
decl_stmt|;
name|ndis_senddone_func
name|senddonefunc
decl_stmt|;
name|uint8_t
name|irql
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_miniportadapterctx
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|sendfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|->
name|nmc_sendsingle_func
expr_stmt|;
name|senddonefunc
operator|=
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_senddone_func
expr_stmt|;
if|if
condition|(
name|NDIS_SERIALIZED
argument_list|(
name|sc
operator|->
name|ndis_block
argument_list|)
condition|)
name|KeAcquireSpinLock
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_lock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
name|status
operator|=
name|MSCALL3
argument_list|(
name|sendfunc
argument_list|,
name|adapter
argument_list|,
name|packet
argument_list|,
name|packet
operator|->
name|np_private
operator|.
name|npp_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|NDIS_STATUS_PENDING
condition|)
block|{
if|if
condition|(
name|NDIS_SERIALIZED
argument_list|(
name|sc
operator|->
name|ndis_block
argument_list|)
condition|)
name|KeReleaseSpinLock
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|MSCALL3
argument_list|(
name|senddonefunc
argument_list|,
name|sc
operator|->
name|ndis_block
argument_list|,
name|packet
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|NDIS_SERIALIZED
argument_list|(
name|sc
operator|->
name|ndis_block
argument_list|)
condition|)
name|KeReleaseSpinLock
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_init_dma
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|sc
operator|->
name|ndis_tmaps
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bus_dmamap_t
argument_list|)
operator|*
name|sc
operator|->
name|ndis_maxpkts
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ndis_tmaps
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|ndis_maxpkts
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|ndis_ttag
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|ndis_tmaps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|ndis_tmaps
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_destroy_dma
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|ndis_packet
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|ndis_maxpkts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sc
operator|->
name|ndis_txarray
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|sc
operator|->
name|ndis_txarray
index|[
name|i
index|]
expr_stmt|;
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|p
operator|->
name|np_rsvd
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ndis_free_packet
argument_list|(
name|sc
operator|->
name|ndis_txarray
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|ndis_ttag
argument_list|,
name|sc
operator|->
name|ndis_tmaps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|sc
operator|->
name|ndis_tmaps
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|ndis_ttag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_reset_nic
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|ndis_reset_handler
name|resetfunc
decl_stmt|;
name|uint8_t
name|addressing_reset
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|uint8_t
name|irql
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|NDIS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_miniportadapterctx
expr_stmt|;
name|resetfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|->
name|nmc_reset_func
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
operator|||
name|resetfunc
operator|==
name|NULL
operator|||
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_devicectx
operator|==
name|NULL
condition|)
block|{
name|NDIS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|NDIS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KeResetEvent
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_resetevent
argument_list|)
expr_stmt|;
if|if
condition|(
name|NDIS_SERIALIZED
argument_list|(
name|sc
operator|->
name|ndis_block
argument_list|)
condition|)
name|KeAcquireSpinLock
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_lock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
name|rval
operator|=
name|MSCALL2
argument_list|(
name|resetfunc
argument_list|,
operator|&
name|addressing_reset
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|NDIS_SERIALIZED
argument_list|(
name|sc
operator|->
name|ndis_block
argument_list|)
condition|)
name|KeReleaseSpinLock
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_PENDING
condition|)
name|KeWaitForSingleObject
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_resetevent
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_halt_nic
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|ndis_halt_handler
name|haltfunc
decl_stmt|;
name|ndis_miniport_block
modifier|*
name|block
decl_stmt|;
name|int
name|empty
init|=
literal|0
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|block
operator|=
name|sc
operator|->
name|ndis_block
expr_stmt|;
if|if
condition|(
operator|!
name|cold
condition|)
name|KeFlushQueuedDpcs
argument_list|()
expr_stmt|;
comment|/* 	 * Wait for all packets to be returned. 	 */
while|while
condition|(
literal|1
condition|)
block|{
name|KeAcquireSpinLock
argument_list|(
operator|&
name|block
operator|->
name|nmb_returnlock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
name|empty
operator|=
name|IsListEmpty
argument_list|(
operator|&
name|block
operator|->
name|nmb_returnlist
argument_list|)
expr_stmt|;
name|KeReleaseSpinLock
argument_list|(
operator|&
name|block
operator|->
name|nmb_returnlock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
if|if
condition|(
name|empty
condition|)
break|break;
name|NdisMSleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
block|}
name|NDIS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_miniportadapterctx
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
condition|)
block|{
name|NDIS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_devicectx
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * The adapter context is only valid after the init 	 * handler has been called, and is invalid once the 	 * halt handler has been called. 	 */
name|haltfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|->
name|nmc_halt_func
expr_stmt|;
name|NDIS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|MSCALL1
argument_list|(
name|haltfunc
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
name|NDIS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_miniportadapterctx
operator|=
name|NULL
expr_stmt|;
name|NDIS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_shutdown_nic
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|ndis_shutdown_handler
name|shutdownfunc
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|NDIS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_miniportadapterctx
expr_stmt|;
name|shutdownfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|->
name|nmc_shutdown_handler
expr_stmt|;
name|NDIS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
operator|||
name|shutdownfunc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|ndis_chars
operator|->
name|nmc_rsvd0
operator|==
name|NULL
condition|)
name|MSCALL1
argument_list|(
name|shutdownfunc
argument_list|,
name|adapter
argument_list|)
expr_stmt|;
else|else
name|MSCALL1
argument_list|(
name|shutdownfunc
argument_list|,
name|sc
operator|->
name|ndis_chars
operator|->
name|nmc_rsvd0
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ndis_devhead
argument_list|,
name|sc
operator|->
name|ndis_block
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_pnpevent_nic
parameter_list|(
name|arg
parameter_list|,
name|type
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|device_t
name|dev
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|ndis_pnpevent_handler
name|pnpeventfunc
decl_stmt|;
name|dev
operator|=
name|arg
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|NDIS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_miniportadapterctx
expr_stmt|;
name|pnpeventfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|->
name|nmc_pnpevent_handler
expr_stmt|;
name|NDIS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
operator|||
name|pnpeventfunc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|ndis_chars
operator|->
name|nmc_rsvd0
operator|==
name|NULL
condition|)
name|MSCALL4
argument_list|(
name|pnpeventfunc
argument_list|,
name|adapter
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|MSCALL4
argument_list|(
name|pnpeventfunc
argument_list|,
name|sc
operator|->
name|ndis_chars
operator|->
name|nmc_rsvd0
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_init_nic
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_miniport_block
modifier|*
name|block
decl_stmt|;
name|ndis_init_handler
name|initfunc
decl_stmt|;
name|ndis_status
name|status
decl_stmt|,
name|openstatus
init|=
literal|0
decl_stmt|;
name|ndis_medium
name|mediumarray
index|[
name|NdisMediumMax
index|]
decl_stmt|;
name|uint32_t
name|chosenmedium
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|arg
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|=
name|arg
expr_stmt|;
name|NDIS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|block
operator|=
name|sc
operator|->
name|ndis_block
expr_stmt|;
name|initfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|->
name|nmc_init_func
expr_stmt|;
name|NDIS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_timerlist
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NdisMediumMax
condition|;
name|i
operator|++
control|)
name|mediumarray
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|status
operator|=
name|MSCALL6
argument_list|(
name|initfunc
argument_list|,
operator|&
name|openstatus
argument_list|,
operator|&
name|chosenmedium
argument_list|,
name|mediumarray
argument_list|,
name|NdisMediumMax
argument_list|,
name|block
argument_list|,
name|block
argument_list|)
expr_stmt|;
comment|/* 	 * If the init fails, blow away the other exported routines 	 * we obtained from the driver so we can't call them later. 	 * If the init failed, none of these will work. 	 */
if|if
condition|(
name|status
operator|!=
name|NDIS_STATUS_SUCCESS
condition|)
block|{
name|NDIS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_miniportadapterctx
operator|=
name|NULL
expr_stmt|;
name|NDIS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * This may look really goofy, but apparently it is possible 	 * to halt a miniport too soon after it's been initialized. 	 * After MiniportInitialize() finishes, pause for 1 second 	 * to give the chip a chance to handle any short-lived timers 	 * that were set in motion. If we call MiniportHalt() too soon, 	 * some of the timers may not be cancelled, because the driver 	 * expects them to fire before the halt is called. 	 */
name|pause
argument_list|(
literal|"ndwait"
argument_list|,
name|hz
argument_list|)
expr_stmt|;
name|NDIS_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_devicectx
operator|=
name|sc
expr_stmt|;
name|NDIS_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ndis_intrsetup
parameter_list|(
name|dpc
parameter_list|,
name|dobj
parameter_list|,
name|ip
parameter_list|,
name|sc
parameter_list|)
name|kdpc
modifier|*
name|dpc
decl_stmt|;
name|device_object
modifier|*
name|dobj
decl_stmt|;
name|irp
modifier|*
name|ip
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|ndis_miniport_interrupt
modifier|*
name|intr
decl_stmt|;
name|intr
operator|=
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_interrupt
expr_stmt|;
comment|/* Sanity check. */
if|if
condition|(
name|intr
operator|==
name|NULL
condition|)
return|return;
name|KeAcquireSpinLockAtDpcLevel
argument_list|(
operator|&
name|intr
operator|->
name|ni_dpccountlock
argument_list|)
expr_stmt|;
name|KeResetEvent
argument_list|(
operator|&
name|intr
operator|->
name|ni_dpcevt
argument_list|)
expr_stmt|;
if|if
condition|(
name|KeInsertQueueDpc
argument_list|(
operator|&
name|intr
operator|->
name|ni_dpc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
name|TRUE
condition|)
name|intr
operator|->
name|ni_dpccnt
operator|++
expr_stmt|;
name|KeReleaseSpinLockFromDpcLevel
argument_list|(
operator|&
name|intr
operator|->
name|ni_dpccountlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ndis_get_info
parameter_list|(
name|arg
parameter_list|,
name|oid
parameter_list|,
name|buf
parameter_list|,
name|buflen
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|ndis_oid
name|oid
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|int
modifier|*
name|buflen
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|ndis_status
name|rval
decl_stmt|;
name|ndis_handle
name|adapter
decl_stmt|;
name|ndis_queryinfo_handler
name|queryfunc
decl_stmt|;
name|uint32_t
name|byteswritten
init|=
literal|0
decl_stmt|,
name|bytesneeded
init|=
literal|0
decl_stmt|;
name|uint8_t
name|irql
decl_stmt|;
name|uint64_t
name|duetime
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|KeResetEvent
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_getevent
argument_list|)
expr_stmt|;
name|KeAcquireSpinLock
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_lock
argument_list|,
operator|&
name|irql
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_pendingreq
operator|!=
name|NULL
condition|)
block|{
name|KeReleaseSpinLock
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"ndis_get_info() called while other request pending"
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_pendingreq
operator|=
operator|(
name|ndis_request
operator|*
operator|)
name|sc
expr_stmt|;
name|queryfunc
operator|=
name|sc
operator|->
name|ndis_chars
operator|->
name|nmc_queryinfo_func
expr_stmt|;
name|adapter
operator|=
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_miniportadapterctx
expr_stmt|;
if|if
condition|(
name|adapter
operator|==
name|NULL
operator|||
name|queryfunc
operator|==
name|NULL
operator|||
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_devicectx
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_pendingreq
operator|=
name|NULL
expr_stmt|;
name|KeReleaseSpinLock
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|rval
operator|=
name|MSCALL6
argument_list|(
name|queryfunc
argument_list|,
name|adapter
argument_list|,
name|oid
argument_list|,
name|buf
argument_list|,
operator|*
name|buflen
argument_list|,
operator|&
name|byteswritten
argument_list|,
operator|&
name|bytesneeded
argument_list|)
expr_stmt|;
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_pendingreq
operator|=
name|NULL
expr_stmt|;
name|KeReleaseSpinLock
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_lock
argument_list|,
name|irql
argument_list|)
expr_stmt|;
comment|/* Wait for requests that block. */
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_PENDING
condition|)
block|{
comment|/* Wait up to 5 seconds. */
name|duetime
operator|=
operator|(
literal|5
operator|*
literal|1000000
operator|)
operator|*
operator|-
literal|10
expr_stmt|;
name|KeWaitForSingleObject
argument_list|(
operator|&
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_getevent
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
operator|&
name|duetime
argument_list|)
expr_stmt|;
name|rval
operator|=
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_getstat
expr_stmt|;
block|}
if|if
condition|(
name|byteswritten
condition|)
operator|*
name|buflen
operator|=
name|byteswritten
expr_stmt|;
if|if
condition|(
name|bytesneeded
condition|)
operator|*
name|buflen
operator|=
name|bytesneeded
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_INVALID_LENGTH
operator|||
name|rval
operator|==
name|NDIS_STATUS_BUFFER_TOO_SHORT
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_INVALID_OID
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|rval
operator|==
name|NDIS_STATUS_NOT_SUPPORTED
operator|||
name|rval
operator|==
name|NDIS_STATUS_NOT_ACCEPTED
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
if|if
condition|(
name|rval
operator|!=
name|NDIS_STATUS_SUCCESS
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|NdisAddDevice
parameter_list|(
name|drv
parameter_list|,
name|pdo
parameter_list|)
name|driver_object
modifier|*
name|drv
decl_stmt|;
name|device_object
modifier|*
name|pdo
decl_stmt|;
block|{
name|device_object
modifier|*
name|fdo
decl_stmt|;
name|ndis_miniport_block
modifier|*
name|block
decl_stmt|;
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|uint32_t
name|status
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|pdo
operator|->
name|do_devext
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ndis_iftype
operator|==
name|PCMCIABus
operator|||
name|sc
operator|->
name|ndis_iftype
operator|==
name|PCIBus
condition|)
block|{
name|error
operator|=
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|ndis_dev
argument_list|,
name|sc
operator|->
name|ndis_irq
argument_list|,
name|INTR_TYPE_NET
operator||
name|INTR_MPSAFE
argument_list|,
name|NULL
argument_list|,
name|ntoskrnl_intr
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|ndis_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|NDIS_STATUS_FAILURE
operator|)
return|;
block|}
name|status
operator|=
name|IoCreateDevice
argument_list|(
name|drv
argument_list|,
sizeof|sizeof
argument_list|(
name|ndis_miniport_block
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|FILE_DEVICE_UNKNOWN
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
operator|&
name|fdo
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|STATUS_SUCCESS
condition|)
return|return
operator|(
name|status
operator|)
return|;
name|block
operator|=
name|fdo
operator|->
name|do_devext
expr_stmt|;
name|block
operator|->
name|nmb_filterdbs
operator|.
name|nf_ethdb
operator|=
name|block
expr_stmt|;
name|block
operator|->
name|nmb_deviceobj
operator|=
name|fdo
expr_stmt|;
name|block
operator|->
name|nmb_physdeviceobj
operator|=
name|pdo
expr_stmt|;
name|block
operator|->
name|nmb_nextdeviceobj
operator|=
name|IoAttachDeviceToDeviceStack
argument_list|(
name|fdo
argument_list|,
name|pdo
argument_list|)
expr_stmt|;
name|KeInitializeSpinLock
argument_list|(
operator|&
name|block
operator|->
name|nmb_lock
argument_list|)
expr_stmt|;
name|KeInitializeSpinLock
argument_list|(
operator|&
name|block
operator|->
name|nmb_returnlock
argument_list|)
expr_stmt|;
name|KeInitializeEvent
argument_list|(
operator|&
name|block
operator|->
name|nmb_getevent
argument_list|,
name|EVENT_TYPE_NOTIFY
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|KeInitializeEvent
argument_list|(
operator|&
name|block
operator|->
name|nmb_setevent
argument_list|,
name|EVENT_TYPE_NOTIFY
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|KeInitializeEvent
argument_list|(
operator|&
name|block
operator|->
name|nmb_resetevent
argument_list|,
name|EVENT_TYPE_NOTIFY
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|InitializeListHead
argument_list|(
operator|&
name|block
operator|->
name|nmb_parmlist
argument_list|)
expr_stmt|;
name|InitializeListHead
argument_list|(
operator|&
name|block
operator|->
name|nmb_returnlist
argument_list|)
expr_stmt|;
name|block
operator|->
name|nmb_returnitem
operator|=
name|IoAllocateWorkItem
argument_list|(
name|fdo
argument_list|)
expr_stmt|;
comment|/* 	 * Stash pointers to the miniport block and miniport 	 * characteristics info in the if_ndis softc so the 	 * UNIX wrapper driver can get to them later. 	 */
name|sc
operator|->
name|ndis_block
operator|=
name|block
expr_stmt|;
name|sc
operator|->
name|ndis_chars
operator|=
name|IoGetDriverObjectExtension
argument_list|(
name|drv
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * If the driver has a MiniportTransferData() function, 	 * we should allocate a private RX packet pool. 	 */
if|if
condition|(
name|sc
operator|->
name|ndis_chars
operator|->
name|nmc_transferdata_func
operator|!=
name|NULL
condition|)
block|{
name|NdisAllocatePacketPool
argument_list|(
operator|&
name|status
argument_list|,
operator|&
name|block
operator|->
name|nmb_rxpool
argument_list|,
literal|32
argument_list|,
name|PROTOCOL_RESERVED_SIZE_IN_PACKET
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|NDIS_STATUS_SUCCESS
condition|)
block|{
name|IoDetachDevice
argument_list|(
name|block
operator|->
name|nmb_nextdeviceobj
argument_list|)
expr_stmt|;
name|IoDeleteDevice
argument_list|(
name|fdo
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
name|InitializeListHead
argument_list|(
operator|(
operator|&
name|block
operator|->
name|nmb_packetlist
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Give interrupt handling priority over timers. */
name|IoInitializeDpcRequest
argument_list|(
name|fdo
argument_list|,
name|kernndis_functbl
index|[
literal|6
index|]
operator|.
name|ipt_wrap
argument_list|)
expr_stmt|;
name|KeSetImportanceDpc
argument_list|(
operator|&
name|fdo
operator|->
name|do_dpc
argument_list|,
name|KDPC_IMPORTANCE_HIGH
argument_list|)
expr_stmt|;
comment|/* Finish up BSD-specific setup. */
name|block
operator|->
name|nmb_signature
operator|=
operator|(
name|void
operator|*
operator|)
literal|0xcafebabe
expr_stmt|;
name|block
operator|->
name|nmb_status_func
operator|=
name|kernndis_functbl
index|[
literal|0
index|]
operator|.
name|ipt_wrap
expr_stmt|;
name|block
operator|->
name|nmb_statusdone_func
operator|=
name|kernndis_functbl
index|[
literal|1
index|]
operator|.
name|ipt_wrap
expr_stmt|;
name|block
operator|->
name|nmb_setdone_func
operator|=
name|kernndis_functbl
index|[
literal|2
index|]
operator|.
name|ipt_wrap
expr_stmt|;
name|block
operator|->
name|nmb_querydone_func
operator|=
name|kernndis_functbl
index|[
literal|3
index|]
operator|.
name|ipt_wrap
expr_stmt|;
name|block
operator|->
name|nmb_resetdone_func
operator|=
name|kernndis_functbl
index|[
literal|4
index|]
operator|.
name|ipt_wrap
expr_stmt|;
name|block
operator|->
name|nmb_sendrsrc_func
operator|=
name|kernndis_functbl
index|[
literal|5
index|]
operator|.
name|ipt_wrap
expr_stmt|;
name|block
operator|->
name|nmb_pendingreq
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ndis_devhead
argument_list|,
name|block
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|STATUS_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ndis_unload_driver
parameter_list|(
name|arg
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|struct
name|ndis_softc
modifier|*
name|sc
decl_stmt|;
name|device_object
modifier|*
name|fdo
decl_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ndis_intrhand
condition|)
name|bus_teardown_intr
argument_list|(
name|sc
operator|->
name|ndis_dev
argument_list|,
name|sc
operator|->
name|ndis_irq
argument_list|,
name|sc
operator|->
name|ndis_intrhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_rlist
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_rlist
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ndis_flush_sysctls
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ndis_devhead
argument_list|,
name|sc
operator|->
name|ndis_block
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|ndis_chars
operator|->
name|nmc_transferdata_func
operator|!=
name|NULL
condition|)
name|NdisFreePacketPool
argument_list|(
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_rxpool
argument_list|)
expr_stmt|;
name|fdo
operator|=
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_deviceobj
expr_stmt|;
name|IoFreeWorkItem
argument_list|(
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_returnitem
argument_list|)
expr_stmt|;
name|IoDetachDevice
argument_list|(
name|sc
operator|->
name|ndis_block
operator|->
name|nmb_nextdeviceobj
argument_list|)
expr_stmt|;
name|IoDeleteDevice
argument_list|(
name|fdo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

