begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2017 Mark Johnston<markj@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conds  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conds, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conds and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sleepqueue.h>
end_include

begin_include
include|#
directive|include
file|<linux/errno.h>
end_include

begin_include
include|#
directive|include
file|<linux/kernel.h>
end_include

begin_include
include|#
directive|include
file|<linux/list.h>
end_include

begin_include
include|#
directive|include
file|<linux/sched.h>
end_include

begin_include
include|#
directive|include
file|<linux/spinlock.h>
end_include

begin_include
include|#
directive|include
file|<linux/wait.h>
end_include

begin_function
specifier|static
name|int
name|linux_add_to_sleepqueue
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|,
specifier|const
name|char
modifier|*
name|wmesg
parameter_list|,
name|int
name|timeout
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|int
name|flags
decl_stmt|,
name|ret
decl_stmt|;
name|MPASS
argument_list|(
operator|(
name|state
operator|&
operator|~
name|TASK_NORMAL
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|flags
operator|=
name|SLEEPQ_SLEEP
operator||
operator|(
operator|(
name|state
operator|&
name|TASK_INTERRUPTIBLE
operator|)
operator|!=
literal|0
condition|?
name|SLEEPQ_INTERRUPTIBLE
else|:
literal|0
operator|)
expr_stmt|;
name|sleepq_add
argument_list|(
name|wchan
argument_list|,
name|NULL
argument_list|,
name|wmesg
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout
operator|!=
literal|0
condition|)
name|sleepq_set_timeout
argument_list|(
name|wchan
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|state
operator|&
name|TASK_INTERRUPTIBLE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
name|ret
operator|=
operator|-
name|sleepq_wait_sig
argument_list|(
name|wchan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
operator|-
name|sleepq_timedwait_sig
argument_list|(
name|wchan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|sleepq_wait
argument_list|(
name|wchan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|ret
operator|=
operator|-
name|sleepq_timedwait
argument_list|(
name|wchan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* filter return value */
if|if
condition|(
name|ret
operator|!=
literal|0
operator|&&
name|ret
operator|!=
operator|-
name|EWOULDBLOCK
condition|)
name|ret
operator|=
operator|-
name|ERESTARTSYS
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wake_up_task
parameter_list|(
name|struct
name|task_struct
modifier|*
name|task
parameter_list|,
name|unsigned
name|int
name|state
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|wakeup_swapper
decl_stmt|;
name|ret
operator|=
name|wakeup_swapper
operator|=
literal|0
expr_stmt|;
name|sleepq_lock
argument_list|(
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|task
operator|->
name|state
argument_list|)
operator|&
name|state
operator|)
operator|!=
literal|0
condition|)
block|{
name|set_task_state
argument_list|(
name|task
argument_list|,
name|TASK_WAKING
argument_list|)
expr_stmt|;
name|wakeup_swapper
operator|=
name|sleepq_signal
argument_list|(
name|task
argument_list|,
name|SLEEPQ_SLEEP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
name|sleepq_release
argument_list|(
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|wakeup_swapper
condition|)
name|kick_proc0
argument_list|()
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|linux_signal_pending
parameter_list|(
name|struct
name|task_struct
modifier|*
name|task
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|sigset_t
name|pending
decl_stmt|;
name|td
operator|=
name|task
operator|->
name|task_thread
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|pending
operator|=
name|td
operator|->
name|td_siglist
expr_stmt|;
name|SIGSETOR
argument_list|(
name|pending
argument_list|,
name|td
operator|->
name|td_proc
operator|->
name|p_siglist
argument_list|)
expr_stmt|;
name|SIGSETNAND
argument_list|(
name|pending
argument_list|,
name|td
operator|->
name|td_sigmask
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
name|SIGISEMPTY
argument_list|(
name|pending
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|linux_fatal_signal_pending
parameter_list|(
name|struct
name|task_struct
modifier|*
name|task
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|bool
name|ret
decl_stmt|;
name|td
operator|=
name|task
operator|->
name|task_thread
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|ret
operator|=
name|SIGISMEMBER
argument_list|(
name|td
operator|->
name|td_siglist
argument_list|,
name|SIGKILL
argument_list|)
operator|||
name|SIGISMEMBER
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_siglist
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|linux_signal_pending_state
parameter_list|(
name|long
name|state
parameter_list|,
name|struct
name|task_struct
modifier|*
name|task
parameter_list|)
block|{
name|MPASS
argument_list|(
operator|(
name|state
operator|&
operator|~
name|TASK_NORMAL
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|state
operator|&
name|TASK_INTERRUPTIBLE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
operator|(
name|linux_signal_pending
argument_list|(
name|task
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|linux_send_sig
parameter_list|(
name|int
name|signo
parameter_list|,
name|struct
name|task_struct
modifier|*
name|task
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|td
operator|=
name|task
operator|->
name|task_thread
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|tdsignal
argument_list|(
name|td
argument_list|,
name|signo
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|autoremove_wake_function
parameter_list|(
name|wait_queue_t
modifier|*
name|wq
parameter_list|,
name|unsigned
name|int
name|state
parameter_list|,
name|int
name|flags
parameter_list|,
name|void
modifier|*
name|key
name|__unused
parameter_list|)
block|{
name|struct
name|task_struct
modifier|*
name|task
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|task
operator|=
name|wq
operator|->
name|private
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|wake_up_task
argument_list|(
name|task
argument_list|,
name|state
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|list_del_init
argument_list|(
operator|&
name|wq
operator|->
name|task_list
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|linux_wake_up
parameter_list|(
name|wait_queue_head_t
modifier|*
name|wqh
parameter_list|,
name|unsigned
name|int
name|state
parameter_list|,
name|int
name|nr
parameter_list|,
name|bool
name|locked
parameter_list|)
block|{
name|wait_queue_t
modifier|*
name|pos
decl_stmt|,
modifier|*
name|next
decl_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|spin_lock
argument_list|(
operator|&
name|wqh
operator|->
name|lock
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|pos
argument_list|,
argument|next
argument_list|,
argument|&wqh->task_list
argument_list|,
argument|task_list
argument_list|)
block|{
if|if
condition|(
name|pos
operator|->
name|func
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|wake_up_task
argument_list|(
name|pos
operator|->
name|private
argument_list|,
name|state
argument_list|)
operator|!=
literal|0
operator|&&
operator|--
name|nr
operator|==
literal|0
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
name|pos
operator|->
name|func
argument_list|(
name|pos
argument_list|,
name|state
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
operator|&&
operator|--
name|nr
operator|==
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|locked
condition|)
name|spin_unlock
argument_list|(
operator|&
name|wqh
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|linux_prepare_to_wait
parameter_list|(
name|wait_queue_head_t
modifier|*
name|wqh
parameter_list|,
name|wait_queue_t
modifier|*
name|wq
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|spin_lock
argument_list|(
operator|&
name|wqh
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|wq
operator|->
name|task_list
argument_list|)
condition|)
name|__add_wait_queue
argument_list|(
name|wqh
argument_list|,
name|wq
argument_list|)
expr_stmt|;
name|set_task_state
argument_list|(
name|current
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|wqh
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|linux_finish_wait
parameter_list|(
name|wait_queue_head_t
modifier|*
name|wqh
parameter_list|,
name|wait_queue_t
modifier|*
name|wq
parameter_list|)
block|{
name|spin_lock
argument_list|(
operator|&
name|wqh
operator|->
name|lock
argument_list|)
expr_stmt|;
name|set_task_state
argument_list|(
name|current
argument_list|,
name|TASK_RUNNING
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|wq
operator|->
name|task_list
argument_list|)
condition|)
block|{
name|__remove_wait_queue
argument_list|(
name|wqh
argument_list|,
name|wq
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|wq
operator|->
name|task_list
argument_list|)
expr_stmt|;
block|}
name|spin_unlock
argument_list|(
operator|&
name|wqh
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|bool
name|linux_waitqueue_active
parameter_list|(
name|wait_queue_head_t
modifier|*
name|wqh
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|;
name|spin_lock
argument_list|(
operator|&
name|wqh
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|!
name|list_empty
argument_list|(
operator|&
name|wqh
operator|->
name|task_list
argument_list|)
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|wqh
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_wait_event_common
parameter_list|(
name|wait_queue_head_t
modifier|*
name|wqh
parameter_list|,
name|wait_queue_t
modifier|*
name|wq
parameter_list|,
name|int
name|timeout
parameter_list|,
name|unsigned
name|int
name|state
parameter_list|,
name|spinlock_t
modifier|*
name|lock
parameter_list|)
block|{
name|struct
name|task_struct
modifier|*
name|task
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|lock
operator|!=
name|NULL
condition|)
name|spin_unlock_irq
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
comment|/* range check timeout */
if|if
condition|(
name|timeout
operator|<
literal|1
condition|)
name|timeout
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|timeout
operator|==
name|MAX_SCHEDULE_TIMEOUT
condition|)
name|timeout
operator|=
literal|0
expr_stmt|;
name|task
operator|=
name|current
expr_stmt|;
comment|/* 	 * Our wait queue entry is on the stack - make sure it doesn't 	 * get swapped out while we sleep. 	 */
name|PHOLD
argument_list|(
name|task
operator|->
name|task_thread
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|sleepq_lock
argument_list|(
name|task
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_load_acq_int
argument_list|(
operator|&
name|task
operator|->
name|state
argument_list|)
operator|!=
name|TASK_WAKING
condition|)
block|{
name|ret
operator|=
name|linux_add_to_sleepqueue
argument_list|(
name|task
argument_list|,
literal|"wevent"
argument_list|,
name|timeout
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sleepq_release
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|ret
operator|=
name|linux_signal_pending_state
argument_list|(
name|state
argument_list|,
name|task
argument_list|)
condition|?
operator|-
name|ERESTARTSYS
else|:
literal|0
expr_stmt|;
block|}
name|PRELE
argument_list|(
name|task
operator|->
name|task_thread
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
if|if
condition|(
name|lock
operator|!=
name|NULL
condition|)
name|spin_lock_irq
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_schedule_timeout
parameter_list|(
name|int
name|timeout
parameter_list|)
block|{
name|struct
name|task_struct
modifier|*
name|task
decl_stmt|;
name|int
name|state
decl_stmt|;
name|int
name|remainder
decl_stmt|;
name|task
operator|=
name|current
expr_stmt|;
comment|/* range check timeout */
if|if
condition|(
name|timeout
operator|<
literal|1
condition|)
name|timeout
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|timeout
operator|==
name|MAX_SCHEDULE_TIMEOUT
condition|)
name|timeout
operator|=
literal|0
expr_stmt|;
name|remainder
operator|=
name|ticks
operator|+
name|timeout
expr_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|sleepq_lock
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|state
operator|=
name|atomic_load_acq_int
argument_list|(
operator|&
name|task
operator|->
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|TASK_WAKING
condition|)
operator|(
name|void
operator|)
name|linux_add_to_sleepqueue
argument_list|(
name|task
argument_list|,
literal|"sched"
argument_list|,
name|timeout
argument_list|,
name|state
argument_list|)
expr_stmt|;
else|else
name|sleepq_release
argument_list|(
name|task
argument_list|)
expr_stmt|;
name|set_task_state
argument_list|(
name|task
argument_list|,
name|TASK_RUNNING
argument_list|)
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
return|return
operator|(
name|MAX_SCHEDULE_TIMEOUT
operator|)
return|;
comment|/* range check return value */
name|remainder
operator|-=
name|ticks
expr_stmt|;
if|if
condition|(
name|remainder
operator|<
literal|0
condition|)
name|remainder
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|remainder
operator|>
name|timeout
condition|)
name|remainder
operator|=
name|timeout
expr_stmt|;
return|return
operator|(
name|remainder
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wake_up_sleepers
parameter_list|(
name|void
modifier|*
name|wchan
parameter_list|)
block|{
name|int
name|wakeup_swapper
decl_stmt|;
name|sleepq_lock
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|wakeup_swapper
operator|=
name|sleepq_signal
argument_list|(
name|wchan
argument_list|,
name|SLEEPQ_SLEEP
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sleepq_release
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
if|if
condition|(
name|wakeup_swapper
condition|)
name|kick_proc0
argument_list|()
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|bit_to_wchan
parameter_list|(
name|word
parameter_list|,
name|bit
parameter_list|)
value|((void *)(((uintptr_t)(word)<< 6) | (bit)))
end_define

begin_function
name|void
name|linux_wake_up_bit
parameter_list|(
name|void
modifier|*
name|word
parameter_list|,
name|int
name|bit
parameter_list|)
block|{
name|wake_up_sleepers
argument_list|(
name|bit_to_wchan
argument_list|(
name|word
argument_list|,
name|bit
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|linux_wait_on_bit_timeout
parameter_list|(
name|unsigned
name|long
modifier|*
name|word
parameter_list|,
name|int
name|bit
parameter_list|,
name|unsigned
name|int
name|state
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
name|struct
name|task_struct
modifier|*
name|task
decl_stmt|;
name|void
modifier|*
name|wchan
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
comment|/* range check timeout */
if|if
condition|(
name|timeout
operator|<
literal|1
condition|)
name|timeout
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|timeout
operator|==
name|MAX_SCHEDULE_TIMEOUT
condition|)
name|timeout
operator|=
literal|0
expr_stmt|;
name|task
operator|=
name|current
expr_stmt|;
name|wchan
operator|=
name|bit_to_wchan
argument_list|(
name|word
argument_list|,
name|bit
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|sleepq_lock
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|word
operator|&
operator|(
literal|1
operator|<<
name|bit
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|sleepq_release
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|set_task_state
argument_list|(
name|task
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|ret
operator|=
name|linux_add_to_sleepqueue
argument_list|(
name|wchan
argument_list|,
literal|"wbit"
argument_list|,
name|timeout
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
break|break;
block|}
name|set_task_state
argument_list|(
name|task
argument_list|,
name|TASK_RUNNING
argument_list|)
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|linux_wake_up_atomic_t
parameter_list|(
name|atomic_t
modifier|*
name|a
parameter_list|)
block|{
name|wake_up_sleepers
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|linux_wait_on_atomic_t
parameter_list|(
name|atomic_t
modifier|*
name|a
parameter_list|,
name|unsigned
name|int
name|state
parameter_list|)
block|{
name|struct
name|task_struct
modifier|*
name|task
decl_stmt|;
name|void
modifier|*
name|wchan
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|DROP_GIANT
argument_list|()
expr_stmt|;
name|task
operator|=
name|current
expr_stmt|;
name|wchan
operator|=
name|a
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|sleepq_lock
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_read
argument_list|(
name|a
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sleepq_release
argument_list|(
name|wchan
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|set_task_state
argument_list|(
name|task
argument_list|,
name|state
argument_list|)
expr_stmt|;
name|ret
operator|=
name|linux_add_to_sleepqueue
argument_list|(
name|wchan
argument_list|,
literal|"watomic"
argument_list|,
literal|0
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
break|break;
block|}
name|set_task_state
argument_list|(
name|task
argument_list|,
name|TASK_RUNNING
argument_list|)
expr_stmt|;
name|PICKUP_GIANT
argument_list|()
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|linux_wake_up_state
parameter_list|(
name|struct
name|task_struct
modifier|*
name|task
parameter_list|,
name|unsigned
name|int
name|state
parameter_list|)
block|{
return|return
operator|(
name|wake_up_task
argument_list|(
name|task
argument_list|,
name|state
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

end_unit

