begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2007 Luigi Rizzo - Universita` di Pisa. All rights reserved.  * Copyright (c) 2007 Hans Petter Selasky. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USB_GLOBAL_INCLUDE_FILE
end_ifdef

begin_include
include|#
directive|include
include|USB_GLOBAL_INCLUDE_FILE
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/stdint.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usbdi_util.h>
end_include

begin_define
define|#
directive|define
name|USB_DEBUG_VAR
value|usb_debug
end_define

begin_include
include|#
directive|include
file|<dev/usb/usb_core.h>
end_include

begin_include
include|#
directive|include
file|<linux/usb.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_process.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_device.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_util.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_busdma.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_transfer.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_hub.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_request.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_debug.h>
end_include

begin_include
include|#
directive|include
file|<dev/usb/usb_dynamic.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USB_GLOBAL_INCLUDE_FILE */
end_comment

begin_struct
struct|struct
name|usb_linux_softc
block|{
name|LIST_ENTRY
argument_list|(
argument|usb_linux_softc
argument_list|)
name|sc_attached_list
expr_stmt|;
name|device_t
name|sc_fbsd_dev
decl_stmt|;
name|struct
name|usb_device
modifier|*
name|sc_fbsd_udev
decl_stmt|;
name|struct
name|usb_interface
modifier|*
name|sc_ui
decl_stmt|;
name|struct
name|usb_driver
modifier|*
name|sc_udrv
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* prototypes */
end_comment

begin_decl_stmt
specifier|static
name|device_probe_t
name|usb_linux_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_attach_t
name|usb_linux_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_detach_t
name|usb_linux_detach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_suspend_t
name|usb_linux_suspend
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_resume_t
name|usb_linux_resume
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|usb_linux_isoc_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_callback_t
name|usb_linux_non_isoc_callback
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|usb_complete_t
name|usb_linux_wait_complete
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|uint16_t
name|usb_max_isoc_frames
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|usb_start_wait_urb
parameter_list|(
name|struct
name|urb
modifier|*
parameter_list|,
name|usb_timeout_t
parameter_list|,
name|uint16_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|usb_device_id
modifier|*
name|usb_linux_lookup_id
parameter_list|(
specifier|const
name|struct
name|usb_device_id
modifier|*
parameter_list|,
name|struct
name|usb_attach_arg
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|usb_driver
modifier|*
name|usb_linux_get_usb_driver
parameter_list|(
name|struct
name|usb_linux_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|usb_linux_create_usb_device
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|,
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_linux_cleanup_interface
parameter_list|(
name|struct
name|usb_device
modifier|*
parameter_list|,
name|struct
name|usb_interface
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usb_linux_complete
parameter_list|(
name|struct
name|usb_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|usb_unlink_urb_sub
parameter_list|(
name|struct
name|urb
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*------------------------------------------------------------------------*  * FreeBSD USB interface  *------------------------------------------------------------------------*/
end_comment

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|usb_linux_softc
argument_list|)
name|usb_linux_attached_list
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|usb_driver
argument_list|)
name|usb_linux_driver_list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|usb_linux_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|usb_linux_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|usb_linux_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|usb_linux_detach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|usb_linux_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|usb_linux_resume
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_t
name|usb_linux_driver
init|=
block|{
operator|.
name|name
operator|=
literal|"usb_linux"
block|,
operator|.
name|methods
operator|=
name|usb_linux_methods
block|,
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|usb_linux_softc
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|usb_linux_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|usb_linux
argument_list|,
name|uhub
argument_list|,
name|usb_linux_driver
argument_list|,
name|usb_linux_devclass
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|usb_linux
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_linux_lookup_id  *  * This functions takes an array of "struct usb_device_id" and tries  * to match the entries with the information in "struct usb_attach_arg".  * If it finds a match the matching entry will be returned.  * Else "NULL" will be returned.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|usb_device_id
modifier|*
name|usb_linux_lookup_id
parameter_list|(
specifier|const
name|struct
name|usb_device_id
modifier|*
name|id
parameter_list|,
name|struct
name|usb_attach_arg
modifier|*
name|uaa
parameter_list|)
block|{
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Keep on matching array entries until we find one with 	 * "match_flags" equal to zero, which indicates the end of the 	 * array: 	 */
for|for
control|(
init|;
name|id
operator|->
name|match_flags
condition|;
name|id
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|id
operator|->
name|match_flags
operator|&
name|USB_DEVICE_ID_MATCH_VENDOR
operator|)
operator|&&
operator|(
name|id
operator|->
name|idVendor
operator|!=
name|uaa
operator|->
name|info
operator|.
name|idVendor
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|id
operator|->
name|match_flags
operator|&
name|USB_DEVICE_ID_MATCH_PRODUCT
operator|)
operator|&&
operator|(
name|id
operator|->
name|idProduct
operator|!=
name|uaa
operator|->
name|info
operator|.
name|idProduct
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|id
operator|->
name|match_flags
operator|&
name|USB_DEVICE_ID_MATCH_DEV_LO
operator|)
operator|&&
operator|(
name|id
operator|->
name|bcdDevice_lo
operator|>
name|uaa
operator|->
name|info
operator|.
name|bcdDevice
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|id
operator|->
name|match_flags
operator|&
name|USB_DEVICE_ID_MATCH_DEV_HI
operator|)
operator|&&
operator|(
name|id
operator|->
name|bcdDevice_hi
operator|<
name|uaa
operator|->
name|info
operator|.
name|bcdDevice
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|id
operator|->
name|match_flags
operator|&
name|USB_DEVICE_ID_MATCH_DEV_CLASS
operator|)
operator|&&
operator|(
name|id
operator|->
name|bDeviceClass
operator|!=
name|uaa
operator|->
name|info
operator|.
name|bDeviceClass
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|id
operator|->
name|match_flags
operator|&
name|USB_DEVICE_ID_MATCH_DEV_SUBCLASS
operator|)
operator|&&
operator|(
name|id
operator|->
name|bDeviceSubClass
operator|!=
name|uaa
operator|->
name|info
operator|.
name|bDeviceSubClass
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|id
operator|->
name|match_flags
operator|&
name|USB_DEVICE_ID_MATCH_DEV_PROTOCOL
operator|)
operator|&&
operator|(
name|id
operator|->
name|bDeviceProtocol
operator|!=
name|uaa
operator|->
name|info
operator|.
name|bDeviceProtocol
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|uaa
operator|->
name|info
operator|.
name|bDeviceClass
operator|==
literal|0xFF
operator|)
operator|&&
operator|!
operator|(
name|id
operator|->
name|match_flags
operator|&
name|USB_DEVICE_ID_MATCH_VENDOR
operator|)
operator|&&
operator|(
name|id
operator|->
name|match_flags
operator|&
operator|(
name|USB_DEVICE_ID_MATCH_INT_CLASS
operator||
name|USB_DEVICE_ID_MATCH_INT_SUBCLASS
operator||
name|USB_DEVICE_ID_MATCH_INT_PROTOCOL
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|id
operator|->
name|match_flags
operator|&
name|USB_DEVICE_ID_MATCH_INT_CLASS
operator|)
operator|&&
operator|(
name|id
operator|->
name|bInterfaceClass
operator|!=
name|uaa
operator|->
name|info
operator|.
name|bInterfaceClass
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|id
operator|->
name|match_flags
operator|&
name|USB_DEVICE_ID_MATCH_INT_SUBCLASS
operator|)
operator|&&
operator|(
name|id
operator|->
name|bInterfaceSubClass
operator|!=
name|uaa
operator|->
name|info
operator|.
name|bInterfaceSubClass
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|id
operator|->
name|match_flags
operator|&
name|USB_DEVICE_ID_MATCH_INT_PROTOCOL
operator|)
operator|&&
operator|(
name|id
operator|->
name|bInterfaceProtocol
operator|!=
name|uaa
operator|->
name|info
operator|.
name|bInterfaceProtocol
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* we found a match! */
return|return
operator|(
name|id
operator|)
return|;
block|}
name|done
label|:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_linux_probe  *  * This function is the FreeBSD probe callback. It is called from the  * FreeBSD USB stack through the "device_probe_and_attach()" function.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|usb_linux_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_driver
modifier|*
name|udrv
decl_stmt|;
name|int
name|err
init|=
name|ENXIO
decl_stmt|;
if|if
condition|(
name|uaa
operator|->
name|usb_mode
operator|!=
name|USB_MODE_HOST
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|udrv
argument_list|,
argument|&usb_linux_driver_list
argument_list|,
argument|linux_driver_list
argument_list|)
block|{
if|if
condition|(
name|usb_linux_lookup_id
argument_list|(
name|udrv
operator|->
name|id_table
argument_list|,
name|uaa
argument_list|)
condition|)
block|{
name|err
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_linux_get_usb_driver  *  * This function returns the pointer to the "struct usb_driver" where  * the Linux USB device driver "struct usb_device_id" match was found.  * We apply a lock before reading out the pointer to avoid races.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|struct
name|usb_driver
modifier|*
name|usb_linux_get_usb_driver
parameter_list|(
name|struct
name|usb_linux_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|usb_driver
modifier|*
name|udrv
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|udrv
operator|=
name|sc
operator|->
name|sc_udrv
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|udrv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_linux_attach  *  * This function is the FreeBSD attach callback. It is called from the  * FreeBSD USB stack through the "device_probe_and_attach()" function.  * This function is called when "usb_linux_probe()" returns zero.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|usb_linux_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|usb_attach_arg
modifier|*
name|uaa
init|=
name|device_get_ivars
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_linux_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_driver
modifier|*
name|udrv
decl_stmt|;
specifier|const
name|struct
name|usb_device_id
modifier|*
name|id
init|=
name|NULL
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|udrv
argument_list|,
argument|&usb_linux_driver_list
argument_list|,
argument|linux_driver_list
argument_list|)
block|{
name|id
operator|=
name|usb_linux_lookup_id
argument_list|(
name|udrv
operator|->
name|id_table
argument_list|,
name|uaa
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
condition|)
break|break;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|usb_linux_create_usb_device
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
name|dev
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|device_set_usb_desc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_fbsd_udev
operator|=
name|uaa
operator|->
name|device
expr_stmt|;
name|sc
operator|->
name|sc_fbsd_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_udrv
operator|=
name|udrv
expr_stmt|;
name|sc
operator|->
name|sc_ui
operator|=
name|usb_ifnum_to_if
argument_list|(
name|uaa
operator|->
name|device
argument_list|,
name|uaa
operator|->
name|info
operator|.
name|bIfaceNum
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ui
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|udrv
operator|->
name|probe
condition|)
block|{
if|if
condition|(
call|(
name|udrv
operator|->
name|probe
call|)
argument_list|(
name|sc
operator|->
name|sc_ui
argument_list|,
name|id
argument_list|)
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
block|}
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|usb_linux_attached_list
argument_list|,
name|sc
argument_list|,
name|sc_attached_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
comment|/* success */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_linux_detach  *  * This function is the FreeBSD detach callback. It is called from the  * FreeBSD USB stack through the "device_detach()" function.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|usb_linux_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|usb_linux_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_driver
modifier|*
name|udrv
init|=
name|NULL
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_attached_list
operator|.
name|le_prev
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|sc
argument_list|,
name|sc_attached_list
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_attached_list
operator|.
name|le_prev
operator|=
name|NULL
expr_stmt|;
name|udrv
operator|=
name|sc
operator|->
name|sc_udrv
expr_stmt|;
name|sc
operator|->
name|sc_udrv
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|udrv
operator|&&
name|udrv
operator|->
name|disconnect
condition|)
block|{
call|(
name|udrv
operator|->
name|disconnect
call|)
argument_list|(
name|sc
operator|->
name|sc_ui
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Make sure that we free all FreeBSD USB transfers belonging to 	 * this Linux "usb_interface", hence they will most likely not be 	 * needed any more. 	 */
name|usb_linux_cleanup_interface
argument_list|(
name|sc
operator|->
name|sc_fbsd_udev
argument_list|,
name|sc
operator|->
name|sc_ui
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_linux_suspend  *  * This function is the FreeBSD suspend callback. Usually it does nothing.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|usb_linux_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|usb_linux_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_driver
modifier|*
name|udrv
init|=
name|usb_linux_get_usb_driver
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|udrv
operator|&&
name|udrv
operator|->
name|suspend
condition|)
block|{
name|err
operator|=
call|(
name|udrv
operator|->
name|suspend
call|)
argument_list|(
name|sc
operator|->
name|sc_ui
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_linux_resume  *  * This function is the FreeBSD resume callback. Usually it does nothing.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|usb_linux_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|usb_linux_softc
modifier|*
name|sc
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|usb_driver
modifier|*
name|udrv
init|=
name|usb_linux_get_usb_driver
argument_list|(
name|sc
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|udrv
operator|&&
name|udrv
operator|->
name|resume
condition|)
block|{
name|err
operator|=
call|(
name|udrv
operator|->
name|resume
call|)
argument_list|(
name|sc
operator|->
name|sc_ui
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  * Linux emulation layer  *------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_max_isoc_frames  *  * The following function returns the maximum number of isochronous  * frames that we support per URB. It is not part of the Linux USB API.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|uint16_t
name|usb_max_isoc_frames
parameter_list|(
name|struct
name|usb_device
modifier|*
name|dev
parameter_list|)
block|{
empty_stmt|;
comment|/* indent fix */
switch|switch
condition|(
name|usbd_get_speed
argument_list|(
name|dev
argument_list|)
condition|)
block|{
case|case
name|USB_SPEED_LOW
case|:
case|case
name|USB_SPEED_FULL
case|:
return|return
operator|(
name|USB_MAX_FULL_SPEED_ISOC_FRAMES
operator|)
return|;
default|default:
return|return
operator|(
name|USB_MAX_HIGH_SPEED_ISOC_FRAMES
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_submit_urb  *  * This function is used to queue an URB after that it has been  * initialized. If it returns non-zero, it means that the URB was not  * queued.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|usb_submit_urb
parameter_list|(
name|struct
name|urb
modifier|*
name|urb
parameter_list|,
name|uint16_t
name|mem_flags
parameter_list|)
block|{
name|struct
name|usb_host_endpoint
modifier|*
name|uhe
decl_stmt|;
name|uint8_t
name|do_unlock
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|urb
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
name|do_unlock
operator|=
name|mtx_owned
argument_list|(
operator|&
name|Giant
argument_list|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|do_unlock
condition|)
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|urb
operator|->
name|endpoint
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*          * Check to see if the urb is in the process of being killed          * and stop a urb that is in the process of being killed from          * being re-submitted (e.g. from its completion callback          * function).          */
if|if
condition|(
name|urb
operator|->
name|kill_count
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
operator|-
name|EPERM
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|uhe
operator|=
name|urb
operator|->
name|endpoint
expr_stmt|;
comment|/* 	 * Check that we have got a FreeBSD USB transfer that will dequeue 	 * the URB structure and do the real transfer. If there are no USB 	 * transfers, then we return an error. 	 */
if|if
condition|(
name|uhe
operator|->
name|bsd_xfer
index|[
literal|0
index|]
operator|||
name|uhe
operator|->
name|bsd_xfer
index|[
literal|1
index|]
condition|)
block|{
comment|/* we are ready! */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|uhe
operator|->
name|bsd_urb_list
argument_list|,
name|urb
argument_list|,
name|bsd_urb_list
argument_list|)
expr_stmt|;
name|urb
operator|->
name|status
operator|=
operator|-
name|EINPROGRESS
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|uhe
operator|->
name|bsd_xfer
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|usbd_transfer_start
argument_list|(
name|uhe
operator|->
name|bsd_xfer
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* no pipes have been setup yet! */
name|urb
operator|->
name|status
operator|=
operator|-
name|EINVAL
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|do_unlock
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_unlink_urb  *  * This function is used to stop an URB after that it is been  * submitted, but before the "complete" callback has been called. On  *------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|usb_unlink_urb
parameter_list|(
name|struct
name|urb
modifier|*
name|urb
parameter_list|)
block|{
return|return
operator|(
name|usb_unlink_urb_sub
argument_list|(
name|urb
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usb_unlink_bsd
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|struct
name|urb
modifier|*
name|urb
parameter_list|,
name|uint8_t
name|drain
parameter_list|)
block|{
if|if
condition|(
name|xfer
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|!
name|usbd_transfer_pending
argument_list|(
name|xfer
argument_list|)
condition|)
return|return;
if|if
condition|(
name|xfer
operator|->
name|priv_fifo
operator|==
operator|(
name|void
operator|*
operator|)
name|urb
condition|)
block|{
if|if
condition|(
name|drain
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|usbd_transfer_drain
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usbd_transfer_stop
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
name|usbd_transfer_start
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|usb_unlink_urb_sub
parameter_list|(
name|struct
name|urb
modifier|*
name|urb
parameter_list|,
name|uint8_t
name|drain
parameter_list|)
block|{
name|struct
name|usb_host_endpoint
modifier|*
name|uhe
decl_stmt|;
name|uint16_t
name|x
decl_stmt|;
name|uint8_t
name|do_unlock
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|urb
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
name|do_unlock
operator|=
name|mtx_owned
argument_list|(
operator|&
name|Giant
argument_list|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|do_unlock
condition|)
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|drain
condition|)
name|urb
operator|->
name|kill_count
operator|++
expr_stmt|;
if|if
condition|(
name|urb
operator|->
name|endpoint
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|uhe
operator|=
name|urb
operator|->
name|endpoint
expr_stmt|;
if|if
condition|(
name|urb
operator|->
name|bsd_urb_list
operator|.
name|tqe_prev
condition|)
block|{
comment|/* not started yet, just remove it from the queue */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|uhe
operator|->
name|bsd_urb_list
argument_list|,
name|urb
argument_list|,
name|bsd_urb_list
argument_list|)
expr_stmt|;
name|urb
operator|->
name|bsd_urb_list
operator|.
name|tqe_prev
operator|=
name|NULL
expr_stmt|;
name|urb
operator|->
name|status
operator|=
operator|-
name|ECONNRESET
expr_stmt|;
name|urb
operator|->
name|actual_length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|urb
operator|->
name|number_of_packets
condition|;
name|x
operator|++
control|)
block|{
name|urb
operator|->
name|iso_frame_desc
index|[
name|x
index|]
operator|.
name|actual_length
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|urb
operator|->
name|complete
condition|)
block|{
call|(
name|urb
operator|->
name|complete
call|)
argument_list|(
name|urb
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * If the URB is not on the URB list, then check if one of 		 * the FreeBSD USB transfer are processing the current URB. 		 * If so, re-start that transfer, which will lead to the 		 * termination of that URB: 		 */
name|usb_unlink_bsd
argument_list|(
name|uhe
operator|->
name|bsd_xfer
index|[
literal|0
index|]
argument_list|,
name|urb
argument_list|,
name|drain
argument_list|)
expr_stmt|;
name|usb_unlink_bsd
argument_list|(
name|uhe
operator|->
name|bsd_xfer
index|[
literal|1
index|]
argument_list|,
name|urb
argument_list|,
name|drain
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
literal|0
expr_stmt|;
name|done
label|:
if|if
condition|(
name|drain
condition|)
name|urb
operator|->
name|kill_count
operator|--
expr_stmt|;
if|if
condition|(
name|do_unlock
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_clear_halt  *  * This function must always be used to clear the stall. Stall is when  * an USB endpoint returns a stall message to the USB host controller.  * Until the stall is cleared, no data can be transferred.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|usb_clear_halt
parameter_list|(
name|struct
name|usb_device
modifier|*
name|dev
parameter_list|,
name|struct
name|usb_host_endpoint
modifier|*
name|uhe
parameter_list|)
block|{
name|struct
name|usb_config
name|cfg
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|usb_endpoint
modifier|*
name|ep
decl_stmt|;
name|uint8_t
name|type
decl_stmt|;
name|uint8_t
name|addr
decl_stmt|;
if|if
condition|(
name|uhe
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
name|type
operator|=
name|uhe
operator|->
name|desc
operator|.
name|bmAttributes
operator|&
name|UE_XFERTYPE
expr_stmt|;
name|addr
operator|=
name|uhe
operator|->
name|desc
operator|.
name|bEndpointAddress
expr_stmt|;
name|memset
argument_list|(
name|cfg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg
argument_list|)
argument_list|)
expr_stmt|;
name|cfg
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|cfg
index|[
literal|0
index|]
operator|.
name|endpoint
operator|=
name|addr
operator|&
name|UE_ADDR
expr_stmt|;
name|cfg
index|[
literal|0
index|]
operator|.
name|direction
operator|=
name|addr
operator|&
operator|(
name|UE_DIR_OUT
operator||
name|UE_DIR_IN
operator|)
expr_stmt|;
name|ep
operator|=
name|usbd_get_endpoint
argument_list|(
name|dev
argument_list|,
name|uhe
operator|->
name|bsd_iface_index
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
name|usbd_clear_data_toggle
argument_list|(
name|dev
argument_list|,
name|ep
argument_list|)
expr_stmt|;
return|return
operator|(
name|usb_control_msg
argument_list|(
name|dev
argument_list|,
operator|&
name|dev
operator|->
name|ep0
argument_list|,
name|UR_CLEAR_FEATURE
argument_list|,
name|UT_WRITE_ENDPOINT
argument_list|,
name|UF_ENDPOINT_HALT
argument_list|,
name|addr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_start_wait_urb  *  * This is an internal function that is used to perform synchronous  * Linux USB transfers.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|usb_start_wait_urb
parameter_list|(
name|struct
name|urb
modifier|*
name|urb
parameter_list|,
name|usb_timeout_t
name|timeout
parameter_list|,
name|uint16_t
modifier|*
name|p_actlen
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|uint8_t
name|do_unlock
decl_stmt|;
comment|/* you must have a timeout! */
if|if
condition|(
name|timeout
operator|==
literal|0
condition|)
block|{
name|timeout
operator|=
literal|1
expr_stmt|;
block|}
name|urb
operator|->
name|complete
operator|=
operator|&
name|usb_linux_wait_complete
expr_stmt|;
name|urb
operator|->
name|timeout
operator|=
name|timeout
expr_stmt|;
name|urb
operator|->
name|transfer_flags
operator||=
name|URB_WAIT_WAKEUP
expr_stmt|;
name|urb
operator|->
name|transfer_flags
operator|&=
operator|~
name|URB_IS_SLEEPING
expr_stmt|;
name|do_unlock
operator|=
name|mtx_owned
argument_list|(
operator|&
name|Giant
argument_list|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|do_unlock
condition|)
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb_submit_urb
argument_list|(
name|urb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * the URB might have completed before we get here, so check that by 	 * using some flags! 	 */
while|while
condition|(
name|urb
operator|->
name|transfer_flags
operator|&
name|URB_WAIT_WAKEUP
condition|)
block|{
name|urb
operator|->
name|transfer_flags
operator||=
name|URB_IS_SLEEPING
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|urb
operator|->
name|cv_wait
argument_list|,
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|urb
operator|->
name|transfer_flags
operator|&=
operator|~
name|URB_IS_SLEEPING
expr_stmt|;
block|}
name|err
operator|=
name|urb
operator|->
name|status
expr_stmt|;
name|done
label|:
if|if
condition|(
name|do_unlock
condition|)
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_actlen
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|err
condition|)
operator|*
name|p_actlen
operator|=
literal|0
expr_stmt|;
else|else
operator|*
name|p_actlen
operator|=
name|urb
operator|->
name|actual_length
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_control_msg  *  * The following function performs a control transfer sequence one any  * control, bulk or interrupt endpoint, specified by "uhe". A control  * transfer means that you transfer an 8-byte header first followed by  * a data-phase as indicated by the 8-byte header. The "timeout" is  * given in milliseconds.  *  * Return values:  *   0: Success  *< 0: Failure  *> 0: Actual length  *------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|usb_control_msg
parameter_list|(
name|struct
name|usb_device
modifier|*
name|dev
parameter_list|,
name|struct
name|usb_host_endpoint
modifier|*
name|uhe
parameter_list|,
name|uint8_t
name|request
parameter_list|,
name|uint8_t
name|requesttype
parameter_list|,
name|uint16_t
name|value
parameter_list|,
name|uint16_t
name|index
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint16_t
name|size
parameter_list|,
name|usb_timeout_t
name|timeout
parameter_list|)
block|{
name|struct
name|usb_device_request
name|req
decl_stmt|;
name|struct
name|urb
modifier|*
name|urb
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint16_t
name|actlen
decl_stmt|;
name|uint8_t
name|type
decl_stmt|;
name|uint8_t
name|addr
decl_stmt|;
name|req
operator|.
name|bmRequestType
operator|=
name|requesttype
expr_stmt|;
name|req
operator|.
name|bRequest
operator|=
name|request
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wValue
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wIndex
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|USETW
argument_list|(
name|req
operator|.
name|wLength
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|uhe
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
block|}
name|type
operator|=
operator|(
name|uhe
operator|->
name|desc
operator|.
name|bmAttributes
operator|&
name|UE_XFERTYPE
operator|)
expr_stmt|;
name|addr
operator|=
operator|(
name|uhe
operator|->
name|desc
operator|.
name|bEndpointAddress
operator|&
name|UE_ADDR
operator|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|UE_CONTROL
condition|)
block|{
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
block|{
comment|/* 		 * The FreeBSD USB stack supports standard control 		 * transfers on control endpoint zero: 		 */
name|err
operator|=
name|usbd_do_request_flags
argument_list|(
name|dev
argument_list|,
name|NULL
argument_list|,
operator|&
name|req
argument_list|,
name|data
argument_list|,
name|USB_SHORT_XFER_OK
argument_list|,
operator|&
name|actlen
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|err
operator|=
operator|-
name|EPIPE
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|actlen
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|dev
operator|->
name|flags
operator|.
name|usb_mode
operator|!=
name|USB_MODE_HOST
condition|)
block|{
comment|/* not supported */
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
block|}
name|err
operator|=
name|usb_setup_endpoint
argument_list|(
name|dev
argument_list|,
name|uhe
argument_list|,
literal|1
comment|/* dummy */
argument_list|)
expr_stmt|;
comment|/* 	 * NOTE: we need to allocate real memory here so that we don't 	 * transfer data to/from the stack! 	 * 	 * 0xFFFF is a FreeBSD specific magic value. 	 */
name|urb
operator|=
name|usb_alloc_urb
argument_list|(
literal|0xFFFF
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|urb
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
name|urb
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|urb
operator|->
name|endpoint
operator|=
name|uhe
expr_stmt|;
name|memcpy
argument_list|(
name|urb
operator|->
name|setup_packet
argument_list|,
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|&&
operator|(
operator|!
operator|(
name|req
operator|.
name|bmRequestType
operator|&
name|UT_READ
operator|)
operator|)
condition|)
block|{
comment|/* move the data to a real buffer */
name|memcpy
argument_list|(
name|USB_ADD_BYTES
argument_list|(
name|urb
operator|->
name|setup_packet
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|usb_start_wait_urb
argument_list|(
name|urb
argument_list|,
name|timeout
argument_list|,
operator|&
name|actlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|req
operator|.
name|bmRequestType
operator|&
name|UT_READ
condition|)
block|{
if|if
condition|(
name|actlen
condition|)
block|{
name|bcopy
argument_list|(
name|USB_ADD_BYTES
argument_list|(
name|urb
operator|->
name|setup_packet
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
argument_list|,
name|data
argument_list|,
name|actlen
argument_list|)
expr_stmt|;
block|}
block|}
name|usb_free_urb
argument_list|(
name|urb
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|actlen
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_set_interface  *  * The following function will select which alternate setting of an  * USB interface you plan to use. By default alternate setting with  * index zero is selected. Note that "iface_no" is not the interface  * index, but rather the value of "bInterfaceNumber".  *------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|usb_set_interface
parameter_list|(
name|struct
name|usb_device
modifier|*
name|dev
parameter_list|,
name|uint8_t
name|iface_no
parameter_list|,
name|uint8_t
name|alt_index
parameter_list|)
block|{
name|struct
name|usb_interface
modifier|*
name|p_ui
init|=
name|usb_ifnum_to_if
argument_list|(
name|dev
argument_list|,
name|iface_no
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|p_ui
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
if|if
condition|(
name|alt_index
operator|>=
name|p_ui
operator|->
name|num_altsetting
condition|)
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
name|usb_linux_cleanup_interface
argument_list|(
name|dev
argument_list|,
name|p_ui
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|usbd_set_alt_interface_index
argument_list|(
name|dev
argument_list|,
name|p_ui
operator|->
name|bsd_iface_index
argument_list|,
name|alt_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|p_ui
operator|->
name|cur_altsetting
operator|=
name|p_ui
operator|->
name|altsetting
operator|+
name|alt_index
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_setup_endpoint  *  * The following function is an extension to the Linux USB API that  * allows you to set a maximum buffer size for a given USB endpoint.  * The maximum buffer size is per URB. If you don't call this function  * to set a maximum buffer size, the endpoint will not be functional.  * Note that for isochronous endpoints the maximum buffer size must be  * a non-zero dummy, hence this function will base the maximum buffer  * size on "wMaxPacketSize".  *------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|usb_setup_endpoint
parameter_list|(
name|struct
name|usb_device
modifier|*
name|dev
parameter_list|,
name|struct
name|usb_host_endpoint
modifier|*
name|uhe
parameter_list|,
name|usb_size_t
name|bufsize
parameter_list|)
block|{
name|struct
name|usb_config
name|cfg
index|[
literal|2
index|]
decl_stmt|;
name|uint8_t
name|type
init|=
name|uhe
operator|->
name|desc
operator|.
name|bmAttributes
operator|&
name|UE_XFERTYPE
decl_stmt|;
name|uint8_t
name|addr
init|=
name|uhe
operator|->
name|desc
operator|.
name|bEndpointAddress
decl_stmt|;
if|if
condition|(
name|uhe
operator|->
name|fbsd_buf_size
operator|==
name|bufsize
condition|)
block|{
comment|/* optimize */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|usbd_transfer_unsetup
argument_list|(
name|uhe
operator|->
name|bsd_xfer
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|uhe
operator|->
name|fbsd_buf_size
operator|=
name|bufsize
expr_stmt|;
if|if
condition|(
name|bufsize
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
name|cfg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cfg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|UE_ISOCHRONOUS
condition|)
block|{
comment|/* 		 * Isochronous transfers are special in that they don't fit 		 * into the BULK/INTR/CONTROL transfer model. 		 */
name|cfg
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|cfg
index|[
literal|0
index|]
operator|.
name|endpoint
operator|=
name|addr
operator|&
name|UE_ADDR
expr_stmt|;
name|cfg
index|[
literal|0
index|]
operator|.
name|direction
operator|=
name|addr
operator|&
operator|(
name|UE_DIR_OUT
operator||
name|UE_DIR_IN
operator|)
expr_stmt|;
name|cfg
index|[
literal|0
index|]
operator|.
name|callback
operator|=
operator|&
name|usb_linux_isoc_callback
expr_stmt|;
name|cfg
index|[
literal|0
index|]
operator|.
name|bufsize
operator|=
literal|0
expr_stmt|;
comment|/* use wMaxPacketSize */
name|cfg
index|[
literal|0
index|]
operator|.
name|frames
operator|=
name|usb_max_isoc_frames
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cfg
index|[
literal|0
index|]
operator|.
name|flags
operator|.
name|proxy_buffer
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|0
comment|/* 		 * The Linux USB API allows non back-to-back 		 * isochronous frames which we do not support. If the 		 * isochronous frames are not back-to-back we need to 		 * do a copy, and then we need a buffer for 		 * that. Enable this at your own risk. 		 */
block|cfg[0].flags.ext_buffer = 1;
endif|#
directive|endif
name|cfg
index|[
literal|0
index|]
operator|.
name|flags
operator|.
name|short_xfer_ok
operator|=
literal|1
expr_stmt|;
name|bcopy
argument_list|(
name|cfg
argument_list|,
name|cfg
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cfg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate and setup two generic FreeBSD USB transfers */
if|if
condition|(
name|usbd_transfer_setup
argument_list|(
name|dev
argument_list|,
operator|&
name|uhe
operator|->
name|bsd_iface_index
argument_list|,
name|uhe
operator|->
name|bsd_xfer
argument_list|,
name|cfg
argument_list|,
literal|2
argument_list|,
name|uhe
argument_list|,
operator|&
name|Giant
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|bufsize
operator|>
operator|(
literal|1
operator|<<
literal|22
operator|)
condition|)
block|{
comment|/* limit buffer size */
name|bufsize
operator|=
operator|(
literal|1
operator|<<
literal|22
operator|)
expr_stmt|;
block|}
comment|/* Allocate and setup one generic FreeBSD USB transfer */
name|cfg
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|cfg
index|[
literal|0
index|]
operator|.
name|endpoint
operator|=
name|addr
operator|&
name|UE_ADDR
expr_stmt|;
name|cfg
index|[
literal|0
index|]
operator|.
name|direction
operator|=
name|addr
operator|&
operator|(
name|UE_DIR_OUT
operator||
name|UE_DIR_IN
operator|)
expr_stmt|;
name|cfg
index|[
literal|0
index|]
operator|.
name|callback
operator|=
operator|&
name|usb_linux_non_isoc_callback
expr_stmt|;
name|cfg
index|[
literal|0
index|]
operator|.
name|bufsize
operator|=
name|bufsize
expr_stmt|;
name|cfg
index|[
literal|0
index|]
operator|.
name|flags
operator|.
name|ext_buffer
operator|=
literal|1
expr_stmt|;
comment|/* enable zero-copy */
name|cfg
index|[
literal|0
index|]
operator|.
name|flags
operator|.
name|proxy_buffer
operator|=
literal|1
expr_stmt|;
name|cfg
index|[
literal|0
index|]
operator|.
name|flags
operator|.
name|short_xfer_ok
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|usbd_transfer_setup
argument_list|(
name|dev
argument_list|,
operator|&
name|uhe
operator|->
name|bsd_iface_index
argument_list|,
name|uhe
operator|->
name|bsd_xfer
argument_list|,
name|cfg
argument_list|,
literal|1
argument_list|,
name|uhe
argument_list|,
operator|&
name|Giant
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_linux_create_usb_device  *  * The following function is used to build up a per USB device  * structure tree, that mimics the Linux one. The root structure  * is returned by this function.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|usb_linux_create_usb_device
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|usb_config_descriptor
modifier|*
name|cd
init|=
name|usbd_get_config_descriptor
argument_list|(
name|udev
argument_list|)
decl_stmt|;
name|struct
name|usb_descriptor
modifier|*
name|desc
decl_stmt|;
name|struct
name|usb_interface_descriptor
modifier|*
name|id
decl_stmt|;
name|struct
name|usb_endpoint_descriptor
modifier|*
name|ed
decl_stmt|;
name|struct
name|usb_interface
modifier|*
name|p_ui
init|=
name|NULL
decl_stmt|;
name|struct
name|usb_host_interface
modifier|*
name|p_uhi
init|=
name|NULL
decl_stmt|;
name|struct
name|usb_host_endpoint
modifier|*
name|p_uhe
init|=
name|NULL
decl_stmt|;
name|usb_size_t
name|size
decl_stmt|;
name|uint16_t
name|niface_total
decl_stmt|;
name|uint16_t
name|nedesc
decl_stmt|;
name|uint16_t
name|iface_no_curr
decl_stmt|;
name|uint16_t
name|iface_index
decl_stmt|;
name|uint8_t
name|pass
decl_stmt|;
name|uint8_t
name|iface_no
decl_stmt|;
comment|/* 	 * We do two passes. One pass for computing necessary memory size 	 * and one pass to initialize all the allocated memory structures. 	 */
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<
literal|2
condition|;
name|pass
operator|++
control|)
block|{
name|iface_no_curr
operator|=
literal|0xFFFF
expr_stmt|;
name|niface_total
operator|=
literal|0
expr_stmt|;
name|iface_index
operator|=
literal|0
expr_stmt|;
name|nedesc
operator|=
literal|0
expr_stmt|;
name|desc
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Iterate over all the USB descriptors. Use the USB config 		 * descriptor pointer provided by the FreeBSD USB stack. 		 */
while|while
condition|(
operator|(
name|desc
operator|=
name|usb_desc_foreach
argument_list|(
name|cd
argument_list|,
name|desc
argument_list|)
operator|)
condition|)
block|{
comment|/* 			 * Build up a tree according to the descriptors we 			 * find: 			 */
switch|switch
condition|(
name|desc
operator|->
name|bDescriptorType
condition|)
block|{
case|case
name|UDESC_DEVICE
case|:
break|break;
case|case
name|UDESC_ENDPOINT
case|:
name|ed
operator|=
operator|(
name|void
operator|*
operator|)
name|desc
expr_stmt|;
if|if
condition|(
operator|(
name|ed
operator|->
name|bLength
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ed
argument_list|)
operator|)
operator|||
operator|(
name|iface_index
operator|==
literal|0
operator|)
condition|)
break|break;
if|if
condition|(
name|p_uhe
condition|)
block|{
name|bcopy
argument_list|(
name|ed
argument_list|,
operator|&
name|p_uhe
operator|->
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|p_uhe
operator|->
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|p_uhe
operator|->
name|bsd_iface_index
operator|=
name|iface_index
operator|-
literal|1
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|p_uhe
operator|->
name|bsd_urb_list
argument_list|)
expr_stmt|;
name|p_uhe
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p_uhi
condition|)
block|{
operator|(
name|p_uhi
operator|-
literal|1
operator|)
operator|->
name|desc
operator|.
name|bNumEndpoints
operator|++
expr_stmt|;
block|}
name|nedesc
operator|++
expr_stmt|;
break|break;
case|case
name|UDESC_INTERFACE
case|:
name|id
operator|=
operator|(
name|void
operator|*
operator|)
name|desc
expr_stmt|;
if|if
condition|(
name|id
operator|->
name|bLength
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
condition|)
break|break;
if|if
condition|(
name|p_uhi
condition|)
block|{
name|bcopy
argument_list|(
name|id
argument_list|,
operator|&
name|p_uhi
operator|->
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|p_uhi
operator|->
name|desc
argument_list|)
argument_list|)
expr_stmt|;
name|p_uhi
operator|->
name|desc
operator|.
name|bNumEndpoints
operator|=
literal|0
expr_stmt|;
name|p_uhi
operator|->
name|endpoint
operator|=
name|p_uhe
expr_stmt|;
name|p_uhi
operator|->
name|string
operator|=
literal|""
expr_stmt|;
name|p_uhi
operator|->
name|bsd_iface_index
operator|=
name|iface_index
expr_stmt|;
name|p_uhi
operator|++
expr_stmt|;
block|}
name|iface_no
operator|=
name|id
operator|->
name|bInterfaceNumber
expr_stmt|;
name|niface_total
operator|++
expr_stmt|;
if|if
condition|(
name|iface_no_curr
operator|!=
name|iface_no
condition|)
block|{
if|if
condition|(
name|p_ui
condition|)
block|{
name|p_ui
operator|->
name|altsetting
operator|=
name|p_uhi
operator|-
literal|1
expr_stmt|;
name|p_ui
operator|->
name|cur_altsetting
operator|=
name|p_uhi
operator|-
literal|1
expr_stmt|;
name|p_ui
operator|->
name|num_altsetting
operator|=
literal|1
expr_stmt|;
name|p_ui
operator|->
name|bsd_iface_index
operator|=
name|iface_index
expr_stmt|;
name|p_ui
operator|->
name|linux_udev
operator|=
name|udev
expr_stmt|;
name|p_ui
operator|++
expr_stmt|;
block|}
name|iface_no_curr
operator|=
name|iface_no
expr_stmt|;
name|iface_index
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|p_ui
condition|)
block|{
operator|(
name|p_ui
operator|-
literal|1
operator|)
operator|->
name|num_altsetting
operator|++
expr_stmt|;
block|}
block|}
break|break;
default|default:
break|break;
block|}
block|}
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
block|{
name|size
operator|=
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|p_uhe
argument_list|)
operator|*
name|nedesc
operator|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|p_ui
argument_list|)
operator|*
name|iface_index
operator|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|p_uhi
argument_list|)
operator|*
name|niface_total
operator|)
expr_stmt|;
name|p_uhe
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_USBDEV
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|p_ui
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|p_uhe
operator|+
name|nedesc
operator|)
expr_stmt|;
name|p_uhi
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|p_ui
operator|+
name|iface_index
operator|)
expr_stmt|;
name|udev
operator|->
name|linux_iface_start
operator|=
name|p_ui
expr_stmt|;
name|udev
operator|->
name|linux_iface_end
operator|=
name|p_ui
operator|+
name|iface_index
expr_stmt|;
name|udev
operator|->
name|linux_endpoint_start
operator|=
name|p_uhe
expr_stmt|;
name|udev
operator|->
name|linux_endpoint_end
operator|=
name|p_uhe
operator|+
name|nedesc
expr_stmt|;
name|udev
operator|->
name|devnum
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|udev
operator|->
name|ddesc
argument_list|,
operator|&
name|udev
operator|->
name|descriptor
argument_list|,
sizeof|sizeof
argument_list|(
name|udev
operator|->
name|descriptor
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|udev
operator|->
name|ctrl_ep
operator|.
name|edesc
argument_list|,
operator|&
name|udev
operator|->
name|ep0
operator|.
name|desc
argument_list|,
sizeof|sizeof
argument_list|(
name|udev
operator|->
name|ep0
operator|.
name|desc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_alloc_urb  *  * This function should always be used when you allocate an URB for  * use with the USB Linux stack. In case of an isochronous transfer  * you must specifiy the maximum number of "iso_packets" which you  * plan to transfer per URB. This function is always blocking, and  * "mem_flags" are not regarded like on Linux.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|struct
name|urb
modifier|*
name|usb_alloc_urb
parameter_list|(
name|uint16_t
name|iso_packets
parameter_list|,
name|uint16_t
name|mem_flags
parameter_list|)
block|{
name|struct
name|urb
modifier|*
name|urb
decl_stmt|;
name|usb_size_t
name|size
decl_stmt|;
if|if
condition|(
name|iso_packets
operator|==
literal|0xFFFF
condition|)
block|{
comment|/* 		 * FreeBSD specific magic value to ask for control transfer 		 * memory allocation: 		 */
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|urb
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_request
argument_list|)
operator|+
name|mem_flags
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|urb
argument_list|)
operator|+
operator|(
name|iso_packets
operator|*
sizeof|sizeof
argument_list|(
name|urb
operator|->
name|iso_frame_desc
index|[
literal|0
index|]
argument_list|)
operator|)
expr_stmt|;
block|}
name|urb
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_USBDEV
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|urb
condition|)
block|{
name|cv_init
argument_list|(
operator|&
name|urb
operator|->
name|cv_wait
argument_list|,
literal|"URBWAIT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso_packets
operator|==
literal|0xFFFF
condition|)
block|{
name|urb
operator|->
name|setup_packet
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|urb
operator|+
literal|1
operator|)
expr_stmt|;
name|urb
operator|->
name|transfer_buffer
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|urb
operator|->
name|setup_packet
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|usb_device_request
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|urb
operator|->
name|number_of_packets
operator|=
name|iso_packets
expr_stmt|;
block|}
block|}
return|return
operator|(
name|urb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_find_host_endpoint  *  * The following function will return the Linux USB host endpoint  * structure that matches the given endpoint type and endpoint  * value. If no match is found, NULL is returned. This function is not  * part of the Linux USB API and is only used internally.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|struct
name|usb_host_endpoint
modifier|*
name|usb_find_host_endpoint
parameter_list|(
name|struct
name|usb_device
modifier|*
name|dev
parameter_list|,
name|uint8_t
name|type
parameter_list|,
name|uint8_t
name|ep
parameter_list|)
block|{
name|struct
name|usb_host_endpoint
modifier|*
name|uhe
decl_stmt|;
name|struct
name|usb_host_endpoint
modifier|*
name|uhe_end
decl_stmt|;
name|struct
name|usb_host_interface
modifier|*
name|uhi
decl_stmt|;
name|struct
name|usb_interface
modifier|*
name|ui
decl_stmt|;
name|uint8_t
name|ea
decl_stmt|;
name|uint8_t
name|at
decl_stmt|;
name|uint8_t
name|mask
decl_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|==
name|UE_CONTROL
condition|)
block|{
name|mask
operator|=
name|UE_ADDR
expr_stmt|;
block|}
else|else
block|{
name|mask
operator|=
operator|(
name|UE_DIR_IN
operator||
name|UE_DIR_OUT
operator||
name|UE_ADDR
operator|)
expr_stmt|;
block|}
name|ep
operator|&=
name|mask
expr_stmt|;
comment|/* 	 * Iterate over all the interfaces searching the selected alternate 	 * setting only, and all belonging endpoints. 	 */
for|for
control|(
name|ui
operator|=
name|dev
operator|->
name|linux_iface_start
init|;
name|ui
operator|!=
name|dev
operator|->
name|linux_iface_end
condition|;
name|ui
operator|++
control|)
block|{
name|uhi
operator|=
name|ui
operator|->
name|cur_altsetting
expr_stmt|;
if|if
condition|(
name|uhi
condition|)
block|{
name|uhe_end
operator|=
name|uhi
operator|->
name|endpoint
operator|+
name|uhi
operator|->
name|desc
operator|.
name|bNumEndpoints
expr_stmt|;
for|for
control|(
name|uhe
operator|=
name|uhi
operator|->
name|endpoint
init|;
name|uhe
operator|!=
name|uhe_end
condition|;
name|uhe
operator|++
control|)
block|{
name|ea
operator|=
name|uhe
operator|->
name|desc
operator|.
name|bEndpointAddress
expr_stmt|;
name|at
operator|=
name|uhe
operator|->
name|desc
operator|.
name|bmAttributes
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ea
operator|&
name|mask
operator|)
operator|==
name|ep
operator|)
operator|&&
operator|(
operator|(
name|at
operator|&
name|UE_XFERTYPE
operator|)
operator|==
name|type
operator|)
condition|)
block|{
return|return
operator|(
name|uhe
operator|)
return|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|(
name|type
operator|==
name|UE_CONTROL
operator|)
operator|&&
operator|(
operator|(
name|ep
operator|&
name|UE_ADDR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
operator|&
name|dev
operator|->
name|ep0
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_altnum_to_altsetting  *  * The following function returns a pointer to an alternate setting by  * index given a "usb_interface" pointer. If the alternate setting by  * index does not exist, NULL is returned. And alternate setting is a  * variant of an interface, but usually with slightly different  * characteristics.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|struct
name|usb_host_interface
modifier|*
name|usb_altnum_to_altsetting
parameter_list|(
specifier|const
name|struct
name|usb_interface
modifier|*
name|intf
parameter_list|,
name|uint8_t
name|alt_index
parameter_list|)
block|{
if|if
condition|(
name|alt_index
operator|>=
name|intf
operator|->
name|num_altsetting
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|intf
operator|->
name|altsetting
operator|+
name|alt_index
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_ifnum_to_if  *  * The following function searches up an USB interface by  * "bInterfaceNumber". If no match is found, NULL is returned.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|struct
name|usb_interface
modifier|*
name|usb_ifnum_to_if
parameter_list|(
name|struct
name|usb_device
modifier|*
name|dev
parameter_list|,
name|uint8_t
name|iface_no
parameter_list|)
block|{
name|struct
name|usb_interface
modifier|*
name|p_ui
decl_stmt|;
for|for
control|(
name|p_ui
operator|=
name|dev
operator|->
name|linux_iface_start
init|;
name|p_ui
operator|!=
name|dev
operator|->
name|linux_iface_end
condition|;
name|p_ui
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|p_ui
operator|->
name|num_altsetting
operator|>
literal|0
operator|)
operator|&&
operator|(
name|p_ui
operator|->
name|altsetting
operator|->
name|desc
operator|.
name|bInterfaceNumber
operator|==
name|iface_no
operator|)
condition|)
block|{
return|return
operator|(
name|p_ui
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_buffer_alloc  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
modifier|*
name|usb_buffer_alloc
parameter_list|(
name|struct
name|usb_device
modifier|*
name|dev
parameter_list|,
name|usb_size_t
name|size
parameter_list|,
name|uint16_t
name|mem_flags
parameter_list|,
name|uint8_t
modifier|*
name|dma_addr
parameter_list|)
block|{
return|return
operator|(
name|malloc
argument_list|(
name|size
argument_list|,
name|M_USBDEV
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usbd_get_intfdata  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
modifier|*
name|usbd_get_intfdata
parameter_list|(
name|struct
name|usb_interface
modifier|*
name|intf
parameter_list|)
block|{
return|return
operator|(
name|intf
operator|->
name|bsd_priv_sc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_linux_register  *  * The following function is used by the "USB_DRIVER_EXPORT()" macro,  * and is used to register a Linux USB driver, so that its  * "usb_device_id" structures gets searched a probe time. This  * function is not part of the Linux USB API, and is for internal use  * only.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_linux_register
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|usb_driver
modifier|*
name|drv
init|=
name|arg
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|usb_linux_driver_list
argument_list|,
name|drv
argument_list|,
name|linux_driver_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|usb_needs_explore_all
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_linux_deregister  *  * The following function is used by the "USB_DRIVER_EXPORT()" macro,  * and is used to deregister a Linux USB driver. This function will  * ensure that all driver instances belonging to the Linux USB device  * driver in question, gets detached before the driver is  * unloaded. This function is not part of the Linux USB API, and is  * for internal use only.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_linux_deregister
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|usb_driver
modifier|*
name|drv
init|=
name|arg
decl_stmt|;
name|struct
name|usb_linux_softc
modifier|*
name|sc
decl_stmt|;
name|repeat
label|:
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sc
argument_list|,
argument|&usb_linux_attached_list
argument_list|,
argument|sc_attached_list
argument_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_udrv
operator|==
name|drv
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|device_detach
argument_list|(
name|sc
operator|->
name|sc_fbsd_dev
argument_list|)
expr_stmt|;
goto|goto
name|repeat
goto|;
block|}
block|}
name|LIST_REMOVE
argument_list|(
name|drv
argument_list|,
name|linux_driver_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_linux_free_device  *  * The following function is only used by the FreeBSD USB stack, to  * cleanup and free memory after that a Linux USB device was attached.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_linux_free_device
parameter_list|(
name|struct
name|usb_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|usb_host_endpoint
modifier|*
name|uhe
decl_stmt|;
name|struct
name|usb_host_endpoint
modifier|*
name|uhe_end
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uhe
operator|=
name|dev
operator|->
name|linux_endpoint_start
expr_stmt|;
name|uhe_end
operator|=
name|dev
operator|->
name|linux_endpoint_end
expr_stmt|;
while|while
condition|(
name|uhe
operator|!=
name|uhe_end
condition|)
block|{
name|err
operator|=
name|usb_setup_endpoint
argument_list|(
name|dev
argument_list|,
name|uhe
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uhe
operator|++
expr_stmt|;
block|}
name|err
operator|=
name|usb_setup_endpoint
argument_list|(
name|dev
argument_list|,
operator|&
name|dev
operator|->
name|ep0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dev
operator|->
name|linux_endpoint_start
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_buffer_free  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_buffer_free
parameter_list|(
name|struct
name|usb_device
modifier|*
name|dev
parameter_list|,
name|usb_size_t
name|size
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|uint8_t
name|dma_addr
parameter_list|)
block|{
name|free
argument_list|(
name|addr
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_free_urb  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_free_urb
parameter_list|(
name|struct
name|urb
modifier|*
name|urb
parameter_list|)
block|{
if|if
condition|(
name|urb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
comment|/* make sure that the current URB is not active */
name|usb_kill_urb
argument_list|(
name|urb
argument_list|)
expr_stmt|;
comment|/* destroy condition variable */
name|cv_destroy
argument_list|(
operator|&
name|urb
operator|->
name|cv_wait
argument_list|)
expr_stmt|;
comment|/* just free it */
name|free
argument_list|(
name|urb
argument_list|,
name|M_USBDEV
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_init_urb  *  * The following function can be used to initialize a custom URB. It  * is not recommended to use this function. Use "usb_alloc_urb()"  * instead.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_init_urb
parameter_list|(
name|struct
name|urb
modifier|*
name|urb
parameter_list|)
block|{
if|if
condition|(
name|urb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|memset
argument_list|(
name|urb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|urb
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_kill_urb  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_kill_urb
parameter_list|(
name|struct
name|urb
modifier|*
name|urb
parameter_list|)
block|{
name|usb_unlink_urb_sub
argument_list|(
name|urb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_set_intfdata  *  * The following function sets the per Linux USB interface private  * data pointer. It is used by most Linux USB device drivers.  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_set_intfdata
parameter_list|(
name|struct
name|usb_interface
modifier|*
name|intf
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|intf
operator|->
name|bsd_priv_sc
operator|=
name|data
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_linux_cleanup_interface  *  * The following function will release all FreeBSD USB transfers  * associated with a Linux USB interface. It is for internal use only.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_linux_cleanup_interface
parameter_list|(
name|struct
name|usb_device
modifier|*
name|dev
parameter_list|,
name|struct
name|usb_interface
modifier|*
name|iface
parameter_list|)
block|{
name|struct
name|usb_host_interface
modifier|*
name|uhi
decl_stmt|;
name|struct
name|usb_host_interface
modifier|*
name|uhi_end
decl_stmt|;
name|struct
name|usb_host_endpoint
modifier|*
name|uhe
decl_stmt|;
name|struct
name|usb_host_endpoint
modifier|*
name|uhe_end
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uhi
operator|=
name|iface
operator|->
name|altsetting
expr_stmt|;
name|uhi_end
operator|=
name|iface
operator|->
name|altsetting
operator|+
name|iface
operator|->
name|num_altsetting
expr_stmt|;
while|while
condition|(
name|uhi
operator|!=
name|uhi_end
condition|)
block|{
name|uhe
operator|=
name|uhi
operator|->
name|endpoint
expr_stmt|;
name|uhe_end
operator|=
name|uhi
operator|->
name|endpoint
operator|+
name|uhi
operator|->
name|desc
operator|.
name|bNumEndpoints
expr_stmt|;
while|while
condition|(
name|uhe
operator|!=
name|uhe_end
condition|)
block|{
name|err
operator|=
name|usb_setup_endpoint
argument_list|(
name|dev
argument_list|,
name|uhe
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uhe
operator|++
expr_stmt|;
block|}
name|uhi
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_linux_wait_complete  *  * The following function is used by "usb_start_wait_urb()" to wake it  * up, when an USB transfer has finished.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_linux_wait_complete
parameter_list|(
name|struct
name|urb
modifier|*
name|urb
parameter_list|)
block|{
if|if
condition|(
name|urb
operator|->
name|transfer_flags
operator|&
name|URB_IS_SLEEPING
condition|)
block|{
name|cv_signal
argument_list|(
operator|&
name|urb
operator|->
name|cv_wait
argument_list|)
expr_stmt|;
block|}
name|urb
operator|->
name|transfer_flags
operator|&=
operator|~
name|URB_WAIT_WAKEUP
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_linux_complete  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_linux_complete
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|)
block|{
name|struct
name|urb
modifier|*
name|urb
decl_stmt|;
name|urb
operator|=
name|usbd_xfer_get_priv
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
name|usbd_xfer_set_priv
argument_list|(
name|xfer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|urb
operator|->
name|complete
condition|)
block|{
call|(
name|urb
operator|->
name|complete
call|)
argument_list|(
name|urb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_linux_isoc_callback  *  * The following is the FreeBSD isochronous USB callback. Isochronous  * frames are USB packets transferred 1000 or 8000 times per second,  * depending on whether a full- or high- speed USB transfer is  * used.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_linux_isoc_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
name|usb_frlength_t
name|max_frame
init|=
name|xfer
operator|->
name|max_frame_size
decl_stmt|;
name|usb_frlength_t
name|offset
decl_stmt|;
name|usb_frcount_t
name|x
decl_stmt|;
name|struct
name|urb
modifier|*
name|urb
init|=
name|usbd_xfer_get_priv
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|usb_host_endpoint
modifier|*
name|uhe
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|usb_iso_packet_descriptor
modifier|*
name|uipd
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
if|if
condition|(
name|urb
operator|->
name|bsd_isread
condition|)
block|{
comment|/* copy in data with regard to the URB */
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|urb
operator|->
name|number_of_packets
condition|;
name|x
operator|++
control|)
block|{
name|uipd
operator|=
name|urb
operator|->
name|iso_frame_desc
operator|+
name|x
expr_stmt|;
if|if
condition|(
name|uipd
operator|->
name|length
operator|>
name|xfer
operator|->
name|frlengths
index|[
name|x
index|]
condition|)
block|{
if|if
condition|(
name|urb
operator|->
name|transfer_flags
operator|&
name|URB_SHORT_NOT_OK
condition|)
block|{
comment|/* XXX should be EREMOTEIO */
name|uipd
operator|->
name|status
operator|=
operator|-
name|EPIPE
expr_stmt|;
block|}
else|else
block|{
name|uipd
operator|->
name|status
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|uipd
operator|->
name|status
operator|=
literal|0
expr_stmt|;
block|}
name|uipd
operator|->
name|actual_length
operator|=
name|xfer
operator|->
name|frlengths
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|xfer
operator|->
name|flags
operator|.
name|ext_buffer
condition|)
block|{
name|usbd_copy_out
argument_list|(
name|xfer
operator|->
name|frbuffers
argument_list|,
name|offset
argument_list|,
name|USB_ADD_BYTES
argument_list|(
name|urb
operator|->
name|transfer_buffer
argument_list|,
name|uipd
operator|->
name|offset
argument_list|)
argument_list|,
name|uipd
operator|->
name|actual_length
argument_list|)
expr_stmt|;
block|}
name|offset
operator|+=
name|max_frame
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|urb
operator|->
name|number_of_packets
condition|;
name|x
operator|++
control|)
block|{
name|uipd
operator|=
name|urb
operator|->
name|iso_frame_desc
operator|+
name|x
expr_stmt|;
name|uipd
operator|->
name|actual_length
operator|=
name|xfer
operator|->
name|frlengths
index|[
name|x
index|]
expr_stmt|;
name|uipd
operator|->
name|status
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|urb
operator|->
name|actual_length
operator|=
name|xfer
operator|->
name|actlen
expr_stmt|;
comment|/* check for short transfer */
if|if
condition|(
name|xfer
operator|->
name|actlen
operator|<
name|xfer
operator|->
name|sumlen
condition|)
block|{
comment|/* short transfer */
if|if
condition|(
name|urb
operator|->
name|transfer_flags
operator|&
name|URB_SHORT_NOT_OK
condition|)
block|{
comment|/* XXX should be EREMOTEIO */
name|urb
operator|->
name|status
operator|=
operator|-
name|EPIPE
expr_stmt|;
block|}
else|else
block|{
name|urb
operator|->
name|status
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* success */
name|urb
operator|->
name|status
operator|=
literal|0
expr_stmt|;
block|}
comment|/* call callback */
name|usb_linux_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
if|if
condition|(
name|xfer
operator|->
name|priv_fifo
operator|==
name|NULL
condition|)
block|{
comment|/* get next transfer */
name|urb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|uhe
operator|->
name|bsd_urb_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|urb
operator|==
name|NULL
condition|)
block|{
comment|/* nothing to do */
return|return;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|uhe
operator|->
name|bsd_urb_list
argument_list|,
name|urb
argument_list|,
name|bsd_urb_list
argument_list|)
expr_stmt|;
name|urb
operator|->
name|bsd_urb_list
operator|.
name|tqe_prev
operator|=
name|NULL
expr_stmt|;
name|x
operator|=
name|xfer
operator|->
name|max_frame_count
expr_stmt|;
if|if
condition|(
name|urb
operator|->
name|number_of_packets
operator|>
name|x
condition|)
block|{
comment|/* XXX simply truncate the transfer */
name|urb
operator|->
name|number_of_packets
operator|=
name|x
expr_stmt|;
block|}
block|}
else|else
block|{
name|DPRINTF
argument_list|(
literal|"Already got a transfer\n"
argument_list|)
expr_stmt|;
comment|/* already got a transfer (should not happen) */
name|urb
operator|=
name|usbd_xfer_get_priv
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
block|}
name|urb
operator|->
name|bsd_isread
operator|=
operator|(
name|uhe
operator|->
name|desc
operator|.
name|bEndpointAddress
operator|&
name|UE_DIR_IN
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags
operator|.
name|ext_buffer
condition|)
block|{
comment|/* set virtual address to load */
name|usbd_xfer_set_frame_data
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|urb
operator|->
name|transfer_buffer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|urb
operator|->
name|bsd_isread
operator|)
condition|)
block|{
comment|/* copy out data with regard to the URB */
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|urb
operator|->
name|number_of_packets
condition|;
name|x
operator|++
control|)
block|{
name|uipd
operator|=
name|urb
operator|->
name|iso_frame_desc
operator|+
name|x
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
name|x
argument_list|,
name|uipd
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xfer
operator|->
name|flags
operator|.
name|ext_buffer
condition|)
block|{
name|usbd_copy_in
argument_list|(
name|xfer
operator|->
name|frbuffers
argument_list|,
name|offset
argument_list|,
name|USB_ADD_BYTES
argument_list|(
name|urb
operator|->
name|transfer_buffer
argument_list|,
name|uipd
operator|->
name|offset
argument_list|)
argument_list|,
name|uipd
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
name|offset
operator|+=
name|uipd
operator|->
name|length
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * compute the transfer length into the "offset" 			 * variable 			 */
name|offset
operator|=
name|urb
operator|->
name|number_of_packets
operator|*
name|max_frame
expr_stmt|;
comment|/* setup "frlengths" array */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|urb
operator|->
name|number_of_packets
condition|;
name|x
operator|++
control|)
block|{
name|uipd
operator|=
name|urb
operator|->
name|iso_frame_desc
operator|+
name|x
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
name|x
argument_list|,
name|max_frame
argument_list|)
expr_stmt|;
block|}
block|}
name|usbd_xfer_set_priv
argument_list|(
name|xfer
argument_list|,
name|urb
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|flags
operator|.
name|force_short_xfer
operator|=
literal|0
expr_stmt|;
name|xfer
operator|->
name|timeout
operator|=
name|urb
operator|->
name|timeout
expr_stmt|;
name|xfer
operator|->
name|nframes
operator|=
name|urb
operator|->
name|number_of_packets
expr_stmt|;
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return;
default|default:
comment|/* Error */
if|if
condition|(
name|xfer
operator|->
name|error
operator|==
name|USB_ERR_CANCELLED
condition|)
block|{
name|urb
operator|->
name|status
operator|=
operator|-
name|ECONNRESET
expr_stmt|;
block|}
else|else
block|{
name|urb
operator|->
name|status
operator|=
operator|-
name|EPIPE
expr_stmt|;
comment|/* stalled */
block|}
comment|/* Set zero for "actual_length" */
name|urb
operator|->
name|actual_length
operator|=
literal|0
expr_stmt|;
comment|/* Set zero for "actual_length" */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|urb
operator|->
name|number_of_packets
condition|;
name|x
operator|++
control|)
block|{
name|urb
operator|->
name|iso_frame_desc
index|[
name|x
index|]
operator|.
name|actual_length
operator|=
literal|0
expr_stmt|;
name|urb
operator|->
name|iso_frame_desc
index|[
name|x
index|]
operator|.
name|status
operator|=
name|urb
operator|->
name|status
expr_stmt|;
block|}
comment|/* call callback */
name|usb_linux_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|error
operator|==
name|USB_ERR_CANCELLED
condition|)
block|{
comment|/* we need to return in this case */
return|return;
block|}
goto|goto
name|tr_setup
goto|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_linux_non_isoc_callback  *  * The following is the FreeBSD BULK/INTERRUPT and CONTROL USB  * callback. It dequeues Linux USB stack compatible URB's, transforms  * the URB fields into a FreeBSD USB transfer, and defragments the USB  * transfer as required. When the transfer is complete the "complete"  * callback is called.  *------------------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|void
name|usb_linux_non_isoc_callback
parameter_list|(
name|struct
name|usb_xfer
modifier|*
name|xfer
parameter_list|,
name|usb_error_t
name|error
parameter_list|)
block|{
enum|enum
block|{
name|REQ_SIZE
init|=
expr|sizeof
operator|(
expr|struct
name|usb_device_request
operator|)
block|}
enum|;
name|struct
name|urb
modifier|*
name|urb
init|=
name|usbd_xfer_get_priv
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|struct
name|usb_host_endpoint
modifier|*
name|uhe
init|=
name|usbd_xfer_softc
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|uint8_t
modifier|*
name|ptr
decl_stmt|;
name|usb_frlength_t
name|max_bulk
init|=
name|usbd_xfer_max_len
argument_list|(
name|xfer
argument_list|)
decl_stmt|;
name|uint8_t
name|data_frame
init|=
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|USB_GET_STATE
argument_list|(
name|xfer
argument_list|)
condition|)
block|{
case|case
name|USB_ST_TRANSFERRED
case|:
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
comment|/* don't transfer the setup packet again: */
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|urb
operator|->
name|bsd_isread
operator|&&
operator|(
operator|!
name|xfer
operator|->
name|flags
operator|.
name|ext_buffer
operator|)
condition|)
block|{
comment|/* copy in data with regard to the URB */
name|usbd_copy_out
argument_list|(
name|xfer
operator|->
name|frbuffers
operator|+
name|data_frame
argument_list|,
literal|0
argument_list|,
name|urb
operator|->
name|bsd_data_ptr
argument_list|,
name|xfer
operator|->
name|frlengths
index|[
name|data_frame
index|]
argument_list|)
expr_stmt|;
block|}
name|urb
operator|->
name|bsd_length_rem
operator|-=
name|xfer
operator|->
name|frlengths
index|[
name|data_frame
index|]
expr_stmt|;
name|urb
operator|->
name|bsd_data_ptr
operator|+=
name|xfer
operator|->
name|frlengths
index|[
name|data_frame
index|]
expr_stmt|;
name|urb
operator|->
name|actual_length
operator|+=
name|xfer
operator|->
name|frlengths
index|[
name|data_frame
index|]
expr_stmt|;
comment|/* check for short transfer */
if|if
condition|(
name|xfer
operator|->
name|actlen
operator|<
name|xfer
operator|->
name|sumlen
condition|)
block|{
name|urb
operator|->
name|bsd_length_rem
operator|=
literal|0
expr_stmt|;
comment|/* short transfer */
if|if
condition|(
name|urb
operator|->
name|transfer_flags
operator|&
name|URB_SHORT_NOT_OK
condition|)
block|{
name|urb
operator|->
name|status
operator|=
operator|-
name|EPIPE
expr_stmt|;
block|}
else|else
block|{
name|urb
operator|->
name|status
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* check remainder */
if|if
condition|(
name|urb
operator|->
name|bsd_length_rem
operator|>
literal|0
condition|)
block|{
goto|goto
name|setup_bulk
goto|;
block|}
comment|/* success */
name|urb
operator|->
name|status
operator|=
literal|0
expr_stmt|;
block|}
comment|/* call callback */
name|usb_linux_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
case|case
name|USB_ST_SETUP
case|:
name|tr_setup
label|:
comment|/* get next transfer */
name|urb
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|uhe
operator|->
name|bsd_urb_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|urb
operator|==
name|NULL
condition|)
block|{
comment|/* nothing to do */
return|return;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|uhe
operator|->
name|bsd_urb_list
argument_list|,
name|urb
argument_list|,
name|bsd_urb_list
argument_list|)
expr_stmt|;
name|urb
operator|->
name|bsd_urb_list
operator|.
name|tqe_prev
operator|=
name|NULL
expr_stmt|;
name|usbd_xfer_set_priv
argument_list|(
name|xfer
argument_list|,
name|urb
argument_list|)
expr_stmt|;
name|xfer
operator|->
name|flags
operator|.
name|force_short_xfer
operator|=
literal|0
expr_stmt|;
name|xfer
operator|->
name|timeout
operator|=
name|urb
operator|->
name|timeout
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
comment|/* 		         * USB control transfers need special handling. 		         * First copy in the header, then copy in data! 		         */
if|if
condition|(
operator|!
name|xfer
operator|->
name|flags
operator|.
name|ext_buffer
condition|)
block|{
name|usbd_copy_in
argument_list|(
name|xfer
operator|->
name|frbuffers
argument_list|,
literal|0
argument_list|,
name|urb
operator|->
name|setup_packet
argument_list|,
name|REQ_SIZE
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|REQ_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* set virtual address to load */
name|usbd_xfer_set_frame_data
argument_list|(
name|xfer
argument_list|,
literal|0
argument_list|,
name|urb
operator|->
name|setup_packet
argument_list|,
name|REQ_SIZE
argument_list|)
expr_stmt|;
block|}
name|ptr
operator|=
name|urb
operator|->
name|setup_packet
expr_stmt|;
comment|/* setup data transfer direction and length */
name|urb
operator|->
name|bsd_isread
operator|=
operator|(
name|ptr
index|[
literal|0
index|]
operator|&
name|UT_READ
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|urb
operator|->
name|bsd_length_rem
operator|=
name|ptr
index|[
literal|6
index|]
operator||
operator|(
name|ptr
index|[
literal|7
index|]
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* setup data transfer direction */
name|urb
operator|->
name|bsd_length_rem
operator|=
name|urb
operator|->
name|transfer_buffer_length
expr_stmt|;
name|urb
operator|->
name|bsd_isread
operator|=
operator|(
name|uhe
operator|->
name|desc
operator|.
name|bEndpointAddress
operator|&
name|UE_DIR_IN
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
name|urb
operator|->
name|bsd_data_ptr
operator|=
name|urb
operator|->
name|transfer_buffer
expr_stmt|;
name|urb
operator|->
name|actual_length
operator|=
literal|0
expr_stmt|;
name|setup_bulk
label|:
if|if
condition|(
name|max_bulk
operator|>
name|urb
operator|->
name|bsd_length_rem
condition|)
block|{
name|max_bulk
operator|=
name|urb
operator|->
name|bsd_length_rem
expr_stmt|;
block|}
comment|/* check if we need to force a short transfer */
if|if
condition|(
operator|(
name|max_bulk
operator|==
name|urb
operator|->
name|bsd_length_rem
operator|)
operator|&&
operator|(
name|urb
operator|->
name|transfer_flags
operator|&
name|URB_ZERO_PACKET
operator|)
operator|&&
operator|(
operator|!
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
operator|)
condition|)
block|{
name|xfer
operator|->
name|flags
operator|.
name|force_short_xfer
operator|=
literal|1
expr_stmt|;
block|}
comment|/* check if we need to copy in data */
if|if
condition|(
name|xfer
operator|->
name|flags
operator|.
name|ext_buffer
condition|)
block|{
comment|/* set virtual address to load */
name|usbd_xfer_set_frame_data
argument_list|(
name|xfer
argument_list|,
name|data_frame
argument_list|,
name|urb
operator|->
name|bsd_data_ptr
argument_list|,
name|max_bulk
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|urb
operator|->
name|bsd_isread
condition|)
block|{
comment|/* copy out data with regard to the URB */
name|usbd_copy_in
argument_list|(
name|xfer
operator|->
name|frbuffers
operator|+
name|data_frame
argument_list|,
literal|0
argument_list|,
name|urb
operator|->
name|bsd_data_ptr
argument_list|,
name|max_bulk
argument_list|)
expr_stmt|;
name|usbd_xfer_set_frame_len
argument_list|(
name|xfer
argument_list|,
name|data_frame
argument_list|,
name|max_bulk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xfer
operator|->
name|flags_int
operator|.
name|control_xfr
condition|)
block|{
if|if
condition|(
name|max_bulk
operator|>
literal|0
condition|)
block|{
name|xfer
operator|->
name|nframes
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|xfer
operator|->
name|nframes
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|xfer
operator|->
name|nframes
operator|=
literal|1
expr_stmt|;
block|}
name|usbd_transfer_submit
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
return|return;
default|default:
if|if
condition|(
name|xfer
operator|->
name|error
operator|==
name|USB_ERR_CANCELLED
condition|)
block|{
name|urb
operator|->
name|status
operator|=
operator|-
name|ECONNRESET
expr_stmt|;
block|}
else|else
block|{
name|urb
operator|->
name|status
operator|=
operator|-
name|EPIPE
expr_stmt|;
block|}
comment|/* Set zero for "actual_length" */
name|urb
operator|->
name|actual_length
operator|=
literal|0
expr_stmt|;
comment|/* call callback */
name|usb_linux_complete
argument_list|(
name|xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|xfer
operator|->
name|error
operator|==
name|USB_ERR_CANCELLED
condition|)
block|{
comment|/* we need to return in this case */
return|return;
block|}
goto|goto
name|tr_setup
goto|;
block|}
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_fill_bulk_urb  *------------------------------------------------------------------------*/
end_comment

begin_function
name|void
name|usb_fill_bulk_urb
parameter_list|(
name|struct
name|urb
modifier|*
name|urb
parameter_list|,
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_host_endpoint
modifier|*
name|uhe
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|length
parameter_list|,
name|usb_complete_t
name|callback
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|urb
operator|->
name|dev
operator|=
name|udev
expr_stmt|;
name|urb
operator|->
name|endpoint
operator|=
name|uhe
expr_stmt|;
name|urb
operator|->
name|transfer_buffer
operator|=
name|buf
expr_stmt|;
name|urb
operator|->
name|transfer_buffer_length
operator|=
name|length
expr_stmt|;
name|urb
operator|->
name|complete
operator|=
name|callback
expr_stmt|;
name|urb
operator|->
name|context
operator|=
name|arg
expr_stmt|;
block|}
end_function

begin_comment
comment|/*------------------------------------------------------------------------*  *	usb_bulk_msg  *  * NOTE: This function can also be used for interrupt endpoints!  *  * Return values:  *    0: Success  * Else: Failure  *------------------------------------------------------------------------*/
end_comment

begin_function
name|int
name|usb_bulk_msg
parameter_list|(
name|struct
name|usb_device
modifier|*
name|udev
parameter_list|,
name|struct
name|usb_host_endpoint
modifier|*
name|uhe
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|,
name|uint16_t
modifier|*
name|pactlen
parameter_list|,
name|usb_timeout_t
name|timeout
parameter_list|)
block|{
name|struct
name|urb
modifier|*
name|urb
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|uhe
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
name|err
operator|=
name|usb_setup_endpoint
argument_list|(
name|udev
argument_list|,
name|uhe
argument_list|,
literal|4096
comment|/* bytes */
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|urb
operator|=
name|usb_alloc_urb
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|urb
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
name|usb_fill_bulk_urb
argument_list|(
name|urb
argument_list|,
name|udev
argument_list|,
name|uhe
argument_list|,
name|data
argument_list|,
name|len
argument_list|,
name|usb_linux_wait_complete
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|err
operator|=
name|usb_start_wait_urb
argument_list|(
name|urb
argument_list|,
name|timeout
argument_list|,
name|pactlen
argument_list|)
expr_stmt|;
name|usb_free_urb
argument_list|(
name|urb
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|linuxkpi
argument_list|,
name|usb
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|usb_linux_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* register our function */
name|usb_linux_free_device_p
operator|=
operator|&
name|usb_linux_free_device
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|usb_linux_init
argument_list|,
name|SI_SUB_LOCK
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|usb_linux_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|usb_linux_unload
argument_list|,
name|SI_SUB_LOCK
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|usb_linux_unload
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

