begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2006 Li, Xiao<intron@intron.ac>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/aio.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_LINUX32
end_ifdef

begin_include
include|#
directive|include
file|<machine/../linux32/linux.h>
end_include

begin_include
include|#
directive|include
file|<machine/../linux32/linux32_proto.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<machine/../linux/linux.h>
end_include

begin_include
include|#
directive|include
file|<machine/../linux/linux_proto.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|LINUX_AIO_DEBUG
end_define

begin_comment
comment|/*  * Linux Kernel Implementation of Asynchronous I/O  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|LINUX_AIO_DEBUG
end_ifdef

begin_comment
comment|/* Print arguments of syscall */
end_comment

begin_define
define|#
directive|define
name|DARGPRINTF
parameter_list|(
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|printf("linux(%ld): %s("fmt")\n",	\ 	(long)td->td_proc->p_pid, __func__, __VA_ARGS__)
end_define

begin_comment
comment|/* Print message in syscall function */
end_comment

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|printf(LMSG("%s(): " fmt),		\ 	__func__, __VA_ARGS__)
end_define

begin_comment
comment|/* Print message in non-syscall function, the one more "P" means "private" */
end_comment

begin_define
define|#
directive|define
name|DPPRINTF
parameter_list|(
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|printf("linux(): %s(): " fmt "\n",	\ 	__func__, __VA_ARGS__)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DARGPRINTF
parameter_list|(
name|fmt
parameter_list|,
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|fmt
parameter_list|,
modifier|...
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DPPRINTF
parameter_list|(
name|fmt
parameter_list|,
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *                             DATA STRUCTURE HIERARCHY  *  *                   +--------------------+      +--------------------+  * context_list ---> |       context      | ---> |       context      | ---> ...  *             SLIST |(owned by a process)|      |(owned by a process)|  *                   |                    |      |                    |  *                   | ctx_req            |      | ctx_req            |  *                   +----|---------------+      +----|---------------+  *                        |  STAILQ                   |  STAILQ  *                        v                           v  *                    +------------+              +------------+  *                    |   request  |              |   request  |  *                    |            |              |            |  *                    |.req_pbsd   |              |.req_pbsd   |  *                    |.req_porig  |              |.req_porig  |  *                    |.req_linux  |              |.req_linux  |  *                    |            |              |            |  *                    +------------+              +------------+  *                        |                           |  *                        v                           v  *                    +------------+              +------------+  *                    |   request  |              |   request  |  *                    |            |              |            |  *                    |.req_pbsd   |              |.req_pbsd   |  *                    |.req_porig  |              |.req_porig  |  *                    |.req_linux  |              |.req_linux  |  *                    |            |              |            |  *                    +------------+              +------------+  *                        |                           |  *                        v                           v  *                       ...                         ...  */
end_comment

begin_struct_decl
struct_decl|struct
name|linux_aio_context
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|linux_aio_request
block|{
name|struct
name|aiocb
modifier|*
name|req_pbsd
decl_stmt|;
comment|/* Userland clone for FreeBSD */
name|struct
name|linux_iocb
modifier|*
name|req_porig
decl_stmt|;
comment|/* Userland original control block */
name|struct
name|linux_iocb
name|req_linux
decl_stmt|;
comment|/* Copy of original control block */
name|STAILQ_ENTRY
argument_list|(
argument|linux_aio_request
argument_list|)
name|req_ctx_entry
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|linux_aio_context
block|{
name|struct
name|sx
name|ctx_sx
decl_stmt|;
name|pid_t
name|ctx_pid
decl_stmt|;
name|struct
name|linux_aio_ring
modifier|*
name|ctx_pring
decl_stmt|;
name|int
name|ctx_nreq_max
decl_stmt|;
comment|/* Maximum request number */
name|int
name|ctx_nreq_cur
decl_stmt|;
comment|/* Current request number */
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|linux_aio_request
argument_list|)
name|ctx_req
expr_stmt|;
name|SLIST_ENTRY
argument_list|(
argument|linux_aio_context
argument_list|)
name|ctx_list_entry
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|linux_aio_context
argument_list|)
name|linux_aio_context_list
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|LINUX_AIO_REQ_HOOK
parameter_list|(
name|pctx
parameter_list|,
name|preq
parameter_list|)
value|{			\ 	STAILQ_INSERT_TAIL(&((pctx)->ctx_req), (preq), req_ctx_entry);	\ 	(pctx)->ctx_nreq_cur ++;					\ }
end_define

begin_define
define|#
directive|define
name|LINUX_AIO_REQ_UNHOOK
parameter_list|(
name|pctx
parameter_list|,
name|preq
parameter_list|)
value|{			\ 	STAILQ_REMOVE(&((pctx)->ctx_req), (preq), linux_aio_request,	\ 			req_ctx_entry);					\ 	(pctx)->ctx_nreq_cur --;					\ }
end_define

begin_define
define|#
directive|define
name|LINUX_AIO_REQ_FOREACH
parameter_list|(
name|pctx
parameter_list|,
name|preq
parameter_list|)
define|\
value|STAILQ_FOREACH((preq),&((pctx)->ctx_req), req_ctx_entry)
end_define

begin_define
define|#
directive|define
name|LINUX_AIO_REQ_FOREACH_SAFE
parameter_list|(
name|pctx
parameter_list|,
name|preq
parameter_list|,
name|ptmpreq
parameter_list|)
define|\
value|STAILQ_FOREACH_SAFE((preq),&((pctx)->ctx_req), req_ctx_entry,	\ 			(ptmpreq))
end_define

begin_define
define|#
directive|define
name|LINUX_AIO_CTX_LOCK
parameter_list|(
name|pctx
parameter_list|)
value|sx_xlock(&((pctx)->ctx_sx))
end_define

begin_define
define|#
directive|define
name|LINUX_AIO_CTX_UNLOCK
parameter_list|(
name|pctx
parameter_list|)
value|sx_unlock(&((pctx)->ctx_sx))
end_define

begin_define
define|#
directive|define
name|LINUX_AIO_CTX_HOOK
parameter_list|(
name|pctx
parameter_list|)
define|\
value|SLIST_INSERT_HEAD(&linux_aio_context_list, (pctx), ctx_list_entry)
end_define

begin_define
define|#
directive|define
name|LINUX_AIO_CTX_UNHOOK
parameter_list|(
name|pctx
parameter_list|)
define|\
value|SLIST_REMOVE(&linux_aio_context_list, (pctx),			\ 			linux_aio_context, ctx_list_entry)
end_define

begin_define
define|#
directive|define
name|LINUX_AIO_CTX_FOREACH
parameter_list|(
name|pctx
parameter_list|)
define|\
value|SLIST_FOREACH((pctx),&linux_aio_context_list, ctx_list_entry)
end_define

begin_define
define|#
directive|define
name|LINUX_AIO_CTX_FOREACH_SAFE
parameter_list|(
name|pctx
parameter_list|,
name|ptmpctx
parameter_list|)
define|\
value|SLIST_FOREACH_SAFE((pctx),&linux_aio_context_list,		\ 			ctx_list_entry, (ptmpctx))
end_define

begin_define
define|#
directive|define
name|LINUX_AIO_CTX_MATCH
parameter_list|(
name|pctx
parameter_list|,
name|ctxid
parameter_list|,
name|pid
parameter_list|)
define|\
value|((linux_aio_context_t)(pctx)->ctx_pring == (ctxid)		\&& (pctx)->ctx_pid == (pid))
end_define

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|linux_aio_context_list_mtx
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|LINUX_AIO_CTX_LIST_LOCK
parameter_list|()
value|mtx_lock(&linux_aio_context_list_mtx)
end_define

begin_define
define|#
directive|define
name|LINUX_AIO_CTX_LIST_UNLOCK
parameter_list|()
value|mtx_unlock(&linux_aio_context_list_mtx)
end_define

begin_comment
comment|/*  * The following two macros are substantially identical to the two macros  * AIO_(UN)LOCK in /sys/kern/vfs_aio.c. Thus, the mutex much be unlocked  * before calling functions of FreeBSD native AIO module.  *  * XXX  * I ASSUME the member "kaio_mtx" is the first element of "struct kaioinfo".  */
end_comment

begin_define
define|#
directive|define
name|LINUX_AIO_LOCK
parameter_list|(
name|p
parameter_list|)
value|{					\ 	if ((p)->p_aioinfo == NULL)					\ 		p_aio_init_aioinfo(p);					\ 	mtx_lock((struct mtx *)((p)->p_aioinfo));			\ }
end_define

begin_define
define|#
directive|define
name|LINUX_AIO_UNLOCK
parameter_list|(
name|p
parameter_list|)
value|{					\ 	if ((p)->p_aioinfo == NULL)					\ 		p_aio_init_aioinfo(p);					\ 	mtx_unlock((struct mtx *)((p)->p_aioinfo));			\ }
end_define

begin_decl_stmt
specifier|static
name|uma_zone_t
name|linux_aio_context_zone
decl_stmt|,
name|linux_aio_request_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|linux_aio_exit_tag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * XXX  * Calling external function/variable declared with "static" is DANGEROUS !!!  * Compiler may use register to transfer calling arguments for optimization,  * which is NOT a normal calling way and can cause kernel crash.  */
end_comment

begin_define
define|#
directive|define
name|NATIVE_AIO_MODULE_NAME
value|"aio"
end_define

begin_decl_stmt
specifier|static
name|struct
name|mod_depend
name|native_aio_module_depend
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|linker_file_t
name|native_aio_module_handle
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Mirror of sysctls in /sys/kern/vfs_aio.c */
end_comment

begin_define
define|#
directive|define
name|NATIVE_AIO_SYSCTL_CAPACITY_PROC
value|"vfs.aio.max_aio_queue_per_proc"
end_define

begin_decl_stmt
specifier|static
name|int
name|native_aio_capacity_proc
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NATIVE_AIO_SYSCTL_CAPACITY_SYS
value|"vfs.aio.max_aio_queue"
end_define

begin_decl_stmt
specifier|static
name|int
name|native_aio_capacity_sys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For declaration of aio_aqueue(), defined in /sys/kern/vfs_aio.c */
end_comment

begin_struct_decl
struct_decl|struct
name|aioliojob
struct_decl|;
end_struct_decl

begin_comment
comment|/* Functions in /sys/kern/vfs_aio.c, XXX defined with "static" */
end_comment

begin_define
define|#
directive|define
name|GET_INTERNAL_FUNC_POINTER
parameter_list|(
name|s
parameter_list|)
value|{				\ 	* ((caddr_t *)& p_ ## s) = linker_file_lookup_symbol(		\ 			native_aio_module_handle, #s, FALSE);		\ 	if (p_ ## s == NULL)						\ 		break;							\ }
end_define

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
name|p_aio_init_aioinfo
function_decl|)
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
function_decl|(
modifier|*
name|p_aio_aqueue
function_decl|)
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|aiocb
modifier|*
name|job
parameter_list|,
name|struct
name|aioliojob
modifier|*
name|lio
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|osigev
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* System calls in /sys/kern/vfs_aio.c */
end_comment

begin_define
define|#
directive|define
name|DEFINE_SYSCALL_POINTER_VARIABLE
parameter_list|(
name|s
parameter_list|)
define|\
value|static int (* p_ ## s) (struct thread *, struct s ## _args *)
end_define

begin_define
define|#
directive|define
name|GET_SYSCALL_POINTER
parameter_list|(
name|s
parameter_list|)
value|{				\ 	* ((sy_call_t **)& p_ ## s) = sysent[SYS_ ## s].sy_call;	\ 	if ((sy_call_t *) p_ ## s == (sy_call_t *)lkmressys)		\ 		break;							\ }
end_define

begin_expr_stmt
name|DEFINE_SYSCALL_POINTER_VARIABLE
argument_list|(
name|aio_return
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_SYSCALL_POINTER_VARIABLE
argument_list|(
name|aio_suspend
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_SYSCALL_POINTER_VARIABLE
argument_list|(
name|aio_cancel
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_SYSCALL_POINTER_VARIABLE
argument_list|(
name|aio_error
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|user_mem_rw_verify
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|int
name|nerr
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
condition|;
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
control|)
block|{
comment|/* Verify reading */
name|nerr
operator|=
name|copyin
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|i
argument_list|,
name|buf
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|s
operator|-
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
operator|!=
literal|0
condition|)
break|break;
comment|/* Verify writing */
name|nerr
operator|=
name|copyout
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|i
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|s
operator|-
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
operator|!=
literal|0
condition|)
break|break;
block|}
return|return
operator|(
name|nerr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate memory in user space */
end_comment

begin_function
specifier|static
name|int
name|user_malloc
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|void
modifier|*
modifier|*
name|pp
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|struct
name|mmap_args
name|mmaparg
decl_stmt|;
name|int
name|nerr
decl_stmt|;
name|register_t
name|r
decl_stmt|;
name|r
operator|=
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
expr_stmt|;
name|mmaparg
operator|.
name|addr
operator|=
name|NULL
expr_stmt|;
name|mmaparg
operator|.
name|len
operator|=
name|s
expr_stmt|;
name|mmaparg
operator|.
name|prot
operator|=
name|PROT_READ
operator||
name|PROT_WRITE
expr_stmt|;
name|mmaparg
operator|.
name|flags
operator|=
name|MAP_PRIVATE
operator||
name|MAP_ANON
expr_stmt|;
name|mmaparg
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|mmaparg
operator|.
name|pad
operator|=
literal|0
expr_stmt|;
name|mmaparg
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|nerr
operator|=
name|mmap
argument_list|(
name|td
argument_list|,
operator|&
name|mmaparg
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
operator|==
literal|0
condition|)
block|{
operator|*
name|pp
operator|=
operator|(
name|void
operator|*
operator|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
expr_stmt|;
name|DPPRINTF
argument_list|(
literal|"%lu bytes allocated at %p"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|s
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|r
expr_stmt|;
return|return
operator|(
name|nerr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Free memory in user space */
end_comment

begin_function
specifier|static
name|int
name|user_free
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|struct
name|munmap_args
name|munmaparg
decl_stmt|;
name|int
name|nerr
decl_stmt|;
name|register_t
name|r
decl_stmt|;
name|r
operator|=
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
expr_stmt|;
name|munmaparg
operator|.
name|addr
operator|=
name|p
expr_stmt|;
name|munmaparg
operator|.
name|len
operator|=
name|s
expr_stmt|;
name|nerr
operator|=
name|munmap
argument_list|(
name|td
argument_list|,
operator|&
name|munmaparg
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|r
expr_stmt|;
name|DPPRINTF
argument_list|(
literal|"%lu bytes at %p"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|s
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|nerr
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LINUX_AIO_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|linux_aio_dump_freebsd_aiocb
parameter_list|(
name|struct
name|aiocb
modifier|*
name|piocb
parameter_list|,
name|int
name|isuserland
parameter_list|)
block|{
name|struct
name|aiocb
name|localcb
decl_stmt|,
modifier|*
name|pcb
decl_stmt|;
name|int
name|nerr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|isuserland
condition|)
block|{
name|nerr
operator|=
name|copyin
argument_list|(
name|piocb
argument_list|,
operator|&
name|localcb
argument_list|,
sizeof|sizeof
argument_list|(
name|localcb
argument_list|)
argument_list|)
expr_stmt|;
name|pcb
operator|=
operator|&
name|localcb
expr_stmt|;
block|}
else|else
name|pcb
operator|=
name|piocb
expr_stmt|;
name|DPPRINTF
argument_list|(
literal|"Dump struct aiocb (%p, %s): %s"
argument_list|,
name|piocb
argument_list|,
operator|(
name|isuserland
condition|?
literal|"userland"
else|:
literal|"kernel"
operator|)
argument_list|,
operator|(
name|nerr
condition|?
literal|"Failure"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nerr
condition|)
block|{
name|DPPRINTF
argument_list|(
literal|"aio_fildes: %d"
argument_list|,
name|pcb
operator|->
name|aio_fildes
argument_list|)
expr_stmt|;
name|DPPRINTF
argument_list|(
literal|"aio_offset: %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pcb
operator|->
name|aio_offset
argument_list|)
expr_stmt|;
name|DPPRINTF
argument_list|(
literal|"aio_buf: %p"
argument_list|,
name|pcb
operator|->
name|aio_buf
argument_list|)
expr_stmt|;
name|DPPRINTF
argument_list|(
literal|"aio_nbytes: %lu"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|pcb
operator|->
name|aio_nbytes
argument_list|)
expr_stmt|;
name|DPPRINTF
argument_list|(
literal|"aio_lio_opcode: %d"
argument_list|,
name|pcb
operator|->
name|aio_lio_opcode
argument_list|)
expr_stmt|;
name|DPPRINTF
argument_list|(
literal|"aio_reqprio: %d"
argument_list|,
name|pcb
operator|->
name|aio_reqprio
argument_list|)
expr_stmt|;
name|DPPRINTF
argument_list|(
literal|"aio_sigevent.sigev_notify: %d"
argument_list|,
name|pcb
operator|->
name|aio_sigevent
operator|.
name|sigev_notify
argument_list|)
expr_stmt|;
name|DPPRINTF
argument_list|(
literal|"aio_sigevent.sigev_signo: %d"
argument_list|,
name|pcb
operator|->
name|aio_sigevent
operator|.
name|sigev_signo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|DUMP_FREEBSD_AIOCB
parameter_list|(
name|p
parameter_list|,
name|isu
parameter_list|)
value|linux_aio_dump_freebsd_aiocb((p), (isu));
end_define

begin_define
define|#
directive|define
name|DUMP_TIMESPEC
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|,
name|a
parameter_list|)
define|\
value|DPRINTF("%s%ld second + %ld nanosecond%s",			\ 			(f), (long)(t)->tv_sec, (long)(t)->tv_nsec, (a));
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! LINUX_AIO_DEBUG */
end_comment

begin_define
define|#
directive|define
name|DUMP_FREEBSD_AIOCB
parameter_list|(
name|p
parameter_list|,
name|isu
parameter_list|)
end_define

begin_define
define|#
directive|define
name|DUMP_TIMESPEC
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|,
name|a
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LINUX_AIO_DEBUG */
end_comment

begin_function
specifier|static
name|int
name|iocb_reformat
parameter_list|(
name|struct
name|linux_iocb
modifier|*
name|plnx
parameter_list|,
name|struct
name|aiocb
modifier|*
name|pbsd
parameter_list|)
block|{
name|int
name|nerr
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
name|pbsd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pbsd
argument_list|)
argument_list|)
expr_stmt|;
name|pbsd
operator|->
name|aio_fildes
operator|=
name|plnx
operator|->
name|aio_fildes
expr_stmt|;
comment|/* File descriptor */
name|pbsd
operator|->
name|aio_offset
operator|=
name|plnx
operator|->
name|aio_offset
expr_stmt|;
comment|/* File offset for I/O */
name|pbsd
operator|->
name|aio_buf
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|plnx
operator|->
name|aio_buf
expr_stmt|;
comment|/* 								* User space 								* I/O buffer 								*/
name|pbsd
operator|->
name|aio_nbytes
operator|=
name|plnx
operator|->
name|aio_nbytes
expr_stmt|;
comment|/* Number of bytes for I/O */
switch|switch
condition|(
name|plnx
operator|->
name|aio_lio_opcode
condition|)
block|{
comment|/* LIO opcode */
case|case
name|LINUX_IOCB_CMD_PREAD
case|:
name|pbsd
operator|->
name|aio_lio_opcode
operator|=
name|LIO_READ
expr_stmt|;
break|break;
case|case
name|LINUX_IOCB_CMD_PWRITE
case|:
name|pbsd
operator|->
name|aio_lio_opcode
operator|=
name|LIO_WRITE
expr_stmt|;
break|break;
case|case
name|LINUX_IOCB_CMD_FSYNC
case|:
case|case
name|LINUX_IOCB_CMD_FDSYNC
case|:
name|pbsd
operator|->
name|aio_lio_opcode
operator|=
name|LIO_SYNC
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case LINUX_IOCB_CMD_PREADX: 		break; 	case LINUX_IOCB_CMD_POLL: 		break;
endif|#
directive|endif
case|case
name|LINUX_IOCB_CMD_NOOP
case|:
name|pbsd
operator|->
name|aio_lio_opcode
operator|=
name|LIO_NOP
expr_stmt|;
break|break;
default|default:
name|nerr
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nerr
operator|!=
literal|0
condition|)
block|{
name|DPPRINTF
argument_list|(
literal|"Unsupported aio_lio_opcode: %u"
argument_list|,
operator|(
name|unsigned
operator|)
name|plnx
operator|->
name|aio_lio_opcode
argument_list|)
expr_stmt|;
return|return
operator|(
name|nerr
operator|)
return|;
block|}
name|pbsd
operator|->
name|aio_reqprio
operator|=
name|plnx
operator|->
name|aio_reqprio
expr_stmt|;
comment|/* Request priority */
name|pbsd
operator|->
name|aio_sigevent
operator|.
name|sigev_notify
operator|=
name|SIGEV_NONE
expr_stmt|;
comment|/* No signal to deliver */
name|pbsd
operator|->
name|aio_sigevent
operator|.
name|sigev_signo
operator|=
literal|0
expr_stmt|;
comment|/* No signal to deliver */
return|return
operator|(
name|nerr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|link_to_native_aio_module
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|nerr
decl_stmt|;
if|if
condition|(
name|native_aio_module_handle
operator|!=
name|NULL
condition|)
block|{
comment|/* Linking has been done successfully. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|nerr
operator|=
name|linker_reference_module
argument_list|(
name|NATIVE_AIO_MODULE_NAME
argument_list|,
operator|&
name|native_aio_module_depend
argument_list|,
operator|&
name|native_aio_module_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
condition|)
return|return
operator|(
name|nerr
operator|)
return|;
do|do
block|{
name|nerr
operator|=
name|EINVAL
expr_stmt|;
comment|/* Kernel internal functions */
name|GET_INTERNAL_FUNC_POINTER
argument_list|(
name|aio_init_aioinfo
argument_list|)
expr_stmt|;
name|GET_INTERNAL_FUNC_POINTER
argument_list|(
name|aio_aqueue
argument_list|)
expr_stmt|;
comment|/* System calls */
name|GET_SYSCALL_POINTER
argument_list|(
name|aio_return
argument_list|)
expr_stmt|;
name|GET_SYSCALL_POINTER
argument_list|(
name|aio_suspend
argument_list|)
expr_stmt|;
name|GET_SYSCALL_POINTER
argument_list|(
name|aio_cancel
argument_list|)
expr_stmt|;
name|GET_SYSCALL_POINTER
argument_list|(
name|aio_error
argument_list|)
expr_stmt|;
name|nerr
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
if|if
condition|(
name|nerr
condition|)
block|{
name|linker_release_module
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|native_aio_module_handle
argument_list|)
expr_stmt|;
name|native_aio_module_handle
operator|=
name|NULL
expr_stmt|;
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"Unable to link to the native module \""
name|NATIVE_AIO_MODULE_NAME
literal|"\"."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|nerr
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|LINK_TO_NATIVE_AIO_MODULE
parameter_list|()
define|\
value|if (link_to_native_aio_module(td)) {				\ 		printf(LMSG("Please load the module \""			\ 			NATIVE_AIO_MODULE_NAME "\""			\ 			"to provide FreeBSD "				\ 			"native Asynchronous I/O support."));		\ 		return (ENOSYS);						\ }
end_define

begin_function
specifier|static
name|int
name|mirror_native_aio_sysctl
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|nerr
init|=
literal|0
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|l
operator|=
sizeof|sizeof
argument_list|(
name|native_aio_capacity_proc
argument_list|)
expr_stmt|;
name|nerr
operator|=
name|kernel_sysctlbyname
argument_list|(
name|td
argument_list|,
name|NATIVE_AIO_SYSCTL_CAPACITY_PROC
argument_list|,
operator|&
name|native_aio_capacity_proc
argument_list|,
operator|&
name|l
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
condition|)
return|return
operator|(
name|nerr
operator|)
return|;
name|l
operator|=
sizeof|sizeof
argument_list|(
name|native_aio_capacity_sys
argument_list|)
expr_stmt|;
name|nerr
operator|=
name|kernel_sysctlbyname
argument_list|(
name|td
argument_list|,
name|NATIVE_AIO_SYSCTL_CAPACITY_SYS
argument_list|,
operator|&
name|native_aio_capacity_sys
argument_list|,
operator|&
name|l
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
condition|)
return|return
operator|(
name|nerr
operator|)
return|;
name|DPRINTF
argument_list|(
name|NATIVE_AIO_SYSCTL_CAPACITY_PROC
literal|"=%d, "
name|NATIVE_AIO_SYSCTL_CAPACITY_SYS
literal|"=%d"
argument_list|,
name|native_aio_capacity_proc
argument_list|,
name|native_aio_capacity_sys
argument_list|)
expr_stmt|;
return|return
operator|(
name|nerr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Linux system call io_setup(2) */
end_comment

begin_function
name|int
name|linux_io_setup
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_io_setup_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|linux_aio_ring
modifier|*
name|pring
decl_stmt|,
name|ring
decl_stmt|;
name|struct
name|linux_aio_context
modifier|*
name|pctx
init|=
name|NULL
decl_stmt|,
modifier|*
name|ptmpctx
decl_stmt|;
name|linux_aio_context_t
name|ctx_id
decl_stmt|;
name|int
name|nerr
init|=
literal|0
decl_stmt|,
name|nr
decl_stmt|,
name|nrall
decl_stmt|,
name|nq
decl_stmt|,
name|arg_nr_reqs
decl_stmt|;
name|DARGPRINTF
argument_list|(
literal|"%u, %p"
argument_list|,
name|args
operator|->
name|nr_reqs
argument_list|,
name|args
operator|->
name|ctxp
argument_list|)
expr_stmt|;
name|LINK_TO_NATIVE_AIO_MODULE
argument_list|()
expr_stmt|;
name|nerr
operator|=
name|mirror_native_aio_sysctl
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
condition|)
block|{
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"linux_io_setup(): Unable to query sysctls "
name|NATIVE_AIO_SYSCTL_CAPACITY_PROC
literal|" and/or "
name|NATIVE_AIO_SYSCTL_CAPACITY_SYS
literal|" ."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|nerr
operator|)
return|;
block|}
comment|/* Signed integer is a little safer than unsigned */
name|arg_nr_reqs
operator|=
name|args
operator|->
name|nr_reqs
expr_stmt|;
if|if
condition|(
name|arg_nr_reqs
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|arg_nr_reqs
operator|>
name|native_aio_capacity_proc
operator|||
name|arg_nr_reqs
operator|>
name|native_aio_capacity_sys
condition|)
block|{
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"linux_io_setup(): Please increase sysctls "
name|NATIVE_AIO_SYSCTL_CAPACITY_PROC
literal|" and/or "
name|NATIVE_AIO_SYSCTL_CAPACITY_SYS
literal|" ."
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|nerr
operator|=
name|user_mem_rw_verify
argument_list|(
name|args
operator|->
name|ctxp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|args
operator|->
name|ctxp
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
operator|!=
literal|0
condition|)
return|return
operator|(
name|nerr
operator|)
return|;
name|copyin
argument_list|(
name|args
operator|->
name|ctxp
argument_list|,
operator|&
name|ctx_id
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx_id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx_id
operator|!=
literal|0
condition|)
comment|/* "Not initialized", described by io_setup(2) */
return|return
operator|(
name|EINVAL
operator|)
return|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
comment|/* Get a new "ring" */
name|nerr
operator|=
name|user_malloc
argument_list|(
name|td
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|pring
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pring
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
operator|!=
literal|0
condition|)
return|return
operator|(
name|nerr
operator|)
return|;
comment|/* Get a new context */
name|pctx
operator|=
name|uma_zalloc
argument_list|(
name|linux_aio_context_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|LINUX_AIO_CTX_LIST_LOCK
argument_list|()
expr_stmt|;
comment|/* Count request capacity of all contexts belonging to this process */
name|nr
operator|=
literal|0
expr_stmt|;
name|nrall
operator|=
literal|0
expr_stmt|;
name|nq
operator|=
literal|0
expr_stmt|;
name|LINUX_AIO_CTX_FOREACH
argument_list|(
argument|ptmpctx
argument_list|)
block|{
if|if
condition|(
name|ptmpctx
operator|->
name|ctx_pid
operator|==
name|p
operator|->
name|p_pid
condition|)
block|{
name|nr
operator|+=
name|ptmpctx
operator|->
name|ctx_nreq_max
expr_stmt|;
name|nq
operator|++
expr_stmt|;
block|}
name|nrall
operator|+=
name|ptmpctx
operator|->
name|ctx_nreq_max
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"%d queues of %d requests totally allocated for this process, "
literal|"%d requests' total capacity for the whole system"
argument_list|,
name|nq
argument_list|,
name|nr
argument_list|,
name|nrall
argument_list|)
expr_stmt|;
comment|/* Check whether there are enough resources for requested queue */
if|if
condition|(
name|arg_nr_reqs
operator|>
name|native_aio_capacity_proc
operator|-
name|nr
operator|||
name|arg_nr_reqs
operator|>
name|native_aio_capacity_sys
operator|-
name|nrall
condition|)
block|{
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"linux_io_setup(): "
literal|"Please increase sysctls "
name|NATIVE_AIO_SYSCTL_CAPACITY_PROC
literal|" and/or "
name|NATIVE_AIO_SYSCTL_CAPACITY_SYS
literal|" ."
literal|"Besides %d queues of %d requests totally "
literal|"for this process, and %d requests' queues "
literal|"totally for the whole system, "
literal|"this Linux application needs one more "
literal|"AIO queue of %d requests' capacity."
argument_list|)
argument_list|,
name|nq
argument_list|,
name|nr
argument_list|,
name|nrall
argument_list|,
name|arg_nr_reqs
argument_list|)
expr_stmt|;
name|LINUX_AIO_CTX_LIST_UNLOCK
argument_list|()
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"Free context %p"
argument_list|,
name|pctx
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|linux_aio_context_zone
argument_list|,
name|pctx
argument_list|)
expr_stmt|;
name|user_free
argument_list|(
name|td
argument_list|,
name|pring
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pring
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Initialize the new context */
name|sx_init
argument_list|(
operator|&
operator|(
name|pctx
operator|->
name|ctx_sx
operator|)
argument_list|,
literal|"linux_aio_context"
argument_list|)
expr_stmt|;
name|pctx
operator|->
name|ctx_pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|pctx
operator|->
name|ctx_pring
operator|=
name|pring
expr_stmt|;
name|pctx
operator|->
name|ctx_nreq_max
operator|=
name|arg_nr_reqs
expr_stmt|;
name|pctx
operator|->
name|ctx_nreq_cur
operator|=
literal|0
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
operator|(
name|pctx
operator|->
name|ctx_req
operator|)
argument_list|)
expr_stmt|;
comment|/* Hook the new context to global context list */
name|LINUX_AIO_CTX_HOOK
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
name|LINUX_AIO_CTX_LIST_UNLOCK
argument_list|()
expr_stmt|;
comment|/* Initialize the new "ring" */
name|DPRINTF
argument_list|(
literal|"initialize the \"ring\" %p"
argument_list|,
name|pring
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ring
argument_list|,
sizeof|sizeof
argument_list|(
name|ring
argument_list|)
argument_list|)
expr_stmt|;
name|ring
operator|.
name|ring_id
operator|=
literal|1
expr_stmt|;
name|ring
operator|.
name|ring_nr
operator|=
name|arg_nr_reqs
expr_stmt|;
name|ring
operator|.
name|ring_head
operator|=
literal|0
expr_stmt|;
name|ring
operator|.
name|ring_tail
operator|=
literal|1
expr_stmt|;
name|ring
operator|.
name|ring_magic
operator|=
name|LINUX_AIO_RING_MAGIC
expr_stmt|;
name|ring
operator|.
name|ring_compat_features
operator|=
name|LINUX_AIO_RING_COMPAT_FEATURES
expr_stmt|;
name|ring
operator|.
name|ring_incompat_features
operator|=
name|LINUX_AIO_RING_INCOMPAT_FEATURES
expr_stmt|;
name|ring
operator|.
name|ring_header_length
operator|=
sizeof|sizeof
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|copyout
argument_list|(
operator|&
name|ring
argument_list|,
name|pring
argument_list|,
sizeof|sizeof
argument_list|(
name|ring
argument_list|)
argument_list|)
expr_stmt|;
comment|/* It has been hooked before */
comment|/* Substantial return value */
name|ctx_id
operator|=
operator|(
name|linux_aio_context_t
operator|)
name|pctx
operator|->
name|ctx_pring
expr_stmt|;
name|copyout
argument_list|(
operator|&
name|ctx_id
argument_list|,
name|args
operator|->
name|ctxp
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx_id
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"returned context: %lx -> %p"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ctx_id
argument_list|,
name|pctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|nerr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Linux system call io_destroy(2) */
end_comment

begin_function
name|int
name|linux_io_destroy
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_io_destroy_args
modifier|*
name|args
parameter_list|)
block|{
name|int
name|nerr
init|=
literal|0
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|linux_aio_context
modifier|*
name|pctx
decl_stmt|;
name|struct
name|linux_aio_request
modifier|*
name|preq
decl_stmt|,
modifier|*
name|ptmpreq
decl_stmt|;
name|struct
name|aio_cancel_args
name|cancelargs
decl_stmt|;
name|struct
name|aio_return_args
name|aioretargs
decl_stmt|;
name|DARGPRINTF
argument_list|(
literal|"%lx"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|args
operator|->
name|ctx
argument_list|)
expr_stmt|;
name|LINK_TO_NATIVE_AIO_MODULE
argument_list|()
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
comment|/* 	 * Locking: 	 * 	 * LINUX_AIO_LOCK(p);<----------------+ 	 * ...                                   | 	 *     LINUX_AIO_CTX_LIST_LOCK();<--+ | 	 *     ...                             | | 	 *     LINUX_AIO_CTX_LIST_UNLOCK();<--+ | 	 * ...                                   | 	 * LINUX_AIO_CTX_LOCK(pctx);<---------|---+ 	 * LINUX_AIO_UNLOCK(p);<----------------+   | 	 * ...                                       | 	 * LINUX_AIO_CTX_UNLOCK(pctx);<-------------+ 	 */
name|LINUX_AIO_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Find the context in context list */
name|LINUX_AIO_CTX_LIST_LOCK
argument_list|()
expr_stmt|;
name|LINUX_AIO_CTX_FOREACH
argument_list|(
argument|pctx
argument_list|)
block|{
if|if
condition|(
name|LINUX_AIO_CTX_MATCH
argument_list|(
name|pctx
argument_list|,
name|args
operator|->
name|ctx
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
condition|)
break|break;
block|}
name|LINUX_AIO_CTX_LIST_UNLOCK
argument_list|()
expr_stmt|;
comment|/* Unable to find the context */
if|if
condition|(
name|pctx
operator|==
name|NULL
condition|)
block|{
name|LINUX_AIO_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|DPRINTF
argument_list|(
literal|"Found the context: %lx -> %p"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|args
operator|->
name|ctx
argument_list|,
name|pctx
argument_list|)
expr_stmt|;
comment|/* Unhook the context from context list */
name|DPRINTF
argument_list|(
literal|"Unhook context %p"
argument_list|,
name|pctx
argument_list|)
expr_stmt|;
name|LINUX_AIO_CTX_UNHOOK
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
name|LINUX_AIO_CTX_LOCK
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
comment|/* XXX Interlaced, seamless */
name|LINUX_AIO_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* XXX Interlaced, seamless */
comment|/* Real cleanup */
name|LINUX_AIO_REQ_FOREACH_SAFE
argument_list|(
argument|pctx
argument_list|,
argument|preq
argument_list|,
argument|ptmpreq
argument_list|)
block|{
name|DPRINTF
argument_list|(
literal|"Cancel request (Linux: %p, FreeBSD: %p)"
argument_list|,
name|preq
operator|->
name|req_porig
argument_list|,
name|preq
operator|->
name|req_pbsd
argument_list|)
expr_stmt|;
comment|/* Cancel FreeBSD native clone */
name|cancelargs
operator|.
name|fd
operator|=
name|preq
operator|->
name|req_linux
operator|.
name|aio_fildes
expr_stmt|;
name|cancelargs
operator|.
name|aiocbp
operator|=
name|preq
operator|->
name|req_pbsd
expr_stmt|;
name|p_aio_cancel
argument_list|(
name|td
argument_list|,
operator|&
name|cancelargs
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"aio_cancel() returned %ld"
argument_list|,
operator|(
name|long
operator|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|==
name|AIO_NOTCANCELED
condition|)
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"linux_io_destroy(): Asynchronous IO "
literal|"request (Linux: %p, FreeBSD: %p) "
literal|"cannot be cancelled. "
literal|"***** Both User Space "
literal|"and Kernel Memory Leaked! *****"
argument_list|)
argument_list|,
name|preq
operator|->
name|req_porig
argument_list|,
name|preq
operator|->
name|req_pbsd
argument_list|)
expr_stmt|;
name|LINUX_AIO_REQ_UNHOOK
argument_list|(
name|pctx
argument_list|,
name|preq
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|==
name|AIO_ALLDONE
condition|)
block|{
name|aioretargs
operator|.
name|aiocbp
operator|=
name|preq
operator|->
name|req_pbsd
expr_stmt|;
name|p_aio_return
argument_list|(
name|td
argument_list|,
operator|&
name|aioretargs
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"aio_return(%p) returned %ld"
argument_list|,
name|aioretargs
operator|.
name|aiocbp
argument_list|,
operator|(
name|long
operator|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|AIO_ALLDONE
expr_stmt|;
block|}
comment|/* Free user space clone of the request */
if|if
condition|(
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|!=
name|AIO_NOTCANCELED
condition|)
comment|/* 							 * XXX How to avoid 							 * memory leak here? 							 */
name|user_free
argument_list|(
name|td
argument_list|,
name|preq
operator|->
name|req_pbsd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|preq
operator|->
name|req_pbsd
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Free kernel structure of the request */
name|uma_zfree
argument_list|(
name|linux_aio_request_zone
argument_list|,
name|preq
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|LINUX_AIO_CTX_UNLOCK
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
operator|(
name|pctx
operator|->
name|ctx_sx
operator|)
argument_list|)
expr_stmt|;
comment|/* Free the "ring" */
name|DPRINTF
argument_list|(
literal|"free the \"ring\" %p"
argument_list|,
name|pctx
operator|->
name|ctx_pring
argument_list|)
expr_stmt|;
name|user_free
argument_list|(
name|td
argument_list|,
name|pctx
operator|->
name|ctx_pring
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pctx
operator|->
name|ctx_pring
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Free destroyed context */
name|uma_zfree
argument_list|(
name|linux_aio_context_zone
argument_list|,
name|pctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|nerr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Linux system call io_getevents(2) */
end_comment

begin_function
name|int
name|linux_io_getevents
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_io_getevents_args
modifier|*
name|args
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nerr
init|=
literal|0
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|l_timespec
name|l_timeout
decl_stmt|;
name|struct
name|timespec
name|timeout
decl_stmt|,
modifier|*
name|u_ptimeout
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|struct
name|linux_aio_context
modifier|*
name|pctx
decl_stmt|;
name|struct
name|linux_aio_request
modifier|*
name|preq
decl_stmt|,
modifier|*
name|ptmpreq
decl_stmt|;
name|struct
name|linux_io_event
name|evt
decl_stmt|;
name|struct
name|aio_return_args
name|aioretargs
decl_stmt|;
name|struct
name|aio_error_args
name|aioerrargs
decl_stmt|;
name|register_t
name|aio_ret
decl_stmt|,
name|aio_err
decl_stmt|;
name|struct
name|aiocb
modifier|*
modifier|*
name|u_aiocbp
decl_stmt|;
name|struct
name|aio_suspend_args
name|aiosusargs
decl_stmt|;
name|DARGPRINTF
argument_list|(
literal|"%lx, %ld, %ld, %p, %p"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|args
operator|->
name|ctx_id
argument_list|,
operator|(
name|long
operator|)
name|args
operator|->
name|min_nr
argument_list|,
operator|(
name|long
operator|)
name|args
operator|->
name|nr
argument_list|,
name|args
operator|->
name|events
argument_list|,
name|args
operator|->
name|timeout
argument_list|)
expr_stmt|;
name|LINK_TO_NATIVE_AIO_MODULE
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|nr
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|args
operator|->
name|min_nr
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|nerr
operator|=
name|user_mem_rw_verify
argument_list|(
name|args
operator|->
name|events
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|args
operator|->
name|events
operator|)
argument_list|)
operator|*
name|args
operator|->
name|nr
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
operator|!=
literal|0
condition|)
return|return
operator|(
name|nerr
operator|)
return|;
if|if
condition|(
name|args
operator|->
name|timeout
operator|!=
name|NULL
condition|)
block|{
name|nerr
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|timeout
argument_list|,
operator|&
name|l_timeout
argument_list|,
sizeof|sizeof
argument_list|(
name|l_timeout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
operator|!=
literal|0
condition|)
return|return
operator|(
name|nerr
operator|)
return|;
name|timeout
operator|.
name|tv_sec
operator|=
name|l_timeout
operator|.
name|tv_sec
expr_stmt|;
name|timeout
operator|.
name|tv_nsec
operator|=
name|l_timeout
operator|.
name|tv_nsec
expr_stmt|;
name|DUMP_TIMESPEC
argument_list|(
literal|"User specified timeout: "
argument_list|,
operator|&
name|timeout
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
comment|/* 	 * Locking: 	 * 	 * LINUX_AIO_LOCK(p);<----------------+ 	 * ...                                   | 	 *     LINUX_AIO_CTX_LIST_LOCK();<--+ | 	 *     ...                             | | 	 *     LINUX_AIO_CTX_LIST_UNLOCK();<--+ | 	 * ...                                   | 	 * LINUX_AIO_CTX_LOCK(pctx);<---------|---+ 	 * LINUX_AIO_UNLOCK(p);<----------------+   | 	 * ...                                       | 	 * LINUX_AIO_CTX_UNLOCK(pctx);<-------------+ 	 */
name|LINUX_AIO_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Find the context in context list */
name|LINUX_AIO_CTX_LIST_LOCK
argument_list|()
expr_stmt|;
name|LINUX_AIO_CTX_FOREACH
argument_list|(
argument|pctx
argument_list|)
block|{
if|if
condition|(
name|LINUX_AIO_CTX_MATCH
argument_list|(
name|pctx
argument_list|,
name|args
operator|->
name|ctx_id
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
condition|)
break|break;
block|}
name|LINUX_AIO_CTX_LIST_UNLOCK
argument_list|()
expr_stmt|;
comment|/* Unable to find the context */
if|if
condition|(
name|pctx
operator|==
name|NULL
condition|)
block|{
name|LINUX_AIO_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|DPRINTF
argument_list|(
literal|"Found the context: %lx -> %p"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|args
operator|->
name|ctx_id
argument_list|,
name|pctx
argument_list|)
expr_stmt|;
name|LINUX_AIO_CTX_LOCK
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
comment|/* XXX Interlaced, seamless */
name|LINUX_AIO_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* XXX Interlaced, seamless */
if|if
condition|(
name|STAILQ_EMPTY
argument_list|(
operator|&
operator|(
name|pctx
operator|->
name|ctx_req
operator|)
argument_list|)
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* No queued request */
name|DPRINTF
argument_list|(
literal|"No request in queue (context: %p) at all, "
literal|"return directly"
argument_list|,
name|pctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Deal with the request queue */
name|i
operator|=
literal|0
expr_stmt|;
comment|/* 			* This variable's value will be the return value 			* of linux_io_getevents()  			*/
name|nerr
operator|=
name|user_malloc
argument_list|(
name|td
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|u_aiocbp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|u_aiocbp
argument_list|)
operator|*
name|pctx
operator|->
name|ctx_nreq_max
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
operator|!=
literal|0
condition|)
goto|goto
name|skip_substantial_0
goto|;
name|nerr
operator|=
name|user_malloc
argument_list|(
name|td
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|u_ptimeout
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|u_ptimeout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
operator|!=
literal|0
condition|)
goto|goto
name|skip_substantial_1
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|args
operator|->
name|nr
condition|;
control|)
block|{
comment|/* Collecting finished requests and waiting for queued requests */
name|LINUX_AIO_REQ_FOREACH_SAFE
argument_list|(
argument|pctx
argument_list|,
argument|preq
argument_list|,
argument|ptmpreq
argument_list|)
block|{
comment|/* Collect all finished requests */
if|if
condition|(
name|i
operator|>=
name|args
operator|->
name|nr
condition|)
comment|/* Full */
break|break;
name|aioerrargs
operator|.
name|aiocbp
operator|=
name|preq
operator|->
name|req_pbsd
expr_stmt|;
name|p_aio_error
argument_list|(
name|td
argument_list|,
operator|&
name|aioerrargs
argument_list|)
expr_stmt|;
name|aio_ret
operator|=
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"aio_error(%p) (Linux: %p) "
literal|"returned %ld%s"
argument_list|,
name|aioerrargs
operator|.
name|aiocbp
argument_list|,
name|preq
operator|->
name|req_porig
argument_list|,
operator|(
name|long
operator|)
name|aio_ret
argument_list|,
name|aio_ret
operator|==
name|EINPROGRESS
condition|?
literal|"(EINPROGRESS)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|aio_ret
operator|==
name|EINPROGRESS
condition|)
continue|continue;
comment|/* Done */
name|LINUX_AIO_REQ_UNHOOK
argument_list|(
name|pctx
argument_list|,
name|preq
argument_list|)
expr_stmt|;
name|aioretargs
operator|.
name|aiocbp
operator|=
name|preq
operator|->
name|req_pbsd
expr_stmt|;
name|aio_err
operator|=
name|p_aio_return
argument_list|(
name|td
argument_list|,
operator|&
name|aioretargs
argument_list|)
expr_stmt|;
name|aio_ret
operator|=
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"aio_return(%p) (Linux: %p) "
literal|"returned %ld, errno=%ld"
argument_list|,
name|aioretargs
operator|.
name|aiocbp
argument_list|,
name|preq
operator|->
name|req_porig
argument_list|,
operator|(
name|long
operator|)
name|aio_ret
argument_list|,
operator|(
name|long
operator|)
name|aio_err
argument_list|)
expr_stmt|;
name|evt
operator|.
name|data
operator|=
name|preq
operator|->
name|req_linux
operator|.
name|aio_data
expr_stmt|;
name|evt
operator|.
name|obj
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|unsigned
name|long
operator|)
name|preq
operator|->
name|req_porig
expr_stmt|;
if|if
condition|(
name|aio_ret
operator|>=
literal|0
condition|)
block|{
comment|/* Normal return (success) */
name|evt
operator|.
name|res
operator|=
name|aio_ret
expr_stmt|;
block|}
else|else
block|{
comment|/* Error code (failure) */
comment|/* 					 * Translate FreeBSD error code 					 * to Linux's 					 */
name|evt
operator|.
name|res
operator|=
name|p
operator|->
name|p_sysent
operator|->
name|sv_errtbl
index|[
name|aio_err
index|]
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
literal|"context %p (Linux: %p): "
literal|"io_event.res=%lld"
argument_list|,
name|preq
operator|->
name|req_pbsd
argument_list|,
name|preq
operator|->
name|req_porig
argument_list|,
operator|(
name|long
name|long
operator|)
name|evt
operator|.
name|res
argument_list|)
expr_stmt|;
name|evt
operator|.
name|res2
operator|=
literal|0
expr_stmt|;
name|copyout
argument_list|(
operator|&
name|evt
argument_list|,
operator|&
operator|(
name|args
operator|->
name|events
index|[
name|i
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|evt
argument_list|)
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|linux_aio_request_zone
argument_list|,
name|preq
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
comment|/* End of collecting all finished requests */
if|if
condition|(
name|STAILQ_EMPTY
argument_list|(
operator|&
operator|(
name|pctx
operator|->
name|ctx_req
operator|)
argument_list|)
condition|)
block|{
comment|/* No request remained in this context */
name|DPRINTF
argument_list|(
literal|"returning(context %p): "
literal|"request queue is empty"
argument_list|,
name|pctx
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|args
operator|->
name|nr
condition|)
block|{
comment|/* Full */
name|DPRINTF
argument_list|(
literal|"returning(context %p): user space "
literal|"event array is full"
argument_list|,
name|pctx
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|>=
name|args
operator|->
name|min_nr
condition|)
block|{
comment|/* Met the minimum requirement */
name|DPRINTF
argument_list|(
literal|"returning(context %p): "
literal|"met the minimum requirement"
argument_list|,
name|pctx
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|args
operator|->
name|timeout
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|timespecisset
argument_list|(
operator|&
name|timeout
argument_list|)
condition|)
block|{
comment|/* Timed out */
name|DPRINTF
argument_list|(
literal|"returning(context %p): "
literal|"no time remaining"
argument_list|,
name|pctx
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|args
operator|->
name|timeout
operator|!=
name|NULL
condition|)
block|{
name|nanouptime
argument_list|(
operator|&
name|t1
argument_list|)
expr_stmt|;
comment|/* Time before aio_suspend() */
name|DUMP_TIMESPEC
argument_list|(
literal|"T1: "
argument_list|,
operator|&
name|t1
argument_list|,
literal|" (uptime before calling aio_suspend())"
argument_list|)
expr_stmt|;
block|}
comment|/* Prepare arguments for aio_suspend() */
name|j
operator|=
literal|0
expr_stmt|;
name|LINUX_AIO_REQ_FOREACH
argument_list|(
argument|pctx
argument_list|,
argument|preq
argument_list|)
block|{
name|copyout
argument_list|(
operator|&
operator|(
name|preq
operator|->
name|req_pbsd
operator|)
argument_list|,
operator|&
operator|(
name|u_aiocbp
index|[
name|j
index|]
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|preq
operator|->
name|req_pbsd
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
name|MPASS
argument_list|(
name|j
operator|==
name|pctx
operator|->
name|ctx_nreq_cur
argument_list|)
expr_stmt|;
name|aiosusargs
operator|.
name|aiocbp
operator|=
name|u_aiocbp
expr_stmt|;
name|aiosusargs
operator|.
name|nent
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|timeout
operator|!=
name|NULL
condition|)
block|{
name|copyout
argument_list|(
operator|&
name|timeout
argument_list|,
name|u_ptimeout
argument_list|,
sizeof|sizeof
argument_list|(
name|timeout
argument_list|)
argument_list|)
expr_stmt|;
name|aiosusargs
operator|.
name|timeout
operator|=
name|u_ptimeout
expr_stmt|;
name|DUMP_TIMESPEC
argument_list|(
literal|"Time remained: "
argument_list|,
operator|&
name|timeout
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aiosusargs
operator|.
name|timeout
operator|=
name|NULL
expr_stmt|;
block|}
name|aio_err
operator|=
name|p_aio_suspend
argument_list|(
name|td
argument_list|,
operator|&
name|aiosusargs
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"aio_suspend(%p, %d, %p) returned %ld"
argument_list|,
name|aiosusargs
operator|.
name|aiocbp
argument_list|,
name|aiosusargs
operator|.
name|nent
argument_list|,
name|aiosusargs
operator|.
name|timeout
argument_list|,
operator|(
name|long
operator|)
name|aio_err
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|timeout
operator|!=
name|NULL
condition|)
block|{
name|nanouptime
argument_list|(
operator|&
name|t2
argument_list|)
expr_stmt|;
comment|/* Time after aio_suspend() */
name|DUMP_TIMESPEC
argument_list|(
literal|"T2: "
argument_list|,
operator|&
name|t2
argument_list|,
literal|" (uptime after calling aio_suspend())"
argument_list|)
expr_stmt|;
name|timespecsub
argument_list|(
operator|&
name|t2
argument_list|,
operator|&
name|t1
argument_list|)
expr_stmt|;
comment|/* 							* Time spent by 							* aio_suspend() 							*/
name|DUMP_TIMESPEC
argument_list|(
literal|"T_delta: "
argument_list|,
operator|&
name|t2
argument_list|,
literal|" (time spent by calling aio_suspend())"
argument_list|)
expr_stmt|;
if|if
condition|(
name|timespeccmp
argument_list|(
operator|&
name|t2
argument_list|,
operator|&
name|timeout
argument_list|,
operator|>=
argument_list|)
condition|)
block|{
name|timespecclear
argument_list|(
operator|&
name|timeout
argument_list|)
expr_stmt|;
comment|/* Timed out */
block|}
else|else
block|{
name|timespecsub
argument_list|(
operator|&
name|timeout
argument_list|,
operator|&
name|t2
argument_list|)
expr_stmt|;
comment|/* Time remaining */
block|}
name|DUMP_TIMESPEC
argument_list|(
literal|"Time remained: "
argument_list|,
operator|&
name|timeout
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aio_err
operator|==
name|EAGAIN
condition|)
block|{
comment|/* Timed out */
name|DPRINTF
argument_list|(
literal|"returning(context %p): "
literal|"timed out after calling aio_suspend()"
argument_list|,
name|pctx
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/*  		   * End of collecting finished requests 		   * and waiting for queued requests 		   */
name|l_timeout
operator|.
name|tv_sec
operator|=
name|timeout
operator|.
name|tv_sec
expr_stmt|;
name|l_timeout
operator|.
name|tv_nsec
operator|=
name|timeout
operator|.
name|tv_nsec
expr_stmt|;
name|copyout
argument_list|(
operator|&
name|l_timeout
argument_list|,
name|args
operator|->
name|timeout
argument_list|,
sizeof|sizeof
argument_list|(
name|l_timeout
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No matter whether successfully or not */
name|nerr
operator|=
name|user_free
argument_list|(
name|td
argument_list|,
name|u_ptimeout
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|u_ptimeout
argument_list|)
argument_list|)
expr_stmt|;
name|skip_substantial_1
label|:
name|nerr
operator|=
name|user_free
argument_list|(
name|td
argument_list|,
name|u_aiocbp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|u_aiocbp
argument_list|)
operator|*
name|pctx
operator|->
name|ctx_nreq_max
argument_list|)
expr_stmt|;
name|skip_substantial_0
label|:
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
comment|/* user_free() resets td->td_retval[0] to 0 */
name|DPRINTF
argument_list|(
literal|"%d requests are unhooked from the context %p"
argument_list|,
name|i
argument_list|,
name|pctx
argument_list|)
expr_stmt|;
block|}
comment|/* End of dealing with request queue */
name|LINUX_AIO_CTX_UNLOCK
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|nerr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Linux system call io_submit(2) */
end_comment

begin_function
name|int
name|linux_io_submit
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_io_submit_args
modifier|*
name|args
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|nerr
init|=
literal|0
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|linux_aio_context
modifier|*
name|pctx
decl_stmt|;
name|struct
name|linux_aio_request
name|req
decl_stmt|,
modifier|*
name|preq
decl_stmt|;
name|struct
name|linux_iocb
modifier|*
name|porig
decl_stmt|;
name|struct
name|aiocb
name|iocb
decl_stmt|,
modifier|*
name|piocb
decl_stmt|;
name|DARGPRINTF
argument_list|(
literal|"%lx, %ld, %p"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|args
operator|->
name|ctx_id
argument_list|,
operator|(
name|long
operator|)
name|args
operator|->
name|nr
argument_list|,
name|args
operator|->
name|iocbpp
argument_list|)
expr_stmt|;
name|LINK_TO_NATIVE_AIO_MODULE
argument_list|()
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|nr
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
comment|/* 	 * Locking: 	 * 	 * LINUX_AIO_LOCK(p);<----------------+ 	 * ...                                   | 	 *     LINUX_AIO_CTX_LIST_LOCK();<--+ | 	 *     ...                             | | 	 *     LINUX_AIO_CTX_LIST_UNLOCK();<--+ | 	 * ...                                   | 	 * LINUX_AIO_CTX_LOCK(pctx);<---------|---+ 	 * LINUX_AIO_UNLOCK(p);<----------------+   | 	 * ...                                       | 	 * LINUX_AIO_CTX_UNLOCK(pctx);<-------------+ 	 */
name|LINUX_AIO_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Find the context in context list */
name|LINUX_AIO_CTX_LIST_LOCK
argument_list|()
expr_stmt|;
name|LINUX_AIO_CTX_FOREACH
argument_list|(
argument|pctx
argument_list|)
block|{
if|if
condition|(
name|LINUX_AIO_CTX_MATCH
argument_list|(
name|pctx
argument_list|,
name|args
operator|->
name|ctx_id
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
condition|)
break|break;
block|}
name|LINUX_AIO_CTX_LIST_UNLOCK
argument_list|()
expr_stmt|;
comment|/* Unable to find the context */
if|if
condition|(
name|pctx
operator|==
name|NULL
condition|)
block|{
name|LINUX_AIO_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|DPRINTF
argument_list|(
literal|"Found the context: %lx -> %p"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|args
operator|->
name|ctx_id
argument_list|,
name|pctx
argument_list|)
expr_stmt|;
name|LINUX_AIO_CTX_LOCK
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
comment|/* XXX Interlaced, seamless */
name|LINUX_AIO_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* XXX Interlaced, seamless */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|pctx
operator|->
name|ctx_nreq_cur
operator|<
name|pctx
operator|->
name|ctx_nreq_max
operator|&&
name|i
operator|<
name|args
operator|->
name|nr
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get user space Linux control block  */
name|nerr
operator|=
name|copyin
argument_list|(
operator|&
operator|(
name|args
operator|->
name|iocbpp
index|[
name|i
index|]
operator|)
argument_list|,
operator|&
name|porig
argument_list|,
sizeof|sizeof
argument_list|(
name|porig
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
operator|!=
literal|0
condition|)
break|break;
name|nerr
operator|=
name|copyin
argument_list|(
name|porig
argument_list|,
operator|&
operator|(
name|req
operator|.
name|req_linux
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|req
operator|.
name|req_linux
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
operator|!=
literal|0
condition|)
break|break;
comment|/* Create user space FreeBSD control block clone */
name|nerr
operator|=
name|iocb_reformat
argument_list|(
operator|&
operator|(
name|req
operator|.
name|req_linux
operator|)
argument_list|,
operator|&
name|iocb
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
operator|!=
literal|0
condition|)
break|break;
name|nerr
operator|=
name|user_malloc
argument_list|(
name|td
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|piocb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|piocb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
operator|!=
literal|0
condition|)
break|break;
name|nerr
operator|=
name|copyout
argument_list|(
operator|&
name|iocb
argument_list|,
name|piocb
argument_list|,
sizeof|sizeof
argument_list|(
name|iocb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
operator|!=
literal|0
condition|)
break|break;
name|DUMP_FREEBSD_AIOCB
argument_list|(
name|piocb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Submit user space control block */
name|nerr
operator|=
name|p_aio_aqueue
argument_list|(
name|td
argument_list|,
name|piocb
argument_list|,
name|NULL
argument_list|,
name|iocb
operator|.
name|aio_lio_opcode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
operator|!=
literal|0
condition|)
block|{
name|user_free
argument_list|(
name|td
argument_list|,
name|piocb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|piocb
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|req
operator|.
name|req_porig
operator|=
name|porig
expr_stmt|;
name|req
operator|.
name|req_pbsd
operator|=
name|piocb
expr_stmt|;
comment|/* Hook request to the context */
name|preq
operator|=
name|uma_zalloc
argument_list|(
name|linux_aio_request_zone
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|preq
argument_list|,
operator|&
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|req
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"Linux IOCB %p (aio_lio_opcode=%u, aio_fildes=%u), "
literal|"FreeBSD IOCB %p"
argument_list|,
name|preq
operator|->
name|req_porig
argument_list|,
operator|(
name|unsigned
operator|)
name|preq
operator|->
name|req_linux
operator|.
name|aio_lio_opcode
argument_list|,
operator|(
name|unsigned
operator|)
name|preq
operator|->
name|req_linux
operator|.
name|aio_fildes
argument_list|,
name|preq
operator|->
name|req_pbsd
argument_list|)
expr_stmt|;
name|LINUX_AIO_REQ_HOOK
argument_list|(
name|pctx
argument_list|,
name|preq
argument_list|)
expr_stmt|;
block|}
name|LINUX_AIO_CTX_UNLOCK
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
name|nerr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|nerr
operator|==
literal|0
condition|)
name|nerr
operator|=
name|EAGAIN
expr_stmt|;
comment|/* No request is successfully submitted */
return|return
operator|(
name|nerr
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Linux system call io_cancel(2) */
end_comment

begin_function
name|int
name|linux_io_cancel
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_io_cancel_args
modifier|*
name|args
parameter_list|)
block|{
name|int
name|nerr
init|=
literal|0
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|linux_iocb
name|lcb
decl_stmt|;
name|struct
name|linux_aio_context
modifier|*
name|pctx
decl_stmt|;
name|struct
name|linux_aio_request
modifier|*
name|preq
decl_stmt|;
name|struct
name|linux_io_event
name|evt
decl_stmt|;
name|struct
name|aio_cancel_args
name|aiocnclargs
decl_stmt|;
name|DARGPRINTF
argument_list|(
literal|"%lx, %p, %p"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|args
operator|->
name|ctx_id
argument_list|,
name|args
operator|->
name|iocb
argument_list|,
name|args
operator|->
name|result
argument_list|)
expr_stmt|;
name|LINK_TO_NATIVE_AIO_MODULE
argument_list|()
expr_stmt|;
name|nerr
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|iocb
argument_list|,
operator|&
name|lcb
argument_list|,
sizeof|sizeof
argument_list|(
name|lcb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
operator|!=
literal|0
condition|)
return|return
operator|(
name|nerr
operator|)
return|;
name|nerr
operator|=
name|user_mem_rw_verify
argument_list|(
name|args
operator|->
name|result
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|args
operator|->
name|result
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerr
operator|!=
literal|0
condition|)
return|return
operator|(
name|nerr
operator|)
return|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
comment|/* 	 * Locking: 	 * 	 * LINUX_AIO_LOCK(p);<----------------+ 	 * ...                                   | 	 *     LINUX_AIO_CTX_LIST_LOCK();<--+ | 	 *     ...                             | | 	 *     LINUX_AIO_CTX_LIST_UNLOCK();<--+ | 	 * ...                                   | 	 * LINUX_AIO_CTX_LOCK(pctx);<---------|---+ 	 * LINUX_AIO_UNLOCK(p);<----------------+   | 	 * ...                                       | 	 * LINUX_AIO_CTX_UNLOCK(pctx);<-------------+ 	 */
name|LINUX_AIO_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Find the context in context list */
name|LINUX_AIO_CTX_LIST_LOCK
argument_list|()
expr_stmt|;
name|LINUX_AIO_CTX_FOREACH
argument_list|(
argument|pctx
argument_list|)
block|{
if|if
condition|(
name|LINUX_AIO_CTX_MATCH
argument_list|(
name|pctx
argument_list|,
name|args
operator|->
name|ctx_id
argument_list|,
name|p
operator|->
name|p_pid
argument_list|)
condition|)
break|break;
block|}
name|LINUX_AIO_CTX_LIST_UNLOCK
argument_list|()
expr_stmt|;
comment|/* Unable to find the context */
if|if
condition|(
name|pctx
operator|==
name|NULL
condition|)
block|{
name|LINUX_AIO_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|DPRINTF
argument_list|(
literal|"Found the context: %lx -> %p"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|args
operator|->
name|ctx_id
argument_list|,
name|pctx
argument_list|)
expr_stmt|;
name|LINUX_AIO_CTX_LOCK
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
comment|/* XXX Interlaced, seamless */
name|LINUX_AIO_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* XXX Interlaced, seamless */
name|LINUX_AIO_REQ_FOREACH
argument_list|(
argument|pctx
argument_list|,
argument|preq
argument_list|)
block|{
if|if
condition|(
name|preq
operator|->
name|req_porig
operator|==
name|args
operator|->
name|iocb
operator|&&
name|preq
operator|->
name|req_linux
operator|.
name|aio_key
operator|==
name|lcb
operator|.
name|aio_key
condition|)
break|break;
block|}
if|if
condition|(
name|preq
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
literal|"Unable to find IO control block %p"
argument_list|,
name|args
operator|->
name|iocb
argument_list|)
expr_stmt|;
name|nerr
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
comment|/* Found the request in context */
name|DPRINTF
argument_list|(
literal|"Cancel request (Linux: %p, FreeBSD: %p)"
argument_list|,
name|preq
operator|->
name|req_porig
argument_list|,
name|preq
operator|->
name|req_pbsd
argument_list|)
expr_stmt|;
comment|/* Cancel FreeBSD native clone */
name|aiocnclargs
operator|.
name|fd
operator|=
name|preq
operator|->
name|req_linux
operator|.
name|aio_fildes
expr_stmt|;
name|aiocnclargs
operator|.
name|aiocbp
operator|=
name|preq
operator|->
name|req_pbsd
expr_stmt|;
name|p_aio_cancel
argument_list|(
name|td
argument_list|,
operator|&
name|aiocnclargs
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"aio_cancel() returned %ld"
argument_list|,
operator|(
name|long
operator|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|==
name|AIO_CANCELED
condition|)
block|{
comment|/* Cancellation succeeded */
name|LINUX_AIO_REQ_UNHOOK
argument_list|(
name|pctx
argument_list|,
name|preq
argument_list|)
expr_stmt|;
name|evt
operator|.
name|data
operator|=
name|preq
operator|->
name|req_linux
operator|.
name|aio_data
expr_stmt|;
name|evt
operator|.
name|obj
operator|=
operator|(
name|uint64_t
operator|)
operator|(
name|unsigned
name|long
operator|)
name|preq
operator|->
name|req_porig
expr_stmt|;
name|evt
operator|.
name|res
operator|=
name|p
operator|->
name|p_sysent
operator|->
name|sv_errtbl
index|[
name|ECANCELED
index|]
expr_stmt|;
name|evt
operator|.
name|res2
operator|=
literal|0
expr_stmt|;
comment|/* Fill in user space structure linux_io_event */
name|copyout
argument_list|(
operator|&
name|evt
argument_list|,
name|args
operator|->
name|result
argument_list|,
sizeof|sizeof
argument_list|(
name|evt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Free user space clone of the request */
name|user_free
argument_list|(
name|td
argument_list|,
name|preq
operator|->
name|req_pbsd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|preq
operator|->
name|req_pbsd
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Free kernel structure of the request */
name|uma_zfree
argument_list|(
name|linux_aio_request_zone
argument_list|,
name|preq
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|==
name|AIO_ALLDONE
condition|)
block|{
name|nerr
operator|=
name|EINVAL
expr_stmt|;
comment|/* 					* This value of Linux 2.6.15 					* is really confusing !!! 					*/
block|}
else|else
block|{
comment|/* AIO_NOTCANCELED */
name|nerr
operator|=
name|EAGAIN
expr_stmt|;
block|}
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|LINUX_AIO_CTX_UNLOCK
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|nerr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|linux_aio_proc_rundown
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|linux_aio_context
modifier|*
name|pctx
decl_stmt|,
modifier|*
name|ptmpctx
decl_stmt|;
name|struct
name|linux_aio_request
modifier|*
name|preq
decl_stmt|,
modifier|*
name|ptmpreq
decl_stmt|;
comment|/* 	 * FreeBSD module "aio" can do more essential native cleanup 	 * (i.e. cancelling all queued requests) itself. 	 */
name|LINUX_AIO_CTX_LIST_LOCK
argument_list|()
expr_stmt|;
name|LINUX_AIO_CTX_FOREACH_SAFE
argument_list|(
argument|pctx
argument_list|,
argument|ptmpctx
argument_list|)
block|{
if|if
condition|(
name|pctx
operator|->
name|ctx_pid
operator|==
name|p
operator|->
name|p_pid
condition|)
block|{
name|LINUX_AIO_REQ_FOREACH_SAFE
argument_list|(
argument|pctx
argument_list|,
argument|preq
argument_list|,
argument|ptmpreq
argument_list|)
block|{
name|DPPRINTF
argument_list|(
literal|"Free request %p from context %p "
literal|"(ring: %p)"
argument_list|,
name|preq
argument_list|,
name|pctx
argument_list|,
name|pctx
operator|->
name|ctx_pring
argument_list|)
expr_stmt|;
name|LINUX_AIO_REQ_UNHOOK
argument_list|(
name|pctx
argument_list|,
name|preq
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|linux_aio_request_zone
argument_list|,
name|preq
argument_list|)
expr_stmt|;
block|}
name|DPPRINTF
argument_list|(
literal|"Free context %p (ring: %p)"
argument_list|,
name|pctx
argument_list|,
name|pctx
operator|->
name|ctx_pring
argument_list|)
expr_stmt|;
comment|/* Unhook it from context list */
name|LINUX_AIO_CTX_UNHOOK
argument_list|(
name|pctx
argument_list|)
expr_stmt|;
comment|/* Free it really */
name|sx_destroy
argument_list|(
operator|&
operator|(
name|pctx
operator|->
name|ctx_sx
operator|)
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|linux_aio_context_zone
argument_list|,
name|pctx
argument_list|)
expr_stmt|;
name|DPPRINTF
argument_list|(
literal|"The remaining context list is %s"
argument_list|,
operator|(
name|SLIST_EMPTY
argument_list|(
operator|&
name|linux_aio_context_list
argument_list|)
condition|?
literal|"empty"
else|:
literal|"not empty"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|LINUX_AIO_CTX_LIST_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Module constructor/destructor  */
end_comment

begin_function
specifier|static
name|int
name|linux_aio_modload
parameter_list|(
name|struct
name|module
modifier|*
name|module
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|nerr
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|linux_aio_context_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"LINUXAIOCTX"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|linux_aio_context
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|linux_aio_request_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"LINUXAIOREQ"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|linux_aio_request
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|linux_aio_context_list_mtx
argument_list|,
literal|"linux_aio_context_list"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|linux_aio_context_list
argument_list|)
expr_stmt|;
name|linux_aio_exit_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|process_exit
argument_list|,
name|linux_aio_proc_rundown
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|LINUX_AIO_CTX_LIST_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|linux_aio_context_list
argument_list|)
condition|)
block|{
name|nerr
operator|=
name|EBUSY
expr_stmt|;
name|LINUX_AIO_CTX_LIST_UNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|process_exit
argument_list|,
name|linux_aio_exit_tag
argument_list|)
expr_stmt|;
name|LINUX_AIO_CTX_LIST_UNLOCK
argument_list|()
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|linux_aio_context_list_mtx
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|linux_aio_request_zone
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|linux_aio_context_zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|native_aio_module_handle
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * linker_release_module() cannot be used here. 			 * It tries to hold "kld_sx", conflicting against 			 * module_unload(). 			 */
name|linker_file_unload
argument_list|(
name|native_aio_module_handle
argument_list|,
name|LINKER_UNLOAD_NORMAL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MOD_SHUTDOWN
case|:
break|break;
default|default:
name|nerr
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|nerr
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|linux_aio_mod
init|=
block|{
literal|"linuxaio"
block|,
operator|&
name|linux_aio_modload
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|linuxaio
argument_list|,
name|linux_aio_mod
argument_list|,
name|SI_SUB_VFS
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

