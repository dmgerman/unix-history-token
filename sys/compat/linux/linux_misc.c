begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002 Doug Rabson  * Copyright (c) 1994-1995 SÃ¸ren Schmidt  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_mac.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/blist.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/imgact_aout.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/swap_pager.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_sysproto.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_emul.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_misc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_LINUX32
end_ifdef

begin_include
include|#
directive|include
file|<machine/../linux32/linux.h>
end_include

begin_include
include|#
directive|include
file|<machine/../linux32/linux32_proto.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<machine/../linux/linux.h>
end_include

begin_include
include|#
directive|include
file|<machine/../linux/linux_proto.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<compat/linux/linux_mib.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_signal.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_util.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_include
include|#
directive|include
file|<machine/cputypes.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BSD_TO_LINUX_SIGNAL
parameter_list|(
name|sig
parameter_list|)
define|\
value|(((sig)<= LINUX_SIGTBLSZ) ? bsd_to_linux_signal[_SIG_IDX(sig)] : sig)
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|linux_to_bsd_resource
index|[
name|LINUX_RLIM_NLIMITS
index|]
init|=
block|{
name|RLIMIT_CPU
block|,
name|RLIMIT_FSIZE
block|,
name|RLIMIT_DATA
block|,
name|RLIMIT_STACK
block|,
name|RLIMIT_CORE
block|,
name|RLIMIT_RSS
block|,
name|RLIMIT_NPROC
block|,
name|RLIMIT_NOFILE
block|,
name|RLIMIT_MEMLOCK
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|l_sysinfo
block|{
name|l_long
name|uptime
decl_stmt|;
comment|/* Seconds since boot */
name|l_ulong
name|loads
index|[
literal|3
index|]
decl_stmt|;
comment|/* 1, 5, and 15 minute load averages */
define|#
directive|define
name|LINUX_SYSINFO_LOADS_SCALE
value|65536
name|l_ulong
name|totalram
decl_stmt|;
comment|/* Total usable main memory size */
name|l_ulong
name|freeram
decl_stmt|;
comment|/* Available memory size */
name|l_ulong
name|sharedram
decl_stmt|;
comment|/* Amount of shared memory */
name|l_ulong
name|bufferram
decl_stmt|;
comment|/* Memory used by buffers */
name|l_ulong
name|totalswap
decl_stmt|;
comment|/* Total swap space size */
name|l_ulong
name|freeswap
decl_stmt|;
comment|/* swap space still available */
name|l_ushort
name|procs
decl_stmt|;
comment|/* Number of current processes */
name|l_ushort
name|pads
decl_stmt|;
name|l_ulong
name|totalbig
decl_stmt|;
name|l_ulong
name|freebig
decl_stmt|;
name|l_uint
name|mem_unit
decl_stmt|;
name|char
name|_f
index|[
literal|20
operator|-
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|l_long
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|l_int
argument_list|)
index|]
decl_stmt|;
comment|/* padding */
block|}
struct|;
end_struct

begin_function
name|int
name|linux_sysinfo
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_sysinfo_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|l_sysinfo
name|sysinfo
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|getnanouptime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|.
name|tv_nsec
operator|!=
literal|0
condition|)
name|ts
operator|.
name|tv_sec
operator|++
expr_stmt|;
name|sysinfo
operator|.
name|uptime
operator|=
name|ts
operator|.
name|tv_sec
expr_stmt|;
comment|/* Use the information from the mib to get our load averages */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|sysinfo
operator|.
name|loads
index|[
name|i
index|]
operator|=
name|averunnable
operator|.
name|ldavg
index|[
name|i
index|]
operator|*
name|LINUX_SYSINFO_LOADS_SCALE
operator|/
name|averunnable
operator|.
name|fscale
expr_stmt|;
name|sysinfo
operator|.
name|totalram
operator|=
name|physmem
operator|*
name|PAGE_SIZE
expr_stmt|;
name|sysinfo
operator|.
name|freeram
operator|=
name|sysinfo
operator|.
name|totalram
operator|-
name|cnt
operator|.
name|v_wire_count
operator|*
name|PAGE_SIZE
expr_stmt|;
name|sysinfo
operator|.
name|sharedram
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|vm_object_list_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|object
argument_list|,
argument|&vm_object_list
argument_list|,
argument|object_list
argument_list|)
if|if
condition|(
name|object
operator|->
name|shadow_count
operator|>
literal|1
condition|)
name|sysinfo
operator|.
name|sharedram
operator|+=
name|object
operator|->
name|resident_page_count
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|vm_object_list_mtx
argument_list|)
expr_stmt|;
name|sysinfo
operator|.
name|sharedram
operator|*=
name|PAGE_SIZE
expr_stmt|;
name|sysinfo
operator|.
name|bufferram
operator|=
literal|0
expr_stmt|;
name|swap_pager_status
argument_list|(
operator|&
name|i
argument_list|,
operator|&
name|j
argument_list|)
expr_stmt|;
name|sysinfo
operator|.
name|totalswap
operator|=
name|i
operator|*
name|PAGE_SIZE
expr_stmt|;
name|sysinfo
operator|.
name|freeswap
operator|=
operator|(
name|i
operator|-
name|j
operator|)
operator|*
name|PAGE_SIZE
expr_stmt|;
name|sysinfo
operator|.
name|procs
operator|=
name|nprocs
expr_stmt|;
comment|/* The following are only present in newer Linux kernels. */
name|sysinfo
operator|.
name|totalbig
operator|=
literal|0
expr_stmt|;
name|sysinfo
operator|.
name|freebig
operator|=
literal|0
expr_stmt|;
name|sysinfo
operator|.
name|mem_unit
operator|=
literal|1
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|sysinfo
argument_list|,
name|args
operator|->
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|sysinfo
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|linux_alarm
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_alarm_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|itimerval
name|it
decl_stmt|,
name|old_it
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|alarm
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|alarm
argument_list|,
literal|"%u"
argument_list|)
argument_list|,
name|args
operator|->
name|secs
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|secs
operator|>
literal|100000000
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|it
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
operator|(
name|long
operator|)
name|args
operator|->
name|secs
expr_stmt|;
name|it
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|it
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|it
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|kern_setitimer
argument_list|(
name|td
argument_list|,
name|ITIMER_REAL
argument_list|,
operator|&
name|it
argument_list|,
operator|&
name|old_it
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|timevalisset
argument_list|(
operator|&
name|old_it
operator|.
name|it_value
argument_list|)
condition|)
block|{
if|if
condition|(
name|old_it
operator|.
name|it_value
operator|.
name|tv_usec
operator|!=
literal|0
condition|)
name|old_it
operator|.
name|it_value
operator|.
name|tv_sec
operator|++
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|old_it
operator|.
name|it_value
operator|.
name|tv_sec
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_brk
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_brk_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|vmspace
modifier|*
name|vm
init|=
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
decl_stmt|;
name|vm_offset_t
name|new
decl_stmt|,
name|old
decl_stmt|;
name|struct
name|obreak_args
comment|/* { 		char * nsize; 	} */
name|tmp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|brk
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|brk
argument_list|,
literal|"%p"
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|args
operator|->
name|dsend
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|old
operator|=
operator|(
name|vm_offset_t
operator|)
name|vm
operator|->
name|vm_daddr
operator|+
name|ctob
argument_list|(
name|vm
operator|->
name|vm_dsize
argument_list|)
expr_stmt|;
name|new
operator|=
operator|(
name|vm_offset_t
operator|)
name|args
operator|->
name|dsend
expr_stmt|;
name|tmp
operator|.
name|nsize
operator|=
operator|(
name|char
operator|*
operator|)
name|new
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|caddr_t
operator|)
name|new
operator|>
name|vm
operator|->
name|vm_daddr
operator|)
operator|&&
operator|!
name|obreak
argument_list|(
name|td
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
operator|(
name|long
operator|)
name|new
expr_stmt|;
else|else
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
operator|(
name|long
operator|)
name|old
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_comment
comment|/* XXX: what about amd64/linux32? */
end_comment

begin_function
name|int
name|linux_uselib
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_uselib_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|nameidata
name|ni
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|exec
modifier|*
name|a_out
decl_stmt|;
name|struct
name|vattr
name|attr
decl_stmt|;
name|vm_offset_t
name|vmaddr
decl_stmt|;
name|unsigned
name|long
name|file_offset
decl_stmt|;
name|vm_offset_t
name|buffer
decl_stmt|;
name|unsigned
name|long
name|bss_size
decl_stmt|;
name|char
modifier|*
name|library
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|locked
decl_stmt|,
name|vfslocked
decl_stmt|;
name|LCONVPATHEXIST
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|library
argument_list|,
operator|&
name|library
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|uselib
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|uselib
argument_list|,
literal|"%s"
argument_list|)
argument_list|,
name|library
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|a_out
operator|=
name|NULL
expr_stmt|;
name|vfslocked
operator|=
literal|0
expr_stmt|;
name|locked
operator|=
literal|0
expr_stmt|;
name|vp
operator|=
name|NULL
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|ni
argument_list|,
name|LOOKUP
argument_list|,
name|ISOPEN
operator||
name|FOLLOW
operator||
name|LOCKLEAF
operator||
name|MPSAFE
operator||
name|AUDITVNODE1
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|library
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|ni
argument_list|)
expr_stmt|;
name|LFREEPATH
argument_list|(
name|library
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
name|vp
operator|=
name|ni
operator|.
name|ni_vp
expr_stmt|;
name|vfslocked
operator|=
name|NDHASGIANT
argument_list|(
operator|&
name|ni
argument_list|)
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|ni
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
comment|/* 	 * From here on down, we have a locked vnode that must be unlocked. 	 * XXX: The code below largely duplicates exec_check_permissions(). 	 */
name|locked
operator|=
literal|1
expr_stmt|;
comment|/* Writable? */
if|if
condition|(
name|vp
operator|->
name|v_writecount
condition|)
block|{
name|error
operator|=
name|ETXTBSY
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Executable? */
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|attr
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_NOEXEC
operator|)
operator|||
operator|(
operator|(
name|attr
operator|.
name|va_mode
operator|&
literal|0111
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|attr
operator|.
name|va_type
operator|!=
name|VREG
operator|)
condition|)
block|{
comment|/* EACCESS is what exec(2) returns. */
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Sensible size? */
if|if
condition|(
name|attr
operator|.
name|va_size
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Can we access it? */
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VEXEC
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 	 * XXX: This should use vn_open() so that it is properly authorized, 	 * and to reduce code redundancy all over the place here. 	 * XXX: Not really, it duplicates far more of exec_check_permissions() 	 * than vn_open(). 	 */
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_vnode_open
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|vp
argument_list|,
name|FREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
endif|#
directive|endif
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|vp
argument_list|,
name|FREAD
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Pull in executable header into kernel_map */
name|error
operator|=
name|vm_mmap
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|a_out
argument_list|,
name|PAGE_SIZE
argument_list|,
name|VM_PROT_READ
argument_list|,
name|VM_PROT_READ
argument_list|,
literal|0
argument_list|,
name|OBJT_VNODE
argument_list|,
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Is it a Linux binary ? */
if|if
condition|(
operator|(
operator|(
name|a_out
operator|->
name|a_magic
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator|!=
literal|0x64
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * While we are here, we should REALLY do some more checks 	 */
comment|/* Set file/virtual offset based on a.out variant. */
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
name|a_out
operator|->
name|a_magic
operator|&
literal|0xffff
argument_list|)
condition|)
block|{
case|case
literal|0413
case|:
comment|/* ZMAGIC */
name|file_offset
operator|=
literal|1024
expr_stmt|;
break|break;
case|case
literal|0314
case|:
comment|/* QMAGIC */
name|file_offset
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|bss_size
operator|=
name|round_page
argument_list|(
name|a_out
operator|->
name|a_bss
argument_list|)
expr_stmt|;
comment|/* Check various fields in header for validity/bounds. */
if|if
condition|(
name|a_out
operator|->
name|a_text
operator|&
name|PAGE_MASK
operator|||
name|a_out
operator|->
name|a_data
operator|&
name|PAGE_MASK
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* text + data can't exceed file size */
if|if
condition|(
name|a_out
operator|->
name|a_data
operator|+
name|a_out
operator|->
name|a_text
operator|>
name|attr
operator|.
name|va_size
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * text/data/bss must not exceed limits 	 * XXX - this is not complete. it should check current usage PLUS 	 * the resources needed by this library. 	 */
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_out
operator|->
name|a_text
operator|>
name|maxtsiz
operator|||
name|a_out
operator|->
name|a_data
operator|+
name|bss_size
operator|>
name|lim_cur
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|RLIMIT_DATA
argument_list|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
comment|/* 	 * Prevent more writers. 	 * XXX: Note that if any of the VM operations fail below we don't 	 * clear this flag. 	 */
name|vp
operator|->
name|v_vflag
operator||=
name|VV_TEXT
expr_stmt|;
comment|/* 	 * Lock no longer needed 	 */
name|locked
operator|=
literal|0
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
comment|/* 	 * Check if file_offset page aligned. Currently we cannot handle 	 * misalinged file offsets, and so we read in the entire image 	 * (what a waste). 	 */
if|if
condition|(
name|file_offset
operator|&
name|PAGE_MASK
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"uselib: Non page aligned binary %lu\n"
argument_list|,
name|file_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Map text+data read/write/execute */
comment|/* a_entry is the load address and is page aligned */
name|vmaddr
operator|=
name|trunc_page
argument_list|(
name|a_out
operator|->
name|a_entry
argument_list|)
expr_stmt|;
comment|/* get anon user mapping, read+write+execute */
name|error
operator|=
name|vm_map_find
argument_list|(
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|vmaddr
argument_list|,
name|a_out
operator|->
name|a_text
operator|+
name|a_out
operator|->
name|a_data
argument_list|,
name|FALSE
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
comment|/* map file into kernel_map */
name|error
operator|=
name|vm_mmap
argument_list|(
name|kernel_map
argument_list|,
operator|&
name|buffer
argument_list|,
name|round_page
argument_list|(
name|a_out
operator|->
name|a_text
operator|+
name|a_out
operator|->
name|a_data
operator|+
name|file_offset
argument_list|)
argument_list|,
name|VM_PROT_READ
argument_list|,
name|VM_PROT_READ
argument_list|,
literal|0
argument_list|,
name|OBJT_VNODE
argument_list|,
name|vp
argument_list|,
name|trunc_page
argument_list|(
name|file_offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
comment|/* copy from kernel VM space to user space */
name|error
operator|=
name|copyout
argument_list|(
name|PTRIN
argument_list|(
name|buffer
operator|+
name|file_offset
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vmaddr
argument_list|,
name|a_out
operator|->
name|a_text
operator|+
name|a_out
operator|->
name|a_data
argument_list|)
expr_stmt|;
comment|/* release temporary kernel space */
name|vm_map_remove
argument_list|(
name|kernel_map
argument_list|,
name|buffer
argument_list|,
name|buffer
operator|+
name|round_page
argument_list|(
name|a_out
operator|->
name|a_text
operator|+
name|a_out
operator|->
name|a_data
operator|+
name|file_offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"uselib: Page aligned binary %lu\n"
argument_list|,
name|file_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * for QMAGIC, a_entry is 20 bytes beyond the load address 		 * to skip the executable header 		 */
name|vmaddr
operator|=
name|trunc_page
argument_list|(
name|a_out
operator|->
name|a_entry
argument_list|)
expr_stmt|;
comment|/* 		 * Map it all into the process's space as a single 		 * copy-on-write "data" segment. 		 */
name|error
operator|=
name|vm_mmap
argument_list|(
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
operator|&
name|vmaddr
argument_list|,
name|a_out
operator|->
name|a_text
operator|+
name|a_out
operator|->
name|a_data
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_FIXED
argument_list|,
name|OBJT_VNODE
argument_list|,
name|vp
argument_list|,
name|file_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"mem=%08lx = %08lx %08lx\n"
argument_list|,
operator|(
name|long
operator|)
name|vmaddr
argument_list|,
operator|(
operator|(
name|long
operator|*
operator|)
name|vmaddr
operator|)
index|[
literal|0
index|]
argument_list|,
operator|(
operator|(
name|long
operator|*
operator|)
name|vmaddr
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bss_size
operator|!=
literal|0
condition|)
block|{
comment|/* Calculate BSS start address */
name|vmaddr
operator|=
name|trunc_page
argument_list|(
name|a_out
operator|->
name|a_entry
argument_list|)
operator|+
name|a_out
operator|->
name|a_text
operator|+
name|a_out
operator|->
name|a_data
expr_stmt|;
comment|/* allocate some 'anon' space */
name|error
operator|=
name|vm_map_find
argument_list|(
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|vmaddr
argument_list|,
name|bss_size
argument_list|,
name|FALSE
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
block|}
name|cleanup
label|:
comment|/* Unlock vnode if needed */
if|if
condition|(
name|locked
condition|)
block|{
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vfslocked
argument_list|)
expr_stmt|;
block|}
comment|/* Release the kernel mapping. */
if|if
condition|(
name|a_out
condition|)
name|vm_map_remove
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|a_out
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|a_out
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __i386__ */
end_comment

begin_function
name|int
name|linux_select
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_select_args
modifier|*
name|args
parameter_list|)
block|{
name|l_timeval
name|ltv
decl_stmt|;
name|struct
name|timeval
name|tv0
decl_stmt|,
name|tv1
decl_stmt|,
name|utv
decl_stmt|,
modifier|*
name|tvp
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|select
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|select
argument_list|,
literal|"%d, %p, %p, %p, %p"
argument_list|)
argument_list|,
name|args
operator|->
name|nfds
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|readfds
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|writefds
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|exceptfds
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|timeout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Store current time for computation of the amount of 	 * time left. 	 */
if|if
condition|(
name|args
operator|->
name|timeout
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|timeout
argument_list|,
operator|&
name|ltv
argument_list|,
sizeof|sizeof
argument_list|(
name|ltv
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|select_out
goto|;
name|utv
operator|.
name|tv_sec
operator|=
name|ltv
operator|.
name|tv_sec
expr_stmt|;
name|utv
operator|.
name|tv_usec
operator|=
name|ltv
operator|.
name|tv_usec
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|select
argument_list|)
condition|)
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"incoming timeout (%jd/%ld)"
argument_list|)
argument_list|,
operator|(
name|intmax_t
operator|)
name|utv
operator|.
name|tv_sec
argument_list|,
name|utv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|itimerfix
argument_list|(
operator|&
name|utv
argument_list|)
condition|)
block|{
comment|/* 			 * The timeval was invalid.  Convert it to something 			 * valid that will act as it does under Linux. 			 */
name|utv
operator|.
name|tv_sec
operator|+=
name|utv
operator|.
name|tv_usec
operator|/
literal|1000000
expr_stmt|;
name|utv
operator|.
name|tv_usec
operator|%=
literal|1000000
expr_stmt|;
if|if
condition|(
name|utv
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|utv
operator|.
name|tv_sec
operator|-=
literal|1
expr_stmt|;
name|utv
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
if|if
condition|(
name|utv
operator|.
name|tv_sec
operator|<
literal|0
condition|)
name|timevalclear
argument_list|(
operator|&
name|utv
argument_list|)
expr_stmt|;
block|}
name|microtime
argument_list|(
operator|&
name|tv0
argument_list|)
expr_stmt|;
name|tvp
operator|=
operator|&
name|utv
expr_stmt|;
block|}
else|else
name|tvp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|kern_select
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|nfds
argument_list|,
name|args
operator|->
name|readfds
argument_list|,
name|args
operator|->
name|writefds
argument_list|,
name|args
operator|->
name|exceptfds
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|select
argument_list|)
condition|)
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"real select returns %d"
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * See fs/select.c in the Linux kernel.  Without this, 		 * Maelstrom doesn't work. 		 */
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|select_out
goto|;
block|}
if|if
condition|(
name|args
operator|->
name|timeout
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
condition|)
block|{
comment|/* 			 * Compute how much time was left of the timeout, 			 * by subtracting the current time and the time 			 * before we started the call, and subtracting 			 * that result from the user-supplied value. 			 */
name|microtime
argument_list|(
operator|&
name|tv1
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|tv1
argument_list|,
operator|&
name|tv0
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|utv
argument_list|,
operator|&
name|tv1
argument_list|)
expr_stmt|;
if|if
condition|(
name|utv
operator|.
name|tv_sec
operator|<
literal|0
condition|)
name|timevalclear
argument_list|(
operator|&
name|utv
argument_list|)
expr_stmt|;
block|}
else|else
name|timevalclear
argument_list|(
operator|&
name|utv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|select
argument_list|)
condition|)
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"outgoing timeout (%jd/%ld)"
argument_list|)
argument_list|,
operator|(
name|intmax_t
operator|)
name|utv
operator|.
name|tv_sec
argument_list|,
name|utv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ltv
operator|.
name|tv_sec
operator|=
name|utv
operator|.
name|tv_sec
expr_stmt|;
name|ltv
operator|.
name|tv_usec
operator|=
name|utv
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|ltv
argument_list|,
name|args
operator|->
name|timeout
argument_list|,
sizeof|sizeof
argument_list|(
name|ltv
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|select_out
goto|;
block|}
name|select_out
label|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|select
argument_list|)
condition|)
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"select_out -> %d"
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|linux_mremap
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_mremap_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|munmap_args
comment|/* { 		void *addr; 		size_t len; 	} */
name|bsd_args
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|mremap
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|mremap
argument_list|,
literal|"%p, %08lx, %08lx, %08lx"
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|args
operator|->
name|addr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|args
operator|->
name|old_len
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|args
operator|->
name|new_len
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|args
operator|->
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|args
operator|->
name|new_len
operator|=
name|round_page
argument_list|(
name|args
operator|->
name|new_len
argument_list|)
expr_stmt|;
name|args
operator|->
name|old_len
operator|=
name|round_page
argument_list|(
name|args
operator|->
name|old_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|new_len
operator|>
name|args
operator|->
name|old_len
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|if
condition|(
name|args
operator|->
name|new_len
operator|<
name|args
operator|->
name|old_len
condition|)
block|{
name|bsd_args
operator|.
name|addr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|uintptr_t
operator|)
name|args
operator|->
name|addr
operator|+
name|args
operator|->
name|new_len
argument_list|)
expr_stmt|;
name|bsd_args
operator|.
name|len
operator|=
name|args
operator|->
name|old_len
operator|-
name|args
operator|->
name|new_len
expr_stmt|;
name|error
operator|=
name|munmap
argument_list|(
name|td
argument_list|,
operator|&
name|bsd_args
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|error
condition|?
literal|0
else|:
operator|(
name|uintptr_t
operator|)
name|args
operator|->
name|addr
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_define
define|#
directive|define
name|LINUX_MS_ASYNC
value|0x0001
end_define

begin_define
define|#
directive|define
name|LINUX_MS_INVALIDATE
value|0x0002
end_define

begin_define
define|#
directive|define
name|LINUX_MS_SYNC
value|0x0004
end_define

begin_function
name|int
name|linux_msync
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_msync_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|msync_args
name|bsd_args
decl_stmt|;
name|bsd_args
operator|.
name|addr
operator|=
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|args
operator|->
name|addr
expr_stmt|;
name|bsd_args
operator|.
name|len
operator|=
operator|(
name|uintptr_t
operator|)
name|args
operator|->
name|len
expr_stmt|;
name|bsd_args
operator|.
name|flags
operator|=
name|args
operator|->
name|fl
operator|&
operator|~
name|LINUX_MS_SYNC
expr_stmt|;
return|return
name|msync
argument_list|(
name|td
argument_list|,
operator|&
name|bsd_args
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|linux_time
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_time_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|l_time_t
name|tm
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|time
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|time
argument_list|,
literal|"*"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|tm
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|tm
operator|&&
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|tm
argument_list|,
name|args
operator|->
name|tm
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|tm
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_struct
struct|struct
name|l_times_argv
block|{
name|l_long
name|tms_utime
decl_stmt|;
name|l_long
name|tms_stime
decl_stmt|;
name|l_long
name|tms_cutime
decl_stmt|;
name|l_long
name|tms_cstime
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|CLK_TCK
value|100
end_define

begin_comment
comment|/* Linux uses 100 */
end_comment

begin_define
define|#
directive|define
name|CONVTCK
parameter_list|(
name|r
parameter_list|)
value|(r.tv_sec * CLK_TCK + r.tv_usec / (1000000 / CLK_TCK))
end_define

begin_function
name|int
name|linux_times
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_times_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|,
name|utime
decl_stmt|,
name|stime
decl_stmt|,
name|cutime
decl_stmt|,
name|cstime
decl_stmt|;
name|struct
name|l_times_argv
name|tms
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|times
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|times
argument_list|,
literal|"*"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|calcru
argument_list|(
name|p
argument_list|,
operator|&
name|utime
argument_list|,
operator|&
name|stime
argument_list|)
expr_stmt|;
name|calccru
argument_list|(
name|p
argument_list|,
operator|&
name|cutime
argument_list|,
operator|&
name|cstime
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|tms
operator|.
name|tms_utime
operator|=
name|CONVTCK
argument_list|(
name|utime
argument_list|)
expr_stmt|;
name|tms
operator|.
name|tms_stime
operator|=
name|CONVTCK
argument_list|(
name|stime
argument_list|)
expr_stmt|;
name|tms
operator|.
name|tms_cutime
operator|=
name|CONVTCK
argument_list|(
name|cutime
argument_list|)
expr_stmt|;
name|tms
operator|.
name|tms_cstime
operator|=
name|CONVTCK
argument_list|(
name|cstime
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|tms
argument_list|,
name|args
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|tms
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
block|}
name|microuptime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|)
name|CONVTCK
argument_list|(
name|tv
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|linux_newuname
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_newuname_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|l_new_utsname
name|utsname
decl_stmt|;
name|char
name|osname
index|[
name|LINUX_MAX_UTSNAME
index|]
decl_stmt|;
name|char
name|osrelease
index|[
name|LINUX_MAX_UTSNAME
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|newuname
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|newuname
argument_list|,
literal|"*"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|linux_get_osname
argument_list|(
name|td
argument_list|,
name|osname
argument_list|)
expr_stmt|;
name|linux_get_osrelease
argument_list|(
name|td
argument_list|,
name|osrelease
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|utsname
argument_list|,
sizeof|sizeof
argument_list|(
name|utsname
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|utsname
operator|.
name|sysname
argument_list|,
name|osname
argument_list|,
name|LINUX_MAX_UTSNAME
argument_list|)
expr_stmt|;
name|getcredhostname
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|utsname
operator|.
name|nodename
argument_list|,
name|LINUX_MAX_UTSNAME
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|utsname
operator|.
name|release
argument_list|,
name|osrelease
argument_list|,
name|LINUX_MAX_UTSNAME
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|utsname
operator|.
name|version
argument_list|,
name|version
argument_list|,
name|LINUX_MAX_UTSNAME
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|utsname
operator|.
name|version
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|__i386__
block|{
specifier|const
name|char
modifier|*
name|class
decl_stmt|;
switch|switch
condition|(
name|cpu_class
condition|)
block|{
case|case
name|CPUCLASS_686
case|:
name|class
operator|=
literal|"i686"
expr_stmt|;
break|break;
case|case
name|CPUCLASS_586
case|:
name|class
operator|=
literal|"i586"
expr_stmt|;
break|break;
case|case
name|CPUCLASS_486
case|:
name|class
operator|=
literal|"i486"
expr_stmt|;
break|break;
default|default:
name|class
operator|=
literal|"i386"
expr_stmt|;
block|}
name|strlcpy
argument_list|(
name|utsname
operator|.
name|machine
argument_list|,
name|class
argument_list|,
name|LINUX_MAX_UTSNAME
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|__amd64__
argument_list|)
comment|/* XXX: Linux can change 'personality'. */
ifdef|#
directive|ifdef
name|COMPAT_LINUX32
name|strlcpy
argument_list|(
name|utsname
operator|.
name|machine
argument_list|,
literal|"i686"
argument_list|,
name|LINUX_MAX_UTSNAME
argument_list|)
expr_stmt|;
else|#
directive|else
name|strlcpy
argument_list|(
name|utsname
operator|.
name|machine
argument_list|,
literal|"x86_64"
argument_list|,
name|LINUX_MAX_UTSNAME
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* COMPAT_LINUX32 */
else|#
directive|else
comment|/* something other than i386 or amd64 - assume we and Linux agree */
name|strlcpy
argument_list|(
name|utsname
operator|.
name|machine
argument_list|,
name|machine
argument_list|,
name|LINUX_MAX_UTSNAME
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* __i386__ */
name|strlcpy
argument_list|(
name|utsname
operator|.
name|domainname
argument_list|,
name|domainname
argument_list|,
name|LINUX_MAX_UTSNAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|utsname
argument_list|,
name|args
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|utsname
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|&&
name|defined
argument_list|(
name|COMPAT_LINUX32
argument_list|)
operator|)
end_if

begin_struct
struct|struct
name|l_utimbuf
block|{
name|l_time_t
name|l_actime
decl_stmt|;
name|l_time_t
name|l_modtime
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|linux_utime
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_utime_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|timeval
name|tv
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|tvp
decl_stmt|;
name|struct
name|l_utimbuf
name|lut
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|error
decl_stmt|;
name|LCONVPATHEXIST
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|fname
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|utime
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|utime
argument_list|,
literal|"%s, *"
argument_list|)
argument_list|,
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|times
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|times
argument_list|,
operator|&
name|lut
argument_list|,
sizeof|sizeof
name|lut
argument_list|)
operator|)
condition|)
block|{
name|LFREEPATH
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|tv
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|lut
operator|.
name|l_actime
expr_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|lut
operator|.
name|l_modtime
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tvp
operator|=
name|tv
expr_stmt|;
block|}
else|else
name|tvp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|kern_utimes
argument_list|(
name|td
argument_list|,
name|fname
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|tvp
argument_list|,
name|UIO_SYSSPACE
argument_list|)
expr_stmt|;
name|LFREEPATH
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __i386__ || (__amd64__&& COMPAT_LINUX32) */
end_comment

begin_define
define|#
directive|define
name|__WCLONE
value|0x80000000
end_define

begin_function
name|int
name|linux_waitpid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_waitpid_args
modifier|*
name|args
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|options
decl_stmt|,
name|tmpstat
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|waitpid
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|waitpid
argument_list|,
literal|"%d, %p, %d"
argument_list|)
argument_list|,
name|args
operator|->
name|pid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|status
argument_list|,
name|args
operator|->
name|options
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * this is necessary because the test in kern_wait doesnt work 	 * because we mess with the options here 	 */
if|if
condition|(
name|args
operator|->
name|options
operator|&
operator|~
operator|(
name|WUNTRACED
operator||
name|WNOHANG
operator||
name|WCONTINUED
operator||
name|__WCLONE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|options
operator|=
operator|(
name|args
operator|->
name|options
operator|&
operator|(
name|WNOHANG
operator||
name|WUNTRACED
operator|)
operator|)
expr_stmt|;
comment|/* WLINUXCLONE should be equal to __WCLONE, but we make sure */
if|if
condition|(
name|args
operator|->
name|options
operator|&
name|__WCLONE
condition|)
name|options
operator||=
name|WLINUXCLONE
expr_stmt|;
name|error
operator|=
name|kern_wait
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|pid
argument_list|,
operator|&
name|tmpstat
argument_list|,
name|options
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|args
operator|->
name|status
condition|)
block|{
name|tmpstat
operator|&=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|tmpstat
argument_list|)
condition|)
name|tmpstat
operator|=
operator|(
name|tmpstat
operator|&
literal|0xffffff80
operator|)
operator||
name|BSD_TO_LINUX_SIGNAL
argument_list|(
name|WTERMSIG
argument_list|(
name|tmpstat
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|tmpstat
argument_list|)
condition|)
name|tmpstat
operator|=
operator|(
name|tmpstat
operator|&
literal|0xffff00ff
operator|)
operator||
operator|(
name|BSD_TO_LINUX_SIGNAL
argument_list|(
name|WSTOPSIG
argument_list|(
name|tmpstat
argument_list|)
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|tmpstat
argument_list|,
name|args
operator|->
name|status
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|linux_wait4
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_wait4_args
modifier|*
name|args
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|options
decl_stmt|,
name|tmpstat
decl_stmt|;
name|struct
name|rusage
name|ru
decl_stmt|,
modifier|*
name|rup
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|wait4
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|wait4
argument_list|,
literal|"%d, %p, %d, %p"
argument_list|)
argument_list|,
name|args
operator|->
name|pid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|status
argument_list|,
name|args
operator|->
name|options
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|rusage
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|options
operator|=
operator|(
name|args
operator|->
name|options
operator|&
operator|(
name|WNOHANG
operator||
name|WUNTRACED
operator|)
operator|)
expr_stmt|;
comment|/* WLINUXCLONE should be equal to __WCLONE, but we make sure */
if|if
condition|(
name|args
operator|->
name|options
operator|&
name|__WCLONE
condition|)
name|options
operator||=
name|WLINUXCLONE
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|rusage
operator|!=
name|NULL
condition|)
name|rup
operator|=
operator|&
name|ru
expr_stmt|;
else|else
name|rup
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|kern_wait
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|pid
argument_list|,
operator|&
name|tmpstat
argument_list|,
name|options
argument_list|,
name|rup
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sigqueue_delete
argument_list|(
operator|&
name|p
operator|->
name|p_sigqueue
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|status
condition|)
block|{
name|tmpstat
operator|&=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|tmpstat
argument_list|)
condition|)
name|tmpstat
operator|=
operator|(
name|tmpstat
operator|&
literal|0xffffff80
operator|)
operator||
name|BSD_TO_LINUX_SIGNAL
argument_list|(
name|WTERMSIG
argument_list|(
name|tmpstat
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|tmpstat
argument_list|)
condition|)
name|tmpstat
operator|=
operator|(
name|tmpstat
operator|&
literal|0xffff00ff
operator|)
operator||
operator|(
name|BSD_TO_LINUX_SIGNAL
argument_list|(
name|WSTOPSIG
argument_list|(
name|tmpstat
argument_list|)
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|tmpstat
argument_list|,
name|args
operator|->
name|status
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|args
operator|->
name|rusage
operator|!=
name|NULL
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|ru
argument_list|,
name|args
operator|->
name|rusage
argument_list|,
sizeof|sizeof
argument_list|(
name|ru
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_mknod
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_mknod_args
modifier|*
name|args
parameter_list|)
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|error
decl_stmt|;
name|LCONVPATHCREAT
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|path
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|mknod
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|mknod
argument_list|,
literal|"%s, %d, %d"
argument_list|)
argument_list|,
name|path
argument_list|,
name|args
operator|->
name|mode
argument_list|,
name|args
operator|->
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|args
operator|->
name|mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFIFO
case|:
case|case
name|S_IFSOCK
case|:
name|error
operator|=
name|kern_mkfifo
argument_list|(
name|td
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|args
operator|->
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFCHR
case|:
case|case
name|S_IFBLK
case|:
name|error
operator|=
name|kern_mknod
argument_list|(
name|td
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|args
operator|->
name|mode
argument_list|,
name|args
operator|->
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFDIR
case|:
name|error
operator|=
name|EPERM
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|args
operator|->
name|mode
operator||=
name|S_IFREG
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|S_IFREG
case|:
name|error
operator|=
name|kern_open
argument_list|(
name|td
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
name|args
operator|->
name|mode
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|LFREEPATH
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * UGH! This is just about the dumbest idea I've ever heard!!  */
end_comment

begin_function
name|int
name|linux_personality
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_personality_args
modifier|*
name|args
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|personality
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|personality
argument_list|,
literal|"%lu"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|args
operator|->
name|per
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|per
operator|!=
literal|0
condition|)
return|return
name|EINVAL
return|;
comment|/* Yes Jim, it's still a Linux... */
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_struct
struct|struct
name|l_itimerval
block|{
name|l_timeval
name|it_interval
decl_stmt|;
name|l_timeval
name|it_value
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|B2L_ITIMERVAL
parameter_list|(
name|bip
parameter_list|,
name|lip
parameter_list|)
define|\
value|(bip)->it_interval.tv_sec = (lip)->it_interval.tv_sec;		\ 	(bip)->it_interval.tv_usec = (lip)->it_interval.tv_usec;	\ 	(bip)->it_value.tv_sec = (lip)->it_value.tv_sec;		\ 	(bip)->it_value.tv_usec = (lip)->it_value.tv_usec;
end_define

begin_function
name|int
name|linux_setitimer
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_setitimer_args
modifier|*
name|uap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|l_itimerval
name|ls
decl_stmt|;
name|struct
name|itimerval
name|aitv
decl_stmt|,
name|oitv
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|setitimer
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|setitimer
argument_list|,
literal|"%p, %p"
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|uap
operator|->
name|itv
argument_list|,
operator|(
name|void
operator|*
operator|)
name|uap
operator|->
name|oitv
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|uap
operator|->
name|itv
operator|==
name|NULL
condition|)
block|{
name|uap
operator|->
name|itv
operator|=
name|uap
operator|->
name|oitv
expr_stmt|;
return|return
operator|(
name|linux_getitimer
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|linux_getitimer_args
operator|*
operator|)
name|uap
argument_list|)
operator|)
return|;
block|}
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|itv
argument_list|,
operator|&
name|ls
argument_list|,
sizeof|sizeof
argument_list|(
name|ls
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|B2L_ITIMERVAL
argument_list|(
operator|&
name|aitv
argument_list|,
operator|&
name|ls
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|setitimer
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"setitimer: value: sec: %jd, usec: %ld\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|aitv
operator|.
name|it_value
operator|.
name|tv_sec
argument_list|,
name|aitv
operator|.
name|it_value
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"setitimer: interval: sec: %jd, usec: %ld\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|aitv
operator|.
name|it_interval
operator|.
name|tv_sec
argument_list|,
name|aitv
operator|.
name|it_interval
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|error
operator|=
name|kern_setitimer
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|which
argument_list|,
operator|&
name|aitv
argument_list|,
operator|&
name|oitv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|uap
operator|->
name|oitv
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|B2L_ITIMERVAL
argument_list|(
operator|&
name|ls
argument_list|,
operator|&
name|oitv
argument_list|)
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|ls
argument_list|,
name|uap
operator|->
name|oitv
argument_list|,
sizeof|sizeof
argument_list|(
name|ls
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_getitimer
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getitimer_args
modifier|*
name|uap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|l_itimerval
name|ls
decl_stmt|;
name|struct
name|itimerval
name|aitv
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|getitimer
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|getitimer
argument_list|,
literal|"%p"
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|uap
operator|->
name|itv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|kern_getitimer
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|which
argument_list|,
operator|&
name|aitv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|B2L_ITIMERVAL
argument_list|(
operator|&
name|ls
argument_list|,
operator|&
name|aitv
argument_list|)
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|ls
argument_list|,
name|uap
operator|->
name|itv
argument_list|,
sizeof|sizeof
argument_list|(
name|ls
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_nice
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_nice_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|setpriority_args
name|bsd_args
decl_stmt|;
name|bsd_args
operator|.
name|which
operator|=
name|PRIO_PROCESS
expr_stmt|;
name|bsd_args
operator|.
name|who
operator|=
literal|0
expr_stmt|;
comment|/* current process */
name|bsd_args
operator|.
name|prio
operator|=
name|args
operator|->
name|inc
expr_stmt|;
return|return
name|setpriority
argument_list|(
name|td
argument_list|,
operator|&
name|bsd_args
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|linux_setgroups
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_setgroups_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|,
modifier|*
name|oldcred
decl_stmt|;
name|l_gid_t
name|linux_gidset
index|[
name|NGROUPS
index|]
decl_stmt|;
name|gid_t
modifier|*
name|bsd_gidset
decl_stmt|;
name|int
name|ngrp
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|ngrp
operator|=
name|args
operator|->
name|gidsetsize
expr_stmt|;
if|if
condition|(
name|ngrp
operator|<
literal|0
operator|||
name|ngrp
operator|>=
name|NGROUPS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|grouplist
argument_list|,
name|linux_gidset
argument_list|,
name|ngrp
operator|*
sizeof|sizeof
argument_list|(
name|l_gid_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|newcred
operator|=
name|crget
argument_list|()
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|oldcred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
comment|/* 	 * cr_groups[0] holds egid. Setting the whole set from 	 * the supplied set will cause egid to be changed too. 	 * Keep cr_groups[0] unchanged to prevent that. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|priv_check_cred
argument_list|(
name|oldcred
argument_list|,
name|PRIV_CRED_SETGROUPS
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|newcred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|crcopy
argument_list|(
name|newcred
argument_list|,
name|oldcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngrp
operator|>
literal|0
condition|)
block|{
name|newcred
operator|->
name|cr_ngroups
operator|=
name|ngrp
operator|+
literal|1
expr_stmt|;
name|bsd_gidset
operator|=
name|newcred
operator|->
name|cr_groups
expr_stmt|;
name|ngrp
operator|--
expr_stmt|;
while|while
condition|(
name|ngrp
operator|>=
literal|0
condition|)
block|{
name|bsd_gidset
index|[
name|ngrp
operator|+
literal|1
index|]
operator|=
name|linux_gidset
index|[
name|ngrp
index|]
expr_stmt|;
name|ngrp
operator|--
expr_stmt|;
block|}
block|}
else|else
name|newcred
operator|->
name|cr_ngroups
operator|=
literal|1
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_ucred
operator|=
name|newcred
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_getgroups
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getgroups_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|l_gid_t
name|linux_gidset
index|[
name|NGROUPS
index|]
decl_stmt|;
name|gid_t
modifier|*
name|bsd_gidset
decl_stmt|;
name|int
name|bsd_gidsetsz
decl_stmt|,
name|ngrp
decl_stmt|,
name|error
decl_stmt|;
name|cred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
name|bsd_gidset
operator|=
name|cred
operator|->
name|cr_groups
expr_stmt|;
name|bsd_gidsetsz
operator|=
name|cred
operator|->
name|cr_ngroups
operator|-
literal|1
expr_stmt|;
comment|/* 	 * cr_groups[0] holds egid. Returning the whole set 	 * here will cause a duplicate. Exclude cr_groups[0] 	 * to prevent that. 	 */
if|if
condition|(
operator|(
name|ngrp
operator|=
name|args
operator|->
name|gidsetsize
operator|)
operator|==
literal|0
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|bsd_gidsetsz
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ngrp
operator|<
name|bsd_gidsetsz
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ngrp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ngrp
operator|<
name|bsd_gidsetsz
condition|)
block|{
name|linux_gidset
index|[
name|ngrp
index|]
operator|=
name|bsd_gidset
index|[
name|ngrp
operator|+
literal|1
index|]
expr_stmt|;
name|ngrp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
name|linux_gidset
argument_list|,
name|args
operator|->
name|grouplist
argument_list|,
name|ngrp
operator|*
sizeof|sizeof
argument_list|(
name|l_gid_t
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|ngrp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_setrlimit
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_setrlimit_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|rlimit
name|bsd_rlim
decl_stmt|;
name|struct
name|l_rlimit
name|rlim
decl_stmt|;
name|u_int
name|which
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|setrlimit
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|setrlimit
argument_list|,
literal|"%d, %p"
argument_list|)
argument_list|,
name|args
operator|->
name|resource
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|rlim
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|resource
operator|>=
name|LINUX_RLIM_NLIMITS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|which
operator|=
name|linux_to_bsd_resource
index|[
name|args
operator|->
name|resource
index|]
expr_stmt|;
if|if
condition|(
name|which
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|rlim
argument_list|,
operator|&
name|rlim
argument_list|,
sizeof|sizeof
argument_list|(
name|rlim
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bsd_rlim
operator|.
name|rlim_cur
operator|=
operator|(
name|rlim_t
operator|)
name|rlim
operator|.
name|rlim_cur
expr_stmt|;
name|bsd_rlim
operator|.
name|rlim_max
operator|=
operator|(
name|rlim_t
operator|)
name|rlim
operator|.
name|rlim_max
expr_stmt|;
return|return
operator|(
name|kern_setrlimit
argument_list|(
name|td
argument_list|,
name|which
argument_list|,
operator|&
name|bsd_rlim
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_old_getrlimit
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_old_getrlimit_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|l_rlimit
name|rlim
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|rlimit
name|bsd_rlim
decl_stmt|;
name|u_int
name|which
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|old_getrlimit
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|old_getrlimit
argument_list|,
literal|"%d, %p"
argument_list|)
argument_list|,
name|args
operator|->
name|resource
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|rlim
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|resource
operator|>=
name|LINUX_RLIM_NLIMITS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|which
operator|=
name|linux_to_bsd_resource
index|[
name|args
operator|->
name|resource
index|]
expr_stmt|;
if|if
condition|(
name|which
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|lim_rlimit
argument_list|(
name|p
argument_list|,
name|which
argument_list|,
operator|&
name|bsd_rlim
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_LINUX32
name|rlim
operator|.
name|rlim_cur
operator|=
operator|(
name|unsigned
name|int
operator|)
name|bsd_rlim
operator|.
name|rlim_cur
expr_stmt|;
if|if
condition|(
name|rlim
operator|.
name|rlim_cur
operator|==
name|UINT_MAX
condition|)
name|rlim
operator|.
name|rlim_cur
operator|=
name|INT_MAX
expr_stmt|;
name|rlim
operator|.
name|rlim_max
operator|=
operator|(
name|unsigned
name|int
operator|)
name|bsd_rlim
operator|.
name|rlim_max
expr_stmt|;
if|if
condition|(
name|rlim
operator|.
name|rlim_max
operator|==
name|UINT_MAX
condition|)
name|rlim
operator|.
name|rlim_max
operator|=
name|INT_MAX
expr_stmt|;
else|#
directive|else
name|rlim
operator|.
name|rlim_cur
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bsd_rlim
operator|.
name|rlim_cur
expr_stmt|;
if|if
condition|(
name|rlim
operator|.
name|rlim_cur
operator|==
name|ULONG_MAX
condition|)
name|rlim
operator|.
name|rlim_cur
operator|=
name|LONG_MAX
expr_stmt|;
name|rlim
operator|.
name|rlim_max
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bsd_rlim
operator|.
name|rlim_max
expr_stmt|;
if|if
condition|(
name|rlim
operator|.
name|rlim_max
operator|==
name|ULONG_MAX
condition|)
name|rlim
operator|.
name|rlim_max
operator|=
name|LONG_MAX
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|rlim
argument_list|,
name|args
operator|->
name|rlim
argument_list|,
sizeof|sizeof
argument_list|(
name|rlim
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_getrlimit
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getrlimit_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|l_rlimit
name|rlim
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|rlimit
name|bsd_rlim
decl_stmt|;
name|u_int
name|which
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|getrlimit
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|getrlimit
argument_list|,
literal|"%d, %p"
argument_list|)
argument_list|,
name|args
operator|->
name|resource
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|rlim
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|resource
operator|>=
name|LINUX_RLIM_NLIMITS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|which
operator|=
name|linux_to_bsd_resource
index|[
name|args
operator|->
name|resource
index|]
expr_stmt|;
if|if
condition|(
name|which
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|lim_rlimit
argument_list|(
name|p
argument_list|,
name|which
argument_list|,
operator|&
name|bsd_rlim
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
operator|(
name|l_ulong
operator|)
name|bsd_rlim
operator|.
name|rlim_cur
expr_stmt|;
name|rlim
operator|.
name|rlim_max
operator|=
operator|(
name|l_ulong
operator|)
name|bsd_rlim
operator|.
name|rlim_max
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|rlim
argument_list|,
name|args
operator|->
name|rlim
argument_list|,
sizeof|sizeof
argument_list|(
name|rlim
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_sched_setscheduler
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_sched_setscheduler_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|sched_setscheduler_args
name|bsd
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|sched_setscheduler
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|sched_setscheduler
argument_list|,
literal|"%d, %d, %p"
argument_list|)
argument_list|,
name|args
operator|->
name|pid
argument_list|,
name|args
operator|->
name|policy
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|args
operator|->
name|param
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|args
operator|->
name|policy
condition|)
block|{
case|case
name|LINUX_SCHED_OTHER
case|:
name|bsd
operator|.
name|policy
operator|=
name|SCHED_OTHER
expr_stmt|;
break|break;
case|case
name|LINUX_SCHED_FIFO
case|:
name|bsd
operator|.
name|policy
operator|=
name|SCHED_FIFO
expr_stmt|;
break|break;
case|case
name|LINUX_SCHED_RR
case|:
name|bsd
operator|.
name|policy
operator|=
name|SCHED_RR
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
name|bsd
operator|.
name|pid
operator|=
name|args
operator|->
name|pid
expr_stmt|;
name|bsd
operator|.
name|param
operator|=
operator|(
expr|struct
name|sched_param
operator|*
operator|)
name|args
operator|->
name|param
expr_stmt|;
return|return
name|sched_setscheduler
argument_list|(
name|td
argument_list|,
operator|&
name|bsd
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|linux_sched_getscheduler
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_sched_getscheduler_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|sched_getscheduler_args
name|bsd
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|sched_getscheduler
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|sched_getscheduler
argument_list|,
literal|"%d"
argument_list|)
argument_list|,
name|args
operator|->
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bsd
operator|.
name|pid
operator|=
name|args
operator|->
name|pid
expr_stmt|;
name|error
operator|=
name|sched_getscheduler
argument_list|(
name|td
argument_list|,
operator|&
name|bsd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
condition|)
block|{
case|case
name|SCHED_OTHER
case|:
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|LINUX_SCHED_OTHER
expr_stmt|;
break|break;
case|case
name|SCHED_FIFO
case|:
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|LINUX_SCHED_FIFO
expr_stmt|;
break|break;
case|case
name|SCHED_RR
case|:
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|LINUX_SCHED_RR
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|linux_sched_get_priority_max
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_sched_get_priority_max_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|sched_get_priority_max_args
name|bsd
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|sched_get_priority_max
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|sched_get_priority_max
argument_list|,
literal|"%d"
argument_list|)
argument_list|,
name|args
operator|->
name|policy
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|args
operator|->
name|policy
condition|)
block|{
case|case
name|LINUX_SCHED_OTHER
case|:
name|bsd
operator|.
name|policy
operator|=
name|SCHED_OTHER
expr_stmt|;
break|break;
case|case
name|LINUX_SCHED_FIFO
case|:
name|bsd
operator|.
name|policy
operator|=
name|SCHED_FIFO
expr_stmt|;
break|break;
case|case
name|LINUX_SCHED_RR
case|:
name|bsd
operator|.
name|policy
operator|=
name|SCHED_RR
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
return|return
name|sched_get_priority_max
argument_list|(
name|td
argument_list|,
operator|&
name|bsd
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|linux_sched_get_priority_min
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_sched_get_priority_min_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|sched_get_priority_min_args
name|bsd
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|sched_get_priority_min
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|sched_get_priority_min
argument_list|,
literal|"%d"
argument_list|)
argument_list|,
name|args
operator|->
name|policy
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|args
operator|->
name|policy
condition|)
block|{
case|case
name|LINUX_SCHED_OTHER
case|:
name|bsd
operator|.
name|policy
operator|=
name|SCHED_OTHER
expr_stmt|;
break|break;
case|case
name|LINUX_SCHED_FIFO
case|:
name|bsd
operator|.
name|policy
operator|=
name|SCHED_FIFO
expr_stmt|;
break|break;
case|case
name|LINUX_SCHED_RR
case|:
name|bsd
operator|.
name|policy
operator|=
name|SCHED_RR
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
return|return
name|sched_get_priority_min
argument_list|(
name|td
argument_list|,
operator|&
name|bsd
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|REBOOT_CAD_ON
value|0x89abcdef
end_define

begin_define
define|#
directive|define
name|REBOOT_CAD_OFF
value|0
end_define

begin_define
define|#
directive|define
name|REBOOT_HALT
value|0xcdef0123
end_define

begin_define
define|#
directive|define
name|REBOOT_RESTART
value|0x01234567
end_define

begin_define
define|#
directive|define
name|REBOOT_RESTART2
value|0xA1B2C3D4
end_define

begin_define
define|#
directive|define
name|REBOOT_POWEROFF
value|0x4321FEDC
end_define

begin_define
define|#
directive|define
name|REBOOT_MAGIC1
value|0xfee1dead
end_define

begin_define
define|#
directive|define
name|REBOOT_MAGIC2
value|0x28121969
end_define

begin_define
define|#
directive|define
name|REBOOT_MAGIC2A
value|0x05121996
end_define

begin_define
define|#
directive|define
name|REBOOT_MAGIC2B
value|0x16041998
end_define

begin_function
name|int
name|linux_reboot
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_reboot_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|reboot_args
name|bsd_args
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|reboot
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|reboot
argument_list|,
literal|"0x%x"
argument_list|)
argument_list|,
name|args
operator|->
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|magic1
operator|!=
name|REBOOT_MAGIC1
condition|)
return|return
name|EINVAL
return|;
switch|switch
condition|(
name|args
operator|->
name|magic2
condition|)
block|{
case|case
name|REBOOT_MAGIC2
case|:
case|case
name|REBOOT_MAGIC2A
case|:
case|case
name|REBOOT_MAGIC2B
case|:
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
switch|switch
condition|(
name|args
operator|->
name|cmd
condition|)
block|{
case|case
name|REBOOT_CAD_ON
case|:
case|case
name|REBOOT_CAD_OFF
case|:
return|return
operator|(
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_REBOOT
argument_list|)
operator|)
return|;
case|case
name|REBOOT_HALT
case|:
name|bsd_args
operator|.
name|opt
operator|=
name|RB_HALT
expr_stmt|;
break|break;
case|case
name|REBOOT_RESTART
case|:
case|case
name|REBOOT_RESTART2
case|:
name|bsd_args
operator|.
name|opt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|REBOOT_POWEROFF
case|:
name|bsd_args
operator|.
name|opt
operator|=
name|RB_POWEROFF
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
return|return
name|reboot
argument_list|(
name|td
argument_list|,
operator|&
name|bsd_args
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * The FreeBSD native getpid(2), getgid(2) and getuid(2) also modify  * td->td_retval[1] when COMPAT_43 is defined. This  * globbers registers that are assumed to be preserved. The following  * lightweight syscalls fixes this. See also linux_getgid16() and  * linux_getuid16() in linux_uid16.c.  *  * linux_getpid() - MP SAFE  * linux_getgid() - MP SAFE  * linux_getuid() - MP SAFE  */
end_comment

begin_function
name|int
name|linux_getpid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getpid_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|linux_emuldata
modifier|*
name|em
decl_stmt|;
name|char
name|osrel
index|[
name|LINUX_MAX_UTSNAME
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|getpid
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|getpid
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|linux_get_osrelease
argument_list|(
name|td
argument_list|,
name|osrel
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|osrel
argument_list|)
operator|>=
literal|3
operator|&&
name|osrel
index|[
literal|2
index|]
operator|==
literal|'6'
condition|)
block|{
name|em
operator|=
name|em_find
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|EMUL_UNLOCKED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|em
operator|!=
name|NULL
argument_list|,
operator|(
literal|"getpid: emuldata not found.\n"
operator|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|em
operator|->
name|shared
operator|->
name|group_pid
expr_stmt|;
name|EMUL_UNLOCK
argument_list|(
operator|&
name|emul_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_gettid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_gettid_args
modifier|*
name|args
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|gettid
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|gettid
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_getppid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getppid_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|linux_emuldata
modifier|*
name|em
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|char
name|osrel
index|[
name|LINUX_MAX_UTSNAME
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|getppid
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|getppid
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|linux_get_osrelease
argument_list|(
name|td
argument_list|,
name|osrel
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|osrel
argument_list|)
operator|>=
literal|3
operator|&&
name|osrel
index|[
literal|2
index|]
operator|!=
literal|'6'
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pptr
operator|->
name|p_pid
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|em
operator|=
name|em_find
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|EMUL_UNLOCKED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|em
operator|!=
name|NULL
argument_list|,
operator|(
literal|"getppid: process emuldata not found.\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* find the group leader */
name|p
operator|=
name|pfind
argument_list|(
name|em
operator|->
name|shared
operator|->
name|group_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"parent process not found.\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pp
operator|=
name|p
operator|->
name|p_pptr
expr_stmt|;
comment|/* switch to parent */
name|PROC_LOCK
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* if its also linux process */
if|if
condition|(
name|pp
operator|->
name|p_sysent
operator|==
operator|&
name|elf_linux_sysvec
condition|)
block|{
name|em
operator|=
name|em_find
argument_list|(
name|pp
argument_list|,
name|EMUL_LOCKED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|em
operator|!=
name|NULL
argument_list|,
operator|(
literal|"getppid: parent emuldata not found.\n"
operator|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|em
operator|->
name|shared
operator|->
name|group_pid
expr_stmt|;
block|}
else|else
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|pp
operator|->
name|p_pid
expr_stmt|;
name|EMUL_UNLOCK
argument_list|(
operator|&
name|emul_lock
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|pp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_getgid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getgid_args
modifier|*
name|args
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|getgid
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|getgid
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_rgid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_getuid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getuid_args
modifier|*
name|args
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|getuid
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|getuid
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_ruid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_getsid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getsid_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|getsid_args
name|bsd
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|getsid
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|getsid
argument_list|,
literal|"%i"
argument_list|)
argument_list|,
name|args
operator|->
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bsd
operator|.
name|pid
operator|=
name|args
operator|->
name|pid
expr_stmt|;
return|return
name|getsid
argument_list|(
name|td
argument_list|,
operator|&
name|bsd
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|linux_nosys
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|nosys_args
modifier|*
name|ignore
parameter_list|)
block|{
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_getpriority
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getpriority_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|getpriority_args
name|bsd_args
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|getpriority
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|getpriority
argument_list|,
literal|"%i, %i"
argument_list|)
argument_list|,
name|args
operator|->
name|which
argument_list|,
name|args
operator|->
name|who
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bsd_args
operator|.
name|which
operator|=
name|args
operator|->
name|which
expr_stmt|;
name|bsd_args
operator|.
name|who
operator|=
name|args
operator|->
name|who
expr_stmt|;
name|error
operator|=
name|getpriority
argument_list|(
name|td
argument_list|,
operator|&
name|bsd_args
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|20
operator|-
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|linux_sethostname
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_sethostname_args
modifier|*
name|args
parameter_list|)
block|{
name|int
name|name
index|[
literal|2
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|sethostname
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|sethostname
argument_list|,
literal|"*, %i"
argument_list|)
argument_list|,
name|args
operator|->
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|name
index|[
literal|0
index|]
operator|=
name|CTL_KERN
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
name|KERN_HOSTNAME
expr_stmt|;
return|return
operator|(
name|userland_sysctl
argument_list|(
name|td
argument_list|,
name|name
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|args
operator|->
name|hostname
argument_list|,
name|args
operator|->
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_exit_group
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_exit_group_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|linux_emuldata
modifier|*
name|em
decl_stmt|,
modifier|*
name|td_em
decl_stmt|,
modifier|*
name|tmp_em
decl_stmt|;
name|struct
name|proc
modifier|*
name|sp
decl_stmt|;
name|char
name|osrel
index|[
name|LINUX_MAX_UTSNAME
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|exit_group
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|exit_group
argument_list|,
literal|"%i"
argument_list|)
argument_list|,
name|args
operator|->
name|error_code
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|linux_get_osrelease
argument_list|(
name|td
argument_list|,
name|osrel
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|osrel
argument_list|)
operator|>=
literal|3
operator|&&
name|osrel
index|[
literal|2
index|]
operator|==
literal|'6'
condition|)
block|{
name|td_em
operator|=
name|em_find
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|EMUL_UNLOCKED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|td_em
operator|!=
name|NULL
argument_list|,
operator|(
literal|"exit_group: emuldata not found.\n"
operator|)
argument_list|)
expr_stmt|;
name|EMUL_SHARED_RLOCK
argument_list|(
operator|&
name|emul_shared_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|em
argument_list|,
argument|&td_em->shared->threads
argument_list|,
argument|threads
argument_list|,
argument|tmp_em
argument_list|)
block|{
if|if
condition|(
name|em
operator|->
name|pid
operator|==
name|td_em
operator|->
name|pid
condition|)
continue|continue;
name|sp
operator|=
name|pfind
argument_list|(
name|em
operator|->
name|pid
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|sp
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|sp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"linux_sys_exit_group: kill PID %d\n"
argument_list|)
argument_list|,
name|em
operator|->
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|EMUL_SHARED_RUNLOCK
argument_list|(
operator|&
name|emul_shared_lock
argument_list|)
expr_stmt|;
name|EMUL_UNLOCK
argument_list|(
operator|&
name|emul_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * XXX: we should send a signal to the parent if 	 * SIGNAL_EXIT_GROUP is set. We ignore that (temporrarily?) 	 * as it doesnt occur often. 	 */
name|exit1
argument_list|(
name|td
argument_list|,
name|W_EXITCODE
argument_list|(
name|args
operator|->
name|error_code
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_prctl
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_prctl_args
modifier|*
name|args
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|,
name|max_size
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|char
name|comm
index|[
name|LINUX_MAX_COMM_LEN
index|]
decl_stmt|;
name|struct
name|linux_emuldata
modifier|*
name|em
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|prctl
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|prctl
argument_list|,
literal|"%d, %d, %d, %d, %d"
argument_list|)
argument_list|,
name|args
operator|->
name|option
argument_list|,
name|args
operator|->
name|arg2
argument_list|,
name|args
operator|->
name|arg3
argument_list|,
name|args
operator|->
name|arg4
argument_list|,
name|args
operator|->
name|arg5
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|args
operator|->
name|option
condition|)
block|{
case|case
name|LINUX_PR_SET_PDEATHSIG
case|:
if|if
condition|(
operator|!
name|LINUX_SIG_VALID
argument_list|(
name|args
operator|->
name|arg2
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|em
operator|=
name|em_find
argument_list|(
name|p
argument_list|,
name|EMUL_UNLOCKED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|em
operator|!=
name|NULL
argument_list|,
operator|(
literal|"prctl: emuldata not found.\n"
operator|)
argument_list|)
expr_stmt|;
name|em
operator|->
name|pdeath_signal
operator|=
name|args
operator|->
name|arg2
expr_stmt|;
name|EMUL_UNLOCK
argument_list|(
operator|&
name|emul_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINUX_PR_GET_PDEATHSIG
case|:
name|em
operator|=
name|em_find
argument_list|(
name|p
argument_list|,
name|EMUL_UNLOCKED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|em
operator|!=
name|NULL
argument_list|,
operator|(
literal|"prctl: emuldata not found.\n"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|em
operator|->
name|pdeath_signal
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|register_t
operator|)
name|args
operator|->
name|arg2
argument_list|,
sizeof|sizeof
argument_list|(
name|em
operator|->
name|pdeath_signal
argument_list|)
argument_list|)
expr_stmt|;
name|EMUL_UNLOCK
argument_list|(
operator|&
name|emul_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINUX_PR_SET_NAME
case|:
comment|/* 		 * To be on the safe side we need to make sure to not 		 * overflow the size a linux program expects. We already 		 * do this here in the copyin, so that we don't need to 		 * check on copyout. 		 */
name|max_size
operator|=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|comm
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|p_comm
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyinstr
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|register_t
operator|)
name|args
operator|->
name|arg2
argument_list|,
name|comm
argument_list|,
name|max_size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Linux silently truncates the name if it is too long. */
if|if
condition|(
name|error
operator|==
name|ENAMETOOLONG
condition|)
block|{
comment|/* 			 * XXX: copyinstr() isn't documented to populate the 			 * array completely, so do a copyin() to be on the 			 * safe side. This should be changed in case 			 * copyinstr() is changed to guarantee this. 			 */
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|register_t
operator|)
name|args
operator|->
name|arg2
argument_list|,
name|comm
argument_list|,
name|max_size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|comm
index|[
name|max_size
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|p
operator|->
name|p_comm
argument_list|,
name|comm
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|p_comm
argument_list|)
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINUX_PR_GET_NAME
case|:
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|comm
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
sizeof|sizeof
argument_list|(
name|comm
argument_list|)
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|comm
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|register_t
operator|)
name|args
operator|->
name|arg2
argument_list|,
name|strlen
argument_list|(
name|comm
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

