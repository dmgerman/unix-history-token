begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1994-1995 SÃ¸ren Schmidt  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_mac.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/blist.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact_aout.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mac.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/swap_pager.h>
end_include

begin_include
include|#
directive|include
file|<machine/limits.h>
end_include

begin_include
include|#
directive|include
file|<posix4/sched.h>
end_include

begin_include
include|#
directive|include
file|<machine/../linux/linux.h>
end_include

begin_include
include|#
directive|include
file|<machine/../linux/linux_proto.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_mib.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_util.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__alpha__
end_ifdef

begin_define
define|#
directive|define
name|BSD_TO_LINUX_SIGNAL
parameter_list|(
name|sig
parameter_list|)
value|(sig)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BSD_TO_LINUX_SIGNAL
parameter_list|(
name|sig
parameter_list|)
define|\
value|(((sig)<= LINUX_SIGTBLSZ) ? bsd_to_linux_signal[_SIG_IDX(sig)] : sig)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__alpha__
end_ifndef

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|linux_to_bsd_resource
index|[
name|LINUX_RLIM_NLIMITS
index|]
init|=
block|{
name|RLIMIT_CPU
block|,
name|RLIMIT_FSIZE
block|,
name|RLIMIT_DATA
block|,
name|RLIMIT_STACK
block|,
name|RLIMIT_CORE
block|,
name|RLIMIT_RSS
block|,
name|RLIMIT_NPROC
block|,
name|RLIMIT_NOFILE
block|,
name|RLIMIT_MEMLOCK
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*!__alpha__*/
end_comment

begin_struct
struct|struct
name|l_sysinfo
block|{
name|l_long
name|uptime
decl_stmt|;
comment|/* Seconds since boot */
name|l_ulong
name|loads
index|[
literal|3
index|]
decl_stmt|;
comment|/* 1, 5, and 15 minute load averages */
name|l_ulong
name|totalram
decl_stmt|;
comment|/* Total usable main memory size */
name|l_ulong
name|freeram
decl_stmt|;
comment|/* Available memory size */
name|l_ulong
name|sharedram
decl_stmt|;
comment|/* Amount of shared memory */
name|l_ulong
name|bufferram
decl_stmt|;
comment|/* Memory used by buffers */
name|l_ulong
name|totalswap
decl_stmt|;
comment|/* Total swap space size */
name|l_ulong
name|freeswap
decl_stmt|;
comment|/* swap space still available */
name|l_ushort
name|procs
decl_stmt|;
comment|/* Number of current processes */
name|char
name|_f
index|[
literal|22
index|]
decl_stmt|;
comment|/* Pads structure to 64 bytes */
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|__alpha__
end_ifndef

begin_function
name|int
name|linux_sysinfo
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_sysinfo_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|l_sysinfo
name|sysinfo
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
comment|/* Uptime is copied out of print_uptime() in kern_shutdown.c */
name|getnanouptime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ts
operator|.
name|tv_sec
operator|>=
literal|86400
condition|)
block|{
name|ts
operator|.
name|tv_sec
operator|%=
literal|86400
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|||
name|ts
operator|.
name|tv_sec
operator|>=
literal|3600
condition|)
block|{
name|ts
operator|.
name|tv_sec
operator|%=
literal|3600
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|||
name|ts
operator|.
name|tv_sec
operator|>=
literal|60
condition|)
block|{
name|ts
operator|.
name|tv_sec
operator|%=
literal|60
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
name|sysinfo
operator|.
name|uptime
operator|=
name|ts
operator|.
name|tv_sec
expr_stmt|;
comment|/* Use the information from the mib to get our load averages */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|sysinfo
operator|.
name|loads
index|[
name|i
index|]
operator|=
name|averunnable
operator|.
name|ldavg
index|[
name|i
index|]
expr_stmt|;
name|sysinfo
operator|.
name|totalram
operator|=
name|physmem
operator|*
name|PAGE_SIZE
expr_stmt|;
name|sysinfo
operator|.
name|freeram
operator|=
name|sysinfo
operator|.
name|totalram
operator|-
name|cnt
operator|.
name|v_wire_count
operator|*
name|PAGE_SIZE
expr_stmt|;
name|sysinfo
operator|.
name|sharedram
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|object
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|vm_object_list
argument_list|)
init|;
name|object
operator|!=
name|NULL
condition|;
name|object
operator|=
name|TAILQ_NEXT
argument_list|(
name|object
argument_list|,
name|object_list
argument_list|)
control|)
if|if
condition|(
name|object
operator|->
name|shadow_count
operator|>
literal|1
condition|)
name|sysinfo
operator|.
name|sharedram
operator|+=
name|object
operator|->
name|resident_page_count
expr_stmt|;
name|sysinfo
operator|.
name|sharedram
operator|*=
name|PAGE_SIZE
expr_stmt|;
name|sysinfo
operator|.
name|bufferram
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|swapblist
operator|==
name|NULL
condition|)
block|{
name|sysinfo
operator|.
name|totalswap
operator|=
literal|0
expr_stmt|;
name|sysinfo
operator|.
name|freeswap
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sysinfo
operator|.
name|totalswap
operator|=
name|swapblist
operator|->
name|bl_blocks
operator|*
literal|1024
expr_stmt|;
name|sysinfo
operator|.
name|freeswap
operator|=
name|swapblist
operator|->
name|bl_root
operator|->
name|u
operator|.
name|bmu_avail
operator|*
name|PAGE_SIZE
expr_stmt|;
block|}
name|sysinfo
operator|.
name|procs
operator|=
literal|20
expr_stmt|;
comment|/* Hack */
return|return
name|copyout
argument_list|(
operator|&
name|sysinfo
argument_list|,
name|args
operator|->
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|sysinfo
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*!__alpha__*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__alpha__
end_ifndef

begin_function
name|int
name|linux_alarm
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_alarm_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|itimerval
name|it
decl_stmt|,
name|old_it
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|alarm
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|alarm
argument_list|,
literal|"%u"
argument_list|)
argument_list|,
name|args
operator|->
name|secs
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|secs
operator|>
literal|100000000
condition|)
return|return
name|EINVAL
return|;
name|it
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
operator|(
name|long
operator|)
name|args
operator|->
name|secs
expr_stmt|;
name|it
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|it
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|it
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|old_it
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_realtimer
expr_stmt|;
name|getmicrouptime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|timevalisset
argument_list|(
operator|&
name|old_it
operator|.
name|it_value
argument_list|)
condition|)
name|callout_stop
argument_list|(
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_itcallout
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|.
name|it_value
operator|.
name|tv_sec
operator|!=
literal|0
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_itcallout
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|it
operator|.
name|it_value
argument_list|)
argument_list|,
name|realitexpire
argument_list|,
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|it
operator|.
name|it_value
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_proc
operator|->
name|p_realtimer
operator|=
name|it
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|old_it
operator|.
name|it_value
argument_list|,
operator|&
name|tv
argument_list|,
operator|>
argument_list|)
condition|)
block|{
name|timevalsub
argument_list|(
operator|&
name|old_it
operator|.
name|it_value
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_it
operator|.
name|it_value
operator|.
name|tv_usec
operator|!=
literal|0
condition|)
name|old_it
operator|.
name|it_value
operator|.
name|tv_sec
operator|++
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|old_it
operator|.
name|it_value
operator|.
name|tv_sec
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*!__alpha__*/
end_comment

begin_function
name|int
name|linux_brk
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_brk_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|vmspace
modifier|*
name|vm
init|=
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
decl_stmt|;
name|vm_offset_t
name|new
decl_stmt|,
name|old
decl_stmt|;
name|struct
name|obreak_args
comment|/* { 		char * nsize; 	} */
name|tmp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|brk
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|brk
argument_list|,
literal|"%p"
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|dsend
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|old
operator|=
operator|(
name|vm_offset_t
operator|)
name|vm
operator|->
name|vm_daddr
operator|+
name|ctob
argument_list|(
name|vm
operator|->
name|vm_dsize
argument_list|)
expr_stmt|;
name|new
operator|=
operator|(
name|vm_offset_t
operator|)
name|args
operator|->
name|dsend
expr_stmt|;
name|tmp
operator|.
name|nsize
operator|=
operator|(
name|char
operator|*
operator|)
name|new
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|caddr_t
operator|)
name|new
operator|>
name|vm
operator|->
name|vm_daddr
operator|)
operator|&&
operator|!
name|obreak
argument_list|(
name|td
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
operator|(
name|long
operator|)
name|new
expr_stmt|;
else|else
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
operator|(
name|long
operator|)
name|old
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|linux_uselib
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_uselib_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|nameidata
name|ni
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|exec
modifier|*
name|a_out
decl_stmt|;
name|struct
name|vattr
name|attr
decl_stmt|;
name|vm_offset_t
name|vmaddr
decl_stmt|;
name|unsigned
name|long
name|file_offset
decl_stmt|;
name|vm_offset_t
name|buffer
decl_stmt|;
name|unsigned
name|long
name|bss_size
decl_stmt|;
name|char
modifier|*
name|library
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|locked
decl_stmt|;
name|LCONVPATHEXIST
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|library
argument_list|,
operator|&
name|library
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|uselib
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|uselib
argument_list|,
literal|"%s"
argument_list|)
argument_list|,
name|library
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|a_out
operator|=
name|NULL
expr_stmt|;
name|locked
operator|=
literal|0
expr_stmt|;
name|vp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * XXX: This code should make use of vn_open(), rather than doing 	 * all this stuff itself. 	 */
name|NDINIT
argument_list|(
operator|&
name|ni
argument_list|,
name|LOOKUP
argument_list|,
name|FOLLOW
operator||
name|LOCKLEAF
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|library
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|ni
argument_list|)
expr_stmt|;
name|LFREEPATH
argument_list|(
name|library
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
name|vp
operator|=
name|ni
operator|.
name|ni_vp
expr_stmt|;
comment|/* 	 * XXX - This looks like a bogus check. A LOCKLEAF namei should not 	 * succeed without returning a vnode. 	 */
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
comment|/* ?? */
goto|goto
name|cleanup
goto|;
block|}
name|NDFREE
argument_list|(
operator|&
name|ni
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
comment|/* 	 * From here on down, we have a locked vnode that must be unlocked. 	 */
name|locked
operator|++
expr_stmt|;
comment|/* Writable? */
if|if
condition|(
name|vp
operator|->
name|v_writecount
condition|)
block|{
name|error
operator|=
name|ETXTBSY
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Executable? */
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|attr
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_NOEXEC
operator|)
operator|||
operator|(
operator|(
name|attr
operator|.
name|va_mode
operator|&
literal|0111
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|attr
operator|.
name|va_type
operator|!=
name|VREG
operator|)
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Sensible size? */
if|if
condition|(
name|attr
operator|.
name|va_size
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Can we access it? */
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VEXEC
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 	 * XXX: This should use vn_open() so that it is properly authorized, 	 * and to reduce code redundancy all over the place here. 	 */
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_vnode_open
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|vp
argument_list|,
name|FREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
endif|#
directive|endif
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|vp
argument_list|,
name|FREAD
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Pull in executable header into kernel_map */
name|error
operator|=
name|vm_mmap
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|a_out
argument_list|,
name|PAGE_SIZE
argument_list|,
name|VM_PROT_READ
argument_list|,
name|VM_PROT_READ
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Lock no longer needed 	 */
name|locked
operator|=
literal|0
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Is it a Linux binary ? */
if|if
condition|(
operator|(
operator|(
name|a_out
operator|->
name|a_magic
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator|!=
literal|0x64
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * While we are here, we should REALLY do some more checks 	 */
comment|/* Set file/virtual offset based on a.out variant. */
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
name|a_out
operator|->
name|a_magic
operator|&
literal|0xffff
argument_list|)
condition|)
block|{
case|case
literal|0413
case|:
comment|/* ZMAGIC */
name|file_offset
operator|=
literal|1024
expr_stmt|;
break|break;
case|case
literal|0314
case|:
comment|/* QMAGIC */
name|file_offset
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|bss_size
operator|=
name|round_page
argument_list|(
name|a_out
operator|->
name|a_bss
argument_list|)
expr_stmt|;
comment|/* Check various fields in header for validity/bounds. */
if|if
condition|(
name|a_out
operator|->
name|a_text
operator|&
name|PAGE_MASK
operator|||
name|a_out
operator|->
name|a_data
operator|&
name|PAGE_MASK
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* text + data can't exceed file size */
if|if
condition|(
name|a_out
operator|->
name|a_data
operator|+
name|a_out
operator|->
name|a_text
operator|>
name|attr
operator|.
name|va_size
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* To protect td->td_proc->p_rlimit in the if condition. */
name|mtx_assert
argument_list|(
operator|&
name|Giant
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * text/data/bss must not exceed limits 	 * XXX - this is not complete. it should check current usage PLUS 	 * the resources needed by this library. 	 */
if|if
condition|(
name|a_out
operator|->
name|a_text
operator|>
name|maxtsiz
operator|||
name|a_out
operator|->
name|a_data
operator|+
name|bss_size
operator|>
name|td
operator|->
name|td_proc
operator|->
name|p_rlimit
index|[
name|RLIMIT_DATA
index|]
operator|.
name|rlim_cur
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|mp_fixme
argument_list|(
literal|"Unlocked vflags access."
argument_list|)
expr_stmt|;
comment|/* prevent more writers */
name|vp
operator|->
name|v_vflag
operator||=
name|VV_TEXT
expr_stmt|;
comment|/* 	 * Check if file_offset page aligned. Currently we cannot handle 	 * misalinged file offsets, and so we read in the entire image 	 * (what a waste). 	 */
if|if
condition|(
name|file_offset
operator|&
name|PAGE_MASK
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"uselib: Non page aligned binary %lu\n"
argument_list|,
name|file_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Map text+data read/write/execute */
comment|/* a_entry is the load address and is page aligned */
name|vmaddr
operator|=
name|trunc_page
argument_list|(
name|a_out
operator|->
name|a_entry
argument_list|)
expr_stmt|;
comment|/* get anon user mapping, read+write+execute */
name|error
operator|=
name|vm_map_find
argument_list|(
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|vmaddr
argument_list|,
name|a_out
operator|->
name|a_text
operator|+
name|a_out
operator|->
name|a_data
argument_list|,
name|FALSE
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
comment|/* map file into kernel_map */
name|error
operator|=
name|vm_mmap
argument_list|(
name|kernel_map
argument_list|,
operator|&
name|buffer
argument_list|,
name|round_page
argument_list|(
name|a_out
operator|->
name|a_text
operator|+
name|a_out
operator|->
name|a_data
operator|+
name|file_offset
argument_list|)
argument_list|,
name|VM_PROT_READ
argument_list|,
name|VM_PROT_READ
argument_list|,
literal|0
argument_list|,
operator|(
name|caddr_t
operator|)
name|vp
argument_list|,
name|trunc_page
argument_list|(
name|file_offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
comment|/* copy from kernel VM space to user space */
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|buffer
operator|+
name|file_offset
operator|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vmaddr
argument_list|,
name|a_out
operator|->
name|a_text
operator|+
name|a_out
operator|->
name|a_data
argument_list|)
expr_stmt|;
comment|/* release temporary kernel space */
name|vm_map_remove
argument_list|(
name|kernel_map
argument_list|,
name|buffer
argument_list|,
name|buffer
operator|+
name|round_page
argument_list|(
name|a_out
operator|->
name|a_text
operator|+
name|a_out
operator|->
name|a_data
operator|+
name|file_offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"uselib: Page aligned binary %lu\n"
argument_list|,
name|file_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * for QMAGIC, a_entry is 20 bytes beyond the load address 		 * to skip the executable header 		 */
name|vmaddr
operator|=
name|trunc_page
argument_list|(
name|a_out
operator|->
name|a_entry
argument_list|)
expr_stmt|;
comment|/* 		 * Map it all into the process's space as a single 		 * copy-on-write "data" segment. 		 */
name|error
operator|=
name|vm_mmap
argument_list|(
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
operator|&
name|vmaddr
argument_list|,
name|a_out
operator|->
name|a_text
operator|+
name|a_out
operator|->
name|a_data
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_FIXED
argument_list|,
operator|(
name|caddr_t
operator|)
name|vp
argument_list|,
name|file_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"mem=%08lx = %08lx %08lx\n"
argument_list|,
operator|(
name|long
operator|)
name|vmaddr
argument_list|,
operator|(
operator|(
name|long
operator|*
operator|)
name|vmaddr
operator|)
index|[
literal|0
index|]
argument_list|,
operator|(
operator|(
name|long
operator|*
operator|)
name|vmaddr
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bss_size
operator|!=
literal|0
condition|)
block|{
comment|/* Calculate BSS start address */
name|vmaddr
operator|=
name|trunc_page
argument_list|(
name|a_out
operator|->
name|a_entry
argument_list|)
operator|+
name|a_out
operator|->
name|a_text
operator|+
name|a_out
operator|->
name|a_data
expr_stmt|;
comment|/* allocate some 'anon' space */
name|error
operator|=
name|vm_map_find
argument_list|(
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|vmaddr
argument_list|,
name|bss_size
argument_list|,
name|FALSE
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
block|}
name|cleanup
label|:
comment|/* Unlock vnode if needed */
if|if
condition|(
name|locked
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* Release the kernel mapping. */
if|if
condition|(
name|a_out
condition|)
name|vm_map_remove
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|a_out
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|a_out
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|linux_select
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_select_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|timeval
name|tv0
decl_stmt|,
name|tv1
decl_stmt|,
name|utv
decl_stmt|,
modifier|*
name|tvp
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|select
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|select
argument_list|,
literal|"%d, %p, %p, %p, %p"
argument_list|)
argument_list|,
name|args
operator|->
name|nfds
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|readfds
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|writefds
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|exceptfds
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|timeout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Store current time for computation of the amount of 	 * time left. 	 */
if|if
condition|(
name|args
operator|->
name|timeout
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|timeout
argument_list|,
operator|&
name|utv
argument_list|,
sizeof|sizeof
argument_list|(
name|utv
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|select_out
goto|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|select
argument_list|)
condition|)
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"incoming timeout (%ld/%ld)"
argument_list|)
argument_list|,
name|utv
operator|.
name|tv_sec
argument_list|,
name|utv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|itimerfix
argument_list|(
operator|&
name|utv
argument_list|)
condition|)
block|{
comment|/* 			 * The timeval was invalid.  Convert it to something 			 * valid that will act as it does under Linux. 			 */
name|utv
operator|.
name|tv_sec
operator|+=
name|utv
operator|.
name|tv_usec
operator|/
literal|1000000
expr_stmt|;
name|utv
operator|.
name|tv_usec
operator|%=
literal|1000000
expr_stmt|;
if|if
condition|(
name|utv
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|utv
operator|.
name|tv_sec
operator|-=
literal|1
expr_stmt|;
name|utv
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
if|if
condition|(
name|utv
operator|.
name|tv_sec
operator|<
literal|0
condition|)
name|timevalclear
argument_list|(
operator|&
name|utv
argument_list|)
expr_stmt|;
block|}
name|microtime
argument_list|(
operator|&
name|tv0
argument_list|)
expr_stmt|;
name|tvp
operator|=
operator|&
name|utv
expr_stmt|;
block|}
else|else
name|tvp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|kern_select
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|nfds
argument_list|,
name|args
operator|->
name|readfds
argument_list|,
name|args
operator|->
name|writefds
argument_list|,
name|args
operator|->
name|exceptfds
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|select
argument_list|)
condition|)
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"real select returns %d"
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * See fs/select.c in the Linux kernel.  Without this, 		 * Maelstrom doesn't work. 		 */
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
goto|goto
name|select_out
goto|;
block|}
if|if
condition|(
name|args
operator|->
name|timeout
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
condition|)
block|{
comment|/* 			 * Compute how much time was left of the timeout, 			 * by subtracting the current time and the time 			 * before we started the call, and subtracting 			 * that result from the user-supplied value. 			 */
name|microtime
argument_list|(
operator|&
name|tv1
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|tv1
argument_list|,
operator|&
name|tv0
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|utv
argument_list|,
operator|&
name|tv1
argument_list|)
expr_stmt|;
if|if
condition|(
name|utv
operator|.
name|tv_sec
operator|<
literal|0
condition|)
name|timevalclear
argument_list|(
operator|&
name|utv
argument_list|)
expr_stmt|;
block|}
else|else
name|timevalclear
argument_list|(
operator|&
name|utv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|select
argument_list|)
condition|)
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"outgoing timeout (%ld/%ld)"
argument_list|)
argument_list|,
name|utv
operator|.
name|tv_sec
argument_list|,
name|utv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|utv
argument_list|,
name|args
operator|->
name|timeout
argument_list|,
sizeof|sizeof
argument_list|(
name|utv
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|select_out
goto|;
block|}
name|select_out
label|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|select
argument_list|)
condition|)
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"select_out -> %d"
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|linux_mremap
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_mremap_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|munmap_args
comment|/* { 		void *addr; 		size_t len; 	} */
name|bsd_args
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|mremap
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|mremap
argument_list|,
literal|"%p, %08lx, %08lx, %08lx"
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|addr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|args
operator|->
name|old_len
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|args
operator|->
name|new_len
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|args
operator|->
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|args
operator|->
name|new_len
operator|=
name|round_page
argument_list|(
name|args
operator|->
name|new_len
argument_list|)
expr_stmt|;
name|args
operator|->
name|old_len
operator|=
name|round_page
argument_list|(
name|args
operator|->
name|old_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|new_len
operator|>
name|args
operator|->
name|old_len
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
if|if
condition|(
name|args
operator|->
name|new_len
operator|<
name|args
operator|->
name|old_len
condition|)
block|{
name|bsd_args
operator|.
name|addr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|args
operator|->
name|addr
operator|+
name|args
operator|->
name|new_len
argument_list|)
expr_stmt|;
name|bsd_args
operator|.
name|len
operator|=
name|args
operator|->
name|old_len
operator|-
name|args
operator|->
name|new_len
expr_stmt|;
name|error
operator|=
name|munmap
argument_list|(
name|td
argument_list|,
operator|&
name|bsd_args
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|error
condition|?
literal|0
else|:
operator|(
name|uintptr_t
operator|)
name|args
operator|->
name|addr
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_define
define|#
directive|define
name|LINUX_MS_ASYNC
value|0x0001
end_define

begin_define
define|#
directive|define
name|LINUX_MS_INVALIDATE
value|0x0002
end_define

begin_define
define|#
directive|define
name|LINUX_MS_SYNC
value|0x0004
end_define

begin_function
name|int
name|linux_msync
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_msync_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|msync_args
name|bsd_args
decl_stmt|;
name|bsd_args
operator|.
name|addr
operator|=
operator|(
name|caddr_t
operator|)
name|args
operator|->
name|addr
expr_stmt|;
name|bsd_args
operator|.
name|len
operator|=
name|args
operator|->
name|len
expr_stmt|;
name|bsd_args
operator|.
name|flags
operator|=
name|args
operator|->
name|fl
operator|&
operator|~
name|LINUX_MS_SYNC
expr_stmt|;
return|return
name|msync
argument_list|(
name|td
argument_list|,
operator|&
name|bsd_args
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|__alpha__
end_ifndef

begin_function
name|int
name|linux_time
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_time_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|l_time_t
name|tm
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|time
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|time
argument_list|,
literal|"*"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|tm
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|tm
operator|&&
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|tm
argument_list|,
name|args
operator|->
name|tm
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|tm
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*!__alpha__*/
end_comment

begin_struct
struct|struct
name|l_times_argv
block|{
name|l_long
name|tms_utime
decl_stmt|;
name|l_long
name|tms_stime
decl_stmt|;
name|l_long
name|tms_cutime
decl_stmt|;
name|l_long
name|tms_cstime
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|__alpha__
end_ifdef

begin_define
define|#
directive|define
name|CLK_TCK
value|1024
end_define

begin_comment
comment|/* Linux uses 1024 on alpha */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CLK_TCK
value|100
end_define

begin_comment
comment|/* Linux uses 100 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CONVTCK
parameter_list|(
name|r
parameter_list|)
value|(r.tv_sec * CLK_TCK + r.tv_usec / (1000000 / CLK_TCK))
end_define

begin_function
name|int
name|linux_times
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_times_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|l_times_argv
name|tms
decl_stmt|;
name|struct
name|rusage
name|ru
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|times
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|times
argument_list|,
literal|"*"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|calcru
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
operator|&
name|ru
operator|.
name|ru_utime
argument_list|,
operator|&
name|ru
operator|.
name|ru_stime
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|tms
operator|.
name|tms_utime
operator|=
name|CONVTCK
argument_list|(
name|ru
operator|.
name|ru_utime
argument_list|)
expr_stmt|;
name|tms
operator|.
name|tms_stime
operator|=
name|CONVTCK
argument_list|(
name|ru
operator|.
name|ru_stime
argument_list|)
expr_stmt|;
name|tms
operator|.
name|tms_cutime
operator|=
name|CONVTCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_stats
operator|->
name|p_cru
operator|.
name|ru_utime
argument_list|)
expr_stmt|;
name|tms
operator|.
name|tms_cstime
operator|=
name|CONVTCK
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_stats
operator|->
name|p_cru
operator|.
name|ru_stime
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|tms
argument_list|,
name|args
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|tms
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
name|microuptime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|)
name|CONVTCK
argument_list|(
name|tv
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|linux_newuname
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_newuname_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|l_new_utsname
name|utsname
decl_stmt|;
name|char
name|osname
index|[
name|LINUX_MAX_UTSNAME
index|]
decl_stmt|;
name|char
name|osrelease
index|[
name|LINUX_MAX_UTSNAME
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|newuname
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|newuname
argument_list|,
literal|"*"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|linux_get_osname
argument_list|(
name|td
argument_list|,
name|osname
argument_list|)
expr_stmt|;
name|linux_get_osrelease
argument_list|(
name|td
argument_list|,
name|osrelease
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|utsname
argument_list|,
sizeof|sizeof
argument_list|(
name|utsname
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|utsname
operator|.
name|sysname
argument_list|,
name|osname
argument_list|,
name|LINUX_MAX_UTSNAME
argument_list|)
expr_stmt|;
name|getcredhostname
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|utsname
operator|.
name|nodename
argument_list|,
name|LINUX_MAX_UTSNAME
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|utsname
operator|.
name|release
argument_list|,
name|osrelease
argument_list|,
name|LINUX_MAX_UTSNAME
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|utsname
operator|.
name|version
argument_list|,
name|version
argument_list|,
name|LINUX_MAX_UTSNAME
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|utsname
operator|.
name|machine
argument_list|,
name|machine
argument_list|,
name|LINUX_MAX_UTSNAME
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|utsname
operator|.
name|domainname
argument_list|,
name|domainname
argument_list|,
name|LINUX_MAX_UTSNAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|utsname
argument_list|,
name|args
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|utsname
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_struct
struct|struct
name|l_utimbuf
block|{
name|l_time_t
name|l_actime
decl_stmt|;
name|l_time_t
name|l_modtime
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|linux_utime
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_utime_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|timeval
name|tv
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|tvp
decl_stmt|;
name|struct
name|l_utimbuf
name|lut
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|error
decl_stmt|;
name|LCONVPATHEXIST
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|fname
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|utime
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|utime
argument_list|,
literal|"%s, *"
argument_list|)
argument_list|,
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|times
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|times
argument_list|,
operator|&
name|lut
argument_list|,
sizeof|sizeof
name|lut
argument_list|)
operator|)
condition|)
block|{
name|LFREEPATH
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|tv
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|lut
operator|.
name|l_actime
expr_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|lut
operator|.
name|l_modtime
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tvp
operator|=
name|tv
expr_stmt|;
block|}
else|else
name|tvp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|kern_utimes
argument_list|(
name|td
argument_list|,
name|fname
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|tvp
argument_list|,
name|UIO_SYSSPACE
argument_list|)
expr_stmt|;
name|LFREEPATH
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __i386__ */
end_comment

begin_define
define|#
directive|define
name|__WCLONE
value|0x80000000
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|__alpha__
end_ifndef

begin_function
name|int
name|linux_waitpid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_waitpid_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|wait_args
comment|/* { 		int pid; 		int *status; 		int options; 		struct	rusage *rusage; 	} */
name|tmp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|tmpstat
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|waitpid
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|waitpid
argument_list|,
literal|"%d, %p, %d"
argument_list|)
argument_list|,
name|args
operator|->
name|pid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|status
argument_list|,
name|args
operator|->
name|options
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tmp
operator|.
name|pid
operator|=
name|args
operator|->
name|pid
expr_stmt|;
name|tmp
operator|.
name|status
operator|=
name|args
operator|->
name|status
expr_stmt|;
name|tmp
operator|.
name|options
operator|=
operator|(
name|args
operator|->
name|options
operator|&
operator|(
name|WNOHANG
operator||
name|WUNTRACED
operator|)
operator|)
expr_stmt|;
comment|/* WLINUXCLONE should be equal to __WCLONE, but we make sure */
if|if
condition|(
name|args
operator|->
name|options
operator|&
name|__WCLONE
condition|)
name|tmp
operator|.
name|options
operator||=
name|WLINUXCLONE
expr_stmt|;
name|tmp
operator|.
name|rusage
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|wait4
argument_list|(
name|td
argument_list|,
operator|&
name|tmp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
name|args
operator|->
name|status
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|status
argument_list|,
operator|&
name|tmpstat
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|tmpstat
operator|&=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|tmpstat
argument_list|)
condition|)
name|tmpstat
operator|=
operator|(
name|tmpstat
operator|&
literal|0xffffff80
operator|)
operator||
name|BSD_TO_LINUX_SIGNAL
argument_list|(
name|WTERMSIG
argument_list|(
name|tmpstat
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|tmpstat
argument_list|)
condition|)
name|tmpstat
operator|=
operator|(
name|tmpstat
operator|&
literal|0xffff00ff
operator|)
operator||
operator|(
name|BSD_TO_LINUX_SIGNAL
argument_list|(
name|WSTOPSIG
argument_list|(
name|tmpstat
argument_list|)
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|tmpstat
argument_list|,
name|args
operator|->
name|status
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*!__alpha__*/
end_comment

begin_function
name|int
name|linux_wait4
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_wait4_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|wait_args
comment|/* { 		int pid; 		int *status; 		int options; 		struct	rusage *rusage; 	} */
name|tmp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|tmpstat
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|wait4
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|wait4
argument_list|,
literal|"%d, %p, %d, %p"
argument_list|)
argument_list|,
name|args
operator|->
name|pid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|status
argument_list|,
name|args
operator|->
name|options
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|rusage
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tmp
operator|.
name|pid
operator|=
name|args
operator|->
name|pid
expr_stmt|;
name|tmp
operator|.
name|status
operator|=
name|args
operator|->
name|status
expr_stmt|;
name|tmp
operator|.
name|options
operator|=
operator|(
name|args
operator|->
name|options
operator|&
operator|(
name|WNOHANG
operator||
name|WUNTRACED
operator|)
operator|)
expr_stmt|;
comment|/* WLINUXCLONE should be equal to __WCLONE, but we make sure */
if|if
condition|(
name|args
operator|->
name|options
operator|&
name|__WCLONE
condition|)
name|tmp
operator|.
name|options
operator||=
name|WLINUXCLONE
expr_stmt|;
name|tmp
operator|.
name|rusage
operator|=
operator|(
expr|struct
name|rusage
operator|*
operator|)
name|args
operator|->
name|rusage
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|wait4
argument_list|(
name|td
argument_list|,
operator|&
name|tmp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|SIGDELSET
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_siglist
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|status
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|status
argument_list|,
operator|&
name|tmpstat
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|tmpstat
operator|&=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|tmpstat
argument_list|)
condition|)
name|tmpstat
operator|=
operator|(
name|tmpstat
operator|&
literal|0xffffff80
operator|)
operator||
name|BSD_TO_LINUX_SIGNAL
argument_list|(
name|WTERMSIG
argument_list|(
name|tmpstat
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|tmpstat
argument_list|)
condition|)
name|tmpstat
operator|=
operator|(
name|tmpstat
operator|&
literal|0xffff00ff
operator|)
operator||
operator|(
name|BSD_TO_LINUX_SIGNAL
argument_list|(
name|WSTOPSIG
argument_list|(
name|tmpstat
argument_list|)
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|tmpstat
argument_list|,
name|args
operator|->
name|status
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|linux_mknod
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_mknod_args
modifier|*
name|args
parameter_list|)
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|error
decl_stmt|;
name|LCONVPATHCREAT
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|path
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|mknod
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|mknod
argument_list|,
literal|"%s, %d, %d"
argument_list|)
argument_list|,
name|path
argument_list|,
name|args
operator|->
name|mode
argument_list|,
name|args
operator|->
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|mode
operator|&
name|S_IFIFO
condition|)
name|error
operator|=
name|kern_mkfifo
argument_list|(
name|td
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|args
operator|->
name|mode
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|kern_mknod
argument_list|(
name|td
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|args
operator|->
name|mode
argument_list|,
name|args
operator|->
name|dev
argument_list|)
expr_stmt|;
name|LFREEPATH
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * UGH! This is just about the dumbest idea I've ever heard!!  */
end_comment

begin_function
name|int
name|linux_personality
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_personality_args
modifier|*
name|args
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|personality
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|personality
argument_list|,
literal|"%ld"
argument_list|)
argument_list|,
name|args
operator|->
name|per
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|__alpha__
if|if
condition|(
name|args
operator|->
name|per
operator|!=
literal|0
condition|)
return|return
name|EINVAL
return|;
endif|#
directive|endif
comment|/* Yes Jim, it's still a Linux... */
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Wrappers for get/setitimer for debugging..  */
end_comment

begin_function
name|int
name|linux_setitimer
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_setitimer_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|setitimer_args
name|bsa
decl_stmt|;
name|struct
name|itimerval
name|foo
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|setitimer
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|setitimer
argument_list|,
literal|"%p, %p"
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|itv
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|oitv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bsa
operator|.
name|which
operator|=
name|args
operator|->
name|which
expr_stmt|;
name|bsa
operator|.
name|itv
operator|=
operator|(
expr|struct
name|itimerval
operator|*
operator|)
name|args
operator|->
name|itv
expr_stmt|;
name|bsa
operator|.
name|oitv
operator|=
operator|(
expr|struct
name|itimerval
operator|*
operator|)
name|args
operator|->
name|oitv
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|itv
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|itv
argument_list|,
operator|&
name|foo
argument_list|,
sizeof|sizeof
argument_list|(
name|foo
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|error
return|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|setitimer
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"setitimer: value: sec: %ld, usec: %ld\n"
argument_list|,
name|foo
operator|.
name|it_value
operator|.
name|tv_sec
argument_list|,
name|foo
operator|.
name|it_value
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"setitimer: interval: sec: %ld, usec: %ld\n"
argument_list|,
name|foo
operator|.
name|it_interval
operator|.
name|tv_sec
argument_list|,
name|foo
operator|.
name|it_interval
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
name|setitimer
argument_list|(
name|td
argument_list|,
operator|&
name|bsa
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|linux_getitimer
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getitimer_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|getitimer_args
name|bsa
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|getitimer
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|getitimer
argument_list|,
literal|"%p"
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|itv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bsa
operator|.
name|which
operator|=
name|args
operator|->
name|which
expr_stmt|;
name|bsa
operator|.
name|itv
operator|=
operator|(
expr|struct
name|itimerval
operator|*
operator|)
name|args
operator|->
name|itv
expr_stmt|;
return|return
name|getitimer
argument_list|(
name|td
argument_list|,
operator|&
name|bsa
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|__alpha__
end_ifndef

begin_function
name|int
name|linux_nice
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_nice_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|setpriority_args
name|bsd_args
decl_stmt|;
name|bsd_args
operator|.
name|which
operator|=
name|PRIO_PROCESS
expr_stmt|;
name|bsd_args
operator|.
name|who
operator|=
literal|0
expr_stmt|;
comment|/* current process */
name|bsd_args
operator|.
name|prio
operator|=
name|args
operator|->
name|inc
expr_stmt|;
return|return
name|setpriority
argument_list|(
name|td
argument_list|,
operator|&
name|bsd_args
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*!__alpha__*/
end_comment

begin_function
name|int
name|linux_setgroups
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_setgroups_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|,
modifier|*
name|oldcred
decl_stmt|;
name|l_gid_t
name|linux_gidset
index|[
name|NGROUPS
index|]
decl_stmt|;
name|gid_t
modifier|*
name|bsd_gidset
decl_stmt|;
name|int
name|ngrp
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|ngrp
operator|=
name|args
operator|->
name|gidsetsize
expr_stmt|;
if|if
condition|(
name|ngrp
operator|>=
name|NGROUPS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|grouplist
argument_list|,
name|linux_gidset
argument_list|,
name|ngrp
operator|*
sizeof|sizeof
argument_list|(
name|l_gid_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|newcred
operator|=
name|crget
argument_list|()
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|oldcred
operator|=
name|p
operator|->
name|p_ucred
expr_stmt|;
comment|/* 	 * cr_groups[0] holds egid. Setting the whole set from 	 * the supplied set will cause egid to be changed too. 	 * Keep cr_groups[0] unchanged to prevent that. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|suser_cred
argument_list|(
name|oldcred
argument_list|,
name|PRISON_ROOT
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|newcred
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|crcopy
argument_list|(
name|newcred
argument_list|,
name|oldcred
argument_list|)
expr_stmt|;
if|if
condition|(
name|ngrp
operator|>
literal|0
condition|)
block|{
name|newcred
operator|->
name|cr_ngroups
operator|=
name|ngrp
operator|+
literal|1
expr_stmt|;
name|bsd_gidset
operator|=
name|newcred
operator|->
name|cr_groups
expr_stmt|;
name|ngrp
operator|--
expr_stmt|;
while|while
condition|(
name|ngrp
operator|>=
literal|0
condition|)
block|{
name|bsd_gidset
index|[
name|ngrp
operator|+
literal|1
index|]
operator|=
name|linux_gidset
index|[
name|ngrp
index|]
expr_stmt|;
name|ngrp
operator|--
expr_stmt|;
block|}
block|}
else|else
name|newcred
operator|->
name|cr_ngroups
operator|=
literal|1
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_ucred
operator|=
name|newcred
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_getgroups
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getgroups_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|l_gid_t
name|linux_gidset
index|[
name|NGROUPS
index|]
decl_stmt|;
name|gid_t
modifier|*
name|bsd_gidset
decl_stmt|;
name|int
name|bsd_gidsetsz
decl_stmt|,
name|ngrp
decl_stmt|,
name|error
decl_stmt|;
name|cred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
name|bsd_gidset
operator|=
name|cred
operator|->
name|cr_groups
expr_stmt|;
name|bsd_gidsetsz
operator|=
name|cred
operator|->
name|cr_ngroups
operator|-
literal|1
expr_stmt|;
comment|/* 	 * cr_groups[0] holds egid. Returning the whole set 	 * here will cause a duplicate. Exclude cr_groups[0] 	 * to prevent that. 	 */
if|if
condition|(
operator|(
name|ngrp
operator|=
name|args
operator|->
name|gidsetsize
operator|)
operator|==
literal|0
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|bsd_gidsetsz
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ngrp
operator|<
name|bsd_gidsetsz
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ngrp
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ngrp
operator|<
name|bsd_gidsetsz
condition|)
block|{
name|linux_gidset
index|[
name|ngrp
index|]
operator|=
name|bsd_gidset
index|[
name|ngrp
operator|+
literal|1
index|]
expr_stmt|;
name|ngrp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
name|linux_gidset
argument_list|,
name|args
operator|->
name|grouplist
argument_list|,
name|ngrp
operator|*
sizeof|sizeof
argument_list|(
name|l_gid_t
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|ngrp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|__alpha__
end_ifndef

begin_function
name|int
name|linux_setrlimit
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_setrlimit_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|rlimit
name|bsd_rlim
decl_stmt|;
name|struct
name|l_rlimit
name|rlim
decl_stmt|;
name|u_int
name|which
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|setrlimit
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|setrlimit
argument_list|,
literal|"%d, %p"
argument_list|)
argument_list|,
name|args
operator|->
name|resource
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|rlim
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|resource
operator|>=
name|LINUX_RLIM_NLIMITS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|which
operator|=
name|linux_to_bsd_resource
index|[
name|args
operator|->
name|resource
index|]
expr_stmt|;
if|if
condition|(
name|which
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|rlim
argument_list|,
operator|&
name|rlim
argument_list|,
sizeof|sizeof
argument_list|(
name|rlim
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bsd_rlim
operator|.
name|rlim_cur
operator|=
operator|(
name|rlim_t
operator|)
name|rlim
operator|.
name|rlim_cur
expr_stmt|;
name|bsd_rlim
operator|.
name|rlim_max
operator|=
operator|(
name|rlim_t
operator|)
name|rlim
operator|.
name|rlim_max
expr_stmt|;
return|return
operator|(
name|dosetrlimit
argument_list|(
name|td
argument_list|,
name|which
argument_list|,
operator|&
name|bsd_rlim
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_old_getrlimit
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_old_getrlimit_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|l_rlimit
name|rlim
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|rlimit
modifier|*
name|bsd_rlp
decl_stmt|;
name|u_int
name|which
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|old_getrlimit
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|old_getrlimit
argument_list|,
literal|"%d, %p"
argument_list|)
argument_list|,
name|args
operator|->
name|resource
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|rlim
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|resource
operator|>=
name|LINUX_RLIM_NLIMITS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|which
operator|=
name|linux_to_bsd_resource
index|[
name|args
operator|->
name|resource
index|]
expr_stmt|;
if|if
condition|(
name|which
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bsd_rlp
operator|=
operator|&
name|p
operator|->
name|p_rlimit
index|[
name|which
index|]
expr_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bsd_rlp
operator|->
name|rlim_cur
expr_stmt|;
if|if
condition|(
name|rlim
operator|.
name|rlim_cur
operator|==
name|ULONG_MAX
condition|)
name|rlim
operator|.
name|rlim_cur
operator|=
name|LONG_MAX
expr_stmt|;
name|rlim
operator|.
name|rlim_max
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bsd_rlp
operator|->
name|rlim_max
expr_stmt|;
if|if
condition|(
name|rlim
operator|.
name|rlim_max
operator|==
name|ULONG_MAX
condition|)
name|rlim
operator|.
name|rlim_max
operator|=
name|LONG_MAX
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|rlim
argument_list|,
name|args
operator|->
name|rlim
argument_list|,
sizeof|sizeof
argument_list|(
name|rlim
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_getrlimit
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getrlimit_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|l_rlimit
name|rlim
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|rlimit
modifier|*
name|bsd_rlp
decl_stmt|;
name|u_int
name|which
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|getrlimit
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|getrlimit
argument_list|,
literal|"%d, %p"
argument_list|)
argument_list|,
name|args
operator|->
name|resource
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|rlim
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|resource
operator|>=
name|LINUX_RLIM_NLIMITS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|which
operator|=
name|linux_to_bsd_resource
index|[
name|args
operator|->
name|resource
index|]
expr_stmt|;
if|if
condition|(
name|which
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bsd_rlp
operator|=
operator|&
name|p
operator|->
name|p_rlimit
index|[
name|which
index|]
expr_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
operator|(
name|l_ulong
operator|)
name|bsd_rlp
operator|->
name|rlim_cur
expr_stmt|;
name|rlim
operator|.
name|rlim_max
operator|=
operator|(
name|l_ulong
operator|)
name|bsd_rlp
operator|->
name|rlim_max
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|rlim
argument_list|,
name|args
operator|->
name|rlim
argument_list|,
sizeof|sizeof
argument_list|(
name|rlim
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*!__alpha__*/
end_comment

begin_function
name|int
name|linux_sched_setscheduler
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_sched_setscheduler_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|sched_setscheduler_args
name|bsd
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|sched_setscheduler
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|sched_setscheduler
argument_list|,
literal|"%d, %d, %p"
argument_list|)
argument_list|,
name|args
operator|->
name|pid
argument_list|,
name|args
operator|->
name|policy
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|args
operator|->
name|param
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|args
operator|->
name|policy
condition|)
block|{
case|case
name|LINUX_SCHED_OTHER
case|:
name|bsd
operator|.
name|policy
operator|=
name|SCHED_OTHER
expr_stmt|;
break|break;
case|case
name|LINUX_SCHED_FIFO
case|:
name|bsd
operator|.
name|policy
operator|=
name|SCHED_FIFO
expr_stmt|;
break|break;
case|case
name|LINUX_SCHED_RR
case|:
name|bsd
operator|.
name|policy
operator|=
name|SCHED_RR
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
name|bsd
operator|.
name|pid
operator|=
name|args
operator|->
name|pid
expr_stmt|;
name|bsd
operator|.
name|param
operator|=
operator|(
expr|struct
name|sched_param
operator|*
operator|)
name|args
operator|->
name|param
expr_stmt|;
return|return
name|sched_setscheduler
argument_list|(
name|td
argument_list|,
operator|&
name|bsd
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|linux_sched_getscheduler
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_sched_getscheduler_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|sched_getscheduler_args
name|bsd
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|sched_getscheduler
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|sched_getscheduler
argument_list|,
literal|"%d"
argument_list|)
argument_list|,
name|args
operator|->
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bsd
operator|.
name|pid
operator|=
name|args
operator|->
name|pid
expr_stmt|;
name|error
operator|=
name|sched_getscheduler
argument_list|(
name|td
argument_list|,
operator|&
name|bsd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
condition|)
block|{
case|case
name|SCHED_OTHER
case|:
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|LINUX_SCHED_OTHER
expr_stmt|;
break|break;
case|case
name|SCHED_FIFO
case|:
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|LINUX_SCHED_FIFO
expr_stmt|;
break|break;
case|case
name|SCHED_RR
case|:
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|LINUX_SCHED_RR
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|linux_sched_get_priority_max
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_sched_get_priority_max_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|sched_get_priority_max_args
name|bsd
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|sched_get_priority_max
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|sched_get_priority_max
argument_list|,
literal|"%d"
argument_list|)
argument_list|,
name|args
operator|->
name|policy
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|args
operator|->
name|policy
condition|)
block|{
case|case
name|LINUX_SCHED_OTHER
case|:
name|bsd
operator|.
name|policy
operator|=
name|SCHED_OTHER
expr_stmt|;
break|break;
case|case
name|LINUX_SCHED_FIFO
case|:
name|bsd
operator|.
name|policy
operator|=
name|SCHED_FIFO
expr_stmt|;
break|break;
case|case
name|LINUX_SCHED_RR
case|:
name|bsd
operator|.
name|policy
operator|=
name|SCHED_RR
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
return|return
name|sched_get_priority_max
argument_list|(
name|td
argument_list|,
operator|&
name|bsd
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|linux_sched_get_priority_min
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_sched_get_priority_min_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|sched_get_priority_min_args
name|bsd
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|sched_get_priority_min
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|sched_get_priority_min
argument_list|,
literal|"%d"
argument_list|)
argument_list|,
name|args
operator|->
name|policy
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|args
operator|->
name|policy
condition|)
block|{
case|case
name|LINUX_SCHED_OTHER
case|:
name|bsd
operator|.
name|policy
operator|=
name|SCHED_OTHER
expr_stmt|;
break|break;
case|case
name|LINUX_SCHED_FIFO
case|:
name|bsd
operator|.
name|policy
operator|=
name|SCHED_FIFO
expr_stmt|;
break|break;
case|case
name|LINUX_SCHED_RR
case|:
name|bsd
operator|.
name|policy
operator|=
name|SCHED_RR
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
return|return
name|sched_get_priority_min
argument_list|(
name|td
argument_list|,
operator|&
name|bsd
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|REBOOT_CAD_ON
value|0x89abcdef
end_define

begin_define
define|#
directive|define
name|REBOOT_CAD_OFF
value|0
end_define

begin_define
define|#
directive|define
name|REBOOT_HALT
value|0xcdef0123
end_define

begin_function
name|int
name|linux_reboot
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_reboot_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|reboot_args
name|bsd_args
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|reboot
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|reboot
argument_list|,
literal|"0x%x"
argument_list|)
argument_list|,
name|args
operator|->
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|cmd
operator|==
name|REBOOT_CAD_ON
operator|||
name|args
operator|->
name|cmd
operator|==
name|REBOOT_CAD_OFF
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bsd_args
operator|.
name|opt
operator|=
operator|(
name|args
operator|->
name|cmd
operator|==
name|REBOOT_HALT
operator|)
condition|?
name|RB_HALT
else|:
literal|0
expr_stmt|;
return|return
operator|(
name|reboot
argument_list|(
name|td
argument_list|,
operator|&
name|bsd_args
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|__alpha__
end_ifndef

begin_comment
comment|/*  * The FreeBSD native getpid(2), getgid(2) and getuid(2) also modify  * td->td_retval[1] when COMPAT_43 or COMPAT_SUNOS is defined. This  * globbers registers that are assumed to be preserved. The following  * lightweight syscalls fixes this. See also linux_getgid16() and  * linux_getuid16() in linux_uid16.c.  *  * linux_getpid() - MP SAFE  * linux_getgid() - MP SAFE  * linux_getuid() - MP SAFE  */
end_comment

begin_function
name|int
name|linux_getpid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getpid_args
modifier|*
name|args
parameter_list|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_getgid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getgid_args
modifier|*
name|args
parameter_list|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_rgid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_getuid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getuid_args
modifier|*
name|args
parameter_list|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_ruid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*!__alpha__*/
end_comment

begin_function
name|int
name|linux_getsid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getsid_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|getsid_args
name|bsd
decl_stmt|;
name|bsd
operator|.
name|pid
operator|=
name|args
operator|->
name|pid
expr_stmt|;
return|return
name|getsid
argument_list|(
name|td
argument_list|,
operator|&
name|bsd
argument_list|)
return|;
block|}
end_function

end_unit

