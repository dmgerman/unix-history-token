begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002 Doug Rabson  * Copyright (c) 1994-1995 SÃ¸ren Schmidt  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_kdtrace.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/blist.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/imgact_aout.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/racct.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/sdt.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/swap_pager.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_LINUX32
end_ifdef

begin_include
include|#
directive|include
file|<machine/../linux32/linux.h>
end_include

begin_include
include|#
directive|include
file|<machine/../linux32/linux32_proto.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<machine/../linux/linux.h>
end_include

begin_include
include|#
directive|include
file|<machine/../linux/linux_proto.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<compat/linux/linux_dtrace.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_file.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_mib.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_signal.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_timer.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_util.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_sysproto.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_emul.h>
end_include

begin_include
include|#
directive|include
file|<compat/linux/linux_misc.h>
end_include

begin_comment
comment|/**  * Special DTrace provider for the linuxulator.  *  * In this file we define the provider for the entire linuxulator. All  * modules (= files of the linuxulator) use it.  *  * We define a different name depending on the emulated bitsize, see  * ../../<ARCH>/linux{,32}/linux.h, e.g.:  *      native bitsize          = linuxulator  *      amd64, 32bit emulation  = linuxulator32  */
end_comment

begin_expr_stmt
name|LIN_SDT_PROVIDER_DEFINE
argument_list|(
name|LINUX_DTRACE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|stclohz
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Statistics clock frequency */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|linux_to_bsd_resource
index|[
name|LINUX_RLIM_NLIMITS
index|]
init|=
block|{
name|RLIMIT_CPU
block|,
name|RLIMIT_FSIZE
block|,
name|RLIMIT_DATA
block|,
name|RLIMIT_STACK
block|,
name|RLIMIT_CORE
block|,
name|RLIMIT_RSS
block|,
name|RLIMIT_NPROC
block|,
name|RLIMIT_NOFILE
block|,
name|RLIMIT_MEMLOCK
block|,
name|RLIMIT_AS
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|l_sysinfo
block|{
name|l_long
name|uptime
decl_stmt|;
comment|/* Seconds since boot */
name|l_ulong
name|loads
index|[
literal|3
index|]
decl_stmt|;
comment|/* 1, 5, and 15 minute load averages */
define|#
directive|define
name|LINUX_SYSINFO_LOADS_SCALE
value|65536
name|l_ulong
name|totalram
decl_stmt|;
comment|/* Total usable main memory size */
name|l_ulong
name|freeram
decl_stmt|;
comment|/* Available memory size */
name|l_ulong
name|sharedram
decl_stmt|;
comment|/* Amount of shared memory */
name|l_ulong
name|bufferram
decl_stmt|;
comment|/* Memory used by buffers */
name|l_ulong
name|totalswap
decl_stmt|;
comment|/* Total swap space size */
name|l_ulong
name|freeswap
decl_stmt|;
comment|/* swap space still available */
name|l_ushort
name|procs
decl_stmt|;
comment|/* Number of current processes */
name|l_ushort
name|pads
decl_stmt|;
name|l_ulong
name|totalbig
decl_stmt|;
name|l_ulong
name|freebig
decl_stmt|;
name|l_uint
name|mem_unit
decl_stmt|;
name|char
name|_f
index|[
literal|20
operator|-
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|l_long
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|l_int
argument_list|)
index|]
decl_stmt|;
comment|/* padding */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|l_pselect6arg
block|{
name|l_uintptr_t
name|ss
decl_stmt|;
name|l_size_t
name|ss_len
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|linux_sysinfo
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_sysinfo_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|l_sysinfo
name|sysinfo
decl_stmt|;
name|vm_object_t
name|object
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|getnanouptime
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|.
name|tv_nsec
operator|!=
literal|0
condition|)
name|ts
operator|.
name|tv_sec
operator|++
expr_stmt|;
name|sysinfo
operator|.
name|uptime
operator|=
name|ts
operator|.
name|tv_sec
expr_stmt|;
comment|/* Use the information from the mib to get our load averages */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|sysinfo
operator|.
name|loads
index|[
name|i
index|]
operator|=
name|averunnable
operator|.
name|ldavg
index|[
name|i
index|]
operator|*
name|LINUX_SYSINFO_LOADS_SCALE
operator|/
name|averunnable
operator|.
name|fscale
expr_stmt|;
name|sysinfo
operator|.
name|totalram
operator|=
name|physmem
operator|*
name|PAGE_SIZE
expr_stmt|;
name|sysinfo
operator|.
name|freeram
operator|=
name|sysinfo
operator|.
name|totalram
operator|-
name|cnt
operator|.
name|v_wire_count
operator|*
name|PAGE_SIZE
expr_stmt|;
name|sysinfo
operator|.
name|sharedram
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|vm_object_list_mtx
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|object
argument_list|,
argument|&vm_object_list
argument_list|,
argument|object_list
argument_list|)
if|if
condition|(
name|object
operator|->
name|shadow_count
operator|>
literal|1
condition|)
name|sysinfo
operator|.
name|sharedram
operator|+=
name|object
operator|->
name|resident_page_count
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|vm_object_list_mtx
argument_list|)
expr_stmt|;
name|sysinfo
operator|.
name|sharedram
operator|*=
name|PAGE_SIZE
expr_stmt|;
name|sysinfo
operator|.
name|bufferram
operator|=
literal|0
expr_stmt|;
name|swap_pager_status
argument_list|(
operator|&
name|i
argument_list|,
operator|&
name|j
argument_list|)
expr_stmt|;
name|sysinfo
operator|.
name|totalswap
operator|=
name|i
operator|*
name|PAGE_SIZE
expr_stmt|;
name|sysinfo
operator|.
name|freeswap
operator|=
operator|(
name|i
operator|-
name|j
operator|)
operator|*
name|PAGE_SIZE
expr_stmt|;
name|sysinfo
operator|.
name|procs
operator|=
name|nprocs
expr_stmt|;
comment|/* The following are only present in newer Linux kernels. */
name|sysinfo
operator|.
name|totalbig
operator|=
literal|0
expr_stmt|;
name|sysinfo
operator|.
name|freebig
operator|=
literal|0
expr_stmt|;
name|sysinfo
operator|.
name|mem_unit
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|sysinfo
argument_list|,
name|args
operator|->
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|sysinfo
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_alarm
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_alarm_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|itimerval
name|it
decl_stmt|,
name|old_it
decl_stmt|;
name|u_int
name|secs
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|alarm
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|alarm
argument_list|,
literal|"%u"
argument_list|)
argument_list|,
name|args
operator|->
name|secs
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|secs
operator|=
name|args
operator|->
name|secs
expr_stmt|;
if|if
condition|(
name|secs
operator|>
name|INT_MAX
condition|)
name|secs
operator|=
name|INT_MAX
expr_stmt|;
name|it
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
operator|(
name|long
operator|)
name|secs
expr_stmt|;
name|it
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|it
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|it
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|kern_setitimer
argument_list|(
name|td
argument_list|,
name|ITIMER_REAL
argument_list|,
operator|&
name|it
argument_list|,
operator|&
name|old_it
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|timevalisset
argument_list|(
operator|&
name|old_it
operator|.
name|it_value
argument_list|)
condition|)
block|{
if|if
condition|(
name|old_it
operator|.
name|it_value
operator|.
name|tv_usec
operator|!=
literal|0
condition|)
name|old_it
operator|.
name|it_value
operator|.
name|tv_sec
operator|++
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|old_it
operator|.
name|it_value
operator|.
name|tv_sec
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_brk
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_brk_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|vmspace
modifier|*
name|vm
init|=
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
decl_stmt|;
name|vm_offset_t
name|new
decl_stmt|,
name|old
decl_stmt|;
name|struct
name|obreak_args
comment|/* { 		char * nsize; 	} */
name|tmp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|brk
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|brk
argument_list|,
literal|"%p"
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|args
operator|->
name|dsend
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|old
operator|=
operator|(
name|vm_offset_t
operator|)
name|vm
operator|->
name|vm_daddr
operator|+
name|ctob
argument_list|(
name|vm
operator|->
name|vm_dsize
argument_list|)
expr_stmt|;
name|new
operator|=
operator|(
name|vm_offset_t
operator|)
name|args
operator|->
name|dsend
expr_stmt|;
name|tmp
operator|.
name|nsize
operator|=
operator|(
name|char
operator|*
operator|)
name|new
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|caddr_t
operator|)
name|new
operator|>
name|vm
operator|->
name|vm_daddr
operator|)
operator|&&
operator|!
name|sys_obreak
argument_list|(
name|td
argument_list|,
operator|&
name|tmp
argument_list|)
condition|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
operator|(
name|long
operator|)
name|new
expr_stmt|;
else|else
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
operator|(
name|long
operator|)
name|old
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_comment
comment|/* XXX: what about amd64/linux32? */
end_comment

begin_function
name|int
name|linux_uselib
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_uselib_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|nameidata
name|ni
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|exec
modifier|*
name|a_out
decl_stmt|;
name|struct
name|vattr
name|attr
decl_stmt|;
name|vm_offset_t
name|vmaddr
decl_stmt|;
name|unsigned
name|long
name|file_offset
decl_stmt|;
name|unsigned
name|long
name|bss_size
decl_stmt|;
name|char
modifier|*
name|library
decl_stmt|;
name|ssize_t
name|aresid
decl_stmt|;
name|int
name|error
decl_stmt|,
name|locked
decl_stmt|,
name|writecount
decl_stmt|;
name|LCONVPATHEXIST
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|library
argument_list|,
operator|&
name|library
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|uselib
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|uselib
argument_list|,
literal|"%s"
argument_list|)
argument_list|,
name|library
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|a_out
operator|=
name|NULL
expr_stmt|;
name|locked
operator|=
literal|0
expr_stmt|;
name|vp
operator|=
name|NULL
expr_stmt|;
name|NDINIT
argument_list|(
operator|&
name|ni
argument_list|,
name|LOOKUP
argument_list|,
name|ISOPEN
operator||
name|FOLLOW
operator||
name|LOCKLEAF
operator||
name|AUDITVNODE1
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|library
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|error
operator|=
name|namei
argument_list|(
operator|&
name|ni
argument_list|)
expr_stmt|;
name|LFREEPATH
argument_list|(
name|library
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
name|vp
operator|=
name|ni
operator|.
name|ni_vp
expr_stmt|;
name|NDFREE
argument_list|(
operator|&
name|ni
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
comment|/* 	 * From here on down, we have a locked vnode that must be unlocked. 	 * XXX: The code below largely duplicates exec_check_permissions(). 	 */
name|locked
operator|=
literal|1
expr_stmt|;
comment|/* Writable? */
name|error
operator|=
name|VOP_GET_WRITECOUNT
argument_list|(
name|vp
argument_list|,
operator|&
name|writecount
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|writecount
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ETXTBSY
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Executable? */
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|attr
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_mount
operator|->
name|mnt_flag
operator|&
name|MNT_NOEXEC
operator|)
operator|||
operator|(
operator|(
name|attr
operator|.
name|va_mode
operator|&
literal|0111
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|attr
operator|.
name|va_type
operator|!=
name|VREG
operator|)
condition|)
block|{
comment|/* EACCESS is what exec(2) returns. */
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Sensible size? */
if|if
condition|(
name|attr
operator|.
name|va_size
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Can we access it? */
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VEXEC
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
comment|/* 	 * XXX: This should use vn_open() so that it is properly authorized, 	 * and to reduce code redundancy all over the place here. 	 * XXX: Not really, it duplicates far more of exec_check_permissions() 	 * than vn_open(). 	 */
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_vnode_check_open
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|vp
argument_list|,
name|VREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
endif|#
directive|endif
name|error
operator|=
name|VOP_OPEN
argument_list|(
name|vp
argument_list|,
name|FREAD
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Pull in executable header into exec_map */
name|error
operator|=
name|vm_mmap
argument_list|(
name|exec_map
argument_list|,
operator|(
name|vm_offset_t
operator|*
operator|)
operator|&
name|a_out
argument_list|,
name|PAGE_SIZE
argument_list|,
name|VM_PROT_READ
argument_list|,
name|VM_PROT_READ
argument_list|,
literal|0
argument_list|,
name|OBJT_VNODE
argument_list|,
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Is it a Linux binary ? */
if|if
condition|(
operator|(
operator|(
name|a_out
operator|->
name|a_magic
operator|>>
literal|16
operator|)
operator|&
literal|0xff
operator|)
operator|!=
literal|0x64
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * While we are here, we should REALLY do some more checks 	 */
comment|/* Set file/virtual offset based on a.out variant. */
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
name|a_out
operator|->
name|a_magic
operator|&
literal|0xffff
argument_list|)
condition|)
block|{
case|case
literal|0413
case|:
comment|/* ZMAGIC */
name|file_offset
operator|=
literal|1024
expr_stmt|;
break|break;
case|case
literal|0314
case|:
comment|/* QMAGIC */
name|file_offset
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|bss_size
operator|=
name|round_page
argument_list|(
name|a_out
operator|->
name|a_bss
argument_list|)
expr_stmt|;
comment|/* Check various fields in header for validity/bounds. */
if|if
condition|(
name|a_out
operator|->
name|a_text
operator|&
name|PAGE_MASK
operator|||
name|a_out
operator|->
name|a_data
operator|&
name|PAGE_MASK
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* text + data can't exceed file size */
if|if
condition|(
name|a_out
operator|->
name|a_data
operator|+
name|a_out
operator|->
name|a_text
operator|>
name|attr
operator|.
name|va_size
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* 	 * text/data/bss must not exceed limits 	 * XXX - this is not complete. it should check current usage PLUS 	 * the resources needed by this library. 	 */
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_out
operator|->
name|a_text
operator|>
name|maxtsiz
operator|||
name|a_out
operator|->
name|a_data
operator|+
name|bss_size
operator|>
name|lim_cur
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|RLIMIT_DATA
argument_list|)
operator|||
name|racct_set
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|RACCT_DATA
argument_list|,
name|a_out
operator|->
name|a_data
operator|+
name|bss_size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
comment|/* 	 * Prevent more writers. 	 * XXX: Note that if any of the VM operations fail below we don't 	 * clear this flag. 	 */
name|VOP_SET_TEXT
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* 	 * Lock no longer needed 	 */
name|locked
operator|=
literal|0
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Check if file_offset page aligned. Currently we cannot handle 	 * misalinged file offsets, and so we read in the entire image 	 * (what a waste). 	 */
if|if
condition|(
name|file_offset
operator|&
name|PAGE_MASK
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"uselib: Non page aligned binary %lu\n"
argument_list|,
name|file_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Map text+data read/write/execute */
comment|/* a_entry is the load address and is page aligned */
name|vmaddr
operator|=
name|trunc_page
argument_list|(
name|a_out
operator|->
name|a_entry
argument_list|)
expr_stmt|;
comment|/* get anon user mapping, read+write+execute */
name|error
operator|=
name|vm_map_find
argument_list|(
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|vmaddr
argument_list|,
name|a_out
operator|->
name|a_text
operator|+
name|a_out
operator|->
name|a_data
argument_list|,
literal|0
argument_list|,
name|VMFS_NO_SPACE
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
name|error
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|vp
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vmaddr
argument_list|,
name|file_offset
argument_list|,
name|a_out
operator|->
name|a_text
operator|+
name|a_out
operator|->
name|a_data
argument_list|,
name|UIO_USERSPACE
argument_list|,
literal|0
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|NOCRED
argument_list|,
operator|&
name|aresid
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|aresid
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"uselib: Page aligned binary %lu\n"
argument_list|,
name|file_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * for QMAGIC, a_entry is 20 bytes beyond the load address 		 * to skip the executable header 		 */
name|vmaddr
operator|=
name|trunc_page
argument_list|(
name|a_out
operator|->
name|a_entry
argument_list|)
expr_stmt|;
comment|/* 		 * Map it all into the process's space as a single 		 * copy-on-write "data" segment. 		 */
name|error
operator|=
name|vm_mmap
argument_list|(
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
operator|&
name|vmaddr
argument_list|,
name|a_out
operator|->
name|a_text
operator|+
name|a_out
operator|->
name|a_data
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_FIXED
argument_list|,
name|OBJT_VNODE
argument_list|,
name|vp
argument_list|,
name|file_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"mem=%08lx = %08lx %08lx\n"
argument_list|,
operator|(
name|long
operator|)
name|vmaddr
argument_list|,
operator|(
operator|(
name|long
operator|*
operator|)
name|vmaddr
operator|)
index|[
literal|0
index|]
argument_list|,
operator|(
operator|(
name|long
operator|*
operator|)
name|vmaddr
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bss_size
operator|!=
literal|0
condition|)
block|{
comment|/* Calculate BSS start address */
name|vmaddr
operator|=
name|trunc_page
argument_list|(
name|a_out
operator|->
name|a_entry
argument_list|)
operator|+
name|a_out
operator|->
name|a_text
operator|+
name|a_out
operator|->
name|a_data
expr_stmt|;
comment|/* allocate some 'anon' space */
name|error
operator|=
name|vm_map_find
argument_list|(
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|vmaddr
argument_list|,
name|bss_size
argument_list|,
literal|0
argument_list|,
name|VMFS_NO_SPACE
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|cleanup
goto|;
block|}
name|cleanup
label|:
comment|/* Unlock vnode if needed */
if|if
condition|(
name|locked
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Release the temporary mapping. */
if|if
condition|(
name|a_out
condition|)
name|kmap_free_wakeup
argument_list|(
name|exec_map
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|a_out
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __i386__ */
end_comment

begin_function
name|int
name|linux_select
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_select_args
modifier|*
name|args
parameter_list|)
block|{
name|l_timeval
name|ltv
decl_stmt|;
name|struct
name|timeval
name|tv0
decl_stmt|,
name|tv1
decl_stmt|,
name|utv
decl_stmt|,
modifier|*
name|tvp
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|select
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|select
argument_list|,
literal|"%d, %p, %p, %p, %p"
argument_list|)
argument_list|,
name|args
operator|->
name|nfds
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|readfds
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|writefds
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|exceptfds
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|timeout
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Store current time for computation of the amount of 	 * time left. 	 */
if|if
condition|(
name|args
operator|->
name|timeout
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|timeout
argument_list|,
operator|&
name|ltv
argument_list|,
sizeof|sizeof
argument_list|(
name|ltv
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|select_out
goto|;
name|utv
operator|.
name|tv_sec
operator|=
name|ltv
operator|.
name|tv_sec
expr_stmt|;
name|utv
operator|.
name|tv_usec
operator|=
name|ltv
operator|.
name|tv_usec
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|select
argument_list|)
condition|)
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"incoming timeout (%jd/%ld)"
argument_list|)
argument_list|,
operator|(
name|intmax_t
operator|)
name|utv
operator|.
name|tv_sec
argument_list|,
name|utv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|itimerfix
argument_list|(
operator|&
name|utv
argument_list|)
condition|)
block|{
comment|/* 			 * The timeval was invalid.  Convert it to something 			 * valid that will act as it does under Linux. 			 */
name|utv
operator|.
name|tv_sec
operator|+=
name|utv
operator|.
name|tv_usec
operator|/
literal|1000000
expr_stmt|;
name|utv
operator|.
name|tv_usec
operator|%=
literal|1000000
expr_stmt|;
if|if
condition|(
name|utv
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|utv
operator|.
name|tv_sec
operator|-=
literal|1
expr_stmt|;
name|utv
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
if|if
condition|(
name|utv
operator|.
name|tv_sec
operator|<
literal|0
condition|)
name|timevalclear
argument_list|(
operator|&
name|utv
argument_list|)
expr_stmt|;
block|}
name|microtime
argument_list|(
operator|&
name|tv0
argument_list|)
expr_stmt|;
name|tvp
operator|=
operator|&
name|utv
expr_stmt|;
block|}
else|else
name|tvp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|kern_select
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|nfds
argument_list|,
name|args
operator|->
name|readfds
argument_list|,
name|args
operator|->
name|writefds
argument_list|,
name|args
operator|->
name|exceptfds
argument_list|,
name|tvp
argument_list|,
name|LINUX_NFDBITS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|select
argument_list|)
condition|)
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"real select returns %d"
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
goto|goto
name|select_out
goto|;
if|if
condition|(
name|args
operator|->
name|timeout
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
condition|)
block|{
comment|/* 			 * Compute how much time was left of the timeout, 			 * by subtracting the current time and the time 			 * before we started the call, and subtracting 			 * that result from the user-supplied value. 			 */
name|microtime
argument_list|(
operator|&
name|tv1
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|tv1
argument_list|,
operator|&
name|tv0
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|utv
argument_list|,
operator|&
name|tv1
argument_list|)
expr_stmt|;
if|if
condition|(
name|utv
operator|.
name|tv_sec
operator|<
literal|0
condition|)
name|timevalclear
argument_list|(
operator|&
name|utv
argument_list|)
expr_stmt|;
block|}
else|else
name|timevalclear
argument_list|(
operator|&
name|utv
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|select
argument_list|)
condition|)
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"outgoing timeout (%jd/%ld)"
argument_list|)
argument_list|,
operator|(
name|intmax_t
operator|)
name|utv
operator|.
name|tv_sec
argument_list|,
name|utv
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ltv
operator|.
name|tv_sec
operator|=
name|utv
operator|.
name|tv_sec
expr_stmt|;
name|ltv
operator|.
name|tv_usec
operator|=
name|utv
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|ltv
argument_list|,
name|args
operator|->
name|timeout
argument_list|,
sizeof|sizeof
argument_list|(
name|ltv
argument_list|)
argument_list|)
operator|)
condition|)
goto|goto
name|select_out
goto|;
block|}
name|select_out
label|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|select
argument_list|)
condition|)
name|printf
argument_list|(
name|LMSG
argument_list|(
literal|"select_out -> %d"
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_mremap
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_mremap_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|munmap_args
comment|/* { 		void *addr; 		size_t len; 	} */
name|bsd_args
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|mremap
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|mremap
argument_list|,
literal|"%p, %08lx, %08lx, %08lx"
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|args
operator|->
name|addr
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|args
operator|->
name|old_len
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|args
operator|->
name|new_len
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|args
operator|->
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|flags
operator|&
operator|~
operator|(
name|LINUX_MREMAP_FIXED
operator||
name|LINUX_MREMAP_MAYMOVE
operator|)
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Check for the page alignment. 	 * Linux defines PAGE_MASK to be FreeBSD ~PAGE_MASK. 	 */
if|if
condition|(
name|args
operator|->
name|addr
operator|&
name|PAGE_MASK
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|args
operator|->
name|new_len
operator|=
name|round_page
argument_list|(
name|args
operator|->
name|new_len
argument_list|)
expr_stmt|;
name|args
operator|->
name|old_len
operator|=
name|round_page
argument_list|(
name|args
operator|->
name|old_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|new_len
operator|>
name|args
operator|->
name|old_len
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|args
operator|->
name|new_len
operator|<
name|args
operator|->
name|old_len
condition|)
block|{
name|bsd_args
operator|.
name|addr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|uintptr_t
operator|)
name|args
operator|->
name|addr
operator|+
name|args
operator|->
name|new_len
argument_list|)
expr_stmt|;
name|bsd_args
operator|.
name|len
operator|=
name|args
operator|->
name|old_len
operator|-
name|args
operator|->
name|new_len
expr_stmt|;
name|error
operator|=
name|sys_munmap
argument_list|(
name|td
argument_list|,
operator|&
name|bsd_args
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|error
condition|?
literal|0
else|:
operator|(
name|uintptr_t
operator|)
name|args
operator|->
name|addr
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|LINUX_MS_ASYNC
value|0x0001
end_define

begin_define
define|#
directive|define
name|LINUX_MS_INVALIDATE
value|0x0002
end_define

begin_define
define|#
directive|define
name|LINUX_MS_SYNC
value|0x0004
end_define

begin_function
name|int
name|linux_msync
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_msync_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|msync_args
name|bsd_args
decl_stmt|;
name|bsd_args
operator|.
name|addr
operator|=
operator|(
name|caddr_t
operator|)
operator|(
name|uintptr_t
operator|)
name|args
operator|->
name|addr
expr_stmt|;
name|bsd_args
operator|.
name|len
operator|=
operator|(
name|uintptr_t
operator|)
name|args
operator|->
name|len
expr_stmt|;
name|bsd_args
operator|.
name|flags
operator|=
name|args
operator|->
name|fl
operator|&
operator|~
name|LINUX_MS_SYNC
expr_stmt|;
return|return
operator|(
name|sys_msync
argument_list|(
name|td
argument_list|,
operator|&
name|bsd_args
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_time
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_time_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|l_time_t
name|tm
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|time
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|time
argument_list|,
literal|"*"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|tm
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|tm
operator|&&
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|tm
argument_list|,
name|args
operator|->
name|tm
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|tm
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|l_times_argv
block|{
name|l_clock_t
name|tms_utime
decl_stmt|;
name|l_clock_t
name|tms_stime
decl_stmt|;
name|l_clock_t
name|tms_cutime
decl_stmt|;
name|l_clock_t
name|tms_cstime
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Glibc versions prior to 2.2.1 always use hard-coded CLK_TCK value.  * Since 2.2.1 Glibc uses value exported from kernel via AT_CLKTCK  * auxiliary vector entry.  */
end_comment

begin_define
define|#
directive|define
name|CLK_TCK
value|100
end_define

begin_define
define|#
directive|define
name|CONVOTCK
parameter_list|(
name|r
parameter_list|)
value|(r.tv_sec * CLK_TCK + r.tv_usec / (1000000 / CLK_TCK))
end_define

begin_define
define|#
directive|define
name|CONVNTCK
parameter_list|(
name|r
parameter_list|)
value|(r.tv_sec * stclohz + r.tv_usec / (1000000 / stclohz))
end_define

begin_define
define|#
directive|define
name|CONVTCK
parameter_list|(
name|r
parameter_list|)
value|(linux_kernver(td)>= LINUX_KERNVER_2004000 ?		\ 			    CONVNTCK(r) : CONVOTCK(r))
end_define

begin_function
name|int
name|linux_times
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_times_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|,
name|utime
decl_stmt|,
name|stime
decl_stmt|,
name|cutime
decl_stmt|,
name|cstime
decl_stmt|;
name|struct
name|l_times_argv
name|tms
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|times
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|times
argument_list|,
literal|"*"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|buf
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PROC_STATLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|calcru
argument_list|(
name|p
argument_list|,
operator|&
name|utime
argument_list|,
operator|&
name|stime
argument_list|)
expr_stmt|;
name|PROC_STATUNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|calccru
argument_list|(
name|p
argument_list|,
operator|&
name|cutime
argument_list|,
operator|&
name|cstime
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|tms
operator|.
name|tms_utime
operator|=
name|CONVTCK
argument_list|(
name|utime
argument_list|)
expr_stmt|;
name|tms
operator|.
name|tms_stime
operator|=
name|CONVTCK
argument_list|(
name|stime
argument_list|)
expr_stmt|;
name|tms
operator|.
name|tms_cutime
operator|=
name|CONVTCK
argument_list|(
name|cutime
argument_list|)
expr_stmt|;
name|tms
operator|.
name|tms_cstime
operator|=
name|CONVTCK
argument_list|(
name|cstime
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|tms
argument_list|,
name|args
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|tms
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|microuptime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|)
name|CONVTCK
argument_list|(
name|tv
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_newuname
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_newuname_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|l_new_utsname
name|utsname
decl_stmt|;
name|char
name|osname
index|[
name|LINUX_MAX_UTSNAME
index|]
decl_stmt|;
name|char
name|osrelease
index|[
name|LINUX_MAX_UTSNAME
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|newuname
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|newuname
argument_list|,
literal|"*"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|linux_get_osname
argument_list|(
name|td
argument_list|,
name|osname
argument_list|)
expr_stmt|;
name|linux_get_osrelease
argument_list|(
name|td
argument_list|,
name|osrelease
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|utsname
argument_list|,
sizeof|sizeof
argument_list|(
name|utsname
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|utsname
operator|.
name|sysname
argument_list|,
name|osname
argument_list|,
name|LINUX_MAX_UTSNAME
argument_list|)
expr_stmt|;
name|getcredhostname
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|utsname
operator|.
name|nodename
argument_list|,
name|LINUX_MAX_UTSNAME
argument_list|)
expr_stmt|;
name|getcreddomainname
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|utsname
operator|.
name|domainname
argument_list|,
name|LINUX_MAX_UTSNAME
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|utsname
operator|.
name|release
argument_list|,
name|osrelease
argument_list|,
name|LINUX_MAX_UTSNAME
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|utsname
operator|.
name|version
argument_list|,
name|version
argument_list|,
name|LINUX_MAX_UTSNAME
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|utsname
operator|.
name|version
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|strlcpy
argument_list|(
name|utsname
operator|.
name|machine
argument_list|,
name|linux_kplatform
argument_list|,
name|LINUX_MAX_UTSNAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|utsname
argument_list|,
name|args
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|utsname
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|l_utimbuf
block|{
name|l_time_t
name|l_actime
decl_stmt|;
name|l_time_t
name|l_modtime
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|linux_utime
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_utime_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|timeval
name|tv
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|tvp
decl_stmt|;
name|struct
name|l_utimbuf
name|lut
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|error
decl_stmt|;
name|LCONVPATHEXIST
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|fname
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|utime
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|utime
argument_list|,
literal|"%s, *"
argument_list|)
argument_list|,
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|times
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|times
argument_list|,
operator|&
name|lut
argument_list|,
sizeof|sizeof
name|lut
argument_list|)
operator|)
condition|)
block|{
name|LFREEPATH
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|tv
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|lut
operator|.
name|l_actime
expr_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|lut
operator|.
name|l_modtime
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|tvp
operator|=
name|tv
expr_stmt|;
block|}
else|else
name|tvp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|kern_utimes
argument_list|(
name|td
argument_list|,
name|fname
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|tvp
argument_list|,
name|UIO_SYSSPACE
argument_list|)
expr_stmt|;
name|LFREEPATH
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_utimes
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_utimes_args
modifier|*
name|args
parameter_list|)
block|{
name|l_timeval
name|ltv
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|timeval
name|tv
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|tvp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|error
decl_stmt|;
name|LCONVPATHEXIST
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|fname
argument_list|,
operator|&
name|fname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|utimes
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|utimes
argument_list|,
literal|"%s, *"
argument_list|)
argument_list|,
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|tptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|tptr
argument_list|,
name|ltv
argument_list|,
sizeof|sizeof
name|ltv
argument_list|)
operator|)
condition|)
block|{
name|LFREEPATH
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|tv
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|ltv
index|[
literal|0
index|]
operator|.
name|tv_sec
expr_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
name|ltv
index|[
literal|0
index|]
operator|.
name|tv_usec
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|ltv
index|[
literal|1
index|]
operator|.
name|tv_sec
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
name|ltv
index|[
literal|1
index|]
operator|.
name|tv_usec
expr_stmt|;
name|tvp
operator|=
name|tv
expr_stmt|;
block|}
name|error
operator|=
name|kern_utimes
argument_list|(
name|td
argument_list|,
name|fname
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|tvp
argument_list|,
name|UIO_SYSSPACE
argument_list|)
expr_stmt|;
name|LFREEPATH
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_utimensat
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_utimensat_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|l_timespec
name|l_times
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|timespec
name|times
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|timesp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|,
name|dfd
decl_stmt|,
name|flags
init|=
literal|0
decl_stmt|;
name|dfd
operator|=
operator|(
name|args
operator|->
name|dfd
operator|==
name|LINUX_AT_FDCWD
operator|)
condition|?
name|AT_FDCWD
else|:
name|args
operator|->
name|dfd
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|utimensat
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|utimensat
argument_list|,
literal|"%d, *"
argument_list|)
argument_list|,
name|dfd
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|flags
operator|&
operator|~
name|LINUX_AT_SYMLINK_NOFOLLOW
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|args
operator|->
name|times
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|times
argument_list|,
name|l_times
argument_list|,
sizeof|sizeof
argument_list|(
name|l_times
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|l_times
index|[
literal|0
index|]
operator|.
name|tv_nsec
operator|>
literal|999999999
operator|||
name|l_times
index|[
literal|1
index|]
operator|.
name|tv_nsec
operator|>
literal|999999999
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|times
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|l_times
index|[
literal|0
index|]
operator|.
name|tv_sec
expr_stmt|;
switch|switch
condition|(
name|l_times
index|[
literal|0
index|]
operator|.
name|tv_nsec
condition|)
block|{
case|case
name|LINUX_UTIME_OMIT
case|:
name|times
index|[
literal|0
index|]
operator|.
name|tv_nsec
operator|=
name|UTIME_OMIT
expr_stmt|;
break|break;
case|case
name|LINUX_UTIME_NOW
case|:
name|times
index|[
literal|0
index|]
operator|.
name|tv_nsec
operator|=
name|UTIME_NOW
expr_stmt|;
break|break;
default|default:
name|times
index|[
literal|0
index|]
operator|.
name|tv_nsec
operator|=
name|l_times
index|[
literal|0
index|]
operator|.
name|tv_nsec
expr_stmt|;
block|}
name|times
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|l_times
index|[
literal|1
index|]
operator|.
name|tv_sec
expr_stmt|;
switch|switch
condition|(
name|l_times
index|[
literal|1
index|]
operator|.
name|tv_nsec
condition|)
block|{
case|case
name|LINUX_UTIME_OMIT
case|:
name|times
index|[
literal|1
index|]
operator|.
name|tv_nsec
operator|=
name|UTIME_OMIT
expr_stmt|;
break|break;
case|case
name|LINUX_UTIME_NOW
case|:
name|times
index|[
literal|1
index|]
operator|.
name|tv_nsec
operator|=
name|UTIME_NOW
expr_stmt|;
break|break;
default|default:
name|times
index|[
literal|1
index|]
operator|.
name|tv_nsec
operator|=
name|l_times
index|[
literal|1
index|]
operator|.
name|tv_nsec
expr_stmt|;
break|break;
block|}
name|timesp
operator|=
name|times
expr_stmt|;
block|}
if|if
condition|(
name|times
index|[
literal|0
index|]
operator|.
name|tv_nsec
operator|==
name|UTIME_OMIT
operator|&&
name|times
index|[
literal|1
index|]
operator|.
name|tv_nsec
operator|==
name|UTIME_OMIT
condition|)
comment|/* This breaks POSIX, but is what the Linux kernel does 		 * _on purpose_ (documented in the man page for utimensat(2)), 		 * so we must follow that behaviour. */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|args
operator|->
name|pathname
operator|!=
name|NULL
condition|)
name|LCONVPATHEXIST_AT
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|pathname
argument_list|,
operator|&
name|path
argument_list|,
name|dfd
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|args
operator|->
name|flags
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|args
operator|->
name|flags
operator|&
name|LINUX_AT_SYMLINK_NOFOLLOW
condition|)
name|flags
operator||=
name|AT_SYMLINK_NOFOLLOW
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
name|error
operator|=
name|kern_futimens
argument_list|(
name|td
argument_list|,
name|dfd
argument_list|,
name|timesp
argument_list|,
name|UIO_SYSSPACE
argument_list|)
expr_stmt|;
else|else
block|{
name|error
operator|=
name|kern_utimensat
argument_list|(
name|td
argument_list|,
name|dfd
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|timesp
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|LFREEPATH
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_futimesat
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_futimesat_args
modifier|*
name|args
parameter_list|)
block|{
name|l_timeval
name|ltv
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|timeval
name|tv
index|[
literal|2
index|]
decl_stmt|,
modifier|*
name|tvp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|error
decl_stmt|,
name|dfd
decl_stmt|;
name|dfd
operator|=
operator|(
name|args
operator|->
name|dfd
operator|==
name|LINUX_AT_FDCWD
operator|)
condition|?
name|AT_FDCWD
else|:
name|args
operator|->
name|dfd
expr_stmt|;
name|LCONVPATHEXIST_AT
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|filename
argument_list|,
operator|&
name|fname
argument_list|,
name|dfd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|futimesat
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|futimesat
argument_list|,
literal|"%s, *"
argument_list|)
argument_list|,
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|utimes
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|utimes
argument_list|,
name|ltv
argument_list|,
sizeof|sizeof
name|ltv
argument_list|)
operator|)
condition|)
block|{
name|LFREEPATH
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|tv
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|ltv
index|[
literal|0
index|]
operator|.
name|tv_sec
expr_stmt|;
name|tv
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
name|ltv
index|[
literal|0
index|]
operator|.
name|tv_usec
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|ltv
index|[
literal|1
index|]
operator|.
name|tv_sec
expr_stmt|;
name|tv
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
name|ltv
index|[
literal|1
index|]
operator|.
name|tv_usec
expr_stmt|;
name|tvp
operator|=
name|tv
expr_stmt|;
block|}
name|error
operator|=
name|kern_utimesat
argument_list|(
name|td
argument_list|,
name|dfd
argument_list|,
name|fname
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|tvp
argument_list|,
name|UIO_SYSSPACE
argument_list|)
expr_stmt|;
name|LFREEPATH
argument_list|(
name|fname
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_common_wait
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|pid
parameter_list|,
name|int
modifier|*
name|status
parameter_list|,
name|int
name|options
parameter_list|,
name|struct
name|rusage
modifier|*
name|ru
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|tmpstat
decl_stmt|;
name|error
operator|=
name|kern_wait
argument_list|(
name|td
argument_list|,
name|pid
argument_list|,
operator|&
name|tmpstat
argument_list|,
name|options
argument_list|,
name|ru
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|status
condition|)
block|{
name|tmpstat
operator|&=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|tmpstat
argument_list|)
condition|)
name|tmpstat
operator|=
operator|(
name|tmpstat
operator|&
literal|0xffffff80
operator|)
operator||
name|bsd_to_linux_signal
argument_list|(
name|WTERMSIG
argument_list|(
name|tmpstat
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|tmpstat
argument_list|)
condition|)
name|tmpstat
operator|=
operator|(
name|tmpstat
operator|&
literal|0xffff00ff
operator|)
operator||
operator|(
name|bsd_to_linux_signal
argument_list|(
name|WSTOPSIG
argument_list|(
name|tmpstat
argument_list|)
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|WIFCONTINUED
argument_list|(
name|tmpstat
argument_list|)
condition|)
name|tmpstat
operator|=
literal|0xffff
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|tmpstat
argument_list|,
name|status
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|&&
name|defined
argument_list|(
name|COMPAT_LINUX32
argument_list|)
operator|)
end_if

begin_function
name|int
name|linux_waitpid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_waitpid_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|linux_wait4_args
name|wait4_args
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|waitpid
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|waitpid
argument_list|,
literal|"%d, %p, %d"
argument_list|)
argument_list|,
name|args
operator|->
name|pid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|status
argument_list|,
name|args
operator|->
name|options
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|wait4_args
operator|.
name|pid
operator|=
name|args
operator|->
name|pid
expr_stmt|;
name|wait4_args
operator|.
name|status
operator|=
name|args
operator|->
name|status
expr_stmt|;
name|wait4_args
operator|.
name|options
operator|=
name|args
operator|->
name|options
expr_stmt|;
name|wait4_args
operator|.
name|rusage
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|linux_wait4
argument_list|(
name|td
argument_list|,
operator|&
name|wait4_args
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __i386__ || (__amd64__&& COMPAT_LINUX32) */
end_comment

begin_function
name|int
name|linux_wait4
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_wait4_args
modifier|*
name|args
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|options
decl_stmt|;
name|struct
name|rusage
name|ru
decl_stmt|,
modifier|*
name|rup
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|wait4
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|wait4
argument_list|,
literal|"%d, %p, %d, %p"
argument_list|)
argument_list|,
name|args
operator|->
name|pid
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|status
argument_list|,
name|args
operator|->
name|options
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|rusage
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|options
operator|&
operator|~
operator|(
name|LINUX_WUNTRACED
operator||
name|LINUX_WNOHANG
operator||
name|LINUX_WCONTINUED
operator||
name|__WCLONE
operator||
name|__WNOTHREAD
operator||
name|__WALL
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|options
operator|=
name|WEXITED
expr_stmt|;
name|linux_to_bsd_waitopts
argument_list|(
name|args
operator|->
name|options
argument_list|,
operator|&
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|rusage
operator|!=
name|NULL
condition|)
name|rup
operator|=
operator|&
name|ru
expr_stmt|;
else|else
name|rup
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|linux_common_wait
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|pid
argument_list|,
name|args
operator|->
name|status
argument_list|,
name|options
argument_list|,
name|rup
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|args
operator|->
name|rusage
operator|!=
name|NULL
condition|)
name|error
operator|=
name|linux_copyout_rusage
argument_list|(
operator|&
name|ru
argument_list|,
name|args
operator|->
name|rusage
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_waitid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_waitid_args
modifier|*
name|args
parameter_list|)
block|{
name|int
name|status
decl_stmt|,
name|options
decl_stmt|,
name|sig
decl_stmt|;
name|struct
name|__wrusage
name|wru
decl_stmt|;
name|siginfo_t
name|siginfo
decl_stmt|;
name|l_siginfo_t
name|lsi
decl_stmt|;
name|idtype_t
name|idtype
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
name|options
operator|=
literal|0
expr_stmt|;
name|linux_to_bsd_waitopts
argument_list|(
name|args
operator|->
name|options
argument_list|,
operator|&
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|&
operator|~
operator|(
name|WNOHANG
operator||
name|WNOWAIT
operator||
name|WEXITED
operator||
name|WUNTRACED
operator||
name|WCONTINUED
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|options
operator|&
operator|(
name|WEXITED
operator||
name|WUNTRACED
operator||
name|WCONTINUED
operator|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|args
operator|->
name|idtype
condition|)
block|{
case|case
name|LINUX_P_ALL
case|:
name|idtype
operator|=
name|P_ALL
expr_stmt|;
break|break;
case|case
name|LINUX_P_PID
case|:
if|if
condition|(
name|args
operator|->
name|id
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|idtype
operator|=
name|P_PID
expr_stmt|;
break|break;
case|case
name|LINUX_P_PGID
case|:
if|if
condition|(
name|args
operator|->
name|id
operator|<=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|idtype
operator|=
name|P_PGID
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|kern_wait6
argument_list|(
name|td
argument_list|,
name|idtype
argument_list|,
name|args
operator|->
name|id
argument_list|,
operator|&
name|status
argument_list|,
name|options
argument_list|,
operator|&
name|wru
argument_list|,
operator|&
name|siginfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|args
operator|->
name|rusage
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|linux_copyout_rusage
argument_list|(
operator|&
name|wru
operator|.
name|wru_children
argument_list|,
name|args
operator|->
name|rusage
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|args
operator|->
name|info
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|bzero
argument_list|(
operator|&
name|lsi
argument_list|,
sizeof|sizeof
argument_list|(
name|lsi
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|sig
operator|=
name|bsd_to_linux_signal
argument_list|(
name|siginfo
operator|.
name|si_signo
argument_list|)
expr_stmt|;
name|siginfo_to_lsiginfo
argument_list|(
operator|&
name|siginfo
argument_list|,
operator|&
name|lsi
argument_list|,
name|sig
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|lsi
argument_list|,
name|args
operator|->
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|lsi
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_mknod
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_mknod_args
modifier|*
name|args
parameter_list|)
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|error
decl_stmt|;
name|LCONVPATHCREAT
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|path
argument_list|,
operator|&
name|path
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|mknod
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|mknod
argument_list|,
literal|"%s, %d, %ju"
argument_list|)
argument_list|,
name|path
argument_list|,
name|args
operator|->
name|mode
argument_list|,
operator|(
name|uintmax_t
operator|)
name|args
operator|->
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|args
operator|->
name|mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFIFO
case|:
case|case
name|S_IFSOCK
case|:
name|error
operator|=
name|kern_mkfifo
argument_list|(
name|td
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|args
operator|->
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFCHR
case|:
case|case
name|S_IFBLK
case|:
name|error
operator|=
name|kern_mknod
argument_list|(
name|td
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|args
operator|->
name|mode
argument_list|,
name|args
operator|->
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFDIR
case|:
name|error
operator|=
name|EPERM
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|args
operator|->
name|mode
operator||=
name|S_IFREG
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|S_IFREG
case|:
name|error
operator|=
name|kern_open
argument_list|(
name|td
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
name|args
operator|->
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|kern_close
argument_list|(
name|td
argument_list|,
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|LFREEPATH
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_mknodat
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_mknodat_args
modifier|*
name|args
parameter_list|)
block|{
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|error
decl_stmt|,
name|dfd
decl_stmt|;
name|dfd
operator|=
operator|(
name|args
operator|->
name|dfd
operator|==
name|LINUX_AT_FDCWD
operator|)
condition|?
name|AT_FDCWD
else|:
name|args
operator|->
name|dfd
expr_stmt|;
name|LCONVPATHCREAT_AT
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|filename
argument_list|,
operator|&
name|path
argument_list|,
name|dfd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|mknodat
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|mknodat
argument_list|,
literal|"%s, %d, %d"
argument_list|)
argument_list|,
name|path
argument_list|,
name|args
operator|->
name|mode
argument_list|,
name|args
operator|->
name|dev
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|args
operator|->
name|mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFIFO
case|:
case|case
name|S_IFSOCK
case|:
name|error
operator|=
name|kern_mkfifoat
argument_list|(
name|td
argument_list|,
name|dfd
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|args
operator|->
name|mode
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFCHR
case|:
case|case
name|S_IFBLK
case|:
name|error
operator|=
name|kern_mknodat
argument_list|(
name|td
argument_list|,
name|dfd
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|args
operator|->
name|mode
argument_list|,
name|args
operator|->
name|dev
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFDIR
case|:
name|error
operator|=
name|EPERM
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|args
operator|->
name|mode
operator||=
name|S_IFREG
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|S_IFREG
case|:
name|error
operator|=
name|kern_openat
argument_list|(
name|td
argument_list|,
name|dfd
argument_list|,
name|path
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
name|args
operator|->
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|kern_close
argument_list|(
name|td
argument_list|,
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|LFREEPATH
argument_list|(
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * UGH! This is just about the dumbest idea I've ever heard!!  */
end_comment

begin_function
name|int
name|linux_personality
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_personality_args
modifier|*
name|args
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|personality
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|personality
argument_list|,
literal|"%lu"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|args
operator|->
name|per
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|per
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Yes Jim, it's still a Linux... */
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|l_itimerval
block|{
name|l_timeval
name|it_interval
decl_stmt|;
name|l_timeval
name|it_value
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|B2L_ITIMERVAL
parameter_list|(
name|bip
parameter_list|,
name|lip
parameter_list|)
define|\
value|(bip)->it_interval.tv_sec = (lip)->it_interval.tv_sec;		\ 	(bip)->it_interval.tv_usec = (lip)->it_interval.tv_usec;	\ 	(bip)->it_value.tv_sec = (lip)->it_value.tv_sec;		\ 	(bip)->it_value.tv_usec = (lip)->it_value.tv_usec;
end_define

begin_function
name|int
name|linux_setitimer
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_setitimer_args
modifier|*
name|uap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|l_itimerval
name|ls
decl_stmt|;
name|struct
name|itimerval
name|aitv
decl_stmt|,
name|oitv
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|setitimer
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|setitimer
argument_list|,
literal|"%p, %p"
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|uap
operator|->
name|itv
argument_list|,
operator|(
name|void
operator|*
operator|)
name|uap
operator|->
name|oitv
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|uap
operator|->
name|itv
operator|==
name|NULL
condition|)
block|{
name|uap
operator|->
name|itv
operator|=
name|uap
operator|->
name|oitv
expr_stmt|;
return|return
operator|(
name|linux_getitimer
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|linux_getitimer_args
operator|*
operator|)
name|uap
argument_list|)
operator|)
return|;
block|}
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|itv
argument_list|,
operator|&
name|ls
argument_list|,
sizeof|sizeof
argument_list|(
name|ls
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|B2L_ITIMERVAL
argument_list|(
operator|&
name|aitv
argument_list|,
operator|&
name|ls
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|setitimer
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"setitimer: value: sec: %jd, usec: %ld\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|aitv
operator|.
name|it_value
operator|.
name|tv_sec
argument_list|,
name|aitv
operator|.
name|it_value
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"setitimer: interval: sec: %jd, usec: %ld\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|aitv
operator|.
name|it_interval
operator|.
name|tv_sec
argument_list|,
name|aitv
operator|.
name|it_interval
operator|.
name|tv_usec
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|error
operator|=
name|kern_setitimer
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|which
argument_list|,
operator|&
name|aitv
argument_list|,
operator|&
name|oitv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|uap
operator|->
name|oitv
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|B2L_ITIMERVAL
argument_list|(
operator|&
name|ls
argument_list|,
operator|&
name|oitv
argument_list|)
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|ls
argument_list|,
name|uap
operator|->
name|oitv
argument_list|,
sizeof|sizeof
argument_list|(
name|ls
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_getitimer
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getitimer_args
modifier|*
name|uap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|l_itimerval
name|ls
decl_stmt|;
name|struct
name|itimerval
name|aitv
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|getitimer
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|getitimer
argument_list|,
literal|"%p"
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|uap
operator|->
name|itv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|kern_getitimer
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|which
argument_list|,
operator|&
name|aitv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|B2L_ITIMERVAL
argument_list|(
operator|&
name|ls
argument_list|,
operator|&
name|aitv
argument_list|)
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|ls
argument_list|,
name|uap
operator|->
name|itv
argument_list|,
sizeof|sizeof
argument_list|(
name|ls
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|&&
name|defined
argument_list|(
name|COMPAT_LINUX32
argument_list|)
operator|)
end_if

begin_function
name|int
name|linux_nice
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_nice_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|setpriority_args
name|bsd_args
decl_stmt|;
name|bsd_args
operator|.
name|which
operator|=
name|PRIO_PROCESS
expr_stmt|;
name|bsd_args
operator|.
name|who
operator|=
literal|0
expr_stmt|;
comment|/* current process */
name|bsd_args
operator|.
name|prio
operator|=
name|args
operator|->
name|inc
expr_stmt|;
return|return
operator|(
name|sys_setpriority
argument_list|(
name|td
argument_list|,
operator|&
name|bsd_args
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __i386__ || (__amd64__&& COMPAT_LINUX32) */
end_comment

begin_function
name|int
name|linux_setgroups
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_setgroups_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|ucred
modifier|*
name|newcred
decl_stmt|,
modifier|*
name|oldcred
decl_stmt|;
name|l_gid_t
modifier|*
name|linux_gidset
decl_stmt|;
name|gid_t
modifier|*
name|bsd_gidset
decl_stmt|;
name|int
name|ngrp
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|ngrp
operator|=
name|args
operator|->
name|gidsetsize
expr_stmt|;
if|if
condition|(
name|ngrp
operator|<
literal|0
operator|||
name|ngrp
operator|>=
name|ngroups_max
operator|+
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|linux_gidset
operator|=
name|malloc
argument_list|(
name|ngrp
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|linux_gidset
argument_list|)
argument_list|,
name|M_LINUX
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|grouplist
argument_list|,
name|linux_gidset
argument_list|,
name|ngrp
operator|*
sizeof|sizeof
argument_list|(
name|l_gid_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|newcred
operator|=
name|crget
argument_list|()
expr_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|oldcred
operator|=
name|crcopysafe
argument_list|(
name|p
argument_list|,
name|newcred
argument_list|)
expr_stmt|;
comment|/* 	 * cr_groups[0] holds egid. Setting the whole set from 	 * the supplied set will cause egid to be changed too. 	 * Keep cr_groups[0] unchanged to prevent that. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|priv_check_cred
argument_list|(
name|oldcred
argument_list|,
name|PRIV_CRED_SETGROUPS
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|newcred
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|ngrp
operator|>
literal|0
condition|)
block|{
name|newcred
operator|->
name|cr_ngroups
operator|=
name|ngrp
operator|+
literal|1
expr_stmt|;
name|bsd_gidset
operator|=
name|newcred
operator|->
name|cr_groups
expr_stmt|;
name|ngrp
operator|--
expr_stmt|;
while|while
condition|(
name|ngrp
operator|>=
literal|0
condition|)
block|{
name|bsd_gidset
index|[
name|ngrp
operator|+
literal|1
index|]
operator|=
name|linux_gidset
index|[
name|ngrp
index|]
expr_stmt|;
name|ngrp
operator|--
expr_stmt|;
block|}
block|}
else|else
name|newcred
operator|->
name|cr_ngroups
operator|=
literal|1
expr_stmt|;
name|setsugid
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_ucred
operator|=
name|newcred
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|oldcred
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|linux_gidset
argument_list|,
name|M_LINUX
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_getgroups
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getgroups_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|l_gid_t
modifier|*
name|linux_gidset
decl_stmt|;
name|gid_t
modifier|*
name|bsd_gidset
decl_stmt|;
name|int
name|bsd_gidsetsz
decl_stmt|,
name|ngrp
decl_stmt|,
name|error
decl_stmt|;
name|cred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
name|bsd_gidset
operator|=
name|cred
operator|->
name|cr_groups
expr_stmt|;
name|bsd_gidsetsz
operator|=
name|cred
operator|->
name|cr_ngroups
operator|-
literal|1
expr_stmt|;
comment|/* 	 * cr_groups[0] holds egid. Returning the whole set 	 * here will cause a duplicate. Exclude cr_groups[0] 	 * to prevent that. 	 */
if|if
condition|(
operator|(
name|ngrp
operator|=
name|args
operator|->
name|gidsetsize
operator|)
operator|==
literal|0
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|bsd_gidsetsz
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ngrp
operator|<
name|bsd_gidsetsz
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ngrp
operator|=
literal|0
expr_stmt|;
name|linux_gidset
operator|=
name|malloc
argument_list|(
name|bsd_gidsetsz
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|linux_gidset
argument_list|)
argument_list|,
name|M_LINUX
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
while|while
condition|(
name|ngrp
operator|<
name|bsd_gidsetsz
condition|)
block|{
name|linux_gidset
index|[
name|ngrp
index|]
operator|=
name|bsd_gidset
index|[
name|ngrp
operator|+
literal|1
index|]
expr_stmt|;
name|ngrp
operator|++
expr_stmt|;
block|}
name|error
operator|=
name|copyout
argument_list|(
name|linux_gidset
argument_list|,
name|args
operator|->
name|grouplist
argument_list|,
name|ngrp
operator|*
sizeof|sizeof
argument_list|(
name|l_gid_t
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|linux_gidset
argument_list|,
name|M_LINUX
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|ngrp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_setrlimit
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_setrlimit_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|rlimit
name|bsd_rlim
decl_stmt|;
name|struct
name|l_rlimit
name|rlim
decl_stmt|;
name|u_int
name|which
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|setrlimit
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|setrlimit
argument_list|,
literal|"%d, %p"
argument_list|)
argument_list|,
name|args
operator|->
name|resource
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|rlim
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|resource
operator|>=
name|LINUX_RLIM_NLIMITS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|which
operator|=
name|linux_to_bsd_resource
index|[
name|args
operator|->
name|resource
index|]
expr_stmt|;
if|if
condition|(
name|which
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|rlim
argument_list|,
operator|&
name|rlim
argument_list|,
sizeof|sizeof
argument_list|(
name|rlim
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bsd_rlim
operator|.
name|rlim_cur
operator|=
operator|(
name|rlim_t
operator|)
name|rlim
operator|.
name|rlim_cur
expr_stmt|;
name|bsd_rlim
operator|.
name|rlim_max
operator|=
operator|(
name|rlim_t
operator|)
name|rlim
operator|.
name|rlim_max
expr_stmt|;
return|return
operator|(
name|kern_setrlimit
argument_list|(
name|td
argument_list|,
name|which
argument_list|,
operator|&
name|bsd_rlim
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|&&
name|defined
argument_list|(
name|COMPAT_LINUX32
argument_list|)
operator|)
end_if

begin_function
name|int
name|linux_old_getrlimit
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_old_getrlimit_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|l_rlimit
name|rlim
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|rlimit
name|bsd_rlim
decl_stmt|;
name|u_int
name|which
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|old_getrlimit
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|old_getrlimit
argument_list|,
literal|"%d, %p"
argument_list|)
argument_list|,
name|args
operator|->
name|resource
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|rlim
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|resource
operator|>=
name|LINUX_RLIM_NLIMITS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|which
operator|=
name|linux_to_bsd_resource
index|[
name|args
operator|->
name|resource
index|]
expr_stmt|;
if|if
condition|(
name|which
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|lim_rlimit
argument_list|(
name|p
argument_list|,
name|which
argument_list|,
operator|&
name|bsd_rlim
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_LINUX32
name|rlim
operator|.
name|rlim_cur
operator|=
operator|(
name|unsigned
name|int
operator|)
name|bsd_rlim
operator|.
name|rlim_cur
expr_stmt|;
if|if
condition|(
name|rlim
operator|.
name|rlim_cur
operator|==
name|UINT_MAX
condition|)
name|rlim
operator|.
name|rlim_cur
operator|=
name|INT_MAX
expr_stmt|;
name|rlim
operator|.
name|rlim_max
operator|=
operator|(
name|unsigned
name|int
operator|)
name|bsd_rlim
operator|.
name|rlim_max
expr_stmt|;
if|if
condition|(
name|rlim
operator|.
name|rlim_max
operator|==
name|UINT_MAX
condition|)
name|rlim
operator|.
name|rlim_max
operator|=
name|INT_MAX
expr_stmt|;
else|#
directive|else
name|rlim
operator|.
name|rlim_cur
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bsd_rlim
operator|.
name|rlim_cur
expr_stmt|;
if|if
condition|(
name|rlim
operator|.
name|rlim_cur
operator|==
name|ULONG_MAX
condition|)
name|rlim
operator|.
name|rlim_cur
operator|=
name|LONG_MAX
expr_stmt|;
name|rlim
operator|.
name|rlim_max
operator|=
operator|(
name|unsigned
name|long
operator|)
name|bsd_rlim
operator|.
name|rlim_max
expr_stmt|;
if|if
condition|(
name|rlim
operator|.
name|rlim_max
operator|==
name|ULONG_MAX
condition|)
name|rlim
operator|.
name|rlim_max
operator|=
name|LONG_MAX
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|rlim
argument_list|,
name|args
operator|->
name|rlim
argument_list|,
sizeof|sizeof
argument_list|(
name|rlim
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __i386__ || (__amd64__&& COMPAT_LINUX32) */
end_comment

begin_function
name|int
name|linux_getrlimit
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getrlimit_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|l_rlimit
name|rlim
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|rlimit
name|bsd_rlim
decl_stmt|;
name|u_int
name|which
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|getrlimit
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|getrlimit
argument_list|,
literal|"%d, %p"
argument_list|)
argument_list|,
name|args
operator|->
name|resource
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|rlim
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|resource
operator|>=
name|LINUX_RLIM_NLIMITS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|which
operator|=
name|linux_to_bsd_resource
index|[
name|args
operator|->
name|resource
index|]
expr_stmt|;
if|if
condition|(
name|which
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|lim_rlimit
argument_list|(
name|p
argument_list|,
name|which
argument_list|,
operator|&
name|bsd_rlim
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
operator|(
name|l_ulong
operator|)
name|bsd_rlim
operator|.
name|rlim_cur
expr_stmt|;
name|rlim
operator|.
name|rlim_max
operator|=
operator|(
name|l_ulong
operator|)
name|bsd_rlim
operator|.
name|rlim_max
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|rlim
argument_list|,
name|args
operator|->
name|rlim
argument_list|,
sizeof|sizeof
argument_list|(
name|rlim
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_sched_setscheduler
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_sched_setscheduler_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|sched_param
name|sched_param
decl_stmt|;
name|struct
name|thread
modifier|*
name|tdt
decl_stmt|;
name|int
name|error
decl_stmt|,
name|policy
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|sched_setscheduler
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|sched_setscheduler
argument_list|,
literal|"%d, %d, %p"
argument_list|)
argument_list|,
name|args
operator|->
name|pid
argument_list|,
name|args
operator|->
name|policy
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|args
operator|->
name|param
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|args
operator|->
name|policy
condition|)
block|{
case|case
name|LINUX_SCHED_OTHER
case|:
name|policy
operator|=
name|SCHED_OTHER
expr_stmt|;
break|break;
case|case
name|LINUX_SCHED_FIFO
case|:
name|policy
operator|=
name|SCHED_FIFO
expr_stmt|;
break|break;
case|case
name|LINUX_SCHED_RR
case|:
name|policy
operator|=
name|SCHED_RR
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|param
argument_list|,
operator|&
name|sched_param
argument_list|,
sizeof|sizeof
argument_list|(
name|sched_param
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tdt
operator|=
name|linux_tdfind
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|pid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdt
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
name|error
operator|=
name|kern_sched_setscheduler
argument_list|(
name|td
argument_list|,
name|tdt
argument_list|,
name|policy
argument_list|,
operator|&
name|sched_param
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|tdt
operator|->
name|td_proc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_sched_getscheduler
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_sched_getscheduler_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|tdt
decl_stmt|;
name|int
name|error
decl_stmt|,
name|policy
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|sched_getscheduler
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|sched_getscheduler
argument_list|,
literal|"%d"
argument_list|)
argument_list|,
name|args
operator|->
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tdt
operator|=
name|linux_tdfind
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|pid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdt
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
name|error
operator|=
name|kern_sched_getscheduler
argument_list|(
name|td
argument_list|,
name|tdt
argument_list|,
operator|&
name|policy
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|tdt
operator|->
name|td_proc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|policy
condition|)
block|{
case|case
name|SCHED_OTHER
case|:
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|LINUX_SCHED_OTHER
expr_stmt|;
break|break;
case|case
name|SCHED_FIFO
case|:
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|LINUX_SCHED_FIFO
expr_stmt|;
break|break;
case|case
name|SCHED_RR
case|:
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|LINUX_SCHED_RR
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_sched_get_priority_max
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_sched_get_priority_max_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|sched_get_priority_max_args
name|bsd
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|sched_get_priority_max
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|sched_get_priority_max
argument_list|,
literal|"%d"
argument_list|)
argument_list|,
name|args
operator|->
name|policy
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|args
operator|->
name|policy
condition|)
block|{
case|case
name|LINUX_SCHED_OTHER
case|:
name|bsd
operator|.
name|policy
operator|=
name|SCHED_OTHER
expr_stmt|;
break|break;
case|case
name|LINUX_SCHED_FIFO
case|:
name|bsd
operator|.
name|policy
operator|=
name|SCHED_FIFO
expr_stmt|;
break|break;
case|case
name|LINUX_SCHED_RR
case|:
name|bsd
operator|.
name|policy
operator|=
name|SCHED_RR
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|sys_sched_get_priority_max
argument_list|(
name|td
argument_list|,
operator|&
name|bsd
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_sched_get_priority_min
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_sched_get_priority_min_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|sched_get_priority_min_args
name|bsd
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|sched_get_priority_min
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|sched_get_priority_min
argument_list|,
literal|"%d"
argument_list|)
argument_list|,
name|args
operator|->
name|policy
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|args
operator|->
name|policy
condition|)
block|{
case|case
name|LINUX_SCHED_OTHER
case|:
name|bsd
operator|.
name|policy
operator|=
name|SCHED_OTHER
expr_stmt|;
break|break;
case|case
name|LINUX_SCHED_FIFO
case|:
name|bsd
operator|.
name|policy
operator|=
name|SCHED_FIFO
expr_stmt|;
break|break;
case|case
name|LINUX_SCHED_RR
case|:
name|bsd
operator|.
name|policy
operator|=
name|SCHED_RR
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|sys_sched_get_priority_min
argument_list|(
name|td
argument_list|,
operator|&
name|bsd
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|REBOOT_CAD_ON
value|0x89abcdef
end_define

begin_define
define|#
directive|define
name|REBOOT_CAD_OFF
value|0
end_define

begin_define
define|#
directive|define
name|REBOOT_HALT
value|0xcdef0123
end_define

begin_define
define|#
directive|define
name|REBOOT_RESTART
value|0x01234567
end_define

begin_define
define|#
directive|define
name|REBOOT_RESTART2
value|0xA1B2C3D4
end_define

begin_define
define|#
directive|define
name|REBOOT_POWEROFF
value|0x4321FEDC
end_define

begin_define
define|#
directive|define
name|REBOOT_MAGIC1
value|0xfee1dead
end_define

begin_define
define|#
directive|define
name|REBOOT_MAGIC2
value|0x28121969
end_define

begin_define
define|#
directive|define
name|REBOOT_MAGIC2A
value|0x05121996
end_define

begin_define
define|#
directive|define
name|REBOOT_MAGIC2B
value|0x16041998
end_define

begin_function
name|int
name|linux_reboot
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_reboot_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|reboot_args
name|bsd_args
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|reboot
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|reboot
argument_list|,
literal|"0x%x"
argument_list|)
argument_list|,
name|args
operator|->
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|magic1
operator|!=
name|REBOOT_MAGIC1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|args
operator|->
name|magic2
condition|)
block|{
case|case
name|REBOOT_MAGIC2
case|:
case|case
name|REBOOT_MAGIC2A
case|:
case|case
name|REBOOT_MAGIC2B
case|:
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
switch|switch
condition|(
name|args
operator|->
name|cmd
condition|)
block|{
case|case
name|REBOOT_CAD_ON
case|:
case|case
name|REBOOT_CAD_OFF
case|:
return|return
operator|(
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_REBOOT
argument_list|)
operator|)
return|;
case|case
name|REBOOT_HALT
case|:
name|bsd_args
operator|.
name|opt
operator|=
name|RB_HALT
expr_stmt|;
break|break;
case|case
name|REBOOT_RESTART
case|:
case|case
name|REBOOT_RESTART2
case|:
name|bsd_args
operator|.
name|opt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|REBOOT_POWEROFF
case|:
name|bsd_args
operator|.
name|opt
operator|=
name|RB_POWEROFF
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|sys_reboot
argument_list|(
name|td
argument_list|,
operator|&
name|bsd_args
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The FreeBSD native getpid(2), getgid(2) and getuid(2) also modify  * td->td_retval[1] when COMPAT_43 is defined. This clobbers registers that  * are assumed to be preserved. The following lightweight syscalls fixes  * this. See also linux_getgid16() and linux_getuid16() in linux_uid16.c  *  * linux_getpid() - MP SAFE  * linux_getgid() - MP SAFE  * linux_getuid() - MP SAFE  */
end_comment

begin_function
name|int
name|linux_getpid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getpid_args
modifier|*
name|args
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|getpid
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|getpid
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_gettid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_gettid_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|linux_emuldata
modifier|*
name|em
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|gettid
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|gettid
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|em
operator|=
name|em_find
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|em
operator|!=
name|NULL
argument_list|,
operator|(
literal|"gettid: emuldata not found.\n"
operator|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|em
operator|->
name|em_tid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_getppid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getppid_args
modifier|*
name|args
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|getppid
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|getppid
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pptr
operator|->
name|p_pid
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_getgid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getgid_args
modifier|*
name|args
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|getgid
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|getgid
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_rgid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_getuid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getuid_args
modifier|*
name|args
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|getuid
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|getuid
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|td
operator|->
name|td_ucred
operator|->
name|cr_ruid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_getsid
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getsid_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|getsid_args
name|bsd
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|getsid
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|getsid
argument_list|,
literal|"%i"
argument_list|)
argument_list|,
name|args
operator|->
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bsd
operator|.
name|pid
operator|=
name|args
operator|->
name|pid
expr_stmt|;
return|return
operator|(
name|sys_getsid
argument_list|(
name|td
argument_list|,
operator|&
name|bsd
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_nosys
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|nosys_args
modifier|*
name|ignore
parameter_list|)
block|{
return|return
operator|(
name|ENOSYS
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_getpriority
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_getpriority_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|getpriority_args
name|bsd_args
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|getpriority
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|getpriority
argument_list|,
literal|"%i, %i"
argument_list|)
argument_list|,
name|args
operator|->
name|which
argument_list|,
name|args
operator|->
name|who
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bsd_args
operator|.
name|which
operator|=
name|args
operator|->
name|which
expr_stmt|;
name|bsd_args
operator|.
name|who
operator|=
name|args
operator|->
name|who
expr_stmt|;
name|error
operator|=
name|sys_getpriority
argument_list|(
name|td
argument_list|,
operator|&
name|bsd_args
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|20
operator|-
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_sethostname
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_sethostname_args
modifier|*
name|args
parameter_list|)
block|{
name|int
name|name
index|[
literal|2
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|sethostname
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|sethostname
argument_list|,
literal|"*, %i"
argument_list|)
argument_list|,
name|args
operator|->
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|name
index|[
literal|0
index|]
operator|=
name|CTL_KERN
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
name|KERN_HOSTNAME
expr_stmt|;
return|return
operator|(
name|userland_sysctl
argument_list|(
name|td
argument_list|,
name|name
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|args
operator|->
name|hostname
argument_list|,
name|args
operator|->
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_setdomainname
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_setdomainname_args
modifier|*
name|args
parameter_list|)
block|{
name|int
name|name
index|[
literal|2
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|setdomainname
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|setdomainname
argument_list|,
literal|"*, %i"
argument_list|)
argument_list|,
name|args
operator|->
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|name
index|[
literal|0
index|]
operator|=
name|CTL_KERN
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
name|KERN_NISDOMAINNAME
expr_stmt|;
return|return
operator|(
name|userland_sysctl
argument_list|(
name|td
argument_list|,
name|name
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|args
operator|->
name|name
argument_list|,
name|args
operator|->
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_exit_group
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_exit_group_args
modifier|*
name|args
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|exit_group
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|exit_group
argument_list|,
literal|"%i"
argument_list|)
argument_list|,
name|args
operator|->
name|error_code
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|LINUX_CTR2
argument_list|(
name|exit_group
argument_list|,
literal|"thread(%d) (%d)"
argument_list|,
name|td
operator|->
name|td_tid
argument_list|,
name|args
operator|->
name|error_code
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: we should send a signal to the parent if 	 * SIGNAL_EXIT_GROUP is set. We ignore that (temporarily?) 	 * as it doesnt occur often. 	 */
name|exit1
argument_list|(
name|td
argument_list|,
name|W_EXITCODE
argument_list|(
name|args
operator|->
name|error_code
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_define
define|#
directive|define
name|_LINUX_CAPABILITY_VERSION
value|0x19980330
end_define

begin_struct
struct|struct
name|l_user_cap_header
block|{
name|l_int
name|version
decl_stmt|;
name|l_int
name|pid
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|l_user_cap_data
block|{
name|l_int
name|effective
decl_stmt|;
name|l_int
name|permitted
decl_stmt|;
name|l_int
name|inheritable
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|linux_capget
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_capget_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|l_user_cap_header
name|luch
decl_stmt|;
name|struct
name|l_user_cap_data
name|lucd
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|args
operator|->
name|hdrp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|hdrp
argument_list|,
operator|&
name|luch
argument_list|,
sizeof|sizeof
argument_list|(
name|luch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|luch
operator|.
name|version
operator|!=
name|_LINUX_CAPABILITY_VERSION
condition|)
block|{
name|luch
operator|.
name|version
operator|=
name|_LINUX_CAPABILITY_VERSION
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|luch
argument_list|,
name|args
operator|->
name|hdrp
argument_list|,
sizeof|sizeof
argument_list|(
name|luch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|luch
operator|.
name|pid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|args
operator|->
name|datap
condition|)
block|{
comment|/* 		 * The current implementation doesn't support setting 		 * a capability (it's essentially a stub) so indicate 		 * that no capabilities are currently set or available 		 * to request. 		 */
name|bzero
argument_list|(
operator|&
name|lucd
argument_list|,
sizeof|sizeof
argument_list|(
name|lucd
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|lucd
argument_list|,
name|args
operator|->
name|datap
argument_list|,
sizeof|sizeof
argument_list|(
name|lucd
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_capset
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_capset_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|l_user_cap_header
name|luch
decl_stmt|;
name|struct
name|l_user_cap_data
name|lucd
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|args
operator|->
name|hdrp
operator|==
name|NULL
operator|||
name|args
operator|->
name|datap
operator|==
name|NULL
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|hdrp
argument_list|,
operator|&
name|luch
argument_list|,
sizeof|sizeof
argument_list|(
name|luch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|luch
operator|.
name|version
operator|!=
name|_LINUX_CAPABILITY_VERSION
condition|)
block|{
name|luch
operator|.
name|version
operator|=
name|_LINUX_CAPABILITY_VERSION
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|luch
argument_list|,
name|args
operator|->
name|hdrp
argument_list|,
sizeof|sizeof
argument_list|(
name|luch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|luch
operator|.
name|pid
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|datap
argument_list|,
operator|&
name|lucd
argument_list|,
sizeof|sizeof
argument_list|(
name|lucd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* We currently don't support setting any capabilities. */
if|if
condition|(
name|lucd
operator|.
name|effective
operator|||
name|lucd
operator|.
name|permitted
operator|||
name|lucd
operator|.
name|inheritable
condition|)
block|{
name|linux_msg
argument_list|(
name|td
argument_list|,
literal|"capset effective=0x%x, permitted=0x%x, "
literal|"inheritable=0x%x is not implemented"
argument_list|,
operator|(
name|int
operator|)
name|lucd
operator|.
name|effective
argument_list|,
operator|(
name|int
operator|)
name|lucd
operator|.
name|permitted
argument_list|,
operator|(
name|int
operator|)
name|lucd
operator|.
name|inheritable
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_prctl
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_prctl_args
modifier|*
name|args
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|,
name|max_size
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|char
name|comm
index|[
name|LINUX_MAX_COMM_LEN
index|]
decl_stmt|;
name|struct
name|linux_emuldata
modifier|*
name|em
decl_stmt|;
name|int
name|pdeath_signal
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|prctl
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|prctl
argument_list|,
literal|"%d, %ju, %ju, %ju, %ju"
argument_list|)
argument_list|,
name|args
operator|->
name|option
argument_list|,
operator|(
name|uintmax_t
operator|)
name|args
operator|->
name|arg2
argument_list|,
operator|(
name|uintmax_t
operator|)
name|args
operator|->
name|arg3
argument_list|,
operator|(
name|uintmax_t
operator|)
name|args
operator|->
name|arg4
argument_list|,
operator|(
name|uintmax_t
operator|)
name|args
operator|->
name|arg5
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|args
operator|->
name|option
condition|)
block|{
case|case
name|LINUX_PR_SET_PDEATHSIG
case|:
if|if
condition|(
operator|!
name|LINUX_SIG_VALID
argument_list|(
name|args
operator|->
name|arg2
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|em
operator|=
name|em_find
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|em
operator|!=
name|NULL
argument_list|,
operator|(
literal|"prctl: emuldata not found.\n"
operator|)
argument_list|)
expr_stmt|;
name|em
operator|->
name|pdeath_signal
operator|=
name|args
operator|->
name|arg2
expr_stmt|;
break|break;
case|case
name|LINUX_PR_GET_PDEATHSIG
case|:
name|em
operator|=
name|em_find
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|em
operator|!=
name|NULL
argument_list|,
operator|(
literal|"prctl: emuldata not found.\n"
operator|)
argument_list|)
expr_stmt|;
name|pdeath_signal
operator|=
name|em
operator|->
name|pdeath_signal
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|pdeath_signal
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|register_t
operator|)
name|args
operator|->
name|arg2
argument_list|,
sizeof|sizeof
argument_list|(
name|pdeath_signal
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINUX_PR_GET_KEEPCAPS
case|:
comment|/* 		 * Indicate that we always clear the effective and 		 * permitted capability sets when the user id becomes 		 * non-zero (actually the capability sets are simply 		 * always zero in the current implementation). 		 */
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LINUX_PR_SET_KEEPCAPS
case|:
comment|/* 		 * Ignore requests to keep the effective and permitted 		 * capability sets when the user id becomes non-zero. 		 */
break|break;
case|case
name|LINUX_PR_SET_NAME
case|:
comment|/* 		 * To be on the safe side we need to make sure to not 		 * overflow the size a linux program expects. We already 		 * do this here in the copyin, so that we don't need to 		 * check on copyout. 		 */
name|max_size
operator|=
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|comm
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|p_comm
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyinstr
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|register_t
operator|)
name|args
operator|->
name|arg2
argument_list|,
name|comm
argument_list|,
name|max_size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Linux silently truncates the name if it is too long. */
if|if
condition|(
name|error
operator|==
name|ENAMETOOLONG
condition|)
block|{
comment|/* 			 * XXX: copyinstr() isn't documented to populate the 			 * array completely, so do a copyin() to be on the 			 * safe side. This should be changed in case 			 * copyinstr() is changed to guarantee this. 			 */
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|register_t
operator|)
name|args
operator|->
name|arg2
argument_list|,
name|comm
argument_list|,
name|max_size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|comm
index|[
name|max_size
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|p
operator|->
name|p_comm
argument_list|,
name|comm
argument_list|,
sizeof|sizeof
argument_list|(
name|p
operator|->
name|p_comm
argument_list|)
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|LINUX_PR_GET_NAME
case|:
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|comm
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
sizeof|sizeof
argument_list|(
name|comm
argument_list|)
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|comm
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|register_t
operator|)
name|args
operator|->
name|arg2
argument_list|,
name|strlen
argument_list|(
name|comm
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_sched_setparam
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_sched_setparam_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|sched_param
name|sched_param
decl_stmt|;
name|struct
name|thread
modifier|*
name|tdt
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|sched_setparam
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|sched_setparam
argument_list|,
literal|"%d, *"
argument_list|)
argument_list|,
name|uap
operator|->
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|param
argument_list|,
operator|&
name|sched_param
argument_list|,
sizeof|sizeof
argument_list|(
name|sched_param
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tdt
operator|=
name|linux_tdfind
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|pid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdt
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
name|error
operator|=
name|kern_sched_setparam
argument_list|(
name|td
argument_list|,
name|tdt
argument_list|,
operator|&
name|sched_param
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|tdt
operator|->
name|td_proc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_sched_getparam
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_sched_getparam_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|sched_param
name|sched_param
decl_stmt|;
name|struct
name|thread
modifier|*
name|tdt
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|sched_getparam
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|sched_getparam
argument_list|,
literal|"%d, *"
argument_list|)
argument_list|,
name|uap
operator|->
name|pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tdt
operator|=
name|linux_tdfind
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|pid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdt
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
name|error
operator|=
name|kern_sched_getparam
argument_list|(
name|td
argument_list|,
name|tdt
argument_list|,
operator|&
name|sched_param
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|tdt
operator|->
name|td_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|sched_param
argument_list|,
name|uap
operator|->
name|param
argument_list|,
sizeof|sizeof
argument_list|(
name|sched_param
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get affinity of a process.  */
end_comment

begin_function
name|int
name|linux_sched_getaffinity
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_sched_getaffinity_args
modifier|*
name|args
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|thread
modifier|*
name|tdt
decl_stmt|;
name|struct
name|cpuset_getaffinity_args
name|cga
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|sched_getaffinity
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|sched_getaffinity
argument_list|,
literal|"%d, %d, *"
argument_list|)
argument_list|,
name|args
operator|->
name|pid
argument_list|,
name|args
operator|->
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|len
operator|<
sizeof|sizeof
argument_list|(
name|cpuset_t
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|tdt
operator|=
name|linux_tdfind
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|pid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdt
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
name|PROC_UNLOCK
argument_list|(
name|tdt
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|cga
operator|.
name|level
operator|=
name|CPU_LEVEL_WHICH
expr_stmt|;
name|cga
operator|.
name|which
operator|=
name|CPU_WHICH_TID
expr_stmt|;
name|cga
operator|.
name|id
operator|=
name|tdt
operator|->
name|td_tid
expr_stmt|;
name|cga
operator|.
name|cpusetsize
operator|=
sizeof|sizeof
argument_list|(
name|cpuset_t
argument_list|)
expr_stmt|;
name|cga
operator|.
name|mask
operator|=
operator|(
name|cpuset_t
operator|*
operator|)
name|args
operator|->
name|user_mask_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sys_cpuset_getaffinity
argument_list|(
name|td
argument_list|,
operator|&
name|cga
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
sizeof|sizeof
argument_list|(
name|cpuset_t
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Set affinity of a process.  */
end_comment

begin_function
name|int
name|linux_sched_setaffinity
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_sched_setaffinity_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|cpuset_setaffinity_args
name|csa
decl_stmt|;
name|struct
name|thread
modifier|*
name|tdt
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|sched_setaffinity
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|sched_setaffinity
argument_list|,
literal|"%d, %d, *"
argument_list|)
argument_list|,
name|args
operator|->
name|pid
argument_list|,
name|args
operator|->
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|len
operator|<
sizeof|sizeof
argument_list|(
name|cpuset_t
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|tdt
operator|=
name|linux_tdfind
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|pid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdt
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
name|PROC_UNLOCK
argument_list|(
name|tdt
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|csa
operator|.
name|level
operator|=
name|CPU_LEVEL_WHICH
expr_stmt|;
name|csa
operator|.
name|which
operator|=
name|CPU_WHICH_TID
expr_stmt|;
name|csa
operator|.
name|id
operator|=
name|tdt
operator|->
name|td_tid
expr_stmt|;
name|csa
operator|.
name|cpusetsize
operator|=
sizeof|sizeof
argument_list|(
name|cpuset_t
argument_list|)
expr_stmt|;
name|csa
operator|.
name|mask
operator|=
operator|(
name|cpuset_t
operator|*
operator|)
name|args
operator|->
name|user_mask_ptr
expr_stmt|;
return|return
operator|(
name|sys_cpuset_setaffinity
argument_list|(
name|td
argument_list|,
operator|&
name|csa
argument_list|)
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|linux_rlimit64
block|{
name|uint64_t
name|rlim_cur
decl_stmt|;
name|uint64_t
name|rlim_max
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|linux_prlimit64
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_prlimit64_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|,
name|nrlim
decl_stmt|;
name|struct
name|linux_rlimit64
name|lrlim
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|u_int
name|which
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ldebug
argument_list|(
name|prlimit64
argument_list|)
condition|)
name|printf
argument_list|(
name|ARGS
argument_list|(
name|prlimit64
argument_list|,
literal|"%d, %d, %p, %p"
argument_list|)
argument_list|,
name|args
operator|->
name|pid
argument_list|,
name|args
operator|->
name|resource
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|new
argument_list|,
operator|(
name|void
operator|*
operator|)
name|args
operator|->
name|old
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|args
operator|->
name|resource
operator|>=
name|LINUX_RLIM_NLIMITS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|which
operator|=
name|linux_to_bsd_resource
index|[
name|args
operator|->
name|resource
index|]
expr_stmt|;
if|if
condition|(
name|which
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|args
operator|->
name|new
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Note. Unlike FreeBSD where rlim is signed 64-bit Linux 		 * rlim is unsigned 64-bit. FreeBSD treats negative limits 		 * as INFINITY so we do not need a conversion even. 		 */
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|new
argument_list|,
operator|&
name|nrlim
argument_list|,
sizeof|sizeof
argument_list|(
name|nrlim
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|flags
operator|=
name|PGET_HOLD
operator||
name|PGET_NOTWEXIT
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|new
operator|!=
name|NULL
condition|)
name|flags
operator||=
name|PGET_CANDEBUG
expr_stmt|;
else|else
name|flags
operator||=
name|PGET_CANSEE
expr_stmt|;
name|error
operator|=
name|pget
argument_list|(
name|args
operator|->
name|pid
argument_list|,
name|flags
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|args
operator|->
name|old
operator|!=
name|NULL
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|lim_rlimit
argument_list|(
name|p
argument_list|,
name|which
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|rlim
operator|.
name|rlim_cur
operator|==
name|RLIM_INFINITY
condition|)
name|lrlim
operator|.
name|rlim_cur
operator|=
name|LINUX_RLIM_INFINITY
expr_stmt|;
else|else
name|lrlim
operator|.
name|rlim_cur
operator|=
name|rlim
operator|.
name|rlim_cur
expr_stmt|;
if|if
condition|(
name|rlim
operator|.
name|rlim_max
operator|==
name|RLIM_INFINITY
condition|)
name|lrlim
operator|.
name|rlim_max
operator|=
name|LINUX_RLIM_INFINITY
expr_stmt|;
else|else
name|lrlim
operator|.
name|rlim_max
operator|=
name|rlim
operator|.
name|rlim_max
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|lrlim
argument_list|,
name|args
operator|->
name|old
argument_list|,
sizeof|sizeof
argument_list|(
name|lrlim
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|args
operator|->
name|new
operator|!=
name|NULL
condition|)
name|error
operator|=
name|kern_proc_setrlimit
argument_list|(
name|td
argument_list|,
name|p
argument_list|,
name|which
argument_list|,
operator|&
name|nrlim
argument_list|)
expr_stmt|;
name|out
label|:
name|PRELE
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_pselect6
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_pselect6_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|timeval
name|utv
decl_stmt|,
name|tv0
decl_stmt|,
name|tv1
decl_stmt|,
modifier|*
name|tvp
decl_stmt|;
name|struct
name|l_pselect6arg
name|lpse6
decl_stmt|;
name|struct
name|l_timespec
name|lts
decl_stmt|;
name|struct
name|timespec
name|uts
decl_stmt|;
name|l_sigset_t
name|l_ss
decl_stmt|;
name|sigset_t
modifier|*
name|ssp
decl_stmt|;
name|sigset_t
name|ss
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ssp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|sig
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|sig
argument_list|,
operator|&
name|lpse6
argument_list|,
sizeof|sizeof
argument_list|(
name|lpse6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|lpse6
operator|.
name|ss_len
operator|!=
sizeof|sizeof
argument_list|(
name|l_ss
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|lpse6
operator|.
name|ss
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|PTRIN
argument_list|(
name|lpse6
operator|.
name|ss
argument_list|)
argument_list|,
operator|&
name|l_ss
argument_list|,
sizeof|sizeof
argument_list|(
name|l_ss
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|linux_to_bsd_sigset
argument_list|(
operator|&
name|l_ss
argument_list|,
operator|&
name|ss
argument_list|)
expr_stmt|;
name|ssp
operator|=
operator|&
name|ss
expr_stmt|;
block|}
block|}
comment|/* 	 * Currently glibc changes nanosecond number to microsecond. 	 * This mean losing precision but for now it is hardly seen. 	 */
if|if
condition|(
name|args
operator|->
name|tsp
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|tsp
argument_list|,
operator|&
name|lts
argument_list|,
sizeof|sizeof
argument_list|(
name|lts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|linux_to_native_timespec
argument_list|(
operator|&
name|uts
argument_list|,
operator|&
name|lts
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|utv
argument_list|,
operator|&
name|uts
argument_list|)
expr_stmt|;
if|if
condition|(
name|itimerfix
argument_list|(
operator|&
name|utv
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|microtime
argument_list|(
operator|&
name|tv0
argument_list|)
expr_stmt|;
name|tvp
operator|=
operator|&
name|utv
expr_stmt|;
block|}
else|else
name|tvp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|kern_pselect
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|nfds
argument_list|,
name|args
operator|->
name|readfds
argument_list|,
name|args
operator|->
name|writefds
argument_list|,
name|args
operator|->
name|exceptfds
argument_list|,
name|tvp
argument_list|,
name|ssp
argument_list|,
name|LINUX_NFDBITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|args
operator|->
name|tsp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Compute how much time was left of the timeout, 			 * by subtracting the current time and the time 			 * before we started the call, and subtracting 			 * that result from the user-supplied value. 			 */
name|microtime
argument_list|(
operator|&
name|tv1
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|tv1
argument_list|,
operator|&
name|tv0
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|utv
argument_list|,
operator|&
name|tv1
argument_list|)
expr_stmt|;
if|if
condition|(
name|utv
operator|.
name|tv_sec
operator|<
literal|0
condition|)
name|timevalclear
argument_list|(
operator|&
name|utv
argument_list|)
expr_stmt|;
block|}
else|else
name|timevalclear
argument_list|(
operator|&
name|utv
argument_list|)
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|utv
argument_list|,
operator|&
name|uts
argument_list|)
expr_stmt|;
name|native_to_linux_timespec
argument_list|(
operator|&
name|lts
argument_list|,
operator|&
name|uts
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|lts
argument_list|,
name|args
operator|->
name|tsp
argument_list|,
sizeof|sizeof
argument_list|(
name|lts
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|linux_ppoll
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_ppoll_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|timespec
name|ts0
decl_stmt|,
name|ts1
decl_stmt|;
name|struct
name|l_timespec
name|lts
decl_stmt|;
name|struct
name|timespec
name|uts
decl_stmt|,
modifier|*
name|tsp
decl_stmt|;
name|l_sigset_t
name|l_ss
decl_stmt|;
name|sigset_t
modifier|*
name|ssp
decl_stmt|;
name|sigset_t
name|ss
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|args
operator|->
name|sset
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|args
operator|->
name|ssize
operator|!=
sizeof|sizeof
argument_list|(
name|l_ss
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|sset
argument_list|,
operator|&
name|l_ss
argument_list|,
sizeof|sizeof
argument_list|(
name|l_ss
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|linux_to_bsd_sigset
argument_list|(
operator|&
name|l_ss
argument_list|,
operator|&
name|ss
argument_list|)
expr_stmt|;
name|ssp
operator|=
operator|&
name|ss
expr_stmt|;
block|}
else|else
name|ssp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|tsp
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|tsp
argument_list|,
operator|&
name|lts
argument_list|,
sizeof|sizeof
argument_list|(
name|lts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|linux_to_native_timespec
argument_list|(
operator|&
name|uts
argument_list|,
operator|&
name|lts
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|nanotime
argument_list|(
operator|&
name|ts0
argument_list|)
expr_stmt|;
name|tsp
operator|=
operator|&
name|uts
expr_stmt|;
block|}
else|else
name|tsp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|kern_poll
argument_list|(
name|td
argument_list|,
name|args
operator|->
name|fds
argument_list|,
name|args
operator|->
name|nfds
argument_list|,
name|tsp
argument_list|,
name|ssp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|args
operator|->
name|tsp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
condition|)
block|{
name|nanotime
argument_list|(
operator|&
name|ts1
argument_list|)
expr_stmt|;
name|timespecsub
argument_list|(
operator|&
name|ts1
argument_list|,
operator|&
name|ts0
argument_list|)
expr_stmt|;
name|timespecsub
argument_list|(
operator|&
name|uts
argument_list|,
operator|&
name|ts1
argument_list|)
expr_stmt|;
if|if
condition|(
name|uts
operator|.
name|tv_sec
operator|<
literal|0
condition|)
name|timespecclear
argument_list|(
operator|&
name|uts
argument_list|)
expr_stmt|;
block|}
else|else
name|timespecclear
argument_list|(
operator|&
name|uts
argument_list|)
expr_stmt|;
name|native_to_linux_timespec
argument_list|(
operator|&
name|lts
argument_list|,
operator|&
name|uts
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|lts
argument_list|,
name|args
operator|->
name|tsp
argument_list|,
sizeof|sizeof
argument_list|(
name|lts
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|KTR
argument_list|)
end_if

begin_comment
comment|/* XXX: can be removed when every ldebug(...) and KTR stuff are removed. */
end_comment

begin_decl_stmt
name|u_char
name|linux_debug_map
index|[
name|howmany
argument_list|(
name|LINUX_SYS_MAXSYSCALL
argument_list|,
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|)
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|linux_debug
parameter_list|(
name|int
name|syscall
parameter_list|,
name|int
name|toggle
parameter_list|,
name|int
name|global
parameter_list|)
block|{
if|if
condition|(
name|global
condition|)
block|{
name|char
name|c
init|=
name|toggle
condition|?
literal|0
else|:
literal|0xff
decl_stmt|;
name|memset
argument_list|(
name|linux_debug_map
argument_list|,
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|linux_debug_map
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|syscall
operator|<
literal|0
operator|||
name|syscall
operator|>=
name|LINUX_SYS_MAXSYSCALL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|toggle
condition|)
name|clrbit
argument_list|(
name|linux_debug_map
argument_list|,
name|syscall
argument_list|)
expr_stmt|;
else|else
name|setbit
argument_list|(
name|linux_debug_map
argument_list|,
name|syscall
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Usage: sysctl linux.debug=<syscall_nr>.<0/1>  *  *    E.g.: sysctl linux.debug=21.0  *  * As a special case, syscall "all" will apply to all syscalls globally.  */
end_comment

begin_define
define|#
directive|define
name|LINUX_MAX_DEBUGSTR
value|16
end_define

begin_function
name|int
name|linux_sysctl_debug
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|value
index|[
name|LINUX_MAX_DEBUGSTR
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|,
name|sysc
decl_stmt|,
name|toggle
decl_stmt|;
name|int
name|global
init|=
literal|0
decl_stmt|;
name|value
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|value
argument_list|,
name|LINUX_MAX_DEBUGSTR
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
name|p
operator|=
name|value
init|;
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
operator|*
name|p
operator|!=
literal|'.'
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|sysc
operator|=
name|strtol
argument_list|(
name|value
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|toggle
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
name|global
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|linux_debug
argument_list|(
name|sysc
argument_list|,
name|toggle
argument_list|,
name|global
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG || KTR */
end_comment

begin_function
name|int
name|linux_sched_rr_get_interval
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|linux_sched_rr_get_interval_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|timespec
name|ts
decl_stmt|;
name|struct
name|l_timespec
name|lts
decl_stmt|;
name|struct
name|thread
modifier|*
name|tdt
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * According to man in case the invalid pid specified 	 * EINVAL should be returned. 	 */
if|if
condition|(
name|uap
operator|->
name|pid
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|tdt
operator|=
name|linux_tdfind
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|pid
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdt
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
name|error
operator|=
name|kern_sched_rr_get_interval_td
argument_list|(
name|td
argument_list|,
name|tdt
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|tdt
operator|->
name|td_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|native_to_linux_timespec
argument_list|(
operator|&
name|lts
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|lts
argument_list|,
name|uap
operator|->
name|interval
argument_list|,
sizeof|sizeof
argument_list|(
name|lts
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * In case when the Linux thread is the initial thread in  * the thread group thread id is equal to the process id.  * Glibc depends on this magic (assert in pthread_getattr_np.c).  */
end_comment

begin_function
name|struct
name|thread
modifier|*
name|linux_tdfind
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|lwpid_t
name|tid
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
name|struct
name|linux_emuldata
modifier|*
name|em
decl_stmt|;
name|struct
name|thread
modifier|*
name|tdt
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|tdt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tid
operator|==
literal|0
operator|||
name|tid
operator|==
name|td
operator|->
name|td_tid
condition|)
block|{
name|tdt
operator|=
name|td
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|tdt
operator|->
name|td_proc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tid
operator|>
name|PID_MAX
condition|)
name|tdt
operator|=
name|tdfind
argument_list|(
name|tid
argument_list|,
name|pid
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 		 * Initial thread where the tid equal to the pid. 		 */
name|p
operator|=
name|pfind
argument_list|(
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SV_PROC_ABI
argument_list|(
name|p
argument_list|)
operator|!=
name|SV_ABI_LINUX
condition|)
block|{
comment|/* 				 * p is not a Linuxulator process. 				 */
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|FOREACH_THREAD_IN_PROC
argument_list|(
argument|p
argument_list|,
argument|tdt
argument_list|)
block|{
name|em
operator|=
name|em_find
argument_list|(
name|tdt
argument_list|)
expr_stmt|;
if|if
condition|(
name|tid
operator|==
name|em
operator|->
name|em_tid
condition|)
return|return
operator|(
name|tdt
operator|)
return|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|tdt
operator|)
return|;
block|}
end_function

begin_function
name|void
name|linux_to_bsd_waitopts
parameter_list|(
name|int
name|options
parameter_list|,
name|int
modifier|*
name|bsdopts
parameter_list|)
block|{
if|if
condition|(
name|options
operator|&
name|LINUX_WNOHANG
condition|)
operator|*
name|bsdopts
operator||=
name|WNOHANG
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|LINUX_WUNTRACED
condition|)
operator|*
name|bsdopts
operator||=
name|WUNTRACED
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|LINUX_WEXITED
condition|)
operator|*
name|bsdopts
operator||=
name|WEXITED
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|LINUX_WCONTINUED
condition|)
operator|*
name|bsdopts
operator||=
name|WCONTINUED
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|LINUX_WNOWAIT
condition|)
operator|*
name|bsdopts
operator||=
name|WNOWAIT
expr_stmt|;
if|if
condition|(
name|options
operator|&
name|__WCLONE
condition|)
operator|*
name|bsdopts
operator||=
name|WLINUXCLONE
expr_stmt|;
block|}
end_function

end_unit

