begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998 Mark Newton  * Copyright (c) 1994, 1997 Christos Zoulas.    * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Christos Zoulas.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *   * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_comment
comment|/*#include<sys/ioctl.h>*/
end_comment

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4_types.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4_signal.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4_proto.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4_util.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4_fcntl.h>
end_include

begin_function_decl
specifier|static
name|int
name|svr4_to_bsd_flags
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_long
name|svr4_to_bsd_cmd
parameter_list|(
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fd_revoke
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fd_truncate
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|flock
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bsd_to_svr4_flags
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bsd_to_svr4_flock
parameter_list|(
name|struct
name|flock
modifier|*
parameter_list|,
name|struct
name|svr4_flock
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|svr4_to_bsd_flock
parameter_list|(
name|struct
name|svr4_flock
modifier|*
parameter_list|,
name|struct
name|flock
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bsd_to_svr4_flock64
parameter_list|(
name|struct
name|flock
modifier|*
parameter_list|,
name|struct
name|svr4_flock64
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|svr4_to_bsd_flock64
parameter_list|(
name|struct
name|svr4_flock64
modifier|*
parameter_list|,
name|struct
name|flock
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|u_long
name|svr4_to_bsd_cmd
parameter_list|(
name|cmd
parameter_list|)
name|u_long
name|cmd
decl_stmt|;
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SVR4_F_DUPFD
case|:
return|return
name|F_DUPFD
return|;
case|case
name|SVR4_F_GETFD
case|:
return|return
name|F_GETFD
return|;
case|case
name|SVR4_F_SETFD
case|:
return|return
name|F_SETFD
return|;
case|case
name|SVR4_F_GETFL
case|:
return|return
name|F_GETFL
return|;
case|case
name|SVR4_F_SETFL
case|:
return|return
name|F_SETFL
return|;
case|case
name|SVR4_F_GETLK
case|:
return|return
name|F_GETLK
return|;
case|case
name|SVR4_F_SETLK
case|:
return|return
name|F_SETLK
return|;
case|case
name|SVR4_F_SETLKW
case|:
return|return
name|F_SETLKW
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|svr4_to_bsd_flags
parameter_list|(
name|l
parameter_list|)
name|int
name|l
decl_stmt|;
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
name|r
operator||=
operator|(
name|l
operator|&
name|SVR4_O_RDONLY
operator|)
condition|?
name|O_RDONLY
else|:
literal|0
expr_stmt|;
name|r
operator||=
operator|(
name|l
operator|&
name|SVR4_O_WRONLY
operator|)
condition|?
name|O_WRONLY
else|:
literal|0
expr_stmt|;
name|r
operator||=
operator|(
name|l
operator|&
name|SVR4_O_RDWR
operator|)
condition|?
name|O_RDWR
else|:
literal|0
expr_stmt|;
name|r
operator||=
operator|(
name|l
operator|&
name|SVR4_O_NDELAY
operator|)
condition|?
name|O_NONBLOCK
else|:
literal|0
expr_stmt|;
name|r
operator||=
operator|(
name|l
operator|&
name|SVR4_O_APPEND
operator|)
condition|?
name|O_APPEND
else|:
literal|0
expr_stmt|;
name|r
operator||=
operator|(
name|l
operator|&
name|SVR4_O_SYNC
operator|)
condition|?
name|O_FSYNC
else|:
literal|0
expr_stmt|;
name|r
operator||=
operator|(
name|l
operator|&
name|SVR4_O_NONBLOCK
operator|)
condition|?
name|O_NONBLOCK
else|:
literal|0
expr_stmt|;
name|r
operator||=
operator|(
name|l
operator|&
name|SVR4_O_PRIV
operator|)
condition|?
name|O_EXLOCK
else|:
literal|0
expr_stmt|;
name|r
operator||=
operator|(
name|l
operator|&
name|SVR4_O_CREAT
operator|)
condition|?
name|O_CREAT
else|:
literal|0
expr_stmt|;
name|r
operator||=
operator|(
name|l
operator|&
name|SVR4_O_TRUNC
operator|)
condition|?
name|O_TRUNC
else|:
literal|0
expr_stmt|;
name|r
operator||=
operator|(
name|l
operator|&
name|SVR4_O_EXCL
operator|)
condition|?
name|O_EXCL
else|:
literal|0
expr_stmt|;
name|r
operator||=
operator|(
name|l
operator|&
name|SVR4_O_NOCTTY
operator|)
condition|?
name|O_NOCTTY
else|:
literal|0
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bsd_to_svr4_flags
parameter_list|(
name|l
parameter_list|)
name|int
name|l
decl_stmt|;
block|{
name|int
name|r
init|=
literal|0
decl_stmt|;
name|r
operator||=
operator|(
name|l
operator|&
name|O_RDONLY
operator|)
condition|?
name|SVR4_O_RDONLY
else|:
literal|0
expr_stmt|;
name|r
operator||=
operator|(
name|l
operator|&
name|O_WRONLY
operator|)
condition|?
name|SVR4_O_WRONLY
else|:
literal|0
expr_stmt|;
name|r
operator||=
operator|(
name|l
operator|&
name|O_RDWR
operator|)
condition|?
name|SVR4_O_RDWR
else|:
literal|0
expr_stmt|;
name|r
operator||=
operator|(
name|l
operator|&
name|O_NDELAY
operator|)
condition|?
name|SVR4_O_NONBLOCK
else|:
literal|0
expr_stmt|;
name|r
operator||=
operator|(
name|l
operator|&
name|O_APPEND
operator|)
condition|?
name|SVR4_O_APPEND
else|:
literal|0
expr_stmt|;
name|r
operator||=
operator|(
name|l
operator|&
name|O_FSYNC
operator|)
condition|?
name|SVR4_O_SYNC
else|:
literal|0
expr_stmt|;
name|r
operator||=
operator|(
name|l
operator|&
name|O_NONBLOCK
operator|)
condition|?
name|SVR4_O_NONBLOCK
else|:
literal|0
expr_stmt|;
name|r
operator||=
operator|(
name|l
operator|&
name|O_EXLOCK
operator|)
condition|?
name|SVR4_O_PRIV
else|:
literal|0
expr_stmt|;
name|r
operator||=
operator|(
name|l
operator|&
name|O_CREAT
operator|)
condition|?
name|SVR4_O_CREAT
else|:
literal|0
expr_stmt|;
name|r
operator||=
operator|(
name|l
operator|&
name|O_TRUNC
operator|)
condition|?
name|SVR4_O_TRUNC
else|:
literal|0
expr_stmt|;
name|r
operator||=
operator|(
name|l
operator|&
name|O_EXCL
operator|)
condition|?
name|SVR4_O_EXCL
else|:
literal|0
expr_stmt|;
name|r
operator||=
operator|(
name|l
operator|&
name|O_NOCTTY
operator|)
condition|?
name|SVR4_O_NOCTTY
else|:
literal|0
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bsd_to_svr4_flock
parameter_list|(
name|iflp
parameter_list|,
name|oflp
parameter_list|)
name|struct
name|flock
modifier|*
name|iflp
decl_stmt|;
name|struct
name|svr4_flock
modifier|*
name|oflp
decl_stmt|;
block|{
switch|switch
condition|(
name|iflp
operator|->
name|l_type
condition|)
block|{
case|case
name|F_RDLCK
case|:
name|oflp
operator|->
name|l_type
operator|=
name|SVR4_F_RDLCK
expr_stmt|;
break|break;
case|case
name|F_WRLCK
case|:
name|oflp
operator|->
name|l_type
operator|=
name|SVR4_F_WRLCK
expr_stmt|;
break|break;
case|case
name|F_UNLCK
case|:
name|oflp
operator|->
name|l_type
operator|=
name|SVR4_F_UNLCK
expr_stmt|;
break|break;
default|default:
name|oflp
operator|->
name|l_type
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|oflp
operator|->
name|l_whence
operator|=
operator|(
name|short
operator|)
name|iflp
operator|->
name|l_whence
expr_stmt|;
name|oflp
operator|->
name|l_start
operator|=
operator|(
name|svr4_off_t
operator|)
name|iflp
operator|->
name|l_start
expr_stmt|;
name|oflp
operator|->
name|l_len
operator|=
operator|(
name|svr4_off_t
operator|)
name|iflp
operator|->
name|l_len
expr_stmt|;
name|oflp
operator|->
name|l_sysid
operator|=
literal|0
expr_stmt|;
name|oflp
operator|->
name|l_pid
operator|=
operator|(
name|svr4_pid_t
operator|)
name|iflp
operator|->
name|l_pid
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|svr4_to_bsd_flock
parameter_list|(
name|iflp
parameter_list|,
name|oflp
parameter_list|)
name|struct
name|svr4_flock
modifier|*
name|iflp
decl_stmt|;
name|struct
name|flock
modifier|*
name|oflp
decl_stmt|;
block|{
switch|switch
condition|(
name|iflp
operator|->
name|l_type
condition|)
block|{
case|case
name|SVR4_F_RDLCK
case|:
name|oflp
operator|->
name|l_type
operator|=
name|F_RDLCK
expr_stmt|;
break|break;
case|case
name|SVR4_F_WRLCK
case|:
name|oflp
operator|->
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
break|break;
case|case
name|SVR4_F_UNLCK
case|:
name|oflp
operator|->
name|l_type
operator|=
name|F_UNLCK
expr_stmt|;
break|break;
default|default:
name|oflp
operator|->
name|l_type
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|oflp
operator|->
name|l_whence
operator|=
name|iflp
operator|->
name|l_whence
expr_stmt|;
name|oflp
operator|->
name|l_start
operator|=
operator|(
name|off_t
operator|)
name|iflp
operator|->
name|l_start
expr_stmt|;
name|oflp
operator|->
name|l_len
operator|=
operator|(
name|off_t
operator|)
name|iflp
operator|->
name|l_len
expr_stmt|;
name|oflp
operator|->
name|l_pid
operator|=
operator|(
name|pid_t
operator|)
name|iflp
operator|->
name|l_pid
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bsd_to_svr4_flock64
parameter_list|(
name|iflp
parameter_list|,
name|oflp
parameter_list|)
name|struct
name|flock
modifier|*
name|iflp
decl_stmt|;
name|struct
name|svr4_flock64
modifier|*
name|oflp
decl_stmt|;
block|{
switch|switch
condition|(
name|iflp
operator|->
name|l_type
condition|)
block|{
case|case
name|F_RDLCK
case|:
name|oflp
operator|->
name|l_type
operator|=
name|SVR4_F_RDLCK
expr_stmt|;
break|break;
case|case
name|F_WRLCK
case|:
name|oflp
operator|->
name|l_type
operator|=
name|SVR4_F_WRLCK
expr_stmt|;
break|break;
case|case
name|F_UNLCK
case|:
name|oflp
operator|->
name|l_type
operator|=
name|SVR4_F_UNLCK
expr_stmt|;
break|break;
default|default:
name|oflp
operator|->
name|l_type
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|oflp
operator|->
name|l_whence
operator|=
operator|(
name|short
operator|)
name|iflp
operator|->
name|l_whence
expr_stmt|;
name|oflp
operator|->
name|l_start
operator|=
operator|(
name|svr4_off64_t
operator|)
name|iflp
operator|->
name|l_start
expr_stmt|;
name|oflp
operator|->
name|l_len
operator|=
operator|(
name|svr4_off64_t
operator|)
name|iflp
operator|->
name|l_len
expr_stmt|;
name|oflp
operator|->
name|l_sysid
operator|=
literal|0
expr_stmt|;
name|oflp
operator|->
name|l_pid
operator|=
operator|(
name|svr4_pid_t
operator|)
name|iflp
operator|->
name|l_pid
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|svr4_to_bsd_flock64
parameter_list|(
name|iflp
parameter_list|,
name|oflp
parameter_list|)
name|struct
name|svr4_flock64
modifier|*
name|iflp
decl_stmt|;
name|struct
name|flock
modifier|*
name|oflp
decl_stmt|;
block|{
switch|switch
condition|(
name|iflp
operator|->
name|l_type
condition|)
block|{
case|case
name|SVR4_F_RDLCK
case|:
name|oflp
operator|->
name|l_type
operator|=
name|F_RDLCK
expr_stmt|;
break|break;
case|case
name|SVR4_F_WRLCK
case|:
name|oflp
operator|->
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
break|break;
case|case
name|SVR4_F_UNLCK
case|:
name|oflp
operator|->
name|l_type
operator|=
name|F_UNLCK
expr_stmt|;
break|break;
default|default:
name|oflp
operator|->
name|l_type
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|oflp
operator|->
name|l_whence
operator|=
name|iflp
operator|->
name|l_whence
expr_stmt|;
name|oflp
operator|->
name|l_start
operator|=
operator|(
name|off_t
operator|)
name|iflp
operator|->
name|l_start
expr_stmt|;
name|oflp
operator|->
name|l_len
operator|=
operator|(
name|off_t
operator|)
name|iflp
operator|->
name|l_len
expr_stmt|;
name|oflp
operator|->
name|l_pid
operator|=
operator|(
name|pid_t
operator|)
name|iflp
operator|->
name|l_pid
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fd_revoke
parameter_list|(
name|td
parameter_list|,
name|fd
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|fd
decl_stmt|;
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|mount
modifier|*
name|mp
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|int
name|error
decl_stmt|,
modifier|*
name|retval
decl_stmt|;
name|retval
operator|=
name|td
operator|->
name|td_retval
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fgetvp
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
operator|&
name|vp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VCHR
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VBLK
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|td
operator|->
name|td_ucred
operator|->
name|cr_uid
operator|!=
name|vattr
operator|.
name|va_uid
operator|&&
operator|(
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|error
operator|=
name|vn_start_write
argument_list|(
name|vp
argument_list|,
operator|&
name|mp
argument_list|,
name|V_WAIT
operator||
name|PCATCH
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|vcount
argument_list|(
name|vp
argument_list|)
operator|>
literal|1
condition|)
name|VOP_REVOKE
argument_list|(
name|vp
argument_list|,
name|REVOKEALL
argument_list|)
expr_stmt|;
name|vn_finished_write
argument_list|(
name|mp
argument_list|)
expr_stmt|;
name|out
label|:
name|vrele
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fd_truncate
parameter_list|(
name|td
parameter_list|,
name|fd
parameter_list|,
name|flp
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|struct
name|flock
modifier|*
name|flp
decl_stmt|;
block|{
name|off_t
name|start
decl_stmt|,
name|length
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|int
name|error
decl_stmt|,
modifier|*
name|retval
decl_stmt|;
name|struct
name|ftruncate_args
name|ft
decl_stmt|;
name|retval
operator|=
name|td
operator|->
name|td_retval
expr_stmt|;
comment|/* 	 * We only support truncating the file. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|fget
argument_list|(
name|td
argument_list|,
name|fd
argument_list|,
operator|&
name|fp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|vp
operator|=
operator|(
expr|struct
name|vnode
operator|*
operator|)
name|fp
operator|->
name|f_data
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_type
operator|!=
name|DTYPE_VNODE
operator|||
name|vp
operator|->
name|v_type
operator|==
name|VFIFO
condition|)
block|{
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
name|ESPIPE
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|length
operator|=
name|vattr
operator|.
name|va_size
expr_stmt|;
switch|switch
condition|(
name|flp
operator|->
name|l_whence
condition|)
block|{
case|case
name|SEEK_CUR
case|:
name|start
operator|=
name|fp
operator|->
name|f_offset
operator|+
name|flp
operator|->
name|l_start
expr_stmt|;
break|break;
case|case
name|SEEK_END
case|:
name|start
operator|=
name|flp
operator|->
name|l_start
operator|+
name|length
expr_stmt|;
break|break;
case|case
name|SEEK_SET
case|:
name|start
operator|=
name|flp
operator|->
name|l_start
expr_stmt|;
break|break;
default|default:
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|start
operator|+
name|flp
operator|->
name|l_len
operator|<
name|length
condition|)
block|{
comment|/* We don't support free'ing in the middle of the file */
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|SCARG
argument_list|(
operator|&
name|ft
argument_list|,
name|fd
argument_list|)
operator|=
name|fd
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|ft
argument_list|,
name|length
argument_list|)
operator|=
name|start
expr_stmt|;
name|error
operator|=
name|ftruncate
argument_list|(
name|td
argument_list|,
operator|&
name|ft
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_open
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_open_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|retval
decl_stmt|;
name|struct
name|open_args
name|cup
decl_stmt|;
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
operator|&
name|sg
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|&
name|cup
operator|)
operator|->
name|path
operator|=
name|uap
operator|->
name|path
expr_stmt|;
operator|(
operator|&
name|cup
operator|)
operator|->
name|flags
operator|=
name|svr4_to_bsd_flags
argument_list|(
name|uap
operator|->
name|flags
argument_list|)
expr_stmt|;
operator|(
operator|&
name|cup
operator|)
operator|->
name|mode
operator|=
name|uap
operator|->
name|mode
expr_stmt|;
name|error
operator|=
name|open
argument_list|(
name|td
argument_list|,
operator|&
name|cup
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/*	        uprintf("svr4_open(%s, 0x%0x, 0%o): %d\n", uap->path, 			uap->flags, uap->mode, error);*/
return|return
name|error
return|;
block|}
name|retval
operator|=
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|SCARG
argument_list|(
operator|&
name|cup
argument_list|,
name|flags
argument_list|)
operator|&
name|O_NOCTTY
operator|)
operator|&&
name|SESS_LEADER
argument_list|(
name|p
argument_list|)
operator|&&
operator|!
operator|(
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator|&
name|P_CONTROLT
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|NOTYET
argument_list|)
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|error
operator|=
name|fget
argument_list|(
name|td
argument_list|,
name|retval
argument_list|,
operator|&
name|fp
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 		 * we may have lost a race the above open() and 		 * another thread issuing a close() 		 */
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
comment|/* XXX: correct errno? */
comment|/* ignore any error, just give it a try */
if|if
condition|(
name|fp
operator|->
name|f_type
operator|==
name|DTYPE_VNODE
condition|)
name|fo_ioctl
argument_list|(
name|fp
argument_list|,
name|TIOCSCTTY
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
block|}
end_function

begin_expr_stmt
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
name|error
return|;
end_return

begin_expr_stmt
unit|}  int
name|svr4_sys_open64
argument_list|(
name|td
argument_list|,
name|uap
argument_list|)
specifier|register
expr|struct
name|thread
operator|*
name|td
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|svr4_sys_open64_args
modifier|*
name|uap
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
name|svr4_sys_open
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|svr4_sys_open_args
operator|*
operator|)
name|uap
argument_list|)
return|;
block|}
end_block

begin_function
name|int
name|svr4_sys_creat
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_creat_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|open_args
name|cup
decl_stmt|;
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
operator|&
name|sg
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|cup
argument_list|,
name|path
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|cup
argument_list|,
name|mode
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|cup
argument_list|,
name|flags
argument_list|)
operator|=
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
expr_stmt|;
return|return
name|open
argument_list|(
name|td
argument_list|,
operator|&
name|cup
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_creat64
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_creat64_args
modifier|*
name|uap
decl_stmt|;
block|{
return|return
name|svr4_sys_creat
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|svr4_sys_creat_args
operator|*
operator|)
name|uap
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_llseek
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_llseek_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|lseek_args
name|ap
decl_stmt|;
name|SCARG
argument_list|(
operator|&
name|ap
argument_list|,
name|fd
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|SCARG
argument_list|(
operator|&
name|ap
argument_list|,
name|offset
argument_list|)
operator|=
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|offset1
argument_list|)
operator|)
operator|<<
literal|32
operator|)
operator||
name|SCARG
argument_list|(
name|uap
argument_list|,
name|offset2
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCARG
argument_list|(
operator|&
name|ap
argument_list|,
name|offset
argument_list|)
operator|=
operator|(
operator|(
operator|(
name|u_int64_t
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|offset2
argument_list|)
operator|)
operator|<<
literal|32
operator|)
operator||
name|SCARG
argument_list|(
name|uap
argument_list|,
name|offset1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCARG
argument_list|(
operator|&
name|ap
argument_list|,
name|whence
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|whence
argument_list|)
expr_stmt|;
return|return
name|lseek
argument_list|(
name|td
argument_list|,
operator|&
name|ap
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_access
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_access_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|access_args
name|cup
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
operator|&
name|sg
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
name|td
operator|->
name|td_retval
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|cup
argument_list|,
name|path
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|cup
argument_list|,
name|flags
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|access
argument_list|(
name|td
argument_list|,
operator|&
name|cup
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NOTYET
argument_list|)
end_if

begin_function
name|int
name|svr4_sys_pread
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_pread_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|pread_args
name|pra
decl_stmt|;
comment|/* 	 * Just translate the args structure and call the NetBSD 	 * pread(2) system call (offset type is 64-bit in NetBSD). 	 */
name|SCARG
argument_list|(
operator|&
name|pra
argument_list|,
name|fd
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|pra
argument_list|,
name|buf
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|pra
argument_list|,
name|nbyte
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|nbyte
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|pra
argument_list|,
name|offset
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
name|pread
argument_list|(
name|td
argument_list|,
operator|&
name|pra
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NOTYET
argument_list|)
end_if

begin_function
name|int
name|svr4_sys_pread64
parameter_list|(
name|td
parameter_list|,
name|v
parameter_list|,
name|retval
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|void
modifier|*
name|v
decl_stmt|;
name|register_t
modifier|*
name|retval
decl_stmt|;
block|{
name|struct
name|svr4_sys_pread64_args
modifier|*
name|uap
init|=
name|v
decl_stmt|;
name|struct
name|sys_pread_args
name|pra
decl_stmt|;
comment|/* 	 * Just translate the args structure and call the NetBSD 	 * pread(2) system call (offset type is 64-bit in NetBSD). 	 */
name|SCARG
argument_list|(
operator|&
name|pra
argument_list|,
name|fd
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|pra
argument_list|,
name|buf
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|pra
argument_list|,
name|nbyte
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|nbyte
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|pra
argument_list|,
name|offset
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
operator|(
name|sys_pread
argument_list|(
name|td
argument_list|,
operator|&
name|pra
argument_list|,
name|retval
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOTYET */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NOTYET
argument_list|)
end_if

begin_function
name|int
name|svr4_sys_pwrite
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_pwrite_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|pwrite_args
name|pwa
decl_stmt|;
comment|/* 	 * Just translate the args structure and call the NetBSD 	 * pwrite(2) system call (offset type is 64-bit in NetBSD). 	 */
name|SCARG
argument_list|(
operator|&
name|pwa
argument_list|,
name|fd
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|pwa
argument_list|,
name|buf
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|pwa
argument_list|,
name|nbyte
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|nbyte
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|pwa
argument_list|,
name|offset
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
name|pwrite
argument_list|(
name|td
argument_list|,
operator|&
name|pwa
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NOTYET
argument_list|)
end_if

begin_function
name|int
name|svr4_sys_pwrite64
parameter_list|(
name|td
parameter_list|,
name|v
parameter_list|,
name|retval
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|void
modifier|*
name|v
decl_stmt|;
name|register_t
modifier|*
name|retval
decl_stmt|;
block|{
name|struct
name|svr4_sys_pwrite64_args
modifier|*
name|uap
init|=
name|v
decl_stmt|;
name|struct
name|sys_pwrite_args
name|pwa
decl_stmt|;
comment|/* 	 * Just translate the args structure and call the NetBSD 	 * pwrite(2) system call (offset type is 64-bit in NetBSD). 	 */
name|SCARG
argument_list|(
operator|&
name|pwa
argument_list|,
name|fd
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|pwa
argument_list|,
name|buf
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|pwa
argument_list|,
name|nbyte
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|nbyte
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|pwa
argument_list|,
name|offset
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
operator|(
name|sys_pwrite
argument_list|(
name|td
argument_list|,
operator|&
name|pwa
argument_list|,
name|retval
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NOTYET */
end_comment

begin_function
name|int
name|svr4_sys_fcntl
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_fcntl_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|fcntl_args
name|fa
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
name|retval
operator|=
name|td
operator|->
name|td_retval
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|fa
argument_list|,
name|fd
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|fa
argument_list|,
name|cmd
argument_list|)
operator|=
name|svr4_to_bsd_cmd
argument_list|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|SCARG
argument_list|(
operator|&
name|fa
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
case|case
name|F_DUPFD
case|:
case|case
name|F_GETFD
case|:
case|case
name|F_SETFD
case|:
name|SCARG
argument_list|(
operator|&
name|fa
argument_list|,
name|arg
argument_list|)
operator|=
operator|(
name|long
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
name|fcntl
argument_list|(
name|td
argument_list|,
operator|&
name|fa
argument_list|)
return|;
case|case
name|F_GETFL
case|:
name|SCARG
argument_list|(
operator|&
name|fa
argument_list|,
name|arg
argument_list|)
operator|=
operator|(
name|long
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|error
operator|=
name|fcntl
argument_list|(
name|td
argument_list|,
operator|&
name|fa
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
operator|*
name|retval
operator|=
name|bsd_to_svr4_flags
argument_list|(
operator|*
name|retval
argument_list|)
expr_stmt|;
return|return
name|error
return|;
case|case
name|F_SETFL
case|:
block|{
comment|/* 			 * we must save the O_ASYNC flag, as that is 			 * handled by ioctl(_, I_SETSIG, _) emulation. 			 */
name|long
name|cmd
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"Setting flags %p\n"
operator|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|arg
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|SCARG
argument_list|(
operator|&
name|fa
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
comment|/* save it for a while */
name|SCARG
argument_list|(
operator|&
name|fa
argument_list|,
name|cmd
argument_list|)
operator|=
name|F_GETFL
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fcntl
argument_list|(
name|td
argument_list|,
operator|&
name|fa
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|flags
operator|=
operator|*
name|retval
expr_stmt|;
name|flags
operator|&=
name|O_ASYNC
expr_stmt|;
name|flags
operator||=
name|svr4_to_bsd_flags
argument_list|(
operator|(
name|u_long
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|arg
argument_list|)
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|fa
argument_list|,
name|cmd
argument_list|)
operator|=
name|cmd
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|fa
argument_list|,
name|arg
argument_list|)
operator|=
operator|(
name|long
operator|)
name|flags
expr_stmt|;
return|return
name|fcntl
argument_list|(
name|td
argument_list|,
operator|&
name|fa
argument_list|)
return|;
block|}
case|case
name|F_GETLK
case|:
case|case
name|F_SETLK
case|:
case|case
name|F_SETLKW
case|:
block|{
name|struct
name|svr4_flock
name|ifl
decl_stmt|;
name|struct
name|flock
modifier|*
name|flp
decl_stmt|,
name|fl
decl_stmt|;
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
name|flp
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|flock
argument_list|)
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|fa
argument_list|,
name|arg
argument_list|)
operator|=
operator|(
name|long
operator|)
name|flp
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|arg
argument_list|)
argument_list|,
operator|&
name|ifl
argument_list|,
sizeof|sizeof
name|ifl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|svr4_to_bsd_flock
argument_list|(
operator|&
name|ifl
argument_list|,
operator|&
name|fl
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|fl
argument_list|,
name|flp
argument_list|,
sizeof|sizeof
name|fl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|fcntl
argument_list|(
name|td
argument_list|,
operator|&
name|fa
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|SCARG
argument_list|(
operator|&
name|fa
argument_list|,
name|cmd
argument_list|)
operator|!=
name|F_GETLK
condition|)
return|return
name|error
return|;
name|error
operator|=
name|copyin
argument_list|(
name|flp
argument_list|,
operator|&
name|fl
argument_list|,
sizeof|sizeof
name|fl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|bsd_to_svr4_flock
argument_list|(
operator|&
name|fl
argument_list|,
operator|&
name|ifl
argument_list|)
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|ifl
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|arg
argument_list|)
argument_list|,
sizeof|sizeof
name|ifl
argument_list|)
return|;
block|}
case|case
operator|-
literal|1
case|:
switch|switch
condition|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|cmd
argument_list|)
condition|)
block|{
case|case
name|SVR4_F_DUP2FD
case|:
block|{
name|struct
name|dup2_args
name|du
decl_stmt|;
name|SCARG
argument_list|(
operator|&
name|du
argument_list|,
name|from
argument_list|)
operator|=
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|du
argument_list|,
name|to
argument_list|)
operator|=
operator|(
name|int
operator|)
name|SCARG
argument_list|(
name|uap
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|error
operator|=
name|dup2
argument_list|(
name|td
argument_list|,
operator|&
name|du
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
operator|*
name|retval
operator|=
name|SCARG
argument_list|(
operator|&
name|du
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|SVR4_F_FREESP
case|:
block|{
name|struct
name|svr4_flock
name|ifl
decl_stmt|;
name|struct
name|flock
name|fl
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|arg
argument_list|)
argument_list|,
operator|&
name|ifl
argument_list|,
sizeof|sizeof
name|ifl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|svr4_to_bsd_flock
argument_list|(
operator|&
name|ifl
argument_list|,
operator|&
name|fl
argument_list|)
expr_stmt|;
return|return
name|fd_truncate
argument_list|(
name|td
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fd
argument_list|)
argument_list|,
operator|&
name|fl
argument_list|)
return|;
block|}
case|case
name|SVR4_F_GETLK64
case|:
case|case
name|SVR4_F_SETLK64
case|:
case|case
name|SVR4_F_SETLKW64
case|:
block|{
name|struct
name|svr4_flock64
name|ifl
decl_stmt|;
name|struct
name|flock
modifier|*
name|flp
decl_stmt|,
name|fl
decl_stmt|;
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
name|flp
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|flock
argument_list|)
argument_list|)
expr_stmt|;
name|SCARG
argument_list|(
operator|&
name|fa
argument_list|,
name|arg
argument_list|)
operator|=
operator|(
name|long
operator|)
name|flp
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|arg
argument_list|)
argument_list|,
operator|&
name|ifl
argument_list|,
sizeof|sizeof
name|ifl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|svr4_to_bsd_flock64
argument_list|(
operator|&
name|ifl
argument_list|,
operator|&
name|fl
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|fl
argument_list|,
name|flp
argument_list|,
sizeof|sizeof
name|fl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|fcntl
argument_list|(
name|td
argument_list|,
operator|&
name|fa
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|SCARG
argument_list|(
operator|&
name|fa
argument_list|,
name|cmd
argument_list|)
operator|!=
name|F_GETLK
condition|)
return|return
name|error
return|;
name|error
operator|=
name|copyin
argument_list|(
name|flp
argument_list|,
operator|&
name|fl
argument_list|,
sizeof|sizeof
name|fl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|bsd_to_svr4_flock64
argument_list|(
operator|&
name|fl
argument_list|,
operator|&
name|ifl
argument_list|)
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|ifl
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|arg
argument_list|)
argument_list|,
sizeof|sizeof
name|ifl
argument_list|)
return|;
block|}
case|case
name|SVR4_F_FREESP64
case|:
block|{
name|struct
name|svr4_flock64
name|ifl
decl_stmt|;
name|struct
name|flock
name|fl
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|SCARG
argument_list|(
name|uap
argument_list|,
name|arg
argument_list|)
argument_list|,
operator|&
name|ifl
argument_list|,
sizeof|sizeof
name|ifl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|svr4_to_bsd_flock64
argument_list|(
operator|&
name|ifl
argument_list|,
operator|&
name|fl
argument_list|)
expr_stmt|;
return|return
name|fd_truncate
argument_list|(
name|td
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fd
argument_list|)
argument_list|,
operator|&
name|fl
argument_list|)
return|;
block|}
case|case
name|SVR4_F_REVOKE
case|:
return|return
name|fd_revoke
argument_list|(
name|td
argument_list|,
name|SCARG
argument_list|(
name|uap
argument_list|,
name|fd
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|ENOSYS
return|;
block|}
default|default:
return|return
name|ENOSYS
return|;
block|}
block|}
end_function

end_unit

