begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1998 Mark Newton  * Copyright (c) 1994 Christos Zoulas  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * SVR4 compatibility module.  *  * SVR4 system calls that are implemented differently in BSD are  * handled here.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_mac.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mac.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_comment
comment|/* Must come after sys/malloc.h */
end_comment

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/msg.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/namei.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sem.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/times.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4_types.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4_signal.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4_proto.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4_util.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4_sysconfig.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4_dirent.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4_acl.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4_ulimit.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4_statvfs.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4_hrt.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4_mman.h>
end_include

begin_include
include|#
directive|include
file|<compat/svr4/svr4_wait.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NetBSD
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|UVM
argument_list|)
end_if

begin_include
include|#
directive|include
file|<uvm/uvm_extern.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BSD_DIRENT
parameter_list|(
name|cp
parameter_list|)
value|((struct dirent *)(cp))
end_define

begin_function_decl
specifier|static
name|int
name|svr4_mknod
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|register_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|svr4_mode_t
parameter_list|,
name|svr4_dev_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|clock_t
name|timeval_to_clock_t
parameter_list|(
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|svr4_setinfo
parameter_list|(
name|struct
name|proc
modifier|*
parameter_list|,
name|int
parameter_list|,
name|svr4_siginfo_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_struct_decl
struct_decl|struct
name|svr4_hrtcntl_args
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|int
name|svr4_hrtcntl
parameter_list|(
name|struct
name|thread
modifier|*
parameter_list|,
name|struct
name|svr4_hrtcntl_args
modifier|*
parameter_list|,
name|register_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bsd_statfs_to_svr4_statvfs
parameter_list|(
specifier|const
name|struct
name|statfs
modifier|*
parameter_list|,
name|struct
name|svr4_statvfs
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bsd_statfs_to_svr4_statvfs64
parameter_list|(
specifier|const
name|struct
name|statfs
modifier|*
parameter_list|,
name|struct
name|svr4_statvfs64
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|proc
modifier|*
name|svr4_pfind
parameter_list|(
name|pid_t
name|pid
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* BOGUS noop */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BOGUS
argument_list|)
end_if

begin_function
name|int
name|svr4_sys_setitimer
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_setitimer_args
modifier|*
name|uap
decl_stmt|;
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|svr4_sys_wait
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_wait_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|,
name|st
decl_stmt|,
name|sig
decl_stmt|;
name|error
operator|=
name|kern_wait
argument_list|(
name|td
argument_list|,
name|WAIT_ANY
argument_list|,
operator|&
name|st
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|st
argument_list|)
condition|)
block|{
name|sig
operator|=
name|WTERMSIG
argument_list|(
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|>=
literal|0
operator|&&
name|sig
operator|<
name|NSIG
condition|)
name|st
operator|=
operator|(
name|st
operator|&
operator|~
literal|0177
operator|)
operator||
name|SVR4_BSD2SVR4_SIG
argument_list|(
name|sig
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|st
argument_list|)
condition|)
block|{
name|sig
operator|=
name|WSTOPSIG
argument_list|(
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|>=
literal|0
operator|&&
name|sig
operator|<
name|NSIG
condition|)
name|st
operator|=
operator|(
name|st
operator|&
operator|~
literal|0xff00
operator|)
operator||
operator|(
name|SVR4_BSD2SVR4_SIG
argument_list|(
name|sig
argument_list|)
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
comment|/* 	 * It looks like wait(2) on svr4/solaris/2.4 returns 	 * the status in retval[1], and the pid on retval[0]. 	 */
name|td
operator|->
name|td_retval
index|[
literal|1
index|]
operator|=
name|st
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|status
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|st
argument_list|,
name|uap
operator|->
name|status
argument_list|,
sizeof|sizeof
argument_list|(
name|st
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_execv
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_execv_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|execve_args
name|ap
decl_stmt|;
name|caddr_t
name|sg
decl_stmt|;
name|sg
operator|=
name|stackgap_init
argument_list|()
expr_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
operator|&
name|sg
argument_list|,
name|uap
operator|->
name|path
argument_list|)
expr_stmt|;
name|ap
operator|.
name|fname
operator|=
name|uap
operator|->
name|path
expr_stmt|;
name|ap
operator|.
name|argv
operator|=
name|uap
operator|->
name|argp
expr_stmt|;
name|ap
operator|.
name|envv
operator|=
name|NULL
expr_stmt|;
return|return
name|execve
argument_list|(
name|td
argument_list|,
operator|&
name|ap
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_execve
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_execve_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|execve_args
name|ap
decl_stmt|;
name|caddr_t
name|sg
decl_stmt|;
name|sg
operator|=
name|stackgap_init
argument_list|()
expr_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
operator|&
name|sg
argument_list|,
name|uap
operator|->
name|path
argument_list|)
expr_stmt|;
name|ap
operator|.
name|fname
operator|=
name|uap
operator|->
name|path
expr_stmt|;
name|ap
operator|.
name|argv
operator|=
name|uap
operator|->
name|argp
expr_stmt|;
name|ap
operator|.
name|envv
operator|=
name|uap
operator|->
name|envp
expr_stmt|;
return|return
name|execve
argument_list|(
name|td
argument_list|,
operator|&
name|ap
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_time
parameter_list|(
name|td
parameter_list|,
name|v
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_time_args
modifier|*
name|v
decl_stmt|;
block|{
name|struct
name|svr4_sys_time_args
modifier|*
name|uap
init|=
name|v
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|t
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|tv
operator|.
name|tv_sec
argument_list|,
name|uap
operator|->
name|t
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|uap
operator|->
name|t
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|)
name|tv
operator|.
name|tv_sec
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Read SVR4-style directory entries.  We suck them into kernel space so  * that they can be massaged before being copied out to user code.    *  * This code is ported from the Linux emulator:  Changes to the VFS interface  * between FreeBSD and NetBSD have made it simpler to port it from there than  * to adapt the NetBSD version.  */
end_comment

begin_function
name|int
name|svr4_sys_getdents64
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_getdents64_args
modifier|*
name|uap
decl_stmt|;
block|{
specifier|register
name|struct
name|dirent
modifier|*
name|bdp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|caddr_t
name|inp
decl_stmt|,
name|buf
decl_stmt|;
comment|/* BSD-format */
name|int
name|len
decl_stmt|,
name|reclen
decl_stmt|;
comment|/* BSD-format */
name|caddr_t
name|outp
decl_stmt|;
comment|/* SVR4-format */
name|int
name|resid
decl_stmt|,
name|svr4reclen
init|=
literal|0
decl_stmt|;
comment|/* SVR4-format */
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|off_t
name|off
decl_stmt|;
name|struct
name|svr4_dirent64
name|svr4_dirent
decl_stmt|;
name|int
name|buflen
decl_stmt|,
name|error
decl_stmt|,
name|eofflag
decl_stmt|,
name|nbytes
decl_stmt|,
name|justone
decl_stmt|;
name|u_long
modifier|*
name|cookies
init|=
name|NULL
decl_stmt|,
modifier|*
name|cookiep
decl_stmt|;
name|int
name|ncookies
decl_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"svr4_sys_getdents64(%d, *, %d)\n"
operator|,
name|uap
operator|->
name|fd
operator|,
name|uap
operator|->
name|nbytes
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|getvnode
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
operator|&
name|fp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FREAD
operator|)
operator|==
literal|0
condition|)
block|{
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
name|vp
operator|=
name|fp
operator|->
name|f_vnode
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|nbytes
operator|=
name|uap
operator|->
name|nbytes
expr_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|1
condition|)
block|{
name|nbytes
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|svr4_dirent64
argument_list|)
expr_stmt|;
name|justone
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|justone
operator|=
literal|0
expr_stmt|;
name|off
operator|=
name|fp
operator|->
name|f_offset
expr_stmt|;
define|#
directive|define
name|DIRBLKSIZ
value|512
comment|/* XXX we used to use ufs's DIRBLKSIZ */
name|buflen
operator|=
name|max
argument_list|(
name|DIRBLKSIZ
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|buflen
operator|=
name|min
argument_list|(
name|buflen
argument_list|,
name|MAXBSIZE
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|buflen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|again
label|:
name|aiov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|buflen
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|buflen
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|off
expr_stmt|;
if|if
condition|(
name|cookies
condition|)
block|{
name|free
argument_list|(
name|cookies
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|cookies
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_vnode_readdir
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
endif|#
directive|endif
name|error
operator|=
name|VOP_READDIR
argument_list|(
name|vp
argument_list|,
operator|&
name|auio
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|,
operator|&
name|eofflag
argument_list|,
operator|&
name|ncookies
argument_list|,
operator|&
name|cookies
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|inp
operator|=
name|buf
expr_stmt|;
name|outp
operator|=
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|dp
expr_stmt|;
name|resid
operator|=
name|nbytes
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|buflen
operator|-
name|auio
operator|.
name|uio_resid
operator|)
operator|<=
literal|0
condition|)
block|{
goto|goto
name|eof
goto|;
block|}
name|cookiep
operator|=
name|cookies
expr_stmt|;
if|if
condition|(
name|cookies
condition|)
block|{
comment|/* 		 * When using cookies, the vfs has the option of reading from 		 * a different offset than that supplied (UFS truncates the 		 * offset to a block boundary to make sure that it never reads 		 * partway through a directory entry, even if the directory 		 * has been compacted). 		 */
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
name|ncookies
operator|>
literal|0
operator|&&
operator|*
name|cookiep
operator|<=
name|off
condition|)
block|{
name|bdp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|inp
expr_stmt|;
name|len
operator|-=
name|bdp
operator|->
name|d_reclen
expr_stmt|;
name|inp
operator|+=
name|bdp
operator|->
name|d_reclen
expr_stmt|;
name|cookiep
operator|++
expr_stmt|;
name|ncookies
operator|--
expr_stmt|;
block|}
block|}
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cookiep
operator|&&
name|ncookies
operator|==
literal|0
condition|)
break|break;
name|bdp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|inp
expr_stmt|;
name|reclen
operator|=
name|bdp
operator|->
name|d_reclen
expr_stmt|;
if|if
condition|(
name|reclen
operator|&
literal|3
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"svr4_readdir: reclen=%d\n"
operator|,
name|reclen
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|bdp
operator|->
name|d_fileno
operator|==
literal|0
condition|)
block|{
name|inp
operator|+=
name|reclen
expr_stmt|;
if|if
condition|(
name|cookiep
condition|)
block|{
name|off
operator|=
operator|*
name|cookiep
operator|++
expr_stmt|;
name|ncookies
operator|--
expr_stmt|;
block|}
else|else
name|off
operator|+=
name|reclen
expr_stmt|;
name|len
operator|-=
name|reclen
expr_stmt|;
continue|continue;
block|}
name|svr4reclen
operator|=
name|SVR4_RECLEN
argument_list|(
operator|&
name|svr4_dirent
argument_list|,
name|bdp
operator|->
name|d_namlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclen
operator|>
name|len
operator|||
name|resid
operator|<
name|svr4reclen
condition|)
block|{
name|outp
operator|++
expr_stmt|;
break|break;
block|}
name|svr4_dirent
operator|.
name|d_ino
operator|=
operator|(
name|long
operator|)
name|bdp
operator|->
name|d_fileno
expr_stmt|;
if|if
condition|(
name|justone
condition|)
block|{
comment|/* 			 * old svr4-style readdir usage. 			 */
name|svr4_dirent
operator|.
name|d_off
operator|=
operator|(
name|svr4_off_t
operator|)
name|svr4reclen
expr_stmt|;
name|svr4_dirent
operator|.
name|d_reclen
operator|=
operator|(
name|u_short
operator|)
name|bdp
operator|->
name|d_namlen
expr_stmt|;
block|}
else|else
block|{
name|svr4_dirent
operator|.
name|d_off
operator|=
call|(
name|svr4_off_t
call|)
argument_list|(
name|off
operator|+
name|reclen
argument_list|)
expr_stmt|;
name|svr4_dirent
operator|.
name|d_reclen
operator|=
operator|(
name|u_short
operator|)
name|svr4reclen
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|svr4_dirent
operator|.
name|d_name
argument_list|,
name|bdp
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|svr4_dirent
argument_list|,
name|outp
argument_list|,
name|svr4reclen
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
name|inp
operator|+=
name|reclen
expr_stmt|;
if|if
condition|(
name|cookiep
condition|)
block|{
name|off
operator|=
operator|*
name|cookiep
operator|++
expr_stmt|;
name|ncookies
operator|--
expr_stmt|;
block|}
else|else
name|off
operator|+=
name|reclen
expr_stmt|;
name|outp
operator|+=
name|svr4reclen
expr_stmt|;
name|resid
operator|-=
name|svr4reclen
expr_stmt|;
name|len
operator|-=
name|reclen
expr_stmt|;
if|if
condition|(
name|justone
condition|)
break|break;
block|}
if|if
condition|(
name|outp
operator|==
operator|(
name|caddr_t
operator|)
name|uap
operator|->
name|dp
condition|)
goto|goto
name|again
goto|;
name|fp
operator|->
name|f_offset
operator|=
name|off
expr_stmt|;
if|if
condition|(
name|justone
condition|)
name|nbytes
operator|=
name|resid
operator|+
name|svr4reclen
expr_stmt|;
name|eof
label|:
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|nbytes
operator|-
name|resid
expr_stmt|;
name|out
label|:
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookies
condition|)
name|free
argument_list|(
name|cookies
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_getdents
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_getdents_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|dirent
modifier|*
name|bdp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|caddr_t
name|inp
decl_stmt|,
name|buf
decl_stmt|;
comment|/* BSD-format */
name|int
name|len
decl_stmt|,
name|reclen
decl_stmt|;
comment|/* BSD-format */
name|caddr_t
name|outp
decl_stmt|;
comment|/* SVR4-format */
name|int
name|resid
decl_stmt|,
name|svr4_reclen
decl_stmt|;
comment|/* SVR4-format */
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|struct
name|uio
name|auio
decl_stmt|;
name|struct
name|iovec
name|aiov
decl_stmt|;
name|struct
name|svr4_dirent
name|idb
decl_stmt|;
name|off_t
name|off
decl_stmt|;
comment|/* true file offset */
name|int
name|buflen
decl_stmt|,
name|error
decl_stmt|,
name|eofflag
decl_stmt|;
name|u_long
modifier|*
name|cookiebuf
init|=
name|NULL
decl_stmt|,
modifier|*
name|cookie
decl_stmt|;
name|int
name|ncookies
init|=
literal|0
decl_stmt|,
modifier|*
name|retval
init|=
name|td
operator|->
name|td_retval
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|nbytes
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|getvnode
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_fd
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
operator|&
name|fp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|fp
operator|->
name|f_flag
operator|&
name|FREAD
operator|)
operator|==
literal|0
condition|)
block|{
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBADF
operator|)
return|;
block|}
name|vp
operator|=
name|fp
operator|->
name|f_vnode
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|buflen
operator|=
name|min
argument_list|(
name|MAXBSIZE
argument_list|,
name|uap
operator|->
name|nbytes
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|buflen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|off
operator|=
name|fp
operator|->
name|f_offset
expr_stmt|;
name|again
label|:
name|aiov
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|aiov
operator|.
name|iov_len
operator|=
name|buflen
expr_stmt|;
name|auio
operator|.
name|uio_iov
operator|=
operator|&
name|aiov
expr_stmt|;
name|auio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|auio
operator|.
name|uio_rw
operator|=
name|UIO_READ
expr_stmt|;
name|auio
operator|.
name|uio_segflg
operator|=
name|UIO_SYSSPACE
expr_stmt|;
name|auio
operator|.
name|uio_td
operator|=
name|td
expr_stmt|;
name|auio
operator|.
name|uio_resid
operator|=
name|buflen
expr_stmt|;
name|auio
operator|.
name|uio_offset
operator|=
name|off
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_vnode_readdir
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
endif|#
directive|endif
comment|/*          * First we read into the malloc'ed buffer, then          * we massage it into user space, one record at a time.          */
name|error
operator|=
name|VOP_READDIR
argument_list|(
name|vp
argument_list|,
operator|&
name|auio
argument_list|,
name|fp
operator|->
name|f_cred
argument_list|,
operator|&
name|eofflag
argument_list|,
operator|&
name|ncookies
argument_list|,
operator|&
name|cookiebuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|inp
operator|=
name|buf
expr_stmt|;
name|outp
operator|=
name|uap
operator|->
name|buf
expr_stmt|;
name|resid
operator|=
name|uap
operator|->
name|nbytes
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
name|buflen
operator|-
name|auio
operator|.
name|uio_resid
operator|)
operator|==
literal|0
condition|)
goto|goto
name|eof
goto|;
for|for
control|(
name|cookie
operator|=
name|cookiebuf
init|;
name|len
operator|>
literal|0
condition|;
name|len
operator|-=
name|reclen
control|)
block|{
name|bdp
operator|=
operator|(
expr|struct
name|dirent
operator|*
operator|)
name|inp
expr_stmt|;
name|reclen
operator|=
name|bdp
operator|->
name|d_reclen
expr_stmt|;
if|if
condition|(
name|reclen
operator|&
literal|3
condition|)
name|panic
argument_list|(
literal|"svr4_sys_getdents64: bad reclen"
argument_list|)
expr_stmt|;
name|off
operator|=
operator|*
name|cookie
operator|++
expr_stmt|;
comment|/* each entry points to the next */
if|if
condition|(
operator|(
name|off
operator|>>
literal|32
operator|)
operator|!=
literal|0
condition|)
block|{
name|uprintf
argument_list|(
literal|"svr4_sys_getdents64: dir offset too large for emulated program"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|bdp
operator|->
name|d_fileno
operator|==
literal|0
condition|)
block|{
name|inp
operator|+=
name|reclen
expr_stmt|;
comment|/* it is a hole; squish it out */
continue|continue;
block|}
name|svr4_reclen
operator|=
name|SVR4_RECLEN
argument_list|(
operator|&
name|idb
argument_list|,
name|bdp
operator|->
name|d_namlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclen
operator|>
name|len
operator|||
name|resid
operator|<
name|svr4_reclen
condition|)
block|{
comment|/* entry too big for buffer, so just stop */
name|outp
operator|++
expr_stmt|;
break|break;
block|}
comment|/* 		 * Massage in place to make a SVR4-shaped dirent (otherwise 		 * we have to worry about touching user memory outside of 		 * the copyout() call). 		 */
name|idb
operator|.
name|d_ino
operator|=
operator|(
name|svr4_ino_t
operator|)
name|bdp
operator|->
name|d_fileno
expr_stmt|;
name|idb
operator|.
name|d_off
operator|=
operator|(
name|svr4_off_t
operator|)
name|off
expr_stmt|;
name|idb
operator|.
name|d_reclen
operator|=
operator|(
name|u_short
operator|)
name|svr4_reclen
expr_stmt|;
name|strcpy
argument_list|(
name|idb
operator|.
name|d_name
argument_list|,
name|bdp
operator|->
name|d_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|idb
argument_list|,
name|outp
argument_list|,
name|svr4_reclen
argument_list|)
operator|)
condition|)
goto|goto
name|out
goto|;
comment|/* advance past this real entry */
name|inp
operator|+=
name|reclen
expr_stmt|;
comment|/* advance output past SVR4-shaped entry */
name|outp
operator|+=
name|svr4_reclen
expr_stmt|;
name|resid
operator|-=
name|svr4_reclen
expr_stmt|;
block|}
comment|/* if we squished out the whole block, try again */
if|if
condition|(
name|outp
operator|==
name|uap
operator|->
name|buf
condition|)
goto|goto
name|again
goto|;
name|fp
operator|->
name|f_offset
operator|=
name|off
expr_stmt|;
comment|/* update the vnode offset */
name|eof
label|:
operator|*
name|retval
operator|=
name|uap
operator|->
name|nbytes
operator|-
name|resid
expr_stmt|;
name|out
label|:
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookiebuf
condition|)
name|free
argument_list|(
name|cookiebuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_mmap
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_mmap_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|mmap_args
name|mm
decl_stmt|;
name|int
modifier|*
name|retval
decl_stmt|;
name|retval
operator|=
name|td
operator|->
name|td_retval
expr_stmt|;
define|#
directive|define
name|_MAP_NEW
value|0x80000000
comment|/*          * Verify the arguments.          */
if|if
condition|(
name|uap
operator|->
name|prot
operator|&
operator|~
operator|(
name|PROT_READ
operator||
name|PROT_WRITE
operator||
name|PROT_EXEC
operator|)
condition|)
return|return
name|EINVAL
return|;
comment|/* XXX still needed? */
if|if
condition|(
name|uap
operator|->
name|len
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|mm
operator|.
name|prot
operator|=
name|uap
operator|->
name|prot
expr_stmt|;
name|mm
operator|.
name|len
operator|=
name|uap
operator|->
name|len
expr_stmt|;
name|mm
operator|.
name|flags
operator|=
name|uap
operator|->
name|flags
operator|&
operator|~
name|_MAP_NEW
expr_stmt|;
name|mm
operator|.
name|fd
operator|=
name|uap
operator|->
name|fd
expr_stmt|;
name|mm
operator|.
name|addr
operator|=
name|uap
operator|->
name|addr
expr_stmt|;
name|mm
operator|.
name|pos
operator|=
name|uap
operator|->
name|pos
expr_stmt|;
return|return
name|mmap
argument_list|(
name|td
argument_list|,
operator|&
name|mm
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_mmap64
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_mmap64_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|mmap_args
name|mm
decl_stmt|;
name|void
modifier|*
name|rp
decl_stmt|;
define|#
directive|define
name|_MAP_NEW
value|0x80000000
comment|/*          * Verify the arguments.          */
if|if
condition|(
name|uap
operator|->
name|prot
operator|&
operator|~
operator|(
name|PROT_READ
operator||
name|PROT_WRITE
operator||
name|PROT_EXEC
operator|)
condition|)
return|return
name|EINVAL
return|;
comment|/* XXX still needed? */
if|if
condition|(
name|uap
operator|->
name|len
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|mm
operator|.
name|prot
operator|=
name|uap
operator|->
name|prot
expr_stmt|;
name|mm
operator|.
name|len
operator|=
name|uap
operator|->
name|len
expr_stmt|;
name|mm
operator|.
name|flags
operator|=
name|uap
operator|->
name|flags
operator|&
operator|~
name|_MAP_NEW
expr_stmt|;
name|mm
operator|.
name|fd
operator|=
name|uap
operator|->
name|fd
expr_stmt|;
name|mm
operator|.
name|addr
operator|=
name|uap
operator|->
name|addr
expr_stmt|;
name|mm
operator|.
name|pos
operator|=
name|uap
operator|->
name|pos
expr_stmt|;
name|rp
operator|=
operator|(
name|void
operator|*
operator|)
name|round_page
argument_list|(
call|(
name|vm_offset_t
call|)
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_daddr
operator|+
name|maxdsiz
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mm
operator|.
name|flags
operator|&
name|MAP_FIXED
operator|)
operator|==
literal|0
operator|&&
name|mm
operator|.
name|addr
operator|!=
literal|0
operator|&&
operator|(
name|void
operator|*
operator|)
name|mm
operator|.
name|addr
operator|<
name|rp
condition|)
name|mm
operator|.
name|addr
operator|=
name|rp
expr_stmt|;
return|return
name|mmap
argument_list|(
name|td
argument_list|,
operator|&
name|mm
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_fchroot
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_fchroot_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|filedesc
modifier|*
name|fdp
init|=
name|td
operator|->
name|td_proc
operator|->
name|p_fd
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|,
modifier|*
name|vpold
decl_stmt|;
name|struct
name|file
modifier|*
name|fp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|getvnode
argument_list|(
name|fdp
argument_list|,
name|uap
operator|->
name|fd
argument_list|,
operator|&
name|fp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|vp
operator|=
name|fp
operator|->
name|f_vnode
expr_stmt|;
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_EXCLUSIVE
operator||
name|LK_RETRY
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
name|error
operator|=
name|ENOTDIR
expr_stmt|;
else|else
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|VEXEC
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|VREF
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|FILEDESC_LOCK
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
name|vpold
operator|=
name|fdp
operator|->
name|fd_rdir
expr_stmt|;
name|fdp
operator|->
name|fd_rdir
operator|=
name|vp
expr_stmt|;
name|FILEDESC_UNLOCK
argument_list|(
name|fdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vpold
operator|!=
name|NULL
condition|)
name|vrele
argument_list|(
name|vpold
argument_list|)
expr_stmt|;
name|fdrop
argument_list|(
name|fp
argument_list|,
name|td
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|svr4_mknod
parameter_list|(
name|td
parameter_list|,
name|retval
parameter_list|,
name|path
parameter_list|,
name|mode
parameter_list|,
name|dev
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|register_t
modifier|*
name|retval
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|svr4_mode_t
name|mode
decl_stmt|;
name|svr4_dev_t
name|dev
decl_stmt|;
block|{
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
operator|&
name|sg
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|S_ISFIFO
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|struct
name|mkfifo_args
name|ap
decl_stmt|;
name|ap
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|ap
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
return|return
name|mkfifo
argument_list|(
name|td
argument_list|,
operator|&
name|ap
argument_list|)
return|;
block|}
else|else
block|{
name|struct
name|mknod_args
name|ap
decl_stmt|;
name|ap
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|ap
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|ap
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
return|return
name|mknod
argument_list|(
name|td
argument_list|,
operator|&
name|ap
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|svr4_sys_mknod
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
specifier|register
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_mknod_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
modifier|*
name|retval
init|=
name|td
operator|->
name|td_retval
decl_stmt|;
return|return
name|svr4_mknod
argument_list|(
name|td
argument_list|,
name|retval
argument_list|,
name|uap
operator|->
name|path
argument_list|,
name|uap
operator|->
name|mode
argument_list|,
operator|(
name|svr4_dev_t
operator|)
name|svr4_to_bsd_odev_t
argument_list|(
name|uap
operator|->
name|dev
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_xmknod
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_xmknod_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
modifier|*
name|retval
init|=
name|td
operator|->
name|td_retval
decl_stmt|;
return|return
name|svr4_mknod
argument_list|(
name|td
argument_list|,
name|retval
argument_list|,
name|uap
operator|->
name|path
argument_list|,
name|uap
operator|->
name|mode
argument_list|,
operator|(
name|svr4_dev_t
operator|)
name|svr4_to_bsd_dev_t
argument_list|(
name|uap
operator|->
name|dev
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_vhangup
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_vhangup_args
modifier|*
name|uap
decl_stmt|;
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_sysconfig
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_sysconfig_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
modifier|*
name|retval
decl_stmt|;
name|retval
operator|=
operator|&
operator|(
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|)
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|name
condition|)
block|{
case|case
name|SVR4_CONFIG_UNUSED
case|:
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SVR4_CONFIG_NGROUPS
case|:
operator|*
name|retval
operator|=
name|NGROUPS_MAX
expr_stmt|;
break|break;
case|case
name|SVR4_CONFIG_CHILD_MAX
case|:
operator|*
name|retval
operator|=
name|maxproc
expr_stmt|;
break|break;
case|case
name|SVR4_CONFIG_OPEN_FILES
case|:
operator|*
name|retval
operator|=
name|maxfiles
expr_stmt|;
break|break;
case|case
name|SVR4_CONFIG_POSIX_VER
case|:
operator|*
name|retval
operator|=
literal|198808
expr_stmt|;
break|break;
case|case
name|SVR4_CONFIG_PAGESIZE
case|:
operator|*
name|retval
operator|=
name|PAGE_SIZE
expr_stmt|;
break|break;
case|case
name|SVR4_CONFIG_CLK_TCK
case|:
operator|*
name|retval
operator|=
literal|60
expr_stmt|;
comment|/* should this be `hz', ie. 100? */
break|break;
case|case
name|SVR4_CONFIG_XOPEN_VER
case|:
operator|*
name|retval
operator|=
literal|2
expr_stmt|;
comment|/* XXX: What should that be? */
break|break;
case|case
name|SVR4_CONFIG_PROF_TCK
case|:
operator|*
name|retval
operator|=
literal|60
expr_stmt|;
comment|/* XXX: What should that be? */
break|break;
case|case
name|SVR4_CONFIG_NPROC_CONF
case|:
operator|*
name|retval
operator|=
literal|1
expr_stmt|;
comment|/* Only one processor for now */
break|break;
case|case
name|SVR4_CONFIG_NPROC_ONLN
case|:
operator|*
name|retval
operator|=
literal|1
expr_stmt|;
comment|/* And it better be online */
break|break;
case|case
name|SVR4_CONFIG_AIO_LISTIO_MAX
case|:
case|case
name|SVR4_CONFIG_AIO_MAX
case|:
case|case
name|SVR4_CONFIG_AIO_PRIO_DELTA_MAX
case|:
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
comment|/* No aio support */
break|break;
case|case
name|SVR4_CONFIG_DELAYTIMER_MAX
case|:
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
comment|/* No delaytimer support */
break|break;
case|case
name|SVR4_CONFIG_MQ_OPEN_MAX
case|:
operator|*
name|retval
operator|=
name|msginfo
operator|.
name|msgmni
expr_stmt|;
break|break;
case|case
name|SVR4_CONFIG_MQ_PRIO_MAX
case|:
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
comment|/* XXX: Don't know */
break|break;
case|case
name|SVR4_CONFIG_RTSIG_MAX
case|:
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SVR4_CONFIG_SEM_NSEMS_MAX
case|:
operator|*
name|retval
operator|=
name|seminfo
operator|.
name|semmni
expr_stmt|;
break|break;
case|case
name|SVR4_CONFIG_SEM_VALUE_MAX
case|:
operator|*
name|retval
operator|=
name|seminfo
operator|.
name|semvmx
expr_stmt|;
break|break;
case|case
name|SVR4_CONFIG_SIGQUEUE_MAX
case|:
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
comment|/* XXX: Don't know */
break|break;
case|case
name|SVR4_CONFIG_SIGRT_MIN
case|:
case|case
name|SVR4_CONFIG_SIGRT_MAX
case|:
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
comment|/* No real time signals */
break|break;
case|case
name|SVR4_CONFIG_TIMER_MAX
case|:
operator|*
name|retval
operator|=
literal|3
expr_stmt|;
comment|/* XXX: real, virtual, profiling */
break|break;
if|#
directive|if
name|defined
argument_list|(
name|NOTYET
argument_list|)
case|case
name|SVR4_CONFIG_PHYS_PAGES
case|:
if|#
directive|if
name|defined
argument_list|(
name|UVM
argument_list|)
operator|*
name|retval
operator|=
name|uvmexp
operator|.
name|free
expr_stmt|;
comment|/* XXX: free instead of total */
else|#
directive|else
operator|*
name|retval
operator|=
name|cnt
operator|.
name|v_free_count
expr_stmt|;
comment|/* XXX: free instead of total */
endif|#
directive|endif
break|break;
case|case
name|SVR4_CONFIG_AVPHYS_PAGES
case|:
if|#
directive|if
name|defined
argument_list|(
name|UVM
argument_list|)
operator|*
name|retval
operator|=
name|uvmexp
operator|.
name|active
expr_stmt|;
comment|/* XXX: active instead of avg */
else|#
directive|else
operator|*
name|retval
operator|=
name|cnt
operator|.
name|v_active_count
expr_stmt|;
comment|/* XXX: active instead of avg */
endif|#
directive|endif
break|break;
endif|#
directive|endif
comment|/* NOTYET */
default|default:
return|return
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|svr4_sys_break
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_break_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|struct
name|vmspace
modifier|*
name|vm
init|=
name|p
operator|->
name|p_vmspace
decl_stmt|;
name|vm_offset_t
name|new
decl_stmt|,
name|old
decl_stmt|,
name|base
decl_stmt|,
name|ns
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|base
operator|=
name|round_page
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vm
operator|->
name|vm_daddr
argument_list|)
expr_stmt|;
name|ns
operator|=
operator|(
name|vm_offset_t
operator|)
name|uap
operator|->
name|nsize
expr_stmt|;
name|new
operator|=
name|round_page
argument_list|(
name|ns
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|>
name|base
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|-
name|base
operator|)
operator|>
operator|(
name|unsigned
operator|)
name|lim_cur
argument_list|(
name|p
argument_list|,
name|RLIMIT_DATA
argument_list|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|>=
name|VM_MAXUSER_ADDRESS
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|new
operator|<
name|base
condition|)
block|{
comment|/* 		 * This is simply an invalid value.  If someone wants to 		 * do fancy address space manipulations, mmap and munmap 		 * can do most of what the user would want. 		 */
return|return
name|EINVAL
return|;
block|}
name|old
operator|=
name|base
operator|+
name|ctob
argument_list|(
name|vm
operator|->
name|vm_dsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|>
name|old
condition|)
block|{
name|vm_size_t
name|diff
decl_stmt|;
name|diff
operator|=
name|new
operator|-
name|old
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|vm
operator|->
name|vm_map
operator|.
name|size
operator|+
name|diff
operator|>
name|lim_cur
argument_list|(
name|p
argument_list|,
name|RLIMIT_VMEM
argument_list|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|rv
operator|=
name|vm_map_find
argument_list|(
operator|&
name|vm
operator|->
name|vm_map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|old
argument_list|,
name|diff
argument_list|,
name|FALSE
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|vm
operator|->
name|vm_dsize
operator|+=
name|btoc
argument_list|(
name|diff
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new
operator|<
name|old
condition|)
block|{
name|rv
operator|=
name|vm_map_remove
argument_list|(
operator|&
name|vm
operator|->
name|vm_map
argument_list|,
name|new
argument_list|,
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|KERN_SUCCESS
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|vm
operator|->
name|vm_dsize
operator|-=
name|btoc
argument_list|(
name|old
operator|-
name|new
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|clock_t
name|timeval_to_clock_t
parameter_list|(
name|tv
parameter_list|)
name|struct
name|timeval
modifier|*
name|tv
decl_stmt|;
block|{
return|return
name|tv
operator|->
name|tv_sec
operator|*
name|hz
operator|+
name|tv
operator|->
name|tv_usec
operator|/
operator|(
literal|1000000
operator|/
name|hz
operator|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_times
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_times_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|,
modifier|*
name|retval
init|=
name|td
operator|->
name|td_retval
decl_stmt|;
name|struct
name|tms
name|tms
decl_stmt|;
name|struct
name|timeval
name|t
decl_stmt|;
name|struct
name|rusage
modifier|*
name|ru
decl_stmt|;
name|struct
name|rusage
name|r
decl_stmt|;
name|struct
name|getrusage_args
name|ga
decl_stmt|;
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
name|ru
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rusage
argument_list|)
argument_list|)
expr_stmt|;
name|ga
operator|.
name|who
operator|=
name|RUSAGE_SELF
expr_stmt|;
name|ga
operator|.
name|rusage
operator|=
name|ru
expr_stmt|;
name|error
operator|=
name|getrusage
argument_list|(
name|td
argument_list|,
operator|&
name|ga
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|ru
argument_list|,
operator|&
name|r
argument_list|,
sizeof|sizeof
name|r
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|tms
operator|.
name|tms_utime
operator|=
name|timeval_to_clock_t
argument_list|(
operator|&
name|r
operator|.
name|ru_utime
argument_list|)
expr_stmt|;
name|tms
operator|.
name|tms_stime
operator|=
name|timeval_to_clock_t
argument_list|(
operator|&
name|r
operator|.
name|ru_stime
argument_list|)
expr_stmt|;
name|ga
operator|.
name|who
operator|=
name|RUSAGE_CHILDREN
expr_stmt|;
name|error
operator|=
name|getrusage
argument_list|(
name|td
argument_list|,
operator|&
name|ga
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|ru
argument_list|,
operator|&
name|r
argument_list|,
sizeof|sizeof
name|r
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|tms
operator|.
name|tms_cutime
operator|=
name|timeval_to_clock_t
argument_list|(
operator|&
name|r
operator|.
name|ru_utime
argument_list|)
expr_stmt|;
name|tms
operator|.
name|tms_cstime
operator|=
name|timeval_to_clock_t
argument_list|(
operator|&
name|r
operator|.
name|ru_stime
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
operator|*
name|retval
operator|=
name|timeval_to_clock_t
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|tms
argument_list|,
name|uap
operator|->
name|tp
argument_list|,
sizeof|sizeof
argument_list|(
name|tms
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_ulimit
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_ulimit_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
modifier|*
name|retval
init|=
name|td
operator|->
name|td_retval
decl_stmt|;
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
name|SVR4_GFILLIM
case|:
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
operator|*
name|retval
operator|=
name|lim_cur
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|RLIMIT_FSIZE
argument_list|)
operator|/
literal|512
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|retval
operator|==
operator|-
literal|1
condition|)
operator|*
name|retval
operator|=
literal|0x7fffffff
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SVR4_SFILLIM
case|:
block|{
name|struct
name|rlimit
name|krl
decl_stmt|;
name|krl
operator|.
name|rlim_cur
operator|=
name|uap
operator|->
name|newlimit
operator|*
literal|512
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|krl
operator|.
name|rlim_max
operator|=
name|lim_max
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|RLIMIT_FSIZE
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|error
operator|=
name|kern_setrlimit
argument_list|(
name|td
argument_list|,
name|RLIMIT_FSIZE
argument_list|,
operator|&
name|krl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
operator|*
name|retval
operator|=
name|lim_cur
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|RLIMIT_FSIZE
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|retval
operator|==
operator|-
literal|1
condition|)
operator|*
name|retval
operator|=
literal|0x7fffffff
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|SVR4_GMEMLIM
case|:
block|{
name|struct
name|vmspace
modifier|*
name|vm
init|=
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
decl_stmt|;
name|register_t
name|r
decl_stmt|;
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|r
operator|=
name|lim_cur
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|RLIMIT_DATA
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
operator|-
literal|1
condition|)
name|r
operator|=
literal|0x7fffffff
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
comment|/* XXX */
name|r
operator|+=
operator|(
name|long
operator|)
name|vm
operator|->
name|vm_daddr
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
name|r
operator|=
literal|0x7fffffff
expr_stmt|;
operator|*
name|retval
operator|=
name|r
expr_stmt|;
return|return
literal|0
return|;
block|}
case|case
name|SVR4_GDESLIM
case|:
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
operator|*
name|retval
operator|=
name|lim_cur
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|RLIMIT_NOFILE
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|retval
operator|==
operator|-
literal|1
condition|)
operator|*
name|retval
operator|=
literal|0x7fffffff
expr_stmt|;
return|return
literal|0
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|proc
modifier|*
name|svr4_pfind
parameter_list|(
name|pid
parameter_list|)
name|pid_t
name|pid
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
comment|/* look in the live processes */
if|if
condition|(
operator|(
name|p
operator|=
name|pfind
argument_list|(
name|pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* look in the zombies */
name|p
operator|=
name|zpfind
argument_list|(
name|pid
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_pgrpsys
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_pgrpsys_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
modifier|*
name|retval
init|=
name|td
operator|->
name|td_retval
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
literal|1
case|:
comment|/* setpgrp() */
comment|/* 		 * SVR4 setpgrp() (which takes no arguments) has the 		 * semantics that the session ID is also created anew, so 		 * in almost every sense, setpgrp() is identical to 		 * setsid() for SVR4.  (Under BSD, the difference is that 		 * a setpgid(0,0) will not create a new session.) 		 */
name|setsid
argument_list|(
name|td
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
literal|0
case|:
comment|/* getpgrp() */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|retval
operator|=
name|p
operator|->
name|p_pgrp
operator|->
name|pg_id
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|2
case|:
comment|/* getsid(pid) */
if|if
condition|(
name|uap
operator|->
name|pid
operator|==
literal|0
condition|)
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|p
operator|=
name|svr4_pfind
argument_list|(
name|uap
operator|->
name|pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ESRCH
return|;
comment|/* 		 * This has already been initialized to the pid of 		 * the session leader. 		 */
operator|*
name|retval
operator|=
operator|(
name|register_t
operator|)
name|p
operator|->
name|p_session
operator|->
name|s_sid
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|3
case|:
comment|/* setsid() */
return|return
name|setsid
argument_list|(
name|td
argument_list|,
name|NULL
argument_list|)
return|;
case|case
literal|4
case|:
comment|/* getpgid(pid) */
if|if
condition|(
name|uap
operator|->
name|pid
operator|==
literal|0
condition|)
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|p
operator|=
name|svr4_pfind
argument_list|(
name|uap
operator|->
name|pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ESRCH
return|;
operator|*
name|retval
operator|=
operator|(
name|int
operator|)
name|p
operator|->
name|p_pgrp
operator|->
name|pg_id
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|5
case|:
comment|/* setpgid(pid, pgid); */
block|{
name|struct
name|setpgid_args
name|sa
decl_stmt|;
name|sa
operator|.
name|pid
operator|=
name|uap
operator|->
name|pid
expr_stmt|;
name|sa
operator|.
name|pgid
operator|=
name|uap
operator|->
name|pgid
expr_stmt|;
return|return
name|setpgid
argument_list|(
name|td
argument_list|,
operator|&
name|sa
argument_list|)
return|;
block|}
default|default:
return|return
name|EINVAL
return|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|syscallarg
parameter_list|(
name|x
parameter_list|)
value|union { x datum; register_t pad; }
end_define

begin_struct
struct|struct
name|svr4_hrtcntl_args
block|{
name|int
name|cmd
decl_stmt|;
name|int
name|fun
decl_stmt|;
name|int
name|clk
decl_stmt|;
name|svr4_hrt_interval_t
modifier|*
name|iv
decl_stmt|;
name|svr4_hrt_time_t
modifier|*
name|ti
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|svr4_hrtcntl
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|,
name|retval
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_hrtcntl_args
modifier|*
name|uap
decl_stmt|;
name|register_t
modifier|*
name|retval
decl_stmt|;
block|{
switch|switch
condition|(
name|uap
operator|->
name|fun
condition|)
block|{
case|case
name|SVR4_HRT_CNTL_RES
case|:
name|DPRINTF
argument_list|(
operator|(
literal|"htrcntl(RES)\n"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|retval
operator|=
name|SVR4_HRT_USEC
expr_stmt|;
return|return
literal|0
return|;
case|case
name|SVR4_HRT_CNTL_TOFD
case|:
name|DPRINTF
argument_list|(
operator|(
literal|"htrcntl(TOFD)\n"
operator|)
argument_list|)
expr_stmt|;
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|svr4_hrt_time_t
name|t
decl_stmt|;
if|if
condition|(
name|uap
operator|->
name|clk
operator|!=
name|SVR4_HRT_CLK_STD
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"clk == %d\n"
operator|,
name|uap
operator|->
name|clk
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|uap
operator|->
name|ti
operator|==
name|NULL
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"ti NULL\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|t
operator|.
name|h_sec
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|t
operator|.
name|h_rem
operator|=
name|tv
operator|.
name|tv_usec
expr_stmt|;
name|t
operator|.
name|h_res
operator|=
name|SVR4_HRT_USEC
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|t
argument_list|,
name|uap
operator|->
name|ti
argument_list|,
sizeof|sizeof
argument_list|(
name|t
argument_list|)
argument_list|)
return|;
block|}
case|case
name|SVR4_HRT_CNTL_START
case|:
name|DPRINTF
argument_list|(
operator|(
literal|"htrcntl(START)\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENOSYS
return|;
case|case
name|SVR4_HRT_CNTL_GET
case|:
name|DPRINTF
argument_list|(
operator|(
literal|"htrcntl(GET)\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENOSYS
return|;
default|default:
name|DPRINTF
argument_list|(
operator|(
literal|"Bad htrcntl command %d\n"
operator|,
name|uap
operator|->
name|fun
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENOSYS
return|;
block|}
block|}
end_function

begin_function
name|int
name|svr4_sys_hrtsys
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_hrtsys_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
modifier|*
name|retval
init|=
name|td
operator|->
name|td_retval
decl_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
name|SVR4_HRT_CNTL
case|:
return|return
name|svr4_hrtcntl
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|svr4_hrtcntl_args
operator|*
operator|)
name|uap
argument_list|,
name|retval
argument_list|)
return|;
case|case
name|SVR4_HRT_ALRM
case|:
name|DPRINTF
argument_list|(
operator|(
literal|"hrtalarm\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENOSYS
return|;
case|case
name|SVR4_HRT_SLP
case|:
name|DPRINTF
argument_list|(
operator|(
literal|"hrtsleep\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENOSYS
return|;
case|case
name|SVR4_HRT_CAN
case|:
name|DPRINTF
argument_list|(
operator|(
literal|"hrtcancel\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|ENOSYS
return|;
default|default:
name|DPRINTF
argument_list|(
operator|(
literal|"Bad hrtsys command %d\n"
operator|,
name|uap
operator|->
name|cmd
operator|)
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|svr4_setinfo
parameter_list|(
name|p
parameter_list|,
name|st
parameter_list|,
name|s
parameter_list|)
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|st
decl_stmt|;
name|svr4_siginfo_t
modifier|*
name|s
decl_stmt|;
block|{
name|svr4_siginfo_t
name|i
decl_stmt|;
name|int
name|sig
decl_stmt|;
name|memset
argument_list|(
operator|&
name|i
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|.
name|si_signo
operator|=
name|SVR4_SIGCHLD
expr_stmt|;
name|i
operator|.
name|si_errno
operator|=
literal|0
expr_stmt|;
comment|/* XXX? */
if|if
condition|(
name|p
condition|)
block|{
name|i
operator|.
name|si_pid
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_state
operator|==
name|PRS_ZOMBIE
condition|)
block|{
name|i
operator|.
name|si_stime
operator|=
name|p
operator|->
name|p_ru
operator|->
name|ru_stime
operator|.
name|tv_sec
expr_stmt|;
name|i
operator|.
name|si_utime
operator|=
name|p
operator|->
name|p_ru
operator|->
name|ru_utime
operator|.
name|tv_sec
expr_stmt|;
block|}
else|else
block|{
name|i
operator|.
name|si_stime
operator|=
name|p
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_stime
operator|.
name|tv_sec
expr_stmt|;
name|i
operator|.
name|si_utime
operator|=
name|p
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_utime
operator|.
name|tv_sec
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|WIFEXITED
argument_list|(
name|st
argument_list|)
condition|)
block|{
name|i
operator|.
name|si_status
operator|=
name|WEXITSTATUS
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|i
operator|.
name|si_code
operator|=
name|SVR4_CLD_EXITED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|WIFSTOPPED
argument_list|(
name|st
argument_list|)
condition|)
block|{
name|sig
operator|=
name|WSTOPSIG
argument_list|(
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|>=
literal|0
operator|&&
name|sig
operator|<
name|NSIG
condition|)
name|i
operator|.
name|si_status
operator|=
name|SVR4_BSD2SVR4_SIG
argument_list|(
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|.
name|si_status
operator|==
name|SVR4_SIGCONT
condition|)
name|i
operator|.
name|si_code
operator|=
name|SVR4_CLD_CONTINUED
expr_stmt|;
else|else
name|i
operator|.
name|si_code
operator|=
name|SVR4_CLD_STOPPED
expr_stmt|;
block|}
else|else
block|{
name|sig
operator|=
name|WTERMSIG
argument_list|(
name|st
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|>=
literal|0
operator|&&
name|sig
operator|<
name|NSIG
condition|)
name|i
operator|.
name|si_status
operator|=
name|SVR4_BSD2SVR4_SIG
argument_list|(
name|sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|WCOREDUMP
argument_list|(
name|st
argument_list|)
condition|)
name|i
operator|.
name|si_code
operator|=
name|SVR4_CLD_DUMPED
expr_stmt|;
else|else
name|i
operator|.
name|si_code
operator|=
name|SVR4_CLD_KILLED
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"siginfo [pid %ld signo %d code %d errno %d status %d]\n"
operator|,
name|i
operator|.
name|si_pid
operator|,
name|i
operator|.
name|si_signo
operator|,
name|i
operator|.
name|si_code
operator|,
name|i
operator|.
name|si_errno
operator|,
name|i
operator|.
name|si_status
operator|)
argument_list|)
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|i
argument_list|,
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|i
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_waitsys
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_waitsys_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|nfound
decl_stmt|;
name|int
name|error
decl_stmt|,
modifier|*
name|retval
init|=
name|td
operator|->
name|td_retval
decl_stmt|;
name|struct
name|proc
modifier|*
name|q
decl_stmt|,
modifier|*
name|t
decl_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|grp
condition|)
block|{
case|case
name|SVR4_P_PID
case|:
break|break;
case|case
name|SVR4_P_PGID
case|:
name|PROC_LOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|uap
operator|->
name|id
operator|=
operator|-
name|td
operator|->
name|td_proc
operator|->
name|p_pgid
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|td
operator|->
name|td_proc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVR4_P_ALL
case|:
name|uap
operator|->
name|id
operator|=
name|WAIT_ANY
expr_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
name|DPRINTF
argument_list|(
operator|(
literal|"waitsys(%d, %d, %p, %x)\n"
operator|,
name|uap
operator|->
name|grp
operator|,
name|uap
operator|->
name|id
operator|,
name|uap
operator|->
name|info
operator|,
name|uap
operator|->
name|options
operator|)
argument_list|)
expr_stmt|;
name|loop
label|:
name|nfound
operator|=
literal|0
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|q
argument_list|,
argument|&td->td_proc->p_children
argument_list|,
argument|p_sibling
argument_list|)
block|{
name|PROC_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|uap
operator|->
name|id
operator|!=
name|WAIT_ANY
operator|&&
name|q
operator|->
name|p_pid
operator|!=
name|uap
operator|->
name|id
operator|&&
name|q
operator|->
name|p_pgid
operator|!=
operator|-
name|uap
operator|->
name|id
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"pid %d pgid %d != %d\n"
operator|,
name|q
operator|->
name|p_pid
operator|,
name|q
operator|->
name|p_pgid
operator|,
name|uap
operator|->
name|id
operator|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nfound
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|q
operator|->
name|p_state
operator|==
name|PRS_ZOMBIE
operator|)
operator|&&
operator|(
operator|(
name|uap
operator|->
name|options
operator|&
operator|(
name|SVR4_WEXITED
operator||
name|SVR4_WTRAPPED
operator|)
operator|)
operator|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
operator|(
literal|"found %d\n"
operator|,
name|q
operator|->
name|p_pid
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|svr4_setinfo
argument_list|(
name|q
argument_list|,
name|q
operator|->
name|p_xstat
argument_list|,
name|uap
operator|->
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|uap
operator|->
name|options
operator|&
name|SVR4_WNOWAIT
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"Don't wait\n"
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 			 * If we got the child via ptrace(2) or procfs, and 			 * the parent is different (meaning the process was 			 * attached, rather than run as a child), then we need 			 * to give it back to the old parent, and send the 			 * parent a SIGCHLD.  The rest of the cleanup will be 			 * done when the old parent waits on the child. 			 */
name|sx_xlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|p_flag
operator|&
name|P_TRACED
condition|)
block|{
if|if
condition|(
name|q
operator|->
name|p_oppid
operator|!=
name|q
operator|->
name|p_pptr
operator|->
name|p_pid
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|t
operator|=
name|pfind
argument_list|(
name|q
operator|->
name|p_oppid
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
name|t
operator|=
name|initproc
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|initproc
argument_list|)
expr_stmt|;
block|}
name|PROC_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|proc_reparent
argument_list|(
name|q
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|q
operator|->
name|p_oppid
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|p_flag
operator|&=
operator|~
operator|(
name|P_TRACED
operator||
name|P_WAITED
operator|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|t
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
name|wakeup
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|q
operator|->
name|p_xstat
operator|=
literal|0
expr_stmt|;
name|ruadd
argument_list|(
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_stats
operator|->
name|p_cru
argument_list|,
name|q
operator|->
name|p_ru
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|q
operator|->
name|p_ru
argument_list|,
name|M_ZOMBIE
argument_list|)
expr_stmt|;
name|q
operator|->
name|p_ru
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Decrement the count of procs running with this uid. 			 */
operator|(
name|void
operator|)
name|chgproccnt
argument_list|(
name|q
operator|->
name|p_ucred
operator|->
name|cr_ruidinfo
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * Release reference to text vnode. 			 */
if|if
condition|(
name|q
operator|->
name|p_textvp
condition|)
name|vrele
argument_list|(
name|q
operator|->
name|p_textvp
argument_list|)
expr_stmt|;
comment|/* 			 * Free up credentials. 			 */
name|crfree
argument_list|(
name|q
operator|->
name|p_ucred
argument_list|)
expr_stmt|;
name|q
operator|->
name|p_ucred
operator|=
name|NULL
expr_stmt|;
comment|/* 			 * Remove unused arguments 			 */
name|pargs_drop
argument_list|(
name|q
operator|->
name|p_args
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* 			 * Finally finished with old proc entry. 			 * Unlink it from its process group and free it. 			 */
name|sx_xlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|leavepgrp
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|q
argument_list|,
name|p_list
argument_list|)
expr_stmt|;
comment|/* off zombproc */
name|sx_xunlock
argument_list|(
operator|&
name|allproc_lock
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|q
argument_list|,
name|p_sibling
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|sigacts_free
argument_list|(
name|q
operator|->
name|p_sigacts
argument_list|)
expr_stmt|;
name|q
operator|->
name|p_sigacts
operator|=
name|NULL
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
comment|/* 			 * Give machine-dependent layer a chance 			 * to free anything that cpu_exit couldn't 			 * release while still running in process context. 			 */
name|vm_waitproc
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
name|pool_put
argument_list|(
operator|&
name|proc_pool
argument_list|,
name|q
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__FreeBSD__
name|mtx_destroy
argument_list|(
operator|&
name|q
operator|->
name|p_mtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_destroy_proc
argument_list|(
name|q
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|uma_zfree
argument_list|(
name|proc_zone
argument_list|,
name|q
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nprocs
operator|--
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* XXXKSE this needs clarification */
if|if
condition|(
name|P_SHOULDSTOP
argument_list|(
name|q
argument_list|)
operator|&&
operator|(
operator|(
name|q
operator|->
name|p_flag
operator|&
name|P_WAITED
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|q
operator|->
name|p_flag
operator|&
name|P_TRACED
operator|||
operator|(
name|uap
operator|->
name|options
operator|&
operator|(
name|SVR4_WSTOPPED
operator||
name|SVR4_WCONTINUED
operator|)
operator|)
operator|)
condition|)
block|{
name|DPRINTF
argument_list|(
operator|(
literal|"jobcontrol %d\n"
operator|,
name|q
operator|->
name|p_pid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|uap
operator|->
name|options
operator|&
name|SVR4_WNOWAIT
operator|)
operator|)
operator|==
literal|0
condition|)
name|q
operator|->
name|p_flag
operator||=
name|P_WAITED
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
return|return
name|svr4_setinfo
argument_list|(
name|q
argument_list|,
name|W_STOPCODE
argument_list|(
name|q
operator|->
name|p_xstat
argument_list|)
argument_list|,
name|uap
operator|->
name|info
argument_list|)
return|;
block|}
name|PROC_UNLOCK
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nfound
operator|==
literal|0
condition|)
return|return
name|ECHILD
return|;
if|if
condition|(
name|uap
operator|->
name|options
operator|&
name|SVR4_WNOHANG
condition|)
block|{
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|svr4_setinfo
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|uap
operator|->
name|info
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|tsleep
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|PWAIT
operator||
name|PCATCH
argument_list|,
literal|"svr4_wait"
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
goto|goto
name|loop
goto|;
block|}
end_function

begin_function
specifier|static
name|void
name|bsd_statfs_to_svr4_statvfs
parameter_list|(
name|bfs
parameter_list|,
name|sfs
parameter_list|)
specifier|const
name|struct
name|statfs
modifier|*
name|bfs
decl_stmt|;
name|struct
name|svr4_statvfs
modifier|*
name|sfs
decl_stmt|;
block|{
name|sfs
operator|->
name|f_bsize
operator|=
name|bfs
operator|->
name|f_iosize
expr_stmt|;
comment|/* XXX */
name|sfs
operator|->
name|f_frsize
operator|=
name|bfs
operator|->
name|f_bsize
expr_stmt|;
name|sfs
operator|->
name|f_blocks
operator|=
name|bfs
operator|->
name|f_blocks
expr_stmt|;
name|sfs
operator|->
name|f_bfree
operator|=
name|bfs
operator|->
name|f_bfree
expr_stmt|;
name|sfs
operator|->
name|f_bavail
operator|=
name|bfs
operator|->
name|f_bavail
expr_stmt|;
name|sfs
operator|->
name|f_files
operator|=
name|bfs
operator|->
name|f_files
expr_stmt|;
name|sfs
operator|->
name|f_ffree
operator|=
name|bfs
operator|->
name|f_ffree
expr_stmt|;
name|sfs
operator|->
name|f_favail
operator|=
name|bfs
operator|->
name|f_ffree
expr_stmt|;
name|sfs
operator|->
name|f_fsid
operator|=
name|bfs
operator|->
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|sfs
operator|->
name|f_basetype
argument_list|,
name|bfs
operator|->
name|f_fstypename
argument_list|,
sizeof|sizeof
argument_list|(
name|sfs
operator|->
name|f_basetype
argument_list|)
argument_list|)
expr_stmt|;
name|sfs
operator|->
name|f_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfs
operator|->
name|f_flags
operator|&
name|MNT_RDONLY
condition|)
name|sfs
operator|->
name|f_flag
operator||=
name|SVR4_ST_RDONLY
expr_stmt|;
if|if
condition|(
name|bfs
operator|->
name|f_flags
operator|&
name|MNT_NOSUID
condition|)
name|sfs
operator|->
name|f_flag
operator||=
name|SVR4_ST_NOSUID
expr_stmt|;
name|sfs
operator|->
name|f_namemax
operator|=
name|MAXNAMLEN
expr_stmt|;
name|memcpy
argument_list|(
name|sfs
operator|->
name|f_fstr
argument_list|,
name|bfs
operator|->
name|f_fstypename
argument_list|,
sizeof|sizeof
argument_list|(
name|sfs
operator|->
name|f_fstr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX */
name|memset
argument_list|(
name|sfs
operator|->
name|f_filler
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sfs
operator|->
name|f_filler
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bsd_statfs_to_svr4_statvfs64
parameter_list|(
name|bfs
parameter_list|,
name|sfs
parameter_list|)
specifier|const
name|struct
name|statfs
modifier|*
name|bfs
decl_stmt|;
name|struct
name|svr4_statvfs64
modifier|*
name|sfs
decl_stmt|;
block|{
name|sfs
operator|->
name|f_bsize
operator|=
name|bfs
operator|->
name|f_iosize
expr_stmt|;
comment|/* XXX */
name|sfs
operator|->
name|f_frsize
operator|=
name|bfs
operator|->
name|f_bsize
expr_stmt|;
name|sfs
operator|->
name|f_blocks
operator|=
name|bfs
operator|->
name|f_blocks
expr_stmt|;
name|sfs
operator|->
name|f_bfree
operator|=
name|bfs
operator|->
name|f_bfree
expr_stmt|;
name|sfs
operator|->
name|f_bavail
operator|=
name|bfs
operator|->
name|f_bavail
expr_stmt|;
name|sfs
operator|->
name|f_files
operator|=
name|bfs
operator|->
name|f_files
expr_stmt|;
name|sfs
operator|->
name|f_ffree
operator|=
name|bfs
operator|->
name|f_ffree
expr_stmt|;
name|sfs
operator|->
name|f_favail
operator|=
name|bfs
operator|->
name|f_ffree
expr_stmt|;
name|sfs
operator|->
name|f_fsid
operator|=
name|bfs
operator|->
name|f_fsid
operator|.
name|val
index|[
literal|0
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|sfs
operator|->
name|f_basetype
argument_list|,
name|bfs
operator|->
name|f_fstypename
argument_list|,
sizeof|sizeof
argument_list|(
name|sfs
operator|->
name|f_basetype
argument_list|)
argument_list|)
expr_stmt|;
name|sfs
operator|->
name|f_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bfs
operator|->
name|f_flags
operator|&
name|MNT_RDONLY
condition|)
name|sfs
operator|->
name|f_flag
operator||=
name|SVR4_ST_RDONLY
expr_stmt|;
if|if
condition|(
name|bfs
operator|->
name|f_flags
operator|&
name|MNT_NOSUID
condition|)
name|sfs
operator|->
name|f_flag
operator||=
name|SVR4_ST_NOSUID
expr_stmt|;
name|sfs
operator|->
name|f_namemax
operator|=
name|MAXNAMLEN
expr_stmt|;
name|memcpy
argument_list|(
name|sfs
operator|->
name|f_fstr
argument_list|,
name|bfs
operator|->
name|f_fstypename
argument_list|,
sizeof|sizeof
argument_list|(
name|sfs
operator|->
name|f_fstr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX */
name|memset
argument_list|(
name|sfs
operator|->
name|f_filler
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sfs
operator|->
name|f_filler
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|svr4_sys_statvfs
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_statvfs_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|statfs_args
name|fs_args
decl_stmt|;
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
name|struct
name|statfs
modifier|*
name|fs
init|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|statfs
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|statfs
name|bfs
decl_stmt|;
name|struct
name|svr4_statvfs
name|sfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
operator|&
name|sg
argument_list|,
name|uap
operator|->
name|path
argument_list|)
expr_stmt|;
name|fs_args
operator|.
name|path
operator|=
name|uap
operator|->
name|path
expr_stmt|;
name|fs_args
operator|.
name|buf
operator|=
name|fs
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|statfs
argument_list|(
name|td
argument_list|,
operator|&
name|fs_args
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|fs
argument_list|,
operator|&
name|bfs
argument_list|,
sizeof|sizeof
argument_list|(
name|bfs
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|bsd_statfs_to_svr4_statvfs
argument_list|(
operator|&
name|bfs
argument_list|,
operator|&
name|sfs
argument_list|)
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|sfs
argument_list|,
name|uap
operator|->
name|fs
argument_list|,
sizeof|sizeof
argument_list|(
name|sfs
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_fstatvfs
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_fstatvfs_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|fstatfs_args
name|fs_args
decl_stmt|;
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
name|struct
name|statfs
modifier|*
name|fs
init|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|statfs
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|statfs
name|bfs
decl_stmt|;
name|struct
name|svr4_statvfs
name|sfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fs_args
operator|.
name|fd
operator|=
name|uap
operator|->
name|fd
expr_stmt|;
name|fs_args
operator|.
name|buf
operator|=
name|fs
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fstatfs
argument_list|(
name|td
argument_list|,
operator|&
name|fs_args
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|fs
argument_list|,
operator|&
name|bfs
argument_list|,
sizeof|sizeof
argument_list|(
name|bfs
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|bsd_statfs_to_svr4_statvfs
argument_list|(
operator|&
name|bfs
argument_list|,
operator|&
name|sfs
argument_list|)
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|sfs
argument_list|,
name|uap
operator|->
name|fs
argument_list|,
sizeof|sizeof
argument_list|(
name|sfs
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_statvfs64
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_statvfs64_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|statfs_args
name|fs_args
decl_stmt|;
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
name|struct
name|statfs
modifier|*
name|fs
init|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|statfs
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|statfs
name|bfs
decl_stmt|;
name|struct
name|svr4_statvfs64
name|sfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|CHECKALTEXIST
argument_list|(
name|td
argument_list|,
operator|&
name|sg
argument_list|,
name|uap
operator|->
name|path
argument_list|)
expr_stmt|;
name|fs_args
operator|.
name|path
operator|=
name|uap
operator|->
name|path
expr_stmt|;
name|fs_args
operator|.
name|buf
operator|=
name|fs
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|statfs
argument_list|(
name|td
argument_list|,
operator|&
name|fs_args
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|fs
argument_list|,
operator|&
name|bfs
argument_list|,
sizeof|sizeof
argument_list|(
name|bfs
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|bsd_statfs_to_svr4_statvfs64
argument_list|(
operator|&
name|bfs
argument_list|,
operator|&
name|sfs
argument_list|)
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|sfs
argument_list|,
name|uap
operator|->
name|fs
argument_list|,
sizeof|sizeof
argument_list|(
name|sfs
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_fstatvfs64
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_fstatvfs64_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|fstatfs_args
name|fs_args
decl_stmt|;
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
name|struct
name|statfs
modifier|*
name|fs
init|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|statfs
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|statfs
name|bfs
decl_stmt|;
name|struct
name|svr4_statvfs64
name|sfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|fs_args
operator|.
name|fd
operator|=
name|uap
operator|->
name|fd
expr_stmt|;
name|fs_args
operator|.
name|buf
operator|=
name|fs
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|fstatfs
argument_list|(
name|td
argument_list|,
operator|&
name|fs_args
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|fs
argument_list|,
operator|&
name|bfs
argument_list|,
sizeof|sizeof
argument_list|(
name|bfs
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|bsd_statfs_to_svr4_statvfs64
argument_list|(
operator|&
name|bfs
argument_list|,
operator|&
name|sfs
argument_list|)
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|sfs
argument_list|,
name|uap
operator|->
name|fs
argument_list|,
sizeof|sizeof
argument_list|(
name|sfs
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_alarm
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_alarm_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|itimerval
modifier|*
name|itp
decl_stmt|,
modifier|*
name|oitp
decl_stmt|;
name|struct
name|setitimer_args
name|sa
decl_stmt|;
name|caddr_t
name|sg
init|=
name|stackgap_init
argument_list|()
decl_stmt|;
name|itp
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|itp
argument_list|)
argument_list|)
expr_stmt|;
name|oitp
operator|=
name|stackgap_alloc
argument_list|(
operator|&
name|sg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|oitp
argument_list|)
argument_list|)
expr_stmt|;
name|timevalclear
argument_list|(
operator|&
name|itp
operator|->
name|it_interval
argument_list|)
expr_stmt|;
name|itp
operator|->
name|it_value
operator|.
name|tv_sec
operator|=
name|uap
operator|->
name|sec
expr_stmt|;
name|itp
operator|->
name|it_value
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|sa
operator|.
name|which
operator|=
name|ITIMER_REAL
expr_stmt|;
name|sa
operator|.
name|itv
operator|=
name|itp
expr_stmt|;
name|sa
operator|.
name|oitv
operator|=
name|oitp
expr_stmt|;
name|error
operator|=
name|setitimer
argument_list|(
name|td
argument_list|,
operator|&
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|oitp
operator|->
name|it_value
operator|.
name|tv_usec
condition|)
name|oitp
operator|->
name|it_value
operator|.
name|tv_sec
operator|++
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
name|oitp
operator|->
name|it_value
operator|.
name|tv_sec
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_gettimeofday
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_gettimeofday_args
modifier|*
name|uap
decl_stmt|;
block|{
if|if
condition|(
name|uap
operator|->
name|tp
condition|)
block|{
name|struct
name|timeval
name|atv
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|atv
argument_list|)
expr_stmt|;
return|return
name|copyout
argument_list|(
operator|&
name|atv
argument_list|,
name|uap
operator|->
name|tp
argument_list|,
sizeof|sizeof
argument_list|(
name|atv
argument_list|)
argument_list|)
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_facl
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_facl_args
modifier|*
name|uap
decl_stmt|;
block|{
name|int
modifier|*
name|retval
decl_stmt|;
name|retval
operator|=
name|td
operator|->
name|td_retval
expr_stmt|;
operator|*
name|retval
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
name|SVR4_SYS_SETACL
case|:
comment|/* We don't support acls on any filesystem */
return|return
name|ENOSYS
return|;
case|case
name|SVR4_SYS_GETACL
case|:
return|return
name|copyout
argument_list|(
name|retval
argument_list|,
operator|&
name|uap
operator|->
name|num
argument_list|,
sizeof|sizeof
argument_list|(
name|uap
operator|->
name|num
argument_list|)
argument_list|)
return|;
case|case
name|SVR4_SYS_GETACLCNT
case|:
return|return
literal|0
return|;
default|default:
return|return
name|EINVAL
return|;
block|}
block|}
end_function

begin_function
name|int
name|svr4_sys_acl
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_acl_args
modifier|*
name|uap
decl_stmt|;
block|{
comment|/* XXX: for now the same */
return|return
name|svr4_sys_facl
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|svr4_sys_facl_args
operator|*
operator|)
name|uap
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_auditsys
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_auditsys_args
modifier|*
name|uap
decl_stmt|;
block|{
comment|/* 	 * XXX: Big brother is *not* watching. 	 */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_memcntl
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_memcntl_args
modifier|*
name|uap
decl_stmt|;
block|{
switch|switch
condition|(
name|uap
operator|->
name|cmd
condition|)
block|{
case|case
name|SVR4_MC_SYNC
case|:
block|{
name|struct
name|msync_args
name|msa
decl_stmt|;
name|msa
operator|.
name|addr
operator|=
name|uap
operator|->
name|addr
expr_stmt|;
name|msa
operator|.
name|len
operator|=
name|uap
operator|->
name|len
expr_stmt|;
name|msa
operator|.
name|flags
operator|=
operator|(
name|int
operator|)
name|uap
operator|->
name|arg
expr_stmt|;
return|return
name|msync
argument_list|(
name|td
argument_list|,
operator|&
name|msa
argument_list|)
return|;
block|}
case|case
name|SVR4_MC_ADVISE
case|:
block|{
name|struct
name|madvise_args
name|maa
decl_stmt|;
name|maa
operator|.
name|addr
operator|=
name|uap
operator|->
name|addr
expr_stmt|;
name|maa
operator|.
name|len
operator|=
name|uap
operator|->
name|len
expr_stmt|;
name|maa
operator|.
name|behav
operator|=
operator|(
name|int
operator|)
name|uap
operator|->
name|arg
expr_stmt|;
return|return
name|madvise
argument_list|(
name|td
argument_list|,
operator|&
name|maa
argument_list|)
return|;
block|}
case|case
name|SVR4_MC_LOCK
case|:
case|case
name|SVR4_MC_UNLOCK
case|:
case|case
name|SVR4_MC_LOCKAS
case|:
case|case
name|SVR4_MC_UNLOCKAS
case|:
return|return
name|EOPNOTSUPP
return|;
default|default:
return|return
name|ENOSYS
return|;
block|}
block|}
end_function

begin_function
name|int
name|svr4_sys_nice
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_nice_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|setpriority_args
name|ap
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ap
operator|.
name|which
operator|=
name|PRIO_PROCESS
expr_stmt|;
name|ap
operator|.
name|who
operator|=
literal|0
expr_stmt|;
name|ap
operator|.
name|prio
operator|=
name|uap
operator|->
name|prio
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|setpriority
argument_list|(
name|td
argument_list|,
operator|&
name|ap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* the cast is stupid, but the structures are the same */
if|if
condition|(
operator|(
name|error
operator|=
name|getpriority
argument_list|(
name|td
argument_list|,
operator|(
expr|struct
name|getpriority_args
operator|*
operator|)
operator|&
name|ap
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|svr4_sys_resolvepath
parameter_list|(
name|td
parameter_list|,
name|uap
parameter_list|)
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|struct
name|svr4_sys_resolvepath_args
modifier|*
name|uap
decl_stmt|;
block|{
name|struct
name|nameidata
name|nd
decl_stmt|;
name|int
name|error
decl_stmt|,
modifier|*
name|retval
init|=
name|td
operator|->
name|td_retval
decl_stmt|;
name|unsigned
name|int
name|ncopy
decl_stmt|;
name|NDINIT
argument_list|(
operator|&
name|nd
argument_list|,
name|LOOKUP
argument_list|,
name|NOFOLLOW
operator||
name|SAVENAME
argument_list|,
name|UIO_USERSPACE
argument_list|,
name|uap
operator|->
name|path
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|namei
argument_list|(
operator|&
name|nd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
name|ncopy
operator|=
name|min
argument_list|(
name|uap
operator|->
name|bufsiz
argument_list|,
name|strlen
argument_list|(
name|nd
operator|.
name|ni_cnd
operator|.
name|cn_pnbuf
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
name|nd
operator|.
name|ni_cnd
operator|.
name|cn_pnbuf
argument_list|,
name|uap
operator|->
name|buf
argument_list|,
name|ncopy
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
operator|*
name|retval
operator|=
name|ncopy
expr_stmt|;
name|bad
label|:
name|NDFREE
argument_list|(
operator|&
name|nd
argument_list|,
name|NDF_ONLY_PNBUF
argument_list|)
expr_stmt|;
name|vput
argument_list|(
name|nd
operator|.
name|ni_vp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

end_unit

