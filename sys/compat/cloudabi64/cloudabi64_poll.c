begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015 Nuxi, https://nuxi.nl/  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscallsubr.h>
end_include

begin_include
include|#
directive|include
file|<contrib/cloudabi/cloudabi64_types.h>
end_include

begin_include
include|#
directive|include
file|<compat/cloudabi/cloudabi_util.h>
end_include

begin_include
include|#
directive|include
file|<compat/cloudabi64/cloudabi64_proto.h>
end_include

begin_include
include|#
directive|include
file|<compat/cloudabi64/cloudabi64_util.h>
end_include

begin_comment
comment|/* Converts a FreeBSD signal number to a CloudABI signal number. */
end_comment

begin_function
specifier|static
name|cloudabi_signal_t
name|convert_signal
parameter_list|(
name|int
name|sig
parameter_list|)
block|{
specifier|static
specifier|const
name|cloudabi_signal_t
name|signals
index|[]
init|=
block|{
index|[
name|SIGABRT
index|]
operator|=
name|CLOUDABI_SIGABRT
block|,
index|[
name|SIGALRM
index|]
operator|=
name|CLOUDABI_SIGALRM
block|,
index|[
name|SIGBUS
index|]
operator|=
name|CLOUDABI_SIGBUS
block|,
index|[
name|SIGCHLD
index|]
operator|=
name|CLOUDABI_SIGCHLD
block|,
index|[
name|SIGCONT
index|]
operator|=
name|CLOUDABI_SIGCONT
block|,
index|[
name|SIGFPE
index|]
operator|=
name|CLOUDABI_SIGFPE
block|,
index|[
name|SIGHUP
index|]
operator|=
name|CLOUDABI_SIGHUP
block|,
index|[
name|SIGILL
index|]
operator|=
name|CLOUDABI_SIGILL
block|,
index|[
name|SIGINT
index|]
operator|=
name|CLOUDABI_SIGINT
block|,
index|[
name|SIGKILL
index|]
operator|=
name|CLOUDABI_SIGKILL
block|,
index|[
name|SIGPIPE
index|]
operator|=
name|CLOUDABI_SIGPIPE
block|,
index|[
name|SIGQUIT
index|]
operator|=
name|CLOUDABI_SIGQUIT
block|,
index|[
name|SIGSEGV
index|]
operator|=
name|CLOUDABI_SIGSEGV
block|,
index|[
name|SIGSTOP
index|]
operator|=
name|CLOUDABI_SIGSTOP
block|,
index|[
name|SIGSYS
index|]
operator|=
name|CLOUDABI_SIGSYS
block|,
index|[
name|SIGTERM
index|]
operator|=
name|CLOUDABI_SIGTERM
block|,
index|[
name|SIGTRAP
index|]
operator|=
name|CLOUDABI_SIGTRAP
block|,
index|[
name|SIGTSTP
index|]
operator|=
name|CLOUDABI_SIGTSTP
block|,
index|[
name|SIGTTIN
index|]
operator|=
name|CLOUDABI_SIGTTIN
block|,
index|[
name|SIGTTOU
index|]
operator|=
name|CLOUDABI_SIGTTOU
block|,
index|[
name|SIGURG
index|]
operator|=
name|CLOUDABI_SIGURG
block|,
index|[
name|SIGUSR1
index|]
operator|=
name|CLOUDABI_SIGUSR1
block|,
index|[
name|SIGUSR2
index|]
operator|=
name|CLOUDABI_SIGUSR2
block|,
index|[
name|SIGVTALRM
index|]
operator|=
name|CLOUDABI_SIGVTALRM
block|,
index|[
name|SIGXCPU
index|]
operator|=
name|CLOUDABI_SIGXCPU
block|,
index|[
name|SIGXFSZ
index|]
operator|=
name|CLOUDABI_SIGXFSZ
block|, 	}
decl_stmt|;
comment|/* Convert unknown signals to SIGABRT. */
if|if
condition|(
name|sig
operator|<
literal|0
operator|||
name|sig
operator|>=
name|nitems
argument_list|(
name|signals
argument_list|)
operator|||
name|signals
index|[
name|sig
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|SIGABRT
operator|)
return|;
return|return
operator|(
name|signals
index|[
name|sig
index|]
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|cloudabi64_kevent_args
block|{
specifier|const
name|cloudabi64_subscription_t
modifier|*
name|in
decl_stmt|;
name|cloudabi_event_t
modifier|*
name|out
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Converts CloudABI's subscription objects to FreeBSD's struct kevent. */
end_comment

begin_function
specifier|static
name|int
name|cloudabi64_kevent_copyin
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|kevent
modifier|*
name|kevp
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|cloudabi64_subscription_t
name|sub
decl_stmt|;
name|struct
name|cloudabi64_kevent_args
modifier|*
name|args
decl_stmt|;
name|cloudabi_timestamp_t
name|ts
decl_stmt|;
name|int
name|error
decl_stmt|;
name|args
operator|=
name|arg
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
comment|/* TODO(ed): Copy in multiple entries at once. */
name|error
operator|=
name|copyin
argument_list|(
name|args
operator|->
name|in
operator|++
argument_list|,
operator|&
name|sub
argument_list|,
sizeof|sizeof
argument_list|(
name|sub
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|memset
argument_list|(
name|kevp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|kevp
argument_list|)
argument_list|)
expr_stmt|;
name|kevp
operator|->
name|udata
operator|=
name|TO_PTR
argument_list|(
name|sub
operator|.
name|userdata
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sub
operator|.
name|type
condition|)
block|{
case|case
name|CLOUDABI_EVENTTYPE_CLOCK
case|:
name|kevp
operator|->
name|filter
operator|=
name|EVFILT_TIMER
expr_stmt|;
name|kevp
operator|->
name|ident
operator|=
name|sub
operator|.
name|clock
operator|.
name|identifier
expr_stmt|;
name|kevp
operator|->
name|fflags
operator|=
name|NOTE_NSECONDS
expr_stmt|;
if|if
condition|(
operator|(
name|sub
operator|.
name|clock
operator|.
name|flags
operator|&
name|CLOUDABI_SUBSCRIPTION_CLOCK_ABSTIME
operator|)
operator|!=
literal|0
operator|&&
name|sub
operator|.
name|clock
operator|.
name|timeout
operator|>
literal|0
condition|)
block|{
comment|/* Convert absolute timestamp to a relative. */
name|error
operator|=
name|cloudabi_clock_time_get
argument_list|(
name|curthread
argument_list|,
name|sub
operator|.
name|clock
operator|.
name|clock_id
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ts
operator|=
name|ts
operator|>
name|sub
operator|.
name|clock
operator|.
name|timeout
condition|?
literal|0
else|:
name|sub
operator|.
name|clock
operator|.
name|timeout
operator|-
name|ts
expr_stmt|;
block|}
else|else
block|{
comment|/* Relative timestamp. */
name|ts
operator|=
name|sub
operator|.
name|clock
operator|.
name|timeout
expr_stmt|;
block|}
name|kevp
operator|->
name|data
operator|=
name|ts
operator|>
name|INTPTR_MAX
condition|?
name|INTPTR_MAX
else|:
name|ts
expr_stmt|;
break|break;
case|case
name|CLOUDABI_EVENTTYPE_FD_READ
case|:
name|kevp
operator|->
name|filter
operator|=
name|EVFILT_READ
expr_stmt|;
name|kevp
operator|->
name|ident
operator|=
name|sub
operator|.
name|fd_readwrite
operator|.
name|fd
expr_stmt|;
name|kevp
operator|->
name|fflags
operator|=
name|NOTE_FILE_POLL
expr_stmt|;
break|break;
case|case
name|CLOUDABI_EVENTTYPE_FD_WRITE
case|:
name|kevp
operator|->
name|filter
operator|=
name|EVFILT_WRITE
expr_stmt|;
name|kevp
operator|->
name|ident
operator|=
name|sub
operator|.
name|fd_readwrite
operator|.
name|fd
expr_stmt|;
break|break;
case|case
name|CLOUDABI_EVENTTYPE_PROC_TERMINATE
case|:
name|kevp
operator|->
name|filter
operator|=
name|EVFILT_PROCDESC
expr_stmt|;
name|kevp
operator|->
name|ident
operator|=
name|sub
operator|.
name|proc_terminate
operator|.
name|fd
expr_stmt|;
name|kevp
operator|->
name|fflags
operator|=
name|NOTE_EXIT
expr_stmt|;
break|break;
block|}
name|kevp
operator|->
name|flags
operator|=
name|EV_ADD
operator||
name|EV_ONESHOT
expr_stmt|;
operator|++
name|kevp
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Converts FreeBSD's struct kevent to CloudABI's event objects. */
end_comment

begin_function
specifier|static
name|int
name|cloudabi64_kevent_copyout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|kevent
modifier|*
name|kevp
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|cloudabi_event_t
name|ev
decl_stmt|;
name|struct
name|cloudabi64_kevent_args
modifier|*
name|args
decl_stmt|;
name|int
name|error
decl_stmt|;
name|args
operator|=
name|arg
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
comment|/* Convert fields that should always be present. */
name|memset
argument_list|(
operator|&
name|ev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
name|ev
operator|.
name|userdata
operator|=
operator|(
name|uintptr_t
operator|)
name|kevp
operator|->
name|udata
expr_stmt|;
switch|switch
condition|(
name|kevp
operator|->
name|filter
condition|)
block|{
case|case
name|EVFILT_TIMER
case|:
name|ev
operator|.
name|type
operator|=
name|CLOUDABI_EVENTTYPE_CLOCK
expr_stmt|;
break|break;
case|case
name|EVFILT_READ
case|:
name|ev
operator|.
name|type
operator|=
name|CLOUDABI_EVENTTYPE_FD_READ
expr_stmt|;
break|break;
case|case
name|EVFILT_WRITE
case|:
name|ev
operator|.
name|type
operator|=
name|CLOUDABI_EVENTTYPE_FD_WRITE
expr_stmt|;
break|break;
case|case
name|EVFILT_PROCDESC
case|:
name|ev
operator|.
name|type
operator|=
name|CLOUDABI_EVENTTYPE_PROC_TERMINATE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|kevp
operator|->
name|flags
operator|&
name|EV_ERROR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Success. */
switch|switch
condition|(
name|kevp
operator|->
name|filter
condition|)
block|{
case|case
name|EVFILT_READ
case|:
case|case
name|EVFILT_WRITE
case|:
name|ev
operator|.
name|fd_readwrite
operator|.
name|nbytes
operator|=
name|kevp
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|kevp
operator|->
name|flags
operator|&
name|EV_EOF
operator|)
operator|!=
literal|0
condition|)
block|{
name|ev
operator|.
name|fd_readwrite
operator|.
name|flags
operator||=
name|CLOUDABI_EVENT_FD_READWRITE_HANGUP
expr_stmt|;
block|}
break|break;
case|case
name|EVFILT_PROCDESC
case|:
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|kevp
operator|->
name|data
argument_list|)
condition|)
block|{
comment|/* Process got signalled. */
name|ev
operator|.
name|proc_terminate
operator|.
name|signal
operator|=
name|convert_signal
argument_list|(
name|WTERMSIG
argument_list|(
name|kevp
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|ev
operator|.
name|proc_terminate
operator|.
name|exitcode
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Process exited. */
name|ev
operator|.
name|proc_terminate
operator|.
name|signal
operator|=
literal|0
expr_stmt|;
name|ev
operator|.
name|proc_terminate
operator|.
name|exitcode
operator|=
name|WEXITSTATUS
argument_list|(
name|kevp
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
block|{
comment|/* Error. */
name|ev
operator|.
name|error
operator|=
name|cloudabi_convert_errno
argument_list|(
name|kevp
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
operator|++
name|kevp
expr_stmt|;
comment|/* TODO(ed): Copy out multiple entries at once. */
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|ev
argument_list|,
name|args
operator|->
name|out
operator|++
argument_list|,
sizeof|sizeof
argument_list|(
name|ev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cloudabi64_sys_poll
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|cloudabi64_sys_poll_args
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|cloudabi64_kevent_args
name|args
init|=
block|{
operator|.
name|in
operator|=
name|uap
operator|->
name|in
block|,
operator|.
name|out
operator|=
name|uap
operator|->
name|out
block|, 	}
decl_stmt|;
name|struct
name|kevent_copyops
name|copyops
init|=
block|{
operator|.
name|k_copyin
operator|=
name|cloudabi64_kevent_copyin
block|,
operator|.
name|k_copyout
operator|=
name|cloudabi64_kevent_copyout
block|,
operator|.
name|arg
operator|=
operator|&
name|args
block|, 	}
decl_stmt|;
comment|/* 	 * Bandaid to support CloudABI futex constructs that are not 	 * implemented through FreeBSD's kqueue(). 	 */
if|if
condition|(
name|uap
operator|->
name|nsubscriptions
operator|==
literal|1
condition|)
block|{
name|cloudabi64_subscription_t
name|sub
decl_stmt|;
name|cloudabi_event_t
name|ev
init|=
block|{}
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|in
argument_list|,
operator|&
name|sub
argument_list|,
sizeof|sizeof
argument_list|(
name|sub
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ev
operator|.
name|userdata
operator|=
name|sub
operator|.
name|userdata
expr_stmt|;
name|ev
operator|.
name|type
operator|=
name|sub
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|sub
operator|.
name|type
operator|==
name|CLOUDABI_EVENTTYPE_CONDVAR
condition|)
block|{
comment|/* Wait on a condition variable. */
name|ev
operator|.
name|error
operator|=
name|cloudabi_convert_errno
argument_list|(
name|cloudabi_futex_condvar_wait
argument_list|(
name|td
argument_list|,
name|TO_PTR
argument_list|(
name|sub
operator|.
name|condvar
operator|.
name|condvar
argument_list|)
argument_list|,
name|sub
operator|.
name|condvar
operator|.
name|condvar_scope
argument_list|,
name|TO_PTR
argument_list|(
name|sub
operator|.
name|condvar
operator|.
name|lock
argument_list|)
argument_list|,
name|sub
operator|.
name|condvar
operator|.
name|lock_scope
argument_list|,
name|CLOUDABI_CLOCK_MONOTONIC
argument_list|,
name|UINT64_MAX
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|ev
argument_list|,
name|uap
operator|->
name|out
argument_list|,
sizeof|sizeof
argument_list|(
name|ev
argument_list|)
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|sub
operator|.
name|type
operator|==
name|CLOUDABI_EVENTTYPE_LOCK_RDLOCK
condition|)
block|{
comment|/* Acquire a read lock. */
name|ev
operator|.
name|error
operator|=
name|cloudabi_convert_errno
argument_list|(
name|cloudabi_futex_lock_rdlock
argument_list|(
name|td
argument_list|,
name|TO_PTR
argument_list|(
name|sub
operator|.
name|lock
operator|.
name|lock
argument_list|)
argument_list|,
name|sub
operator|.
name|lock
operator|.
name|lock_scope
argument_list|,
name|CLOUDABI_CLOCK_MONOTONIC
argument_list|,
name|UINT64_MAX
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|ev
argument_list|,
name|uap
operator|->
name|out
argument_list|,
sizeof|sizeof
argument_list|(
name|ev
argument_list|)
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|sub
operator|.
name|type
operator|==
name|CLOUDABI_EVENTTYPE_LOCK_WRLOCK
condition|)
block|{
comment|/* Acquire a write lock. */
name|ev
operator|.
name|error
operator|=
name|cloudabi_convert_errno
argument_list|(
name|cloudabi_futex_lock_wrlock
argument_list|(
name|td
argument_list|,
name|TO_PTR
argument_list|(
name|sub
operator|.
name|lock
operator|.
name|lock
argument_list|)
argument_list|,
name|sub
operator|.
name|lock
operator|.
name|lock_scope
argument_list|,
name|CLOUDABI_CLOCK_MONOTONIC
argument_list|,
name|UINT64_MAX
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|ev
argument_list|,
name|uap
operator|->
name|out
argument_list|,
sizeof|sizeof
argument_list|(
name|ev
argument_list|)
argument_list|)
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|uap
operator|->
name|nsubscriptions
operator|==
literal|2
condition|)
block|{
name|cloudabi64_subscription_t
name|sub
index|[
literal|2
index|]
decl_stmt|;
name|cloudabi_event_t
name|ev
index|[
literal|2
index|]
init|=
block|{}
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|uap
operator|->
name|in
argument_list|,
operator|&
name|sub
argument_list|,
sizeof|sizeof
argument_list|(
name|sub
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ev
index|[
literal|0
index|]
operator|.
name|userdata
operator|=
name|sub
index|[
literal|0
index|]
operator|.
name|userdata
expr_stmt|;
name|ev
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|sub
index|[
literal|0
index|]
operator|.
name|type
expr_stmt|;
name|ev
index|[
literal|1
index|]
operator|.
name|userdata
operator|=
name|sub
index|[
literal|1
index|]
operator|.
name|userdata
expr_stmt|;
name|ev
index|[
literal|1
index|]
operator|.
name|type
operator|=
name|sub
index|[
literal|1
index|]
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|sub
index|[
literal|0
index|]
operator|.
name|type
operator|==
name|CLOUDABI_EVENTTYPE_CONDVAR
operator|&&
name|sub
index|[
literal|1
index|]
operator|.
name|type
operator|==
name|CLOUDABI_EVENTTYPE_CLOCK
operator|&&
name|sub
index|[
literal|1
index|]
operator|.
name|clock
operator|.
name|flags
operator|==
name|CLOUDABI_SUBSCRIPTION_CLOCK_ABSTIME
condition|)
block|{
comment|/* Wait for a condition variable with timeout. */
name|error
operator|=
name|cloudabi_futex_condvar_wait
argument_list|(
name|td
argument_list|,
name|TO_PTR
argument_list|(
name|sub
index|[
literal|0
index|]
operator|.
name|condvar
operator|.
name|condvar
argument_list|)
argument_list|,
name|sub
index|[
literal|0
index|]
operator|.
name|condvar
operator|.
name|condvar_scope
argument_list|,
name|TO_PTR
argument_list|(
name|sub
index|[
literal|0
index|]
operator|.
name|condvar
operator|.
name|lock
argument_list|)
argument_list|,
name|sub
index|[
literal|0
index|]
operator|.
name|condvar
operator|.
name|lock_scope
argument_list|,
name|sub
index|[
literal|1
index|]
operator|.
name|clock
operator|.
name|clock_id
argument_list|,
name|sub
index|[
literal|1
index|]
operator|.
name|clock
operator|.
name|timeout
argument_list|,
name|sub
index|[
literal|1
index|]
operator|.
name|clock
operator|.
name|precision
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ETIMEDOUT
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|ev
index|[
literal|1
index|]
argument_list|,
name|uap
operator|->
name|out
argument_list|,
sizeof|sizeof
argument_list|(
name|ev
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|)
return|;
block|}
name|ev
index|[
literal|0
index|]
operator|.
name|error
operator|=
name|cloudabi_convert_errno
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|ev
index|[
literal|0
index|]
argument_list|,
name|uap
operator|->
name|out
argument_list|,
sizeof|sizeof
argument_list|(
name|ev
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|sub
index|[
literal|0
index|]
operator|.
name|type
operator|==
name|CLOUDABI_EVENTTYPE_LOCK_RDLOCK
operator|&&
name|sub
index|[
literal|1
index|]
operator|.
name|type
operator|==
name|CLOUDABI_EVENTTYPE_CLOCK
operator|&&
name|sub
index|[
literal|1
index|]
operator|.
name|clock
operator|.
name|flags
operator|==
name|CLOUDABI_SUBSCRIPTION_CLOCK_ABSTIME
condition|)
block|{
comment|/* Acquire a read lock with a timeout. */
name|error
operator|=
name|cloudabi_futex_lock_rdlock
argument_list|(
name|td
argument_list|,
name|TO_PTR
argument_list|(
name|sub
index|[
literal|0
index|]
operator|.
name|lock
operator|.
name|lock
argument_list|)
argument_list|,
name|sub
index|[
literal|0
index|]
operator|.
name|lock
operator|.
name|lock_scope
argument_list|,
name|sub
index|[
literal|1
index|]
operator|.
name|clock
operator|.
name|clock_id
argument_list|,
name|sub
index|[
literal|1
index|]
operator|.
name|clock
operator|.
name|timeout
argument_list|,
name|sub
index|[
literal|1
index|]
operator|.
name|clock
operator|.
name|precision
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ETIMEDOUT
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|ev
index|[
literal|1
index|]
argument_list|,
name|uap
operator|->
name|out
argument_list|,
sizeof|sizeof
argument_list|(
name|ev
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|)
return|;
block|}
name|ev
index|[
literal|0
index|]
operator|.
name|error
operator|=
name|cloudabi_convert_errno
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|ev
index|[
literal|0
index|]
argument_list|,
name|uap
operator|->
name|out
argument_list|,
sizeof|sizeof
argument_list|(
name|ev
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|sub
index|[
literal|0
index|]
operator|.
name|type
operator|==
name|CLOUDABI_EVENTTYPE_LOCK_WRLOCK
operator|&&
name|sub
index|[
literal|1
index|]
operator|.
name|type
operator|==
name|CLOUDABI_EVENTTYPE_CLOCK
operator|&&
name|sub
index|[
literal|1
index|]
operator|.
name|clock
operator|.
name|flags
operator|==
name|CLOUDABI_SUBSCRIPTION_CLOCK_ABSTIME
condition|)
block|{
comment|/* Acquire a write lock with a timeout. */
name|error
operator|=
name|cloudabi_futex_lock_wrlock
argument_list|(
name|td
argument_list|,
name|TO_PTR
argument_list|(
name|sub
index|[
literal|0
index|]
operator|.
name|lock
operator|.
name|lock
argument_list|)
argument_list|,
name|sub
index|[
literal|0
index|]
operator|.
name|lock
operator|.
name|lock_scope
argument_list|,
name|sub
index|[
literal|1
index|]
operator|.
name|clock
operator|.
name|clock_id
argument_list|,
name|sub
index|[
literal|1
index|]
operator|.
name|clock
operator|.
name|timeout
argument_list|,
name|sub
index|[
literal|1
index|]
operator|.
name|clock
operator|.
name|precision
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ETIMEDOUT
condition|)
block|{
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|ev
index|[
literal|1
index|]
argument_list|,
name|uap
operator|->
name|out
argument_list|,
sizeof|sizeof
argument_list|(
name|ev
index|[
literal|1
index|]
argument_list|)
argument_list|)
operator|)
return|;
block|}
name|ev
index|[
literal|0
index|]
operator|.
name|error
operator|=
name|cloudabi_convert_errno
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_retval
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|ev
index|[
literal|0
index|]
argument_list|,
name|uap
operator|->
name|out
argument_list|,
sizeof|sizeof
argument_list|(
name|ev
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
name|kern_kevent_anonymous
argument_list|(
name|td
argument_list|,
name|uap
operator|->
name|nsubscriptions
argument_list|,
operator|&
name|copyops
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

