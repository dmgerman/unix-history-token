begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008-2009 Ed Schouten<ed@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_define
define|#
directive|define
name|teken_assert
parameter_list|(
name|x
parameter_list|)
value|MPASS(x)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !(__FreeBSD__&& _KERNEL) */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|teken_assert
parameter_list|(
name|x
parameter_list|)
value|assert(x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__&& _KERNEL */
end_comment

begin_comment
comment|/* debug messages */
end_comment

begin_define
define|#
directive|define
name|teken_printf
parameter_list|(
name|x
parameter_list|,
modifier|...
parameter_list|)
end_define

begin_comment
comment|/* Private flags for t_stateflags. */
end_comment

begin_define
define|#
directive|define
name|TS_FIRSTDIGIT
value|0x0001
end_define

begin_comment
comment|/* First numeric digit in escape sequence. */
end_comment

begin_define
define|#
directive|define
name|TS_INSERT
value|0x0002
end_define

begin_comment
comment|/* Insert mode. */
end_comment

begin_define
define|#
directive|define
name|TS_AUTOWRAP
value|0x0004
end_define

begin_comment
comment|/* Autowrap. */
end_comment

begin_define
define|#
directive|define
name|TS_ORIGIN
value|0x0008
end_define

begin_comment
comment|/* Origin mode. */
end_comment

begin_define
define|#
directive|define
name|TS_WRAPPED
value|0x0010
end_define

begin_comment
comment|/* Next character should be printed on col 0. */
end_comment

begin_define
define|#
directive|define
name|TS_8BIT
value|0x0020
end_define

begin_comment
comment|/* UTF-8 disabled. */
end_comment

begin_define
define|#
directive|define
name|TS_CONS25
value|0x0040
end_define

begin_comment
comment|/* cons25 emulation. */
end_comment

begin_define
define|#
directive|define
name|TS_INSTRING
value|0x0080
end_define

begin_comment
comment|/* Inside string. */
end_comment

begin_define
define|#
directive|define
name|TS_CURSORKEYS
value|0x0100
end_define

begin_comment
comment|/* Cursor keys mode. */
end_comment

begin_comment
comment|/* Character that blanks a cell. */
end_comment

begin_define
define|#
directive|define
name|BLANK
value|' '
end_define

begin_include
include|#
directive|include
file|"teken.h"
end_include

begin_include
include|#
directive|include
file|"teken_wcwidth.h"
end_include

begin_include
include|#
directive|include
file|"teken_scs.h"
end_include

begin_decl_stmt
specifier|static
name|teken_state_t
name|teken_state_init
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Wrappers for hooks.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|teken_funcs_bell
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|)
block|{
name|t
operator|->
name|t_funcs
operator|->
name|tf_bell
argument_list|(
name|t
operator|->
name|t_softc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|teken_funcs_cursor
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|)
block|{
name|teken_assert
argument_list|(
name|t
operator|->
name|t_cursor
operator|.
name|tp_row
operator|<
name|t
operator|->
name|t_winsize
operator|.
name|tp_row
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|t
operator|->
name|t_cursor
operator|.
name|tp_col
operator|<
name|t
operator|->
name|t_winsize
operator|.
name|tp_col
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_funcs
operator|->
name|tf_cursor
argument_list|(
name|t
operator|->
name|t_softc
argument_list|,
operator|&
name|t
operator|->
name|t_cursor
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|teken_funcs_putchar
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
specifier|const
name|teken_pos_t
modifier|*
name|p
parameter_list|,
name|teken_char_t
name|c
parameter_list|,
specifier|const
name|teken_attr_t
modifier|*
name|a
parameter_list|)
block|{
name|teken_assert
argument_list|(
name|p
operator|->
name|tp_row
operator|<
name|t
operator|->
name|t_winsize
operator|.
name|tp_row
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|p
operator|->
name|tp_col
operator|<
name|t
operator|->
name|t_winsize
operator|.
name|tp_col
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_funcs
operator|->
name|tf_putchar
argument_list|(
name|t
operator|->
name|t_softc
argument_list|,
name|p
argument_list|,
name|c
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|teken_funcs_fill
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
specifier|const
name|teken_rect_t
modifier|*
name|r
parameter_list|,
specifier|const
name|teken_char_t
name|c
parameter_list|,
specifier|const
name|teken_attr_t
modifier|*
name|a
parameter_list|)
block|{
name|teken_assert
argument_list|(
name|r
operator|->
name|tr_end
operator|.
name|tp_row
operator|>
name|r
operator|->
name|tr_begin
operator|.
name|tp_row
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|r
operator|->
name|tr_end
operator|.
name|tp_row
operator|<=
name|t
operator|->
name|t_winsize
operator|.
name|tp_row
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|r
operator|->
name|tr_end
operator|.
name|tp_col
operator|>
name|r
operator|->
name|tr_begin
operator|.
name|tp_col
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|r
operator|->
name|tr_end
operator|.
name|tp_col
operator|<=
name|t
operator|->
name|t_winsize
operator|.
name|tp_col
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_funcs
operator|->
name|tf_fill
argument_list|(
name|t
operator|->
name|t_softc
argument_list|,
name|r
argument_list|,
name|c
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|teken_funcs_copy
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
specifier|const
name|teken_rect_t
modifier|*
name|r
parameter_list|,
specifier|const
name|teken_pos_t
modifier|*
name|p
parameter_list|)
block|{
name|teken_assert
argument_list|(
name|r
operator|->
name|tr_end
operator|.
name|tp_row
operator|>
name|r
operator|->
name|tr_begin
operator|.
name|tp_row
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|r
operator|->
name|tr_end
operator|.
name|tp_row
operator|<=
name|t
operator|->
name|t_winsize
operator|.
name|tp_row
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|r
operator|->
name|tr_end
operator|.
name|tp_col
operator|>
name|r
operator|->
name|tr_begin
operator|.
name|tp_col
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|r
operator|->
name|tr_end
operator|.
name|tp_col
operator|<=
name|t
operator|->
name|t_winsize
operator|.
name|tp_col
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|p
operator|->
name|tp_row
operator|+
operator|(
name|r
operator|->
name|tr_end
operator|.
name|tp_row
operator|-
name|r
operator|->
name|tr_begin
operator|.
name|tp_row
operator|)
operator|<=
name|t
operator|->
name|t_winsize
operator|.
name|tp_row
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|p
operator|->
name|tp_col
operator|+
operator|(
name|r
operator|->
name|tr_end
operator|.
name|tp_col
operator|-
name|r
operator|->
name|tr_begin
operator|.
name|tp_col
operator|)
operator|<=
name|t
operator|->
name|t_winsize
operator|.
name|tp_col
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_funcs
operator|->
name|tf_copy
argument_list|(
name|t
operator|->
name|t_softc
argument_list|,
name|r
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|teken_funcs_param
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
name|int
name|cmd
parameter_list|,
name|unsigned
name|int
name|value
parameter_list|)
block|{
name|t
operator|->
name|t_funcs
operator|->
name|tf_param
argument_list|(
name|t
operator|->
name|t_softc
argument_list|,
name|cmd
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|teken_funcs_respond
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|t
operator|->
name|t_funcs
operator|->
name|tf_respond
argument_list|(
name|t
operator|->
name|t_softc
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"teken_subr.h"
end_include

begin_include
include|#
directive|include
file|"teken_subr_compat.h"
end_include

begin_comment
comment|/*  * Programming interface.  */
end_comment

begin_function
name|void
name|teken_init
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
specifier|const
name|teken_funcs_t
modifier|*
name|tf
parameter_list|,
name|void
modifier|*
name|softc
parameter_list|)
block|{
name|teken_pos_t
name|tp
init|=
block|{
operator|.
name|tp_row
operator|=
literal|24
block|,
operator|.
name|tp_col
operator|=
literal|80
block|}
decl_stmt|;
name|t
operator|->
name|t_funcs
operator|=
name|tf
expr_stmt|;
name|t
operator|->
name|t_softc
operator|=
name|softc
expr_stmt|;
name|t
operator|->
name|t_nextstate
operator|=
name|teken_state_init
expr_stmt|;
name|t
operator|->
name|t_stateflags
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|t_utf8_left
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|t_defattr
operator|.
name|ta_format
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|t_defattr
operator|.
name|ta_fgcolor
operator|=
name|TC_WHITE
expr_stmt|;
name|t
operator|->
name|t_defattr
operator|.
name|ta_bgcolor
operator|=
name|TC_BLACK
expr_stmt|;
name|teken_subr_do_reset
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|teken_set_winsize
argument_list|(
name|t
argument_list|,
operator|&
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|teken_input_char
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
name|teken_char_t
name|c
parameter_list|)
block|{
comment|/* 	 * There is no support for DCS and OSC.  Just discard strings 	 * until we receive characters that may indicate string 	 * termination. 	 */
if|if
condition|(
name|t
operator|->
name|t_stateflags
operator|&
name|TS_INSTRING
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\x1B'
case|:
name|t
operator|->
name|t_stateflags
operator|&=
operator|~
name|TS_INSTRING
expr_stmt|;
break|break;
case|case
literal|'\a'
case|:
name|t
operator|->
name|t_stateflags
operator|&=
operator|~
name|TS_INSTRING
expr_stmt|;
return|return;
default|default:
return|return;
block|}
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
break|break;
case|case
literal|'\a'
case|:
name|teken_subr_bell
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|teken_subr_backspace
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
case|case
literal|'\x0B'
case|:
name|teken_subr_newline
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\x0C'
case|:
name|teken_subr_newpage
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\x0E'
case|:
if|if
condition|(
name|t
operator|->
name|t_stateflags
operator|&
name|TS_CONS25
condition|)
name|t
operator|->
name|t_nextstate
argument_list|(
name|t
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|t
operator|->
name|t_curscs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'\x0F'
case|:
if|if
condition|(
name|t
operator|->
name|t_stateflags
operator|&
name|TS_CONS25
condition|)
name|t
operator|->
name|t_nextstate
argument_list|(
name|t
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|t
operator|->
name|t_curscs
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|teken_subr_carriage_return
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|teken_subr_horizontal_tab
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|t
operator|->
name|t_nextstate
argument_list|(
name|t
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Post-processing assertions. */
name|teken_assert
argument_list|(
name|t
operator|->
name|t_cursor
operator|.
name|tp_row
operator|>=
name|t
operator|->
name|t_originreg
operator|.
name|ts_begin
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|t
operator|->
name|t_cursor
operator|.
name|tp_row
operator|<
name|t
operator|->
name|t_originreg
operator|.
name|ts_end
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|t
operator|->
name|t_cursor
operator|.
name|tp_row
operator|<
name|t
operator|->
name|t_winsize
operator|.
name|tp_row
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|t
operator|->
name|t_cursor
operator|.
name|tp_col
operator|<
name|t
operator|->
name|t_winsize
operator|.
name|tp_col
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|t
operator|->
name|t_saved_cursor
operator|.
name|tp_row
operator|<
name|t
operator|->
name|t_winsize
operator|.
name|tp_row
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|t
operator|->
name|t_saved_cursor
operator|.
name|tp_col
operator|<
name|t
operator|->
name|t_winsize
operator|.
name|tp_col
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|t
operator|->
name|t_scrollreg
operator|.
name|ts_end
operator|<=
name|t
operator|->
name|t_winsize
operator|.
name|tp_row
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|t
operator|->
name|t_scrollreg
operator|.
name|ts_begin
operator|<
name|t
operator|->
name|t_scrollreg
operator|.
name|ts_end
argument_list|)
expr_stmt|;
comment|/* Origin region has to be window size or the same as scrollreg. */
name|teken_assert
argument_list|(
operator|(
name|t
operator|->
name|t_originreg
operator|.
name|ts_begin
operator|==
name|t
operator|->
name|t_scrollreg
operator|.
name|ts_begin
operator|&&
name|t
operator|->
name|t_originreg
operator|.
name|ts_end
operator|==
name|t
operator|->
name|t_scrollreg
operator|.
name|ts_end
operator|)
operator|||
operator|(
name|t
operator|->
name|t_originreg
operator|.
name|ts_begin
operator|==
literal|0
operator|&&
name|t
operator|->
name|t_originreg
operator|.
name|ts_end
operator|==
name|t
operator|->
name|t_winsize
operator|.
name|tp_row
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|teken_input_byte
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
name|unsigned
name|char
name|c
parameter_list|)
block|{
comment|/* 	 * UTF-8 handling. 	 */
if|if
condition|(
operator|(
name|c
operator|&
literal|0x80
operator|)
operator|==
literal|0x00
operator|||
name|t
operator|->
name|t_stateflags
operator|&
name|TS_8BIT
condition|)
block|{
comment|/* One-byte sequence. */
name|t
operator|->
name|t_utf8_left
operator|=
literal|0
expr_stmt|;
name|teken_input_char
argument_list|(
name|t
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|&
literal|0xe0
operator|)
operator|==
literal|0xc0
condition|)
block|{
comment|/* Two-byte sequence. */
name|t
operator|->
name|t_utf8_left
operator|=
literal|1
expr_stmt|;
name|t
operator|->
name|t_utf8_partial
operator|=
name|c
operator|&
literal|0x1f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|&
literal|0xf0
operator|)
operator|==
literal|0xe0
condition|)
block|{
comment|/* Three-byte sequence. */
name|t
operator|->
name|t_utf8_left
operator|=
literal|2
expr_stmt|;
name|t
operator|->
name|t_utf8_partial
operator|=
name|c
operator|&
literal|0x0f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|&
literal|0xf8
operator|)
operator|==
literal|0xf0
condition|)
block|{
comment|/* Four-byte sequence. */
name|t
operator|->
name|t_utf8_left
operator|=
literal|3
expr_stmt|;
name|t
operator|->
name|t_utf8_partial
operator|=
name|c
operator|&
literal|0x07
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|&
literal|0xc0
operator|)
operator|==
literal|0x80
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|t_utf8_left
operator|==
literal|0
condition|)
return|return;
name|t
operator|->
name|t_utf8_left
operator|--
expr_stmt|;
name|t
operator|->
name|t_utf8_partial
operator|=
operator|(
name|t
operator|->
name|t_utf8_partial
operator|<<
literal|6
operator|)
operator||
operator|(
name|c
operator|&
literal|0x3f
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_utf8_left
operator|==
literal|0
condition|)
block|{
name|teken_printf
argument_list|(
literal|"Got UTF-8 char %x\n"
argument_list|,
name|t
operator|->
name|t_utf8_partial
argument_list|)
expr_stmt|;
name|teken_input_char
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|t_utf8_partial
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|teken_input
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|c
init|=
name|buf
decl_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
name|teken_input_byte
argument_list|(
name|t
argument_list|,
operator|*
name|c
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|teken_pos_t
modifier|*
name|teken_get_cursor
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|)
block|{
return|return
operator|(
operator|&
name|t
operator|->
name|t_cursor
operator|)
return|;
block|}
end_function

begin_function
name|void
name|teken_set_cursor
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
specifier|const
name|teken_pos_t
modifier|*
name|p
parameter_list|)
block|{
comment|/* XXX: bounds checking with originreg! */
name|teken_assert
argument_list|(
name|p
operator|->
name|tp_row
operator|<
name|t
operator|->
name|t_winsize
operator|.
name|tp_row
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|p
operator|->
name|tp_col
operator|<
name|t
operator|->
name|t_winsize
operator|.
name|tp_col
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_cursor
operator|=
operator|*
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|teken_attr_t
modifier|*
name|teken_get_curattr
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|)
block|{
return|return
operator|(
operator|&
name|t
operator|->
name|t_curattr
operator|)
return|;
block|}
end_function

begin_function
name|void
name|teken_set_curattr
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
specifier|const
name|teken_attr_t
modifier|*
name|a
parameter_list|)
block|{
name|t
operator|->
name|t_curattr
operator|=
operator|*
name|a
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|teken_attr_t
modifier|*
name|teken_get_defattr
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|)
block|{
return|return
operator|(
operator|&
name|t
operator|->
name|t_defattr
operator|)
return|;
block|}
end_function

begin_function
name|void
name|teken_set_defattr
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
specifier|const
name|teken_attr_t
modifier|*
name|a
parameter_list|)
block|{
name|t
operator|->
name|t_curattr
operator|=
name|t
operator|->
name|t_saved_curattr
operator|=
name|t
operator|->
name|t_defattr
operator|=
operator|*
name|a
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|teken_pos_t
modifier|*
name|teken_get_winsize
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|)
block|{
return|return
operator|(
operator|&
name|t
operator|->
name|t_winsize
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|teken_trim_cursor_pos
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
specifier|const
name|teken_pos_t
modifier|*
name|new
parameter_list|)
block|{
specifier|const
name|teken_pos_t
modifier|*
name|cur
decl_stmt|;
name|cur
operator|=
operator|&
name|t
operator|->
name|t_winsize
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|tp_row
operator|<
name|new
operator|->
name|tp_row
operator|||
name|cur
operator|->
name|tp_col
operator|<
name|new
operator|->
name|tp_col
condition|)
return|return;
if|if
condition|(
name|t
operator|->
name|t_cursor
operator|.
name|tp_row
operator|>=
name|new
operator|->
name|tp_row
condition|)
name|t
operator|->
name|t_cursor
operator|.
name|tp_row
operator|=
name|new
operator|->
name|tp_row
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_cursor
operator|.
name|tp_col
operator|>=
name|new
operator|->
name|tp_col
condition|)
name|t
operator|->
name|t_cursor
operator|.
name|tp_col
operator|=
name|new
operator|->
name|tp_col
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|teken_set_winsize
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
specifier|const
name|teken_pos_t
modifier|*
name|p
parameter_list|)
block|{
name|teken_trim_cursor_pos
argument_list|(
name|t
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_winsize
operator|=
operator|*
name|p
expr_stmt|;
name|teken_subr_do_reset
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|teken_set_winsize_noreset
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
specifier|const
name|teken_pos_t
modifier|*
name|p
parameter_list|)
block|{
name|teken_trim_cursor_pos
argument_list|(
name|t
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_winsize
operator|=
operator|*
name|p
expr_stmt|;
name|teken_subr_do_resize
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|teken_set_8bit
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|)
block|{
name|t
operator|->
name|t_stateflags
operator||=
name|TS_8BIT
expr_stmt|;
block|}
end_function

begin_function
name|void
name|teken_set_cons25
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|)
block|{
name|t
operator|->
name|t_stateflags
operator||=
name|TS_CONS25
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * State machine.  */
end_comment

begin_function
specifier|static
name|void
name|teken_state_switch
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
name|teken_state_t
modifier|*
name|s
parameter_list|)
block|{
name|t
operator|->
name|t_nextstate
operator|=
name|s
expr_stmt|;
name|t
operator|->
name|t_curnum
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|t_stateflags
operator||=
name|TS_FIRSTDIGIT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|teken_state_numbers
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
name|teken_char_t
name|c
parameter_list|)
block|{
name|teken_assert
argument_list|(
name|t
operator|->
name|t_curnum
operator|<
name|T_NUMSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|t_stateflags
operator|&
name|TS_FIRSTDIGIT
condition|)
block|{
comment|/* First digit. */
name|t
operator|->
name|t_stateflags
operator|&=
operator|~
name|TS_FIRSTDIGIT
expr_stmt|;
name|t
operator|->
name|t_nums
index|[
name|t
operator|->
name|t_curnum
index|]
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|t_nums
index|[
name|t
operator|->
name|t_curnum
index|]
operator|<
name|UINT_MAX
operator|/
literal|100
condition|)
block|{
comment|/* 			 * There is no need to continue parsing input 			 * once the value exceeds the size of the 			 * terminal. It would only allow for integer 			 * overflows when performing arithmetic on the 			 * cursor position. 			 * 			 * Ignore any further digits if the value is 			 * already UINT_MAX / 100. 			 */
name|t
operator|->
name|t_nums
index|[
name|t
operator|->
name|t_curnum
index|]
operator|=
name|t
operator|->
name|t_nums
index|[
name|t
operator|->
name|t_curnum
index|]
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|t_stateflags
operator|&
name|TS_FIRSTDIGIT
condition|)
name|t
operator|->
name|t_nums
index|[
name|t
operator|->
name|t_curnum
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Only allow a limited set of arguments. */
if|if
condition|(
operator|++
name|t
operator|->
name|t_curnum
operator|==
name|T_NUMSIZE
condition|)
block|{
name|teken_state_switch
argument_list|(
name|t
argument_list|,
name|teken_state_init
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|t
operator|->
name|t_stateflags
operator||=
name|TS_FIRSTDIGIT
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|t
operator|->
name|t_stateflags
operator|&
name|TS_FIRSTDIGIT
operator|&&
name|t
operator|->
name|t_curnum
operator|>
literal|0
condition|)
block|{
comment|/* Finish off the last empty argument. */
name|t
operator|->
name|t_nums
index|[
name|t
operator|->
name|t_curnum
index|]
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|t_curnum
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|t
operator|->
name|t_stateflags
operator|&
name|TS_FIRSTDIGIT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Also count the last argument. */
name|t
operator|->
name|t_curnum
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|k
value|TC_BLACK
end_define

begin_define
define|#
directive|define
name|b
value|TC_BLUE
end_define

begin_define
define|#
directive|define
name|y
value|TC_BROWN
end_define

begin_define
define|#
directive|define
name|c
value|TC_CYAN
end_define

begin_define
define|#
directive|define
name|g
value|TC_GREEN
end_define

begin_define
define|#
directive|define
name|m
value|TC_MAGENTA
end_define

begin_define
define|#
directive|define
name|r
value|TC_RED
end_define

begin_define
define|#
directive|define
name|w
value|TC_WHITE
end_define

begin_define
define|#
directive|define
name|K
value|(TC_BLACK | TC_LIGHT)
end_define

begin_define
define|#
directive|define
name|B
value|(TC_BLUE | TC_LIGHT)
end_define

begin_define
define|#
directive|define
name|Y
value|(TC_BROWN | TC_LIGHT)
end_define

begin_define
define|#
directive|define
name|C
value|(TC_CYAN | TC_LIGHT)
end_define

begin_define
define|#
directive|define
name|G
value|(TC_GREEN | TC_LIGHT)
end_define

begin_define
define|#
directive|define
name|M
value|(TC_MAGENTA | TC_LIGHT)
end_define

begin_define
define|#
directive|define
name|R
value|(TC_RED | TC_LIGHT)
end_define

begin_define
define|#
directive|define
name|W
value|(TC_WHITE | TC_LIGHT)
end_define

begin_comment
comment|/**  * The xterm-256 color map has steps of 0x28 (in the range 0-0xff), except  * for the first step which is 0x5f.  Scale to the range 0-6 by dividing  * by 0x28 and rounding down.  The range of 0-5 cannot represent the  * larger first step.  *  * This table is generated by the follow rules:  * - if all components are equal, the result is black for (0, 0, 0) and  *   (2, 2, 2), else white; otherwise:  * - subtract the smallest component from all components  * - if this gives only one nonzero component, then that is the color  * - else if one component is 2 or more larger than the other nonzero one,  *   then that component gives the color  * - else there are 2 nonzero components.  The color is that of a small  *   equal mixture of these components (cyan, yellow or magenta).  E.g.,  *   (0, 5, 6) (Turquoise2) is a much purer cyan than (0, 2, 3)  *   (DeepSkyBlue4), but we map both to cyan since we can't represent  *   delicate shades of either blue or cyan and blue would be worse.  *   Here it is important that components of 1 never occur.  Blue would  *   be twice as large as green in (0, 1, 2).  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|teken_color_t
name|teken_256to8tab
index|[]
init|=
block|{
comment|/* xterm normal colors: */
name|k
block|,
name|r
block|,
name|g
block|,
name|y
block|,
name|b
block|,
name|m
block|,
name|c
block|,
name|w
block|,
comment|/* xterm bright colors: */
name|k
block|,
name|r
block|,
name|g
block|,
name|y
block|,
name|b
block|,
name|m
block|,
name|c
block|,
name|w
block|,
comment|/* Red0 submap. */
name|k
block|,
name|b
block|,
name|b
block|,
name|b
block|,
name|b
block|,
name|b
block|,
name|g
block|,
name|c
block|,
name|c
block|,
name|b
block|,
name|b
block|,
name|b
block|,
name|g
block|,
name|c
block|,
name|c
block|,
name|c
block|,
name|b
block|,
name|b
block|,
name|g
block|,
name|g
block|,
name|c
block|,
name|c
block|,
name|c
block|,
name|b
block|,
name|g
block|,
name|g
block|,
name|g
block|,
name|c
block|,
name|c
block|,
name|c
block|,
name|g
block|,
name|g
block|,
name|g
block|,
name|g
block|,
name|c
block|,
name|c
block|,
comment|/* Red2 submap. */
name|r
block|,
name|m
block|,
name|m
block|,
name|b
block|,
name|b
block|,
name|b
block|,
name|y
block|,
name|k
block|,
name|b
block|,
name|b
block|,
name|b
block|,
name|b
block|,
name|y
block|,
name|g
block|,
name|c
block|,
name|c
block|,
name|b
block|,
name|b
block|,
name|g
block|,
name|g
block|,
name|c
block|,
name|c
block|,
name|c
block|,
name|b
block|,
name|g
block|,
name|g
block|,
name|g
block|,
name|c
block|,
name|c
block|,
name|c
block|,
name|g
block|,
name|g
block|,
name|g
block|,
name|g
block|,
name|c
block|,
name|c
block|,
comment|/* Red3 submap. */
name|r
block|,
name|m
block|,
name|m
block|,
name|m
block|,
name|b
block|,
name|b
block|,
name|y
block|,
name|r
block|,
name|m
block|,
name|m
block|,
name|b
block|,
name|b
block|,
name|y
block|,
name|y
block|,
name|w
block|,
name|b
block|,
name|b
block|,
name|b
block|,
name|y
block|,
name|y
block|,
name|g
block|,
name|c
block|,
name|c
block|,
name|b
block|,
name|g
block|,
name|g
block|,
name|g
block|,
name|c
block|,
name|c
block|,
name|c
block|,
name|g
block|,
name|g
block|,
name|g
block|,
name|g
block|,
name|c
block|,
name|c
block|,
comment|/* Red4 submap. */
name|r
block|,
name|r
block|,
name|m
block|,
name|m
block|,
name|m
block|,
name|b
block|,
name|r
block|,
name|r
block|,
name|m
block|,
name|m
block|,
name|m
block|,
name|b
block|,
name|y
block|,
name|y
block|,
name|r
block|,
name|m
block|,
name|m
block|,
name|b
block|,
name|y
block|,
name|y
block|,
name|y
block|,
name|w
block|,
name|b
block|,
name|b
block|,
name|y
block|,
name|y
block|,
name|y
block|,
name|g
block|,
name|c
block|,
name|c
block|,
name|g
block|,
name|g
block|,
name|g
block|,
name|g
block|,
name|c
block|,
name|c
block|,
comment|/* Red5 submap. */
name|r
block|,
name|r
block|,
name|r
block|,
name|m
block|,
name|m
block|,
name|m
block|,
name|r
block|,
name|r
block|,
name|r
block|,
name|m
block|,
name|m
block|,
name|m
block|,
name|r
block|,
name|r
block|,
name|r
block|,
name|m
block|,
name|m
block|,
name|m
block|,
name|y
block|,
name|y
block|,
name|y
block|,
name|r
block|,
name|m
block|,
name|m
block|,
name|y
block|,
name|y
block|,
name|y
block|,
name|y
block|,
name|w
block|,
name|b
block|,
name|y
block|,
name|y
block|,
name|y
block|,
name|y
block|,
name|g
block|,
name|c
block|,
comment|/* Red6 submap. */
name|r
block|,
name|r
block|,
name|r
block|,
name|r
block|,
name|m
block|,
name|m
block|,
name|r
block|,
name|r
block|,
name|r
block|,
name|r
block|,
name|m
block|,
name|m
block|,
name|r
block|,
name|r
block|,
name|r
block|,
name|r
block|,
name|m
block|,
name|m
block|,
name|r
block|,
name|r
block|,
name|r
block|,
name|r
block|,
name|m
block|,
name|m
block|,
name|y
block|,
name|y
block|,
name|y
block|,
name|y
block|,
name|r
block|,
name|m
block|,
name|y
block|,
name|y
block|,
name|y
block|,
name|y
block|,
name|y
block|,
name|w
block|,
comment|/* Grey submap. */
name|k
block|,
name|k
block|,
name|k
block|,
name|k
block|,
name|k
block|,
name|k
block|,
name|k
block|,
name|k
block|,
name|k
block|,
name|k
block|,
name|k
block|,
name|k
block|,
name|w
block|,
name|w
block|,
name|w
block|,
name|w
block|,
name|w
block|,
name|w
block|,
name|w
block|,
name|w
block|,
name|w
block|,
name|w
block|,
name|w
block|,
name|w
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This table is generated from the previous one by setting TC_LIGHT for  * entries whose luminosity in the xterm256 color map is 60% or larger.  * Thus the previous table is currently not really needed.  It will be  * used for different fine tuning of the tables.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|teken_color_t
name|teken_256to16tab
index|[]
init|=
block|{
comment|/* xterm normal colors: */
name|k
block|,
name|r
block|,
name|g
block|,
name|y
block|,
name|b
block|,
name|m
block|,
name|c
block|,
name|w
block|,
comment|/* xterm bright colors: */
name|K
block|,
name|R
block|,
name|G
block|,
name|Y
block|,
name|B
block|,
name|M
block|,
name|C
block|,
name|W
block|,
comment|/* Red0 submap. */
name|k
block|,
name|b
block|,
name|b
block|,
name|b
block|,
name|b
block|,
name|b
block|,
name|g
block|,
name|c
block|,
name|c
block|,
name|b
block|,
name|b
block|,
name|b
block|,
name|g
block|,
name|c
block|,
name|c
block|,
name|c
block|,
name|b
block|,
name|b
block|,
name|g
block|,
name|g
block|,
name|c
block|,
name|c
block|,
name|c
block|,
name|b
block|,
name|g
block|,
name|g
block|,
name|g
block|,
name|c
block|,
name|c
block|,
name|c
block|,
name|g
block|,
name|g
block|,
name|g
block|,
name|g
block|,
name|c
block|,
name|c
block|,
comment|/* Red2 submap. */
name|r
block|,
name|m
block|,
name|m
block|,
name|b
block|,
name|b
block|,
name|b
block|,
name|y
block|,
name|K
block|,
name|b
block|,
name|b
block|,
name|B
block|,
name|B
block|,
name|y
block|,
name|g
block|,
name|c
block|,
name|c
block|,
name|B
block|,
name|B
block|,
name|g
block|,
name|g
block|,
name|c
block|,
name|c
block|,
name|C
block|,
name|B
block|,
name|g
block|,
name|G
block|,
name|G
block|,
name|C
block|,
name|C
block|,
name|C
block|,
name|g
block|,
name|G
block|,
name|G
block|,
name|G
block|,
name|C
block|,
name|C
block|,
comment|/* Red3 submap. */
name|r
block|,
name|m
block|,
name|m
block|,
name|m
block|,
name|b
block|,
name|b
block|,
name|y
block|,
name|r
block|,
name|m
block|,
name|m
block|,
name|B
block|,
name|B
block|,
name|y
block|,
name|y
block|,
name|w
block|,
name|B
block|,
name|B
block|,
name|B
block|,
name|y
block|,
name|y
block|,
name|G
block|,
name|C
block|,
name|C
block|,
name|B
block|,
name|g
block|,
name|G
block|,
name|G
block|,
name|C
block|,
name|C
block|,
name|C
block|,
name|g
block|,
name|G
block|,
name|G
block|,
name|G
block|,
name|C
block|,
name|C
block|,
comment|/* Red4 submap. */
name|r
block|,
name|r
block|,
name|m
block|,
name|m
block|,
name|m
block|,
name|b
block|,
name|r
block|,
name|r
block|,
name|m
block|,
name|m
block|,
name|M
block|,
name|B
block|,
name|y
block|,
name|y
block|,
name|R
block|,
name|M
block|,
name|M
block|,
name|B
block|,
name|y
block|,
name|y
block|,
name|Y
block|,
name|W
block|,
name|B
block|,
name|B
block|,
name|y
block|,
name|Y
block|,
name|Y
block|,
name|G
block|,
name|C
block|,
name|C
block|,
name|g
block|,
name|G
block|,
name|G
block|,
name|G
block|,
name|C
block|,
name|C
block|,
comment|/* Red5 submap. */
name|r
block|,
name|r
block|,
name|r
block|,
name|m
block|,
name|m
block|,
name|m
block|,
name|r
block|,
name|R
block|,
name|R
block|,
name|M
block|,
name|M
block|,
name|M
block|,
name|r
block|,
name|R
block|,
name|R
block|,
name|M
block|,
name|M
block|,
name|M
block|,
name|y
block|,
name|Y
block|,
name|Y
block|,
name|R
block|,
name|M
block|,
name|M
block|,
name|y
block|,
name|Y
block|,
name|Y
block|,
name|Y
block|,
name|W
block|,
name|B
block|,
name|y
block|,
name|Y
block|,
name|Y
block|,
name|Y
block|,
name|G
block|,
name|C
block|,
comment|/* Red6 submap. */
name|r
block|,
name|r
block|,
name|r
block|,
name|r
block|,
name|m
block|,
name|m
block|,
name|r
block|,
name|R
block|,
name|R
block|,
name|R
block|,
name|M
block|,
name|M
block|,
name|r
block|,
name|R
block|,
name|R
block|,
name|R
block|,
name|M
block|,
name|M
block|,
name|r
block|,
name|R
block|,
name|R
block|,
name|R
block|,
name|M
block|,
name|M
block|,
name|y
block|,
name|Y
block|,
name|Y
block|,
name|Y
block|,
name|R
block|,
name|M
block|,
name|y
block|,
name|Y
block|,
name|Y
block|,
name|Y
block|,
name|Y
block|,
name|W
block|,
comment|/* Grey submap. */
name|k
block|,
name|k
block|,
name|k
block|,
name|k
block|,
name|k
block|,
name|k
block|,
name|K
block|,
name|K
block|,
name|K
block|,
name|K
block|,
name|K
block|,
name|K
block|,
name|w
block|,
name|w
block|,
name|w
block|,
name|w
block|,
name|w
block|,
name|w
block|,
name|W
block|,
name|W
block|,
name|W
block|,
name|W
block|,
name|W
block|,
name|W
block|, }
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|k
end_undef

begin_undef
undef|#
directive|undef
name|b
end_undef

begin_undef
undef|#
directive|undef
name|y
end_undef

begin_undef
undef|#
directive|undef
name|c
end_undef

begin_undef
undef|#
directive|undef
name|g
end_undef

begin_undef
undef|#
directive|undef
name|m
end_undef

begin_undef
undef|#
directive|undef
name|r
end_undef

begin_undef
undef|#
directive|undef
name|w
end_undef

begin_undef
undef|#
directive|undef
name|K
end_undef

begin_undef
undef|#
directive|undef
name|B
end_undef

begin_undef
undef|#
directive|undef
name|Y
end_undef

begin_undef
undef|#
directive|undef
name|C
end_undef

begin_undef
undef|#
directive|undef
name|G
end_undef

begin_undef
undef|#
directive|undef
name|M
end_undef

begin_undef
undef|#
directive|undef
name|R
end_undef

begin_undef
undef|#
directive|undef
name|W
end_undef

begin_function
name|teken_color_t
name|teken_256to8
parameter_list|(
name|teken_color_t
name|c
parameter_list|)
block|{
return|return
operator|(
name|teken_256to8tab
index|[
name|c
operator|%
literal|256
index|]
operator|)
return|;
block|}
end_function

begin_function
name|teken_color_t
name|teken_256to16
parameter_list|(
name|teken_color_t
name|c
parameter_list|)
block|{
return|return
operator|(
name|teken_256to16tab
index|[
name|c
operator|%
literal|256
index|]
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|special_strings_cons25
index|[]
init|=
block|{
index|[
name|TKEY_UP
index|]
operator|=
literal|"\x1B[A"
block|,
index|[
name|TKEY_DOWN
index|]
operator|=
literal|"\x1B[B"
block|,
index|[
name|TKEY_LEFT
index|]
operator|=
literal|"\x1B[D"
block|,
index|[
name|TKEY_RIGHT
index|]
operator|=
literal|"\x1B[C"
block|,
index|[
name|TKEY_HOME
index|]
operator|=
literal|"\x1B[H"
block|,
index|[
name|TKEY_END
index|]
operator|=
literal|"\x1B[F"
block|,
index|[
name|TKEY_INSERT
index|]
operator|=
literal|"\x1B[L"
block|,
index|[
name|TKEY_DELETE
index|]
operator|=
literal|"\x7F"
block|,
index|[
name|TKEY_PAGE_UP
index|]
operator|=
literal|"\x1B[I"
block|,
index|[
name|TKEY_PAGE_DOWN
index|]
operator|=
literal|"\x1B[G"
block|,
index|[
name|TKEY_F1
index|]
operator|=
literal|"\x1B[M"
block|,
index|[
name|TKEY_F2
index|]
operator|=
literal|"\x1B[N"
block|,
index|[
name|TKEY_F3
index|]
operator|=
literal|"\x1B[O"
block|,
index|[
name|TKEY_F4
index|]
operator|=
literal|"\x1B[P"
block|,
index|[
name|TKEY_F5
index|]
operator|=
literal|"\x1B[Q"
block|,
index|[
name|TKEY_F6
index|]
operator|=
literal|"\x1B[R"
block|,
index|[
name|TKEY_F7
index|]
operator|=
literal|"\x1B[S"
block|,
index|[
name|TKEY_F8
index|]
operator|=
literal|"\x1B[T"
block|,
index|[
name|TKEY_F9
index|]
operator|=
literal|"\x1B[U"
block|,
index|[
name|TKEY_F10
index|]
operator|=
literal|"\x1B[V"
block|,
index|[
name|TKEY_F11
index|]
operator|=
literal|"\x1B[W"
block|,
index|[
name|TKEY_F12
index|]
operator|=
literal|"\x1B[X"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|special_strings_ckeys
index|[]
init|=
block|{
index|[
name|TKEY_UP
index|]
operator|=
literal|"\x1BOA"
block|,
index|[
name|TKEY_DOWN
index|]
operator|=
literal|"\x1BOB"
block|,
index|[
name|TKEY_LEFT
index|]
operator|=
literal|"\x1BOD"
block|,
index|[
name|TKEY_RIGHT
index|]
operator|=
literal|"\x1BOC"
block|,
index|[
name|TKEY_HOME
index|]
operator|=
literal|"\x1BOH"
block|,
index|[
name|TKEY_END
index|]
operator|=
literal|"\x1BOF"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|special_strings_normal
index|[]
init|=
block|{
index|[
name|TKEY_UP
index|]
operator|=
literal|"\x1B[A"
block|,
index|[
name|TKEY_DOWN
index|]
operator|=
literal|"\x1B[B"
block|,
index|[
name|TKEY_LEFT
index|]
operator|=
literal|"\x1B[D"
block|,
index|[
name|TKEY_RIGHT
index|]
operator|=
literal|"\x1B[C"
block|,
index|[
name|TKEY_HOME
index|]
operator|=
literal|"\x1B[H"
block|,
index|[
name|TKEY_END
index|]
operator|=
literal|"\x1B[F"
block|,
index|[
name|TKEY_INSERT
index|]
operator|=
literal|"\x1B[2~"
block|,
index|[
name|TKEY_DELETE
index|]
operator|=
literal|"\x1B[3~"
block|,
index|[
name|TKEY_PAGE_UP
index|]
operator|=
literal|"\x1B[5~"
block|,
index|[
name|TKEY_PAGE_DOWN
index|]
operator|=
literal|"\x1B[6~"
block|,
index|[
name|TKEY_F1
index|]
operator|=
literal|"\x1BOP"
block|,
index|[
name|TKEY_F2
index|]
operator|=
literal|"\x1BOQ"
block|,
index|[
name|TKEY_F3
index|]
operator|=
literal|"\x1BOR"
block|,
index|[
name|TKEY_F4
index|]
operator|=
literal|"\x1BOS"
block|,
index|[
name|TKEY_F5
index|]
operator|=
literal|"\x1B[15~"
block|,
index|[
name|TKEY_F6
index|]
operator|=
literal|"\x1B[17~"
block|,
index|[
name|TKEY_F7
index|]
operator|=
literal|"\x1B[18~"
block|,
index|[
name|TKEY_F8
index|]
operator|=
literal|"\x1B[19~"
block|,
index|[
name|TKEY_F9
index|]
operator|=
literal|"\x1B[20~"
block|,
index|[
name|TKEY_F10
index|]
operator|=
literal|"\x1B[21~"
block|,
index|[
name|TKEY_F11
index|]
operator|=
literal|"\x1B[23~"
block|,
index|[
name|TKEY_F12
index|]
operator|=
literal|"\x1B[24~"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|teken_get_sequence
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
name|unsigned
name|int
name|k
parameter_list|)
block|{
comment|/* Cons25 mode. */
if|if
condition|(
name|t
operator|->
name|t_stateflags
operator|&
name|TS_CONS25
operator|&&
name|k
operator|<
sizeof|sizeof
name|special_strings_cons25
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
condition|)
return|return
operator|(
name|special_strings_cons25
index|[
name|k
index|]
operator|)
return|;
comment|/* Cursor keys mode. */
if|if
condition|(
name|t
operator|->
name|t_stateflags
operator|&
name|TS_CURSORKEYS
operator|&&
name|k
operator|<
sizeof|sizeof
name|special_strings_ckeys
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
condition|)
return|return
operator|(
name|special_strings_ckeys
index|[
name|k
index|]
operator|)
return|;
comment|/* Default xterm sequences. */
if|if
condition|(
name|k
operator|<
sizeof|sizeof
name|special_strings_normal
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
condition|)
return|return
operator|(
name|special_strings_normal
index|[
name|k
index|]
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"teken_state.h"
end_include

end_unit

