begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008-2009 Ed Schouten<ed@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_define
define|#
directive|define
name|teken_assert
parameter_list|(
name|x
parameter_list|)
value|MPASS(x)
end_define

begin_define
define|#
directive|define
name|teken_printf
parameter_list|(
name|x
parameter_list|,
modifier|...
parameter_list|)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !(__FreeBSD__&& _KERNEL) */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_define
define|#
directive|define
name|teken_assert
parameter_list|(
name|x
parameter_list|)
value|assert(x)
end_define

begin_define
define|#
directive|define
name|teken_printf
parameter_list|(
name|x
parameter_list|,
modifier|...
parameter_list|)
value|do { \ 	if (df != NULL) \ 		fprintf(df, x, ## __VA_ARGS__); \ } while (0)
end_define

begin_comment
comment|/* debug messages */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|df
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__&& _KERNEL */
end_comment

begin_comment
comment|/* Private flags for t_stateflags. */
end_comment

begin_define
define|#
directive|define
name|TS_FIRSTDIGIT
value|0x0001
end_define

begin_comment
comment|/* First numeric digit in escape sequence. */
end_comment

begin_define
define|#
directive|define
name|TS_INSERT
value|0x0002
end_define

begin_comment
comment|/* Insert mode. */
end_comment

begin_define
define|#
directive|define
name|TS_AUTOWRAP
value|0x0004
end_define

begin_comment
comment|/* Autowrap. */
end_comment

begin_define
define|#
directive|define
name|TS_ORIGIN
value|0x0008
end_define

begin_comment
comment|/* Origin mode. */
end_comment

begin_define
define|#
directive|define
name|TS_WRAPPED
value|0x0010
end_define

begin_comment
comment|/* Next character should be printed on col 0. */
end_comment

begin_define
define|#
directive|define
name|TS_8BIT
value|0x0020
end_define

begin_comment
comment|/* UTF-8 disabled. */
end_comment

begin_define
define|#
directive|define
name|TS_CONS25
value|0x0040
end_define

begin_comment
comment|/* cons25 emulation. */
end_comment

begin_define
define|#
directive|define
name|TS_INSTRING
value|0x0080
end_define

begin_comment
comment|/* Inside string. */
end_comment

begin_define
define|#
directive|define
name|TS_CURSORKEYS
value|0x0100
end_define

begin_comment
comment|/* Cursor keys mode. */
end_comment

begin_comment
comment|/* Character that blanks a cell. */
end_comment

begin_define
define|#
directive|define
name|BLANK
value|' '
end_define

begin_include
include|#
directive|include
file|"teken.h"
end_include

begin_include
include|#
directive|include
file|"teken_wcwidth.h"
end_include

begin_include
include|#
directive|include
file|"teken_scs.h"
end_include

begin_decl_stmt
specifier|static
name|teken_state_t
name|teken_state_init
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Wrappers for hooks.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|teken_funcs_bell
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|)
block|{
name|t
operator|->
name|t_funcs
operator|->
name|tf_bell
argument_list|(
name|t
operator|->
name|t_softc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|teken_funcs_cursor
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|)
block|{
name|teken_assert
argument_list|(
name|t
operator|->
name|t_cursor
operator|.
name|tp_row
operator|<
name|t
operator|->
name|t_winsize
operator|.
name|tp_row
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|t
operator|->
name|t_cursor
operator|.
name|tp_col
operator|<
name|t
operator|->
name|t_winsize
operator|.
name|tp_col
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_funcs
operator|->
name|tf_cursor
argument_list|(
name|t
operator|->
name|t_softc
argument_list|,
operator|&
name|t
operator|->
name|t_cursor
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|teken_funcs_putchar
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
specifier|const
name|teken_pos_t
modifier|*
name|p
parameter_list|,
name|teken_char_t
name|c
parameter_list|,
specifier|const
name|teken_attr_t
modifier|*
name|a
parameter_list|)
block|{
name|teken_assert
argument_list|(
name|p
operator|->
name|tp_row
operator|<
name|t
operator|->
name|t_winsize
operator|.
name|tp_row
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|p
operator|->
name|tp_col
operator|<
name|t
operator|->
name|t_winsize
operator|.
name|tp_col
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_funcs
operator|->
name|tf_putchar
argument_list|(
name|t
operator|->
name|t_softc
argument_list|,
name|p
argument_list|,
name|c
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|teken_funcs_fill
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
specifier|const
name|teken_rect_t
modifier|*
name|r
parameter_list|,
specifier|const
name|teken_char_t
name|c
parameter_list|,
specifier|const
name|teken_attr_t
modifier|*
name|a
parameter_list|)
block|{
name|teken_assert
argument_list|(
name|r
operator|->
name|tr_end
operator|.
name|tp_row
operator|>
name|r
operator|->
name|tr_begin
operator|.
name|tp_row
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|r
operator|->
name|tr_end
operator|.
name|tp_row
operator|<=
name|t
operator|->
name|t_winsize
operator|.
name|tp_row
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|r
operator|->
name|tr_end
operator|.
name|tp_col
operator|>
name|r
operator|->
name|tr_begin
operator|.
name|tp_col
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|r
operator|->
name|tr_end
operator|.
name|tp_col
operator|<=
name|t
operator|->
name|t_winsize
operator|.
name|tp_col
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_funcs
operator|->
name|tf_fill
argument_list|(
name|t
operator|->
name|t_softc
argument_list|,
name|r
argument_list|,
name|c
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|teken_funcs_copy
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
specifier|const
name|teken_rect_t
modifier|*
name|r
parameter_list|,
specifier|const
name|teken_pos_t
modifier|*
name|p
parameter_list|)
block|{
name|teken_assert
argument_list|(
name|r
operator|->
name|tr_end
operator|.
name|tp_row
operator|>
name|r
operator|->
name|tr_begin
operator|.
name|tp_row
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|r
operator|->
name|tr_end
operator|.
name|tp_row
operator|<=
name|t
operator|->
name|t_winsize
operator|.
name|tp_row
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|r
operator|->
name|tr_end
operator|.
name|tp_col
operator|>
name|r
operator|->
name|tr_begin
operator|.
name|tp_col
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|r
operator|->
name|tr_end
operator|.
name|tp_col
operator|<=
name|t
operator|->
name|t_winsize
operator|.
name|tp_col
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|p
operator|->
name|tp_row
operator|+
operator|(
name|r
operator|->
name|tr_end
operator|.
name|tp_row
operator|-
name|r
operator|->
name|tr_begin
operator|.
name|tp_row
operator|)
operator|<=
name|t
operator|->
name|t_winsize
operator|.
name|tp_row
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|p
operator|->
name|tp_col
operator|+
operator|(
name|r
operator|->
name|tr_end
operator|.
name|tp_col
operator|-
name|r
operator|->
name|tr_begin
operator|.
name|tp_col
operator|)
operator|<=
name|t
operator|->
name|t_winsize
operator|.
name|tp_col
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_funcs
operator|->
name|tf_copy
argument_list|(
name|t
operator|->
name|t_softc
argument_list|,
name|r
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|teken_funcs_param
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
name|int
name|cmd
parameter_list|,
name|unsigned
name|int
name|value
parameter_list|)
block|{
name|t
operator|->
name|t_funcs
operator|->
name|tf_param
argument_list|(
name|t
operator|->
name|t_softc
argument_list|,
name|cmd
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|teken_funcs_respond
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|t
operator|->
name|t_funcs
operator|->
name|tf_respond
argument_list|(
name|t
operator|->
name|t_softc
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"teken_subr.h"
end_include

begin_include
include|#
directive|include
file|"teken_subr_compat.h"
end_include

begin_comment
comment|/*  * Programming interface.  */
end_comment

begin_function
name|void
name|teken_init
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
specifier|const
name|teken_funcs_t
modifier|*
name|tf
parameter_list|,
name|void
modifier|*
name|softc
parameter_list|)
block|{
name|teken_pos_t
name|tp
init|=
block|{
operator|.
name|tp_row
operator|=
literal|24
block|,
operator|.
name|tp_col
operator|=
literal|80
block|}
decl_stmt|;
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|)
name|df
operator|=
name|fopen
argument_list|(
literal|"teken.log"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|df
operator|!=
name|NULL
condition|)
name|setvbuf
argument_list|(
name|df
argument_list|,
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !(__FreeBSD__&& _KERNEL) */
name|t
operator|->
name|t_funcs
operator|=
name|tf
expr_stmt|;
name|t
operator|->
name|t_softc
operator|=
name|softc
expr_stmt|;
name|t
operator|->
name|t_nextstate
operator|=
name|teken_state_init
expr_stmt|;
name|t
operator|->
name|t_stateflags
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|t_utf8_left
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|t_defattr
operator|.
name|ta_format
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|t_defattr
operator|.
name|ta_fgcolor
operator|=
name|TC_WHITE
expr_stmt|;
name|t
operator|->
name|t_defattr
operator|.
name|ta_bgcolor
operator|=
name|TC_BLACK
expr_stmt|;
name|teken_subr_do_reset
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|teken_set_winsize
argument_list|(
name|t
argument_list|,
operator|&
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|teken_input_char
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
name|teken_char_t
name|c
parameter_list|)
block|{
comment|/* 	 * There is no support for DCS and OSC.  Just discard strings 	 * until we receive characters that may indicate string 	 * termination. 	 */
if|if
condition|(
name|t
operator|->
name|t_stateflags
operator|&
name|TS_INSTRING
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\x1B'
case|:
name|t
operator|->
name|t_stateflags
operator|&=
operator|~
name|TS_INSTRING
expr_stmt|;
break|break;
case|case
literal|'\a'
case|:
name|t
operator|->
name|t_stateflags
operator|&=
operator|~
name|TS_INSTRING
expr_stmt|;
return|return;
default|default:
return|return;
block|}
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\0'
case|:
break|break;
case|case
literal|'\a'
case|:
name|teken_subr_bell
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
name|teken_subr_backspace
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
case|case
literal|'\x0B'
case|:
name|teken_subr_newline
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\x0C'
case|:
name|teken_subr_newpage
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\x0E'
case|:
if|if
condition|(
name|t
operator|->
name|t_stateflags
operator|&
name|TS_CONS25
condition|)
name|t
operator|->
name|t_nextstate
argument_list|(
name|t
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|t
operator|->
name|t_curscs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'\x0F'
case|:
if|if
condition|(
name|t
operator|->
name|t_stateflags
operator|&
name|TS_CONS25
condition|)
name|t
operator|->
name|t_nextstate
argument_list|(
name|t
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
name|t
operator|->
name|t_curscs
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|teken_subr_carriage_return
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
name|teken_subr_horizontal_tab
argument_list|(
name|t
argument_list|)
expr_stmt|;
break|break;
default|default:
name|t
operator|->
name|t_nextstate
argument_list|(
name|t
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Post-processing assertions. */
name|teken_assert
argument_list|(
name|t
operator|->
name|t_cursor
operator|.
name|tp_row
operator|>=
name|t
operator|->
name|t_originreg
operator|.
name|ts_begin
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|t
operator|->
name|t_cursor
operator|.
name|tp_row
operator|<
name|t
operator|->
name|t_originreg
operator|.
name|ts_end
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|t
operator|->
name|t_cursor
operator|.
name|tp_row
operator|<
name|t
operator|->
name|t_winsize
operator|.
name|tp_row
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|t
operator|->
name|t_cursor
operator|.
name|tp_col
operator|<
name|t
operator|->
name|t_winsize
operator|.
name|tp_col
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|t
operator|->
name|t_saved_cursor
operator|.
name|tp_row
operator|<
name|t
operator|->
name|t_winsize
operator|.
name|tp_row
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|t
operator|->
name|t_saved_cursor
operator|.
name|tp_col
operator|<
name|t
operator|->
name|t_winsize
operator|.
name|tp_col
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|t
operator|->
name|t_scrollreg
operator|.
name|ts_end
operator|<=
name|t
operator|->
name|t_winsize
operator|.
name|tp_row
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|t
operator|->
name|t_scrollreg
operator|.
name|ts_begin
operator|<
name|t
operator|->
name|t_scrollreg
operator|.
name|ts_end
argument_list|)
expr_stmt|;
comment|/* Origin region has to be window size or the same as scrollreg. */
name|teken_assert
argument_list|(
operator|(
name|t
operator|->
name|t_originreg
operator|.
name|ts_begin
operator|==
name|t
operator|->
name|t_scrollreg
operator|.
name|ts_begin
operator|&&
name|t
operator|->
name|t_originreg
operator|.
name|ts_end
operator|==
name|t
operator|->
name|t_scrollreg
operator|.
name|ts_end
operator|)
operator|||
operator|(
name|t
operator|->
name|t_originreg
operator|.
name|ts_begin
operator|==
literal|0
operator|&&
name|t
operator|->
name|t_originreg
operator|.
name|ts_end
operator|==
name|t
operator|->
name|t_winsize
operator|.
name|tp_row
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|teken_input_byte
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
name|unsigned
name|char
name|c
parameter_list|)
block|{
comment|/* 	 * UTF-8 handling. 	 */
if|if
condition|(
operator|(
name|c
operator|&
literal|0x80
operator|)
operator|==
literal|0x00
operator|||
name|t
operator|->
name|t_stateflags
operator|&
name|TS_8BIT
condition|)
block|{
comment|/* One-byte sequence. */
name|t
operator|->
name|t_utf8_left
operator|=
literal|0
expr_stmt|;
name|teken_input_char
argument_list|(
name|t
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|&
literal|0xe0
operator|)
operator|==
literal|0xc0
condition|)
block|{
comment|/* Two-byte sequence. */
name|t
operator|->
name|t_utf8_left
operator|=
literal|1
expr_stmt|;
name|t
operator|->
name|t_utf8_partial
operator|=
name|c
operator|&
literal|0x1f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|&
literal|0xf0
operator|)
operator|==
literal|0xe0
condition|)
block|{
comment|/* Three-byte sequence. */
name|t
operator|->
name|t_utf8_left
operator|=
literal|2
expr_stmt|;
name|t
operator|->
name|t_utf8_partial
operator|=
name|c
operator|&
literal|0x0f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|&
literal|0xf8
operator|)
operator|==
literal|0xf0
condition|)
block|{
comment|/* Four-byte sequence. */
name|t
operator|->
name|t_utf8_left
operator|=
literal|3
expr_stmt|;
name|t
operator|->
name|t_utf8_partial
operator|=
name|c
operator|&
literal|0x07
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|c
operator|&
literal|0xc0
operator|)
operator|==
literal|0x80
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|t_utf8_left
operator|==
literal|0
condition|)
return|return;
name|t
operator|->
name|t_utf8_left
operator|--
expr_stmt|;
name|t
operator|->
name|t_utf8_partial
operator|=
operator|(
name|t
operator|->
name|t_utf8_partial
operator|<<
literal|6
operator|)
operator||
operator|(
name|c
operator|&
literal|0x3f
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|t_utf8_left
operator|==
literal|0
condition|)
block|{
name|teken_printf
argument_list|(
literal|"Got UTF-8 char %x\n"
argument_list|,
name|t
operator|->
name|t_utf8_partial
argument_list|)
expr_stmt|;
name|teken_input_char
argument_list|(
name|t
argument_list|,
name|t
operator|->
name|t_utf8_partial
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|teken_input
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|c
init|=
name|buf
decl_stmt|;
while|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
name|teken_input_byte
argument_list|(
name|t
argument_list|,
operator|*
name|c
operator|++
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|teken_pos_t
modifier|*
name|teken_get_cursor
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|)
block|{
return|return
operator|(
operator|&
name|t
operator|->
name|t_cursor
operator|)
return|;
block|}
end_function

begin_function
name|void
name|teken_set_cursor
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
specifier|const
name|teken_pos_t
modifier|*
name|p
parameter_list|)
block|{
comment|/* XXX: bounds checking with originreg! */
name|teken_assert
argument_list|(
name|p
operator|->
name|tp_row
operator|<
name|t
operator|->
name|t_winsize
operator|.
name|tp_row
argument_list|)
expr_stmt|;
name|teken_assert
argument_list|(
name|p
operator|->
name|tp_col
operator|<
name|t
operator|->
name|t_winsize
operator|.
name|tp_col
argument_list|)
expr_stmt|;
name|t
operator|->
name|t_cursor
operator|=
operator|*
name|p
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|teken_attr_t
modifier|*
name|teken_get_curattr
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|)
block|{
return|return
operator|(
operator|&
name|t
operator|->
name|t_curattr
operator|)
return|;
block|}
end_function

begin_function
name|void
name|teken_set_curattr
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
specifier|const
name|teken_attr_t
modifier|*
name|a
parameter_list|)
block|{
name|t
operator|->
name|t_curattr
operator|=
operator|*
name|a
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|teken_attr_t
modifier|*
name|teken_get_defattr
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|)
block|{
return|return
operator|(
operator|&
name|t
operator|->
name|t_defattr
operator|)
return|;
block|}
end_function

begin_function
name|void
name|teken_set_defattr
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
specifier|const
name|teken_attr_t
modifier|*
name|a
parameter_list|)
block|{
name|t
operator|->
name|t_curattr
operator|=
name|t
operator|->
name|t_saved_curattr
operator|=
name|t
operator|->
name|t_defattr
operator|=
operator|*
name|a
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|teken_pos_t
modifier|*
name|teken_get_winsize
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|)
block|{
return|return
operator|(
operator|&
name|t
operator|->
name|t_winsize
operator|)
return|;
block|}
end_function

begin_function
name|void
name|teken_set_winsize
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
specifier|const
name|teken_pos_t
modifier|*
name|p
parameter_list|)
block|{
name|t
operator|->
name|t_winsize
operator|=
operator|*
name|p
expr_stmt|;
name|teken_subr_do_reset
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|teken_set_8bit
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|)
block|{
name|t
operator|->
name|t_stateflags
operator||=
name|TS_8BIT
expr_stmt|;
block|}
end_function

begin_function
name|void
name|teken_set_cons25
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|)
block|{
name|t
operator|->
name|t_stateflags
operator||=
name|TS_CONS25
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * State machine.  */
end_comment

begin_function
specifier|static
name|void
name|teken_state_switch
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
name|teken_state_t
modifier|*
name|s
parameter_list|)
block|{
name|t
operator|->
name|t_nextstate
operator|=
name|s
expr_stmt|;
name|t
operator|->
name|t_curnum
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|t_stateflags
operator||=
name|TS_FIRSTDIGIT
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|teken_state_numbers
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
name|teken_char_t
name|c
parameter_list|)
block|{
name|teken_assert
argument_list|(
name|t
operator|->
name|t_curnum
operator|<
name|T_NUMSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
comment|/* 		 * Don't do math with the default value of 1 when a 		 * custom number is inserted. 		 */
if|if
condition|(
name|t
operator|->
name|t_stateflags
operator|&
name|TS_FIRSTDIGIT
condition|)
block|{
name|t
operator|->
name|t_stateflags
operator|&=
operator|~
name|TS_FIRSTDIGIT
expr_stmt|;
name|t
operator|->
name|t_nums
index|[
name|t
operator|->
name|t_curnum
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|t
operator|->
name|t_nums
index|[
name|t
operator|->
name|t_curnum
index|]
operator|*=
literal|10
expr_stmt|;
block|}
name|t
operator|->
name|t_nums
index|[
name|t
operator|->
name|t_curnum
index|]
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|t_stateflags
operator|&
name|TS_FIRSTDIGIT
condition|)
name|t
operator|->
name|t_nums
index|[
name|t
operator|->
name|t_curnum
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Only allow a limited set of arguments. */
if|if
condition|(
operator|++
name|t
operator|->
name|t_curnum
operator|==
name|T_NUMSIZE
condition|)
block|{
name|teken_state_switch
argument_list|(
name|t
argument_list|,
name|teken_state_init
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|t
operator|->
name|t_stateflags
operator||=
name|TS_FIRSTDIGIT
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|t
operator|->
name|t_stateflags
operator|&
name|TS_FIRSTDIGIT
operator|&&
name|t
operator|->
name|t_curnum
operator|>
literal|0
condition|)
block|{
comment|/* Finish off the last empty argument. */
name|t
operator|->
name|t_nums
index|[
name|t
operator|->
name|t_curnum
index|]
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|t_curnum
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|t
operator|->
name|t_stateflags
operator|&
name|TS_FIRSTDIGIT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Also count the last argument. */
name|t
operator|->
name|t_curnum
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|teken_color_t
name|teken_256to8
parameter_list|(
name|teken_color_t
name|c
parameter_list|)
block|{
name|unsigned
name|int
name|r
decl_stmt|,
name|g
decl_stmt|,
name|b
decl_stmt|;
if|if
condition|(
name|c
operator|<
literal|16
condition|)
block|{
comment|/* Traditional color indices. */
return|return
operator|(
name|c
operator|%
literal|8
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|244
condition|)
block|{
comment|/* Upper grayscale colors. */
return|return
operator|(
name|TC_WHITE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
literal|232
condition|)
block|{
comment|/* Lower grayscale colors. */
return|return
operator|(
name|TC_BLACK
operator|)
return|;
block|}
comment|/* Convert to RGB. */
name|c
operator|-=
literal|16
expr_stmt|;
name|b
operator|=
name|c
operator|%
literal|6
expr_stmt|;
name|g
operator|=
operator|(
name|c
operator|/
literal|6
operator|)
operator|%
literal|6
expr_stmt|;
name|r
operator|=
name|c
operator|/
literal|36
expr_stmt|;
if|if
condition|(
name|r
operator|<
name|g
condition|)
block|{
comment|/* Possibly green. */
if|if
condition|(
name|g
operator|<
name|b
condition|)
return|return
operator|(
name|TC_BLUE
operator|)
return|;
elseif|else
if|if
condition|(
name|g
operator|>
name|b
condition|)
return|return
operator|(
name|TC_GREEN
operator|)
return|;
else|else
return|return
operator|(
name|TC_CYAN
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|>
name|g
condition|)
block|{
comment|/* Possibly red. */
if|if
condition|(
name|r
operator|<
name|b
condition|)
return|return
operator|(
name|TC_BLUE
operator|)
return|;
elseif|else
if|if
condition|(
name|r
operator|>
name|b
condition|)
return|return
operator|(
name|TC_RED
operator|)
return|;
else|else
return|return
operator|(
name|TC_MAGENTA
operator|)
return|;
block|}
else|else
block|{
comment|/* Possibly brown. */
if|if
condition|(
name|g
operator|<
name|b
condition|)
return|return
operator|(
name|TC_BLUE
operator|)
return|;
elseif|else
if|if
condition|(
name|g
operator|>
name|b
condition|)
return|return
operator|(
name|TC_BROWN
operator|)
return|;
elseif|else
if|if
condition|(
name|r
operator|<
literal|3
condition|)
return|return
operator|(
name|TC_BLACK
operator|)
return|;
else|else
return|return
operator|(
name|TC_WHITE
operator|)
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|special_strings_cons25
index|[]
init|=
block|{
index|[
name|TKEY_UP
index|]
operator|=
literal|"\x1B[A"
block|,
index|[
name|TKEY_DOWN
index|]
operator|=
literal|"\x1B[B"
block|,
index|[
name|TKEY_LEFT
index|]
operator|=
literal|"\x1B[D"
block|,
index|[
name|TKEY_RIGHT
index|]
operator|=
literal|"\x1B[C"
block|,
index|[
name|TKEY_HOME
index|]
operator|=
literal|"\x1B[H"
block|,
index|[
name|TKEY_END
index|]
operator|=
literal|"\x1B[F"
block|,
index|[
name|TKEY_INSERT
index|]
operator|=
literal|"\x1B[L"
block|,
index|[
name|TKEY_DELETE
index|]
operator|=
literal|"\x7F"
block|,
index|[
name|TKEY_PAGE_UP
index|]
operator|=
literal|"\x1B[I"
block|,
index|[
name|TKEY_PAGE_DOWN
index|]
operator|=
literal|"\x1B[G"
block|,
index|[
name|TKEY_F1
index|]
operator|=
literal|"\x1B[M"
block|,
index|[
name|TKEY_F2
index|]
operator|=
literal|"\x1B[N"
block|,
index|[
name|TKEY_F3
index|]
operator|=
literal|"\x1B[O"
block|,
index|[
name|TKEY_F4
index|]
operator|=
literal|"\x1B[P"
block|,
index|[
name|TKEY_F5
index|]
operator|=
literal|"\x1B[Q"
block|,
index|[
name|TKEY_F6
index|]
operator|=
literal|"\x1B[R"
block|,
index|[
name|TKEY_F7
index|]
operator|=
literal|"\x1B[S"
block|,
index|[
name|TKEY_F8
index|]
operator|=
literal|"\x1B[T"
block|,
index|[
name|TKEY_F9
index|]
operator|=
literal|"\x1B[U"
block|,
index|[
name|TKEY_F10
index|]
operator|=
literal|"\x1B[V"
block|,
index|[
name|TKEY_F11
index|]
operator|=
literal|"\x1B[W"
block|,
index|[
name|TKEY_F12
index|]
operator|=
literal|"\x1B[X"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|special_strings_ckeys
index|[]
init|=
block|{
index|[
name|TKEY_UP
index|]
operator|=
literal|"\x1BOA"
block|,
index|[
name|TKEY_DOWN
index|]
operator|=
literal|"\x1BOB"
block|,
index|[
name|TKEY_LEFT
index|]
operator|=
literal|"\x1BOD"
block|,
index|[
name|TKEY_RIGHT
index|]
operator|=
literal|"\x1BOC"
block|,
index|[
name|TKEY_HOME
index|]
operator|=
literal|"\x1BOH"
block|,
index|[
name|TKEY_END
index|]
operator|=
literal|"\x1BOF"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|special_strings_normal
index|[]
init|=
block|{
index|[
name|TKEY_UP
index|]
operator|=
literal|"\x1B[A"
block|,
index|[
name|TKEY_DOWN
index|]
operator|=
literal|"\x1B[B"
block|,
index|[
name|TKEY_LEFT
index|]
operator|=
literal|"\x1B[D"
block|,
index|[
name|TKEY_RIGHT
index|]
operator|=
literal|"\x1B[C"
block|,
index|[
name|TKEY_HOME
index|]
operator|=
literal|"\x1B[H"
block|,
index|[
name|TKEY_END
index|]
operator|=
literal|"\x1B[F"
block|,
index|[
name|TKEY_INSERT
index|]
operator|=
literal|"\x1B[2~"
block|,
index|[
name|TKEY_DELETE
index|]
operator|=
literal|"\x1B[3~"
block|,
index|[
name|TKEY_PAGE_UP
index|]
operator|=
literal|"\x1B[5~"
block|,
index|[
name|TKEY_PAGE_DOWN
index|]
operator|=
literal|"\x1B[6~"
block|,
index|[
name|TKEY_F1
index|]
operator|=
literal|"\x1BOP"
block|,
index|[
name|TKEY_F2
index|]
operator|=
literal|"\x1BOQ"
block|,
index|[
name|TKEY_F3
index|]
operator|=
literal|"\x1BOR"
block|,
index|[
name|TKEY_F4
index|]
operator|=
literal|"\x1BOS"
block|,
index|[
name|TKEY_F5
index|]
operator|=
literal|"\x1B[15~"
block|,
index|[
name|TKEY_F6
index|]
operator|=
literal|"\x1B[17~"
block|,
index|[
name|TKEY_F7
index|]
operator|=
literal|"\x1B[18~"
block|,
index|[
name|TKEY_F8
index|]
operator|=
literal|"\x1B[19~"
block|,
index|[
name|TKEY_F9
index|]
operator|=
literal|"\x1B[20~"
block|,
index|[
name|TKEY_F10
index|]
operator|=
literal|"\x1B[21~"
block|,
index|[
name|TKEY_F11
index|]
operator|=
literal|"\x1B[23~"
block|,
index|[
name|TKEY_F12
index|]
operator|=
literal|"\x1B[24~"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|teken_get_sequence
parameter_list|(
name|teken_t
modifier|*
name|t
parameter_list|,
name|unsigned
name|int
name|k
parameter_list|)
block|{
comment|/* Cons25 mode. */
if|if
condition|(
name|t
operator|->
name|t_stateflags
operator|&
name|TS_CONS25
operator|&&
name|k
operator|<
sizeof|sizeof
name|special_strings_cons25
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
condition|)
return|return
operator|(
name|special_strings_cons25
index|[
name|k
index|]
operator|)
return|;
comment|/* Cursor keys mode. */
if|if
condition|(
name|t
operator|->
name|t_stateflags
operator|&
name|TS_CURSORKEYS
operator|&&
name|k
operator|<
sizeof|sizeof
name|special_strings_ckeys
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
condition|)
return|return
operator|(
name|special_strings_ckeys
index|[
name|k
index|]
operator|)
return|;
comment|/* Default xterm sequences. */
if|if
condition|(
name|k
operator|<
sizeof|sizeof
name|special_strings_normal
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
condition|)
return|return
operator|(
name|special_strings_normal
index|[
name|k
index|]
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_include
include|#
directive|include
file|"teken_state.h"
end_include

end_unit

