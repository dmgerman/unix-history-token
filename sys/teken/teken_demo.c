begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008-2009 Ed Schouten<ed@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<ncurses.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__linux__
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<pty.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<util.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"teken.h"
end_include

begin_decl_stmt
specifier|static
name|tf_bell_t
name|test_bell
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tf_cursor_t
name|test_cursor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tf_putchar_t
name|test_putchar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tf_fill_t
name|test_fill
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tf_copy_t
name|test_copy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tf_param_t
name|test_param
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tf_respond_t
name|test_respond
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|teken_funcs_t
name|tf
init|=
block|{
operator|.
name|tf_bell
operator|=
name|test_bell
block|,
operator|.
name|tf_cursor
operator|=
name|test_cursor
block|,
operator|.
name|tf_putchar
operator|=
name|test_putchar
block|,
operator|.
name|tf_fill
operator|=
name|test_fill
block|,
operator|.
name|tf_copy
operator|=
name|test_copy
block|,
operator|.
name|tf_param
operator|=
name|test_param
block|,
operator|.
name|tf_respond
operator|=
name|test_respond
block|, }
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|pixel
block|{
name|teken_char_t
name|c
decl_stmt|;
name|teken_attr_t
name|a
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NCOLS
value|80
end_define

begin_define
define|#
directive|define
name|NROWS
value|24
end_define

begin_decl_stmt
name|struct
name|pixel
name|buffer
index|[
name|NCOLS
index|]
index|[
name|NROWS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ptfd
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|printchar
parameter_list|(
specifier|const
name|teken_pos_t
modifier|*
name|p
parameter_list|)
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|,
name|attr
init|=
literal|0
decl_stmt|;
name|struct
name|pixel
modifier|*
name|px
decl_stmt|;
name|char
name|str
index|[
literal|5
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|tp_row
operator|<
name|NROWS
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|tp_col
operator|<
name|NCOLS
argument_list|)
expr_stmt|;
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|px
operator|=
operator|&
name|buffer
index|[
name|p
operator|->
name|tp_col
index|]
index|[
name|p
operator|->
name|tp_row
index|]
expr_stmt|;
comment|/* Convert Unicode to UTF-8. */
if|if
condition|(
name|px
operator|->
name|c
operator|<
literal|0x80
condition|)
block|{
name|str
index|[
literal|0
index|]
operator|=
name|px
operator|->
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|px
operator|->
name|c
operator|<
literal|0x800
condition|)
block|{
name|str
index|[
literal|0
index|]
operator|=
literal|0xc0
operator||
operator|(
name|px
operator|->
name|c
operator|>>
literal|6
operator|)
expr_stmt|;
name|str
index|[
literal|1
index|]
operator|=
literal|0x80
operator||
operator|(
name|px
operator|->
name|c
operator|&
literal|0x3f
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|px
operator|->
name|c
operator|<
literal|0x10000
condition|)
block|{
name|str
index|[
literal|0
index|]
operator|=
literal|0xe0
operator||
operator|(
name|px
operator|->
name|c
operator|>>
literal|12
operator|)
expr_stmt|;
name|str
index|[
literal|1
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
name|px
operator|->
name|c
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|str
index|[
literal|2
index|]
operator|=
literal|0x80
operator||
operator|(
name|px
operator|->
name|c
operator|&
literal|0x3f
operator|)
expr_stmt|;
block|}
else|else
block|{
name|str
index|[
literal|0
index|]
operator|=
literal|0xf0
operator||
operator|(
name|px
operator|->
name|c
operator|>>
literal|18
operator|)
expr_stmt|;
name|str
index|[
literal|1
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
name|px
operator|->
name|c
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|str
index|[
literal|2
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
name|px
operator|->
name|c
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|str
index|[
literal|3
index|]
operator|=
literal|0x80
operator||
operator|(
name|px
operator|->
name|c
operator|&
literal|0x3f
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|px
operator|->
name|a
operator|.
name|ta_format
operator|&
name|TF_BOLD
condition|)
name|attr
operator||=
name|A_BOLD
expr_stmt|;
if|if
condition|(
name|px
operator|->
name|a
operator|.
name|ta_format
operator|&
name|TF_UNDERLINE
condition|)
name|attr
operator||=
name|A_UNDERLINE
expr_stmt|;
if|if
condition|(
name|px
operator|->
name|a
operator|.
name|ta_format
operator|&
name|TF_BLINK
condition|)
name|attr
operator||=
name|A_BLINK
expr_stmt|;
if|if
condition|(
name|px
operator|->
name|a
operator|.
name|ta_format
operator|&
name|TF_REVERSE
condition|)
name|attr
operator||=
name|A_REVERSE
expr_stmt|;
name|bkgdset
argument_list|(
name|attr
operator||
name|COLOR_PAIR
argument_list|(
name|teken_256to8
argument_list|(
name|px
operator|->
name|a
operator|.
name|ta_fgcolor
argument_list|)
operator|+
literal|8
operator|*
name|teken_256to8
argument_list|(
name|px
operator|->
name|a
operator|.
name|ta_bgcolor
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|p
operator|->
name|tp_row
argument_list|,
name|p
operator|->
name|tp_col
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_bell
parameter_list|(
name|void
modifier|*
name|s
name|__unused
parameter_list|)
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_cursor
parameter_list|(
name|void
modifier|*
name|s
name|__unused
parameter_list|,
specifier|const
name|teken_pos_t
modifier|*
name|p
parameter_list|)
block|{
name|move
argument_list|(
name|p
operator|->
name|tp_row
argument_list|,
name|p
operator|->
name|tp_col
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_putchar
parameter_list|(
name|void
modifier|*
name|s
name|__unused
parameter_list|,
specifier|const
name|teken_pos_t
modifier|*
name|p
parameter_list|,
name|teken_char_t
name|c
parameter_list|,
specifier|const
name|teken_attr_t
modifier|*
name|a
parameter_list|)
block|{
name|buffer
index|[
name|p
operator|->
name|tp_col
index|]
index|[
name|p
operator|->
name|tp_row
index|]
operator|.
name|c
operator|=
name|c
expr_stmt|;
name|buffer
index|[
name|p
operator|->
name|tp_col
index|]
index|[
name|p
operator|->
name|tp_row
index|]
operator|.
name|a
operator|=
operator|*
name|a
expr_stmt|;
name|printchar
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_fill
parameter_list|(
name|void
modifier|*
name|s
parameter_list|,
specifier|const
name|teken_rect_t
modifier|*
name|r
parameter_list|,
name|teken_char_t
name|c
parameter_list|,
specifier|const
name|teken_attr_t
modifier|*
name|a
parameter_list|)
block|{
name|teken_pos_t
name|p
decl_stmt|;
comment|/* Braindead implementation of fill() - just call putchar(). */
for|for
control|(
name|p
operator|.
name|tp_row
operator|=
name|r
operator|->
name|tr_begin
operator|.
name|tp_row
init|;
name|p
operator|.
name|tp_row
operator|<
name|r
operator|->
name|tr_end
operator|.
name|tp_row
condition|;
name|p
operator|.
name|tp_row
operator|++
control|)
for|for
control|(
name|p
operator|.
name|tp_col
operator|=
name|r
operator|->
name|tr_begin
operator|.
name|tp_col
init|;
name|p
operator|.
name|tp_col
operator|<
name|r
operator|->
name|tr_end
operator|.
name|tp_col
condition|;
name|p
operator|.
name|tp_col
operator|++
control|)
name|test_putchar
argument_list|(
name|s
argument_list|,
operator|&
name|p
argument_list|,
name|c
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|test_copy
parameter_list|(
name|void
modifier|*
name|s
name|__unused
parameter_list|,
specifier|const
name|teken_rect_t
modifier|*
name|r
parameter_list|,
specifier|const
name|teken_pos_t
modifier|*
name|p
parameter_list|)
block|{
name|int
name|nrow
decl_stmt|,
name|ncol
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|;
comment|/* Has to be signed ->= 0 comparison */
name|teken_pos_t
name|d
decl_stmt|;
comment|/* 	 * Copying is a little tricky. We must make sure we do it in 	 * correct order, to make sure we don't overwrite our own data. 	 */
name|nrow
operator|=
name|r
operator|->
name|tr_end
operator|.
name|tp_row
operator|-
name|r
operator|->
name|tr_begin
operator|.
name|tp_row
expr_stmt|;
name|ncol
operator|=
name|r
operator|->
name|tr_end
operator|.
name|tp_col
operator|-
name|r
operator|->
name|tr_begin
operator|.
name|tp_col
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|tp_row
operator|<
name|r
operator|->
name|tr_begin
operator|.
name|tp_row
condition|)
block|{
comment|/* Copy from top to bottom. */
if|if
condition|(
name|p
operator|->
name|tp_col
operator|<
name|r
operator|->
name|tr_begin
operator|.
name|tp_col
condition|)
block|{
comment|/* Copy from left to right. */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|nrow
condition|;
name|y
operator|++
control|)
block|{
name|d
operator|.
name|tp_row
operator|=
name|p
operator|->
name|tp_row
operator|+
name|y
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|ncol
condition|;
name|x
operator|++
control|)
block|{
name|d
operator|.
name|tp_col
operator|=
name|p
operator|->
name|tp_col
operator|+
name|x
expr_stmt|;
name|buffer
index|[
name|d
operator|.
name|tp_col
index|]
index|[
name|d
operator|.
name|tp_row
index|]
operator|=
name|buffer
index|[
name|r
operator|->
name|tr_begin
operator|.
name|tp_col
operator|+
name|x
index|]
index|[
name|r
operator|->
name|tr_begin
operator|.
name|tp_row
operator|+
name|y
index|]
expr_stmt|;
name|printchar
argument_list|(
operator|&
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Copy from right to left. */
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|nrow
condition|;
name|y
operator|++
control|)
block|{
name|d
operator|.
name|tp_row
operator|=
name|p
operator|->
name|tp_row
operator|+
name|y
expr_stmt|;
for|for
control|(
name|x
operator|=
name|ncol
operator|-
literal|1
init|;
name|x
operator|>=
literal|0
condition|;
name|x
operator|--
control|)
block|{
name|d
operator|.
name|tp_col
operator|=
name|p
operator|->
name|tp_col
operator|+
name|x
expr_stmt|;
name|buffer
index|[
name|d
operator|.
name|tp_col
index|]
index|[
name|d
operator|.
name|tp_row
index|]
operator|=
name|buffer
index|[
name|r
operator|->
name|tr_begin
operator|.
name|tp_col
operator|+
name|x
index|]
index|[
name|r
operator|->
name|tr_begin
operator|.
name|tp_row
operator|+
name|y
index|]
expr_stmt|;
name|printchar
argument_list|(
operator|&
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* Copy from bottom to top. */
if|if
condition|(
name|p
operator|->
name|tp_col
operator|<
name|r
operator|->
name|tr_begin
operator|.
name|tp_col
condition|)
block|{
comment|/* Copy from left to right. */
for|for
control|(
name|y
operator|=
name|nrow
operator|-
literal|1
init|;
name|y
operator|>=
literal|0
condition|;
name|y
operator|--
control|)
block|{
name|d
operator|.
name|tp_row
operator|=
name|p
operator|->
name|tp_row
operator|+
name|y
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|ncol
condition|;
name|x
operator|++
control|)
block|{
name|d
operator|.
name|tp_col
operator|=
name|p
operator|->
name|tp_col
operator|+
name|x
expr_stmt|;
name|buffer
index|[
name|d
operator|.
name|tp_col
index|]
index|[
name|d
operator|.
name|tp_row
index|]
operator|=
name|buffer
index|[
name|r
operator|->
name|tr_begin
operator|.
name|tp_col
operator|+
name|x
index|]
index|[
name|r
operator|->
name|tr_begin
operator|.
name|tp_row
operator|+
name|y
index|]
expr_stmt|;
name|printchar
argument_list|(
operator|&
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Copy from right to left. */
for|for
control|(
name|y
operator|=
name|nrow
operator|-
literal|1
init|;
name|y
operator|>=
literal|0
condition|;
name|y
operator|--
control|)
block|{
name|d
operator|.
name|tp_row
operator|=
name|p
operator|->
name|tp_row
operator|+
name|y
expr_stmt|;
for|for
control|(
name|x
operator|=
name|ncol
operator|-
literal|1
init|;
name|x
operator|>=
literal|0
condition|;
name|x
operator|--
control|)
block|{
name|d
operator|.
name|tp_col
operator|=
name|p
operator|->
name|tp_col
operator|+
name|x
expr_stmt|;
name|buffer
index|[
name|d
operator|.
name|tp_col
index|]
index|[
name|d
operator|.
name|tp_row
index|]
operator|=
name|buffer
index|[
name|r
operator|->
name|tr_begin
operator|.
name|tp_col
operator|+
name|x
index|]
index|[
name|r
operator|->
name|tr_begin
operator|.
name|tp_row
operator|+
name|y
index|]
expr_stmt|;
name|printchar
argument_list|(
operator|&
name|d
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|test_param
parameter_list|(
name|void
modifier|*
name|s
name|__unused
parameter_list|,
name|int
name|cmd
parameter_list|,
name|unsigned
name|int
name|value
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|TP_SHOWCURSOR
case|:
name|curs_set
argument_list|(
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
name|TP_KEYPADAPP
case|:
name|keypad
argument_list|(
name|stdscr
argument_list|,
name|value
condition|?
name|TRUE
else|:
name|FALSE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|test_respond
parameter_list|(
name|void
modifier|*
name|s
name|__unused
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|write
argument_list|(
name|ptfd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|redraw_border
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NROWS
condition|;
name|i
operator|++
control|)
name|mvaddch
argument_list|(
name|i
argument_list|,
name|NCOLS
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCOLS
condition|;
name|i
operator|++
control|)
name|mvaddch
argument_list|(
name|NROWS
argument_list|,
name|i
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
name|mvaddch
argument_list|(
name|NROWS
argument_list|,
name|NCOLS
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|redraw_all
parameter_list|(
name|void
parameter_list|)
block|{
name|teken_pos_t
name|tp
decl_stmt|;
for|for
control|(
name|tp
operator|.
name|tp_row
operator|=
literal|0
init|;
name|tp
operator|.
name|tp_row
operator|<
name|NROWS
condition|;
name|tp
operator|.
name|tp_row
operator|++
control|)
for|for
control|(
name|tp
operator|.
name|tp_col
operator|=
literal|0
init|;
name|tp
operator|.
name|tp_col
operator|<
name|NCOLS
condition|;
name|tp
operator|.
name|tp_col
operator|++
control|)
name|printchar
argument_list|(
operator|&
name|tp
argument_list|)
expr_stmt|;
name|redraw_border
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
name|__unused
parameter_list|,
name|char
modifier|*
name|argv
index|[]
name|__unused
parameter_list|)
block|{
name|struct
name|winsize
name|ws
decl_stmt|;
name|teken_t
name|t
decl_stmt|;
name|teken_pos_t
name|tp
decl_stmt|;
name|fd_set
name|rfds
decl_stmt|;
name|char
name|b
index|[
literal|256
index|]
decl_stmt|;
name|ssize_t
name|bl
decl_stmt|;
specifier|const
name|int
name|ccolors
index|[
literal|8
index|]
init|=
block|{
name|COLOR_BLACK
block|,
name|COLOR_RED
block|,
name|COLOR_GREEN
block|,
name|COLOR_YELLOW
block|,
name|COLOR_BLUE
block|,
name|COLOR_MAGENTA
block|,
name|COLOR_CYAN
block|,
name|COLOR_WHITE
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|"UTF-8"
argument_list|)
expr_stmt|;
name|tp
operator|.
name|tp_row
operator|=
name|ws
operator|.
name|ws_row
operator|=
name|NROWS
expr_stmt|;
name|tp
operator|.
name|tp_col
operator|=
name|ws
operator|.
name|ws_col
operator|=
name|NCOLS
expr_stmt|;
switch|switch
condition|(
name|forkpty
argument_list|(
operator|&
name|ptfd
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|ws
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|perror
argument_list|(
literal|"forkpty"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
name|setenv
argument_list|(
literal|"TERM"
argument_list|,
literal|"xterm"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|setenv
argument_list|(
literal|"LC_CTYPE"
argument_list|,
literal|"UTF-8"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
literal|"zsh"
argument_list|,
literal|"-zsh"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
literal|"bash"
argument_list|,
literal|"-bash"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
literal|"sh"
argument_list|,
literal|"-sh"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|teken_init
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|tf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|teken_set_winsize
argument_list|(
operator|&
name|t
argument_list|,
operator|&
name|tp
argument_list|)
expr_stmt|;
name|initscr
argument_list|()
expr_stmt|;
name|raw
argument_list|()
expr_stmt|;
name|start_color
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|init_pair
argument_list|(
name|i
operator|+
literal|8
operator|*
name|j
argument_list|,
name|ccolors
index|[
name|i
index|]
argument_list|,
name|ccolors
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|redraw_border
argument_list|()
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|rfds
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|FD_SET
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|rfds
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|ptfd
argument_list|,
operator|&
name|rfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|ptfd
operator|+
literal|1
argument_list|,
operator|&
name|rfds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
name|redraw_all
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
name|FD_ISSET
argument_list|(
name|STDIN_FILENO
argument_list|,
operator|&
name|rfds
argument_list|)
condition|)
block|{
name|bl
operator|=
name|read
argument_list|(
name|STDIN_FILENO
argument_list|,
name|b
argument_list|,
sizeof|sizeof
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|bl
operator|<=
literal|0
condition|)
break|break;
name|write
argument_list|(
name|ptfd
argument_list|,
name|b
argument_list|,
name|bl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|FD_ISSET
argument_list|(
name|ptfd
argument_list|,
operator|&
name|rfds
argument_list|)
condition|)
block|{
name|bl
operator|=
name|read
argument_list|(
name|ptfd
argument_list|,
name|b
argument_list|,
sizeof|sizeof
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|bl
operator|<=
literal|0
condition|)
break|break;
name|teken_input
argument_list|(
operator|&
name|t
argument_list|,
name|b
argument_list|,
name|bl
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
block|}
name|endwin
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

