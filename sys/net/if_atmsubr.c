begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*      $NetBSD: if_atmsubr.c,v 1.10 1997/03/11 23:19:51 chuck Exp $       */
end_comment

begin_comment
comment|/*  *  * Copyright (c) 1996 Charles D. Cranor and Washington University.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Charles D. Cranor and   *	Washington University.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * if_atmsubr.c  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_natm.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_atm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_atm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_comment
comment|/* XXX: for ETHERTYPE_* */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NATM
end_ifdef

begin_include
include|#
directive|include
file|<netnatm/natm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ETHERTYPE_IPV6
end_ifndef

begin_define
define|#
directive|define
name|ETHERTYPE_IPV6
value|0x86dd
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|senderr
parameter_list|(
name|e
parameter_list|)
value|{ error = (e); goto bad;}
end_define

begin_comment
comment|/*  * atm_output: ATM output routine  *   inputs:  *     "ifp" = ATM interface to output to  *     "m0" = the packet to output  *     "dst" = the sockaddr to send to (either IP addr, or raw VPI/VCI)  *     "rt0" = the route to use  *   returns: error code   [0 == ok]  *  *   note: special semantic: if (dst == NULL) then we assume "m" already  *		has an atm_pseudohdr on it and just send it directly.  *		[for native mode ATM output]   if dst is null, then  *		rt0 must also be NULL.  */
end_comment

begin_function
name|int
name|atm_output
parameter_list|(
name|ifp
parameter_list|,
name|m0
parameter_list|,
name|dst
parameter_list|,
name|rt0
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt0
decl_stmt|;
block|{
name|u_int16_t
name|etype
init|=
literal|0
decl_stmt|;
comment|/* if using LLC/SNAP */
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|sz
decl_stmt|;
name|struct
name|atm_pseudohdr
name|atmdst
decl_stmt|,
modifier|*
name|ad
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m0
decl_stmt|;
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|atmllc
modifier|*
name|atmllc
decl_stmt|;
name|struct
name|atmllc
modifier|*
name|llc_hdr
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|atm_flags
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
operator|)
operator|!=
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
condition|)
name|senderr
argument_list|(
name|ENETDOWN
argument_list|)
expr_stmt|;
comment|/* 	 * check route 	 */
if|if
condition|(
operator|(
name|rt
operator|=
name|rt0
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* route went down! */
if|if
condition|(
operator|(
name|rt0
operator|=
name|rt
operator|=
name|RTALLOC1
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|rt
operator|->
name|rt_refcnt
operator|--
expr_stmt|;
else|else
name|senderr
argument_list|(
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_gwroute
operator|==
literal|0
condition|)
goto|goto
name|lookup
goto|;
if|if
condition|(
operator|(
operator|(
name|rt
operator|=
name|rt
operator|->
name|rt_gwroute
operator|)
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|rtfree
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|rt
operator|=
name|rt0
expr_stmt|;
name|lookup
label|:
name|rt
operator|->
name|rt_gwroute
operator|=
name|RTALLOC1
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rt
operator|=
name|rt
operator|->
name|rt_gwroute
operator|)
operator|==
literal|0
condition|)
name|senderr
argument_list|(
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* XXX: put RTF_REJECT code here if doing ATMARP */
block|}
comment|/* 	 * check for non-native ATM traffic   (dst != NULL) 	 */
if|if
condition|(
name|dst
condition|)
block|{
switch|switch
condition|(
name|dst
operator|->
name|sa_family
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
case|case
name|AF_INET
case|:
case|case
name|AF_INET6
case|:
if|if
condition|(
operator|!
name|atmresolve
argument_list|(
name|rt
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
operator|&
name|atmdst
argument_list|)
condition|)
block|{
name|m
operator|=
name|NULL
expr_stmt|;
comment|/* XXX: atmresolve already free'd it */
name|senderr
argument_list|(
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
comment|/* XXX: put ATMARP stuff here */
comment|/* XXX: watch who frees m on failure */
block|}
if|if
condition|(
name|dst
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
name|etype
operator|=
name|htons
argument_list|(
name|ETHERTYPE_IPV6
argument_list|)
expr_stmt|;
else|else
name|etype
operator|=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET || INET6 */
case|case
name|AF_UNSPEC
case|:
comment|/* 			 * XXX: bpfwrite or output from a pvc shadow if. 			 * assuming dst contains 12 bytes (atm pseudo 			 * header (4) + LLC/SNAP (8)) 			 */
name|bcopy
argument_list|(
name|dst
operator|->
name|sa_data
argument_list|,
operator|&
name|atmdst
argument_list|,
sizeof|sizeof
argument_list|(
name|atmdst
argument_list|)
argument_list|)
expr_stmt|;
name|llc_hdr
operator|=
operator|(
expr|struct
name|atmllc
operator|*
operator|)
operator|(
name|dst
operator|->
name|sa_data
operator|+
sizeof|sizeof
argument_list|(
name|atmdst
argument_list|)
operator|)
expr_stmt|;
break|break;
default|default:
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|printf
argument_list|(
literal|"%s: can't handle af%d\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__bsdi__
argument_list|)
name|printf
argument_list|(
literal|"%s%d: can't handle af%d\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|senderr
argument_list|(
name|EAFNOSUPPORT
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * must add atm_pseudohdr to data 		 */
name|sz
operator|=
sizeof|sizeof
argument_list|(
name|atmdst
argument_list|)
expr_stmt|;
name|atm_flags
operator|=
name|ATM_PH_FLAGS
argument_list|(
operator|&
name|atmdst
argument_list|)
expr_stmt|;
if|if
condition|(
name|atm_flags
operator|&
name|ATM_PH_LLCSNAP
condition|)
name|sz
operator|+=
literal|8
expr_stmt|;
comment|/* sizeof snap == 8 */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|sz
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
name|senderr
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
name|ad
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|atm_pseudohdr
operator|*
argument_list|)
expr_stmt|;
operator|*
name|ad
operator|=
name|atmdst
expr_stmt|;
if|if
condition|(
name|atm_flags
operator|&
name|ATM_PH_LLCSNAP
condition|)
block|{
name|atmllc
operator|=
operator|(
expr|struct
name|atmllc
operator|*
operator|)
operator|(
name|ad
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|llc_hdr
operator|==
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|ATMLLC_HDR
argument_list|,
name|atmllc
operator|->
name|llchdr
argument_list|,
sizeof|sizeof
argument_list|(
name|atmllc
operator|->
name|llchdr
argument_list|)
argument_list|)
expr_stmt|;
name|ATM_LLC_SETTYPE
argument_list|(
name|atmllc
argument_list|,
name|etype
argument_list|)
expr_stmt|;
comment|/* note: already in network order */
block|}
else|else
name|bcopy
argument_list|(
name|llc_hdr
argument_list|,
name|atmllc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|atmllc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Queue message on interface, and start output if interface 	 * not yet active. 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_obytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|IF_ENQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|==
literal|0
condition|)
call|(
modifier|*
name|ifp
operator|->
name|if_start
call|)
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|bad
label|:
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a received ATM packet;  * the packet is in the mbuf chain m.  */
end_comment

begin_function
name|void
name|atm_input
parameter_list|(
name|ifp
parameter_list|,
name|ah
parameter_list|,
name|m
parameter_list|,
name|rxhand
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|struct
name|atm_pseudohdr
modifier|*
name|ah
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|void
modifier|*
name|rxhand
decl_stmt|;
block|{
specifier|register
name|struct
name|ifqueue
modifier|*
name|inq
decl_stmt|;
name|u_int16_t
name|etype
init|=
name|ETHERTYPE_IP
decl_stmt|;
comment|/* default */
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|->
name|if_ibytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
ifdef|#
directive|ifdef
name|ATM_PVCEXT
if|if
condition|(
name|ATM_PH_FLAGS
argument_list|(
name|ah
argument_list|)
operator|&
name|ATM_PH_PVCSIF
condition|)
block|{
comment|/* 		 * when PVC shadow interface is used, pointer to 		 * the shadow interface is passed as rxhand. 		 * override the receive interface of the packet. 		 */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|(
expr|struct
name|ifnet
operator|*
operator|)
name|rxhand
expr_stmt|;
name|rxhand
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*  ATM_PVCEXT */
if|if
condition|(
name|rxhand
condition|)
block|{
ifdef|#
directive|ifdef
name|NATM
name|struct
name|natmpcb
modifier|*
name|npcb
init|=
name|rxhand
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* in case 2 atm cards @ diff lvls */
name|npcb
operator|->
name|npcb_inq
operator|++
expr_stmt|;
comment|/* count # in queue */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|schednetisr
argument_list|(
name|NETISR_NATM
argument_list|)
expr_stmt|;
name|inq
operator|=
operator|&
name|natmintrq
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|rxhand
expr_stmt|;
comment|/* XXX: overload */
else|#
directive|else
name|printf
argument_list|(
literal|"atm_input: NATM detected but not configured in kernel\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 		 * handle LLC/SNAP header, if present 		 */
if|if
condition|(
name|ATM_PH_FLAGS
argument_list|(
name|ah
argument_list|)
operator|&
name|ATM_PH_LLCSNAP
condition|)
block|{
name|struct
name|atmllc
modifier|*
name|alc
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|alc
argument_list|)
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|alc
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* failed */
name|alc
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|atmllc
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|alc
argument_list|,
name|ATMLLC_HDR
argument_list|,
literal|6
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
name|printf
argument_list|(
literal|"%s: recv'd invalid LLC/SNAP frame [vp=%d,vc=%d]\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|ATM_PH_VPI
argument_list|(
name|ah
argument_list|)
argument_list|,
name|ATM_PH_VCI
argument_list|(
name|ah
argument_list|)
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__bsdi__
argument_list|)
name|printf
argument_list|(
literal|"%s%d: recv'd invalid LLC/SNAP frame [vp=%d,vc=%d]\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|ATM_PH_VPI
argument_list|(
name|ah
argument_list|)
argument_list|,
name|ATM_PH_VCI
argument_list|(
name|ah
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|etype
operator|=
name|ATM_LLC_TYPE
argument_list|(
name|alc
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|alc
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|etype
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|ETHERTYPE_IP
case|:
name|schednetisr
argument_list|(
name|NETISR_IP
argument_list|)
expr_stmt|;
name|inq
operator|=
operator|&
name|ipintrq
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|ETHERTYPE_IPV6
case|:
name|schednetisr
argument_list|(
name|NETISR_IPV6
argument_list|)
expr_stmt|;
name|inq
operator|=
operator|&
name|ip6intrq
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
name|inq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
name|inq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
name|IF_ENQUEUE
argument_list|(
name|inq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform common duties while attaching to interface list  */
end_comment

begin_function
name|void
name|atm_ifattach
parameter_list|(
name|ifp
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
specifier|register
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|ifp
operator|->
name|if_type
operator|=
name|IFT_ATM
expr_stmt|;
name|ifp
operator|->
name|if_addrlen
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_hdrlen
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ATMMTU
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|atm_output
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
for|for
control|(
name|ifa
operator|=
name|ifp
operator|->
name|if_addrlist
operator|.
name|tqh_first
init|;
name|ifa
operator|!=
literal|0
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_list
operator|.
name|tqe_next
control|)
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|(
name|__FreeBSD__
operator|>
literal|2
operator|)
for|for
control|(
name|ifa
operator|=
name|ifp
operator|->
name|if_addrhead
operator|.
name|tqh_first
init|;
name|ifa
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_link
operator|.
name|tqe_next
control|)
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__bsdi__
argument_list|)
for|for
control|(
name|ifa
operator|=
name|ifp
operator|->
name|if_addrlist
init|;
name|ifa
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
control|)
endif|#
directive|endif
if|if
condition|(
operator|(
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
operator|)
operator|&&
name|sdl
operator|->
name|sdl_family
operator|==
name|AF_LINK
condition|)
block|{
name|sdl
operator|->
name|sdl_type
operator|=
name|IFT_ATM
expr_stmt|;
name|sdl
operator|->
name|sdl_alen
operator|=
name|ifp
operator|->
name|if_addrlen
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* if using ATMARP, store hardware address using the next line */
name|bcopy
argument_list|(
name|ifp
operator|->
name|hw_addr
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|ifp
operator|->
name|if_addrlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ATM_PVCEXT
end_ifdef

begin_comment
comment|/*  * ATM PVC shadow interface: a trick to assign a shadow interface  * to a PVC.  * with shadow interface, each PVC looks like an individual  * Point-to-Point interface.  * as oposed to the NBMA model, a shadow interface is inherently  * multicast capable (no LANE/MARS required).  */
end_comment

begin_struct
struct|struct
name|pvcsif
block|{
name|struct
name|ifnet
name|sif_shadow
decl_stmt|;
comment|/* shadow ifnet structure per pvc */
name|struct
name|atm_pseudohdr
name|sif_aph
decl_stmt|;
comment|/* flags + vpi:vci */
name|struct
name|ifnet
modifier|*
name|sif_ifp
decl_stmt|;
comment|/* pointer to the genuine interface */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|pvc_output
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|sockaddr
operator|*
operator|,
expr|struct
name|rtentry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pvc_ioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
name|u_long
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * create and attach per pvc shadow interface  * (currently detach is not supported)  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pvc_number
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|struct
name|ifnet
modifier|*
name|pvc_attach
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|pvcsif
modifier|*
name|pvcsif
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|shadow
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|int
name|s
decl_stmt|;
name|MALLOC
argument_list|(
name|pvcsif
argument_list|,
expr|struct
name|pvcsif
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pvcsif
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|pvcsif
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pvcsif
argument_list|)
argument_list|)
expr_stmt|;
name|pvcsif
operator|->
name|sif_ifp
operator|=
name|ifp
expr_stmt|;
name|shadow
operator|=
operator|&
name|pvcsif
operator|->
name|sif_shadow
expr_stmt|;
name|shadow
operator|->
name|if_name
operator|=
literal|"pvc"
expr_stmt|;
name|shadow
operator|->
name|if_unit
operator|=
name|pvc_number
operator|++
expr_stmt|;
name|shadow
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
operator||
operator|(
name|IFF_POINTOPOINT
operator||
name|IFF_MULTICAST
operator|)
expr_stmt|;
name|shadow
operator|->
name|if_ioctl
operator|=
name|pvc_ioctl
expr_stmt|;
name|shadow
operator|->
name|if_output
operator|=
name|pvc_output
expr_stmt|;
name|shadow
operator|->
name|if_start
operator|=
name|NULL
expr_stmt|;
name|shadow
operator|->
name|if_mtu
operator|=
name|ifp
operator|->
name|if_mtu
expr_stmt|;
name|shadow
operator|->
name|if_type
operator|=
name|ifp
operator|->
name|if_type
expr_stmt|;
name|shadow
operator|->
name|if_addrlen
operator|=
name|ifp
operator|->
name|if_addrlen
expr_stmt|;
name|shadow
operator|->
name|if_hdrlen
operator|=
name|ifp
operator|->
name|if_hdrlen
expr_stmt|;
name|shadow
operator|->
name|if_softc
operator|=
name|pvcsif
expr_stmt|;
name|shadow
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
literal|50
expr_stmt|;
comment|/* dummy */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|if_attach
argument_list|(
name|shadow
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD__
argument_list|)
for|for
control|(
name|ifa
operator|=
name|shadow
operator|->
name|if_addrlist
operator|.
name|tqh_first
init|;
name|ifa
operator|!=
literal|0
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_list
operator|.
name|tqe_next
control|)
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
operator|(
name|__FreeBSD__
operator|>
literal|2
operator|)
for|for
control|(
name|ifa
operator|=
name|shadow
operator|->
name|if_addrhead
operator|.
name|tqh_first
init|;
name|ifa
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_link
operator|.
name|tqe_next
control|)
elif|#
directive|elif
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__bsdi__
argument_list|)
for|for
control|(
name|ifa
operator|=
name|shadow
operator|->
name|if_addrlist
init|;
name|ifa
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
control|)
endif|#
directive|endif
if|if
condition|(
operator|(
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
operator|)
operator|&&
name|sdl
operator|->
name|sdl_family
operator|==
name|AF_LINK
condition|)
block|{
name|sdl
operator|->
name|sdl_type
operator|=
name|IFT_ATM
expr_stmt|;
name|sdl
operator|->
name|sdl_alen
operator|=
name|shadow
operator|->
name|if_addrlen
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|shadow
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * pvc_output relays the packet to atm_output along with vpi:vci info.  */
end_comment

begin_function
specifier|static
name|int
name|pvc_output
parameter_list|(
name|shadow
parameter_list|,
name|m
parameter_list|,
name|dst
parameter_list|,
name|rt
parameter_list|)
name|struct
name|ifnet
modifier|*
name|shadow
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
block|{
name|struct
name|pvcsif
modifier|*
name|pvcsif
decl_stmt|;
name|struct
name|sockaddr
name|dst_addr
decl_stmt|;
name|struct
name|atmllc
modifier|*
name|atmllc
decl_stmt|;
name|u_int16_t
name|etype
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|shadow
operator|->
name|if_flags
operator|&
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
operator|)
operator|!=
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
condition|)
name|senderr
argument_list|(
name|ENETDOWN
argument_list|)
expr_stmt|;
name|pvcsif
operator|=
name|shadow
operator|->
name|if_softc
expr_stmt|;
if|if
condition|(
name|ATM_PH_VCI
argument_list|(
operator|&
name|pvcsif
operator|->
name|sif_aph
argument_list|)
operator|==
literal|0
condition|)
name|senderr
argument_list|(
name|ENETDOWN
argument_list|)
expr_stmt|;
comment|/* 	 * create a dummy sockaddr: (using bpfwrite interface) 	 * put atm pseudo header and llc/snap into sa_data (12 bytes) 	 * and mark it as AF_UNSPEC. 	 */
if|if
condition|(
name|dst
condition|)
block|{
switch|switch
condition|(
name|dst
operator|->
name|sa_family
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
case|case
name|AF_INET
case|:
case|case
name|AF_INET6
case|:
if|if
condition|(
name|dst
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
name|etype
operator|=
name|htons
argument_list|(
name|ETHERTYPE_IPV6
argument_list|)
expr_stmt|;
else|else
name|etype
operator|=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|printf
argument_list|(
literal|"%s%d: can't handle af%d\n"
argument_list|,
name|shadow
operator|->
name|if_name
argument_list|,
name|shadow
operator|->
name|if_unit
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|EAFNOSUPPORT
argument_list|)
expr_stmt|;
block|}
block|}
name|dst_addr
operator|.
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|pvcsif
operator|->
name|sif_aph
argument_list|,
name|dst_addr
operator|.
name|sa_data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|atm_pseudohdr
argument_list|)
argument_list|)
expr_stmt|;
name|atmllc
operator|=
operator|(
expr|struct
name|atmllc
operator|*
operator|)
operator|(
name|dst_addr
operator|.
name|sa_data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|atm_pseudohdr
argument_list|)
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|ATMLLC_HDR
argument_list|,
name|atmllc
operator|->
name|llchdr
argument_list|,
sizeof|sizeof
argument_list|(
name|atmllc
operator|->
name|llchdr
argument_list|)
argument_list|)
expr_stmt|;
name|ATM_LLC_SETTYPE
argument_list|(
name|atmllc
argument_list|,
name|etype
argument_list|)
expr_stmt|;
comment|/* note: already in network order */
return|return
name|atm_output
argument_list|(
name|pvcsif
operator|->
name|sif_ifp
argument_list|,
name|m
argument_list|,
operator|&
name|dst_addr
argument_list|,
name|rt
argument_list|)
return|;
name|bad
label|:
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pvc_ioctl
parameter_list|(
name|shadow
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|)
name|struct
name|ifnet
modifier|*
name|shadow
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|pvcsif
modifier|*
name|pvcsif
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|void
function_decl|(
modifier|*
name|ifa_rtrequest
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|struct
name|rtentry
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|)
init|=
name|NULL
function_decl|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|pvcsif
operator|=
operator|(
expr|struct
name|pvcsif
operator|*
operator|)
name|shadow
operator|->
name|if_softc
expr_stmt|;
name|ifp
operator|=
name|pvcsif
operator|->
name|sif_ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
literal|0
operator|||
name|ifp
operator|->
name|if_ioctl
operator|==
literal|0
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
comment|/* 	 * pre process 	 */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCGPVCSIF
case|:
name|sprintf
argument_list|(
name|ifr
operator|->
name|ifr_name
argument_list|,
literal|"%s%d"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SIOCGPVCTX
case|:
do|do
block|{
name|struct
name|pvctxreq
modifier|*
name|pvcreq
init|=
operator|(
expr|struct
name|pvctxreq
operator|*
operator|)
name|data
decl_stmt|;
name|sprintf
argument_list|(
name|pvcreq
operator|->
name|pvc_ifname
argument_list|,
literal|"%s%d"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|pvcreq
operator|->
name|pvc_aph
operator|=
name|pvcsif
operator|->
name|sif_aph
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
if|if
condition|(
name|ifr
operator|==
literal|0
condition|)
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
comment|/* XXX */
switch|switch
condition|(
name|ifr
operator|->
name|ifr_addr
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
default|default:
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
block|}
break|break;
case|case
name|SIOCSIFADDR
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
comment|/* real if is already up */
name|shadow
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
operator||
operator|(
name|IFF_POINTOPOINT
operator||
name|IFF_MULTICAST
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * XXX: save the rtrequest field since the atm driver 		 * overwrites this field. 		 */
name|ifa_rtrequest
operator|=
operator|(
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
operator|)
operator|->
name|ifa_rtrequest
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|shadow
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * interface down. don't pass this to 			 * the real interface. 			 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|shadow
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
comment|/* 			 * interface up. if the real if is already up, 			 * nothing to do. 			 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
name|shadow
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
operator||
operator|(
name|IFF_POINTOPOINT
operator||
name|IFF_MULTICAST
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
break|break;
block|}
comment|/* 	 * pass the ioctl to the genuine interface 	 */
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_ioctl
call|)
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* 	 * post process 	 */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFMTU
case|:
name|shadow
operator|->
name|if_mtu
operator|=
name|ifp
operator|->
name|if_mtu
expr_stmt|;
break|break;
case|case
name|SIOCSIFADDR
case|:
comment|/* restore rtrequest */
operator|(
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
operator|)
operator|->
name|ifa_rtrequest
operator|=
name|ifa_rtrequest
expr_stmt|;
comment|/* fall into... */
case|case
name|SIOCSIFFLAGS
case|:
comment|/* update if_flags */
name|shadow
operator|->
name|if_flags
operator|=
name|ifp
operator|->
name|if_flags
operator||
operator|(
name|IFF_POINTOPOINT
operator||
name|IFF_MULTICAST
operator|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pvc_setaph
parameter_list|(
name|shadow
parameter_list|,
name|aph
parameter_list|)
name|struct
name|ifnet
modifier|*
name|shadow
decl_stmt|;
name|struct
name|atm_pseudohdr
modifier|*
name|aph
decl_stmt|;
block|{
name|struct
name|pvcsif
modifier|*
name|pvcsif
decl_stmt|;
name|pvcsif
operator|=
name|shadow
operator|->
name|if_softc
expr_stmt|;
name|bcopy
argument_list|(
name|aph
argument_list|,
operator|&
name|pvcsif
operator|->
name|sif_aph
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|atm_pseudohdr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATM_PVCEXT */
end_comment

end_unit

