begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*      $NetBSD: if_atmsubr.c,v 1.10 1997/03/11 23:19:51 chuck Exp $       */
end_comment

begin_comment
comment|/*-  *  * Copyright (c) 1996 Charles D. Cranor and Washington University.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Charles D. Cranor and   *	Washington University.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * if_atmsubr.c  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_mac.h"
end_include

begin_include
include|#
directive|include
file|"opt_natm.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_atm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_atm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_comment
comment|/* XXX: for ETHERTYPE_* */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NATM
end_ifdef

begin_include
include|#
directive|include
file|<netnatm/natm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_comment
comment|/*  * Netgraph interface functions.  * These need not be protected by a lock, because ng_atm nodes are persitent.  * The ng_atm module can be unloaded only if all ATM interfaces have been  * unloaded, so nobody should be in the code paths accessing these function  * pointers.  */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|ng_atm_attach_p
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|ng_atm_detach_p
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
function_decl|(
modifier|*
name|ng_atm_output_p
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|ng_atm_input_p
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|atm_pseudohdr
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|ng_atm_input_orphan_p
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|atm_pseudohdr
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|ng_atm_event_p
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Harp pseudo interface hooks  */
end_comment

begin_function_decl
name|void
function_decl|(
modifier|*
name|atm_harp_input_p
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|struct
name|atm_pseudohdr
modifier|*
name|ah
parameter_list|,
name|void
modifier|*
name|rxhand
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|atm_harp_attach_p
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|atm_harp_detach_p
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|atm_harp_event_p
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_hw
argument_list|,
name|OID_AUTO
argument_list|,
name|atm
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"ATM hardware"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_IFATM
argument_list|,
literal|"ifatm"
argument_list|,
literal|"atm interface internals"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|ETHERTYPE_IPV6
end_ifndef

begin_define
define|#
directive|define
name|ETHERTYPE_IPV6
value|0x86dd
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|senderr
parameter_list|(
name|e
parameter_list|)
value|do { error = (e); goto bad; } while (0)
end_define

begin_comment
comment|/*  * atm_output: ATM output routine  *   inputs:  *     "ifp" = ATM interface to output to  *     "m0" = the packet to output  *     "dst" = the sockaddr to send to (either IP addr, or raw VPI/VCI)  *     "rt0" = the route to use  *   returns: error code   [0 == ok]  *  *   note: special semantic: if (dst == NULL) then we assume "m" already  *		has an atm_pseudohdr on it and just send it directly.  *		[for native mode ATM output]   if dst is null, then  *		rt0 must also be NULL.  */
end_comment

begin_function
name|int
name|atm_output
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt0
parameter_list|)
block|{
name|u_int16_t
name|etype
init|=
literal|0
decl_stmt|;
comment|/* if using LLC/SNAP */
name|int
name|error
init|=
literal|0
decl_stmt|,
name|sz
decl_stmt|;
name|struct
name|atm_pseudohdr
name|atmdst
decl_stmt|,
modifier|*
name|ad
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m0
decl_stmt|;
name|struct
name|atmllc
modifier|*
name|atmllc
decl_stmt|;
name|struct
name|atmllc
modifier|*
name|llc_hdr
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|atm_flags
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_ifnet_transmit
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|senderr
argument_list|(
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|)
condition|)
name|senderr
argument_list|(
name|ENETDOWN
argument_list|)
expr_stmt|;
comment|/* 	 * check for non-native ATM traffic   (dst != NULL) 	 */
if|if
condition|(
name|dst
condition|)
block|{
switch|switch
condition|(
name|dst
operator|->
name|sa_family
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
case|case
name|AF_INET
case|:
case|case
name|AF_INET6
case|:
block|{
name|struct
name|rtentry
modifier|*
name|rt
init|=
name|NULL
decl_stmt|;
comment|/*   			 * check route 			 */
if|if
condition|(
name|rt0
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|rt_check
argument_list|(
operator|&
name|rt
argument_list|,
operator|&
name|rt0
argument_list|,
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|RT_UNLOCK
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dst
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
name|etype
operator|=
name|ETHERTYPE_IPV6
expr_stmt|;
else|else
name|etype
operator|=
name|ETHERTYPE_IP
expr_stmt|;
if|if
condition|(
operator|!
name|atmresolve
argument_list|(
name|rt
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
operator|&
name|atmdst
argument_list|)
condition|)
block|{
name|m
operator|=
name|NULL
expr_stmt|;
comment|/* XXX: atmresolve already free'd it */
name|senderr
argument_list|(
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
comment|/* XXX: put ATMARP stuff here */
comment|/* XXX: watch who frees m on failure */
block|}
block|}
break|break;
endif|#
directive|endif
comment|/* INET || INET6 */
case|case
name|AF_UNSPEC
case|:
comment|/* 			 * XXX: bpfwrite. assuming dst contains 12 bytes 			 * (atm pseudo header (4) + LLC/SNAP (8)) 			 */
name|bcopy
argument_list|(
name|dst
operator|->
name|sa_data
argument_list|,
operator|&
name|atmdst
argument_list|,
sizeof|sizeof
argument_list|(
name|atmdst
argument_list|)
argument_list|)
expr_stmt|;
name|llc_hdr
operator|=
operator|(
expr|struct
name|atmllc
operator|*
operator|)
operator|(
name|dst
operator|->
name|sa_data
operator|+
sizeof|sizeof
argument_list|(
name|atmdst
argument_list|)
operator|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%s: can't handle af%d\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|EAFNOSUPPORT
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * must add atm_pseudohdr to data 		 */
name|sz
operator|=
sizeof|sizeof
argument_list|(
name|atmdst
argument_list|)
expr_stmt|;
name|atm_flags
operator|=
name|ATM_PH_FLAGS
argument_list|(
operator|&
name|atmdst
argument_list|)
expr_stmt|;
if|if
condition|(
name|atm_flags
operator|&
name|ATM_PH_LLCSNAP
condition|)
name|sz
operator|+=
literal|8
expr_stmt|;
comment|/* sizeof snap == 8 */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|sz
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
name|senderr
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
name|ad
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|atm_pseudohdr
operator|*
argument_list|)
expr_stmt|;
operator|*
name|ad
operator|=
name|atmdst
expr_stmt|;
if|if
condition|(
name|atm_flags
operator|&
name|ATM_PH_LLCSNAP
condition|)
block|{
name|atmllc
operator|=
operator|(
expr|struct
name|atmllc
operator|*
operator|)
operator|(
name|ad
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|llc_hdr
operator|==
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|ATMLLC_HDR
argument_list|,
name|atmllc
operator|->
name|llchdr
argument_list|,
sizeof|sizeof
argument_list|(
name|atmllc
operator|->
name|llchdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* note: in host order */
name|ATM_LLC_SETTYPE
argument_list|(
name|atmllc
argument_list|,
name|etype
argument_list|)
expr_stmt|;
block|}
else|else
name|bcopy
argument_list|(
name|llc_hdr
argument_list|,
name|atmllc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|atmllc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ng_atm_output_p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
call|(
modifier|*
name|ng_atm_output_p
call|)
argument_list|(
name|ifp
argument_list|,
operator|&
name|m
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Queue message on interface, and start output if interface 	 * not yet active. 	 */
if|if
condition|(
operator|!
name|IF_HANDOFF_ADJ
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|,
name|ifp
argument_list|,
operator|-
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|atm_pseudohdr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
return|return
operator|(
name|error
operator|)
return|;
name|bad
label|:
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a received ATM packet;  * the packet is in the mbuf chain m.  */
end_comment

begin_function
name|void
name|atm_input
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|atm_pseudohdr
modifier|*
name|ah
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
modifier|*
name|rxhand
parameter_list|)
block|{
name|int
name|isr
decl_stmt|;
name|u_int16_t
name|etype
init|=
name|ETHERTYPE_IP
decl_stmt|;
comment|/* default */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|MAC
name|mac_create_mbuf_from_ifnet
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|->
name|if_ibytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|ng_atm_input_p
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|ng_atm_input_p
call|)
argument_list|(
name|ifp
argument_list|,
operator|&
name|m
argument_list|,
name|ah
argument_list|,
name|rxhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
block|}
comment|/* not eaten by ng_atm. Maybe it's a pseudo-harp PDU? */
if|if
condition|(
name|atm_harp_input_p
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|atm_harp_input_p
call|)
argument_list|(
name|ifp
argument_list|,
operator|&
name|m
argument_list|,
name|ah
argument_list|,
name|rxhand
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
block|}
if|if
condition|(
name|rxhand
condition|)
block|{
ifdef|#
directive|ifdef
name|NATM
name|struct
name|natmpcb
modifier|*
name|npcb
decl_stmt|;
comment|/* 		 * XXXRW: this use of 'rxhand' is not a very good idea, and 		 * was subject to races even before SMPng due to the release 		 * of spl here. 		 */
name|NATM_LOCK
argument_list|()
expr_stmt|;
name|npcb
operator|=
name|rxhand
expr_stmt|;
name|npcb
operator|->
name|npcb_inq
operator|++
expr_stmt|;
comment|/* count # in queue */
name|isr
operator|=
name|NETISR_NATM
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|rxhand
expr_stmt|;
comment|/* XXX: overload */
name|NATM_UNLOCK
argument_list|()
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"atm_input: NATM detected but not "
literal|"configured in kernel\n"
argument_list|)
expr_stmt|;
goto|goto
name|dropit
goto|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 		 * handle LLC/SNAP header, if present 		 */
if|if
condition|(
name|ATM_PH_FLAGS
argument_list|(
name|ah
argument_list|)
operator|&
name|ATM_PH_LLCSNAP
condition|)
block|{
name|struct
name|atmllc
modifier|*
name|alc
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|alc
argument_list|)
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|alc
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* failed */
name|alc
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|atmllc
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|alc
argument_list|,
name|ATMLLC_HDR
argument_list|,
literal|6
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: recv'd invalid LLC/SNAP frame "
literal|"[vp=%d,vc=%d]\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|ATM_PH_VPI
argument_list|(
name|ah
argument_list|)
argument_list|,
name|ATM_PH_VCI
argument_list|(
name|ah
argument_list|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|etype
operator|=
name|ATM_LLC_TYPE
argument_list|(
name|alc
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|alc
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|etype
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|ETHERTYPE_IP
case|:
name|isr
operator|=
name|NETISR_IP
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|ETHERTYPE_IPV6
case|:
name|isr
operator|=
name|NETISR_IPV6
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
ifndef|#
directive|ifndef
name|NATM
name|dropit
label|:
endif|#
directive|endif
if|if
condition|(
name|ng_atm_input_orphan_p
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ng_atm_input_orphan_p
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|ah
argument_list|,
name|rxhand
argument_list|)
expr_stmt|;
else|else
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|M_SETFIB
argument_list|(
name|m
argument_list|,
name|ifp
operator|->
name|if_fib
argument_list|)
expr_stmt|;
name|netisr_dispatch
argument_list|(
name|isr
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform common duties while attaching to interface list.  */
end_comment

begin_function
name|void
name|atm_ifattach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|struct
name|ifatm
modifier|*
name|ifatm
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|ifp
operator|->
name|if_addrlen
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_hdrlen
operator|=
literal|0
expr_stmt|;
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ATMMTU
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|atm_output
expr_stmt|;
if|#
directive|if
literal|0
block|ifp->if_input = atm_input;
endif|#
directive|endif
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
literal|50
expr_stmt|;
comment|/* dummy */
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifp->if_addrhead
argument_list|,
argument|ifa_link
argument_list|)
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_LINK
condition|)
block|{
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|sdl
operator|->
name|sdl_type
operator|=
name|IFT_ATM
expr_stmt|;
name|sdl
operator|->
name|sdl_alen
operator|=
name|ifp
operator|->
name|if_addrlen
expr_stmt|;
ifdef|#
directive|ifdef
name|notyet
comment|/* if using ATMARP, store hardware address using the next line */
name|bcopy
argument_list|(
name|ifp
operator|->
name|hw_addr
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|ifp
operator|->
name|if_addrlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|ifp
operator|->
name|if_linkmib
operator|=
operator|&
name|ifatm
operator|->
name|mib
expr_stmt|;
name|ifp
operator|->
name|if_linkmiblen
operator|=
sizeof|sizeof
argument_list|(
name|ifatm
operator|->
name|mib
argument_list|)
expr_stmt|;
if|if
condition|(
name|ng_atm_attach_p
condition|)
call|(
modifier|*
name|ng_atm_attach_p
call|)
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|atm_harp_attach_p
condition|)
call|(
modifier|*
name|atm_harp_attach_p
call|)
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Common stuff for detaching an ATM interface  */
end_comment

begin_function
name|void
name|atm_ifdetach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
if|if
condition|(
name|atm_harp_detach_p
condition|)
call|(
modifier|*
name|atm_harp_detach_p
call|)
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ng_atm_detach_p
condition|)
call|(
modifier|*
name|ng_atm_detach_p
call|)
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_detach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Support routine for the SIOCATMGVCCS ioctl().  *  * This routine assumes, that the private VCC structures used by the driver  * begin with a struct atmio_vcc.  *  * Return a table of VCCs in a freshly allocated memory area.  * Here we have a problem: we first count, how many vccs we need  * to return. The we allocate the memory and finally fill it in.  * Because we cannot lock while calling malloc, the number of active  * vccs may change while we're in malloc. So we allocate a couple of  * vccs more and if space anyway is not enough re-iterate.  *  * We could use an sx lock for the vcc tables.  */
end_comment

begin_function
name|struct
name|atmio_vcctable
modifier|*
name|atm_getvccs
parameter_list|(
name|struct
name|atmio_vcc
modifier|*
modifier|*
name|table
parameter_list|,
name|u_int
name|size
parameter_list|,
name|u_int
name|start
parameter_list|,
name|struct
name|mtx
modifier|*
name|lock
parameter_list|,
name|int
name|waitok
parameter_list|)
block|{
name|u_int
name|cid
decl_stmt|,
name|alloc
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|struct
name|atmio_vcctable
modifier|*
name|vccs
decl_stmt|;
name|struct
name|atmio_vcc
modifier|*
name|v
decl_stmt|;
name|alloc
operator|=
name|start
operator|+
literal|10
expr_stmt|;
name|vccs
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|vccs
argument_list|)
operator|+
name|alloc
operator|*
sizeof|sizeof
argument_list|(
name|vccs
operator|->
name|vccs
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|vccs
operator|=
name|reallocf
argument_list|(
name|vccs
argument_list|,
name|len
argument_list|,
name|M_TEMP
argument_list|,
name|waitok
condition|?
name|M_WAITOK
else|:
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|vccs
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bzero
argument_list|(
name|vccs
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|vccs
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|v
operator|=
name|vccs
operator|->
name|vccs
expr_stmt|;
name|mtx_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|cid
operator|=
literal|0
init|;
name|cid
operator|<
name|size
condition|;
name|cid
operator|++
control|)
if|if
condition|(
name|table
index|[
name|cid
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|++
name|vccs
operator|->
name|count
operator|==
name|alloc
condition|)
comment|/* too many - try again */
break|break;
operator|*
name|v
operator|++
operator|=
operator|*
name|table
index|[
name|cid
index|]
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cid
operator|==
name|size
condition|)
break|break;
name|alloc
operator|*=
literal|2
expr_stmt|;
block|}
return|return
operator|(
name|vccs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Driver or channel state has changed. Inform whoever is interested  * in these events.  */
end_comment

begin_function
name|void
name|atm_event
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|ng_atm_event_p
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|ng_atm_event_p
call|)
argument_list|(
name|ifp
argument_list|,
name|event
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|atm_harp_event_p
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|atm_harp_event_p
call|)
argument_list|(
name|ifp
argument_list|,
name|event
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|atm_alloc
parameter_list|(
name|u_char
name|type
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ifatm
modifier|*
name|ifatm
decl_stmt|;
name|ifatm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ifatm
argument_list|)
argument_list|,
name|M_IFATM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ifatm
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|ifatm
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atm_free
parameter_list|(
name|void
modifier|*
name|com
parameter_list|,
name|u_char
name|type
parameter_list|)
block|{
name|free
argument_list|(
name|com
argument_list|,
name|M_IFATM
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|atm_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|if_register_com_alloc
argument_list|(
name|IFT_ATM
argument_list|,
name|atm_alloc
argument_list|,
name|atm_free
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|if_deregister_com_alloc
argument_list|(
name|IFT_ATM
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|atm_mod
init|=
block|{
literal|"atm"
block|,
name|atm_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|atm
argument_list|,
name|atm_mod
argument_list|,
name|SI_SUB_INIT_IF
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|atm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

