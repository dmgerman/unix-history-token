begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: bridgestp.c,v 1.5 2003/11/28 08:56:48 keihan Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2000 Jason L. Wright (jason@thought.net)  * Copyright (c) 2006 Andrew Thompson (thompsa@FreeBSD.org)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * OpenBSD: bridgestp.c,v 1.5 2001/03/22 03:48:29 jason Exp  */
end_comment

begin_comment
comment|/*  * Implementation of the spanning tree protocol as defined in  * ISO/IEC 802.1D-2004, June 9, 2004.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<net/bridgestp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BRIDGESTP_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|arg
modifier|...
parameter_list|)
value|printf("bstp: " fmt, ##arg)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|arg
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PV2ADDR
parameter_list|(
name|pv
parameter_list|,
name|eaddr
parameter_list|)
value|do {		\ 	eaddr[0] = pv>> 40;			\ 	eaddr[1] = pv>> 32;			\ 	eaddr[2] = pv>> 24;			\ 	eaddr[3] = pv>> 16;			\ 	eaddr[4] = pv>> 8;			\ 	eaddr[5] = pv>> 0;			\ } while (0)
end_define

begin_define
define|#
directive|define
name|INFO_BETTER
value|1
end_define

begin_define
define|#
directive|define
name|INFO_SAME
value|0
end_define

begin_define
define|#
directive|define
name|INFO_WORSE
value|-1
end_define

begin_decl_stmt
specifier|const
name|uint8_t
name|bstp_etheraddr
index|[]
init|=
block|{
literal|0x01
block|,
literal|0x80
block|,
literal|0xc2
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|LIST_HEAD
argument_list|(
argument_list|,
argument|bstp_state
argument_list|)
end_macro

begin_expr_stmt
name|bstp_list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|bstp_list_mtx
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|bstp_transmit
parameter_list|(
name|struct
name|bstp_state
modifier|*
parameter_list|,
name|struct
name|bstp_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_transmit_bpdu
parameter_list|(
name|struct
name|bstp_state
modifier|*
parameter_list|,
name|struct
name|bstp_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_transmit_tcn
parameter_list|(
name|struct
name|bstp_state
modifier|*
parameter_list|,
name|struct
name|bstp_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_decode_bpdu
parameter_list|(
name|struct
name|bstp_port
modifier|*
parameter_list|,
name|struct
name|bstp_cbpdu
modifier|*
parameter_list|,
name|struct
name|bstp_config_unit
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_send_bpdu
parameter_list|(
name|struct
name|bstp_state
modifier|*
parameter_list|,
name|struct
name|bstp_port
modifier|*
parameter_list|,
name|struct
name|bstp_cbpdu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_enqueue
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bstp_pdu_flags
parameter_list|(
name|struct
name|bstp_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_received_stp
parameter_list|(
name|struct
name|bstp_state
modifier|*
parameter_list|,
name|struct
name|bstp_port
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|bstp_tbpdu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_received_rstp
parameter_list|(
name|struct
name|bstp_state
modifier|*
parameter_list|,
name|struct
name|bstp_port
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|bstp_tbpdu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_received_tcn
parameter_list|(
name|struct
name|bstp_state
modifier|*
parameter_list|,
name|struct
name|bstp_port
modifier|*
parameter_list|,
name|struct
name|bstp_tcn_unit
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_received_bpdu
parameter_list|(
name|struct
name|bstp_state
modifier|*
parameter_list|,
name|struct
name|bstp_port
modifier|*
parameter_list|,
name|struct
name|bstp_config_unit
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bstp_pdu_rcvtype
parameter_list|(
name|struct
name|bstp_port
modifier|*
parameter_list|,
name|struct
name|bstp_config_unit
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bstp_pdu_bettersame
parameter_list|(
name|struct
name|bstp_port
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bstp_info_cmp
parameter_list|(
name|struct
name|bstp_pri_vector
modifier|*
parameter_list|,
name|struct
name|bstp_pri_vector
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bstp_info_superior
parameter_list|(
name|struct
name|bstp_pri_vector
modifier|*
parameter_list|,
name|struct
name|bstp_pri_vector
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_assign_roles
parameter_list|(
name|struct
name|bstp_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_update_roles
parameter_list|(
name|struct
name|bstp_state
modifier|*
parameter_list|,
name|struct
name|bstp_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_update_state
parameter_list|(
name|struct
name|bstp_state
modifier|*
parameter_list|,
name|struct
name|bstp_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_update_tc
parameter_list|(
name|struct
name|bstp_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_update_info
parameter_list|(
name|struct
name|bstp_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_set_other_tcprop
parameter_list|(
name|struct
name|bstp_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_set_all_reroot
parameter_list|(
name|struct
name|bstp_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_set_all_sync
parameter_list|(
name|struct
name|bstp_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_set_port_state
parameter_list|(
name|struct
name|bstp_port
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_set_port_role
parameter_list|(
name|struct
name|bstp_port
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_set_port_proto
parameter_list|(
name|struct
name|bstp_port
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_set_port_tc
parameter_list|(
name|struct
name|bstp_port
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_set_timer_tc
parameter_list|(
name|struct
name|bstp_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_set_timer_msgage
parameter_list|(
name|struct
name|bstp_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bstp_rerooted
parameter_list|(
name|struct
name|bstp_state
modifier|*
parameter_list|,
name|struct
name|bstp_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|bstp_calc_path_cost
parameter_list|(
name|struct
name|bstp_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_notify_state
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_notify_rtage
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_ifupdstatus
parameter_list|(
name|struct
name|bstp_state
modifier|*
parameter_list|,
name|struct
name|bstp_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_enable_port
parameter_list|(
name|struct
name|bstp_state
modifier|*
parameter_list|,
name|struct
name|bstp_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_disable_port
parameter_list|(
name|struct
name|bstp_state
modifier|*
parameter_list|,
name|struct
name|bstp_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_tick
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_timer_start
parameter_list|(
name|struct
name|bstp_timer
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_timer_stop
parameter_list|(
name|struct
name|bstp_timer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_timer_latch
parameter_list|(
name|struct
name|bstp_timer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bstp_timer_expired
parameter_list|(
name|struct
name|bstp_timer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_hello_timer_expiry
parameter_list|(
name|struct
name|bstp_state
modifier|*
parameter_list|,
name|struct
name|bstp_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_message_age_expiry
parameter_list|(
name|struct
name|bstp_state
modifier|*
parameter_list|,
name|struct
name|bstp_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_migrate_delay_expiry
parameter_list|(
name|struct
name|bstp_state
modifier|*
parameter_list|,
name|struct
name|bstp_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_edge_delay_expiry
parameter_list|(
name|struct
name|bstp_state
modifier|*
parameter_list|,
name|struct
name|bstp_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bstp_addr_cmp
parameter_list|(
specifier|const
name|uint8_t
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bstp_same_bridgeid
parameter_list|(
name|uint64_t
parameter_list|,
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bstp_reinit
parameter_list|(
name|struct
name|bstp_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|bstp_transmit
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
name|bs
operator|->
name|bs_running
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * a PDU can only be sent if we have tx quota left and the 	 * hello timer is running. 	 */
if|if
condition|(
name|bp
operator|->
name|bp_hello_timer
operator|.
name|active
operator|==
literal|0
condition|)
block|{
comment|/* Test if it needs to be reset */
name|bstp_hello_timer_expiry
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bp
operator|->
name|bp_txcount
operator|>
name|bs
operator|->
name|bs_txholdcount
condition|)
comment|/* Ran out of karma */
return|return;
if|if
condition|(
name|bp
operator|->
name|bp_protover
operator|==
name|BSTP_PROTO_RSTP
condition|)
block|{
name|bstp_transmit_bpdu
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_tc_ack
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* STP */
switch|switch
condition|(
name|bp
operator|->
name|bp_role
condition|)
block|{
case|case
name|BSTP_ROLE_DESIGNATED
case|:
name|bstp_transmit_bpdu
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_tc_ack
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BSTP_ROLE_ROOT
case|:
name|bstp_transmit_tcn
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|bstp_timer_start
argument_list|(
operator|&
name|bp
operator|->
name|bp_hello_timer
argument_list|,
name|bp
operator|->
name|bp_desg_htime
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_flags
operator|&=
operator|~
name|BSTP_PORT_NEWINFO
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_transmit_bpdu
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|bstp_cbpdu
name|bpdu
decl_stmt|;
name|BSTP_LOCK_ASSERT
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|bpdu
operator|.
name|cbu_rootpri
operator|=
name|htons
argument_list|(
name|bp
operator|->
name|bp_desg_pv
operator|.
name|pv_root_id
operator|>>
literal|48
argument_list|)
expr_stmt|;
name|PV2ADDR
argument_list|(
name|bp
operator|->
name|bp_desg_pv
operator|.
name|pv_root_id
argument_list|,
name|bpdu
operator|.
name|cbu_rootaddr
argument_list|)
expr_stmt|;
name|bpdu
operator|.
name|cbu_rootpathcost
operator|=
name|htonl
argument_list|(
name|bp
operator|->
name|bp_desg_pv
operator|.
name|pv_cost
argument_list|)
expr_stmt|;
name|bpdu
operator|.
name|cbu_bridgepri
operator|=
name|htons
argument_list|(
name|bp
operator|->
name|bp_desg_pv
operator|.
name|pv_dbridge_id
operator|>>
literal|48
argument_list|)
expr_stmt|;
name|PV2ADDR
argument_list|(
name|bp
operator|->
name|bp_desg_pv
operator|.
name|pv_dbridge_id
argument_list|,
name|bpdu
operator|.
name|cbu_bridgeaddr
argument_list|)
expr_stmt|;
name|bpdu
operator|.
name|cbu_portid
operator|=
name|htons
argument_list|(
name|bp
operator|->
name|bp_port_id
argument_list|)
expr_stmt|;
name|bpdu
operator|.
name|cbu_messageage
operator|=
name|htons
argument_list|(
name|bp
operator|->
name|bp_desg_msg_age
argument_list|)
expr_stmt|;
name|bpdu
operator|.
name|cbu_maxage
operator|=
name|htons
argument_list|(
name|bp
operator|->
name|bp_desg_max_age
argument_list|)
expr_stmt|;
name|bpdu
operator|.
name|cbu_hellotime
operator|=
name|htons
argument_list|(
name|bp
operator|->
name|bp_desg_htime
argument_list|)
expr_stmt|;
name|bpdu
operator|.
name|cbu_forwarddelay
operator|=
name|htons
argument_list|(
name|bp
operator|->
name|bp_desg_fdelay
argument_list|)
expr_stmt|;
name|bpdu
operator|.
name|cbu_flags
operator|=
name|bstp_pdu_flags
argument_list|(
name|bp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bp_protover
condition|)
block|{
case|case
name|BSTP_PROTO_STP
case|:
name|bpdu
operator|.
name|cbu_bpdutype
operator|=
name|BSTP_MSGTYPE_CFG
expr_stmt|;
break|break;
case|case
name|BSTP_PROTO_RSTP
case|:
name|bpdu
operator|.
name|cbu_bpdutype
operator|=
name|BSTP_MSGTYPE_RSTP
expr_stmt|;
break|break;
block|}
name|bstp_send_bpdu
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|,
operator|&
name|bpdu
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_transmit_tcn
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|bstp_tbpdu
name|bpdu
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|bp
operator|->
name|bp_ifp
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|KASSERT
argument_list|(
name|bp
operator|==
name|bs
operator|->
name|bs_root_port
argument_list|,
operator|(
literal|"%s: bad root port\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|bpdu
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|bstp_etheraddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|eh
operator|->
name|ether_type
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
name|bpdu
argument_list|)
argument_list|)
expr_stmt|;
name|bpdu
operator|.
name|tbu_ssap
operator|=
name|bpdu
operator|.
name|tbu_dsap
operator|=
name|LLC_8021D_LSAP
expr_stmt|;
name|bpdu
operator|.
name|tbu_ctl
operator|=
name|LLC_UI
expr_stmt|;
name|bpdu
operator|.
name|tbu_protoid
operator|=
literal|0
expr_stmt|;
name|bpdu
operator|.
name|tbu_protover
operator|=
literal|0
expr_stmt|;
name|bpdu
operator|.
name|tbu_bpdutype
operator|=
name|BSTP_MSGTYPE_TCN
expr_stmt|;
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
argument_list|,
operator|&
name|bpdu
argument_list|,
sizeof|sizeof
argument_list|(
name|bpdu
argument_list|)
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_txcount
operator|++
expr_stmt|;
name|bstp_enqueue
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_decode_bpdu
parameter_list|(
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|,
name|struct
name|bstp_cbpdu
modifier|*
name|cpdu
parameter_list|,
name|struct
name|bstp_config_unit
modifier|*
name|cu
parameter_list|)
block|{
name|int
name|flags
decl_stmt|;
name|cu
operator|->
name|cu_pv
operator|.
name|pv_root_id
operator|=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|ntohs
argument_list|(
name|cpdu
operator|->
name|cbu_rootpri
argument_list|)
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|cpdu
operator|->
name|cbu_rootaddr
index|[
literal|0
index|]
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|cpdu
operator|->
name|cbu_rootaddr
index|[
literal|1
index|]
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|cpdu
operator|->
name|cbu_rootaddr
index|[
literal|2
index|]
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|cpdu
operator|->
name|cbu_rootaddr
index|[
literal|3
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|cpdu
operator|->
name|cbu_rootaddr
index|[
literal|4
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|cpdu
operator|->
name|cbu_rootaddr
index|[
literal|5
index|]
operator|)
operator|<<
literal|0
operator|)
expr_stmt|;
name|cu
operator|->
name|cu_pv
operator|.
name|pv_dbridge_id
operator|=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|ntohs
argument_list|(
name|cpdu
operator|->
name|cbu_bridgepri
argument_list|)
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|cpdu
operator|->
name|cbu_bridgeaddr
index|[
literal|0
index|]
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|cpdu
operator|->
name|cbu_bridgeaddr
index|[
literal|1
index|]
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|cpdu
operator|->
name|cbu_bridgeaddr
index|[
literal|2
index|]
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|cpdu
operator|->
name|cbu_bridgeaddr
index|[
literal|3
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|cpdu
operator|->
name|cbu_bridgeaddr
index|[
literal|4
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|cpdu
operator|->
name|cbu_bridgeaddr
index|[
literal|5
index|]
operator|)
operator|<<
literal|0
operator|)
expr_stmt|;
name|cu
operator|->
name|cu_pv
operator|.
name|pv_cost
operator|=
name|ntohl
argument_list|(
name|cpdu
operator|->
name|cbu_rootpathcost
argument_list|)
expr_stmt|;
name|cu
operator|->
name|cu_message_age
operator|=
name|ntohs
argument_list|(
name|cpdu
operator|->
name|cbu_messageage
argument_list|)
expr_stmt|;
name|cu
operator|->
name|cu_max_age
operator|=
name|ntohs
argument_list|(
name|cpdu
operator|->
name|cbu_maxage
argument_list|)
expr_stmt|;
name|cu
operator|->
name|cu_hello_time
operator|=
name|ntohs
argument_list|(
name|cpdu
operator|->
name|cbu_hellotime
argument_list|)
expr_stmt|;
name|cu
operator|->
name|cu_forward_delay
operator|=
name|ntohs
argument_list|(
name|cpdu
operator|->
name|cbu_forwarddelay
argument_list|)
expr_stmt|;
name|cu
operator|->
name|cu_pv
operator|.
name|pv_dport_id
operator|=
name|ntohs
argument_list|(
name|cpdu
operator|->
name|cbu_portid
argument_list|)
expr_stmt|;
name|cu
operator|->
name|cu_pv
operator|.
name|pv_port_id
operator|=
name|bp
operator|->
name|bp_port_id
expr_stmt|;
name|cu
operator|->
name|cu_message_type
operator|=
name|cpdu
operator|->
name|cbu_bpdutype
expr_stmt|;
comment|/* Strip off unused flags in STP mode */
name|flags
operator|=
name|cpdu
operator|->
name|cbu_flags
expr_stmt|;
switch|switch
condition|(
name|cpdu
operator|->
name|cbu_protover
condition|)
block|{
case|case
name|BSTP_PROTO_STP
case|:
name|flags
operator|&=
name|BSTP_PDU_STPMASK
expr_stmt|;
comment|/* A STP BPDU explicitly conveys a Designated Port */
name|cu
operator|->
name|cu_role
operator|=
name|BSTP_ROLE_DESIGNATED
expr_stmt|;
break|break;
case|case
name|BSTP_PROTO_RSTP
case|:
name|flags
operator|&=
name|BSTP_PDU_RSTPMASK
expr_stmt|;
break|break;
block|}
name|cu
operator|->
name|cu_topology_change_ack
operator|=
operator|(
name|flags
operator|&
name|BSTP_PDU_F_TCA
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|cu
operator|->
name|cu_proposal
operator|=
operator|(
name|flags
operator|&
name|BSTP_PDU_F_P
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|cu
operator|->
name|cu_agree
operator|=
operator|(
name|flags
operator|&
name|BSTP_PDU_F_A
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|cu
operator|->
name|cu_learning
operator|=
operator|(
name|flags
operator|&
name|BSTP_PDU_F_L
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|cu
operator|->
name|cu_forwarding
operator|=
operator|(
name|flags
operator|&
name|BSTP_PDU_F_F
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|cu
operator|->
name|cu_topology_change
operator|=
operator|(
name|flags
operator|&
name|BSTP_PDU_F_TC
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
switch|switch
condition|(
operator|(
name|flags
operator|&
name|BSTP_PDU_PRMASK
operator|)
operator|>>
name|BSTP_PDU_PRSHIFT
condition|)
block|{
case|case
name|BSTP_PDU_F_ROOT
case|:
name|cu
operator|->
name|cu_role
operator|=
name|BSTP_ROLE_ROOT
expr_stmt|;
break|break;
case|case
name|BSTP_PDU_F_ALT
case|:
name|cu
operator|->
name|cu_role
operator|=
name|BSTP_ROLE_ALTERNATE
expr_stmt|;
break|break;
case|case
name|BSTP_PDU_F_DESG
case|:
name|cu
operator|->
name|cu_role
operator|=
name|BSTP_ROLE_DESIGNATED
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_send_bpdu
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|,
name|struct
name|bstp_cbpdu
modifier|*
name|bpdu
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|BSTP_LOCK_ASSERT
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|bp
operator|->
name|bp_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|bpdu
operator|->
name|cbu_ssap
operator|=
name|bpdu
operator|->
name|cbu_dsap
operator|=
name|LLC_8021D_LSAP
expr_stmt|;
name|bpdu
operator|->
name|cbu_ctl
operator|=
name|LLC_UI
expr_stmt|;
name|bpdu
operator|->
name|cbu_protoid
operator|=
name|htons
argument_list|(
name|BSTP_PROTO_ID
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|bstp_etheraddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bpdu
operator|->
name|cbu_bpdutype
condition|)
block|{
case|case
name|BSTP_MSGTYPE_CFG
case|:
name|bpdu
operator|->
name|cbu_protover
operator|=
name|BSTP_PROTO_STP
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
operator|+
name|BSTP_BPDU_STP_LEN
expr_stmt|;
name|eh
operator|->
name|ether_type
operator|=
name|htons
argument_list|(
name|BSTP_BPDU_STP_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
argument_list|,
name|bpdu
argument_list|,
name|BSTP_BPDU_STP_LEN
argument_list|)
expr_stmt|;
break|break;
case|case
name|BSTP_MSGTYPE_RSTP
case|:
name|bpdu
operator|->
name|cbu_protover
operator|=
name|BSTP_PROTO_RSTP
expr_stmt|;
name|bpdu
operator|->
name|cbu_versionlen
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
operator|+
name|BSTP_BPDU_RSTP_LEN
expr_stmt|;
name|eh
operator|->
name|ether_type
operator|=
name|htons
argument_list|(
name|BSTP_BPDU_RSTP_LEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
argument_list|,
name|bpdu
argument_list|,
name|BSTP_BPDU_RSTP_LEN
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"not implemented"
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|bp
operator|->
name|bp_txcount
operator|++
expr_stmt|;
name|bstp_enqueue
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_enqueue
parameter_list|(
name|struct
name|ifnet
modifier|*
name|dst_ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|IFQ_ENQUEUE
argument_list|(
operator|&
name|dst_ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dst_ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
operator|==
literal|0
condition|)
call|(
modifier|*
name|dst_ifp
operator|->
name|if_start
call|)
argument_list|(
name|dst_ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bstp_pdu_flags
parameter_list|(
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_proposing
operator|&&
name|bp
operator|->
name|bp_state
operator|!=
name|BSTP_IFSTATE_FORWARDING
condition|)
name|flags
operator||=
name|BSTP_PDU_F_P
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_agree
condition|)
name|flags
operator||=
name|BSTP_PDU_F_A
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_tc_timer
operator|.
name|active
condition|)
name|flags
operator||=
name|BSTP_PDU_F_TC
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_tc_ack
condition|)
name|flags
operator||=
name|BSTP_PDU_F_TCA
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bp_state
condition|)
block|{
case|case
name|BSTP_IFSTATE_LEARNING
case|:
name|flags
operator||=
name|BSTP_PDU_F_L
expr_stmt|;
break|break;
case|case
name|BSTP_IFSTATE_FORWARDING
case|:
name|flags
operator||=
operator|(
name|BSTP_PDU_F_L
operator||
name|BSTP_PDU_F_F
operator|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|bp
operator|->
name|bp_role
condition|)
block|{
case|case
name|BSTP_ROLE_ROOT
case|:
name|flags
operator||=
operator|(
name|BSTP_PDU_F_ROOT
operator|<<
name|BSTP_PDU_PRSHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|BSTP_ROLE_ALTERNATE
case|:
case|case
name|BSTP_ROLE_BACKUP
case|:
comment|/* fall through */
name|flags
operator||=
operator|(
name|BSTP_PDU_F_ALT
operator|<<
name|BSTP_PDU_PRSHIFT
operator|)
expr_stmt|;
break|break;
case|case
name|BSTP_ROLE_DESIGNATED
case|:
name|flags
operator||=
operator|(
name|BSTP_PDU_F_DESG
operator|<<
name|BSTP_PDU_PRSHIFT
operator|)
expr_stmt|;
break|break;
block|}
comment|/* Strip off unused flags in either mode */
switch|switch
condition|(
name|bp
operator|->
name|bp_protover
condition|)
block|{
case|case
name|BSTP_PROTO_STP
case|:
name|flags
operator|&=
name|BSTP_PDU_STPMASK
expr_stmt|;
break|break;
case|case
name|BSTP_PROTO_RSTP
case|:
name|flags
operator|&=
name|BSTP_PDU_RSTPMASK
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|flags
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|bstp_input
parameter_list|(
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|bstp_state
modifier|*
name|bs
init|=
name|bp
operator|->
name|bp_bs
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|bstp_tbpdu
name|tpdu
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_active
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|BSTP_LOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|len
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|tpdu
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|len
condition|)
name|m_adj
argument_list|(
name|m
argument_list|,
name|len
operator|-
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
name|tpdu
argument_list|)
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|tpdu
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|memcpy
argument_list|(
operator|&
name|tpdu
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tpdu
argument_list|)
argument_list|)
expr_stmt|;
comment|/* basic packet checks */
if|if
condition|(
name|tpdu
operator|.
name|tbu_dsap
operator|!=
name|LLC_8021D_LSAP
operator|||
name|tpdu
operator|.
name|tbu_ssap
operator|!=
name|LLC_8021D_LSAP
operator|||
name|tpdu
operator|.
name|tbu_ctl
operator|!=
name|LLC_UI
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|tpdu
operator|.
name|tbu_protoid
operator|!=
name|BSTP_PROTO_ID
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * We can treat later versions of the PDU as the same as the maximum 	 * version we implement. All additional parameters/flags are ignored. 	 */
if|if
condition|(
name|tpdu
operator|.
name|tbu_protover
operator|>
name|BSTP_PROTO_MAX
condition|)
name|tpdu
operator|.
name|tbu_protover
operator|=
name|BSTP_PROTO_MAX
expr_stmt|;
if|if
condition|(
name|tpdu
operator|.
name|tbu_protover
operator|!=
name|bp
operator|->
name|bp_protover
condition|)
block|{
comment|/* 		 * Wait for the migration delay timer to expire before changing 		 * protocol version to avoid flip-flops. 		 */
if|if
condition|(
name|bp
operator|->
name|bp_flags
operator|&
name|BSTP_PORT_CANMIGRATE
condition|)
name|bstp_set_port_proto
argument_list|(
name|bp
argument_list|,
name|tpdu
operator|.
name|tbu_protover
argument_list|)
expr_stmt|;
else|else
goto|goto
name|out
goto|;
block|}
comment|/* Clear operedge upon receiving a PDU on the port */
name|bp
operator|->
name|bp_operedge
operator|=
literal|0
expr_stmt|;
name|bstp_timer_start
argument_list|(
operator|&
name|bp
operator|->
name|bp_edge_delay_timer
argument_list|,
name|BSTP_DEFAULT_MIGRATE_DELAY
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tpdu
operator|.
name|tbu_protover
condition|)
block|{
case|case
name|BSTP_PROTO_STP
case|:
name|bstp_received_stp
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|tpdu
argument_list|)
expr_stmt|;
break|break;
case|case
name|BSTP_PROTO_RSTP
case|:
name|bstp_received_rstp
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|tpdu
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
label|:
name|BSTP_UNLOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_received_stp
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|struct
name|bstp_tbpdu
modifier|*
name|tpdu
parameter_list|)
block|{
name|struct
name|bstp_cbpdu
name|cpdu
decl_stmt|;
name|struct
name|bstp_config_unit
modifier|*
name|cu
init|=
operator|&
name|bp
operator|->
name|bp_msg_cu
decl_stmt|;
name|struct
name|bstp_tcn_unit
name|tu
decl_stmt|;
switch|switch
condition|(
name|tpdu
operator|->
name|tbu_bpdutype
condition|)
block|{
case|case
name|BSTP_MSGTYPE_TCN
case|:
name|tu
operator|.
name|tu_message_type
operator|=
name|tpdu
operator|->
name|tbu_bpdutype
expr_stmt|;
name|bstp_received_tcn
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|,
operator|&
name|tu
argument_list|)
expr_stmt|;
break|break;
case|case
name|BSTP_MSGTYPE_CFG
case|:
if|if
condition|(
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|<
name|BSTP_BPDU_STP_LEN
operator|&&
operator|(
operator|*
name|mp
operator|=
name|m_pullup
argument_list|(
operator|*
name|mp
argument_list|,
name|BSTP_BPDU_STP_LEN
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|memcpy
argument_list|(
operator|&
name|cpdu
argument_list|,
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|BSTP_BPDU_STP_LEN
argument_list|)
expr_stmt|;
name|bstp_decode_bpdu
argument_list|(
name|bp
argument_list|,
operator|&
name|cpdu
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|bstp_received_bpdu
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|,
name|cu
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_received_rstp
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|struct
name|bstp_tbpdu
modifier|*
name|tpdu
parameter_list|)
block|{
name|struct
name|bstp_cbpdu
name|cpdu
decl_stmt|;
name|struct
name|bstp_config_unit
modifier|*
name|cu
init|=
operator|&
name|bp
operator|->
name|bp_msg_cu
decl_stmt|;
if|if
condition|(
name|tpdu
operator|->
name|tbu_bpdutype
operator|!=
name|BSTP_MSGTYPE_RSTP
condition|)
return|return;
if|if
condition|(
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|<
name|BSTP_BPDU_RSTP_LEN
operator|&&
operator|(
operator|*
name|mp
operator|=
name|m_pullup
argument_list|(
operator|*
name|mp
argument_list|,
name|BSTP_BPDU_RSTP_LEN
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|memcpy
argument_list|(
operator|&
name|cpdu
argument_list|,
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|BSTP_BPDU_RSTP_LEN
argument_list|)
expr_stmt|;
name|bstp_decode_bpdu
argument_list|(
name|bp
argument_list|,
operator|&
name|cpdu
argument_list|,
name|cu
argument_list|)
expr_stmt|;
name|bstp_received_bpdu
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|,
name|cu
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_received_tcn
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|,
name|struct
name|bstp_tcn_unit
modifier|*
name|tcn
parameter_list|)
block|{
name|bp
operator|->
name|bp_rcvdtcn
operator|=
literal|1
expr_stmt|;
name|bstp_update_tc
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_received_bpdu
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|,
name|struct
name|bstp_config_unit
modifier|*
name|cu
parameter_list|)
block|{
name|int
name|type
decl_stmt|;
name|BSTP_LOCK_ASSERT
argument_list|(
name|bs
argument_list|)
expr_stmt|;
comment|/* We need to have transitioned to INFO_MINE before proceeding */
switch|switch
condition|(
name|bp
operator|->
name|bp_infois
condition|)
block|{
case|case
name|BSTP_INFO_DISABLED
case|:
case|case
name|BSTP_INFO_AGED
case|:
return|return;
block|}
name|type
operator|=
name|bstp_pdu_rcvtype
argument_list|(
name|bp
argument_list|,
name|cu
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BSTP_PDU_SUPERIOR
case|:
name|bs
operator|->
name|bs_allsynced
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bp_agreed
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bp_proposing
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cu
operator|->
name|cu_proposal
operator|&&
name|cu
operator|->
name|cu_forwarding
operator|==
literal|0
condition|)
name|bp
operator|->
name|bp_proposed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cu
operator|->
name|cu_topology_change
condition|)
name|bp
operator|->
name|bp_rcvdtc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cu
operator|->
name|cu_topology_change_ack
condition|)
name|bp
operator|->
name|bp_rcvdtca
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_agree
operator|&&
operator|!
name|bstp_pdu_bettersame
argument_list|(
name|bp
argument_list|,
name|BSTP_INFO_RECIEVED
argument_list|)
condition|)
name|bp
operator|->
name|bp_agree
operator|=
literal|0
expr_stmt|;
comment|/* copy the received priority and timers to the port */
name|bp
operator|->
name|bp_port_pv
operator|=
name|cu
operator|->
name|cu_pv
expr_stmt|;
name|bp
operator|->
name|bp_port_msg_age
operator|=
name|cu
operator|->
name|cu_message_age
expr_stmt|;
name|bp
operator|->
name|bp_port_max_age
operator|=
name|cu
operator|->
name|cu_max_age
expr_stmt|;
name|bp
operator|->
name|bp_port_fdelay
operator|=
name|cu
operator|->
name|cu_forward_delay
expr_stmt|;
name|bp
operator|->
name|bp_port_htime
operator|=
operator|(
name|cu
operator|->
name|cu_hello_time
operator|>
name|BSTP_MIN_HELLO_TIME
condition|?
name|cu
operator|->
name|cu_hello_time
else|:
name|BSTP_MIN_HELLO_TIME
operator|)
expr_stmt|;
comment|/* set expiry for the new info */
name|bstp_set_timer_msgage
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_infois
operator|=
name|BSTP_INFO_RECIEVED
expr_stmt|;
name|bstp_assign_roles
argument_list|(
name|bs
argument_list|)
expr_stmt|;
break|break;
case|case
name|BSTP_PDU_REPEATED
case|:
if|if
condition|(
name|cu
operator|->
name|cu_proposal
operator|&&
name|cu
operator|->
name|cu_forwarding
operator|==
literal|0
condition|)
name|bp
operator|->
name|bp_proposed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cu
operator|->
name|cu_topology_change
condition|)
name|bp
operator|->
name|bp_rcvdtc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cu
operator|->
name|cu_topology_change_ack
condition|)
name|bp
operator|->
name|bp_rcvdtca
operator|=
literal|1
expr_stmt|;
comment|/* rearm the age timer */
name|bstp_set_timer_msgage
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
case|case
name|BSTP_PDU_INFERIOR
case|:
if|if
condition|(
name|cu
operator|->
name|cu_learning
condition|)
block|{
name|bp
operator|->
name|bp_agreed
operator|=
literal|1
expr_stmt|;
name|bp
operator|->
name|bp_proposing
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|BSTP_PDU_INFERIORALT
case|:
comment|/* 			 * only point to point links are allowed fast 			 * transitions to forwarding. 			 */
if|if
condition|(
name|cu
operator|->
name|cu_agree
operator|&&
name|bp
operator|->
name|bp_p2p_link
condition|)
block|{
name|bp
operator|->
name|bp_agreed
operator|=
literal|1
expr_stmt|;
name|bp
operator|->
name|bp_proposing
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|bp
operator|->
name|bp_agreed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cu
operator|->
name|cu_topology_change
condition|)
name|bp
operator|->
name|bp_rcvdtc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cu
operator|->
name|cu_topology_change_ack
condition|)
name|bp
operator|->
name|bp_rcvdtca
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|BSTP_PDU_OTHER
case|:
return|return;
comment|/* do nothing */
block|}
comment|/* update the state machines with the new data */
name|bstp_update_state
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bstp_pdu_rcvtype
parameter_list|(
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|,
name|struct
name|bstp_config_unit
modifier|*
name|cu
parameter_list|)
block|{
name|int
name|type
decl_stmt|;
comment|/* default return type */
name|type
operator|=
name|BSTP_PDU_OTHER
expr_stmt|;
switch|switch
condition|(
name|cu
operator|->
name|cu_role
condition|)
block|{
case|case
name|BSTP_ROLE_DESIGNATED
case|:
if|if
condition|(
name|bstp_info_superior
argument_list|(
operator|&
name|bp
operator|->
name|bp_port_pv
argument_list|,
operator|&
name|cu
operator|->
name|cu_pv
argument_list|)
condition|)
comment|/* bpdu priority is superior */
name|type
operator|=
name|BSTP_PDU_SUPERIOR
expr_stmt|;
elseif|else
if|if
condition|(
name|bstp_info_cmp
argument_list|(
operator|&
name|bp
operator|->
name|bp_port_pv
argument_list|,
operator|&
name|cu
operator|->
name|cu_pv
argument_list|)
operator|==
name|INFO_SAME
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bp_port_msg_age
operator|!=
name|cu
operator|->
name|cu_message_age
operator|||
name|bp
operator|->
name|bp_port_max_age
operator|!=
name|cu
operator|->
name|cu_max_age
operator|||
name|bp
operator|->
name|bp_port_fdelay
operator|!=
name|cu
operator|->
name|cu_forward_delay
operator|||
name|bp
operator|->
name|bp_port_htime
operator|!=
name|cu
operator|->
name|cu_hello_time
condition|)
comment|/* bpdu priority is equal and timers differ */
name|type
operator|=
name|BSTP_PDU_SUPERIOR
expr_stmt|;
else|else
comment|/* bpdu is equal */
name|type
operator|=
name|BSTP_PDU_REPEATED
expr_stmt|;
block|}
else|else
comment|/* bpdu priority is worse */
name|type
operator|=
name|BSTP_PDU_INFERIOR
expr_stmt|;
break|break;
case|case
name|BSTP_ROLE_ROOT
case|:
case|case
name|BSTP_ROLE_ALTERNATE
case|:
case|case
name|BSTP_ROLE_BACKUP
case|:
if|if
condition|(
name|bstp_info_cmp
argument_list|(
operator|&
name|bp
operator|->
name|bp_port_pv
argument_list|,
operator|&
name|cu
operator|->
name|cu_pv
argument_list|)
operator|<=
name|INFO_SAME
condition|)
comment|/* 			 * not a designated port and priority is the same or 			 * worse 			 */
name|type
operator|=
name|BSTP_PDU_INFERIORALT
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bstp_pdu_bettersame
parameter_list|(
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|,
name|int
name|newinfo
parameter_list|)
block|{
if|if
condition|(
name|newinfo
operator|==
name|BSTP_INFO_RECIEVED
operator|&&
name|bp
operator|->
name|bp_infois
operator|==
name|BSTP_INFO_RECIEVED
operator|&&
name|bstp_info_cmp
argument_list|(
operator|&
name|bp
operator|->
name|bp_port_pv
argument_list|,
operator|&
name|bp
operator|->
name|bp_msg_cu
operator|.
name|cu_pv
argument_list|)
operator|>=
name|INFO_SAME
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|newinfo
operator|==
name|BSTP_INFO_MINE
operator|&&
name|bp
operator|->
name|bp_infois
operator|==
name|BSTP_INFO_MINE
operator|&&
name|bstp_info_cmp
argument_list|(
operator|&
name|bp
operator|->
name|bp_port_pv
argument_list|,
operator|&
name|bp
operator|->
name|bp_desg_pv
argument_list|)
operator|>=
name|INFO_SAME
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bstp_info_cmp
parameter_list|(
name|struct
name|bstp_pri_vector
modifier|*
name|pv
parameter_list|,
name|struct
name|bstp_pri_vector
modifier|*
name|cpv
parameter_list|)
block|{
if|if
condition|(
name|cpv
operator|->
name|pv_root_id
operator|<
name|pv
operator|->
name|pv_root_id
condition|)
return|return
operator|(
name|INFO_BETTER
operator|)
return|;
if|if
condition|(
name|cpv
operator|->
name|pv_root_id
operator|>
name|pv
operator|->
name|pv_root_id
condition|)
return|return
operator|(
name|INFO_WORSE
operator|)
return|;
if|if
condition|(
name|cpv
operator|->
name|pv_cost
operator|<
name|pv
operator|->
name|pv_cost
condition|)
return|return
operator|(
name|INFO_BETTER
operator|)
return|;
if|if
condition|(
name|cpv
operator|->
name|pv_cost
operator|>
name|pv
operator|->
name|pv_cost
condition|)
return|return
operator|(
name|INFO_WORSE
operator|)
return|;
if|if
condition|(
name|cpv
operator|->
name|pv_dbridge_id
operator|<
name|pv
operator|->
name|pv_dbridge_id
condition|)
return|return
operator|(
name|INFO_BETTER
operator|)
return|;
if|if
condition|(
name|cpv
operator|->
name|pv_dbridge_id
operator|>
name|pv
operator|->
name|pv_dbridge_id
condition|)
return|return
operator|(
name|INFO_WORSE
operator|)
return|;
if|if
condition|(
name|cpv
operator|->
name|pv_dport_id
operator|<
name|pv
operator|->
name|pv_dport_id
condition|)
return|return
operator|(
name|INFO_BETTER
operator|)
return|;
if|if
condition|(
name|cpv
operator|->
name|pv_dport_id
operator|>
name|pv
operator|->
name|pv_dport_id
condition|)
return|return
operator|(
name|INFO_WORSE
operator|)
return|;
return|return
operator|(
name|INFO_SAME
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This message priority vector is superior to the port priority vector and  * will replace it if, and only if, the message priority vector is better than  * the port priority vector, or the message has been transmitted from the same  * designated bridge and designated port as the port priority vector.  */
end_comment

begin_function
specifier|static
name|int
name|bstp_info_superior
parameter_list|(
name|struct
name|bstp_pri_vector
modifier|*
name|pv
parameter_list|,
name|struct
name|bstp_pri_vector
modifier|*
name|cpv
parameter_list|)
block|{
if|if
condition|(
name|bstp_info_cmp
argument_list|(
name|pv
argument_list|,
name|cpv
argument_list|)
operator|==
name|INFO_BETTER
operator|||
operator|(
name|bstp_same_bridgeid
argument_list|(
name|pv
operator|->
name|pv_dbridge_id
argument_list|,
name|cpv
operator|->
name|pv_dbridge_id
argument_list|)
operator|&&
operator|(
name|cpv
operator|->
name|pv_dport_id
operator|&
literal|0xfff
operator|)
operator|==
operator|(
name|pv
operator|->
name|pv_dport_id
operator|&
literal|0xfff
operator|)
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_assign_roles
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|)
block|{
name|struct
name|bstp_port
modifier|*
name|bp
decl_stmt|,
modifier|*
name|rbp
init|=
name|NULL
decl_stmt|;
name|struct
name|bstp_pri_vector
name|pv
decl_stmt|;
comment|/* default to our priority vector */
name|bs
operator|->
name|bs_root_pv
operator|=
name|bs
operator|->
name|bs_bridge_pv
expr_stmt|;
name|bs
operator|->
name|bs_root_msg_age
operator|=
literal|0
expr_stmt|;
name|bs
operator|->
name|bs_root_max_age
operator|=
name|bs
operator|->
name|bs_bridge_max_age
expr_stmt|;
name|bs
operator|->
name|bs_root_fdelay
operator|=
name|bs
operator|->
name|bs_bridge_fdelay
expr_stmt|;
name|bs
operator|->
name|bs_root_htime
operator|=
name|bs
operator|->
name|bs_bridge_htime
expr_stmt|;
name|bs
operator|->
name|bs_root_port
operator|=
name|NULL
expr_stmt|;
comment|/* check if any recieved info supersedes us */
name|LIST_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&bs->bs_bplist
argument_list|,
argument|bp_next
argument_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|bp_infois
operator|!=
name|BSTP_INFO_RECIEVED
condition|)
continue|continue;
name|pv
operator|=
name|bp
operator|->
name|bp_port_pv
expr_stmt|;
name|pv
operator|.
name|pv_cost
operator|+=
name|bp
operator|->
name|bp_path_cost
expr_stmt|;
comment|/* 		 * The root priority vector is the best of the set comprising 		 * the bridge priority vector plus all root path priority 		 * vectors whose bridge address is not equal to us. 		 */
if|if
condition|(
name|bstp_same_bridgeid
argument_list|(
name|pv
operator|.
name|pv_dbridge_id
argument_list|,
name|bs
operator|->
name|bs_bridge_pv
operator|.
name|pv_dbridge_id
argument_list|)
operator|==
literal|0
operator|&&
name|bstp_info_cmp
argument_list|(
operator|&
name|bs
operator|->
name|bs_root_pv
argument_list|,
operator|&
name|pv
argument_list|)
operator|==
name|INFO_BETTER
condition|)
block|{
comment|/* the port vector replaces the root */
name|bs
operator|->
name|bs_root_pv
operator|=
name|pv
expr_stmt|;
name|bs
operator|->
name|bs_root_msg_age
operator|=
name|bp
operator|->
name|bp_port_msg_age
operator|+
name|BSTP_MESSAGE_AGE_INCR
expr_stmt|;
name|bs
operator|->
name|bs_root_max_age
operator|=
name|bp
operator|->
name|bp_port_max_age
expr_stmt|;
name|bs
operator|->
name|bs_root_fdelay
operator|=
name|bp
operator|->
name|bp_port_fdelay
expr_stmt|;
name|bs
operator|->
name|bs_root_htime
operator|=
name|bp
operator|->
name|bp_port_htime
expr_stmt|;
name|rbp
operator|=
name|bp
expr_stmt|;
block|}
block|}
name|LIST_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&bs->bs_bplist
argument_list|,
argument|bp_next
argument_list|)
block|{
comment|/* calculate the port designated vector */
name|bp
operator|->
name|bp_desg_pv
operator|.
name|pv_root_id
operator|=
name|bs
operator|->
name|bs_root_pv
operator|.
name|pv_root_id
expr_stmt|;
name|bp
operator|->
name|bp_desg_pv
operator|.
name|pv_cost
operator|=
name|bs
operator|->
name|bs_root_pv
operator|.
name|pv_cost
expr_stmt|;
name|bp
operator|->
name|bp_desg_pv
operator|.
name|pv_dbridge_id
operator|=
name|bs
operator|->
name|bs_bridge_pv
operator|.
name|pv_dbridge_id
expr_stmt|;
name|bp
operator|->
name|bp_desg_pv
operator|.
name|pv_dport_id
operator|=
name|bp
operator|->
name|bp_port_id
expr_stmt|;
name|bp
operator|->
name|bp_desg_pv
operator|.
name|pv_port_id
operator|=
name|bp
operator|->
name|bp_port_id
expr_stmt|;
comment|/* calculate designated times */
name|bp
operator|->
name|bp_desg_msg_age
operator|=
name|bs
operator|->
name|bs_root_msg_age
expr_stmt|;
name|bp
operator|->
name|bp_desg_max_age
operator|=
name|bs
operator|->
name|bs_root_max_age
expr_stmt|;
name|bp
operator|->
name|bp_desg_fdelay
operator|=
name|bs
operator|->
name|bs_root_fdelay
expr_stmt|;
name|bp
operator|->
name|bp_desg_htime
operator|=
name|bs
operator|->
name|bs_bridge_htime
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bp_infois
condition|)
block|{
case|case
name|BSTP_INFO_DISABLED
case|:
name|bstp_set_port_role
argument_list|(
name|bp
argument_list|,
name|BSTP_ROLE_DISABLED
argument_list|)
expr_stmt|;
break|break;
case|case
name|BSTP_INFO_AGED
case|:
name|bstp_set_port_role
argument_list|(
name|bp
argument_list|,
name|BSTP_ROLE_DESIGNATED
argument_list|)
expr_stmt|;
name|bstp_update_info
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
case|case
name|BSTP_INFO_MINE
case|:
name|bstp_set_port_role
argument_list|(
name|bp
argument_list|,
name|BSTP_ROLE_DESIGNATED
argument_list|)
expr_stmt|;
comment|/* update the port info if stale */
if|if
condition|(
name|bstp_info_cmp
argument_list|(
operator|&
name|bp
operator|->
name|bp_port_pv
argument_list|,
operator|&
name|bp
operator|->
name|bp_desg_pv
argument_list|)
operator|!=
name|INFO_SAME
operator|||
operator|(
name|rbp
operator|!=
name|NULL
operator|&&
operator|(
name|bp
operator|->
name|bp_port_msg_age
operator|!=
name|rbp
operator|->
name|bp_port_msg_age
operator|||
name|bp
operator|->
name|bp_port_max_age
operator|!=
name|rbp
operator|->
name|bp_port_max_age
operator|||
name|bp
operator|->
name|bp_port_fdelay
operator|!=
name|rbp
operator|->
name|bp_port_fdelay
operator|||
name|bp
operator|->
name|bp_port_htime
operator|!=
name|rbp
operator|->
name|bp_port_htime
operator|)
operator|)
condition|)
name|bstp_update_info
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
case|case
name|BSTP_INFO_RECIEVED
case|:
if|if
condition|(
name|bp
operator|==
name|rbp
condition|)
block|{
comment|/* 				 * root priority is derived from this 				 * port, make it the root port. 				 */
name|bstp_set_port_role
argument_list|(
name|bp
argument_list|,
name|BSTP_ROLE_ROOT
argument_list|)
expr_stmt|;
name|bs
operator|->
name|bs_root_port
operator|=
name|bp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bstp_info_cmp
argument_list|(
operator|&
name|bp
operator|->
name|bp_port_pv
argument_list|,
operator|&
name|bp
operator|->
name|bp_desg_pv
argument_list|)
operator|==
name|INFO_BETTER
condition|)
block|{
comment|/* 				 * the port priority is lower than the root 				 * port. 				 */
name|bstp_set_port_role
argument_list|(
name|bp
argument_list|,
name|BSTP_ROLE_DESIGNATED
argument_list|)
expr_stmt|;
name|bstp_update_info
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bstp_same_bridgeid
argument_list|(
name|bp
operator|->
name|bp_port_pv
operator|.
name|pv_dbridge_id
argument_list|,
name|bs
operator|->
name|bs_bridge_pv
operator|.
name|pv_dbridge_id
argument_list|)
condition|)
block|{
comment|/* 					 * the designated bridge refers to 					 * another port on this bridge. 					 */
name|bstp_set_port_role
argument_list|(
name|bp
argument_list|,
name|BSTP_ROLE_BACKUP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * the port is an inferior path to the 					 * root bridge. 					 */
name|bstp_set_port_role
argument_list|(
name|bp
argument_list|,
name|BSTP_ROLE_ALTERNATE
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_update_state
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|bstp_port
modifier|*
name|bp2
decl_stmt|;
name|int
name|synced
decl_stmt|;
name|BSTP_LOCK_ASSERT
argument_list|(
name|bs
argument_list|)
expr_stmt|;
comment|/* check if all the ports have syncronised again */
if|if
condition|(
operator|!
name|bs
operator|->
name|bs_allsynced
condition|)
block|{
name|synced
operator|=
literal|1
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bp2
argument_list|,
argument|&bs->bs_bplist
argument_list|,
argument|bp_next
argument_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|bp_synced
operator|||
name|bp
operator|->
name|bp_role
operator|==
name|BSTP_ROLE_ROOT
operator|)
condition|)
block|{
name|synced
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|bs
operator|->
name|bs_allsynced
operator|=
name|synced
expr_stmt|;
block|}
name|bstp_update_roles
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bstp_update_tc
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_update_roles
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|)
block|{
switch|switch
condition|(
name|bp
operator|->
name|bp_role
condition|)
block|{
case|case
name|BSTP_ROLE_DISABLED
case|:
comment|/* Clear any flags if set */
if|if
condition|(
name|bp
operator|->
name|bp_sync
operator|||
operator|!
name|bp
operator|->
name|bp_synced
operator|||
name|bp
operator|->
name|bp_reroot
condition|)
block|{
name|bp
operator|->
name|bp_sync
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bp_synced
operator|=
literal|1
expr_stmt|;
name|bp
operator|->
name|bp_reroot
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|BSTP_ROLE_ALTERNATE
case|:
case|case
name|BSTP_ROLE_BACKUP
case|:
if|if
condition|(
operator|(
name|bs
operator|->
name|bs_allsynced
operator|&&
operator|!
name|bp
operator|->
name|bp_agree
operator|)
operator|||
operator|(
name|bp
operator|->
name|bp_proposed
operator|&&
name|bp
operator|->
name|bp_agree
operator|)
condition|)
block|{
name|bp
operator|->
name|bp_proposed
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bp_agree
operator|=
literal|1
expr_stmt|;
name|bp
operator|->
name|bp_flags
operator||=
name|BSTP_PORT_NEWINFO
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%s -> ALTERNATE_AGREED\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|bp_proposed
operator|&&
operator|!
name|bp
operator|->
name|bp_agree
condition|)
block|{
name|bstp_set_all_sync
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_proposed
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%s -> ALTERNATE_PROPOSED\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
comment|/* Clear any flags if set */
if|if
condition|(
name|bp
operator|->
name|bp_sync
operator|||
operator|!
name|bp
operator|->
name|bp_synced
operator|||
name|bp
operator|->
name|bp_reroot
condition|)
block|{
name|bp
operator|->
name|bp_sync
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bp_synced
operator|=
literal|1
expr_stmt|;
name|bp
operator|->
name|bp_reroot
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%s -> ALTERNATE_PORT\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BSTP_ROLE_ROOT
case|:
if|if
condition|(
name|bp
operator|->
name|bp_state
operator|!=
name|BSTP_IFSTATE_FORWARDING
operator|&&
operator|!
name|bp
operator|->
name|bp_reroot
condition|)
block|{
name|bstp_set_all_reroot
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%s -> ROOT_REROOT\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bs
operator|->
name|bs_allsynced
operator|&&
operator|!
name|bp
operator|->
name|bp_agree
operator|)
operator|||
operator|(
name|bp
operator|->
name|bp_proposed
operator|&&
name|bp
operator|->
name|bp_agree
operator|)
condition|)
block|{
name|bp
operator|->
name|bp_proposed
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bp_sync
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bp_agree
operator|=
literal|1
expr_stmt|;
name|bp
operator|->
name|bp_flags
operator||=
name|BSTP_PORT_NEWINFO
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%s -> ROOT_AGREED\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|bp_proposed
operator|&&
operator|!
name|bp
operator|->
name|bp_agree
condition|)
block|{
name|bstp_set_all_sync
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_proposed
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%s -> ROOT_PROPOSED\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|bp_state
operator|!=
name|BSTP_IFSTATE_FORWARDING
operator|&&
operator|(
name|bp
operator|->
name|bp_forward_delay_timer
operator|.
name|active
operator|==
literal|0
operator|||
operator|(
name|bstp_rerooted
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
operator|&&
name|bp
operator|->
name|bp_recent_backup_timer
operator|.
name|active
operator|==
literal|0
operator|&&
name|bp
operator|->
name|bp_protover
operator|==
name|BSTP_PROTO_RSTP
operator|)
operator|)
condition|)
block|{
switch|switch
condition|(
name|bp
operator|->
name|bp_state
condition|)
block|{
case|case
name|BSTP_IFSTATE_DISCARDING
case|:
name|bstp_set_port_state
argument_list|(
name|bp
argument_list|,
name|BSTP_IFSTATE_LEARNING
argument_list|)
expr_stmt|;
break|break;
case|case
name|BSTP_IFSTATE_LEARNING
case|:
name|bstp_set_port_state
argument_list|(
name|bp
argument_list|,
name|BSTP_IFSTATE_FORWARDING
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bp
operator|->
name|bp_state
operator|==
name|BSTP_IFSTATE_FORWARDING
operator|&&
name|bp
operator|->
name|bp_reroot
condition|)
block|{
name|bp
operator|->
name|bp_reroot
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%s -> ROOT_REROOTED\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BSTP_ROLE_DESIGNATED
case|:
if|if
condition|(
name|bp
operator|->
name|bp_recent_root_timer
operator|.
name|active
operator|==
literal|0
operator|&&
name|bp
operator|->
name|bp_reroot
condition|)
block|{
name|bp
operator|->
name|bp_reroot
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%s -> DESIGNATED_RETIRED\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bp
operator|->
name|bp_state
operator|==
name|BSTP_IFSTATE_DISCARDING
operator|&&
operator|!
name|bp
operator|->
name|bp_synced
operator|)
operator|||
operator|(
name|bp
operator|->
name|bp_agreed
operator|&&
operator|!
name|bp
operator|->
name|bp_synced
operator|)
operator|||
operator|(
name|bp
operator|->
name|bp_operedge
operator|&&
operator|!
name|bp
operator|->
name|bp_synced
operator|)
operator|||
operator|(
name|bp
operator|->
name|bp_sync
operator|&&
name|bp
operator|->
name|bp_synced
operator|)
condition|)
block|{
name|bstp_timer_stop
argument_list|(
operator|&
name|bp
operator|->
name|bp_recent_root_timer
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_synced
operator|=
literal|1
expr_stmt|;
name|bp
operator|->
name|bp_sync
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%s -> DESIGNATED_SYNCED\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|bp_state
operator|!=
name|BSTP_IFSTATE_FORWARDING
operator|&&
operator|!
name|bp
operator|->
name|bp_agreed
operator|&&
operator|!
name|bp
operator|->
name|bp_proposing
operator|&&
operator|!
name|bp
operator|->
name|bp_operedge
condition|)
block|{
name|bp
operator|->
name|bp_proposing
operator|=
literal|1
expr_stmt|;
name|bp
operator|->
name|bp_flags
operator||=
name|BSTP_PORT_NEWINFO
expr_stmt|;
name|bstp_timer_start
argument_list|(
operator|&
name|bp
operator|->
name|bp_edge_delay_timer
argument_list|,
operator|(
name|bp
operator|->
name|bp_p2p_link
condition|?
name|BSTP_DEFAULT_MIGRATE_DELAY
else|:
name|bp
operator|->
name|bp_desg_max_age
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%s -> DESIGNATED_PROPOSE\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|bp_state
operator|!=
name|BSTP_IFSTATE_FORWARDING
operator|&&
operator|(
name|bp
operator|->
name|bp_forward_delay_timer
operator|.
name|active
operator|==
literal|0
operator|||
name|bp
operator|->
name|bp_agreed
operator|||
name|bp
operator|->
name|bp_operedge
operator|)
operator|&&
operator|(
name|bp
operator|->
name|bp_recent_root_timer
operator|.
name|active
operator|==
literal|0
operator|||
operator|!
name|bp
operator|->
name|bp_reroot
operator|)
operator|&&
operator|!
name|bp
operator|->
name|bp_sync
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|bp_agreed
condition|)
name|DPRINTF
argument_list|(
literal|"%s -> AGREED\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
comment|/* 			 * If agreed|operedge then go straight to forwarding, 			 * otherwise follow discard -> learn -> forward. 			 */
if|if
condition|(
name|bp
operator|->
name|bp_agreed
operator|||
name|bp
operator|->
name|bp_operedge
operator|||
name|bp
operator|->
name|bp_state
operator|==
name|BSTP_IFSTATE_LEARNING
condition|)
block|{
name|bstp_set_port_state
argument_list|(
name|bp
argument_list|,
name|BSTP_IFSTATE_FORWARDING
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_agreed
operator|=
name|bp
operator|->
name|bp_protover
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
operator|->
name|bp_state
operator|==
name|BSTP_IFSTATE_DISCARDING
condition|)
name|bstp_set_port_state
argument_list|(
name|bp
argument_list|,
name|BSTP_IFSTATE_LEARNING
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|bp
operator|->
name|bp_sync
operator|&&
operator|!
name|bp
operator|->
name|bp_synced
operator|)
operator|||
operator|(
name|bp
operator|->
name|bp_reroot
operator|&&
name|bp
operator|->
name|bp_recent_root_timer
operator|.
name|active
operator|)
operator|||
operator|(
name|bp
operator|->
name|bp_flags
operator|&
name|BSTP_PORT_DISPUTED
operator|)
operator|)
operator|&&
operator|!
name|bp
operator|->
name|bp_operedge
operator|&&
name|bp
operator|->
name|bp_state
operator|!=
name|BSTP_IFSTATE_DISCARDING
condition|)
block|{
name|bstp_set_port_state
argument_list|(
name|bp
argument_list|,
name|BSTP_IFSTATE_DISCARDING
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_flags
operator|&=
operator|~
name|BSTP_PORT_DISPUTED
expr_stmt|;
name|bstp_timer_start
argument_list|(
operator|&
name|bp
operator|->
name|bp_forward_delay_timer
argument_list|,
name|bp
operator|->
name|bp_protover
operator|==
name|BSTP_PROTO_RSTP
condition|?
name|bp
operator|->
name|bp_desg_htime
else|:
name|bp
operator|->
name|bp_desg_fdelay
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%s -> DESIGNATED_DISCARD\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|bp
operator|->
name|bp_flags
operator|&
name|BSTP_PORT_NEWINFO
condition|)
name|bstp_transmit
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_update_tc
parameter_list|(
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|)
block|{
switch|switch
condition|(
name|bp
operator|->
name|bp_tcstate
condition|)
block|{
case|case
name|BSTP_TCSTATE_ACTIVE
case|:
if|if
condition|(
operator|(
name|bp
operator|->
name|bp_role
operator|!=
name|BSTP_ROLE_DESIGNATED
operator|&&
name|bp
operator|->
name|bp_role
operator|!=
name|BSTP_ROLE_ROOT
operator|)
operator|||
name|bp
operator|->
name|bp_operedge
condition|)
name|bstp_set_port_tc
argument_list|(
name|bp
argument_list|,
name|BSTP_TCSTATE_LEARNING
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_rcvdtcn
condition|)
name|bstp_set_port_tc
argument_list|(
name|bp
argument_list|,
name|BSTP_TCSTATE_TCN
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_rcvdtc
condition|)
name|bstp_set_port_tc
argument_list|(
name|bp
argument_list|,
name|BSTP_TCSTATE_TC
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_tc_prop
operator|&&
operator|!
name|bp
operator|->
name|bp_operedge
condition|)
name|bstp_set_port_tc
argument_list|(
name|bp
argument_list|,
name|BSTP_TCSTATE_PROPAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_rcvdtca
condition|)
name|bstp_set_port_tc
argument_list|(
name|bp
argument_list|,
name|BSTP_TCSTATE_ACK
argument_list|)
expr_stmt|;
break|break;
case|case
name|BSTP_TCSTATE_INACTIVE
case|:
if|if
condition|(
operator|(
name|bp
operator|->
name|bp_state
operator|==
name|BSTP_IFSTATE_LEARNING
operator|||
name|bp
operator|->
name|bp_state
operator|==
name|BSTP_IFSTATE_FORWARDING
operator|)
operator|&&
name|bp
operator|->
name|bp_fdbflush
operator|==
literal|0
condition|)
name|bstp_set_port_tc
argument_list|(
name|bp
argument_list|,
name|BSTP_TCSTATE_LEARNING
argument_list|)
expr_stmt|;
break|break;
case|case
name|BSTP_TCSTATE_LEARNING
case|:
if|if
condition|(
name|bp
operator|->
name|bp_rcvdtc
operator|||
name|bp
operator|->
name|bp_rcvdtcn
operator|||
name|bp
operator|->
name|bp_rcvdtca
operator|||
name|bp
operator|->
name|bp_tc_prop
condition|)
name|bstp_set_port_tc
argument_list|(
name|bp
argument_list|,
name|BSTP_TCSTATE_LEARNING
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bp
operator|->
name|bp_role
operator|!=
name|BSTP_ROLE_DESIGNATED
operator|&&
name|bp
operator|->
name|bp_role
operator|!=
name|BSTP_ROLE_ROOT
operator|&&
name|bp
operator|->
name|bp_state
operator|==
name|BSTP_IFSTATE_DISCARDING
condition|)
name|bstp_set_port_tc
argument_list|(
name|bp
argument_list|,
name|BSTP_TCSTATE_INACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|bp_role
operator|==
name|BSTP_ROLE_DESIGNATED
operator|||
name|bp
operator|->
name|bp_role
operator|==
name|BSTP_ROLE_ROOT
operator|)
operator|&&
name|bp
operator|->
name|bp_state
operator|==
name|BSTP_IFSTATE_FORWARDING
operator|&&
operator|!
name|bp
operator|->
name|bp_operedge
condition|)
name|bstp_set_port_tc
argument_list|(
name|bp
argument_list|,
name|BSTP_TCSTATE_DETECTED
argument_list|)
expr_stmt|;
break|break;
comment|/* these are transient states and go straight back to ACTIVE */
case|case
name|BSTP_TCSTATE_DETECTED
case|:
case|case
name|BSTP_TCSTATE_TCN
case|:
case|case
name|BSTP_TCSTATE_TC
case|:
case|case
name|BSTP_TCSTATE_PROPAG
case|:
case|case
name|BSTP_TCSTATE_ACK
case|:
name|DPRINTF
argument_list|(
literal|"Invalid TC state for %s\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_update_info
parameter_list|(
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|bstp_state
modifier|*
name|bs
init|=
name|bp
operator|->
name|bp_bs
decl_stmt|;
name|bp
operator|->
name|bp_proposing
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bp_proposed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_agreed
operator|&&
operator|!
name|bstp_pdu_bettersame
argument_list|(
name|bp
argument_list|,
name|BSTP_INFO_MINE
argument_list|)
condition|)
name|bp
operator|->
name|bp_agreed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_synced
operator|&&
operator|!
name|bp
operator|->
name|bp_agreed
condition|)
block|{
name|bp
operator|->
name|bp_synced
operator|=
literal|0
expr_stmt|;
name|bs
operator|->
name|bs_allsynced
operator|=
literal|0
expr_stmt|;
block|}
comment|/* copy the designated pv to the port */
name|bp
operator|->
name|bp_port_pv
operator|=
name|bp
operator|->
name|bp_desg_pv
expr_stmt|;
name|bp
operator|->
name|bp_port_msg_age
operator|=
name|bp
operator|->
name|bp_desg_msg_age
expr_stmt|;
name|bp
operator|->
name|bp_port_max_age
operator|=
name|bp
operator|->
name|bp_desg_max_age
expr_stmt|;
name|bp
operator|->
name|bp_port_fdelay
operator|=
name|bp
operator|->
name|bp_desg_fdelay
expr_stmt|;
name|bp
operator|->
name|bp_port_htime
operator|=
name|bp
operator|->
name|bp_desg_htime
expr_stmt|;
name|bp
operator|->
name|bp_infois
operator|=
name|BSTP_INFO_MINE
expr_stmt|;
comment|/* Set transmit flag but do not immediately send */
name|bp
operator|->
name|bp_flags
operator||=
name|BSTP_PORT_NEWINFO
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set tcprop on every port other than the caller */
end_comment

begin_function
specifier|static
name|void
name|bstp_set_other_tcprop
parameter_list|(
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|bstp_state
modifier|*
name|bs
init|=
name|bp
operator|->
name|bp_bs
decl_stmt|;
name|struct
name|bstp_port
modifier|*
name|bp2
decl_stmt|;
name|BSTP_LOCK_ASSERT
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bp2
argument_list|,
argument|&bs->bs_bplist
argument_list|,
argument|bp_next
argument_list|)
block|{
if|if
condition|(
name|bp2
operator|==
name|bp
condition|)
continue|continue;
name|bp
operator|->
name|bp_tc_prop
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_set_all_reroot
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|)
block|{
name|struct
name|bstp_port
modifier|*
name|bp
decl_stmt|;
name|BSTP_LOCK_ASSERT
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&bs->bs_bplist
argument_list|,
argument|bp_next
argument_list|)
name|bp
operator|->
name|bp_reroot
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_set_all_sync
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|)
block|{
name|struct
name|bstp_port
modifier|*
name|bp
decl_stmt|;
name|BSTP_LOCK_ASSERT
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&bs->bs_bplist
argument_list|,
argument|bp_next
argument_list|)
block|{
name|bp
operator|->
name|bp_sync
operator|=
literal|1
expr_stmt|;
name|bp
operator|->
name|bp_synced
operator|=
literal|0
expr_stmt|;
comment|/* Not explicit in spec */
block|}
name|bs
operator|->
name|bs_allsynced
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_set_port_state
parameter_list|(
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|,
name|int
name|state
parameter_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|bp_state
operator|==
name|state
condition|)
return|return;
name|bp
operator|->
name|bp_state
operator|=
name|state
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bp_state
condition|)
block|{
case|case
name|BSTP_IFSTATE_DISCARDING
case|:
name|DPRINTF
argument_list|(
literal|"state changed to DISCARDING on %s\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
break|break;
case|case
name|BSTP_IFSTATE_LEARNING
case|:
name|DPRINTF
argument_list|(
literal|"state changed to LEARNING on %s\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|bstp_timer_start
argument_list|(
operator|&
name|bp
operator|->
name|bp_forward_delay_timer
argument_list|,
name|bp
operator|->
name|bp_protover
operator|==
name|BSTP_PROTO_RSTP
condition|?
name|bp
operator|->
name|bp_desg_htime
else|:
name|bp
operator|->
name|bp_desg_fdelay
argument_list|)
expr_stmt|;
break|break;
case|case
name|BSTP_IFSTATE_FORWARDING
case|:
name|DPRINTF
argument_list|(
literal|"state changed to FORWARDING on %s\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|bstp_timer_stop
argument_list|(
operator|&
name|bp
operator|->
name|bp_forward_delay_timer
argument_list|)
expr_stmt|;
comment|/* Record that we enabled forwarding */
name|bp
operator|->
name|bp_forward_transitions
operator|++
expr_stmt|;
break|break;
block|}
comment|/* notify the parent bridge */
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|bp
operator|->
name|bp_statetask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_set_port_role
parameter_list|(
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|,
name|int
name|role
parameter_list|)
block|{
name|struct
name|bstp_state
modifier|*
name|bs
init|=
name|bp
operator|->
name|bp_bs
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_role
operator|==
name|role
condition|)
return|return;
comment|/* perform pre-change tasks */
switch|switch
condition|(
name|bp
operator|->
name|bp_role
condition|)
block|{
case|case
name|BSTP_ROLE_DISABLED
case|:
name|bstp_timer_start
argument_list|(
operator|&
name|bp
operator|->
name|bp_forward_delay_timer
argument_list|,
name|bp
operator|->
name|bp_desg_max_age
argument_list|)
expr_stmt|;
break|break;
case|case
name|BSTP_ROLE_BACKUP
case|:
name|bstp_timer_start
argument_list|(
operator|&
name|bp
operator|->
name|bp_recent_backup_timer
argument_list|,
name|bp
operator|->
name|bp_desg_htime
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|BSTP_ROLE_ALTERNATE
case|:
name|bstp_timer_start
argument_list|(
operator|&
name|bp
operator|->
name|bp_forward_delay_timer
argument_list|,
name|bp
operator|->
name|bp_desg_fdelay
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_sync
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bp_synced
operator|=
literal|1
expr_stmt|;
name|bp
operator|->
name|bp_reroot
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BSTP_ROLE_ROOT
case|:
name|bstp_timer_start
argument_list|(
operator|&
name|bp
operator|->
name|bp_recent_root_timer
argument_list|,
name|BSTP_DEFAULT_FORWARD_DELAY
argument_list|)
expr_stmt|;
break|break;
block|}
name|bp
operator|->
name|bp_role
operator|=
name|role
expr_stmt|;
comment|/* clear values not carried between roles */
name|bp
operator|->
name|bp_proposing
operator|=
literal|0
expr_stmt|;
name|bs
operator|->
name|bs_allsynced
operator|=
literal|0
expr_stmt|;
comment|/* initialise the new role */
switch|switch
condition|(
name|bp
operator|->
name|bp_role
condition|)
block|{
case|case
name|BSTP_ROLE_DISABLED
case|:
case|case
name|BSTP_ROLE_ALTERNATE
case|:
case|case
name|BSTP_ROLE_BACKUP
case|:
name|DPRINTF
argument_list|(
literal|"%s role -> ALT/BACK/DISABLED\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|bstp_set_port_state
argument_list|(
name|bp
argument_list|,
name|BSTP_IFSTATE_DISCARDING
argument_list|)
expr_stmt|;
name|bstp_timer_stop
argument_list|(
operator|&
name|bp
operator|->
name|bp_recent_root_timer
argument_list|)
expr_stmt|;
name|bstp_timer_latch
argument_list|(
operator|&
name|bp
operator|->
name|bp_forward_delay_timer
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_sync
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bp_synced
operator|=
literal|1
expr_stmt|;
name|bp
operator|->
name|bp_reroot
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BSTP_ROLE_ROOT
case|:
name|DPRINTF
argument_list|(
literal|"%s role -> ROOT\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|bstp_set_port_state
argument_list|(
name|bp
argument_list|,
name|BSTP_IFSTATE_DISCARDING
argument_list|)
expr_stmt|;
name|bstp_timer_latch
argument_list|(
operator|&
name|bp
operator|->
name|bp_recent_root_timer
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_proposing
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BSTP_ROLE_DESIGNATED
case|:
name|DPRINTF
argument_list|(
literal|"%s role -> DESIGNATED\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|bstp_timer_start
argument_list|(
operator|&
name|bp
operator|->
name|bp_hello_timer
argument_list|,
name|bp
operator|->
name|bp_desg_htime
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_agree
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* let the TC state know that the role changed */
name|bstp_update_tc
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_set_port_proto
parameter_list|(
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|,
name|int
name|proto
parameter_list|)
block|{
name|struct
name|bstp_state
modifier|*
name|bs
init|=
name|bp
operator|->
name|bp_bs
decl_stmt|;
comment|/* supported protocol versions */
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|BSTP_PROTO_STP
case|:
comment|/* we can downgrade protocols only */
name|bstp_timer_stop
argument_list|(
operator|&
name|bp
operator|->
name|bp_migrate_delay_timer
argument_list|)
expr_stmt|;
comment|/* clear unsupported features */
name|bp
operator|->
name|bp_operedge
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|BSTP_PROTO_RSTP
case|:
name|bstp_timer_start
argument_list|(
operator|&
name|bp
operator|->
name|bp_migrate_delay_timer
argument_list|,
name|bs
operator|->
name|bs_migration_delay
argument_list|)
expr_stmt|;
break|break;
default|default:
name|DPRINTF
argument_list|(
literal|"Unsupported STP version %d\n"
argument_list|,
name|proto
argument_list|)
expr_stmt|;
return|return;
block|}
name|bp
operator|->
name|bp_protover
operator|=
name|proto
expr_stmt|;
name|bp
operator|->
name|bp_flags
operator|&=
operator|~
name|BSTP_PORT_CANMIGRATE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_set_port_tc
parameter_list|(
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|bstp_state
modifier|*
name|bs
init|=
name|bp
operator|->
name|bp_bs
decl_stmt|;
name|bp
operator|->
name|bp_tcstate
operator|=
name|state
expr_stmt|;
comment|/* initialise the new state */
switch|switch
condition|(
name|bp
operator|->
name|bp_tcstate
condition|)
block|{
case|case
name|BSTP_TCSTATE_ACTIVE
case|:
name|DPRINTF
argument_list|(
literal|"%s -> TC_ACTIVE\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
comment|/* nothing to do */
break|break;
case|case
name|BSTP_TCSTATE_INACTIVE
case|:
name|bstp_timer_stop
argument_list|(
operator|&
name|bp
operator|->
name|bp_tc_timer
argument_list|)
expr_stmt|;
comment|/* flush routes on the parent bridge */
name|bp
operator|->
name|bp_fdbflush
operator|=
literal|1
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|bp
operator|->
name|bp_rtagetask
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_tc_ack
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%s -> TC_INACTIVE\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
break|break;
case|case
name|BSTP_TCSTATE_LEARNING
case|:
name|bp
operator|->
name|bp_rcvdtc
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bp_rcvdtcn
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bp_rcvdtca
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bp_tc_prop
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%s -> TC_LEARNING\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
break|break;
case|case
name|BSTP_TCSTATE_DETECTED
case|:
name|bstp_set_timer_tc
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bstp_set_other_tcprop
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* send out notification */
name|bp
operator|->
name|bp_flags
operator||=
name|BSTP_PORT_NEWINFO
expr_stmt|;
name|bstp_transmit
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|bs
operator|->
name|bs_last_tc_time
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%s -> TC_DETECTED\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_tcstate
operator|=
name|BSTP_TCSTATE_ACTIVE
expr_stmt|;
comment|/* UCT */
break|break;
case|case
name|BSTP_TCSTATE_TCN
case|:
name|bstp_set_timer_tc
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%s -> TC_TCN\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
name|BSTP_TCSTATE_TC
case|:
name|bp
operator|->
name|bp_rcvdtc
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bp_rcvdtcn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_role
operator|==
name|BSTP_ROLE_DESIGNATED
condition|)
name|bp
operator|->
name|bp_tc_ack
operator|=
literal|1
expr_stmt|;
name|bstp_set_other_tcprop
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%s -> TC_TC\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_tcstate
operator|=
name|BSTP_TCSTATE_ACTIVE
expr_stmt|;
comment|/* UCT */
break|break;
case|case
name|BSTP_TCSTATE_PROPAG
case|:
comment|/* flush routes on the parent bridge */
name|bp
operator|->
name|bp_fdbflush
operator|=
literal|1
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|bp
operator|->
name|bp_rtagetask
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_tc_prop
operator|=
literal|0
expr_stmt|;
name|bstp_set_timer_tc
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%s -> TC_PROPAG\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_tcstate
operator|=
name|BSTP_TCSTATE_ACTIVE
expr_stmt|;
comment|/* UCT */
break|break;
case|case
name|BSTP_TCSTATE_ACK
case|:
name|bstp_timer_stop
argument_list|(
operator|&
name|bp
operator|->
name|bp_tc_timer
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_rcvdtca
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%s -> TC_ACK\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_tcstate
operator|=
name|BSTP_TCSTATE_ACTIVE
expr_stmt|;
comment|/* UCT */
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_set_timer_tc
parameter_list|(
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|bstp_state
modifier|*
name|bs
init|=
name|bp
operator|->
name|bp_bs
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_tc_timer
operator|.
name|active
condition|)
return|return;
switch|switch
condition|(
name|bp
operator|->
name|bp_protover
condition|)
block|{
case|case
name|BSTP_PROTO_RSTP
case|:
name|bstp_timer_start
argument_list|(
operator|&
name|bp
operator|->
name|bp_tc_timer
argument_list|,
name|bp
operator|->
name|bp_desg_htime
operator|+
name|BSTP_TICK_VAL
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_flags
operator||=
name|BSTP_PORT_NEWINFO
expr_stmt|;
break|break;
case|case
name|BSTP_PROTO_STP
case|:
name|bstp_timer_start
argument_list|(
operator|&
name|bp
operator|->
name|bp_tc_timer
argument_list|,
name|bs
operator|->
name|bs_root_max_age
operator|+
name|bs
operator|->
name|bs_root_fdelay
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_set_timer_msgage
parameter_list|(
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|bp_port_msg_age
operator|+
name|BSTP_MESSAGE_AGE_INCR
operator|<=
name|bp
operator|->
name|bp_port_max_age
condition|)
block|{
name|bstp_timer_start
argument_list|(
operator|&
name|bp
operator|->
name|bp_message_age_timer
argument_list|,
name|bp
operator|->
name|bp_port_htime
operator|*
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* expires immediately */
name|bstp_timer_start
argument_list|(
operator|&
name|bp
operator|->
name|bp_message_age_timer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bstp_rerooted
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|bstp_port
modifier|*
name|bp2
decl_stmt|;
name|int
name|rr_set
init|=
literal|0
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bp2
argument_list|,
argument|&bs->bs_bplist
argument_list|,
argument|bp_next
argument_list|)
block|{
if|if
condition|(
name|bp2
operator|==
name|bp
condition|)
continue|continue;
if|if
condition|(
name|bp2
operator|->
name|bp_recent_root_timer
operator|.
name|active
condition|)
block|{
name|rr_set
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
operator|!
name|rr_set
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bstp_set_htime
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|int
name|t
parameter_list|)
block|{
comment|/* convert seconds to ticks */
name|t
operator|*=
name|BSTP_TICK_VAL
expr_stmt|;
comment|/* value can only be changed in leagacy stp mode */
if|if
condition|(
name|bs
operator|->
name|bs_protover
operator|!=
name|BSTP_PROTO_STP
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|t
operator|<
name|BSTP_MIN_HELLO_TIME
operator|||
name|t
operator|>
name|BSTP_MAX_HELLO_TIME
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|BSTP_LOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|bs
operator|->
name|bs_bridge_htime
operator|=
name|t
expr_stmt|;
name|bstp_reinit
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|BSTP_UNLOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bstp_set_fdelay
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|int
name|t
parameter_list|)
block|{
comment|/* convert seconds to ticks */
name|t
operator|*=
name|BSTP_TICK_VAL
expr_stmt|;
if|if
condition|(
name|t
operator|<
name|BSTP_MIN_FORWARD_DELAY
operator|||
name|t
operator|>
name|BSTP_MAX_FORWARD_DELAY
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|BSTP_LOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|bs
operator|->
name|bs_bridge_fdelay
operator|=
name|t
expr_stmt|;
name|bstp_reinit
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|BSTP_UNLOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bstp_set_maxage
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|int
name|t
parameter_list|)
block|{
comment|/* convert seconds to ticks */
name|t
operator|*=
name|BSTP_TICK_VAL
expr_stmt|;
if|if
condition|(
name|t
operator|<
name|BSTP_MIN_MAX_AGE
operator|||
name|t
operator|>
name|BSTP_MAX_MAX_AGE
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|BSTP_LOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|bs
operator|->
name|bs_bridge_max_age
operator|=
name|t
expr_stmt|;
name|bstp_reinit
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|BSTP_UNLOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bstp_set_holdcount
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|bstp_port
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|count
operator|<
name|BSTP_MIN_HOLD_COUNT
operator|||
name|count
operator|>
name|BSTP_MAX_HOLD_COUNT
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|BSTP_LOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|bs
operator|->
name|bs_txholdcount
operator|=
name|count
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&bs->bs_bplist
argument_list|,
argument|bp_next
argument_list|)
name|bp
operator|->
name|bp_txcount
operator|=
literal|0
expr_stmt|;
name|BSTP_UNLOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bstp_set_protocol
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|int
name|proto
parameter_list|)
block|{
name|struct
name|bstp_port
modifier|*
name|bp
decl_stmt|;
switch|switch
condition|(
name|proto
condition|)
block|{
comment|/* Supported protocol versions */
case|case
name|BSTP_PROTO_STP
case|:
case|case
name|BSTP_PROTO_RSTP
case|:
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|BSTP_LOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|bs
operator|->
name|bs_protover
operator|=
name|proto
expr_stmt|;
name|bs
operator|->
name|bs_bridge_htime
operator|=
name|BSTP_DEFAULT_HELLO_TIME
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&bs->bs_bplist
argument_list|,
argument|bp_next
argument_list|)
block|{
comment|/* reinit state */
name|bp
operator|->
name|bp_infois
operator|=
name|BSTP_INFO_DISABLED
expr_stmt|;
name|bp
operator|->
name|bp_txcount
operator|=
literal|0
expr_stmt|;
name|bstp_set_port_proto
argument_list|(
name|bp
argument_list|,
name|bs
operator|->
name|bs_protover
argument_list|)
expr_stmt|;
name|bstp_set_port_role
argument_list|(
name|bp
argument_list|,
name|BSTP_ROLE_DISABLED
argument_list|)
expr_stmt|;
name|bstp_set_port_tc
argument_list|(
name|bp
argument_list|,
name|BSTP_TCSTATE_INACTIVE
argument_list|)
expr_stmt|;
name|bstp_timer_stop
argument_list|(
operator|&
name|bp
operator|->
name|bp_recent_backup_timer
argument_list|)
expr_stmt|;
block|}
name|bstp_reinit
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|BSTP_UNLOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bstp_set_priority
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|int
name|pri
parameter_list|)
block|{
if|if
condition|(
name|pri
operator|<
literal|0
operator|||
name|pri
operator|>
name|BSTP_MAX_PRIORITY
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Limit to steps of 4096 */
name|pri
operator|-=
name|pri
operator|%
literal|4096
expr_stmt|;
name|BSTP_LOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|bs
operator|->
name|bs_bridge_priority
operator|=
name|pri
expr_stmt|;
name|bstp_reinit
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|BSTP_UNLOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bstp_set_port_priority
parameter_list|(
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|,
name|int
name|pri
parameter_list|)
block|{
name|struct
name|bstp_state
modifier|*
name|bs
init|=
name|bp
operator|->
name|bp_bs
decl_stmt|;
if|if
condition|(
name|pri
operator|<
literal|0
operator|||
name|pri
operator|>
name|BSTP_MAX_PORT_PRIORITY
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Limit to steps of 16 */
name|pri
operator|-=
name|pri
operator|%
literal|16
expr_stmt|;
name|BSTP_LOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_priority
operator|=
name|pri
expr_stmt|;
name|bstp_reinit
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|BSTP_UNLOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bstp_set_path_cost
parameter_list|(
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|,
name|uint32_t
name|path_cost
parameter_list|)
block|{
name|struct
name|bstp_state
modifier|*
name|bs
init|=
name|bp
operator|->
name|bp_bs
decl_stmt|;
if|if
condition|(
name|path_cost
operator|>
name|BSTP_MAX_PATH_COST
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|BSTP_LOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_cost
operator|==
literal|0
condition|)
block|{
comment|/* use auto */
name|bp
operator|->
name|bp_flags
operator|&=
operator|~
name|BSTP_PORT_ADMCOST
expr_stmt|;
name|bp
operator|->
name|bp_path_cost
operator|=
name|bstp_calc_path_cost
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|bp_path_cost
operator|=
name|path_cost
expr_stmt|;
name|bp
operator|->
name|bp_flags
operator||=
name|BSTP_PORT_ADMCOST
expr_stmt|;
block|}
name|bstp_reinit
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|BSTP_UNLOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bstp_set_edge
parameter_list|(
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|,
name|int
name|set
parameter_list|)
block|{
name|struct
name|bstp_state
modifier|*
name|bs
init|=
name|bp
operator|->
name|bp_bs
decl_stmt|;
name|BSTP_LOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_operedge
operator|=
name|set
expr_stmt|;
name|BSTP_UNLOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bstp_set_autoedge
parameter_list|(
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|,
name|int
name|set
parameter_list|)
block|{
name|struct
name|bstp_state
modifier|*
name|bs
init|=
name|bp
operator|->
name|bp_bs
decl_stmt|;
name|BSTP_LOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
name|bp
operator|->
name|bp_flags
operator||=
name|BSTP_PORT_AUTOEDGE
expr_stmt|;
comment|/* we may be able to transition straight to edge */
if|if
condition|(
name|bp
operator|->
name|bp_edge_delay_timer
operator|.
name|active
operator|==
literal|0
condition|)
name|bstp_edge_delay_expiry
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
name|bp
operator|->
name|bp_flags
operator|&=
operator|~
name|BSTP_PORT_AUTOEDGE
expr_stmt|;
name|BSTP_UNLOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the path cost according to the link speed.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|bstp_calc_path_cost
parameter_list|(
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|bp
operator|->
name|bp_ifp
decl_stmt|;
name|uint32_t
name|path_cost
decl_stmt|;
comment|/* If the priority has been manually set then retain the value */
if|if
condition|(
name|bp
operator|->
name|bp_flags
operator|&
name|BSTP_PORT_ADMCOST
condition|)
return|return
name|bp
operator|->
name|bp_path_cost
return|;
if|if
condition|(
name|ifp
operator|->
name|if_baudrate
operator|<
literal|1000
condition|)
return|return
operator|(
name|BSTP_DEFAULT_PATH_COST
operator|)
return|;
comment|/* formula from section 17.14, IEEE Std 802.1D-2004 */
name|path_cost
operator|=
literal|20000000000
operator|/
operator|(
name|ifp
operator|->
name|if_baudrate
operator|/
literal|1000
operator|)
expr_stmt|;
if|if
condition|(
name|path_cost
operator|>
name|BSTP_MAX_PATH_COST
condition|)
name|path_cost
operator|=
name|BSTP_MAX_PATH_COST
expr_stmt|;
comment|/* STP compat mode only uses 16 bits of the 32 */
if|if
condition|(
name|bp
operator|->
name|bp_protover
operator|==
name|BSTP_PROTO_STP
operator|&&
name|path_cost
operator|>
literal|65535
condition|)
name|path_cost
operator|=
literal|65535
expr_stmt|;
return|return
operator|(
name|path_cost
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Notify the bridge that a port state has changed, we need to do this from a  * taskqueue to avoid a LOR.  */
end_comment

begin_function
specifier|static
name|void
name|bstp_notify_state
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|bstp_port
modifier|*
name|bp
init|=
operator|(
expr|struct
name|bstp_port
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|bstp_state
modifier|*
name|bs
init|=
name|bp
operator|->
name|bp_bs
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_active
operator|==
literal|1
operator|&&
name|bs
operator|->
name|bs_state_cb
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|bs
operator|->
name|bs_state_cb
call|)
argument_list|(
name|bp
operator|->
name|bp_ifp
argument_list|,
name|bp
operator|->
name|bp_state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flush the routes on the bridge port, we need to do this from a  * taskqueue to avoid a LOR.  */
end_comment

begin_function
specifier|static
name|void
name|bstp_notify_rtage
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|bstp_port
modifier|*
name|bp
init|=
operator|(
expr|struct
name|bstp_port
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|bstp_state
modifier|*
name|bs
init|=
name|bp
operator|->
name|bp_bs
decl_stmt|;
name|int
name|age
init|=
literal|0
decl_stmt|;
name|BSTP_LOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|bp_protover
condition|)
block|{
case|case
name|BSTP_PROTO_STP
case|:
comment|/* convert to seconds */
name|age
operator|=
name|bp
operator|->
name|bp_desg_fdelay
operator|/
name|BSTP_TICK_VAL
expr_stmt|;
break|break;
case|case
name|BSTP_PROTO_RSTP
case|:
name|age
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|BSTP_UNLOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_active
operator|==
literal|1
operator|&&
name|bs
operator|->
name|bs_rtage_cb
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|bs
operator|->
name|bs_rtage_cb
call|)
argument_list|(
name|bp
operator|->
name|bp_ifp
argument_list|,
name|age
argument_list|)
expr_stmt|;
comment|/* flush is complete */
name|BSTP_LOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_fdbflush
operator|=
literal|0
expr_stmt|;
name|BSTP_UNLOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bstp_linkstate
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|bstp_state
modifier|*
name|bs
decl_stmt|;
name|struct
name|bstp_port
modifier|*
name|bp
decl_stmt|;
comment|/* search for the stp port */
name|mtx_lock
argument_list|(
operator|&
name|bstp_list_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bs
argument_list|,
argument|&bstp_list
argument_list|,
argument|bs_list
argument_list|)
block|{
name|BSTP_LOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&bs->bs_bplist
argument_list|,
argument|bp_next
argument_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|bp_ifp
operator|==
name|ifp
condition|)
block|{
name|bstp_ifupdstatus
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bstp_update_state
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* it only exists once so return */
name|BSTP_UNLOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bstp_list_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|BSTP_UNLOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|bstp_list_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_ifupdstatus
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|bp
operator|->
name|bp_ifp
decl_stmt|;
name|struct
name|ifmediareq
name|ifmr
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|BSTP_LOCK_ASSERT
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ifmr
argument_list|,
sizeof|sizeof
argument_list|(
name|ifmr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_ioctl
call|)
argument_list|(
name|ifp
argument_list|,
name|SIOCGIFMEDIA
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifmr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
if|if
condition|(
name|ifmr
operator|.
name|ifm_status
operator|&
name|IFM_ACTIVE
condition|)
block|{
comment|/* A full-duplex link is assumed to be point to point */
name|bp
operator|->
name|bp_p2p_link
operator|=
name|ifmr
operator|.
name|ifm_active
operator|&
name|IFM_FDX
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_role
operator|==
name|BSTP_ROLE_DISABLED
condition|)
name|bstp_enable_port
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|bp
operator|->
name|bp_role
operator|!=
name|BSTP_ROLE_DISABLED
condition|)
name|bstp_disable_port
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|bp
operator|->
name|bp_infois
operator|!=
name|BSTP_INFO_DISABLED
condition|)
name|bstp_disable_port
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_enable_port
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|)
block|{
name|bp
operator|->
name|bp_infois
operator|=
name|BSTP_INFO_AGED
expr_stmt|;
name|bstp_assign_roles
argument_list|(
name|bs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_disable_port
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|)
block|{
name|bp
operator|->
name|bp_infois
operator|=
name|BSTP_INFO_DISABLED
expr_stmt|;
name|bstp_assign_roles
argument_list|(
name|bs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|bstp_state
modifier|*
name|bs
init|=
name|arg
decl_stmt|;
name|struct
name|bstp_port
modifier|*
name|bp
decl_stmt|;
name|BSTP_LOCK_ASSERT
argument_list|(
name|bs
argument_list|)
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|bs_running
operator|==
literal|0
condition|)
return|return;
comment|/* slow timer to catch missed link events */
if|if
condition|(
name|bstp_timer_expired
argument_list|(
operator|&
name|bs
operator|->
name|bs_link_timer
argument_list|)
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&bs->bs_bplist
argument_list|,
argument|bp_next
argument_list|)
name|bstp_ifupdstatus
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|bstp_timer_start
argument_list|(
operator|&
name|bs
operator|->
name|bs_link_timer
argument_list|,
name|BSTP_LINK_TIMER
argument_list|)
expr_stmt|;
block|}
name|LIST_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&bs->bs_bplist
argument_list|,
argument|bp_next
argument_list|)
block|{
comment|/* no events need to happen for these */
name|bstp_timer_expired
argument_list|(
operator|&
name|bp
operator|->
name|bp_tc_timer
argument_list|)
expr_stmt|;
name|bstp_timer_expired
argument_list|(
operator|&
name|bp
operator|->
name|bp_recent_root_timer
argument_list|)
expr_stmt|;
name|bstp_timer_expired
argument_list|(
operator|&
name|bp
operator|->
name|bp_forward_delay_timer
argument_list|)
expr_stmt|;
name|bstp_timer_expired
argument_list|(
operator|&
name|bp
operator|->
name|bp_recent_backup_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|bstp_timer_expired
argument_list|(
operator|&
name|bp
operator|->
name|bp_hello_timer
argument_list|)
condition|)
name|bstp_hello_timer_expiry
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bstp_timer_expired
argument_list|(
operator|&
name|bp
operator|->
name|bp_message_age_timer
argument_list|)
condition|)
name|bstp_message_age_expiry
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bstp_timer_expired
argument_list|(
operator|&
name|bp
operator|->
name|bp_migrate_delay_timer
argument_list|)
condition|)
name|bstp_migrate_delay_expiry
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bstp_timer_expired
argument_list|(
operator|&
name|bp
operator|->
name|bp_edge_delay_timer
argument_list|)
condition|)
name|bstp_edge_delay_expiry
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* update the various state machines for the port */
name|bstp_update_state
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_txcount
operator|>
literal|0
condition|)
name|bp
operator|->
name|bp_txcount
operator|--
expr_stmt|;
block|}
name|callout_reset
argument_list|(
operator|&
name|bs
operator|->
name|bs_bstpcallout
argument_list|,
name|hz
argument_list|,
name|bstp_tick
argument_list|,
name|bs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_timer_start
parameter_list|(
name|struct
name|bstp_timer
modifier|*
name|t
parameter_list|,
name|uint16_t
name|v
parameter_list|)
block|{
name|t
operator|->
name|value
operator|=
name|v
expr_stmt|;
name|t
operator|->
name|active
operator|=
literal|1
expr_stmt|;
name|t
operator|->
name|latched
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_timer_stop
parameter_list|(
name|struct
name|bstp_timer
modifier|*
name|t
parameter_list|)
block|{
name|t
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|t
operator|->
name|latched
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_timer_latch
parameter_list|(
name|struct
name|bstp_timer
modifier|*
name|t
parameter_list|)
block|{
name|t
operator|->
name|latched
operator|=
literal|1
expr_stmt|;
name|t
operator|->
name|active
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bstp_timer_expired
parameter_list|(
name|struct
name|bstp_timer
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
name|t
operator|->
name|active
operator|==
literal|0
operator|||
name|t
operator|->
name|latched
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|t
operator|->
name|value
operator|-=
name|BSTP_TICK_VAL
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|value
operator|<=
literal|0
condition|)
block|{
name|bstp_timer_stop
argument_list|(
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_hello_timer_expiry
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|bp_flags
operator|&
name|BSTP_PORT_NEWINFO
operator|)
operator|||
name|bp
operator|->
name|bp_role
operator|==
name|BSTP_ROLE_DESIGNATED
operator|||
operator|(
name|bp
operator|->
name|bp_role
operator|==
name|BSTP_ROLE_ROOT
operator|&&
name|bp
operator|->
name|bp_tc_timer
operator|.
name|active
operator|==
literal|1
operator|)
condition|)
block|{
name|bstp_timer_start
argument_list|(
operator|&
name|bp
operator|->
name|bp_hello_timer
argument_list|,
name|bp
operator|->
name|bp_desg_htime
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_flags
operator||=
name|BSTP_PORT_NEWINFO
expr_stmt|;
name|bstp_transmit
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_message_age_expiry
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|bp_infois
operator|==
name|BSTP_INFO_RECIEVED
condition|)
block|{
name|bp
operator|->
name|bp_infois
operator|=
name|BSTP_INFO_AGED
expr_stmt|;
name|bstp_assign_roles
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"aged info on %s\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_migrate_delay_expiry
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|)
block|{
name|bp
operator|->
name|bp_flags
operator||=
name|BSTP_PORT_CANMIGRATE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bstp_edge_delay_expiry
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|bp_flags
operator|&
name|BSTP_PORT_AUTOEDGE
operator|)
operator|&&
name|bp
operator|->
name|bp_protover
operator|==
name|BSTP_PROTO_RSTP
operator|&&
name|bp
operator|->
name|bp_proposing
operator|&&
name|bp
operator|->
name|bp_role
operator|==
name|BSTP_ROLE_DESIGNATED
condition|)
block|{
name|bp
operator|->
name|bp_operedge
operator|=
literal|1
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"%s -> edge port\n"
argument_list|,
name|bp
operator|->
name|bp_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bstp_addr_cmp
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|a
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|b
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|d
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
operator|&&
name|d
operator|==
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
operator|(
operator|(
name|int
operator|)
name|a
index|[
name|i
index|]
operator|)
operator|-
operator|(
operator|(
name|int
operator|)
name|b
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|d
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * compare the bridge address component of the bridgeid  */
end_comment

begin_function
specifier|static
name|int
name|bstp_same_bridgeid
parameter_list|(
name|uint64_t
name|id1
parameter_list|,
name|uint64_t
name|id2
parameter_list|)
block|{
name|u_char
name|addr1
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|u_char
name|addr2
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|PV2ADDR
argument_list|(
name|id1
argument_list|,
name|addr1
argument_list|)
expr_stmt|;
name|PV2ADDR
argument_list|(
name|id2
argument_list|,
name|addr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bstp_addr_cmp
argument_list|(
name|addr1
argument_list|,
name|addr2
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|bstp_reinit
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|)
block|{
name|struct
name|bstp_port
modifier|*
name|bp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|,
modifier|*
name|mif
decl_stmt|;
name|u_char
modifier|*
name|e_addr
decl_stmt|;
name|BSTP_LOCK_ASSERT
argument_list|(
name|bs
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|bs
operator|->
name|bs_bplist
argument_list|)
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|bs
operator|->
name|bs_bstpcallout
argument_list|)
expr_stmt|;
return|return;
block|}
name|mif
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Search through the Ethernet adapters and find the one with the 	 * lowest value. The adapter which we take the MAC address from does 	 * not need to be part of the bridge, it just needs to be a unique 	 * value. It is not possible for mif to be null, at this point we have 	 * at least one stp port and hence at least one NIC. 	 */
name|IFNET_RLOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifp
argument_list|,
argument|&ifnet
argument_list|,
argument|if_link
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_type
operator|!=
name|IFT_ETHER
condition|)
continue|continue;
if|if
condition|(
name|mif
operator|==
name|NULL
condition|)
block|{
name|mif
operator|=
name|ifp
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|bstp_addr_cmp
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|IF_LLADDR
argument_list|(
name|mif
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|mif
operator|=
name|ifp
expr_stmt|;
continue|continue;
block|}
block|}
name|IFNET_RUNLOCK
argument_list|()
expr_stmt|;
name|e_addr
operator|=
name|IF_LLADDR
argument_list|(
name|mif
argument_list|)
expr_stmt|;
name|bs
operator|->
name|bs_bridge_pv
operator|.
name|pv_dbridge_id
operator|=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|bs
operator|->
name|bs_bridge_priority
operator|)
operator|<<
literal|48
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|e_addr
index|[
literal|0
index|]
operator|)
operator|<<
literal|40
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|e_addr
index|[
literal|1
index|]
operator|)
operator|<<
literal|32
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|e_addr
index|[
literal|2
index|]
operator|)
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|e_addr
index|[
literal|3
index|]
operator|)
operator|<<
literal|16
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|e_addr
index|[
literal|4
index|]
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|e_addr
index|[
literal|5
index|]
operator|)
operator|)
expr_stmt|;
name|bs
operator|->
name|bs_bridge_pv
operator|.
name|pv_root_id
operator|=
name|bs
operator|->
name|bs_bridge_pv
operator|.
name|pv_dbridge_id
expr_stmt|;
name|bs
operator|->
name|bs_bridge_pv
operator|.
name|pv_cost
operator|=
literal|0
expr_stmt|;
name|bs
operator|->
name|bs_bridge_pv
operator|.
name|pv_dport_id
operator|=
literal|0
expr_stmt|;
name|bs
operator|->
name|bs_bridge_pv
operator|.
name|pv_port_id
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bs
operator|->
name|bs_running
operator|&&
name|callout_pending
argument_list|(
operator|&
name|bs
operator|->
name|bs_bstpcallout
argument_list|)
operator|==
literal|0
condition|)
name|callout_reset
argument_list|(
operator|&
name|bs
operator|->
name|bs_bstpcallout
argument_list|,
name|hz
argument_list|,
name|bstp_tick
argument_list|,
name|bs
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&bs->bs_bplist
argument_list|,
argument|bp_next
argument_list|)
block|{
name|bp
operator|->
name|bp_port_id
operator|=
operator|(
name|bp
operator|->
name|bp_priority
operator|<<
literal|8
operator|)
operator||
operator|(
name|bp
operator|->
name|bp_ifp
operator|->
name|if_index
operator|&
literal|0xfff
operator|)
expr_stmt|;
name|bstp_ifupdstatus
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
name|bstp_assign_roles
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|bstp_timer_start
argument_list|(
operator|&
name|bs
operator|->
name|bs_link_timer
argument_list|,
name|BSTP_LINK_TIMER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bstp_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|mtx_init
argument_list|(
operator|&
name|bstp_list_mtx
argument_list|,
literal|"bridgestp list"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|bstp_list
argument_list|)
expr_stmt|;
name|bstp_linkstate_p
operator|=
name|bstp_linkstate
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|mtx_destroy
argument_list|(
operator|&
name|bstp_list_mtx
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|bstp_mod
init|=
block|{
literal|"bridgestp"
block|,
name|bstp_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|bridgestp
argument_list|,
name|bstp_mod
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|bridgestp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|bstp_attach
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|bstp_state_cb_t
name|state_callback
parameter_list|,
name|bstp_rtage_cb_t
name|rtage_callback
parameter_list|)
block|{
name|BSTP_LOCK_INIT
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|bs
operator|->
name|bs_bstpcallout
argument_list|,
operator|&
name|bs
operator|->
name|bs_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|bs
operator|->
name|bs_bplist
argument_list|)
expr_stmt|;
name|bs
operator|->
name|bs_bridge_max_age
operator|=
name|BSTP_DEFAULT_MAX_AGE
expr_stmt|;
name|bs
operator|->
name|bs_bridge_htime
operator|=
name|BSTP_DEFAULT_HELLO_TIME
expr_stmt|;
name|bs
operator|->
name|bs_bridge_fdelay
operator|=
name|BSTP_DEFAULT_FORWARD_DELAY
expr_stmt|;
name|bs
operator|->
name|bs_bridge_priority
operator|=
name|BSTP_DEFAULT_BRIDGE_PRIORITY
expr_stmt|;
name|bs
operator|->
name|bs_hold_time
operator|=
name|BSTP_DEFAULT_HOLD_TIME
expr_stmt|;
name|bs
operator|->
name|bs_migration_delay
operator|=
name|BSTP_DEFAULT_MIGRATE_DELAY
expr_stmt|;
name|bs
operator|->
name|bs_txholdcount
operator|=
name|BSTP_DEFAULT_HOLD_COUNT
expr_stmt|;
name|bs
operator|->
name|bs_protover
operator|=
name|BSTP_PROTO_RSTP
expr_stmt|;
name|bs
operator|->
name|bs_state_cb
operator|=
name|state_callback
expr_stmt|;
name|bs
operator|->
name|bs_rtage_cb
operator|=
name|rtage_callback
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|bs
operator|->
name|bs_last_tc_time
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bstp_list_mtx
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|bstp_list
argument_list|,
name|bs
argument_list|,
name|bs_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bstp_list_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bstp_detach
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|bs
operator|->
name|bs_bplist
argument_list|)
argument_list|,
operator|(
literal|"bstp still active"
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bstp_list_mtx
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bs
argument_list|,
name|bs_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bstp_list_mtx
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|bs
operator|->
name|bs_bstpcallout
argument_list|)
expr_stmt|;
name|BSTP_LOCK_DESTROY
argument_list|(
name|bs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bstp_init
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|)
block|{
name|BSTP_LOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|bs
operator|->
name|bs_bstpcallout
argument_list|,
name|hz
argument_list|,
name|bstp_tick
argument_list|,
name|bs
argument_list|)
expr_stmt|;
name|bs
operator|->
name|bs_running
operator|=
literal|1
expr_stmt|;
name|bstp_reinit
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|BSTP_UNLOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bstp_stop
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|)
block|{
name|struct
name|bstp_port
modifier|*
name|bp
decl_stmt|;
name|BSTP_LOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&bs->bs_bplist
argument_list|,
argument|bp_next
argument_list|)
name|bstp_set_port_state
argument_list|(
name|bp
argument_list|,
name|BSTP_IFSTATE_DISCARDING
argument_list|)
expr_stmt|;
name|bs
operator|->
name|bs_running
operator|=
literal|0
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|bs
operator|->
name|bs_bstpcallout
argument_list|)
expr_stmt|;
name|BSTP_UNLOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bstp_create
parameter_list|(
name|struct
name|bstp_state
modifier|*
name|bs
parameter_list|,
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|bzero
argument_list|(
name|bp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bstp_port
argument_list|)
argument_list|)
expr_stmt|;
name|BSTP_LOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_ifp
operator|=
name|ifp
expr_stmt|;
name|bp
operator|->
name|bp_bs
operator|=
name|bs
expr_stmt|;
name|bp
operator|->
name|bp_priority
operator|=
name|BSTP_DEFAULT_PORT_PRIORITY
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|bp
operator|->
name|bp_statetask
argument_list|,
literal|0
argument_list|,
name|bstp_notify_state
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|bp
operator|->
name|bp_rtagetask
argument_list|,
literal|0
argument_list|,
name|bstp_notify_rtage
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* Init state */
name|bp
operator|->
name|bp_flags
operator|=
name|BSTP_PORT_AUTOEDGE
expr_stmt|;
name|bstp_set_port_state
argument_list|(
name|bp
argument_list|,
name|BSTP_IFSTATE_DISCARDING
argument_list|)
expr_stmt|;
name|bstp_set_port_proto
argument_list|(
name|bp
argument_list|,
name|bs
operator|->
name|bs_protover
argument_list|)
expr_stmt|;
name|bstp_set_port_role
argument_list|(
name|bp
argument_list|,
name|BSTP_ROLE_DISABLED
argument_list|)
expr_stmt|;
name|bstp_set_port_tc
argument_list|(
name|bp
argument_list|,
name|BSTP_TCSTATE_INACTIVE
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_path_cost
operator|=
name|bstp_calc_path_cost
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|BSTP_UNLOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bstp_enable
parameter_list|(
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|bstp_state
modifier|*
name|bs
init|=
name|bp
operator|->
name|bp_bs
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|bp
operator|->
name|bp_ifp
decl_stmt|;
name|KASSERT
argument_list|(
name|bp
operator|->
name|bp_active
operator|==
literal|0
argument_list|,
operator|(
literal|"already a bstp member"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ifp
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ETHER
case|:
comment|/* These can do spanning tree. */
break|break;
default|default:
comment|/* Nothing else can. */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|BSTP_LOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|bs
operator|->
name|bs_bplist
argument_list|,
name|bp
argument_list|,
name|bp_next
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_active
operator|=
literal|1
expr_stmt|;
name|bp
operator|->
name|bp_flags
operator||=
name|BSTP_PORT_NEWINFO
expr_stmt|;
name|bstp_reinit
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|bstp_update_roles
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|BSTP_UNLOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|bstp_disable
parameter_list|(
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|)
block|{
name|struct
name|bstp_state
modifier|*
name|bs
init|=
name|bp
operator|->
name|bp_bs
decl_stmt|;
name|KASSERT
argument_list|(
name|bp
operator|->
name|bp_active
operator|==
literal|1
argument_list|,
operator|(
literal|"not a bstp member"
operator|)
argument_list|)
expr_stmt|;
name|BSTP_LOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|bstp_disable_port
argument_list|(
name|bs
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bp
argument_list|,
name|bp_next
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bp_active
operator|=
literal|0
expr_stmt|;
name|bstp_reinit
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|BSTP_UNLOCK
argument_list|(
name|bs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The bstp_port structure is about to be freed by the parent bridge.  */
end_comment

begin_function
name|void
name|bstp_destroy
parameter_list|(
name|struct
name|bstp_port
modifier|*
name|bp
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|bp
operator|->
name|bp_active
operator|==
literal|0
argument_list|,
operator|(
literal|"port is still attached"
operator|)
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|bp
operator|->
name|bp_statetask
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|bp
operator|->
name|bp_rtagetask
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

