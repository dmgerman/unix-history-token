begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: if_trunk.c,v 1.30 2007/01/31 06:20:19 reyk Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2006 Reyk Floeter<reyk@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/hash.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_clone.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_trunk.h>
end_include

begin_include
include|#
directive|include
file|<net/ieee8023ad_lacp.h>
end_include

begin_comment
comment|/* Special flags we should propagate to the trunk ports. */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|int
name|flag
decl_stmt|;
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
block|}
name|trunk_pflags
index|[]
init|=
block|{
block|{
name|IFF_PROMISC
block|,
name|ifpromisc
block|}
block|,
block|{
name|IFF_ALLMULTI
block|,
name|if_allmulti
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_macro
name|SLIST_HEAD
argument_list|(
argument|__trhead
argument_list|,
argument|trunk_softc
argument_list|)
end_macro

begin_expr_stmt
name|trunk_list
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* list of trunks */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|trunk_list_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|eventhandler_tag
name|trunk_detach_cookie
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|trunk_clone_create
parameter_list|(
name|struct
name|if_clone
modifier|*
parameter_list|,
name|int
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trunk_clone_destroy
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trunk_lladdr
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trunk_capabilities
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trunk_port_lladdr
parameter_list|(
name|struct
name|trunk_port
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trunk_port_create
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trunk_port_destroy
parameter_list|(
name|struct
name|trunk_port
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|trunk_input
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trunk_port_state
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trunk_port_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trunk_port_output
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|struct
name|rtentry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trunk_port_ifdetach
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trunk_port_checkstacking
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trunk_port2req
parameter_list|(
name|struct
name|trunk_port
modifier|*
parameter_list|,
name|struct
name|trunk_reqport
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trunk_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trunk_stop
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trunk_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trunk_ether_setmulti
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trunk_ether_cmdmulti
parameter_list|(
name|struct
name|trunk_port
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trunk_ether_purgemulti
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trunk_setflag
parameter_list|(
name|struct
name|trunk_port
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trunk_setflags
parameter_list|(
name|struct
name|trunk_port
modifier|*
parameter_list|,
name|int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trunk_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trunk_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trunk_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|trunk_port
modifier|*
name|trunk_link_active
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|,
name|struct
name|trunk_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|void
modifier|*
name|trunk_gethdr
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|IFC_SIMPLE_DECLARE
argument_list|(
name|trunk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Simple round robin */
end_comment

begin_function_decl
specifier|static
name|int
name|trunk_rr_attach
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trunk_rr_detach
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trunk_rr_port_destroy
parameter_list|(
name|struct
name|trunk_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trunk_rr_start
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|trunk_rr_input
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|,
name|struct
name|trunk_port
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Active failover */
end_comment

begin_function_decl
specifier|static
name|int
name|trunk_fail_attach
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trunk_fail_detach
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trunk_fail_start
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|trunk_fail_input
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|,
name|struct
name|trunk_port
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Loadbalancing */
end_comment

begin_function_decl
specifier|static
name|int
name|trunk_lb_attach
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trunk_lb_detach
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trunk_lb_port_create
parameter_list|(
name|struct
name|trunk_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trunk_lb_port_destroy
parameter_list|(
name|struct
name|trunk_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trunk_lb_start
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|trunk_lb_input
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|,
name|struct
name|trunk_port
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trunk_lb_porttable
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|,
name|struct
name|trunk_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* 802.3ad LACP */
end_comment

begin_function_decl
specifier|static
name|int
name|trunk_lacp_attach
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trunk_lacp_detach
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|trunk_lacp_start
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|trunk_lacp_input
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|,
name|struct
name|trunk_port
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trunk_lacp_lladdr
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Trunk protocol table */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|int
name|ti_proto
decl_stmt|;
name|int
function_decl|(
modifier|*
name|ti_attach
function_decl|)
parameter_list|(
name|struct
name|trunk_softc
modifier|*
parameter_list|)
function_decl|;
block|}
name|trunk_protos
index|[]
init|=
block|{
block|{
name|TRUNK_PROTO_ROUNDROBIN
block|,
name|trunk_rr_attach
block|}
block|,
block|{
name|TRUNK_PROTO_FAILOVER
block|,
name|trunk_fail_attach
block|}
block|,
block|{
name|TRUNK_PROTO_LOADBALANCE
block|,
name|trunk_lb_attach
block|}
block|,
block|{
name|TRUNK_PROTO_ETHERCHANNEL
block|,
name|trunk_lb_attach
block|}
block|,
block|{
name|TRUNK_PROTO_LACP
block|,
name|trunk_lacp_attach
block|}
block|,
block|{
name|TRUNK_PROTO_NONE
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|trunk_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|mtx_init
argument_list|(
operator|&
name|trunk_list_mtx
argument_list|,
literal|"if_trunk list"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|trunk_list
argument_list|)
expr_stmt|;
name|if_clone_attach
argument_list|(
operator|&
name|trunk_cloner
argument_list|)
expr_stmt|;
name|trunk_input_p
operator|=
name|trunk_input
expr_stmt|;
name|trunk_linkstate_p
operator|=
name|trunk_port_state
expr_stmt|;
name|trunk_detach_cookie
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|ifnet_departure_event
argument_list|,
name|trunk_port_ifdetach
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|ifnet_departure_event
argument_list|,
name|trunk_detach_cookie
argument_list|)
expr_stmt|;
name|if_clone_detach
argument_list|(
operator|&
name|trunk_cloner
argument_list|)
expr_stmt|;
name|trunk_input_p
operator|=
name|NULL
expr_stmt|;
name|trunk_linkstate_p
operator|=
name|NULL
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|trunk_list_mtx
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|trunk_mod
init|=
block|{
literal|"if_trunk"
block|,
name|trunk_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|if_trunk
argument_list|,
name|trunk_mod
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|trunk_clone_create
parameter_list|(
name|struct
name|if_clone
modifier|*
name|ifc
parameter_list|,
name|int
name|unit
parameter_list|,
name|caddr_t
name|params
parameter_list|)
block|{
name|struct
name|trunk_softc
modifier|*
name|tr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|u_char
name|eaddr
index|[
literal|6
index|]
decl_stmt|;
comment|/* 00:00:00:00:00:00 */
name|tr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tr
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|tr
operator|->
name|tr_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|tr
operator|->
name|tr_proto
operator|=
name|TRUNK_PROTO_NONE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|trunk_protos
index|[
name|i
index|]
operator|.
name|ti_proto
operator|!=
name|TRUNK_PROTO_NONE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|trunk_protos
index|[
name|i
index|]
operator|.
name|ti_proto
operator|==
name|TRUNK_PROTO_DEFAULT
condition|)
block|{
name|tr
operator|->
name|tr_proto
operator|=
name|trunk_protos
index|[
name|i
index|]
operator|.
name|ti_proto
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|trunk_protos
index|[
name|i
index|]
operator|.
name|ti_attach
argument_list|(
name|tr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|if_free_type
argument_list|(
name|ifp
argument_list|,
name|IFT_ETHER
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
break|break;
block|}
block|}
name|TRUNK_LOCK_INIT
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|tr
operator|->
name|tr_ports
argument_list|)
expr_stmt|;
comment|/* Initialise pseudo media types */
name|ifmedia_init
argument_list|(
operator|&
name|tr
operator|->
name|tr_media
argument_list|,
literal|0
argument_list|,
name|trunk_media_change
argument_list|,
name|trunk_media_status
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|tr
operator|->
name|tr_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|tr
operator|->
name|tr_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|ifc
operator|->
name|ifc_name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_type
operator|=
name|IFT_ETHER
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|tr
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|trunk_start
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|trunk_init
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|trunk_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_SIMPLEX
operator||
name|IFF_BROADCAST
operator||
name|IFF_MULTICAST
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifqmaxlen
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|ifqmaxlen
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
comment|/* 	 * Attach as an ordinary ethernet device, childs will be attached 	 * as special device IFT_IEEE8023ADLAG. 	 */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
comment|/* Insert into the global list of trunks */
name|mtx_lock
argument_list|(
operator|&
name|trunk_list_mtx
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|trunk_list
argument_list|,
name|tr
argument_list|,
name|tr_entries
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|trunk_list_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trunk_clone_destroy
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|trunk_softc
modifier|*
name|tr
init|=
operator|(
expr|struct
name|trunk_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|trunk_port
modifier|*
name|tp
decl_stmt|;
name|TRUNK_LOCK
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|trunk_stop
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
comment|/* Shutdown and remove trunk ports */
while|while
condition|(
operator|(
name|tp
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|tr
operator|->
name|tr_ports
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|trunk_port_destroy
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Unhook the trunking protocol */
if|if
condition|(
name|tr
operator|->
name|tr_detach
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|tr
operator|->
name|tr_detach
call|)
argument_list|(
name|tr
argument_list|)
expr_stmt|;
comment|/* Remove any multicast groups that we may have joined. */
name|trunk_ether_purgemulti
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|TRUNK_UNLOCK
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
operator|&
name|tr
operator|->
name|tr_media
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_free_type
argument_list|(
name|ifp
argument_list|,
name|IFT_ETHER
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|trunk_list_mtx
argument_list|)
expr_stmt|;
name|SLIST_REMOVE
argument_list|(
operator|&
name|trunk_list
argument_list|,
name|tr
argument_list|,
name|trunk_softc
argument_list|,
name|tr_entries
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|trunk_list_mtx
argument_list|)
expr_stmt|;
name|TRUNK_LOCK_DESTROY
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tr
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trunk_lladdr
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|,
name|uint8_t
modifier|*
name|lladdr
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|tr
operator|->
name|tr_ifp
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|lladdr
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|bcopy
argument_list|(
name|lladdr
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Let the protocol know the MAC has changed */
if|if
condition|(
name|tr
operator|->
name|tr_lladdr
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|tr
operator|->
name|tr_lladdr
call|)
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|trunk_capabilities
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|)
block|{
name|struct
name|trunk_port
modifier|*
name|tp
decl_stmt|;
name|int
name|cap
init|=
operator|~
literal|0
decl_stmt|,
name|priv
decl_stmt|;
name|TRUNK_LOCK_ASSERT
argument_list|(
name|tr
argument_list|)
expr_stmt|;
comment|/* Preserve private capabilities */
name|priv
operator|=
name|tr
operator|->
name|tr_capabilities
operator|&
name|IFCAP_TRUNK_MASK
expr_stmt|;
comment|/* Get capabilities from the trunk ports */
name|SLIST_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|&tr->tr_ports
argument_list|,
argument|tp_entries
argument_list|)
name|cap
operator|&=
name|tp
operator|->
name|tp_capabilities
expr_stmt|;
if|if
condition|(
name|tr
operator|->
name|tr_ifflags
operator|&
name|IFF_DEBUG
condition|)
block|{
name|printf
argument_list|(
literal|"%s: capabilities 0x%08x\n"
argument_list|,
name|tr
operator|->
name|tr_ifname
argument_list|,
name|cap
operator|==
operator|~
literal|0
condition|?
name|priv
else|:
operator|(
name|cap
operator||
name|priv
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|cap
operator|==
operator|~
literal|0
condition|?
name|priv
else|:
operator|(
name|cap
operator||
name|priv
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trunk_port_lladdr
parameter_list|(
name|struct
name|trunk_port
modifier|*
name|tp
parameter_list|,
name|uint8_t
modifier|*
name|lladdr
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|tp
operator|->
name|tp_ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|lladdr
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Set the link layer address */
name|error
operator|=
name|if_setlladdr
argument_list|(
name|ifp
argument_list|,
name|lladdr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"%s: setlladdr failed on %s\n"
argument_list|,
name|__func__
argument_list|,
name|tp
operator|->
name|tp_ifname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|trunk_port_create
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|trunk_softc
modifier|*
name|tr_ptr
decl_stmt|;
name|struct
name|trunk_port
modifier|*
name|tp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|TRUNK_LOCK_ASSERT
argument_list|(
name|tr
argument_list|)
expr_stmt|;
comment|/* Limit the maximal number of trunk ports */
if|if
condition|(
name|tr
operator|->
name|tr_count
operator|>=
name|TRUNK_MAX_PORTS
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* New trunk port has to be in an idle state */
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Check if port has already been associated to a trunk */
if|if
condition|(
name|ifp
operator|->
name|if_trunk
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* XXX Disallow non-ethernet interfaces (this should be any of 802) */
if|if
condition|(
name|ifp
operator|->
name|if_type
operator|!=
name|IFT_ETHER
condition|)
return|return
operator|(
name|EPROTONOSUPPORT
operator|)
return|;
if|if
condition|(
operator|(
name|tp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|trunk_port
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Check if port is a stacked trunk */
name|mtx_lock
argument_list|(
operator|&
name|trunk_list_mtx
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|tr_ptr
argument_list|,
argument|&trunk_list
argument_list|,
argument|tr_entries
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|==
name|tr_ptr
operator|->
name|tr_ifp
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|trunk_list_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* XXX disable stacking for the moment, its untested 			tp->tp_flags |= TRUNK_PORT_STACK; 			if (trunk_port_checkstacking(tr_ptr)>= 			    TRUNK_MAX_STACKING) { 				mtx_unlock(&trunk_list_mtx); 				free(tp, M_DEVBUF); 				return (E2BIG); 			} 			*/
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|trunk_list_mtx
argument_list|)
expr_stmt|;
comment|/* Change the interface type */
name|tp
operator|->
name|tp_iftype
operator|=
name|ifp
operator|->
name|if_type
expr_stmt|;
name|ifp
operator|->
name|if_type
operator|=
name|IFT_IEEE8023ADLAG
expr_stmt|;
name|ifp
operator|->
name|if_trunk
operator|=
name|tp
expr_stmt|;
name|tp
operator|->
name|tp_ioctl
operator|=
name|ifp
operator|->
name|if_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|trunk_port_ioctl
expr_stmt|;
name|tp
operator|->
name|tp_output
operator|=
name|ifp
operator|->
name|if_output
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|trunk_port_output
expr_stmt|;
name|tp
operator|->
name|tp_ifp
operator|=
name|ifp
expr_stmt|;
name|tp
operator|->
name|tp_trunk
operator|=
name|tr
expr_stmt|;
comment|/* Save port link layer address */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|tp
operator|->
name|tp_lladdr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLIST_EMPTY
argument_list|(
operator|&
name|tr
operator|->
name|tr_ports
argument_list|)
condition|)
block|{
name|tr
operator|->
name|tr_primary
operator|=
name|tp
expr_stmt|;
name|trunk_lladdr
argument_list|(
name|tr
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Update link layer address for this port */
name|trunk_port_lladdr
argument_list|(
name|tp
argument_list|,
name|IF_LLADDR
argument_list|(
name|tr
operator|->
name|tr_ifp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Insert into the list of ports */
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|tr
operator|->
name|tr_ports
argument_list|,
name|tp
argument_list|,
name|tp_entries
argument_list|)
expr_stmt|;
name|tr
operator|->
name|tr_count
operator|++
expr_stmt|;
comment|/* Update trunk capabilities */
name|tr
operator|->
name|tr_capabilities
operator|=
name|trunk_capabilities
argument_list|(
name|tr
argument_list|)
expr_stmt|;
comment|/* Add multicast addresses and interface flags to this port */
name|trunk_ether_cmdmulti
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|trunk_setflags
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
operator|->
name|tr_port_create
operator|!=
name|NULL
condition|)
name|error
operator|=
call|(
modifier|*
name|tr
operator|->
name|tr_port_create
call|)
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* remove the port again, without calling tr_port_destroy */
name|trunk_port_destroy
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|trunk_port_checkstacking
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|)
block|{
name|struct
name|trunk_softc
modifier|*
name|tr_ptr
decl_stmt|;
name|struct
name|trunk_port
modifier|*
name|tp
decl_stmt|;
name|int
name|m
init|=
literal|0
decl_stmt|;
name|TRUNK_LOCK_ASSERT
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|&tr->tr_ports
argument_list|,
argument|tp_entries
argument_list|)
block|{
if|if
condition|(
name|tp
operator|->
name|tp_flags
operator|&
name|TRUNK_PORT_STACK
condition|)
block|{
name|tr_ptr
operator|=
operator|(
expr|struct
name|trunk_softc
operator|*
operator|)
name|tp
operator|->
name|tp_ifp
operator|->
name|if_softc
expr_stmt|;
name|m
operator|=
name|MAX
argument_list|(
name|m
argument_list|,
name|trunk_port_checkstacking
argument_list|(
name|tr_ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|m
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|trunk_port_destroy
parameter_list|(
name|struct
name|trunk_port
modifier|*
name|tp
parameter_list|,
name|int
name|runpd
parameter_list|)
block|{
name|struct
name|trunk_softc
modifier|*
name|tr
init|=
name|tp
operator|->
name|tp_trunk
decl_stmt|;
name|struct
name|trunk_port
modifier|*
name|tp_ptr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|tp
operator|->
name|tp_ifp
decl_stmt|;
name|TRUNK_LOCK_ASSERT
argument_list|(
name|tr
argument_list|)
expr_stmt|;
if|if
condition|(
name|runpd
operator|&&
name|tr
operator|->
name|tr_port_destroy
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|tr
operator|->
name|tr_port_destroy
call|)
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* Remove multicast addresses and interface flags from this port */
name|trunk_ether_cmdmulti
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|trunk_setflags
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Restore interface */
name|ifp
operator|->
name|if_type
operator|=
name|tp
operator|->
name|tp_iftype
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|tp
operator|->
name|tp_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|tp
operator|->
name|tp_output
expr_stmt|;
name|ifp
operator|->
name|if_trunk
operator|=
name|NULL
expr_stmt|;
comment|/* Finally, remove the port from the trunk */
name|SLIST_REMOVE
argument_list|(
operator|&
name|tr
operator|->
name|tr_ports
argument_list|,
name|tp
argument_list|,
name|trunk_port
argument_list|,
name|tp_entries
argument_list|)
expr_stmt|;
name|tr
operator|->
name|tr_count
operator|--
expr_stmt|;
comment|/* Update the primary interface */
if|if
condition|(
name|tp
operator|==
name|tr
operator|->
name|tr_primary
condition|)
block|{
name|uint8_t
name|lladdr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|tp_ptr
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|tr
operator|->
name|tr_ports
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|lladdr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|tp_ptr
operator|->
name|tp_lladdr
argument_list|,
name|lladdr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
name|trunk_lladdr
argument_list|(
name|tr
argument_list|,
name|lladdr
argument_list|)
expr_stmt|;
name|tr
operator|->
name|tr_primary
operator|=
name|tp_ptr
expr_stmt|;
comment|/* Update link layer address for each port */
name|SLIST_FOREACH
argument_list|(
argument|tp_ptr
argument_list|,
argument|&tr->tr_ports
argument_list|,
argument|tp_entries
argument_list|)
name|trunk_port_lladdr
argument_list|(
name|tp_ptr
argument_list|,
name|lladdr
argument_list|)
expr_stmt|;
block|}
comment|/* Reset the port lladdr */
name|trunk_port_lladdr
argument_list|(
name|tp
argument_list|,
name|tp
operator|->
name|tp_lladdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|tp_ifflags
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: tp_ifflags unclean\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* Update trunk capabilities */
name|tr
operator|->
name|tr_capabilities
operator|=
name|trunk_capabilities
argument_list|(
name|tr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|trunk_port_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|trunk_reqport
modifier|*
name|rp
init|=
operator|(
expr|struct
name|trunk_reqport
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|trunk_softc
modifier|*
name|tr
decl_stmt|;
name|struct
name|trunk_port
modifier|*
name|tp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Should be checked by the caller */
if|if
condition|(
name|ifp
operator|->
name|if_type
operator|!=
name|IFT_IEEE8023ADLAG
operator|||
operator|(
name|tp
operator|=
name|ifp
operator|->
name|if_trunk
operator|)
operator|==
name|NULL
operator|||
operator|(
name|tr
operator|=
name|tp
operator|->
name|tp_trunk
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|fallback
goto|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCGTRUNKPORT
case|:
name|TRUNK_LOCK
argument_list|(
name|tr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rp_portname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|ifunit
argument_list|(
name|rp
operator|->
name|rp_portname
argument_list|)
operator|!=
name|ifp
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tp
operator|->
name|tp_trunk
operator|!=
name|tr
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
name|trunk_port2req
argument_list|(
name|tp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|TRUNK_UNLOCK
argument_list|(
name|tr
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|fallback
goto|;
block|}
return|return
operator|(
name|error
operator|)
return|;
name|fallback
label|:
if|if
condition|(
name|tp
operator|!=
name|NULL
condition|)
return|return
operator|(
call|(
modifier|*
name|tp
operator|->
name|tp_ioctl
call|)
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
operator|)
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|trunk_port_output
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt0
parameter_list|)
block|{
name|struct
name|trunk_port
modifier|*
name|tp
init|=
name|ifp
operator|->
name|if_trunk
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|short
name|type
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|dst
operator|->
name|sa_family
condition|)
block|{
case|case
name|pseudo_AF_HDRCMPLT
case|:
case|case
name|AF_UNSPEC
case|:
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|dst
operator|->
name|sa_data
expr_stmt|;
name|type
operator|=
name|eh
operator|->
name|ether_type
expr_stmt|;
break|break;
block|}
comment|/* 	 * Only allow ethernet types required to initiate or maintain the link, 	 * trunked frames take a different path. 	 */
switch|switch
condition|(
name|ntohs
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ETHERTYPE_PAE
case|:
comment|/* EAPOL PAE/802.1x */
return|return
operator|(
call|(
modifier|*
name|tp
operator|->
name|tp_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
name|rt0
argument_list|)
operator|)
return|;
block|}
comment|/* drop any other frames */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trunk_port_ifdetach
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|trunk_port
modifier|*
name|tp
decl_stmt|;
name|struct
name|trunk_softc
modifier|*
name|tr
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|ifp
operator|->
name|if_trunk
operator|)
operator|==
name|NULL
condition|)
return|return;
name|tr
operator|=
name|tp
operator|->
name|tp_trunk
expr_stmt|;
name|TRUNK_LOCK
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|trunk_port_destroy
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TRUNK_UNLOCK
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trunk_port2req
parameter_list|(
name|struct
name|trunk_port
modifier|*
name|tp
parameter_list|,
name|struct
name|trunk_reqport
modifier|*
name|rp
parameter_list|)
block|{
name|struct
name|trunk_softc
modifier|*
name|tr
init|=
name|tp
operator|->
name|tp_trunk
decl_stmt|;
name|strlcpy
argument_list|(
name|rp
operator|->
name|rp_ifname
argument_list|,
name|tr
operator|->
name|tr_ifname
argument_list|,
sizeof|sizeof
argument_list|(
name|rp
operator|->
name|rp_ifname
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|rp
operator|->
name|rp_portname
argument_list|,
name|tp
operator|->
name|tp_ifp
operator|->
name|if_xname
argument_list|,
sizeof|sizeof
argument_list|(
name|rp
operator|->
name|rp_portname
argument_list|)
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rp_prio
operator|=
name|tp
operator|->
name|tp_prio
expr_stmt|;
name|rp
operator|->
name|rp_flags
operator|=
name|tp
operator|->
name|tp_flags
expr_stmt|;
comment|/* Add protocol specific flags */
switch|switch
condition|(
name|tr
operator|->
name|tr_proto
condition|)
block|{
case|case
name|TRUNK_PROTO_FAILOVER
case|:
if|if
condition|(
name|tp
operator|==
name|tr
operator|->
name|tr_primary
condition|)
name|tp
operator|->
name|tp_flags
operator||=
name|TRUNK_PORT_MASTER
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|TRUNK_PROTO_ROUNDROBIN
case|:
case|case
name|TRUNK_PROTO_LOADBALANCE
case|:
case|case
name|TRUNK_PROTO_ETHERCHANNEL
case|:
if|if
condition|(
name|TRUNK_PORTACTIVE
argument_list|(
name|tp
argument_list|)
condition|)
name|rp
operator|->
name|rp_flags
operator||=
name|TRUNK_PORT_ACTIVE
expr_stmt|;
break|break;
case|case
name|TRUNK_PROTO_LACP
case|:
comment|/* LACP has a different definition of active */
if|if
condition|(
name|lacp_port_isactive
argument_list|(
name|tp
argument_list|)
condition|)
name|rp
operator|->
name|rp_flags
operator||=
name|TRUNK_PORT_ACTIVE
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|trunk_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|trunk_softc
modifier|*
name|tr
init|=
operator|(
expr|struct
name|trunk_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|struct
name|trunk_port
modifier|*
name|tp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|tr
operator|->
name|tr_ifp
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
return|return;
name|TRUNK_LOCK
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
comment|/* Update the port lladdrs */
name|SLIST_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|&tr->tr_ports
argument_list|,
argument|tp_entries
argument_list|)
name|trunk_port_lladdr
argument_list|(
name|tp
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
operator|->
name|tr_init
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|tr
operator|->
name|tr_init
call|)
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|TRUNK_UNLOCK
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trunk_stop
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|tr
operator|->
name|tr_ifp
decl_stmt|;
name|TRUNK_LOCK_ASSERT
argument_list|(
name|tr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
if|if
condition|(
name|tr
operator|->
name|tr_stop
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|tr
operator|->
name|tr_stop
call|)
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|trunk_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|trunk_softc
modifier|*
name|tr
init|=
operator|(
expr|struct
name|trunk_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|trunk_reqall
modifier|*
name|ra
init|=
operator|(
expr|struct
name|trunk_reqall
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|trunk_reqport
modifier|*
name|rp
init|=
operator|(
expr|struct
name|trunk_reqport
operator|*
operator|)
name|data
decl_stmt|,
name|rpbuf
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|trunk_port
modifier|*
name|tp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|tpif
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|unlock
init|=
literal|1
decl_stmt|;
name|TRUNK_LOCK
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|rpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|rpbuf
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCGTRUNK
case|:
name|ra
operator|->
name|ra_proto
operator|=
name|tr
operator|->
name|tr_proto
expr_stmt|;
name|ra
operator|->
name|ra_ports
operator|=
name|i
operator|=
literal|0
expr_stmt|;
name|tp
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|tr
operator|->
name|tr_ports
argument_list|)
expr_stmt|;
while|while
condition|(
name|tp
operator|&&
name|ra
operator|->
name|ra_size
operator|>=
name|i
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|trunk_reqport
argument_list|)
condition|)
block|{
name|trunk_port2req
argument_list|(
name|tp
argument_list|,
operator|&
name|rpbuf
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|rpbuf
argument_list|,
operator|(
name|caddr_t
operator|)
name|ra
operator|->
name|ra_port
operator|+
name|i
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|trunk_reqport
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|i
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|trunk_reqport
argument_list|)
expr_stmt|;
name|ra
operator|->
name|ra_ports
operator|++
expr_stmt|;
name|tp
operator|=
name|SLIST_NEXT
argument_list|(
name|tp
argument_list|,
name|tp_entries
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSTRUNK
case|:
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NET_TRUNK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|ra
operator|->
name|ra_proto
operator|>=
name|TRUNK_PROTO_MAX
condition|)
block|{
name|error
operator|=
name|EPROTONOSUPPORT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tr
operator|->
name|tr_proto
operator|!=
name|TRUNK_PROTO_NONE
condition|)
block|{
name|error
operator|=
name|tr
operator|->
name|tr_detach
argument_list|(
name|tr
argument_list|)
expr_stmt|;
comment|/* Reset protocol and pointers */
name|tr
operator|->
name|tr_proto
operator|=
name|TRUNK_PROTO_NONE
expr_stmt|;
name|tr
operator|->
name|tr_detach
operator|=
name|NULL
expr_stmt|;
name|tr
operator|->
name|tr_start
operator|=
name|NULL
expr_stmt|;
name|tr
operator|->
name|tr_input
operator|=
name|NULL
expr_stmt|;
name|tr
operator|->
name|tr_port_create
operator|=
name|NULL
expr_stmt|;
name|tr
operator|->
name|tr_port_destroy
operator|=
name|NULL
expr_stmt|;
name|tr
operator|->
name|tr_linkstate
operator|=
name|NULL
expr_stmt|;
name|tr
operator|->
name|tr_init
operator|=
name|NULL
expr_stmt|;
name|tr
operator|->
name|tr_stop
operator|=
name|NULL
expr_stmt|;
name|tr
operator|->
name|tr_lladdr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|trunk_protos
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|trunk_protos
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|trunk_protos
index|[
name|i
index|]
operator|.
name|ti_proto
operator|==
name|ra
operator|->
name|ra_proto
condition|)
block|{
if|if
condition|(
name|tr
operator|->
name|tr_ifflags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: using proto %u\n"
argument_list|,
name|tr
operator|->
name|tr_ifname
argument_list|,
name|trunk_protos
index|[
name|i
index|]
operator|.
name|ti_proto
argument_list|)
expr_stmt|;
name|tr
operator|->
name|tr_proto
operator|=
name|trunk_protos
index|[
name|i
index|]
operator|.
name|ti_proto
expr_stmt|;
if|if
condition|(
name|tr
operator|->
name|tr_proto
operator|!=
name|TRUNK_PROTO_NONE
condition|)
name|error
operator|=
name|trunk_protos
index|[
name|i
index|]
operator|.
name|ti_attach
argument_list|(
name|tr
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|error
operator|=
name|EPROTONOSUPPORT
expr_stmt|;
break|break;
case|case
name|SIOCGTRUNKPORT
case|:
if|if
condition|(
name|rp
operator|->
name|rp_portname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|tpif
operator|=
name|ifunit
argument_list|(
name|rp
operator|->
name|rp_portname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|tp
operator|=
operator|(
expr|struct
name|trunk_port
operator|*
operator|)
name|tpif
operator|->
name|if_trunk
operator|)
operator|==
name|NULL
operator|||
name|tp
operator|->
name|tp_trunk
operator|!=
name|tr
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
name|trunk_port2req
argument_list|(
name|tp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSTRUNKPORT
case|:
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NET_TRUNK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|rp
operator|->
name|rp_portname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|tpif
operator|=
name|ifunit
argument_list|(
name|rp
operator|->
name|rp_portname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|trunk_port_create
argument_list|(
name|tr
argument_list|,
name|tpif
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSTRUNKDELPORT
case|:
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NET_TRUNK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|rp
operator|->
name|rp_portname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|tpif
operator|=
name|ifunit
argument_list|(
name|rp
operator|->
name|rp_portname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|tp
operator|=
operator|(
expr|struct
name|trunk_port
operator|*
operator|)
name|tpif
operator|->
name|if_trunk
operator|)
operator|==
name|NULL
operator|||
name|tp
operator|->
name|tp_trunk
operator|!=
name|tr
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|trunk_port_destroy
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/* Set flags on ports too */
name|SLIST_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|&tr->tr_ports
argument_list|,
argument|tp_entries
argument_list|)
block|{
name|trunk_setflags
argument_list|(
name|tp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
comment|/* 			 * If interface is marked down and it is running, 			 * then stop and disable it. 			 */
name|trunk_stop
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
comment|/* 			 * If interface is marked up and it is stopped, then 			 * start it. 			 */
name|TRUNK_UNLOCK
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|unlock
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_init
call|)
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|error
operator|=
name|trunk_ether_setmulti
argument_list|(
name|tr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|TRUNK_UNLOCK
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|unlock
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|tr
operator|->
name|tr_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|TRUNK_UNLOCK
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|unlock
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
label|:
if|if
condition|(
name|unlock
condition|)
name|TRUNK_UNLOCK
argument_list|(
name|tr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|trunk_ether_setmulti
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|trifp
init|=
name|tr
operator|->
name|tr_ifp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|,
modifier|*
name|rifma
init|=
name|NULL
decl_stmt|;
name|struct
name|trunk_port
modifier|*
name|tp
decl_stmt|;
name|struct
name|trunk_mc
modifier|*
name|mc
decl_stmt|;
name|struct
name|sockaddr_dl
name|sdl
decl_stmt|;
name|int
name|error
decl_stmt|;
name|TRUNK_LOCK_ASSERT
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sdl
argument_list|,
sizeof|sizeof
argument_list|(
name|sdl
argument_list|)
argument_list|)
expr_stmt|;
name|sdl
operator|.
name|sdl_len
operator|=
sizeof|sizeof
argument_list|(
name|sdl
argument_list|)
expr_stmt|;
name|sdl
operator|.
name|sdl_family
operator|=
name|AF_LINK
expr_stmt|;
name|sdl
operator|.
name|sdl_type
operator|=
name|IFT_ETHER
expr_stmt|;
name|sdl
operator|.
name|sdl_alen
operator|=
name|ETHER_ADDR_LEN
expr_stmt|;
comment|/* First, remove any existing filter entries. */
name|trunk_ether_purgemulti
argument_list|(
name|tr
argument_list|)
expr_stmt|;
comment|/* Now program new ones. */
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&trifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|mc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|trunk_mc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mc
operator|->
name|mc_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|tr
operator|->
name|tr_mc_head
argument_list|,
name|mc
argument_list|,
name|mc_entries
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
name|LLADDR
argument_list|(
operator|&
name|sdl
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* do all the ports */
name|SLIST_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|&tr->tr_ports
argument_list|,
argument|tp_entries
argument_list|)
block|{
name|ifp
operator|=
name|tp
operator|->
name|tp_ifp
expr_stmt|;
name|sdl
operator|.
name|sdl_index
operator|=
name|ifp
operator|->
name|if_index
expr_stmt|;
name|error
operator|=
name|if_addmulti
argument_list|(
name|ifp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sdl
argument_list|,
operator|&
name|rifma
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|trunk_ether_cmdmulti
parameter_list|(
name|struct
name|trunk_port
modifier|*
name|tp
parameter_list|,
name|int
name|set
parameter_list|)
block|{
name|struct
name|trunk_softc
modifier|*
name|tr
init|=
name|tp
operator|->
name|tp_trunk
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|tp
operator|->
name|tp_ifp
decl_stmt|;
empty_stmt|;
name|struct
name|trunk_mc
modifier|*
name|mc
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|rifma
init|=
name|NULL
decl_stmt|;
name|struct
name|sockaddr_dl
name|sdl
decl_stmt|;
name|int
name|error
decl_stmt|;
name|TRUNK_LOCK_ASSERT
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sdl
argument_list|,
sizeof|sizeof
argument_list|(
name|sdl
argument_list|)
argument_list|)
expr_stmt|;
name|sdl
operator|.
name|sdl_len
operator|=
sizeof|sizeof
argument_list|(
name|sdl
argument_list|)
expr_stmt|;
name|sdl
operator|.
name|sdl_family
operator|=
name|AF_LINK
expr_stmt|;
name|sdl
operator|.
name|sdl_type
operator|=
name|IFT_ETHER
expr_stmt|;
name|sdl
operator|.
name|sdl_alen
operator|=
name|ETHER_ADDR_LEN
expr_stmt|;
name|sdl
operator|.
name|sdl_index
operator|=
name|ifp
operator|->
name|if_index
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|mc
argument_list|,
argument|&tr->tr_mc_head
argument_list|,
argument|mc_entries
argument_list|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|mc
operator|->
name|mc_addr
argument_list|,
name|LLADDR
argument_list|(
operator|&
name|sdl
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
name|error
operator|=
name|if_addmulti
argument_list|(
name|ifp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sdl
argument_list|,
operator|&
name|rifma
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|if_delmulti
argument_list|(
name|ifp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sdl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|printf
argument_list|(
literal|"cmdmulti error on %s, set = %d\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|set
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trunk_ether_purgemulti
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|)
block|{
name|struct
name|trunk_port
modifier|*
name|tp
decl_stmt|;
name|struct
name|trunk_mc
modifier|*
name|mc
decl_stmt|;
name|TRUNK_LOCK_ASSERT
argument_list|(
name|tr
argument_list|)
expr_stmt|;
comment|/* remove from ports */
name|SLIST_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|&tr->tr_ports
argument_list|,
argument|tp_entries
argument_list|)
name|trunk_ether_cmdmulti
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|mc
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|tr
operator|->
name|tr_mc_head
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE
argument_list|(
operator|&
name|tr
operator|->
name|tr_mc_head
argument_list|,
name|mc
argument_list|,
name|trunk_mc
argument_list|,
name|mc_entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Handle a ref counted flag that should be set on the trunk port as well */
end_comment

begin_function
specifier|static
name|int
name|trunk_setflag
parameter_list|(
name|struct
name|trunk_port
modifier|*
name|tp
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|status
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|)
block|{
name|struct
name|trunk_softc
modifier|*
name|tr
init|=
name|tp
operator|->
name|tp_trunk
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|trifp
init|=
name|tr
operator|->
name|tr_ifp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|tp
operator|->
name|tp_ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|TRUNK_LOCK_ASSERT
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|status
operator|=
name|status
condition|?
operator|(
name|trifp
operator|->
name|if_flags
operator|&
name|flag
operator|)
else|:
literal|0
expr_stmt|;
comment|/* Now "status" contains the flag value or 0 */
comment|/* 	 * See if recorded ports status is different from what 	 * we want it to be.  If it is, flip it.  We record ports 	 * status in tp_ifflags so that we won't clear ports flag 	 * we haven't set.  In fact, we don't clear or set ports 	 * flags directly, but get or release references to them. 	 * That's why we can be sure that recorded flags still are 	 * in accord with actual ports flags. 	 */
if|if
condition|(
name|status
operator|!=
operator|(
name|tp
operator|->
name|tp_ifflags
operator|&
name|flag
operator|)
condition|)
block|{
name|error
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|ifp
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tp
operator|->
name|tp_ifflags
operator|&=
operator|~
name|flag
expr_stmt|;
name|tp
operator|->
name|tp_ifflags
operator||=
name|status
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle IFF_* flags that require certain changes on the trunk port  * if "status" is true, update ports flags respective to the trunk  * if "status" is false, forcedly clear the flags set on port.  */
end_comment

begin_function
specifier|static
name|int
name|trunk_setflags
parameter_list|(
name|struct
name|trunk_port
modifier|*
name|tp
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|trunk_pflags
index|[
name|i
index|]
operator|.
name|flag
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|trunk_setflag
argument_list|(
name|tp
argument_list|,
name|trunk_pflags
index|[
name|i
index|]
operator|.
name|flag
argument_list|,
name|status
argument_list|,
name|trunk_pflags
index|[
name|i
index|]
operator|.
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trunk_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|trunk_softc
modifier|*
name|tr
init|=
operator|(
expr|struct
name|trunk_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
name|error
operator|=
literal|0
control|)
block|{
name|IFQ_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
operator|->
name|tr_proto
operator|!=
name|TRUNK_PROTO_NONE
condition|)
block|{
name|TRUNK_LOCK
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|tr
operator|->
name|tr_start
call|)
argument_list|(
name|tr
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|TRUNK_UNLOCK
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
else|else
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
else|else
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|trunk_input
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|trunk_port
modifier|*
name|tp
init|=
name|ifp
operator|->
name|if_trunk
decl_stmt|;
name|struct
name|trunk_softc
modifier|*
name|tr
init|=
name|tp
operator|->
name|tp_trunk
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|trifp
init|=
name|tr
operator|->
name|tr_ifp
decl_stmt|;
if|if
condition|(
operator|(
name|trifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
name|tr
operator|->
name|tr_proto
operator|==
name|TRUNK_PROTO_NONE
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|TRUNK_LOCK
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|BPF_MTAP
argument_list|(
name|trifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
call|(
modifier|*
name|tr
operator|->
name|tr_input
call|)
argument_list|(
name|tr
argument_list|,
name|tp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_ibytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|trifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|trifp
operator|->
name|if_ibytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
block|}
name|TRUNK_UNLOCK
argument_list|(
name|tr
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|trunk_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|trunk_softc
modifier|*
name|tr
init|=
operator|(
expr|struct
name|trunk_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
name|tr
operator|->
name|tr_ifflags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Ignore */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trunk_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|imr
parameter_list|)
block|{
name|struct
name|trunk_softc
modifier|*
name|tr
init|=
operator|(
expr|struct
name|trunk_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|trunk_port
modifier|*
name|tp
decl_stmt|;
name|imr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|imr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
expr_stmt|;
name|TRUNK_LOCK
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|tp
operator|=
name|tr
operator|->
name|tr_primary
expr_stmt|;
if|if
condition|(
name|tp
operator|!=
name|NULL
operator|&&
name|tp
operator|->
name|tp_ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|imr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
name|TRUNK_UNLOCK
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trunk_port_state
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|trunk_port
modifier|*
name|tp
init|=
operator|(
expr|struct
name|trunk_port
operator|*
operator|)
name|ifp
operator|->
name|if_trunk
decl_stmt|;
name|struct
name|trunk_softc
modifier|*
name|tr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|tp
operator|!=
name|NULL
condition|)
name|tr
operator|=
name|tp
operator|->
name|tp_trunk
expr_stmt|;
if|if
condition|(
name|tr
operator|==
name|NULL
condition|)
return|return;
name|TRUNK_LOCK
argument_list|(
name|tr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tr
operator|->
name|tr_linkstate
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|tr
operator|->
name|tr_linkstate
call|)
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|TRUNK_UNLOCK
argument_list|(
name|tr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|trunk_port
modifier|*
name|trunk_link_active
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|,
name|struct
name|trunk_port
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|trunk_port
modifier|*
name|tp_next
decl_stmt|,
modifier|*
name|rval
init|=
name|NULL
decl_stmt|;
comment|// int new_link = LINK_STATE_DOWN;
name|TRUNK_LOCK_ASSERT
argument_list|(
name|tr
argument_list|)
expr_stmt|;
comment|/* 	 * Search a port which reports an active link state. 	 */
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
goto|goto
name|search
goto|;
if|if
condition|(
name|TRUNK_PORTACTIVE
argument_list|(
name|tp
argument_list|)
condition|)
block|{
name|rval
operator|=
name|tp
expr_stmt|;
goto|goto
name|found
goto|;
block|}
if|if
condition|(
operator|(
name|tp_next
operator|=
name|SLIST_NEXT
argument_list|(
name|tp
argument_list|,
name|tp_entries
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|TRUNK_PORTACTIVE
argument_list|(
name|tp_next
argument_list|)
condition|)
block|{
name|rval
operator|=
name|tp_next
expr_stmt|;
goto|goto
name|found
goto|;
block|}
name|search
label|:
name|SLIST_FOREACH
argument_list|(
argument|tp_next
argument_list|,
argument|&tr->tr_ports
argument_list|,
argument|tp_entries
argument_list|)
block|{
if|if
condition|(
name|TRUNK_PORTACTIVE
argument_list|(
name|tp_next
argument_list|)
condition|)
block|{
name|rval
operator|=
name|tp_next
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
name|found
label|:
if|if
condition|(
name|rval
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * The IEEE 802.1D standard assumes that a trunk with 		 * multiple ports is always full duplex. This is valid 		 * for load sharing trunks and if at least two links 		 * are active. Unfortunately, checking the latter would 		 * be too expensive at this point. 		 XXX 		if ((tr->tr_capabilities& IFCAP_TRUNK_FULLDUPLEX)&& 		    (tr->tr_count> 1)) 			new_link = LINK_STATE_FULL_DUPLEX; 		else 			new_link = rval->tp_link_state; 		 */
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|void
modifier|*
name|trunk_gethdr
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u_int
name|off
parameter_list|,
name|u_int
name|len
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
operator|(
name|off
operator|+
name|len
operator|)
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
operator|(
name|off
operator|+
name|len
operator|)
condition|)
block|{
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
return|return
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|off
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|trunk_hashmbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
name|key
parameter_list|)
block|{
name|uint16_t
name|etype
decl_stmt|;
name|uint32_t
name|p
init|=
literal|0
decl_stmt|;
name|int
name|off
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ether_vlan_header
name|vlanbuf
decl_stmt|;
specifier|const
name|struct
name|ether_vlan_header
modifier|*
name|vlan
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
specifier|const
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|ip
name|ipbuf
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
specifier|const
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|ip6_hdr
name|ip6buf
decl_stmt|;
endif|#
directive|endif
name|off
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|off
condition|)
goto|goto
name|out
goto|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|eh
operator|->
name|ether_shost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|eh
operator|->
name|ether_dhost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Special handling for encapsulating VLAN frames */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|,
sizeof|sizeof
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|etype
operator|==
name|ETHERTYPE_VLAN
condition|)
block|{
name|vlan
operator|=
name|trunk_gethdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vlan
argument_list|)
argument_list|,
operator|&
name|vlanbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlan
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|vlan
operator|->
name|evl_tag
argument_list|,
sizeof|sizeof
argument_list|(
name|vlan
operator|->
name|evl_tag
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|etype
operator|=
name|ntohs
argument_list|(
name|vlan
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
name|off
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|vlan
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|etype
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|ETHERTYPE_IP
case|:
name|ip
operator|=
name|trunk_gethdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|,
operator|&
name|ipbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|ip
operator|->
name|ip_src
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|ip
operator|->
name|ip_dst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|ETHERTYPE_IPV6
case|:
name|ip6
operator|=
name|trunk_gethdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
argument_list|,
operator|&
name|ip6buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip6
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|out
label|:
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|int
name|trunk_enqueue
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Send mbuf */
name|IFQ_ENQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
operator|==
literal|0
condition|)
call|(
modifier|*
name|ifp
operator|->
name|if_start
call|)
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_obytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_MCAST
condition|)
name|ifp
operator|->
name|if_omcasts
operator|++
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Simple round robin trunking  */
end_comment

begin_function
specifier|static
name|int
name|trunk_rr_attach
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|)
block|{
name|struct
name|trunk_port
modifier|*
name|tp
decl_stmt|;
name|tr
operator|->
name|tr_detach
operator|=
name|trunk_rr_detach
expr_stmt|;
name|tr
operator|->
name|tr_start
operator|=
name|trunk_rr_start
expr_stmt|;
name|tr
operator|->
name|tr_input
operator|=
name|trunk_rr_input
expr_stmt|;
name|tr
operator|->
name|tr_port_create
operator|=
name|NULL
expr_stmt|;
name|tr
operator|->
name|tr_port_destroy
operator|=
name|trunk_rr_port_destroy
expr_stmt|;
name|tr
operator|->
name|tr_capabilities
operator|=
name|IFCAP_TRUNK_FULLDUPLEX
expr_stmt|;
name|tp
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|tr
operator|->
name|tr_ports
argument_list|)
expr_stmt|;
name|tr
operator|->
name|tr_psc
operator|=
operator|(
name|caddr_t
operator|)
name|tp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|trunk_rr_detach
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|)
block|{
name|tr
operator|->
name|tr_psc
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trunk_rr_port_destroy
parameter_list|(
name|struct
name|trunk_port
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|trunk_softc
modifier|*
name|tr
init|=
name|tp
operator|->
name|tp_trunk
decl_stmt|;
if|if
condition|(
name|tp
operator|==
operator|(
expr|struct
name|trunk_port
operator|*
operator|)
name|tr
operator|->
name|tr_psc
condition|)
name|tr
operator|->
name|tr_psc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|trunk_rr_start
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|trunk_port
modifier|*
name|tp
init|=
operator|(
expr|struct
name|trunk_port
operator|*
operator|)
name|tr
operator|->
name|tr_psc
decl_stmt|,
modifier|*
name|tp_next
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
operator|&&
operator|(
name|tp
operator|=
name|trunk_link_active
argument_list|(
name|tr
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Send mbuf */
name|error
operator|=
name|trunk_enqueue
argument_list|(
name|tp
operator|->
name|tp_ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Get next active port */
name|tp_next
operator|=
name|trunk_link_active
argument_list|(
name|tr
argument_list|,
name|SLIST_NEXT
argument_list|(
name|tp
argument_list|,
name|tp_entries
argument_list|)
argument_list|)
expr_stmt|;
name|tr
operator|->
name|tr_psc
operator|=
operator|(
name|caddr_t
operator|)
name|tp_next
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|trunk_rr_input
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|,
name|struct
name|trunk_port
modifier|*
name|tp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|tr
operator|->
name|tr_ifp
decl_stmt|;
comment|/* Just pass in the packet to our trunk device */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Active failover  */
end_comment

begin_function
specifier|static
name|int
name|trunk_fail_attach
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|)
block|{
name|tr
operator|->
name|tr_detach
operator|=
name|trunk_fail_detach
expr_stmt|;
name|tr
operator|->
name|tr_start
operator|=
name|trunk_fail_start
expr_stmt|;
name|tr
operator|->
name|tr_input
operator|=
name|trunk_fail_input
expr_stmt|;
name|tr
operator|->
name|tr_port_create
operator|=
name|NULL
expr_stmt|;
name|tr
operator|->
name|tr_port_destroy
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|trunk_fail_detach
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|trunk_fail_start
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|trunk_port
modifier|*
name|tp
decl_stmt|;
comment|/* Use the master port if active or the next available port */
if|if
condition|(
operator|(
name|tp
operator|=
name|trunk_link_active
argument_list|(
name|tr
argument_list|,
name|tr
operator|->
name|tr_primary
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Send mbuf */
return|return
operator|(
name|trunk_enqueue
argument_list|(
name|tp
operator|->
name|tp_ifp
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|trunk_fail_input
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|,
name|struct
name|trunk_port
modifier|*
name|tp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|tr
operator|->
name|tr_ifp
decl_stmt|;
name|struct
name|trunk_port
modifier|*
name|tmp_tp
decl_stmt|;
if|if
condition|(
name|tp
operator|==
name|tr
operator|->
name|tr_primary
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
if|if
condition|(
name|tr
operator|->
name|tr_primary
operator|->
name|tp_link_state
operator|==
name|LINK_STATE_DOWN
condition|)
block|{
name|tmp_tp
operator|=
name|trunk_link_active
argument_list|(
name|tr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * If tmp_tp is null, we've recieved a packet when all 		 * our links are down. Weird, but process it anyways. 		 */
if|if
condition|(
operator|(
name|tmp_tp
operator|==
name|NULL
operator|||
name|tmp_tp
operator|==
name|tp
operator|)
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Loadbalancing  */
end_comment

begin_function
specifier|static
name|int
name|trunk_lb_attach
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|)
block|{
name|struct
name|trunk_port
modifier|*
name|tp
decl_stmt|;
name|struct
name|trunk_lb
modifier|*
name|lb
decl_stmt|;
if|if
condition|(
operator|(
name|lb
operator|=
operator|(
expr|struct
name|trunk_lb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|trunk_lb
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|tr
operator|->
name|tr_detach
operator|=
name|trunk_lb_detach
expr_stmt|;
name|tr
operator|->
name|tr_start
operator|=
name|trunk_lb_start
expr_stmt|;
name|tr
operator|->
name|tr_input
operator|=
name|trunk_lb_input
expr_stmt|;
name|tr
operator|->
name|tr_port_create
operator|=
name|trunk_lb_port_create
expr_stmt|;
name|tr
operator|->
name|tr_port_destroy
operator|=
name|trunk_lb_port_destroy
expr_stmt|;
name|tr
operator|->
name|tr_capabilities
operator|=
name|IFCAP_TRUNK_FULLDUPLEX
expr_stmt|;
name|lb
operator|->
name|lb_key
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|tr
operator|->
name|tr_psc
operator|=
operator|(
name|caddr_t
operator|)
name|lb
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|&tr->tr_ports
argument_list|,
argument|tp_entries
argument_list|)
name|trunk_lb_port_create
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|trunk_lb_detach
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|)
block|{
name|struct
name|trunk_lb
modifier|*
name|lb
init|=
operator|(
expr|struct
name|trunk_lb
operator|*
operator|)
name|tr
operator|->
name|tr_psc
decl_stmt|;
if|if
condition|(
name|lb
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|lb
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|trunk_lb_porttable
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|,
name|struct
name|trunk_port
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|trunk_lb
modifier|*
name|lb
init|=
operator|(
expr|struct
name|trunk_lb
operator|*
operator|)
name|tr
operator|->
name|tr_psc
decl_stmt|;
name|struct
name|trunk_port
modifier|*
name|tp_next
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|lb
operator|->
name|lb_ports
argument_list|,
sizeof|sizeof
argument_list|(
name|lb
operator|->
name|lb_ports
argument_list|)
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|tp_next
argument_list|,
argument|&tr->tr_ports
argument_list|,
argument|tp_entries
argument_list|)
block|{
if|if
condition|(
name|tp_next
operator|==
name|tp
condition|)
continue|continue;
if|if
condition|(
name|i
operator|>=
name|TRUNK_MAX_PORTS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|tr
operator|->
name|tr_ifflags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: port %s at index %d\n"
argument_list|,
name|tr
operator|->
name|tr_ifname
argument_list|,
name|tp_next
operator|->
name|tp_ifname
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lb
operator|->
name|lb_ports
index|[
name|i
operator|++
index|]
operator|=
name|tp_next
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|trunk_lb_port_create
parameter_list|(
name|struct
name|trunk_port
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|trunk_softc
modifier|*
name|tr
init|=
name|tp
operator|->
name|tp_trunk
decl_stmt|;
return|return
operator|(
name|trunk_lb_porttable
argument_list|(
name|tr
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trunk_lb_port_destroy
parameter_list|(
name|struct
name|trunk_port
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|trunk_softc
modifier|*
name|tr
init|=
name|tp
operator|->
name|tp_trunk
decl_stmt|;
name|trunk_lb_porttable
argument_list|(
name|tr
argument_list|,
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|trunk_lb_start
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|trunk_lb
modifier|*
name|lb
init|=
operator|(
expr|struct
name|trunk_lb
operator|*
operator|)
name|tr
operator|->
name|tr_psc
decl_stmt|;
name|struct
name|trunk_port
modifier|*
name|tp
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|p
init|=
literal|0
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|p
operator|=
name|trunk_hashmbuf
argument_list|(
name|m
argument_list|,
name|lb
operator|->
name|lb_key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|idx
operator|=
name|p
operator|%
name|tr
operator|->
name|tr_count
operator|)
operator|>=
name|TRUNK_MAX_PORTS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|tp
operator|=
name|lb
operator|->
name|lb_ports
index|[
name|idx
index|]
expr_stmt|;
comment|/* 	 * Check the port's link state. This will return the next active 	 * port if the link is down or the port is NULL. 	 */
if|if
condition|(
operator|(
name|tp
operator|=
name|trunk_link_active
argument_list|(
name|tr
argument_list|,
name|tp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Send mbuf */
return|return
operator|(
name|trunk_enqueue
argument_list|(
name|tp
operator|->
name|tp_ifp
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|trunk_lb_input
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|,
name|struct
name|trunk_port
modifier|*
name|tp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|tr
operator|->
name|tr_ifp
decl_stmt|;
comment|/* Just pass in the packet to our trunk device */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 802.3ad LACP  */
end_comment

begin_function
specifier|static
name|int
name|trunk_lacp_attach
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|)
block|{
name|struct
name|trunk_port
modifier|*
name|tp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|tr
operator|->
name|tr_detach
operator|=
name|trunk_lacp_detach
expr_stmt|;
name|tr
operator|->
name|tr_port_create
operator|=
name|lacp_port_create
expr_stmt|;
name|tr
operator|->
name|tr_port_destroy
operator|=
name|lacp_port_destroy
expr_stmt|;
name|tr
operator|->
name|tr_linkstate
operator|=
name|lacp_linkstate
expr_stmt|;
name|tr
operator|->
name|tr_start
operator|=
name|trunk_lacp_start
expr_stmt|;
name|tr
operator|->
name|tr_input
operator|=
name|trunk_lacp_input
expr_stmt|;
name|tr
operator|->
name|tr_init
operator|=
name|lacp_init
expr_stmt|;
name|tr
operator|->
name|tr_stop
operator|=
name|lacp_stop
expr_stmt|;
name|tr
operator|->
name|tr_lladdr
operator|=
name|trunk_lacp_lladdr
expr_stmt|;
name|error
operator|=
name|lacp_attach
argument_list|(
name|tr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|SLIST_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|&tr->tr_ports
argument_list|,
argument|tp_entries
argument_list|)
name|lacp_port_create
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|trunk_lacp_detach
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|)
block|{
name|struct
name|trunk_port
modifier|*
name|tp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|&tr->tr_ports
argument_list|,
argument|tp_entries
argument_list|)
name|lacp_port_destroy
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* unlocking is safe here */
name|TRUNK_UNLOCK
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|error
operator|=
name|lacp_detach
argument_list|(
name|tr
argument_list|)
expr_stmt|;
name|TRUNK_LOCK
argument_list|(
name|tr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|trunk_lacp_lladdr
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|)
block|{
name|struct
name|trunk_port
modifier|*
name|tp
decl_stmt|;
comment|/* purge all the lacp ports */
name|SLIST_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|&tr->tr_ports
argument_list|,
argument|tp_entries
argument_list|)
name|lacp_port_destroy
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/* add them back in */
name|SLIST_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|&tr->tr_ports
argument_list|,
argument|tp_entries
argument_list|)
name|lacp_port_create
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|trunk_lacp_start
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|trunk_port
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
name|lacp_select_tx_port
argument_list|(
name|tr
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Send mbuf */
return|return
operator|(
name|trunk_enqueue
argument_list|(
name|tp
operator|->
name|tp_ifp
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|trunk_lacp_input
parameter_list|(
name|struct
name|trunk_softc
modifier|*
name|tr
parameter_list|,
name|struct
name|trunk_port
modifier|*
name|tp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|tr
operator|->
name|tr_ifp
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|u_short
name|etype
decl_stmt|;
name|uint8_t
name|subtype
decl_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
comment|/* Tap off LACP control messages */
if|if
condition|(
name|etype
operator|==
name|ETHERTYPE_SLOW
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|subtype
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|subtype
argument_list|)
argument_list|,
operator|&
name|subtype
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|subtype
condition|)
block|{
case|case
name|SLOWPROTOCOLS_SUBTYPE_LACP
case|:
name|lacp_input
argument_list|(
name|tp
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLOWPROTOCOLS_SUBTYPE_MARKER
case|:
name|lacp_marker_input
argument_list|(
name|tp
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Unknown LACP packet type */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * If the port is not collecting or not in the active aggregator then 	 * free and return. 	 */
if|if
condition|(
operator|(
name|tp
operator|->
name|tp_flags
operator|&
name|TRUNK_PORT_COLLECTING
operator|)
operator|==
literal|0
operator|||
name|lacp_port_isactive
argument_list|(
name|tp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

end_unit

