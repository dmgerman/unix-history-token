begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007 Seccuris Inc.  * All rights reserved.  *  * This software was developed by Robert N. M. Watson under contract to  * Seccuris Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_bpf.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sf_buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf_zerocopy.h>
end_include

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_comment
comment|/*  * Zero-copy buffer scheme for BPF: user space "donates" two buffers, which  * are mapped into the kernel address space using sf_bufs and used directly  * by BPF.  Memory is wired since page faults cannot be tolerated in the  * contexts where the buffers are copied to (locks held, interrupt context,  * etc).  Access to shared memory buffers is synchronized using a header on  * each buffer, allowing the number of system calls to go to zero as BPF  * reaches saturation (buffers filled as fast as they can be drained by the  * user process).  Full details of the protocol for communicating between the  * user process and BPF may be found in bpf(4).  */
end_comment

begin_comment
comment|/*  * Maximum number of pages per buffer.  Since all BPF devices use two, the  * maximum per device is 2*BPF_MAX_PAGES.  Resource limits on the number of  * sf_bufs may be an issue, so do not set this too high.  On older systems,  * kernel address space limits may also be an issue.  */
end_comment

begin_define
define|#
directive|define
name|BPF_MAX_PAGES
value|512
end_define

begin_comment
comment|/*  * struct zbuf describes a memory buffer loaned by a user process to the  * kernel.  We represent this as a series of pages managed using an array of  * sf_bufs.  Even though the memory is contiguous in user space, it may not  * be mapped contiguously in the kernel (i.e., a set of physically  * non-contiguous pages in the direct map region) so we must implement  * scatter-gather copying.  One significant mitigating factor is that on  * systems with a direct memory map, we can avoid TLB misses.  *  * At the front of the shared memory region is a bpf_zbuf_header, which  * contains shared control data to allow user space and the kernel to  * synchronize; this is included in zb_size, but not bpf_bufsize, so that BPF  * knows that the space is not available.  */
end_comment

begin_struct
struct|struct
name|zbuf
block|{
name|vm_offset_t
name|zb_uaddr
decl_stmt|;
comment|/* User address at time of setup. */
name|size_t
name|zb_size
decl_stmt|;
comment|/* Size of buffer, incl. header. */
name|u_int
name|zb_numpages
decl_stmt|;
comment|/* Number of pages. */
name|int
name|zb_flags
decl_stmt|;
comment|/* Flags on zbuf. */
name|struct
name|sf_buf
modifier|*
modifier|*
name|zb_pages
decl_stmt|;
comment|/* Pages themselves. */
name|struct
name|bpf_zbuf_header
modifier|*
name|zb_header
decl_stmt|;
comment|/* Shared header. */
block|}
struct|;
end_struct

begin_comment
comment|/*  * When a buffer has been assigned to userspace, flag it as such, as the  * buffer may remain in the store position as a result of the user process  * not yet having acknowledged the buffer in the hold position yet.  */
end_comment

begin_define
define|#
directive|define
name|ZBUF_FLAG_ASSIGNED
value|0x00000001
end_define

begin_comment
comment|/* Set when owned by user. */
end_comment

begin_comment
comment|/*  * Release a page we've previously wired.  */
end_comment

begin_function
specifier|static
name|void
name|zbuf_page_free
parameter_list|(
name|vm_page_t
name|pp
parameter_list|)
block|{
name|vm_page_lock
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|wire_count
operator|==
literal|0
operator|&&
name|pp
operator|->
name|object
operator|==
name|NULL
condition|)
name|vm_page_free
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free an sf_buf with attached page.  */
end_comment

begin_function
specifier|static
name|void
name|zbuf_sfbuf_free
parameter_list|(
name|struct
name|sf_buf
modifier|*
name|sf
parameter_list|)
block|{
name|vm_page_t
name|pp
decl_stmt|;
name|pp
operator|=
name|sf_buf_page
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|sf_buf_free
argument_list|(
name|sf
argument_list|)
expr_stmt|;
name|zbuf_page_free
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free a zbuf, including its page array, sbufs, and pages.  Allow partially  * allocated zbufs to be freed so that it may be used even during a zbuf  * setup.  */
end_comment

begin_function
specifier|static
name|void
name|zbuf_free
parameter_list|(
name|struct
name|zbuf
modifier|*
name|zb
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zb
operator|->
name|zb_numpages
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|zb
operator|->
name|zb_pages
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|zbuf_sfbuf_free
argument_list|(
name|zb
operator|->
name|zb_pages
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|zb
operator|->
name|zb_pages
argument_list|,
name|M_BPF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|zb
argument_list|,
name|M_BPF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a user pointer to a page of user memory, return an sf_buf for the  * page.  Because we may be requesting quite a few sf_bufs, prefer failure to  * deadlock and use SFB_NOWAIT.  */
end_comment

begin_function
specifier|static
name|struct
name|sf_buf
modifier|*
name|zbuf_sfbuf_get
parameter_list|(
name|struct
name|vm_map
modifier|*
name|map
parameter_list|,
name|vm_offset_t
name|uaddr
parameter_list|)
block|{
name|struct
name|sf_buf
modifier|*
name|sf
decl_stmt|;
name|vm_page_t
name|pp
decl_stmt|;
if|if
condition|(
name|vm_fault_quick_hold_pages
argument_list|(
name|map
argument_list|,
name|uaddr
argument_list|,
name|PAGE_SIZE
argument_list|,
name|VM_PROT_READ
operator||
name|VM_PROT_WRITE
argument_list|,
operator|&
name|pp
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|vm_page_lock
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|vm_page_wire
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|vm_page_unhold
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|vm_page_unlock
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|sf
operator|=
name|sf_buf_alloc
argument_list|(
name|pp
argument_list|,
name|SFB_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf
operator|==
name|NULL
condition|)
block|{
name|zbuf_page_free
argument_list|(
name|pp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|sf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a zbuf describing a range of user address space memory.  Validate  * page alignment, size requirements, etc.  */
end_comment

begin_function
specifier|static
name|int
name|zbuf_setup
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|vm_offset_t
name|uaddr
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|zbuf
modifier|*
modifier|*
name|zbp
parameter_list|)
block|{
name|struct
name|zbuf
modifier|*
name|zb
decl_stmt|;
name|struct
name|vm_map
modifier|*
name|map
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
operator|*
name|zbp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * User address must be page-aligned. 	 */
if|if
condition|(
name|uaddr
operator|&
name|PAGE_MASK
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Length must be an integer number of full pages. 	 */
if|if
condition|(
name|len
operator|&
name|PAGE_MASK
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Length must not exceed per-buffer resource limit. 	 */
if|if
condition|(
operator|(
name|len
operator|/
name|PAGE_SIZE
operator|)
operator|>
name|BPF_MAX_PAGES
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Allocate the buffer and set up each page with is own sf_buf. 	 */
name|error
operator|=
literal|0
expr_stmt|;
name|zb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|zb
argument_list|)
argument_list|,
name|M_BPF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|zb
operator|->
name|zb_uaddr
operator|=
name|uaddr
expr_stmt|;
name|zb
operator|->
name|zb_size
operator|=
name|len
expr_stmt|;
name|zb
operator|->
name|zb_numpages
operator|=
name|len
operator|/
name|PAGE_SIZE
expr_stmt|;
name|zb
operator|->
name|zb_pages
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sf_buf
operator|*
argument_list|)
operator|*
name|zb
operator|->
name|zb_numpages
argument_list|,
name|M_BPF
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|map
operator|=
operator|&
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_map
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zb
operator|->
name|zb_numpages
condition|;
name|i
operator|++
control|)
block|{
name|zb
operator|->
name|zb_pages
index|[
name|i
index|]
operator|=
name|zbuf_sfbuf_get
argument_list|(
name|map
argument_list|,
name|uaddr
operator|+
operator|(
name|i
operator|*
name|PAGE_SIZE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zb
operator|->
name|zb_pages
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
name|zb
operator|->
name|zb_header
operator|=
operator|(
expr|struct
name|bpf_zbuf_header
operator|*
operator|)
name|sf_buf_kva
argument_list|(
name|zb
operator|->
name|zb_pages
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|zb
operator|->
name|zb_header
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zb
operator|->
name|zb_header
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|zbp
operator|=
name|zb
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|zbuf_free
argument_list|(
name|zb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy bytes from a source into the specified zbuf.  The caller is  * responsible for performing bounds checking, etc.  */
end_comment

begin_function
name|void
name|bpf_zerocopy_append_bytes
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|,
name|caddr_t
name|buf
parameter_list|,
name|u_int
name|offset
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|u_int
name|count
decl_stmt|,
name|page
decl_stmt|,
name|poffset
decl_stmt|;
name|u_char
modifier|*
name|src_bytes
decl_stmt|;
name|struct
name|zbuf
modifier|*
name|zb
decl_stmt|;
name|KASSERT
argument_list|(
name|d
operator|->
name|bd_bufmode
operator|==
name|BPF_BUFMODE_ZBUF
argument_list|,
operator|(
literal|"bpf_zerocopy_append_bytes: not in zbuf mode"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|buf
operator|!=
name|NULL
argument_list|,
operator|(
literal|"bpf_zerocopy_append_bytes: NULL buf"
operator|)
argument_list|)
expr_stmt|;
name|src_bytes
operator|=
operator|(
name|u_char
operator|*
operator|)
name|src
expr_stmt|;
name|zb
operator|=
operator|(
expr|struct
name|zbuf
operator|*
operator|)
name|buf
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|zb
operator|->
name|zb_flags
operator|&
name|ZBUF_FLAG_ASSIGNED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"bpf_zerocopy_append_bytes: ZBUF_FLAG_ASSIGNED"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Scatter-gather copy to user pages mapped into kernel address space 	 * using sf_bufs: copy up to a page at a time. 	 */
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|bpf_zbuf_header
argument_list|)
expr_stmt|;
name|page
operator|=
name|offset
operator|/
name|PAGE_SIZE
expr_stmt|;
name|poffset
operator|=
name|offset
operator|%
name|PAGE_SIZE
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|page
operator|<
name|zb
operator|->
name|zb_numpages
argument_list|,
operator|(
literal|"bpf_zerocopy_append_bytes:"
literal|" page overflow (%d p %d np)\n"
operator|,
name|page
operator|,
name|zb
operator|->
name|zb_numpages
operator|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|min
argument_list|(
name|len
argument_list|,
name|PAGE_SIZE
operator|-
name|poffset
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|src_bytes
argument_list|,
operator|(
operator|(
name|u_char
operator|*
operator|)
name|sf_buf_kva
argument_list|(
name|zb
operator|->
name|zb_pages
index|[
name|page
index|]
argument_list|)
operator|)
operator|+
name|poffset
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|poffset
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|poffset
operator|==
name|PAGE_SIZE
condition|)
block|{
name|poffset
operator|=
literal|0
expr_stmt|;
name|page
operator|++
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|poffset
operator|<
name|PAGE_SIZE
argument_list|,
operator|(
literal|"bpf_zerocopy_append_bytes: page offset overflow (%d)"
operator|,
name|poffset
operator|)
argument_list|)
expr_stmt|;
name|len
operator|-=
name|count
expr_stmt|;
name|src_bytes
operator|+=
name|count
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Copy bytes from an mbuf chain to the specified zbuf: copying will be  * scatter-gather both from mbufs, which may be fragmented over memory, and  * to pages, which may not be contiguously mapped in kernel address space.  * As with bpf_zerocopy_append_bytes(), the caller is responsible for  * checking that this will not exceed the buffer limit.  */
end_comment

begin_function
name|void
name|bpf_zerocopy_append_mbuf
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|,
name|caddr_t
name|buf
parameter_list|,
name|u_int
name|offset
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|u_int
name|count
decl_stmt|,
name|moffset
decl_stmt|,
name|page
decl_stmt|,
name|poffset
decl_stmt|;
specifier|const
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|zbuf
modifier|*
name|zb
decl_stmt|;
name|KASSERT
argument_list|(
name|d
operator|->
name|bd_bufmode
operator|==
name|BPF_BUFMODE_ZBUF
argument_list|,
operator|(
literal|"bpf_zerocopy_append_mbuf not in zbuf mode"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|buf
operator|!=
name|NULL
argument_list|,
operator|(
literal|"bpf_zerocopy_append_mbuf: NULL buf"
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|src
expr_stmt|;
name|zb
operator|=
operator|(
expr|struct
name|zbuf
operator|*
operator|)
name|buf
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|zb
operator|->
name|zb_flags
operator|&
name|ZBUF_FLAG_ASSIGNED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"bpf_zerocopy_append_mbuf: ZBUF_FLAG_ASSIGNED"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Scatter gather both from an mbuf chain and to a user page set 	 * mapped into kernel address space using sf_bufs.  If we're lucky, 	 * each mbuf requires one copy operation, but if page alignment and 	 * mbuf alignment work out less well, we'll be doing two copies per 	 * mbuf. 	 */
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|bpf_zbuf_header
argument_list|)
expr_stmt|;
name|page
operator|=
name|offset
operator|/
name|PAGE_SIZE
expr_stmt|;
name|poffset
operator|=
name|offset
operator|%
name|PAGE_SIZE
expr_stmt|;
name|moffset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|page
operator|<
name|zb
operator|->
name|zb_numpages
argument_list|,
operator|(
literal|"bpf_zerocopy_append_mbuf: page overflow (%d p %d "
literal|"np)\n"
operator|,
name|page
operator|,
name|zb
operator|->
name|zb_numpages
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"bpf_zerocopy_append_mbuf: end of mbuf chain"
operator|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|min
argument_list|(
name|m
operator|->
name|m_len
operator|-
name|moffset
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|count
operator|=
name|min
argument_list|(
name|count
argument_list|,
name|PAGE_SIZE
operator|-
name|poffset
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
name|moffset
argument_list|,
operator|(
operator|(
name|u_char
operator|*
operator|)
name|sf_buf_kva
argument_list|(
name|zb
operator|->
name|zb_pages
index|[
name|page
index|]
argument_list|)
operator|)
operator|+
name|poffset
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|poffset
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|poffset
operator|==
name|PAGE_SIZE
condition|)
block|{
name|poffset
operator|=
literal|0
expr_stmt|;
name|page
operator|++
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|poffset
operator|<
name|PAGE_SIZE
argument_list|,
operator|(
literal|"bpf_zerocopy_append_mbuf: page offset overflow (%d)"
operator|,
name|poffset
operator|)
argument_list|)
expr_stmt|;
name|moffset
operator|+=
name|count
expr_stmt|;
if|if
condition|(
name|moffset
operator|==
name|m
operator|->
name|m_len
condition|)
block|{
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|moffset
operator|=
literal|0
expr_stmt|;
block|}
name|len
operator|-=
name|count
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Notification from the BPF framework that a buffer in the store position is  * rejecting packets and may be considered full.  We mark the buffer as  * immutable and assign to userspace so that it is immediately available for  * the user process to access.  */
end_comment

begin_function
name|void
name|bpf_zerocopy_buffull
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|zbuf
modifier|*
name|zb
decl_stmt|;
name|KASSERT
argument_list|(
name|d
operator|->
name|bd_bufmode
operator|==
name|BPF_BUFMODE_ZBUF
argument_list|,
operator|(
literal|"bpf_zerocopy_buffull: not in zbuf mode"
operator|)
argument_list|)
expr_stmt|;
name|zb
operator|=
operator|(
expr|struct
name|zbuf
operator|*
operator|)
name|d
operator|->
name|bd_sbuf
expr_stmt|;
name|KASSERT
argument_list|(
name|zb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"bpf_zerocopy_buffull: zb == NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zb
operator|->
name|zb_flags
operator|&
name|ZBUF_FLAG_ASSIGNED
operator|)
operator|==
literal|0
condition|)
block|{
name|zb
operator|->
name|zb_flags
operator||=
name|ZBUF_FLAG_ASSIGNED
expr_stmt|;
name|zb
operator|->
name|zb_header
operator|->
name|bzh_kernel_len
operator|=
name|d
operator|->
name|bd_slen
expr_stmt|;
name|atomic_add_rel_int
argument_list|(
operator|&
name|zb
operator|->
name|zb_header
operator|->
name|bzh_kernel_gen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Notification from the BPF framework that a buffer has moved into the held  * slot on a descriptor.  Zero-copy BPF will update the shared page to let  * the user process know and flag the buffer as assigned if it hasn't already  * been marked assigned due to filling while it was in the store position.  *  * Note: identical logic as in bpf_zerocopy_buffull(), except that we operate  * on bd_hbuf and bd_hlen.  */
end_comment

begin_function
name|void
name|bpf_zerocopy_bufheld
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|zbuf
modifier|*
name|zb
decl_stmt|;
name|KASSERT
argument_list|(
name|d
operator|->
name|bd_bufmode
operator|==
name|BPF_BUFMODE_ZBUF
argument_list|,
operator|(
literal|"bpf_zerocopy_bufheld: not in zbuf mode"
operator|)
argument_list|)
expr_stmt|;
name|zb
operator|=
operator|(
expr|struct
name|zbuf
operator|*
operator|)
name|d
operator|->
name|bd_hbuf
expr_stmt|;
name|KASSERT
argument_list|(
name|zb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"bpf_zerocopy_bufheld: zb == NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zb
operator|->
name|zb_flags
operator|&
name|ZBUF_FLAG_ASSIGNED
operator|)
operator|==
literal|0
condition|)
block|{
name|zb
operator|->
name|zb_flags
operator||=
name|ZBUF_FLAG_ASSIGNED
expr_stmt|;
name|zb
operator|->
name|zb_header
operator|->
name|bzh_kernel_len
operator|=
name|d
operator|->
name|bd_hlen
expr_stmt|;
name|atomic_add_rel_int
argument_list|(
operator|&
name|zb
operator|->
name|zb_header
operator|->
name|bzh_kernel_gen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Notification from the BPF framework that the free buffer has been been  * rotated out of the held position to the free position.  This happens when  * the user acknowledges the held buffer.  */
end_comment

begin_function
name|void
name|bpf_zerocopy_buf_reclaimed
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|zbuf
modifier|*
name|zb
decl_stmt|;
name|KASSERT
argument_list|(
name|d
operator|->
name|bd_bufmode
operator|==
name|BPF_BUFMODE_ZBUF
argument_list|,
operator|(
literal|"bpf_zerocopy_reclaim_buf: not in zbuf mode"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|d
operator|->
name|bd_fbuf
operator|!=
name|NULL
argument_list|,
operator|(
literal|"bpf_zerocopy_buf_reclaimed: NULL free buf"
operator|)
argument_list|)
expr_stmt|;
name|zb
operator|=
operator|(
expr|struct
name|zbuf
operator|*
operator|)
name|d
operator|->
name|bd_fbuf
expr_stmt|;
name|zb
operator|->
name|zb_flags
operator|&=
operator|~
name|ZBUF_FLAG_ASSIGNED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Query from the BPF framework regarding whether the buffer currently in the  * held position can be moved to the free position, which can be indicated by  * the user process making their generation number equal to the kernel  * generation number.  */
end_comment

begin_function
name|int
name|bpf_zerocopy_canfreebuf
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|zbuf
modifier|*
name|zb
decl_stmt|;
name|KASSERT
argument_list|(
name|d
operator|->
name|bd_bufmode
operator|==
name|BPF_BUFMODE_ZBUF
argument_list|,
operator|(
literal|"bpf_zerocopy_canfreebuf: not in zbuf mode"
operator|)
argument_list|)
expr_stmt|;
name|zb
operator|=
operator|(
expr|struct
name|zbuf
operator|*
operator|)
name|d
operator|->
name|bd_hbuf
expr_stmt|;
if|if
condition|(
name|zb
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|zb
operator|->
name|zb_header
operator|->
name|bzh_kernel_gen
operator|==
name|atomic_load_acq_int
argument_list|(
operator|&
name|zb
operator|->
name|zb_header
operator|->
name|bzh_user_gen
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Query from the BPF framework as to whether or not the buffer current in  * the store position can actually be written to.  This may return false if  * the store buffer is assigned to userspace before the hold buffer is  * acknowledged.  */
end_comment

begin_function
name|int
name|bpf_zerocopy_canwritebuf
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|zbuf
modifier|*
name|zb
decl_stmt|;
name|KASSERT
argument_list|(
name|d
operator|->
name|bd_bufmode
operator|==
name|BPF_BUFMODE_ZBUF
argument_list|,
operator|(
literal|"bpf_zerocopy_canwritebuf: not in zbuf mode"
operator|)
argument_list|)
expr_stmt|;
name|zb
operator|=
operator|(
expr|struct
name|zbuf
operator|*
operator|)
name|d
operator|->
name|bd_sbuf
expr_stmt|;
name|KASSERT
argument_list|(
name|zb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"bpf_zerocopy_canwritebuf: bd_sbuf NULL"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zb
operator|->
name|zb_flags
operator|&
name|ZBUF_FLAG_ASSIGNED
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free zero copy buffers at request of descriptor.  */
end_comment

begin_function
name|void
name|bpf_zerocopy_free
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|zbuf
modifier|*
name|zb
decl_stmt|;
name|KASSERT
argument_list|(
name|d
operator|->
name|bd_bufmode
operator|==
name|BPF_BUFMODE_ZBUF
argument_list|,
operator|(
literal|"bpf_zerocopy_free: not in zbuf mode"
operator|)
argument_list|)
expr_stmt|;
name|zb
operator|=
operator|(
expr|struct
name|zbuf
operator|*
operator|)
name|d
operator|->
name|bd_sbuf
expr_stmt|;
if|if
condition|(
name|zb
operator|!=
name|NULL
condition|)
name|zbuf_free
argument_list|(
name|zb
argument_list|)
expr_stmt|;
name|zb
operator|=
operator|(
expr|struct
name|zbuf
operator|*
operator|)
name|d
operator|->
name|bd_hbuf
expr_stmt|;
if|if
condition|(
name|zb
operator|!=
name|NULL
condition|)
name|zbuf_free
argument_list|(
name|zb
argument_list|)
expr_stmt|;
name|zb
operator|=
operator|(
expr|struct
name|zbuf
operator|*
operator|)
name|d
operator|->
name|bd_fbuf
expr_stmt|;
if|if
condition|(
name|zb
operator|!=
name|NULL
condition|)
name|zbuf_free
argument_list|(
name|zb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Ioctl to return the maximum buffer size.  */
end_comment

begin_function
name|int
name|bpf_zerocopy_ioctl_getzmax
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|,
name|size_t
modifier|*
name|i
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|d
operator|->
name|bd_bufmode
operator|==
name|BPF_BUFMODE_ZBUF
argument_list|,
operator|(
literal|"bpf_zerocopy_ioctl_getzmax: not in zbuf mode"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|i
operator|=
name|BPF_MAX_PAGES
operator|*
name|PAGE_SIZE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Ioctl to force rotation of the two buffers, if there's any data available.  * This can be used by user space to implement timeouts when waiting for a  * buffer to fill.  */
end_comment

begin_function
name|int
name|bpf_zerocopy_ioctl_rotzbuf
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|,
name|struct
name|bpf_zbuf
modifier|*
name|bz
parameter_list|)
block|{
name|struct
name|zbuf
modifier|*
name|bzh
decl_stmt|;
name|bzero
argument_list|(
name|bz
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bz
argument_list|)
argument_list|)
expr_stmt|;
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_hbuf
operator|==
name|NULL
operator|&&
name|d
operator|->
name|bd_slen
operator|!=
literal|0
condition|)
block|{
name|ROTATE_BUFFERS
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|bzh
operator|=
operator|(
expr|struct
name|zbuf
operator|*
operator|)
name|d
operator|->
name|bd_hbuf
expr_stmt|;
name|bz
operator|->
name|bz_bufa
operator|=
operator|(
name|void
operator|*
operator|)
name|bzh
operator|->
name|zb_uaddr
expr_stmt|;
name|bz
operator|->
name|bz_buflen
operator|=
name|d
operator|->
name|bd_hlen
expr_stmt|;
block|}
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Ioctl to configure zero-copy buffers -- may be done only once.  */
end_comment

begin_function
name|int
name|bpf_zerocopy_ioctl_setzbuf
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|,
name|struct
name|bpf_zbuf
modifier|*
name|bz
parameter_list|)
block|{
name|struct
name|zbuf
modifier|*
name|zba
decl_stmt|,
modifier|*
name|zbb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|d
operator|->
name|bd_bufmode
operator|==
name|BPF_BUFMODE_ZBUF
argument_list|,
operator|(
literal|"bpf_zerocopy_ioctl_setzbuf: not in zbuf mode"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Must set both buffers.  Cannot clear them. 	 */
if|if
condition|(
name|bz
operator|->
name|bz_bufa
operator|==
name|NULL
operator|||
name|bz
operator|->
name|bz_bufb
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Buffers must have a size greater than 0.  Alignment and other size 	 * validity checking is done in zbuf_setup(). 	 */
if|if
condition|(
name|bz
operator|->
name|bz_buflen
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Allocate new buffers. 	 */
name|error
operator|=
name|zbuf_setup
argument_list|(
name|td
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|bz
operator|->
name|bz_bufa
argument_list|,
name|bz
operator|->
name|bz_buflen
argument_list|,
operator|&
name|zba
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|zbuf_setup
argument_list|(
name|td
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|bz
operator|->
name|bz_bufb
argument_list|,
name|bz
operator|->
name|bz_buflen
argument_list|,
operator|&
name|zbb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|zbuf_free
argument_list|(
name|zba
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * We only allow buffers to be installed once, so atomically check 	 * that no buffers are currently installed and install new buffers. 	 */
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_hbuf
operator|!=
name|NULL
operator|||
name|d
operator|->
name|bd_sbuf
operator|!=
name|NULL
operator|||
name|d
operator|->
name|bd_fbuf
operator|!=
name|NULL
operator|||
name|d
operator|->
name|bd_bif
operator|!=
name|NULL
condition|)
block|{
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|zbuf_free
argument_list|(
name|zba
argument_list|)
expr_stmt|;
name|zbuf_free
argument_list|(
name|zbb
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Point BPF descriptor at buffers; initialize sbuf as zba so that 	 * it is always filled first in the sequence, per bpf(4). 	 */
name|d
operator|->
name|bd_fbuf
operator|=
operator|(
name|caddr_t
operator|)
name|zbb
expr_stmt|;
name|d
operator|->
name|bd_sbuf
operator|=
operator|(
name|caddr_t
operator|)
name|zba
expr_stmt|;
name|d
operator|->
name|bd_slen
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_hlen
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We expose only the space left in the buffer after the size of the 	 * shared management region. 	 */
name|d
operator|->
name|bd_bufsize
operator|=
name|bz
operator|->
name|bz_buflen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|bpf_zbuf_header
argument_list|)
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

