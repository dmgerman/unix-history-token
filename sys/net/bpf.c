begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1990, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from the Stanford/CMU enet packet filter,  * (net/enet.c) distributed as part of 4.3BSD, and code contributed  * to Berkeley by Steven McCanne and Van Jacobson both of Lawrence  * Berkeley Laboratory.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      @(#)bpf.c	8.2 (Berkeley) 3/28/94  *  * $Id: bpf.c,v 1.37 1998/01/24 02:54:37 eivind Exp $  */
end_comment

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUC__
end_ifndef

begin_define
define|#
directive|define
name|inline
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|inline
value|__inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ttycom.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sparc
argument_list|)
operator|&&
name|BSD
operator|<
literal|199103
end_if

begin_include
include|#
directive|include
file|<sys/stream.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|"opt_devfs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DEVFS*/
end_comment

begin_comment
comment|/*  * Older BSDs don't have kernel malloc.  */
end_comment

begin_if
if|#
directive|if
name|BSD
operator|<
literal|199103
end_if

begin_extern
extern|extern bcopy(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|caddr_t
name|bpf_alloc
parameter_list|()
function_decl|;
end_function_decl

begin_include
include|#
directive|include
file|<net/bpf_compat.h>
end_include

begin_define
define|#
directive|define
name|BPF_BUFSIZE
value|(MCLBYTES-8)
end_define

begin_define
define|#
directive|define
name|UIOMOVE
parameter_list|(
name|cp
parameter_list|,
name|len
parameter_list|,
name|code
parameter_list|,
name|uio
parameter_list|)
value|uiomove(cp, len, code, uio)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BPF_BUFSIZE
value|4096
end_define

begin_define
define|#
directive|define
name|UIOMOVE
parameter_list|(
name|cp
parameter_list|,
name|len
parameter_list|,
name|code
parameter_list|,
name|uio
parameter_list|)
value|uiomove(cp, len, uio)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PRINET
value|26
end_define

begin_comment
comment|/* interruptible */
end_comment

begin_comment
comment|/*  * The default read buffer size is patchable.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bpf_bufsize
init|=
name|BPF_BUFSIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|bpf_bufsize
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|bpf_bufsize
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  *  bpf_iflist is the list of interfaces; each corresponds to an ifnet  *  bpf_dtab holds the descriptors, indexed by minor device #  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bpf_if
modifier|*
name|bpf_iflist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bpf_d
name|bpf_dtab
index|[
name|NBPFILTER
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bpf_dtab_init
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bpf_allocbufs
name|__P
argument_list|(
operator|(
expr|struct
name|bpf_d
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bpf_attachd
name|__P
argument_list|(
operator|(
expr|struct
name|bpf_d
operator|*
name|d
operator|,
expr|struct
name|bpf_if
operator|*
name|bp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bpf_detachd
name|__P
argument_list|(
operator|(
expr|struct
name|bpf_d
operator|*
name|d
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bpf_freed
name|__P
argument_list|(
operator|(
expr|struct
name|bpf_d
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bpf_ifname
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
expr|struct
name|ifreq
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bpf_mcopy
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
name|void
operator|*
operator|,
name|u_int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bpf_movein
name|__P
argument_list|(
operator|(
expr|struct
name|uio
operator|*
operator|,
name|int
operator|,
expr|struct
name|mbuf
operator|*
operator|*
operator|,
expr|struct
name|sockaddr
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bpf_setif
name|__P
argument_list|(
operator|(
expr|struct
name|bpf_d
operator|*
operator|,
expr|struct
name|ifreq
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|bpf_wakeup
name|__P
argument_list|(
operator|(
expr|struct
name|bpf_d
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|catchpacket
name|__P
argument_list|(
operator|(
expr|struct
name|bpf_d
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_int
operator|,
name|u_int
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
name|void
operator|*
argument_list|,
name|u_int
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reset_d
name|__P
argument_list|(
operator|(
expr|struct
name|bpf_d
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bpf_setf
name|__P
argument_list|(
operator|(
expr|struct
name|bpf_d
operator|*
operator|,
expr|struct
name|bpf_program
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|bpfopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|bpfclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|bpfread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|bpfwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|bpfioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|bpfpoll
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|23
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|bpf_cdevsw
init|=
block|{
name|bpfopen
block|,
name|bpfclose
block|,
name|bpfread
block|,
name|bpfwrite
block|,
comment|/*23*/
name|bpfioctl
block|,
name|nostop
block|,
name|nullreset
block|,
name|nodevtotty
block|,
comment|/* bpf */
name|bpfpoll
block|,
name|nommap
block|,
name|NULL
block|,
literal|"bpf"
block|,
name|NULL
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|bpf_movein
parameter_list|(
name|uio
parameter_list|,
name|linktype
parameter_list|,
name|mp
parameter_list|,
name|sockp
parameter_list|,
name|datlen
parameter_list|)
specifier|register
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|linktype
decl_stmt|,
decl|*
name|datlen
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|sockaddr
modifier|*
name|sockp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|hlen
decl_stmt|;
comment|/* 	 * Build a sockaddr based on the data link layer type. 	 * We do this at this level because the ethernet header 	 * is copied directly into the data field of the sockaddr. 	 * In the case of SLIP, there is no header and the packet 	 * is forwarded as is. 	 * Also, we are careful to leave room at the front of the mbuf 	 * for the link level header. 	 */
switch|switch
condition|(
name|linktype
condition|)
block|{
case|case
name|DLT_SLIP
case|:
name|sockp
operator|->
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
name|hlen
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DLT_EN10MB
case|:
name|sockp
operator|->
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
comment|/* XXX Would MAXLINKHDR be better? */
name|hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
break|break;
case|case
name|DLT_FDDI
case|:
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__bsdi__
argument_list|)
name|sockp
operator|->
name|sa_family
operator|=
name|AF_IMPLINK
expr_stmt|;
name|hlen
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|sockp
operator|->
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
comment|/* XXX 4(FORMAC)+6(dst)+6(src)+3(LLC)+5(SNAP) */
name|hlen
operator|=
literal|24
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|DLT_NULL
case|:
name|sockp
operator|->
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|hlen
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|len
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
operator|*
name|datlen
operator|=
name|len
operator|-
name|hlen
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|len
operator|>
name|MCLBYTES
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_WAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
if|if
condition|(
name|len
operator|>
name|MHLEN
condition|)
block|{
if|#
directive|if
name|BSD
operator|>=
literal|199103
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
else|#
directive|else
name|MCLGET
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|!=
name|MCLBYTES
condition|)
block|{
endif|#
directive|endif
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
comment|/* 	 * Make room for link header. 	 */
if|if
condition|(
name|hlen
operator|!=
literal|0
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|hlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|hlen
expr_stmt|;
if|#
directive|if
name|BSD
operator|>=
literal|199103
name|m
operator|->
name|m_data
operator|+=
name|hlen
expr_stmt|;
comment|/* XXX */
else|#
directive|else
name|m
operator|->
name|m_off
operator|+=
name|hlen
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|UIOMOVE
argument_list|(
operator|(
name|caddr_t
operator|)
name|sockp
operator|->
name|sa_data
argument_list|,
name|hlen
argument_list|,
name|UIO_WRITE
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
block|}
name|error
operator|=
name|UIOMOVE
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
operator|-
name|hlen
argument_list|,
name|UIO_WRITE
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * Attach file to the bpf interface, i.e. make d listen on bp.  * Must be called at splimp.  */
specifier|static
name|void
name|bpf_attachd
parameter_list|(
name|d
parameter_list|,
name|bp
parameter_list|)
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|;
block|{
comment|/* 	 * Point d at bp, and add d to the interface's list of listeners. 	 * Finally, point the driver's bpf cookie at the interface so 	 * it will divert packets to bpf. 	 */
name|d
operator|->
name|bd_bif
operator|=
name|bp
expr_stmt|;
name|d
operator|->
name|bd_next
operator|=
name|bp
operator|->
name|bif_dlist
expr_stmt|;
name|bp
operator|->
name|bif_dlist
operator|=
name|d
expr_stmt|;
name|bp
operator|->
name|bif_ifp
operator|->
name|if_bpf
operator|=
name|bp
expr_stmt|;
block|}
comment|/*  * Detach a file from its interface.  */
specifier|static
name|void
name|bpf_detachd
parameter_list|(
name|d
parameter_list|)
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
block|{
name|struct
name|bpf_d
modifier|*
modifier|*
name|p
decl_stmt|;
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|d
operator|->
name|bd_bif
expr_stmt|;
comment|/* 	 * Check if this descriptor had requested promiscuous mode. 	 * If so, turn it off. 	 */
if|if
condition|(
name|d
operator|->
name|bd_promisc
condition|)
block|{
name|d
operator|->
name|bd_promisc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifpromisc
argument_list|(
name|bp
operator|->
name|bif_ifp
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* 			 * Something is really wrong if we were able to put 			 * the driver into promiscuous mode, but can't 			 * take it out. 			 */
name|panic
argument_list|(
literal|"bpf: ifpromisc failed"
argument_list|)
expr_stmt|;
block|}
comment|/* Remove d from the interface's descriptor list. */
name|p
operator|=
operator|&
name|bp
operator|->
name|bif_dlist
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|d
condition|)
block|{
name|p
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|bd_next
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"bpf_detachd: descriptor not in list"
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
operator|(
operator|*
name|p
operator|)
operator|->
name|bd_next
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bif_dlist
operator|==
literal|0
condition|)
comment|/* 		 * Let the driver know that there are no more listeners. 		 */
name|d
operator|->
name|bd_bif
operator|->
name|bif_ifp
operator|->
name|if_bpf
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_bif
operator|=
literal|0
expr_stmt|;
block|}
comment|/*  * Mark a descriptor free by making it point to itself.  * This is probably cheaper than marking with a constant since  * the address should be in a register anyway.  */
define|#
directive|define
name|D_ISFREE
parameter_list|(
name|d
parameter_list|)
value|((d) == (d)->bd_next)
define|#
directive|define
name|D_MARKFREE
parameter_list|(
name|d
parameter_list|)
value|((d)->bd_next = (d))
define|#
directive|define
name|D_MARKUSED
parameter_list|(
name|d
parameter_list|)
value|((d)->bd_next = 0)
comment|/*  * Open ethernet device.  Returns ENXIO for illegal minor device number,  * EBUSY if file is open by another process.  */
comment|/* ARGSUSED */
specifier|static
name|int
name|bpfopen
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|,
name|fmt
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|fmt
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|minor
argument_list|(
name|dev
argument_list|)
operator|>=
name|NBPFILTER
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Each minor can be opened by only one process.  If the requested 	 * minor is in use, return EBUSY. 	 */
name|d
operator|=
operator|&
name|bpf_dtab
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|D_ISFREE
argument_list|(
name|d
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Mark "free" and do most initialization. */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|d
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_bufsize
operator|=
name|bpf_bufsize
expr_stmt|;
name|d
operator|->
name|bd_sig
operator|=
name|SIGIO
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Close the descriptor by detaching it from its interface,  * deallocating its buffers, and marking it free.  */
comment|/* ARGSUSED */
specifier|static
name|int
name|bpfclose
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|,
name|fmt
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|fmt
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
init|=
operator|&
name|bpf_dtab
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_bif
condition|)
name|bpf_detachd
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bpf_freed
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Support for SunOS, which does not have tsleep.  */
if|#
directive|if
name|BSD
operator|<
literal|199103
specifier|static
name|bpf_timeout
argument_list|(
argument|arg
argument_list|)
name|caddr_t
name|arg
expr_stmt|;
block|{
name|struct
name|bpf_d
modifier|*
name|d
init|=
operator|(
expr|struct
name|bpf_d
operator|*
operator|)
name|arg
decl_stmt|;
name|d
operator|->
name|bd_timedout
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|BPF_SLEEP
parameter_list|(
name|chan
parameter_list|,
name|pri
parameter_list|,
name|s
parameter_list|,
name|t
parameter_list|)
value|bpf_sleep((struct bpf_d *)chan)
name|int
name|bpf_sleep
parameter_list|(
name|d
parameter_list|)
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
block|{
specifier|register
name|int
name|rto
init|=
name|d
operator|->
name|bd_rtout
decl_stmt|;
specifier|register
name|int
name|st
decl_stmt|;
if|if
condition|(
name|rto
operator|!=
literal|0
condition|)
block|{
name|d
operator|->
name|bd_timedout
operator|=
literal|0
expr_stmt|;
name|timeout
argument_list|(
name|bpf_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|d
argument_list|,
name|rto
argument_list|)
expr_stmt|;
block|}
name|st
operator|=
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|d
argument_list|,
name|PRINET
operator||
name|PCATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|rto
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|bd_timedout
operator|==
literal|0
condition|)
name|untimeout
argument_list|(
name|bpf_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|st
operator|==
literal|0
condition|)
return|return
name|EWOULDBLOCK
return|;
block|}
return|return
operator|(
name|st
operator|!=
literal|0
operator|)
condition|?
name|EINTR
else|:
literal|0
return|;
block|}
else|#
directive|else
define|#
directive|define
name|BPF_SLEEP
value|tsleep
endif|#
directive|endif
comment|/*  * Rotate the packet buffers in descriptor d.  Move the store buffer  * into the hold slot, and the free buffer into the store slot.  * Zero the length of the new store buffer.  */
define|#
directive|define
name|ROTATE_BUFFERS
parameter_list|(
name|d
parameter_list|)
define|\
value|(d)->bd_hbuf = (d)->bd_sbuf; \ 	(d)->bd_hlen = (d)->bd_slen; \ 	(d)->bd_sbuf = (d)->bd_fbuf; \ 	(d)->bd_slen = 0; \ 	(d)->bd_fbuf = 0;
comment|/*  *  bpfread - read next chunk of packets from buffers  */
specifier|static
name|int
name|bpfread
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|ioflag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
specifier|register
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|ioflag
decl_stmt|;
block|{
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
init|=
operator|&
name|bpf_dtab
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Restrict application to use a buffer the same size as 	 * as kernel buffers. 	 */
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|!=
name|d
operator|->
name|bd_bufsize
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * If the hold buffer is empty, then do a timed sleep, which 	 * ends when the timeout expires or when enough packets 	 * have arrived to fill the store buffer. 	 */
while|while
condition|(
name|d
operator|->
name|bd_hbuf
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|bd_immediate
operator|&&
name|d
operator|->
name|bd_slen
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * A packet(s) either arrived since the previous 			 * read or arrived while we were asleep. 			 * Rotate the buffers and return what's here. 			 */
name|ROTATE_BUFFERS
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ioflag
operator|&
name|IO_NDELAY
condition|)
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
else|else
name|error
operator|=
name|BPF_SLEEP
argument_list|(
operator|(
name|caddr_t
operator|)
name|d
argument_list|,
name|PRINET
operator||
name|PCATCH
argument_list|,
literal|"bpf"
argument_list|,
name|d
operator|->
name|bd_rtout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|ERESTART
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
block|{
comment|/* 			 * On a timeout, return what's in the buffer, 			 * which may be nothing.  If there is something 			 * in the store buffer, we can rotate the buffers. 			 */
if|if
condition|(
name|d
operator|->
name|bd_hbuf
condition|)
comment|/* 				 * We filled up the buffer in between 				 * getting the timeout and arriving 				 * here, so we don't need to rotate. 				 */
break|break;
if|if
condition|(
name|d
operator|->
name|bd_slen
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ROTATE_BUFFERS
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * At this point, we know we have something in the hold slot. 	 */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Move data from hold buffer into user space. 	 * We know the entire buffer is transferred since 	 * we checked above that the read buffer is bpf_bufsize bytes. 	 */
name|error
operator|=
name|UIOMOVE
argument_list|(
name|d
operator|->
name|bd_hbuf
argument_list|,
name|d
operator|->
name|bd_hlen
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|d
operator|->
name|bd_fbuf
operator|=
name|d
operator|->
name|bd_hbuf
expr_stmt|;
name|d
operator|->
name|bd_hbuf
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_hlen
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * If there are processes sleeping on this descriptor, wake them up.  */
specifier|static
specifier|inline
name|void
name|bpf_wakeup
parameter_list|(
name|d
parameter_list|)
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_async
operator|&&
name|d
operator|->
name|bd_sig
condition|)
if|if
condition|(
name|d
operator|->
name|bd_pgid
operator|>
literal|0
condition|)
name|gsignal
argument_list|(
name|d
operator|->
name|bd_pgid
argument_list|,
name|d
operator|->
name|bd_sig
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|=
name|pfind
argument_list|(
operator|-
name|d
operator|->
name|bd_pgid
argument_list|)
condition|)
name|psignal
argument_list|(
name|p
argument_list|,
name|d
operator|->
name|bd_sig
argument_list|)
expr_stmt|;
if|#
directive|if
name|BSD
operator|>=
literal|199103
name|selwakeup
argument_list|(
operator|&
name|d
operator|->
name|bd_sel
argument_list|)
expr_stmt|;
comment|/* XXX */
name|d
operator|->
name|bd_sel
operator|.
name|si_pid
operator|=
literal|0
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|d
operator|->
name|bd_selproc
condition|)
block|{
name|selwakeup
argument_list|(
name|d
operator|->
name|bd_selproc
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|bd_selcoll
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_selcoll
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_selproc
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
specifier|static
name|int
name|bpfwrite
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|ioflag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|ioflag
decl_stmt|;
block|{
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
init|=
operator|&
name|bpf_dtab
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
specifier|static
name|struct
name|sockaddr
name|dst
decl_stmt|;
name|int
name|datlen
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ifp
operator|=
name|d
operator|->
name|bd_bif
operator|->
name|bif_ifp
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|bpf_movein
argument_list|(
name|uio
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|bd_bif
operator|->
name|bif_dlt
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|dst
argument_list|,
operator|&
name|datlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|datlen
operator|>
name|ifp
operator|->
name|if_mtu
condition|)
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|#
directive|if
name|BSD
operator|>=
literal|199103
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
operator|&
name|dst
argument_list|,
operator|(
expr|struct
name|rtentry
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * The driver frees the mbuf. 	 */
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * Reset a descriptor by flushing its packet buffer and clearing the  * receive and drop counts.  Should be called at splimp.  */
specifier|static
name|void
name|reset_d
parameter_list|(
name|d
parameter_list|)
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
block|{
if|if
condition|(
name|d
operator|->
name|bd_hbuf
condition|)
block|{
comment|/* Free the hold buffer. */
name|d
operator|->
name|bd_fbuf
operator|=
name|d
operator|->
name|bd_hbuf
expr_stmt|;
name|d
operator|->
name|bd_hbuf
operator|=
literal|0
expr_stmt|;
block|}
name|d
operator|->
name|bd_slen
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_hlen
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_rcount
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_dcount
operator|=
literal|0
expr_stmt|;
block|}
comment|/*  *  FIONREAD		Check for read packet available.  *  SIOCGIFADDR		Get interface address - convenient hook to driver.  *  BIOCGBLEN		Get buffer len [for read()].  *  BIOCSETF		Set ethernet read filter.  *  BIOCFLUSH		Flush read packet buffer.  *  BIOCPROMISC		Put interface into promiscuous mode.  *  BIOCGDLT		Get link layer type.  *  BIOCGETIF		Get interface name.  *  BIOCSETIF		Set interface.  *  BIOCSRTIMEOUT	Set read timeout.  *  BIOCGRTIMEOUT	Get read timeout.  *  BIOCGSTATS		Get packet stats.  *  BIOCIMMEDIATE	Set immediate mode.  *  BIOCVERSION		Get filter language version.  */
comment|/* ARGSUSED */
specifier|static
name|int
name|bpfioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|addr
parameter_list|,
name|flags
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
init|=
operator|&
name|bpf_dtab
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
comment|/* 	 * Check for read packet available. 	 */
case|case
name|FIONREAD
case|:
block|{
name|int
name|n
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|n
operator|=
name|d
operator|->
name|bd_slen
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_hbuf
condition|)
name|n
operator|+=
name|d
operator|->
name|bd_hlen
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|n
expr_stmt|;
break|break;
block|}
case|case
name|SIOCGIFADDR
case|:
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|ifp
operator|=
name|d
operator|->
name|bd_bif
operator|->
name|bif_ifp
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_ioctl
call|)
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* 	 * Get buffer len [for read()]. 	 */
case|case
name|BIOCGBLEN
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
operator|=
name|d
operator|->
name|bd_bufsize
expr_stmt|;
break|break;
comment|/* 	 * Set buffer length. 	 */
case|case
name|BIOCSBLEN
case|:
if|#
directive|if
name|BSD
operator|<
literal|199103
name|error
operator|=
name|EINVAL
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|!=
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
specifier|register
name|u_int
name|size
init|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|BPF_MAXBUFSIZE
condition|)
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
operator|=
name|size
operator|=
name|BPF_MAXBUFSIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|<
name|BPF_MINBUFSIZE
condition|)
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
operator|=
name|size
operator|=
name|BPF_MINBUFSIZE
expr_stmt|;
name|d
operator|->
name|bd_bufsize
operator|=
name|size
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
comment|/* 	 * Set link layer read filter. 	 */
case|case
name|BIOCSETF
case|:
name|error
operator|=
name|bpf_setf
argument_list|(
name|d
argument_list|,
operator|(
expr|struct
name|bpf_program
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Flush read packet buffer. 	 */
case|case
name|BIOCFLUSH
case|:
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|reset_d
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Put interface into promiscuous mode. 	 */
case|case
name|BIOCPROMISC
case|:
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
literal|0
condition|)
block|{
comment|/* 			 * No interface attached yet. 			 */
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_promisc
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ifpromisc
argument_list|(
name|d
operator|->
name|bd_bif
operator|->
name|bif_ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|d
operator|->
name|bd_promisc
operator|=
literal|1
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Get device parameters. 	 */
case|case
name|BIOCGDLT
case|:
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
operator|=
name|d
operator|->
name|bd_bif
operator|->
name|bif_dlt
expr_stmt|;
break|break;
comment|/* 	 * Set interface name. 	 */
case|case
name|BIOCGETIF
case|:
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|bpf_ifname
argument_list|(
name|d
operator|->
name|bd_bif
operator|->
name|bif_ifp
argument_list|,
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set interface. 	 */
case|case
name|BIOCSETIF
case|:
name|error
operator|=
name|bpf_setif
argument_list|(
name|d
argument_list|,
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set read timeout. 	 */
case|case
name|BIOCSRTIMEOUT
case|:
block|{
name|struct
name|timeval
modifier|*
name|tv
init|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|addr
decl_stmt|;
name|u_long
name|msec
decl_stmt|;
comment|/* Compute number of milliseconds. */
name|msec
operator|=
name|tv
operator|->
name|tv_sec
operator|*
literal|1000
operator|+
name|tv
operator|->
name|tv_usec
operator|/
literal|1000
expr_stmt|;
comment|/* Scale milliseconds to ticks.  Assume hard 			   clock has millisecond or greater resolution 			   (i.e. tick>= 1000).  For 10ms hardclock, 			   tick/1000 = 10, so rtout<-msec/10. */
name|d
operator|->
name|bd_rtout
operator|=
name|msec
operator|/
operator|(
name|tick
operator|/
literal|1000
operator|)
expr_stmt|;
break|break;
block|}
comment|/* 	 * Get read timeout. 	 */
case|case
name|BIOCGRTIMEOUT
case|:
block|{
name|struct
name|timeval
modifier|*
name|tv
init|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|addr
decl_stmt|;
name|u_long
name|msec
init|=
name|d
operator|->
name|bd_rtout
decl_stmt|;
name|msec
operator|*=
name|tick
operator|/
literal|1000
expr_stmt|;
name|tv
operator|->
name|tv_sec
operator|=
name|msec
operator|/
literal|1000
expr_stmt|;
name|tv
operator|->
name|tv_usec
operator|=
name|msec
operator|%
literal|1000
expr_stmt|;
break|break;
block|}
comment|/* 	 * Get packet stats. 	 */
case|case
name|BIOCGSTATS
case|:
block|{
name|struct
name|bpf_stat
modifier|*
name|bs
init|=
operator|(
expr|struct
name|bpf_stat
operator|*
operator|)
name|addr
decl_stmt|;
name|bs
operator|->
name|bs_recv
operator|=
name|d
operator|->
name|bd_rcount
expr_stmt|;
name|bs
operator|->
name|bs_drop
operator|=
name|d
operator|->
name|bd_dcount
expr_stmt|;
break|break;
block|}
comment|/* 	 * Set immediate mode. 	 */
case|case
name|BIOCIMMEDIATE
case|:
name|d
operator|->
name|bd_immediate
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
name|BIOCVERSION
case|:
block|{
name|struct
name|bpf_version
modifier|*
name|bv
init|=
operator|(
expr|struct
name|bpf_version
operator|*
operator|)
name|addr
decl_stmt|;
name|bv
operator|->
name|bv_major
operator|=
name|BPF_MAJOR_VERSION
expr_stmt|;
name|bv
operator|->
name|bv_minor
operator|=
name|BPF_MINOR_VERSION
expr_stmt|;
break|break;
block|}
case|case
name|FIONBIO
case|:
comment|/* Non-blocking I/O */
break|break;
case|case
name|FIOASYNC
case|:
comment|/* Send signal on receive packets */
name|d
operator|->
name|bd_async
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
comment|/* N.B.  ioctl (FIOSETOWN) and fcntl (F_SETOWN) both end up doing the    equivalent of a TIOCSPGRP and hence end up here.  *However* TIOCSPGRP's arg    is a process group if it's positive and a process id if it's negative.  This    is exactly the opposite of what the other two functions want!  Therefore    there is code in ioctl and fcntl to negate the arg before calling here. */
case|case
name|TIOCSPGRP
case|:
comment|/* Process or group to send signals to */
name|d
operator|->
name|bd_pgid
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
name|TIOCGPGRP
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|d
operator|->
name|bd_pgid
expr_stmt|;
break|break;
case|case
name|BIOCSRSIG
case|:
comment|/* Set receive signal */
block|{
name|u_int
name|sig
decl_stmt|;
name|sig
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|sig
operator|>=
name|NSIG
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|d
operator|->
name|bd_sig
operator|=
name|sig
expr_stmt|;
break|break;
block|}
case|case
name|BIOCGRSIG
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
operator|=
name|d
operator|->
name|bd_sig
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * Set d's packet filter program to fp.  If this file already has a filter,  * free it and replace it.  Returns EINVAL for bogus requests.  */
specifier|static
name|int
name|bpf_setf
parameter_list|(
name|d
parameter_list|,
name|fp
parameter_list|)
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
name|struct
name|bpf_program
modifier|*
name|fp
decl_stmt|;
block|{
name|struct
name|bpf_insn
modifier|*
name|fcode
decl_stmt|,
modifier|*
name|old
decl_stmt|;
name|u_int
name|flen
decl_stmt|,
name|size
decl_stmt|;
name|int
name|s
decl_stmt|;
name|old
operator|=
name|d
operator|->
name|bd_filter
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|bf_insns
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|bf_len
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|d
operator|->
name|bd_filter
operator|=
literal|0
expr_stmt|;
name|reset_d
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|!=
literal|0
condition|)
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|old
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|flen
operator|=
name|fp
operator|->
name|bf_len
expr_stmt|;
if|if
condition|(
name|flen
operator|>
name|BPF_MAXINSNS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|size
operator|=
name|flen
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|fp
operator|->
name|bf_insns
argument_list|)
expr_stmt|;
name|fcode
operator|=
operator|(
expr|struct
name|bpf_insn
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|fp
operator|->
name|bf_insns
argument_list|,
operator|(
name|caddr_t
operator|)
name|fcode
argument_list|,
name|size
argument_list|)
operator|==
literal|0
operator|&&
name|bpf_validate
argument_list|(
name|fcode
argument_list|,
operator|(
name|int
operator|)
name|flen
argument_list|)
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|d
operator|->
name|bd_filter
operator|=
name|fcode
expr_stmt|;
name|reset_d
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|!=
literal|0
condition|)
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|old
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|fcode
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/*  * Detach a file from its current interface (if attached at all) and attach  * to the interface indicated by the name stored in ifr.  * Return an errno or 0.  */
specifier|static
name|int
name|bpf_setif
parameter_list|(
name|d
parameter_list|,
name|ifr
parameter_list|)
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
block|{
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|theywant
decl_stmt|;
name|theywant
operator|=
name|ifunit
argument_list|(
name|ifr
operator|->
name|ifr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|theywant
operator|==
literal|0
condition|)
return|return
name|ENXIO
return|;
comment|/* 	 * Look through attached interfaces for the named one. 	 */
for|for
control|(
name|bp
operator|=
name|bpf_iflist
init|;
name|bp
operator|!=
literal|0
condition|;
name|bp
operator|=
name|bp
operator|->
name|bif_next
control|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|bp
operator|->
name|bif_ifp
decl_stmt|;
if|if
condition|(
name|ifp
operator|==
literal|0
operator|||
name|ifp
operator|!=
name|theywant
condition|)
continue|continue;
comment|/* 		 * We found the requested interface. 		 * If it's not up, return an error. 		 * Allocate the packet buffers if we need to. 		 * If we're already attached to requested interface, 		 * just flush the buffer. 		 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENETDOWN
operator|)
return|;
if|if
condition|(
name|d
operator|->
name|bd_sbuf
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|bpf_allocbufs
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|d
operator|->
name|bd_bif
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|bd_bif
condition|)
comment|/* 				 * Detach if attached to something else. 				 */
name|bpf_detachd
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|bpf_attachd
argument_list|(
name|d
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
name|reset_d
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Not found. */
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/*  * Convert an interface name plus unit number of an ifp to a single  * name which is returned in the ifr.  */
specifier|static
name|void
name|bpf_ifname
parameter_list|(
name|ifp
parameter_list|,
name|ifr
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
block|{
name|char
modifier|*
name|s
init|=
name|ifp
operator|->
name|if_name
decl_stmt|;
name|char
modifier|*
name|d
init|=
name|ifr
operator|->
name|ifr_name
decl_stmt|;
while|while
condition|(
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
condition|)
continue|continue;
name|d
operator|--
expr_stmt|;
comment|/* back to the null */
comment|/* XXX Assume that unit number is less than 10. */
operator|*
name|d
operator|++
operator|=
name|ifp
operator|->
name|if_unit
operator|+
literal|'0'
expr_stmt|;
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/*  * Support for select() and poll() system calls  *  * Return true iff the specific operation will not block indefinitely.  * Otherwise, return false but make a note that a selwakeup() must be done.  */
name|int
name|bpfpoll
parameter_list|(
name|dev
parameter_list|,
name|events
parameter_list|,
name|p
parameter_list|)
specifier|register
name|dev_t
name|dev
decl_stmt|;
name|int
name|events
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
comment|/* 	 * An imitation of the FIONREAD ioctl code. 	 */
name|d
operator|=
operator|&
name|bpf_dtab
index|[
name|minor
argument_list|(
name|dev
argument_list|)
index|]
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
if|if
condition|(
name|d
operator|->
name|bd_hlen
operator|!=
literal|0
operator|||
operator|(
name|d
operator|->
name|bd_immediate
operator|&&
name|d
operator|->
name|bd_slen
operator|!=
literal|0
operator|)
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
else|else
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|d
operator|->
name|bd_sel
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
comment|/*  * Incoming linkage from device drivers.  Process the packet pkt, of length  * pktlen, which is stored in a contiguous buffer.  The packet is parsed  * by each process' filter, and if accepted, stashed into the corresponding  * buffer.  */
name|void
name|bpf_tap
parameter_list|(
name|ifp
parameter_list|,
name|pkt
parameter_list|,
name|pktlen
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|pkt
decl_stmt|;
specifier|register
name|u_int
name|pktlen
decl_stmt|;
block|{
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
specifier|register
name|u_int
name|slen
decl_stmt|;
comment|/* 	 * Note that the ipl does not have to be raised at this point. 	 * The only problem that could arise here is that if two different 	 * interfaces shared any data.  This is not the case. 	 */
name|bp
operator|=
name|ifp
operator|->
name|if_bpf
expr_stmt|;
for|for
control|(
name|d
operator|=
name|bp
operator|->
name|bif_dlist
init|;
name|d
operator|!=
literal|0
condition|;
name|d
operator|=
name|d
operator|->
name|bd_next
control|)
block|{
operator|++
name|d
operator|->
name|bd_rcount
expr_stmt|;
name|slen
operator|=
name|bpf_filter
argument_list|(
name|d
operator|->
name|bd_filter
argument_list|,
name|pkt
argument_list|,
name|pktlen
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|!=
literal|0
condition|)
name|catchpacket
argument_list|(
name|d
argument_list|,
name|pkt
argument_list|,
name|pktlen
argument_list|,
name|slen
argument_list|,
name|bcopy
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * Copy data from an mbuf chain into a buffer.  This code is derived  * from m_copydata in sys/uipc_mbuf.c.  */
specifier|static
name|void
name|bpf_mcopy
parameter_list|(
name|src_arg
parameter_list|,
name|dst_arg
parameter_list|,
name|len
parameter_list|)
specifier|const
name|void
modifier|*
name|src_arg
decl_stmt|;
name|void
modifier|*
name|dst_arg
decl_stmt|;
specifier|register
name|u_int
name|len
decl_stmt|;
block|{
specifier|register
specifier|const
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|u_int
name|count
decl_stmt|;
name|u_char
modifier|*
name|dst
decl_stmt|;
name|m
operator|=
name|src_arg
expr_stmt|;
name|dst
operator|=
name|dst_arg
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"bpf_mcopy"
argument_list|)
expr_stmt|;
name|count
operator|=
name|min
argument_list|(
name|m
operator|->
name|m_len
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|dst
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|dst
operator|+=
name|count
expr_stmt|;
name|len
operator|-=
name|count
expr_stmt|;
block|}
block|}
comment|/*  * Incoming linkage from device drivers, when packet is in an mbuf chain.  */
name|void
name|bpf_mtap
parameter_list|(
name|ifp
parameter_list|,
name|m
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|bpf_if
modifier|*
name|bp
init|=
name|ifp
operator|->
name|if_bpf
decl_stmt|;
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
name|u_int
name|pktlen
decl_stmt|,
name|slen
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|pktlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m0
operator|=
name|m
init|;
name|m0
operator|!=
literal|0
condition|;
name|m0
operator|=
name|m0
operator|->
name|m_next
control|)
name|pktlen
operator|+=
name|m0
operator|->
name|m_len
expr_stmt|;
for|for
control|(
name|d
operator|=
name|bp
operator|->
name|bif_dlist
init|;
name|d
operator|!=
literal|0
condition|;
name|d
operator|=
name|d
operator|->
name|bd_next
control|)
block|{
operator|++
name|d
operator|->
name|bd_rcount
expr_stmt|;
name|slen
operator|=
name|bpf_filter
argument_list|(
name|d
operator|->
name|bd_filter
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|m
argument_list|,
name|pktlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|!=
literal|0
condition|)
name|catchpacket
argument_list|(
name|d
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|m
argument_list|,
name|pktlen
argument_list|,
name|slen
argument_list|,
name|bpf_mcopy
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * Move the packet data from interface memory (pkt) into the  * store buffer.  Return 1 if it's time to wakeup a listener (buffer full),  * otherwise 0.  "copy" is the routine called to do the actual data  * transfer.  bcopy is passed in to copy contiguous chunks, while  * bpf_mcopy is passed in to copy mbuf chains.  In the latter case,  * pkt is really an mbuf.  */
specifier|static
name|void
name|catchpacket
argument_list|(
name|d
argument_list|,
name|pkt
argument_list|,
name|pktlen
argument_list|,
name|snaplen
argument_list|,
name|cpfn
argument_list|)
decl|register struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|pkt
decl_stmt|;
specifier|register
name|u_int
name|pktlen
decl_stmt|,
name|snaplen
decl_stmt|;
specifier|register
name|void
argument_list|(
argument|*cpfn
argument_list|)
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
name|void
operator|*
operator|,
name|u_int
operator|)
argument_list|)
expr_stmt|;
block|{
specifier|register
name|struct
name|bpf_hdr
modifier|*
name|hp
decl_stmt|;
specifier|register
name|int
name|totlen
decl_stmt|,
name|curlen
decl_stmt|;
specifier|register
name|int
name|hdrlen
init|=
name|d
operator|->
name|bd_bif
operator|->
name|bif_hdrlen
decl_stmt|;
comment|/* 	 * Figure out how many bytes to move.  If the packet is 	 * greater or equal to the snapshot length, transfer that 	 * much.  Otherwise, transfer the whole packet (unless 	 * we hit the buffer size limit). 	 */
name|totlen
operator|=
name|hdrlen
operator|+
name|min
argument_list|(
name|snaplen
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|totlen
operator|>
name|d
operator|->
name|bd_bufsize
condition|)
name|totlen
operator|=
name|d
operator|->
name|bd_bufsize
expr_stmt|;
comment|/* 	 * Round up the end of the previous packet to the next longword. 	 */
name|curlen
operator|=
name|BPF_WORDALIGN
argument_list|(
name|d
operator|->
name|bd_slen
argument_list|)
expr_stmt|;
if|if
condition|(
name|curlen
operator|+
name|totlen
operator|>
name|d
operator|->
name|bd_bufsize
condition|)
block|{
comment|/* 		 * This packet will overflow the storage buffer. 		 * Rotate the buffers if we can, then wakeup any 		 * pending reads. 		 */
if|if
condition|(
name|d
operator|->
name|bd_fbuf
operator|==
literal|0
condition|)
block|{
comment|/* 			 * We haven't completed the previous read yet, 			 * so drop the packet. 			 */
operator|++
name|d
operator|->
name|bd_dcount
expr_stmt|;
return|return;
block|}
name|ROTATE_BUFFERS
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|bpf_wakeup
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|curlen
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|bd_immediate
condition|)
comment|/* 		 * Immediate mode is set.  A packet arrived so any 		 * reads should be woken up. 		 */
name|bpf_wakeup
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* 	 * Append the bpf header. 	 */
name|hp
operator|=
operator|(
expr|struct
name|bpf_hdr
operator|*
operator|)
operator|(
name|d
operator|->
name|bd_sbuf
operator|+
name|curlen
operator|)
expr_stmt|;
if|#
directive|if
name|BSD
operator|>=
literal|199103
name|microtime
argument_list|(
operator|&
name|hp
operator|->
name|bh_tstamp
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|sun
argument_list|)
name|uniqtime
argument_list|(
operator|&
name|hp
operator|->
name|bh_tstamp
argument_list|)
expr_stmt|;
else|#
directive|else
name|hp
operator|->
name|bh_tstamp
operator|=
name|time
expr_stmt|;
endif|#
directive|endif
name|hp
operator|->
name|bh_datalen
operator|=
name|pktlen
expr_stmt|;
name|hp
operator|->
name|bh_hdrlen
operator|=
name|hdrlen
expr_stmt|;
comment|/* 	 * Copy the packet data into the store buffer and update its length. 	 */
call|(
modifier|*
name|cpfn
call|)
argument_list|(
name|pkt
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|hp
operator|+
name|hdrlen
argument_list|,
operator|(
name|hp
operator|->
name|bh_caplen
operator|=
name|totlen
operator|-
name|hdrlen
operator|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_slen
operator|=
name|curlen
operator|+
name|totlen
expr_stmt|;
block|}
comment|/*  * Initialize all nonzero fields of a descriptor.  */
specifier|static
name|int
name|bpf_allocbufs
parameter_list|(
name|d
parameter_list|)
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
block|{
name|d
operator|->
name|bd_fbuf
operator|=
operator|(
name|caddr_t
operator|)
name|malloc
argument_list|(
name|d
operator|->
name|bd_bufsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_fbuf
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|d
operator|->
name|bd_sbuf
operator|=
operator|(
name|caddr_t
operator|)
name|malloc
argument_list|(
name|d
operator|->
name|bd_bufsize
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_sbuf
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|d
operator|->
name|bd_fbuf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|d
operator|->
name|bd_slen
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_hlen
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Free buffers currently in use by a descriptor.  * Called on close.  */
specifier|static
name|void
name|bpf_freed
parameter_list|(
name|d
parameter_list|)
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
block|{
comment|/* 	 * We don't need to lock out interrupts since this descriptor has 	 * been detached from its interface and it yet hasn't been marked 	 * free. 	 */
if|if
condition|(
name|d
operator|->
name|bd_sbuf
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|d
operator|->
name|bd_sbuf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_hbuf
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|d
operator|->
name|bd_hbuf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_fbuf
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|d
operator|->
name|bd_fbuf
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|bd_filter
condition|)
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|d
operator|->
name|bd_filter
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|D_MARKFREE
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
comment|/*  * Attach an interface to bpf.  driverp is a pointer to a (struct bpf_if *)  * in the driver's softc; dlt is the link layer type; hdrlen is the fixed  * size of the link header (variable length headers not yet supported).  */
name|void
name|bpfattach
parameter_list|(
name|ifp
parameter_list|,
name|dlt
parameter_list|,
name|hdrlen
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int
name|dlt
decl_stmt|,
name|hdrlen
decl_stmt|;
block|{
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bp
operator|=
operator|(
expr|struct
name|bpf_if
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bp
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"bpfattach"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bif_dlist
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bif_ifp
operator|=
name|ifp
expr_stmt|;
name|bp
operator|->
name|bif_dlt
operator|=
name|dlt
expr_stmt|;
name|bp
operator|->
name|bif_next
operator|=
name|bpf_iflist
expr_stmt|;
name|bpf_iflist
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|bif_ifp
operator|->
name|if_bpf
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Compute the length of the bpf header.  This is not necessarily 	 * equal to SIZEOF_BPF_HDR because we want to insert spacing such 	 * that the network layer header begins on a longword boundary (for 	 * performance reasons and to alleviate alignment restrictions). 	 */
name|bp
operator|->
name|bif_hdrlen
operator|=
name|BPF_WORDALIGN
argument_list|(
name|hdrlen
operator|+
name|SIZEOF_BPF_HDR
argument_list|)
operator|-
name|hdrlen
expr_stmt|;
comment|/* 	 * Mark all the descriptors free if this hasn't been done. 	 */
if|if
condition|(
operator|!
name|bpf_dtab_init
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBPFILTER
condition|;
operator|++
name|i
control|)
name|D_MARKFREE
argument_list|(
operator|&
name|bpf_dtab
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bpf_dtab_init
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"bpf: %s%d attached\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEVFS
specifier|static
name|void
modifier|*
name|bpf_devfs_token
index|[
name|NBPFILTER
index|]
decl_stmt|;
endif|#
directive|endif
specifier|static
name|int
name|bpf_devsw_installed
decl_stmt|;
specifier|static
name|void
name|bpf_drvinit
name|__P
argument_list|(
operator|(
name|void
operator|*
name|unused
operator|)
argument_list|)
decl_stmt|;
specifier|static
name|void
name|bpf_drvinit
parameter_list|(
name|unused
parameter_list|)
name|void
modifier|*
name|unused
decl_stmt|;
block|{
name|dev_t
name|dev
decl_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|int
name|i
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|bpf_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|bpf_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bpf_devsw_installed
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBPFILTER
condition|;
name|i
operator|++
control|)
block|{
name|bpf_devfs_token
index|[
name|i
index|]
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|bpf_cdevsw
argument_list|,
name|i
argument_list|,
name|DV_CHR
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0600
argument_list|,
literal|"bpf%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
name|SYSINIT
argument_list|(
argument|bpfdev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|bpf_drvinit
argument_list|,
argument|NULL
argument_list|)
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

