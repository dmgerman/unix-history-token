begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from the Stanford/CMU enet packet filter,  * (net/enet.c) distributed as part of 4.3BSD, and code contributed  * to Berkeley by Steven McCanne and Van Jacobson both of Lawrence  * Berkeley Laboratory.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      @(#)bpf.c	8.4 (Berkeley) 1/9/95  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_bpf.h"
end_include

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_netgraph.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ttycom.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/event.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_define
define|#
directive|define
name|BPF_INTERNAL
end_define

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf_buffer.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BPF_JITTER
end_ifdef

begin_include
include|#
directive|include
file|<net/bpf_jitter.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf_zerocopy.h>
end_include

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_freebsd.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_BPF
argument_list|,
literal|"BPF"
argument_list|,
literal|"BPF data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|DEV_BPF
argument_list|)
operator|||
name|defined
argument_list|(
name|NETGRAPH_BPF
argument_list|)
end_if

begin_define
define|#
directive|define
name|PRINET
value|26
end_define

begin_comment
comment|/* interruptible */
end_comment

begin_define
define|#
directive|define
name|SIZEOF_BPF_HDR
parameter_list|(
name|type
parameter_list|)
define|\
value|(offsetof(type, bh_hdrlen) + sizeof(((type *)0)->bh_hdrlen))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
end_ifdef

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<compat/freebsd32/freebsd32.h>
end_include

begin_define
define|#
directive|define
name|BPF_ALIGNMENT32
value|sizeof(int32_t)
end_define

begin_define
define|#
directive|define
name|BPF_WORDALIGN32
parameter_list|(
name|x
parameter_list|)
value|(((x)+(BPF_ALIGNMENT32-1))&~(BPF_ALIGNMENT32-1))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|BURN_BRIDGES
end_ifndef

begin_comment
comment|/*  * 32-bit version of structure prepended to each packet.  We use this header  * instead of the standard one for 32-bit streams.  We mark the a stream as  * 32-bit the first time we see a 32-bit compat ioctl request.  */
end_comment

begin_struct
struct|struct
name|bpf_hdr32
block|{
name|struct
name|timeval32
name|bh_tstamp
decl_stmt|;
comment|/* time stamp */
name|uint32_t
name|bh_caplen
decl_stmt|;
comment|/* length of captured portion */
name|uint32_t
name|bh_datalen
decl_stmt|;
comment|/* original length of packet */
name|uint16_t
name|bh_hdrlen
decl_stmt|;
comment|/* length of bpf header (this struct 					   plus alignment padding) */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|bpf_program32
block|{
name|u_int
name|bf_len
decl_stmt|;
name|uint32_t
name|bf_insns
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|bpf_dltlist32
block|{
name|u_int
name|bfl_len
decl_stmt|;
name|u_int
name|bfl_list
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|BIOCSETF32
value|_IOW('B', 103, struct bpf_program32)
end_define

begin_define
define|#
directive|define
name|BIOCSRTIMEOUT32
value|_IOW('B', 109, struct timeval32)
end_define

begin_define
define|#
directive|define
name|BIOCGRTIMEOUT32
value|_IOR('B', 110, struct timeval32)
end_define

begin_define
define|#
directive|define
name|BIOCGDLTLIST32
value|_IOWR('B', 121, struct bpf_dltlist32)
end_define

begin_define
define|#
directive|define
name|BIOCSETWF32
value|_IOW('B', 123, struct bpf_program32)
end_define

begin_define
define|#
directive|define
name|BIOCSETFNR32
value|_IOW('B', 130, struct bpf_program32)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * bpf_iflist is a list of BPF interface structures, each corresponding to a  * specific DLT.  The same network interface might have several BPF interface  * structures registered by different layers in the stack (i.e., 802.11  * frames, ethernet frames, etc).  */
end_comment

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|bpf_if
argument_list|)
name|bpf_iflist
operator|,
name|bpf_freelist
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|bpf_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* bpf global lock */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bpf_bpfd_cnt
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|bpf_attachd
parameter_list|(
name|struct
name|bpf_d
modifier|*
parameter_list|,
name|struct
name|bpf_if
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bpf_detachd
parameter_list|(
name|struct
name|bpf_d
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bpf_detachd_locked
parameter_list|(
name|struct
name|bpf_d
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bpf_freed
parameter_list|(
name|struct
name|bpf_d
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bpf_movein
parameter_list|(
name|struct
name|uio
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|bpf_insn
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bpf_setif
parameter_list|(
name|struct
name|bpf_d
modifier|*
parameter_list|,
name|struct
name|ifreq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bpf_timed_out
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|bpf_wakeup
parameter_list|(
name|struct
name|bpf_d
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|catchpacket
parameter_list|(
name|struct
name|bpf_d
modifier|*
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|struct
name|bpf_d
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|u_int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|u_int
parameter_list|)
parameter_list|,
name|struct
name|bintime
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|reset_d
parameter_list|(
name|struct
name|bpf_d
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bpf_setf
parameter_list|(
name|struct
name|bpf_d
modifier|*
parameter_list|,
name|struct
name|bpf_program
modifier|*
parameter_list|,
name|u_long
name|cmd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bpf_getdltlist
parameter_list|(
name|struct
name|bpf_d
modifier|*
parameter_list|,
name|struct
name|bpf_dltlist
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bpf_setdlt
parameter_list|(
name|struct
name|bpf_d
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|filt_bpfdetach
parameter_list|(
name|struct
name|knote
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|filt_bpfread
parameter_list|(
name|struct
name|knote
modifier|*
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bpf_drvinit
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bpf_stats_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net
argument_list|,
name|OID_AUTO
argument_list|,
name|bpf
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"bpf sysctl"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|bpf_maxinsns
init|=
name|BPF_MAXINSNS
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_bpf
argument_list|,
name|OID_AUTO
argument_list|,
name|maxinsns
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|bpf_maxinsns
argument_list|,
literal|0
argument_list|,
literal|"Maximum bpf program instructions"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|bpf_zerocopy_enable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_bpf
argument_list|,
name|OID_AUTO
argument_list|,
name|zerocopy_enable
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|bpf_zerocopy_enable
argument_list|,
literal|0
argument_list|,
literal|"Enable new zero-copy BPF buffer sessions"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_net_bpf
argument_list|,
name|OID_AUTO
argument_list|,
name|stats
argument_list|,
name|CTLFLAG_MPSAFE
operator||
name|CTLFLAG_RW
argument_list|,
name|bpf_stats_sysctl
argument_list|,
literal|"bpf statistics portal"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|bpf_optimize_writers
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_bpf_optimize_writers
value|VNET(bpf_optimize_writers)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_bpf
argument_list|,
name|OID_AUTO
argument_list|,
name|optimize_writers
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|bpf_optimize_writers
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Do not send packets until BPF program is set"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|bpfopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|bpfread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|bpfwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|bpfioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|bpfpoll
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_kqfilter_t
name|bpfkqfilter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|bpf_cdevsw
init|=
block|{
operator|.
name|d_version
operator|=
name|D_VERSION
block|,
operator|.
name|d_open
operator|=
name|bpfopen
block|,
operator|.
name|d_read
operator|=
name|bpfread
block|,
operator|.
name|d_write
operator|=
name|bpfwrite
block|,
operator|.
name|d_ioctl
operator|=
name|bpfioctl
block|,
operator|.
name|d_poll
operator|=
name|bpfpoll
block|,
operator|.
name|d_name
operator|=
literal|"bpf"
block|,
operator|.
name|d_kqfilter
operator|=
name|bpfkqfilter
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|filterops
name|bpfread_filtops
init|=
block|{
operator|.
name|f_isfd
operator|=
literal|1
block|,
operator|.
name|f_detach
operator|=
name|filt_bpfdetach
block|,
operator|.
name|f_event
operator|=
name|filt_bpfread
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|eventhandler_tag
name|bpf_ifdetach_cookie
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * LOCKING MODEL USED BY BPF:  * Locks:  * 1) global lock (BPF_LOCK). Mutex, used to protect interface addition/removal,  * some global counters and every bpf_if reference.  * 2) Interface lock. Rwlock, used to protect list of BPF descriptors and their filters.  * 3) Descriptor lock. Mutex, used to protect BPF buffers and various structure fields  *   used by bpf_mtap code.  *  * Lock order:  *  * Global lock, interface lock, descriptor lock  *  * We have to acquire interface lock before descriptor main lock due to BPF_MTAP[2]  * working model. In many places (like bpf_detachd) we start with BPF descriptor  * (and we need to at least rlock it to get reliable interface pointer). This  * gives us potential LOR. As a result, we use global lock to protect from bpf_if  * change in every such place.  *  * Changing d->bd_bif is protected by 1) global lock, 2) interface lock and  * 3) descriptor main wlock.  * Reading bd_bif can be protected by any of these locks, typically global lock.  *  * Changing read/write BPF filter is protected by the same three locks,  * the same applies for reading.  *  * Sleeping in global lock is not allowed due to bpfdetach() using it.  */
end_comment

begin_comment
comment|/*  * Wrapper functions for various buffering methods.  If the set of buffer  * modes expands, we will probably want to introduce a switch data structure  * similar to protosw, et.  */
end_comment

begin_function
specifier|static
name|void
name|bpf_append_bytes
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|,
name|caddr_t
name|buf
parameter_list|,
name|u_int
name|offset
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|BPFD_LOCK_ASSERT
argument_list|(
name|d
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|bd_bufmode
condition|)
block|{
case|case
name|BPF_BUFMODE_BUFFER
case|:
return|return
operator|(
name|bpf_buffer_append_bytes
argument_list|(
name|d
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
operator|)
return|;
case|case
name|BPF_BUFMODE_ZBUF
case|:
name|d
operator|->
name|bd_zcopy
operator|++
expr_stmt|;
return|return
operator|(
name|bpf_zerocopy_append_bytes
argument_list|(
name|d
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"bpf_buf_append_bytes"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bpf_append_mbuf
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|,
name|caddr_t
name|buf
parameter_list|,
name|u_int
name|offset
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|BPFD_LOCK_ASSERT
argument_list|(
name|d
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|bd_bufmode
condition|)
block|{
case|case
name|BPF_BUFMODE_BUFFER
case|:
return|return
operator|(
name|bpf_buffer_append_mbuf
argument_list|(
name|d
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
operator|)
return|;
case|case
name|BPF_BUFMODE_ZBUF
case|:
name|d
operator|->
name|bd_zcopy
operator|++
expr_stmt|;
return|return
operator|(
name|bpf_zerocopy_append_mbuf
argument_list|(
name|d
argument_list|,
name|buf
argument_list|,
name|offset
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"bpf_buf_append_mbuf"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This function gets called when the free buffer is re-assigned.  */
end_comment

begin_function
specifier|static
name|void
name|bpf_buf_reclaimed
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|)
block|{
name|BPFD_LOCK_ASSERT
argument_list|(
name|d
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|bd_bufmode
condition|)
block|{
case|case
name|BPF_BUFMODE_BUFFER
case|:
return|return;
case|case
name|BPF_BUFMODE_ZBUF
case|:
name|bpf_zerocopy_buf_reclaimed
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return;
default|default:
name|panic
argument_list|(
literal|"bpf_buf_reclaimed"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * If the buffer mechanism has a way to decide that a held buffer can be made  * free, then it is exposed via the bpf_canfreebuf() interface.  (1) is  * returned if the buffer can be discarded, (0) is returned if it cannot.  */
end_comment

begin_function
specifier|static
name|int
name|bpf_canfreebuf
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|)
block|{
name|BPFD_LOCK_ASSERT
argument_list|(
name|d
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|bd_bufmode
condition|)
block|{
case|case
name|BPF_BUFMODE_ZBUF
case|:
return|return
operator|(
name|bpf_zerocopy_canfreebuf
argument_list|(
name|d
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allow the buffer model to indicate that the current store buffer is  * immutable, regardless of the appearance of space.  Return (1) if the  * buffer is writable, and (0) if not.  */
end_comment

begin_function
specifier|static
name|int
name|bpf_canwritebuf
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|)
block|{
name|BPFD_LOCK_ASSERT
argument_list|(
name|d
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|bd_bufmode
condition|)
block|{
case|case
name|BPF_BUFMODE_ZBUF
case|:
return|return
operator|(
name|bpf_zerocopy_canwritebuf
argument_list|(
name|d
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Notify buffer model that an attempt to write to the store buffer has  * resulted in a dropped packet, in which case the buffer may be considered  * full.  */
end_comment

begin_function
specifier|static
name|void
name|bpf_buffull
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|)
block|{
name|BPFD_LOCK_ASSERT
argument_list|(
name|d
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|bd_bufmode
condition|)
block|{
case|case
name|BPF_BUFMODE_ZBUF
case|:
name|bpf_zerocopy_buffull
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Notify the buffer model that a buffer has moved into the hold position.  */
end_comment

begin_function
name|void
name|bpf_bufheld
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|)
block|{
name|BPFD_LOCK_ASSERT
argument_list|(
name|d
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|d
operator|->
name|bd_bufmode
condition|)
block|{
case|case
name|BPF_BUFMODE_ZBUF
case|:
name|bpf_zerocopy_bufheld
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bpf_free
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|)
block|{
switch|switch
condition|(
name|d
operator|->
name|bd_bufmode
condition|)
block|{
case|case
name|BPF_BUFMODE_BUFFER
case|:
return|return
operator|(
name|bpf_buffer_free
argument_list|(
name|d
argument_list|)
operator|)
return|;
case|case
name|BPF_BUFMODE_ZBUF
case|:
return|return
operator|(
name|bpf_zerocopy_free
argument_list|(
name|d
argument_list|)
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"bpf_buf_free"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bpf_uiomove
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|,
name|caddr_t
name|buf
parameter_list|,
name|u_int
name|len
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|bd_bufmode
operator|!=
name|BPF_BUFMODE_BUFFER
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
return|return
operator|(
name|bpf_buffer_uiomove
argument_list|(
name|d
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|uio
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bpf_ioctl_sblen
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|,
name|u_int
modifier|*
name|i
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|bd_bufmode
operator|!=
name|BPF_BUFMODE_BUFFER
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
return|return
operator|(
name|bpf_buffer_ioctl_sblen
argument_list|(
name|d
argument_list|,
name|i
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bpf_ioctl_getzmax
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|,
name|size_t
modifier|*
name|i
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|bd_bufmode
operator|!=
name|BPF_BUFMODE_ZBUF
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
return|return
operator|(
name|bpf_zerocopy_ioctl_getzmax
argument_list|(
name|td
argument_list|,
name|d
argument_list|,
name|i
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bpf_ioctl_rotzbuf
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|,
name|struct
name|bpf_zbuf
modifier|*
name|bz
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|bd_bufmode
operator|!=
name|BPF_BUFMODE_ZBUF
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
return|return
operator|(
name|bpf_zerocopy_ioctl_rotzbuf
argument_list|(
name|td
argument_list|,
name|d
argument_list|,
name|bz
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bpf_ioctl_setzbuf
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|,
name|struct
name|bpf_zbuf
modifier|*
name|bz
parameter_list|)
block|{
if|if
condition|(
name|d
operator|->
name|bd_bufmode
operator|!=
name|BPF_BUFMODE_ZBUF
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
return|return
operator|(
name|bpf_zerocopy_ioctl_setzbuf
argument_list|(
name|td
argument_list|,
name|d
argument_list|,
name|bz
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * General BPF functions.  */
end_comment

begin_function
specifier|static
name|int
name|bpf_movein
parameter_list|(
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|linktype
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sockp
parameter_list|,
name|int
modifier|*
name|hdrlen
parameter_list|,
name|struct
name|bpf_insn
modifier|*
name|wfilter
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|p
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|hlen
decl_stmt|;
name|int
name|slen
decl_stmt|;
comment|/* 	 * Build a sockaddr based on the data link layer type. 	 * We do this at this level because the ethernet header 	 * is copied directly into the data field of the sockaddr. 	 * In the case of SLIP, there is no header and the packet 	 * is forwarded as is. 	 * Also, we are careful to leave room at the front of the mbuf 	 * for the link level header. 	 */
switch|switch
condition|(
name|linktype
condition|)
block|{
case|case
name|DLT_SLIP
case|:
name|sockp
operator|->
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
name|hlen
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DLT_EN10MB
case|:
name|sockp
operator|->
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
comment|/* XXX Would MAXLINKHDR be better? */
name|hlen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
break|break;
case|case
name|DLT_FDDI
case|:
name|sockp
operator|->
name|sa_family
operator|=
name|AF_IMPLINK
expr_stmt|;
name|hlen
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DLT_RAW
case|:
name|sockp
operator|->
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|hlen
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DLT_NULL
case|:
comment|/* 		 * null interface types require a 4 byte pseudo header which 		 * corresponds to the address family of the packet. 		 */
name|sockp
operator|->
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|hlen
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|DLT_ATM_RFC1483
case|:
comment|/* 		 * en atm driver requires 4-byte atm pseudo header. 		 * though it isn't standard, vpi:vci needs to be 		 * specified anyway. 		 */
name|sockp
operator|->
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|hlen
operator|=
literal|12
expr_stmt|;
comment|/* XXX 4(ATM_PH) + 3(LLC) + 5(SNAP) */
break|break;
case|case
name|DLT_PPP
case|:
name|sockp
operator|->
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|hlen
operator|=
literal|4
expr_stmt|;
comment|/* This should match PPP_HDRLEN */
break|break;
case|case
name|DLT_IEEE802_11
case|:
comment|/* IEEE 802.11 wireless */
name|sockp
operator|->
name|sa_family
operator|=
name|AF_IEEE80211
expr_stmt|;
name|hlen
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DLT_IEEE802_11_RADIO
case|:
comment|/* IEEE 802.11 wireless w/ phy params */
name|sockp
operator|->
name|sa_family
operator|=
name|AF_IEEE80211
expr_stmt|;
name|sockp
operator|->
name|sa_len
operator|=
literal|12
expr_stmt|;
comment|/* XXX != 0 */
name|hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_bpf_params
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|len
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|hlen
operator|||
name|len
operator|-
name|hlen
operator|>
name|ifp
operator|->
name|if_mtu
condition|)
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
name|m
operator|=
name|m_get2
argument_list|(
name|len
argument_list|,
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|slen
operator|=
name|bpf_filter
argument_list|(
name|wfilter
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|len
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Check for multicast destination */
switch|switch
condition|(
name|linktype
condition|)
block|{
case|case
name|DLT_EN10MB
case|:
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ETHER_IS_MULTICAST
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
condition|)
block|{
if|if
condition|(
name|bcmp
argument_list|(
name|ifp
operator|->
name|if_broadcastaddr
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
name|m
operator|->
name|m_flags
operator||=
name|M_BCAST
expr_stmt|;
else|else
name|m
operator|->
name|m_flags
operator||=
name|M_MCAST
expr_stmt|;
block|}
break|break;
block|}
comment|/* 	 * Make room for link header, and copy it to sockaddr 	 */
if|if
condition|(
name|hlen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sockp
operator|->
name|sa_family
operator|==
name|AF_IEEE80211
condition|)
block|{
comment|/* 			 * Collect true length from the parameter header 			 * NB: sockp is known to be zero'd so if we do a 			 *     short copy unspecified parameters will be 			 *     zero. 			 * NB: packet may not be aligned after stripping 			 *     bpf params 			 * XXX check ibp_vers 			 */
name|p
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
expr|struct
name|ieee80211_bpf_params
operator|*
argument_list|)
expr_stmt|;
name|hlen
operator|=
name|p
operator|->
name|ibp_len
expr_stmt|;
if|if
condition|(
name|hlen
operator|>
sizeof|sizeof
argument_list|(
name|sockp
operator|->
name|sa_data
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
argument_list|,
name|sockp
operator|->
name|sa_data
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
block|}
operator|*
name|hdrlen
operator|=
name|hlen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach file to the bpf interface, i.e. make d listen on bp.  */
end_comment

begin_function
specifier|static
name|void
name|bpf_attachd
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|,
name|struct
name|bpf_if
modifier|*
name|bp
parameter_list|)
block|{
name|int
name|op_w
decl_stmt|;
name|BPF_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/* 	 * Save sysctl value to protect from sysctl change 	 * between reads 	 */
name|op_w
operator|=
name|V_bpf_optimize_writers
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|!=
name|NULL
condition|)
name|bpf_detachd_locked
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* 	 * Point d at bp, and add d to the interface's list. 	 * Since there are many applicaiotns using BPF for 	 * sending raw packets only (dhcpd, cdpd are good examples) 	 * we can delay adding d to the list of active listeners until 	 * some filter is configured. 	 */
name|BPFIF_WLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_bif
operator|=
name|bp
expr_stmt|;
if|if
condition|(
name|op_w
operator|!=
literal|0
condition|)
block|{
comment|/* Add to writers-only list */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|bp
operator|->
name|bif_wlist
argument_list|,
name|d
argument_list|,
name|bd_next
argument_list|)
expr_stmt|;
comment|/* 		 * We decrement bd_writer on every filter set operation. 		 * First BIOCSETF is done by pcap_open_live() to set up 		 * snap length. After that appliation usually sets its own filter 		 */
name|d
operator|->
name|bd_writer
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|bp
operator|->
name|bif_dlist
argument_list|,
name|d
argument_list|,
name|bd_next
argument_list|)
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|BPFIF_WUNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bpf_bpfd_cnt
operator|++
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_NET
argument_list|,
literal|"%s: bpf_attach called by pid %d, adding to %s list"
argument_list|,
name|__func__
argument_list|,
name|d
operator|->
name|bd_pid
argument_list|,
name|d
operator|->
name|bd_writer
condition|?
literal|"writer"
else|:
literal|"active"
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_w
operator|==
literal|0
condition|)
name|EVENTHANDLER_INVOKE
argument_list|(
name|bpf_track
argument_list|,
name|bp
operator|->
name|bif_ifp
argument_list|,
name|bp
operator|->
name|bif_dlt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check if we need to upgrade our descriptor @d from write-only mode.  */
end_comment

begin_function
specifier|static
name|int
name|bpf_check_upgrade
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|,
name|struct
name|bpf_insn
modifier|*
name|fcode
parameter_list|,
name|int
name|flen
parameter_list|)
block|{
name|int
name|is_snap
decl_stmt|,
name|need_upgrade
decl_stmt|;
comment|/* 	 * Check if we've already upgraded or new filter is empty. 	 */
if|if
condition|(
name|d
operator|->
name|bd_writer
operator|==
literal|0
operator|||
name|fcode
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|need_upgrade
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check if cmd looks like snaplen setting from 	 * pcap_bpf.c:pcap_open_live(). 	 * Note we're not checking .k value here: 	 * while pcap_open_live() definitely sets to to non-zero value, 	 * we'd prefer to treat k=0 (deny ALL) case the same way: e.g. 	 * do not consider upgrading immediately 	 */
if|if
condition|(
name|cmd
operator|==
name|BIOCSETF
operator|&&
name|flen
operator|==
literal|1
operator|&&
name|fcode
index|[
literal|0
index|]
operator|.
name|code
operator|==
operator|(
name|BPF_RET
operator||
name|BPF_K
operator|)
condition|)
name|is_snap
operator|=
literal|1
expr_stmt|;
else|else
name|is_snap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_snap
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We're setting first filter and it doesn't look like 		 * setting snaplen.  We're probably using bpf directly. 		 * Upgrade immediately. 		 */
name|need_upgrade
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Do not require upgrade by first BIOCSETF 		 * (used to set snaplen) by pcap_open_live(). 		 */
if|if
condition|(
operator|--
name|d
operator|->
name|bd_writer
operator|==
literal|0
condition|)
block|{
comment|/* 			 * First snaplen filter has already 			 * been set. This is probably catch-all 			 * filter 			 */
name|need_upgrade
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|CTR5
argument_list|(
name|KTR_NET
argument_list|,
literal|"%s: filter function set by pid %d, "
literal|"bd_writer counter %d, snap %d upgrade %d"
argument_list|,
name|__func__
argument_list|,
name|d
operator|->
name|bd_pid
argument_list|,
name|d
operator|->
name|bd_writer
argument_list|,
name|is_snap
argument_list|,
name|need_upgrade
argument_list|)
expr_stmt|;
return|return
operator|(
name|need_upgrade
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add d to the list of active bp filters.  * Reuqires bpf_attachd() to be called before  */
end_comment

begin_function
specifier|static
name|void
name|bpf_upgraded
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|;
name|BPF_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|bp
operator|=
name|d
operator|->
name|bd_bif
expr_stmt|;
comment|/* 	 * Filter can be set several times without specifying interface. 	 * Mark d as reader and exit. 	 */
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_writer
operator|=
literal|0
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return;
block|}
name|BPFIF_WLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* Remove from writers-only list */
name|LIST_REMOVE
argument_list|(
name|d
argument_list|,
name|bd_next
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|bp
operator|->
name|bif_dlist
argument_list|,
name|d
argument_list|,
name|bd_next
argument_list|)
expr_stmt|;
comment|/* Mark d as reader */
name|d
operator|->
name|bd_writer
operator|=
literal|0
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|BPFIF_WUNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_NET
argument_list|,
literal|"%s: upgrade required by pid %d"
argument_list|,
name|__func__
argument_list|,
name|d
operator|->
name|bd_pid
argument_list|)
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|bpf_track
argument_list|,
name|bp
operator|->
name|bif_ifp
argument_list|,
name|bp
operator|->
name|bif_dlt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Detach a file from its interface.  */
end_comment

begin_function
specifier|static
name|void
name|bpf_detachd
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|)
block|{
name|BPF_LOCK
argument_list|()
expr_stmt|;
name|bpf_detachd_locked
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|BPF_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bpf_detachd_locked
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_NET
argument_list|,
literal|"%s: detach required by pid %d"
argument_list|,
name|__func__
argument_list|,
name|d
operator|->
name|bd_pid
argument_list|)
expr_stmt|;
name|BPF_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/* Check if descriptor is attached */
if|if
condition|(
operator|(
name|bp
operator|=
name|d
operator|->
name|bd_bif
operator|)
operator|==
name|NULL
condition|)
return|return;
name|BPFIF_WLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* Save bd_writer value */
name|error
operator|=
name|d
operator|->
name|bd_writer
expr_stmt|;
comment|/* 	 * Remove d from the interface's descriptor list. 	 */
name|LIST_REMOVE
argument_list|(
name|d
argument_list|,
name|bd_next
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|bp
operator|->
name|bif_ifp
expr_stmt|;
name|d
operator|->
name|bd_bif
operator|=
name|NULL
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|BPFIF_WUNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bpf_bpfd_cnt
operator|--
expr_stmt|;
comment|/* Call event handler iff d is attached */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|EVENTHANDLER_INVOKE
argument_list|(
name|bpf_track
argument_list|,
name|ifp
argument_list|,
name|bp
operator|->
name|bif_dlt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Check if this descriptor had requested promiscuous mode. 	 * If so, turn it off. 	 */
if|if
condition|(
name|d
operator|->
name|bd_promisc
condition|)
block|{
name|d
operator|->
name|bd_promisc
operator|=
literal|0
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|ifp
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifpromisc
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENXIO
condition|)
block|{
comment|/* 			 * ENXIO can happen if a pccard is unplugged 			 * Something is really wrong if we were able to put 			 * the driver into promiscuous mode, but can't 			 * take it out. 			 */
name|if_printf
argument_list|(
name|bp
operator|->
name|bif_ifp
argument_list|,
literal|"bpf_detach: ifpromisc failed (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Close the descriptor by detaching it from its interface,  * deallocating its buffers, and marking it free.  */
end_comment

begin_function
specifier|static
name|void
name|bpf_dtor
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|bpf_d
modifier|*
name|d
init|=
name|data
decl_stmt|;
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_state
operator|==
name|BPF_WAITING
condition|)
name|callout_stop
argument_list|(
operator|&
name|d
operator|->
name|bd_callout
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_state
operator|=
name|BPF_IDLE
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|funsetown
argument_list|(
operator|&
name|d
operator|->
name|bd_sigio
argument_list|)
expr_stmt|;
name|bpf_detachd
argument_list|(
name|d
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_bpfdesc_destroy
argument_list|(
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MAC */
name|seldrain
argument_list|(
operator|&
name|d
operator|->
name|bd_sel
argument_list|)
expr_stmt|;
name|knlist_destroy
argument_list|(
operator|&
name|d
operator|->
name|bd_sel
operator|.
name|si_note
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|d
operator|->
name|bd_callout
argument_list|)
expr_stmt|;
name|bpf_freed
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|d
argument_list|,
name|M_BPF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open ethernet device.  Returns ENXIO for illegal minor device number,  * EBUSY if file is open by another process.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|bpfopen
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
name|int
name|error
decl_stmt|,
name|size
decl_stmt|;
name|d
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|,
name|M_BPF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|error
operator|=
name|devfs_set_cdevpriv
argument_list|(
name|d
argument_list|,
name|bpf_dtor
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|d
argument_list|,
name|M_BPF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * For historical reasons, perform a one-time initialization call to 	 * the buffer routines, even though we're not yet committed to a 	 * particular buffer method. 	 */
name|bpf_buffer_init
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_hbuf_in_use
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_bufmode
operator|=
name|BPF_BUFMODE_BUFFER
expr_stmt|;
name|d
operator|->
name|bd_sig
operator|=
name|SIGIO
expr_stmt|;
name|d
operator|->
name|bd_direction
operator|=
name|BPF_D_INOUT
expr_stmt|;
name|BPF_PID_REFRESH
argument_list|(
name|d
argument_list|,
name|td
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_bpfdesc_init
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|mac_bpfdesc_create
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_init
argument_list|(
operator|&
name|d
operator|->
name|bd_lock
argument_list|,
name|devtoname
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|"bpf cdev lock"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|d
operator|->
name|bd_callout
argument_list|,
operator|&
name|d
operator|->
name|bd_lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|knlist_init_mtx
argument_list|(
operator|&
name|d
operator|->
name|bd_sel
operator|.
name|si_note
argument_list|,
operator|&
name|d
operator|->
name|bd_lock
argument_list|)
expr_stmt|;
comment|/* Allocate default buffers */
name|size
operator|=
name|d
operator|->
name|bd_bufsize
expr_stmt|;
name|bpf_buffer_ioctl_sblen
argument_list|(
name|d
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  bpfread - read next chunk of packets from buffers  */
end_comment

begin_function
specifier|static
name|int
name|bpfread
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|non_block
decl_stmt|;
name|int
name|timed_out
decl_stmt|;
name|error
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Restrict application to use a buffer the same size as 	 * as kernel buffers. 	 */
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|!=
name|d
operator|->
name|bd_bufsize
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|non_block
operator|=
operator|(
operator|(
name|ioflag
operator|&
name|O_NONBLOCK
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|BPF_PID_REFRESH_CUR
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_bufmode
operator|!=
name|BPF_BUFMODE_BUFFER
condition|)
block|{
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
if|if
condition|(
name|d
operator|->
name|bd_state
operator|==
name|BPF_WAITING
condition|)
name|callout_stop
argument_list|(
operator|&
name|d
operator|->
name|bd_callout
argument_list|)
expr_stmt|;
name|timed_out
operator|=
operator|(
name|d
operator|->
name|bd_state
operator|==
name|BPF_TIMED_OUT
operator|)
expr_stmt|;
name|d
operator|->
name|bd_state
operator|=
name|BPF_IDLE
expr_stmt|;
while|while
condition|(
name|d
operator|->
name|bd_hbuf_in_use
condition|)
block|{
name|error
operator|=
name|mtx_sleep
argument_list|(
operator|&
name|d
operator|->
name|bd_hbuf_in_use
argument_list|,
operator|&
name|d
operator|->
name|bd_lock
argument_list|,
name|PRINET
operator||
name|PCATCH
argument_list|,
literal|"bd_hbuf"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * If the hold buffer is empty, then do a timed sleep, which 	 * ends when the timeout expires or when enough packets 	 * have arrived to fill the store buffer. 	 */
while|while
condition|(
name|d
operator|->
name|bd_hbuf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|bd_slen
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * A packet(s) either arrived since the previous 			 * read or arrived while we were asleep. 			 */
if|if
condition|(
name|d
operator|->
name|bd_immediate
operator|||
name|non_block
operator|||
name|timed_out
condition|)
block|{
comment|/* 				 * Rotate the buffers and return what's here 				 * if we are in immediate mode, non-blocking 				 * flag is set, or this descriptor timed out. 				 */
name|ROTATE_BUFFERS
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * No data is available, check to see if the bpf device 		 * is still pointed at a real interface.  If not, return 		 * ENXIO so that the userland process knows to rebind 		 * it before using it again. 		 */
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
name|NULL
condition|)
block|{
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|non_block
condition|)
block|{
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
block|}
name|error
operator|=
name|msleep
argument_list|(
name|d
argument_list|,
operator|&
name|d
operator|->
name|bd_lock
argument_list|,
name|PRINET
operator||
name|PCATCH
argument_list|,
literal|"bpf"
argument_list|,
name|d
operator|->
name|bd_rtout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|ERESTART
condition|)
block|{
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
block|{
comment|/* 			 * On a timeout, return what's in the buffer, 			 * which may be nothing.  If there is something 			 * in the store buffer, we can rotate the buffers. 			 */
if|if
condition|(
name|d
operator|->
name|bd_hbuf
condition|)
comment|/* 				 * We filled up the buffer in between 				 * getting the timeout and arriving 				 * here, so we don't need to rotate. 				 */
break|break;
if|if
condition|(
name|d
operator|->
name|bd_slen
operator|==
literal|0
condition|)
block|{
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ROTATE_BUFFERS
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * At this point, we know we have something in the hold slot. 	 */
name|d
operator|->
name|bd_hbuf_in_use
operator|=
literal|1
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* 	 * Move data from hold buffer into user space. 	 * We know the entire buffer is transferred since 	 * we checked above that the read buffer is bpf_bufsize bytes.   	 * 	 * We do not have to worry about simultaneous reads because 	 * we waited for sole access to the hold buffer above. 	 */
name|error
operator|=
name|bpf_uiomove
argument_list|(
name|d
argument_list|,
name|d
operator|->
name|bd_hbuf
argument_list|,
name|d
operator|->
name|bd_hlen
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|d
operator|->
name|bd_hbuf
operator|!=
name|NULL
argument_list|,
operator|(
literal|"bpfread: lost bd_hbuf"
operator|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_fbuf
operator|=
name|d
operator|->
name|bd_hbuf
expr_stmt|;
name|d
operator|->
name|bd_hbuf
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|bd_hlen
operator|=
literal|0
expr_stmt|;
name|bpf_buf_reclaimed
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_hbuf_in_use
operator|=
literal|0
expr_stmt|;
name|wakeup
argument_list|(
operator|&
name|d
operator|->
name|bd_hbuf_in_use
argument_list|)
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If there are processes sleeping on this descriptor, wake them up.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|bpf_wakeup
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|)
block|{
name|BPFD_LOCK_ASSERT
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_state
operator|==
name|BPF_WAITING
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|d
operator|->
name|bd_callout
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_state
operator|=
name|BPF_IDLE
expr_stmt|;
block|}
name|wakeup
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_async
operator|&&
name|d
operator|->
name|bd_sig
operator|&&
name|d
operator|->
name|bd_sigio
condition|)
name|pgsigio
argument_list|(
operator|&
name|d
operator|->
name|bd_sigio
argument_list|,
name|d
operator|->
name|bd_sig
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|selwakeuppri
argument_list|(
operator|&
name|d
operator|->
name|bd_sel
argument_list|,
name|PRINET
argument_list|)
expr_stmt|;
name|KNOTE_LOCKED
argument_list|(
operator|&
name|d
operator|->
name|bd_sel
operator|.
name|si_note
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bpf_timed_out
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|bpf_d
modifier|*
name|d
init|=
operator|(
expr|struct
name|bpf_d
operator|*
operator|)
name|arg
decl_stmt|;
name|BPFD_LOCK_ASSERT
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|d
operator|->
name|bd_callout
argument_list|)
operator|||
operator|!
name|callout_active
argument_list|(
operator|&
name|d
operator|->
name|bd_callout
argument_list|)
condition|)
return|return;
if|if
condition|(
name|d
operator|->
name|bd_state
operator|==
name|BPF_WAITING
condition|)
block|{
name|d
operator|->
name|bd_state
operator|=
name|BPF_TIMED_OUT
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_slen
operator|!=
literal|0
condition|)
name|bpf_wakeup
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bpf_ready
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|)
block|{
name|BPFD_LOCK_ASSERT
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bpf_canfreebuf
argument_list|(
name|d
argument_list|)
operator|&&
name|d
operator|->
name|bd_hlen
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|d
operator|->
name|bd_immediate
operator|||
name|d
operator|->
name|bd_state
operator|==
name|BPF_TIMED_OUT
operator|)
operator|&&
name|d
operator|->
name|bd_slen
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bpfwrite
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|)
block|{
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mc
decl_stmt|;
name|struct
name|sockaddr
name|dst
decl_stmt|;
name|int
name|error
decl_stmt|,
name|hlen
decl_stmt|;
name|error
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|BPF_PID_REFRESH_CUR
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_wcount
operator|++
expr_stmt|;
comment|/* XXX: locking required */
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
name|NULL
condition|)
block|{
name|d
operator|->
name|bd_wdcount
operator|++
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ifp
operator|=
name|d
operator|->
name|bd_bif
operator|->
name|bif_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|d
operator|->
name|bd_wdcount
operator|++
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
block|{
name|d
operator|->
name|bd_wdcount
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|hlen
operator|=
literal|0
expr_stmt|;
comment|/* XXX: bpf_movein() can sleep */
name|error
operator|=
name|bpf_movein
argument_list|(
name|uio
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|bd_bif
operator|->
name|bif_dlt
argument_list|,
name|ifp
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|dst
argument_list|,
operator|&
name|hlen
argument_list|,
name|d
operator|->
name|bd_wfilter
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|d
operator|->
name|bd_wdcount
operator|++
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|d
operator|->
name|bd_wfcount
operator|++
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_hdrcmplt
condition|)
name|dst
operator|.
name|sa_family
operator|=
name|pseudo_AF_HDRCMPLT
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_feedback
condition|)
block|{
name|mc
operator|=
name|m_dup
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|!=
name|NULL
condition|)
name|mc
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
comment|/* Set M_PROMISC for outgoing packets to be discarded. */
if|if
condition|(
name|d
operator|->
name|bd_direction
operator|==
name|BPF_D_INOUT
condition|)
name|m
operator|->
name|m_flags
operator||=
name|M_PROMISC
expr_stmt|;
block|}
else|else
name|mc
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|hlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|hlen
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|hlen
expr_stmt|;
comment|/* XXX */
name|CURVNET_SET
argument_list|(
name|ifp
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|mac_bpfdesc_create_mbuf
argument_list|(
name|d
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|!=
name|NULL
condition|)
name|mac_bpfdesc_create_mbuf
argument_list|(
name|d
argument_list|,
name|mc
argument_list|)
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
operator|&
name|dst
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|d
operator|->
name|bd_wdcount
operator|++
expr_stmt|;
if|if
condition|(
name|mc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|error
operator|==
literal|0
condition|)
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|mc
argument_list|)
expr_stmt|;
else|else
name|m_freem
argument_list|(
name|mc
argument_list|)
expr_stmt|;
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reset a descriptor by flushing its packet buffer and clearing the receive  * and drop counts.  This is doable for kernel-only buffers, but with  * zero-copy buffers, we can't write to (or rotate) buffers that are  * currently owned by userspace.  It would be nice if we could encapsulate  * this logic in the buffer code rather than here.  */
end_comment

begin_function
specifier|static
name|void
name|reset_d
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|)
block|{
name|BPFD_LOCK_ASSERT
argument_list|(
name|d
argument_list|)
expr_stmt|;
while|while
condition|(
name|d
operator|->
name|bd_hbuf_in_use
condition|)
name|mtx_sleep
argument_list|(
operator|&
name|d
operator|->
name|bd_hbuf_in_use
argument_list|,
operator|&
name|d
operator|->
name|bd_lock
argument_list|,
name|PRINET
argument_list|,
literal|"bd_hbuf"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|->
name|bd_hbuf
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|d
operator|->
name|bd_bufmode
operator|!=
name|BPF_BUFMODE_ZBUF
operator|||
name|bpf_canfreebuf
argument_list|(
name|d
argument_list|)
operator|)
condition|)
block|{
comment|/* Free the hold buffer. */
name|d
operator|->
name|bd_fbuf
operator|=
name|d
operator|->
name|bd_hbuf
expr_stmt|;
name|d
operator|->
name|bd_hbuf
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|bd_hlen
operator|=
literal|0
expr_stmt|;
name|bpf_buf_reclaimed
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bpf_canwritebuf
argument_list|(
name|d
argument_list|)
condition|)
name|d
operator|->
name|bd_slen
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_rcount
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_dcount
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_fcount
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_wcount
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_wfcount
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_wdcount
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_zcopy
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  FIONREAD		Check for read packet available.  *  BIOCGBLEN		Get buffer len [for read()].  *  BIOCSETF		Set read filter.  *  BIOCSETFNR		Set read filter without resetting descriptor.  *  BIOCSETWF		Set write filter.  *  BIOCFLUSH		Flush read packet buffer.  *  BIOCPROMISC		Put interface into promiscuous mode.  *  BIOCGDLT		Get link layer type.  *  BIOCGETIF		Get interface name.  *  BIOCSETIF		Set interface.  *  BIOCSRTIMEOUT	Set read timeout.  *  BIOCGRTIMEOUT	Get read timeout.  *  BIOCGSTATS		Get packet stats.  *  BIOCIMMEDIATE	Set immediate mode.  *  BIOCVERSION		Get filter language version.  *  BIOCGHDRCMPLT	Get "header already complete" flag  *  BIOCSHDRCMPLT	Set "header already complete" flag  *  BIOCGDIRECTION	Get packet direction flag  *  BIOCSDIRECTION	Set packet direction flag  *  BIOCGTSTAMP		Get time stamp format and resolution.  *  BIOCSTSTAMP		Set time stamp format and resolution.  *  BIOCLOCK		Set "locked" flag  *  BIOCFEEDBACK	Set packet feedback mode.  *  BIOCSETZBUF		Set current zero-copy buffer locations.  *  BIOCGETZMAX		Get maximum zero-copy buffer size.  *  BIOCROTZBUF		Force rotation of zero-copy buffer  *  BIOCSETBUFMODE	Set buffer mode.  *  BIOCGETBUFMODE	Get current buffer mode.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|bpfioctl
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Refresh PID associated with this descriptor. 	 */
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|BPF_PID_REFRESH
argument_list|(
name|d
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_state
operator|==
name|BPF_WAITING
condition|)
name|callout_stop
argument_list|(
operator|&
name|d
operator|->
name|bd_callout
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_state
operator|=
name|BPF_IDLE
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_locked
operator|==
literal|1
condition|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|BIOCGBLEN
case|:
case|case
name|BIOCFLUSH
case|:
case|case
name|BIOCGDLT
case|:
case|case
name|BIOCGDLTLIST
case|:
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
case|case
name|BIOCGDLTLIST32
case|:
endif|#
directive|endif
case|case
name|BIOCGETIF
case|:
case|case
name|BIOCGRTIMEOUT
case|:
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__mips__
argument_list|)
case|case
name|BIOCGRTIMEOUT32
case|:
endif|#
directive|endif
case|case
name|BIOCGSTATS
case|:
case|case
name|BIOCVERSION
case|:
case|case
name|BIOCGRSIG
case|:
case|case
name|BIOCGHDRCMPLT
case|:
case|case
name|BIOCSTSTAMP
case|:
case|case
name|BIOCFEEDBACK
case|:
case|case
name|FIONREAD
case|:
case|case
name|BIOCLOCK
case|:
case|case
name|BIOCSRTIMEOUT
case|:
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__mips__
argument_list|)
case|case
name|BIOCSRTIMEOUT32
case|:
endif|#
directive|endif
case|case
name|BIOCIMMEDIATE
case|:
case|case
name|TIOCGPGRP
case|:
case|case
name|BIOCROTZBUF
case|:
break|break;
default|default:
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
comment|/* 	 * If we see a 32-bit compat ioctl, mark the stream as 32-bit so 	 * that it will get 32-bit packet headers. 	 */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|BIOCSETF32
case|:
case|case
name|BIOCSETFNR32
case|:
case|case
name|BIOCSETWF32
case|:
case|case
name|BIOCGDLTLIST32
case|:
case|case
name|BIOCGRTIMEOUT32
case|:
case|case
name|BIOCSRTIMEOUT32
case|:
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_compat32
operator|=
literal|1
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|CURVNET_SET
argument_list|(
name|TD_TO_VNET
argument_list|(
name|td
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
comment|/* 	 * Check for read packet available. 	 */
case|case
name|FIONREAD
case|:
block|{
name|int
name|n
decl_stmt|;
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|n
operator|=
name|d
operator|->
name|bd_slen
expr_stmt|;
while|while
condition|(
name|d
operator|->
name|bd_hbuf_in_use
condition|)
name|mtx_sleep
argument_list|(
operator|&
name|d
operator|->
name|bd_hbuf_in_use
argument_list|,
operator|&
name|d
operator|->
name|bd_lock
argument_list|,
name|PRINET
argument_list|,
literal|"bd_hbuf"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_hbuf
condition|)
name|n
operator|+=
name|d
operator|->
name|bd_hlen
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|n
expr_stmt|;
break|break;
block|}
comment|/* 	 * Get buffer len [for read()]. 	 */
case|case
name|BIOCGBLEN
case|:
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
operator|=
name|d
operator|->
name|bd_bufsize
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set buffer length. 	 */
case|case
name|BIOCSBLEN
case|:
name|error
operator|=
name|bpf_ioctl_sblen
argument_list|(
name|d
argument_list|,
operator|(
name|u_int
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set link layer read filter. 	 */
case|case
name|BIOCSETF
case|:
case|case
name|BIOCSETFNR
case|:
case|case
name|BIOCSETWF
case|:
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
case|case
name|BIOCSETF32
case|:
case|case
name|BIOCSETFNR32
case|:
case|case
name|BIOCSETWF32
case|:
endif|#
directive|endif
name|error
operator|=
name|bpf_setf
argument_list|(
name|d
argument_list|,
operator|(
expr|struct
name|bpf_program
operator|*
operator|)
name|addr
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Flush read packet buffer. 	 */
case|case
name|BIOCFLUSH
case|:
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|reset_d
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Put interface into promiscuous mode. 	 */
case|case
name|BIOCPROMISC
case|:
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * No interface attached yet. 			 */
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|d
operator|->
name|bd_promisc
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ifpromisc
argument_list|(
name|d
operator|->
name|bd_bif
operator|->
name|bif_ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|d
operator|->
name|bd_promisc
operator|=
literal|1
expr_stmt|;
block|}
break|break;
comment|/* 	 * Get current data link type. 	 */
case|case
name|BIOCGDLT
case|:
name|BPF_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
name|NULL
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
operator|=
name|d
operator|->
name|bd_bif
operator|->
name|bif_dlt
expr_stmt|;
name|BPF_UNLOCK
argument_list|()
expr_stmt|;
break|break;
comment|/* 	 * Get a list of supported data link types. 	 */
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
case|case
name|BIOCGDLTLIST32
case|:
block|{
name|struct
name|bpf_dltlist32
modifier|*
name|list32
decl_stmt|;
name|struct
name|bpf_dltlist
name|dltlist
decl_stmt|;
name|list32
operator|=
operator|(
expr|struct
name|bpf_dltlist32
operator|*
operator|)
name|addr
expr_stmt|;
name|dltlist
operator|.
name|bfl_len
operator|=
name|list32
operator|->
name|bfl_len
expr_stmt|;
name|dltlist
operator|.
name|bfl_list
operator|=
name|PTRIN
argument_list|(
name|list32
operator|->
name|bfl_list
argument_list|)
expr_stmt|;
name|BPF_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
name|NULL
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|error
operator|=
name|bpf_getdltlist
argument_list|(
name|d
argument_list|,
operator|&
name|dltlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|list32
operator|->
name|bfl_len
operator|=
name|dltlist
operator|.
name|bfl_len
expr_stmt|;
block|}
name|BPF_UNLOCK
argument_list|()
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
case|case
name|BIOCGDLTLIST
case|:
name|BPF_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
name|NULL
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|error
operator|=
name|bpf_getdltlist
argument_list|(
name|d
argument_list|,
operator|(
expr|struct
name|bpf_dltlist
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
name|BPF_UNLOCK
argument_list|()
expr_stmt|;
break|break;
comment|/* 	 * Set data link type. 	 */
case|case
name|BIOCSDLT
case|:
name|BPF_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
name|NULL
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|error
operator|=
name|bpf_setdlt
argument_list|(
name|d
argument_list|,
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
name|BPF_UNLOCK
argument_list|()
expr_stmt|;
break|break;
comment|/* 	 * Get interface name. 	 */
case|case
name|BIOCGETIF
case|:
name|BPF_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
name|NULL
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|struct
name|ifnet
modifier|*
specifier|const
name|ifp
init|=
name|d
operator|->
name|bd_bif
operator|->
name|bif_ifp
decl_stmt|;
name|struct
name|ifreq
modifier|*
specifier|const
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|addr
decl_stmt|;
name|strlcpy
argument_list|(
name|ifr
operator|->
name|ifr_name
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|->
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|BPF_UNLOCK
argument_list|()
expr_stmt|;
break|break;
comment|/* 	 * Set interface. 	 */
case|case
name|BIOCSETIF
case|:
name|BPF_LOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|bpf_setif
argument_list|(
name|d
argument_list|,
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
name|BPF_UNLOCK
argument_list|()
expr_stmt|;
break|break;
comment|/* 	 * Set read timeout. 	 */
case|case
name|BIOCSRTIMEOUT
case|:
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__mips__
argument_list|)
case|case
name|BIOCSRTIMEOUT32
case|:
endif|#
directive|endif
block|{
name|struct
name|timeval
modifier|*
name|tv
init|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|addr
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__mips__
argument_list|)
name|struct
name|timeval32
modifier|*
name|tv32
decl_stmt|;
name|struct
name|timeval
name|tv64
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
name|BIOCSRTIMEOUT32
condition|)
block|{
name|tv32
operator|=
operator|(
expr|struct
name|timeval32
operator|*
operator|)
name|addr
expr_stmt|;
name|tv
operator|=
operator|&
name|tv64
expr_stmt|;
name|tv
operator|->
name|tv_sec
operator|=
name|tv32
operator|->
name|tv_sec
expr_stmt|;
name|tv
operator|->
name|tv_usec
operator|=
name|tv32
operator|->
name|tv_usec
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|tv
operator|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|addr
expr_stmt|;
comment|/* 			 * Subtract 1 tick from tvtohz() since this isn't 			 * a one-shot timer. 			 */
if|if
condition|(
operator|(
name|error
operator|=
name|itimerfix
argument_list|(
name|tv
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|d
operator|->
name|bd_rtout
operator|=
name|tvtohz
argument_list|(
name|tv
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 	 * Get read timeout. 	 */
case|case
name|BIOCGRTIMEOUT
case|:
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__mips__
argument_list|)
case|case
name|BIOCGRTIMEOUT32
case|:
endif|#
directive|endif
block|{
name|struct
name|timeval
modifier|*
name|tv
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__mips__
argument_list|)
name|struct
name|timeval32
modifier|*
name|tv32
decl_stmt|;
name|struct
name|timeval
name|tv64
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
name|BIOCGRTIMEOUT32
condition|)
name|tv
operator|=
operator|&
name|tv64
expr_stmt|;
else|else
endif|#
directive|endif
name|tv
operator|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|addr
expr_stmt|;
name|tv
operator|->
name|tv_sec
operator|=
name|d
operator|->
name|bd_rtout
operator|/
name|hz
expr_stmt|;
name|tv
operator|->
name|tv_usec
operator|=
operator|(
name|d
operator|->
name|bd_rtout
operator|%
name|hz
operator|)
operator|*
name|tick
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|COMPAT_FREEBSD32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__mips__
argument_list|)
if|if
condition|(
name|cmd
operator|==
name|BIOCGRTIMEOUT32
condition|)
block|{
name|tv32
operator|=
operator|(
expr|struct
name|timeval32
operator|*
operator|)
name|addr
expr_stmt|;
name|tv32
operator|->
name|tv_sec
operator|=
name|tv
operator|->
name|tv_sec
expr_stmt|;
name|tv32
operator|->
name|tv_usec
operator|=
name|tv
operator|->
name|tv_usec
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
comment|/* 	 * Get packet stats. 	 */
case|case
name|BIOCGSTATS
case|:
block|{
name|struct
name|bpf_stat
modifier|*
name|bs
init|=
operator|(
expr|struct
name|bpf_stat
operator|*
operator|)
name|addr
decl_stmt|;
comment|/* XXXCSJP overflow */
name|bs
operator|->
name|bs_recv
operator|=
name|d
operator|->
name|bd_rcount
expr_stmt|;
name|bs
operator|->
name|bs_drop
operator|=
name|d
operator|->
name|bd_dcount
expr_stmt|;
break|break;
block|}
comment|/* 	 * Set immediate mode. 	 */
case|case
name|BIOCIMMEDIATE
case|:
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_immediate
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIOCVERSION
case|:
block|{
name|struct
name|bpf_version
modifier|*
name|bv
init|=
operator|(
expr|struct
name|bpf_version
operator|*
operator|)
name|addr
decl_stmt|;
name|bv
operator|->
name|bv_major
operator|=
name|BPF_MAJOR_VERSION
expr_stmt|;
name|bv
operator|->
name|bv_minor
operator|=
name|BPF_MINOR_VERSION
expr_stmt|;
break|break;
block|}
comment|/* 	 * Get "header already complete" flag 	 */
case|case
name|BIOCGHDRCMPLT
case|:
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
operator|=
name|d
operator|->
name|bd_hdrcmplt
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set "header already complete" flag 	 */
case|case
name|BIOCSHDRCMPLT
case|:
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_hdrcmplt
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Get packet direction flag 	 */
case|case
name|BIOCGDIRECTION
case|:
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
operator|=
name|d
operator|->
name|bd_direction
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set packet direction flag 	 */
case|case
name|BIOCSDIRECTION
case|:
block|{
name|u_int
name|direction
decl_stmt|;
name|direction
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
expr_stmt|;
switch|switch
condition|(
name|direction
condition|)
block|{
case|case
name|BPF_D_IN
case|:
case|case
name|BPF_D_INOUT
case|:
case|case
name|BPF_D_OUT
case|:
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_direction
operator|=
name|direction
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
break|break;
comment|/* 	 * Get packet timestamp format and resolution. 	 */
case|case
name|BIOCGTSTAMP
case|:
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
operator|=
name|d
operator|->
name|bd_tstamp
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set packet timestamp format and resolution. 	 */
case|case
name|BIOCSTSTAMP
case|:
block|{
name|u_int
name|func
decl_stmt|;
name|func
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|BPF_T_VALID
argument_list|(
name|func
argument_list|)
condition|)
name|d
operator|->
name|bd_tstamp
operator|=
name|func
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
case|case
name|BIOCFEEDBACK
case|:
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_feedback
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIOCLOCK
case|:
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_locked
operator|=
literal|1
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIONBIO
case|:
comment|/* Non-blocking I/O */
break|break;
case|case
name|FIOASYNC
case|:
comment|/* Send signal on receive packets */
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_async
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIOSETOWN
case|:
comment|/* 		 * XXX: Add some sort of locking here? 		 * fsetown() can sleep. 		 */
name|error
operator|=
name|fsetown
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
argument_list|,
operator|&
name|d
operator|->
name|bd_sigio
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIOGETOWN
case|:
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|fgetown
argument_list|(
operator|&
name|d
operator|->
name|bd_sigio
argument_list|)
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
comment|/* This is deprecated, FIOSETOWN should be used instead. */
case|case
name|TIOCSPGRP
case|:
name|error
operator|=
name|fsetown
argument_list|(
operator|-
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|)
argument_list|,
operator|&
name|d
operator|->
name|bd_sigio
argument_list|)
expr_stmt|;
break|break;
comment|/* This is deprecated, FIOGETOWN should be used instead. */
case|case
name|TIOCGPGRP
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
operator|-
name|fgetown
argument_list|(
operator|&
name|d
operator|->
name|bd_sigio
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIOCSRSIG
case|:
comment|/* Set receive signal */
block|{
name|u_int
name|sig
decl_stmt|;
name|sig
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|sig
operator|>=
name|NSIG
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_sig
operator|=
name|sig
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|BIOCGRSIG
case|:
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
operator|=
name|d
operator|->
name|bd_sig
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIOCGETBUFMODE
case|:
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
operator|=
name|d
operator|->
name|bd_bufmode
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIOCSETBUFMODE
case|:
comment|/* 		 * Allow the buffering mode to be changed as long as we 		 * haven't yet committed to a particular mode.  Our 		 * definition of commitment, for now, is whether or not a 		 * buffer has been allocated or an interface attached, since 		 * that's the point where things get tricky. 		 */
switch|switch
condition|(
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
condition|)
block|{
case|case
name|BPF_BUFMODE_BUFFER
case|:
break|break;
case|case
name|BPF_BUFMODE_ZBUF
case|:
if|if
condition|(
name|bpf_zerocopy_enable
condition|)
break|break;
comment|/* FALLSTHROUGH */
default|default:
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_sbuf
operator|!=
name|NULL
operator|||
name|d
operator|->
name|bd_hbuf
operator|!=
name|NULL
operator|||
name|d
operator|->
name|bd_fbuf
operator|!=
name|NULL
operator|||
name|d
operator|->
name|bd_bif
operator|!=
name|NULL
condition|)
block|{
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|d
operator|->
name|bd_bufmode
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIOCGETZMAX
case|:
name|error
operator|=
name|bpf_ioctl_getzmax
argument_list|(
name|td
argument_list|,
name|d
argument_list|,
operator|(
name|size_t
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIOCSETZBUF
case|:
name|error
operator|=
name|bpf_ioctl_setzbuf
argument_list|(
name|td
argument_list|,
name|d
argument_list|,
operator|(
expr|struct
name|bpf_zbuf
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIOCROTZBUF
case|:
name|error
operator|=
name|bpf_ioctl_rotzbuf
argument_list|(
name|td
argument_list|,
name|d
argument_list|,
operator|(
expr|struct
name|bpf_zbuf
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set d's packet filter program to fp.  If this file already has a filter,  * free it and replace it.  Returns EINVAL for bogus requests.  *  * Note we need global lock here to serialize bpf_setf() and bpf_setif() calls  * since reading d->bd_bif can't be protected by d or interface lock due to  * lock order.  *  * Additionally, we have to acquire interface write lock due to bpf_mtap() uses  * interface read lock to read all filers.  *  */
end_comment

begin_function
specifier|static
name|int
name|bpf_setf
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|,
name|struct
name|bpf_program
modifier|*
name|fp
parameter_list|,
name|u_long
name|cmd
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
name|struct
name|bpf_program
name|fp_swab
decl_stmt|;
name|struct
name|bpf_program32
modifier|*
name|fp32
decl_stmt|;
endif|#
directive|endif
name|struct
name|bpf_insn
modifier|*
name|fcode
decl_stmt|,
modifier|*
name|old
decl_stmt|;
ifdef|#
directive|ifdef
name|BPF_JITTER
name|bpf_jit_filter
modifier|*
name|jfunc
decl_stmt|,
modifier|*
name|ofunc
decl_stmt|;
endif|#
directive|endif
name|size_t
name|size
decl_stmt|;
name|u_int
name|flen
decl_stmt|;
name|int
name|need_upgrade
decl_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|BIOCSETF32
case|:
case|case
name|BIOCSETWF32
case|:
case|case
name|BIOCSETFNR32
case|:
name|fp32
operator|=
operator|(
expr|struct
name|bpf_program32
operator|*
operator|)
name|fp
expr_stmt|;
name|fp_swab
operator|.
name|bf_len
operator|=
name|fp32
operator|->
name|bf_len
expr_stmt|;
name|fp_swab
operator|.
name|bf_insns
operator|=
operator|(
expr|struct
name|bpf_insn
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|fp32
operator|->
name|bf_insns
expr_stmt|;
name|fp
operator|=
operator|&
name|fp_swab
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|BIOCSETF32
case|:
name|cmd
operator|=
name|BIOCSETF
expr_stmt|;
break|break;
case|case
name|BIOCSETWF32
case|:
name|cmd
operator|=
name|BIOCSETWF
expr_stmt|;
break|break;
block|}
break|break;
block|}
endif|#
directive|endif
name|fcode
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|BPF_JITTER
name|jfunc
operator|=
name|ofunc
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|need_upgrade
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Check new filter validness before acquiring any locks. 	 * Allocate memory for new filter, if needed. 	 */
name|flen
operator|=
name|fp
operator|->
name|bf_len
expr_stmt|;
if|if
condition|(
name|flen
operator|>
name|bpf_maxinsns
operator|||
operator|(
name|fp
operator|->
name|bf_insns
operator|==
name|NULL
operator|&&
name|flen
operator|!=
literal|0
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|size
operator|=
name|flen
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|fp
operator|->
name|bf_insns
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
comment|/* We're setting up new filter.  Copy and check actual data. */
name|fcode
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_BPF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyin
argument_list|(
name|fp
operator|->
name|bf_insns
argument_list|,
name|fcode
argument_list|,
name|size
argument_list|)
operator|!=
literal|0
operator|||
operator|!
name|bpf_validate
argument_list|(
name|fcode
argument_list|,
name|flen
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|fcode
argument_list|,
name|M_BPF
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|BPF_JITTER
comment|/* Filter is copied inside fcode and is perfectly valid. */
name|jfunc
operator|=
name|bpf_jitter
argument_list|(
name|fcode
argument_list|,
name|flen
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|BPF_LOCK
argument_list|()
expr_stmt|;
comment|/* 	 * Set up new filter. 	 * Protect filter change by interface lock. 	 * Additionally, we are protected by global lock here. 	 */
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|!=
name|NULL
condition|)
name|BPFIF_WLOCK
argument_list|(
name|d
operator|->
name|bd_bif
argument_list|)
expr_stmt|;
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|BIOCSETWF
condition|)
block|{
name|old
operator|=
name|d
operator|->
name|bd_wfilter
expr_stmt|;
name|d
operator|->
name|bd_wfilter
operator|=
name|fcode
expr_stmt|;
block|}
else|else
block|{
name|old
operator|=
name|d
operator|->
name|bd_rfilter
expr_stmt|;
name|d
operator|->
name|bd_rfilter
operator|=
name|fcode
expr_stmt|;
ifdef|#
directive|ifdef
name|BPF_JITTER
name|ofunc
operator|=
name|d
operator|->
name|bd_bfilter
expr_stmt|;
name|d
operator|->
name|bd_bfilter
operator|=
name|jfunc
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cmd
operator|==
name|BIOCSETF
condition|)
name|reset_d
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|need_upgrade
operator|=
name|bpf_check_upgrade
argument_list|(
name|cmd
argument_list|,
name|d
argument_list|,
name|fcode
argument_list|,
name|flen
argument_list|)
expr_stmt|;
block|}
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|!=
name|NULL
condition|)
name|BPFIF_WUNLOCK
argument_list|(
name|d
operator|->
name|bd_bif
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|old
argument_list|,
name|M_BPF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BPF_JITTER
if|if
condition|(
name|ofunc
operator|!=
name|NULL
condition|)
name|bpf_destroy_jit_filter
argument_list|(
name|ofunc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Move d to active readers list. */
if|if
condition|(
name|need_upgrade
operator|!=
literal|0
condition|)
name|bpf_upgraded
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|BPF_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detach a file from its current interface (if attached at all) and attach  * to the interface indicated by the name stored in ifr.  * Return an errno or 0.  */
end_comment

begin_function
specifier|static
name|int
name|bpf_setif
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|,
name|struct
name|ifreq
modifier|*
name|ifr
parameter_list|)
block|{
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|theywant
decl_stmt|;
name|BPF_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|theywant
operator|=
name|ifunit
argument_list|(
name|ifr
operator|->
name|ifr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|theywant
operator|==
name|NULL
operator|||
name|theywant
operator|->
name|if_bpf
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|bp
operator|=
name|theywant
operator|->
name|if_bpf
expr_stmt|;
comment|/* Check if interface is not being detached from BPF */
name|BPFIF_RLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|flags
operator|&
name|BPFIF_FLAG_DYING
condition|)
block|{
name|BPFIF_RUNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|BPFIF_RUNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Behavior here depends on the buffering model.  If we're using 	 * kernel memory buffers, then we can allocate them here.  If we're 	 * using zero-copy, then the user process must have registered 	 * buffers by the time we get here.  If not, return an error. 	 */
switch|switch
condition|(
name|d
operator|->
name|bd_bufmode
condition|)
block|{
case|case
name|BPF_BUFMODE_BUFFER
case|:
case|case
name|BPF_BUFMODE_ZBUF
case|:
if|if
condition|(
name|d
operator|->
name|bd_sbuf
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
default|default:
name|panic
argument_list|(
literal|"bpf_setif: bufmode %d"
argument_list|,
name|d
operator|->
name|bd_bufmode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|!=
name|d
operator|->
name|bd_bif
condition|)
name|bpf_attachd
argument_list|(
name|d
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|reset_d
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Support for select() and poll() system calls  *  * Return true iff the specific operation will not block indefinitely.  * Otherwise, return false but make a note that a selwakeup() must be done.  */
end_comment

begin_function
specifier|static
name|int
name|bpfpoll
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|int
name|events
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
name|int
name|revents
decl_stmt|;
if|if
condition|(
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|d
argument_list|)
operator|!=
literal|0
operator|||
name|d
operator|->
name|bd_bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|events
operator|&
operator|(
name|POLLHUP
operator||
name|POLLIN
operator||
name|POLLRDNORM
operator||
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
operator|)
return|;
comment|/* 	 * Refresh PID associated with this descriptor. 	 */
name|revents
operator|=
name|events
operator|&
operator|(
name|POLLOUT
operator||
name|POLLWRNORM
operator|)
expr_stmt|;
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|BPF_PID_REFRESH
argument_list|(
name|d
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
if|if
condition|(
name|bpf_ready
argument_list|(
name|d
argument_list|)
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
else|else
block|{
name|selrecord
argument_list|(
name|td
argument_list|,
operator|&
name|d
operator|->
name|bd_sel
argument_list|)
expr_stmt|;
comment|/* Start the read timeout if necessary. */
if|if
condition|(
name|d
operator|->
name|bd_rtout
operator|>
literal|0
operator|&&
name|d
operator|->
name|bd_state
operator|==
name|BPF_IDLE
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|d
operator|->
name|bd_callout
argument_list|,
name|d
operator|->
name|bd_rtout
argument_list|,
name|bpf_timed_out
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_state
operator|=
name|BPF_WAITING
expr_stmt|;
block|}
block|}
block|}
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Support for kevent() system call.  Register EVFILT_READ filters and  * reject all others.  */
end_comment

begin_function
name|int
name|bpfkqfilter
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|devfs_get_cdevpriv
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|d
argument_list|)
operator|!=
literal|0
operator|||
name|kn
operator|->
name|kn_filter
operator|!=
name|EVFILT_READ
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Refresh PID associated with this descriptor. 	 */
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|BPF_PID_REFRESH_CUR
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|kn
operator|->
name|kn_fop
operator|=
operator|&
name|bpfread_filtops
expr_stmt|;
name|kn
operator|->
name|kn_hook
operator|=
name|d
expr_stmt|;
name|knlist_add
argument_list|(
operator|&
name|d
operator|->
name|bd_sel
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|filt_bpfdetach
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|)
block|{
name|struct
name|bpf_d
modifier|*
name|d
init|=
operator|(
expr|struct
name|bpf_d
operator|*
operator|)
name|kn
operator|->
name|kn_hook
decl_stmt|;
name|knlist_remove
argument_list|(
operator|&
name|d
operator|->
name|bd_sel
operator|.
name|si_note
argument_list|,
name|kn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|filt_bpfread
parameter_list|(
name|struct
name|knote
modifier|*
name|kn
parameter_list|,
name|long
name|hint
parameter_list|)
block|{
name|struct
name|bpf_d
modifier|*
name|d
init|=
operator|(
expr|struct
name|bpf_d
operator|*
operator|)
name|kn
operator|->
name|kn_hook
decl_stmt|;
name|int
name|ready
decl_stmt|;
name|BPFD_LOCK_ASSERT
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|ready
operator|=
name|bpf_ready
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|ready
condition|)
block|{
name|kn
operator|->
name|kn_data
operator|=
name|d
operator|->
name|bd_slen
expr_stmt|;
while|while
condition|(
name|d
operator|->
name|bd_hbuf_in_use
condition|)
name|mtx_sleep
argument_list|(
operator|&
name|d
operator|->
name|bd_hbuf_in_use
argument_list|,
operator|&
name|d
operator|->
name|bd_lock
argument_list|,
name|PRINET
argument_list|,
literal|"bd_hbuf"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_hbuf
condition|)
name|kn
operator|->
name|kn_data
operator|+=
name|d
operator|->
name|bd_hlen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|bd_rtout
operator|>
literal|0
operator|&&
name|d
operator|->
name|bd_state
operator|==
name|BPF_IDLE
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|d
operator|->
name|bd_callout
argument_list|,
name|d
operator|->
name|bd_rtout
argument_list|,
name|bpf_timed_out
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_state
operator|=
name|BPF_WAITING
expr_stmt|;
block|}
return|return
operator|(
name|ready
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BPF_TSTAMP_NONE
value|0
end_define

begin_define
define|#
directive|define
name|BPF_TSTAMP_FAST
value|1
end_define

begin_define
define|#
directive|define
name|BPF_TSTAMP_NORMAL
value|2
end_define

begin_define
define|#
directive|define
name|BPF_TSTAMP_EXTERN
value|3
end_define

begin_function
specifier|static
name|int
name|bpf_ts_quality
parameter_list|(
name|int
name|tstype
parameter_list|)
block|{
if|if
condition|(
name|tstype
operator|==
name|BPF_T_NONE
condition|)
return|return
operator|(
name|BPF_TSTAMP_NONE
operator|)
return|;
if|if
condition|(
operator|(
name|tstype
operator|&
name|BPF_T_FAST
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|BPF_TSTAMP_FAST
operator|)
return|;
return|return
operator|(
name|BPF_TSTAMP_NORMAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bpf_gettime
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|,
name|int
name|tstype
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|m_tag
modifier|*
name|tag
decl_stmt|;
name|int
name|quality
decl_stmt|;
name|quality
operator|=
name|bpf_ts_quality
argument_list|(
name|tstype
argument_list|)
expr_stmt|;
if|if
condition|(
name|quality
operator|==
name|BPF_TSTAMP_NONE
condition|)
return|return
operator|(
name|quality
operator|)
return|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|tag
operator|=
name|m_tag_locate
argument_list|(
name|m
argument_list|,
name|MTAG_BPF
argument_list|,
name|MTAG_BPF_TIMESTAMP
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|!=
name|NULL
condition|)
block|{
operator|*
name|bt
operator|=
operator|*
operator|(
expr|struct
name|bintime
operator|*
operator|)
operator|(
name|tag
operator|+
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|BPF_TSTAMP_EXTERN
operator|)
return|;
block|}
block|}
if|if
condition|(
name|quality
operator|==
name|BPF_TSTAMP_NORMAL
condition|)
name|binuptime
argument_list|(
name|bt
argument_list|)
expr_stmt|;
else|else
name|getbinuptime
argument_list|(
name|bt
argument_list|)
expr_stmt|;
return|return
operator|(
name|quality
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Incoming linkage from device drivers.  Process the packet pkt, of length  * pktlen, which is stored in a contiguous buffer.  The packet is parsed  * by each process' filter, and if accepted, stashed into the corresponding  * buffer.  */
end_comment

begin_function
name|void
name|bpf_tap
parameter_list|(
name|struct
name|bpf_if
modifier|*
name|bp
parameter_list|,
name|u_char
modifier|*
name|pkt
parameter_list|,
name|u_int
name|pktlen
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
ifdef|#
directive|ifdef
name|BPF_JITTER
name|bpf_jit_filter
modifier|*
name|bf
decl_stmt|;
endif|#
directive|endif
name|u_int
name|slen
decl_stmt|;
name|int
name|gottime
decl_stmt|;
name|gottime
operator|=
name|BPF_TSTAMP_NONE
expr_stmt|;
name|BPFIF_RLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|d
argument_list|,
argument|&bp->bif_dlist
argument_list|,
argument|bd_next
argument_list|)
block|{
comment|/* 		 * We are not using any locks for d here because: 		 * 1) any filter change is protected by interface 		 * write lock 		 * 2) destroying/detaching d is protected by interface 		 * write lock, too 		 */
comment|/* XXX: Do not protect counter for the sake of performance. */
operator|++
name|d
operator|->
name|bd_rcount
expr_stmt|;
comment|/* 		 * NB: We dont call BPF_CHECK_DIRECTION() here since there is no 		 * way for the caller to indiciate to us whether this packet 		 * is inbound or outbound.  In the bpf_mtap() routines, we use 		 * the interface pointers on the mbuf to figure it out. 		 */
ifdef|#
directive|ifdef
name|BPF_JITTER
name|bf
operator|=
name|bpf_jitter_enable
operator|!=
literal|0
condition|?
name|d
operator|->
name|bd_bfilter
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|bf
operator|!=
name|NULL
condition|)
name|slen
operator|=
operator|(
operator|*
operator|(
name|bf
operator|->
name|func
operator|)
operator|)
operator|(
name|pkt
operator|,
name|pktlen
operator|,
name|pktlen
operator|)
expr_stmt|;
else|else
endif|#
directive|endif
name|slen
operator|=
name|bpf_filter
argument_list|(
name|d
operator|->
name|bd_rfilter
argument_list|,
name|pkt
argument_list|,
name|pktlen
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Filter matches. Let's to acquire write lock. 			 */
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_fcount
operator|++
expr_stmt|;
if|if
condition|(
name|gottime
operator|<
name|bpf_ts_quality
argument_list|(
name|d
operator|->
name|bd_tstamp
argument_list|)
condition|)
name|gottime
operator|=
name|bpf_gettime
argument_list|(
operator|&
name|bt
argument_list|,
name|d
operator|->
name|bd_tstamp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
name|mac_bpfdesc_check_receive
argument_list|(
name|d
argument_list|,
name|bp
operator|->
name|bif_ifp
argument_list|)
operator|==
literal|0
condition|)
endif|#
directive|endif
name|catchpacket
argument_list|(
name|d
argument_list|,
name|pkt
argument_list|,
name|pktlen
argument_list|,
name|slen
argument_list|,
name|bpf_append_bytes
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
name|BPFIF_RUNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|BPF_CHECK_DIRECTION
parameter_list|(
name|d
parameter_list|,
name|r
parameter_list|,
name|i
parameter_list|)
define|\
value|(((d)->bd_direction == BPF_D_IN&& (r) != (i)) ||	\ 	    ((d)->bd_direction == BPF_D_OUT&& (r) == (i)))
end_define

begin_comment
comment|/*  * Incoming linkage from device drivers, when packet is in an mbuf chain.  * Locking model is explained in bpf_tap().  */
end_comment

begin_function
name|void
name|bpf_mtap
parameter_list|(
name|struct
name|bpf_if
modifier|*
name|bp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
ifdef|#
directive|ifdef
name|BPF_JITTER
name|bpf_jit_filter
modifier|*
name|bf
decl_stmt|;
endif|#
directive|endif
name|u_int
name|pktlen
decl_stmt|,
name|slen
decl_stmt|;
name|int
name|gottime
decl_stmt|;
comment|/* Skip outgoing duplicate packets. */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PROMISC
operator|)
operator|!=
literal|0
operator|&&
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|==
name|NULL
condition|)
block|{
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_PROMISC
expr_stmt|;
return|return;
block|}
name|pktlen
operator|=
name|m_length
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|gottime
operator|=
name|BPF_TSTAMP_NONE
expr_stmt|;
name|BPFIF_RLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|d
argument_list|,
argument|&bp->bif_dlist
argument_list|,
argument|bd_next
argument_list|)
block|{
if|if
condition|(
name|BPF_CHECK_DIRECTION
argument_list|(
name|d
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|bp
operator|->
name|bif_ifp
argument_list|)
condition|)
continue|continue;
operator|++
name|d
operator|->
name|bd_rcount
expr_stmt|;
ifdef|#
directive|ifdef
name|BPF_JITTER
name|bf
operator|=
name|bpf_jitter_enable
operator|!=
literal|0
condition|?
name|d
operator|->
name|bd_bfilter
else|:
name|NULL
expr_stmt|;
comment|/* XXX We cannot handle multiple mbufs. */
if|if
condition|(
name|bf
operator|!=
name|NULL
operator|&&
name|m
operator|->
name|m_next
operator|==
name|NULL
condition|)
name|slen
operator|=
operator|(
operator|*
operator|(
name|bf
operator|->
name|func
operator|)
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator|,
name|pktlen
operator|,
name|pktlen
operator|)
expr_stmt|;
else|else
endif|#
directive|endif
name|slen
operator|=
name|bpf_filter
argument_list|(
name|d
operator|->
name|bd_rfilter
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|m
argument_list|,
name|pktlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|!=
literal|0
condition|)
block|{
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_fcount
operator|++
expr_stmt|;
if|if
condition|(
name|gottime
operator|<
name|bpf_ts_quality
argument_list|(
name|d
operator|->
name|bd_tstamp
argument_list|)
condition|)
name|gottime
operator|=
name|bpf_gettime
argument_list|(
operator|&
name|bt
argument_list|,
name|d
operator|->
name|bd_tstamp
argument_list|,
name|m
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
name|mac_bpfdesc_check_receive
argument_list|(
name|d
argument_list|,
name|bp
operator|->
name|bif_ifp
argument_list|)
operator|==
literal|0
condition|)
endif|#
directive|endif
name|catchpacket
argument_list|(
name|d
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|m
argument_list|,
name|pktlen
argument_list|,
name|slen
argument_list|,
name|bpf_append_mbuf
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
name|BPFIF_RUNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Incoming linkage from device drivers, when packet is in  * an mbuf chain and to be prepended by a contiguous header.  */
end_comment

begin_function
name|void
name|bpf_mtap2
parameter_list|(
name|struct
name|bpf_if
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|u_int
name|dlen
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|struct
name|mbuf
name|mb
decl_stmt|;
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
name|u_int
name|pktlen
decl_stmt|,
name|slen
decl_stmt|;
name|int
name|gottime
decl_stmt|;
comment|/* Skip outgoing duplicate packets. */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PROMISC
operator|)
operator|!=
literal|0
operator|&&
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|==
name|NULL
condition|)
block|{
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_PROMISC
expr_stmt|;
return|return;
block|}
name|pktlen
operator|=
name|m_length
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Craft on-stack mbuf suitable for passing to bpf_filter. 	 * Note that we cut corners here; we only setup what's 	 * absolutely needed--this mbuf should never go anywhere else. 	 */
name|mb
operator|.
name|m_next
operator|=
name|m
expr_stmt|;
name|mb
operator|.
name|m_data
operator|=
name|data
expr_stmt|;
name|mb
operator|.
name|m_len
operator|=
name|dlen
expr_stmt|;
name|pktlen
operator|+=
name|dlen
expr_stmt|;
name|gottime
operator|=
name|BPF_TSTAMP_NONE
expr_stmt|;
name|BPFIF_RLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|d
argument_list|,
argument|&bp->bif_dlist
argument_list|,
argument|bd_next
argument_list|)
block|{
if|if
condition|(
name|BPF_CHECK_DIRECTION
argument_list|(
name|d
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|bp
operator|->
name|bif_ifp
argument_list|)
condition|)
continue|continue;
operator|++
name|d
operator|->
name|bd_rcount
expr_stmt|;
name|slen
operator|=
name|bpf_filter
argument_list|(
name|d
operator|->
name|bd_rfilter
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|mb
argument_list|,
name|pktlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|!=
literal|0
condition|)
block|{
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_fcount
operator|++
expr_stmt|;
if|if
condition|(
name|gottime
operator|<
name|bpf_ts_quality
argument_list|(
name|d
operator|->
name|bd_tstamp
argument_list|)
condition|)
name|gottime
operator|=
name|bpf_gettime
argument_list|(
operator|&
name|bt
argument_list|,
name|d
operator|->
name|bd_tstamp
argument_list|,
name|m
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
name|mac_bpfdesc_check_receive
argument_list|(
name|d
argument_list|,
name|bp
operator|->
name|bif_ifp
argument_list|)
operator|==
literal|0
condition|)
endif|#
directive|endif
name|catchpacket
argument_list|(
name|d
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|mb
argument_list|,
name|pktlen
argument_list|,
name|slen
argument_list|,
name|bpf_append_mbuf
argument_list|,
operator|&
name|bt
argument_list|)
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
name|BPFIF_RUNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|BPF_CHECK_DIRECTION
end_undef

begin_undef
undef|#
directive|undef
name|BPF_TSTAMP_NONE
end_undef

begin_undef
undef|#
directive|undef
name|BPF_TSTAMP_FAST
end_undef

begin_undef
undef|#
directive|undef
name|BPF_TSTAMP_NORMAL
end_undef

begin_undef
undef|#
directive|undef
name|BPF_TSTAMP_EXTERN
end_undef

begin_function
specifier|static
name|int
name|bpf_hdrlen
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|)
block|{
name|int
name|hdrlen
decl_stmt|;
name|hdrlen
operator|=
name|d
operator|->
name|bd_bif
operator|->
name|bif_hdrlen
expr_stmt|;
ifndef|#
directive|ifndef
name|BURN_BRIDGES
if|if
condition|(
name|d
operator|->
name|bd_tstamp
operator|==
name|BPF_T_NONE
operator|||
name|BPF_T_FORMAT
argument_list|(
name|d
operator|->
name|bd_tstamp
argument_list|)
operator|==
name|BPF_T_MICROTIME
condition|)
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
if|if
condition|(
name|d
operator|->
name|bd_compat32
condition|)
name|hdrlen
operator|+=
name|SIZEOF_BPF_HDR
argument_list|(
expr|struct
name|bpf_hdr32
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|hdrlen
operator|+=
name|SIZEOF_BPF_HDR
argument_list|(
expr|struct
name|bpf_hdr
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|hdrlen
operator|+=
name|SIZEOF_BPF_HDR
argument_list|(
expr|struct
name|bpf_xhdr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
if|if
condition|(
name|d
operator|->
name|bd_compat32
condition|)
name|hdrlen
operator|=
name|BPF_WORDALIGN32
argument_list|(
name|hdrlen
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|hdrlen
operator|=
name|BPF_WORDALIGN
argument_list|(
name|hdrlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|hdrlen
operator|-
name|d
operator|->
name|bd_bif
operator|->
name|bif_hdrlen
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bpf_bintime2ts
parameter_list|(
name|struct
name|bintime
modifier|*
name|bt
parameter_list|,
name|struct
name|bpf_ts
modifier|*
name|ts
parameter_list|,
name|int
name|tstype
parameter_list|)
block|{
name|struct
name|bintime
name|bt2
decl_stmt|;
name|struct
name|timeval
name|tsm
decl_stmt|;
name|struct
name|timespec
name|tsn
decl_stmt|;
if|if
condition|(
operator|(
name|tstype
operator|&
name|BPF_T_MONOTONIC
operator|)
operator|==
literal|0
condition|)
block|{
name|bt2
operator|=
operator|*
name|bt
expr_stmt|;
name|bintime_add
argument_list|(
operator|&
name|bt2
argument_list|,
operator|&
name|boottimebin
argument_list|)
expr_stmt|;
name|bt
operator|=
operator|&
name|bt2
expr_stmt|;
block|}
switch|switch
condition|(
name|BPF_T_FORMAT
argument_list|(
name|tstype
argument_list|)
condition|)
block|{
case|case
name|BPF_T_MICROTIME
case|:
name|bintime2timeval
argument_list|(
name|bt
argument_list|,
operator|&
name|tsm
argument_list|)
expr_stmt|;
name|ts
operator|->
name|bt_sec
operator|=
name|tsm
operator|.
name|tv_sec
expr_stmt|;
name|ts
operator|->
name|bt_frac
operator|=
name|tsm
operator|.
name|tv_usec
expr_stmt|;
break|break;
case|case
name|BPF_T_NANOTIME
case|:
name|bintime2timespec
argument_list|(
name|bt
argument_list|,
operator|&
name|tsn
argument_list|)
expr_stmt|;
name|ts
operator|->
name|bt_sec
operator|=
name|tsn
operator|.
name|tv_sec
expr_stmt|;
name|ts
operator|->
name|bt_frac
operator|=
name|tsn
operator|.
name|tv_nsec
expr_stmt|;
break|break;
case|case
name|BPF_T_BINTIME
case|:
name|ts
operator|->
name|bt_sec
operator|=
name|bt
operator|->
name|sec
expr_stmt|;
name|ts
operator|->
name|bt_frac
operator|=
name|bt
operator|->
name|frac
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Move the packet data from interface memory (pkt) into the  * store buffer.  "cpfn" is the routine called to do the actual data  * transfer.  bcopy is passed in to copy contiguous chunks, while  * bpf_append_mbuf is passed in to copy mbuf chains.  In the latter case,  * pkt is really an mbuf.  */
end_comment

begin_function
specifier|static
name|void
name|catchpacket
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|,
name|u_char
modifier|*
name|pkt
parameter_list|,
name|u_int
name|pktlen
parameter_list|,
name|u_int
name|snaplen
parameter_list|,
name|void
function_decl|(
modifier|*
name|cpfn
function_decl|)
parameter_list|(
name|struct
name|bpf_d
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|u_int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|u_int
parameter_list|)
parameter_list|,
name|struct
name|bintime
modifier|*
name|bt
parameter_list|)
block|{
name|struct
name|bpf_xhdr
name|hdr
decl_stmt|;
ifndef|#
directive|ifndef
name|BURN_BRIDGES
name|struct
name|bpf_hdr
name|hdr_old
decl_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
name|struct
name|bpf_hdr32
name|hdr32_old
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|int
name|caplen
decl_stmt|,
name|curlen
decl_stmt|,
name|hdrlen
decl_stmt|,
name|totlen
decl_stmt|;
name|int
name|do_wakeup
init|=
literal|0
decl_stmt|;
name|int
name|do_timestamp
decl_stmt|;
name|int
name|tstype
decl_stmt|;
name|BPFD_LOCK_ASSERT
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* 	 * Detect whether user space has released a buffer back to us, and if 	 * so, move it from being a hold buffer to a free buffer.  This may 	 * not be the best place to do it (for example, we might only want to 	 * run this check if we need the space), but for now it's a reliable 	 * spot to do it. 	 */
if|if
condition|(
name|d
operator|->
name|bd_fbuf
operator|==
name|NULL
operator|&&
name|bpf_canfreebuf
argument_list|(
name|d
argument_list|)
condition|)
block|{
while|while
condition|(
name|d
operator|->
name|bd_hbuf_in_use
condition|)
name|mtx_sleep
argument_list|(
operator|&
name|d
operator|->
name|bd_hbuf_in_use
argument_list|,
operator|&
name|d
operator|->
name|bd_lock
argument_list|,
name|PRINET
argument_list|,
literal|"bd_hbuf"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_fbuf
operator|=
name|d
operator|->
name|bd_hbuf
expr_stmt|;
name|d
operator|->
name|bd_hbuf
operator|=
name|NULL
expr_stmt|;
name|d
operator|->
name|bd_hlen
operator|=
literal|0
expr_stmt|;
name|bpf_buf_reclaimed
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Figure out how many bytes to move.  If the packet is 	 * greater or equal to the snapshot length, transfer that 	 * much.  Otherwise, transfer the whole packet (unless 	 * we hit the buffer size limit). 	 */
name|hdrlen
operator|=
name|bpf_hdrlen
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|totlen
operator|=
name|hdrlen
operator|+
name|min
argument_list|(
name|snaplen
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|totlen
operator|>
name|d
operator|->
name|bd_bufsize
condition|)
name|totlen
operator|=
name|d
operator|->
name|bd_bufsize
expr_stmt|;
comment|/* 	 * Round up the end of the previous packet to the next longword. 	 * 	 * Drop the packet if there's no room and no hope of room 	 * If the packet would overflow the storage buffer or the storage 	 * buffer is considered immutable by the buffer model, try to rotate 	 * the buffer and wakeup pending processes. 	 */
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
if|if
condition|(
name|d
operator|->
name|bd_compat32
condition|)
name|curlen
operator|=
name|BPF_WORDALIGN32
argument_list|(
name|d
operator|->
name|bd_slen
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|curlen
operator|=
name|BPF_WORDALIGN
argument_list|(
name|d
operator|->
name|bd_slen
argument_list|)
expr_stmt|;
if|if
condition|(
name|curlen
operator|+
name|totlen
operator|>
name|d
operator|->
name|bd_bufsize
operator|||
operator|!
name|bpf_canwritebuf
argument_list|(
name|d
argument_list|)
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|bd_fbuf
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * There's no room in the store buffer, and no 			 * prospect of room, so drop the packet.  Notify the 			 * buffer model. 			 */
name|bpf_buffull
argument_list|(
name|d
argument_list|)
expr_stmt|;
operator|++
name|d
operator|->
name|bd_dcount
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|d
operator|->
name|bd_hbuf_in_use
condition|)
name|mtx_sleep
argument_list|(
operator|&
name|d
operator|->
name|bd_hbuf_in_use
argument_list|,
operator|&
name|d
operator|->
name|bd_lock
argument_list|,
name|PRINET
argument_list|,
literal|"bd_hbuf"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ROTATE_BUFFERS
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|do_wakeup
operator|=
literal|1
expr_stmt|;
name|curlen
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|bd_immediate
operator|||
name|d
operator|->
name|bd_state
operator|==
name|BPF_TIMED_OUT
condition|)
comment|/* 		 * Immediate mode is set, or the read timeout has already 		 * expired during a select call.  A packet arrived, so the 		 * reader should be woken up. 		 */
name|do_wakeup
operator|=
literal|1
expr_stmt|;
name|caplen
operator|=
name|totlen
operator|-
name|hdrlen
expr_stmt|;
name|tstype
operator|=
name|d
operator|->
name|bd_tstamp
expr_stmt|;
name|do_timestamp
operator|=
name|tstype
operator|!=
name|BPF_T_NONE
expr_stmt|;
ifndef|#
directive|ifndef
name|BURN_BRIDGES
if|if
condition|(
name|tstype
operator|==
name|BPF_T_NONE
operator|||
name|BPF_T_FORMAT
argument_list|(
name|tstype
argument_list|)
operator|==
name|BPF_T_MICROTIME
condition|)
block|{
name|struct
name|bpf_ts
name|ts
decl_stmt|;
if|if
condition|(
name|do_timestamp
condition|)
name|bpf_bintime2ts
argument_list|(
name|bt
argument_list|,
operator|&
name|ts
argument_list|,
name|tstype
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|COMPAT_FREEBSD32
if|if
condition|(
name|d
operator|->
name|bd_compat32
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|hdr32_old
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr32_old
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_timestamp
condition|)
block|{
name|hdr32_old
operator|.
name|bh_tstamp
operator|.
name|tv_sec
operator|=
name|ts
operator|.
name|bt_sec
expr_stmt|;
name|hdr32_old
operator|.
name|bh_tstamp
operator|.
name|tv_usec
operator|=
name|ts
operator|.
name|bt_frac
expr_stmt|;
block|}
name|hdr32_old
operator|.
name|bh_datalen
operator|=
name|pktlen
expr_stmt|;
name|hdr32_old
operator|.
name|bh_hdrlen
operator|=
name|hdrlen
expr_stmt|;
name|hdr32_old
operator|.
name|bh_caplen
operator|=
name|caplen
expr_stmt|;
name|bpf_append_bytes
argument_list|(
name|d
argument_list|,
name|d
operator|->
name|bd_sbuf
argument_list|,
name|curlen
argument_list|,
operator|&
name|hdr32_old
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr32_old
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|copy
goto|;
block|}
endif|#
directive|endif
name|bzero
argument_list|(
operator|&
name|hdr_old
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr_old
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_timestamp
condition|)
block|{
name|hdr_old
operator|.
name|bh_tstamp
operator|.
name|tv_sec
operator|=
name|ts
operator|.
name|bt_sec
expr_stmt|;
name|hdr_old
operator|.
name|bh_tstamp
operator|.
name|tv_usec
operator|=
name|ts
operator|.
name|bt_frac
expr_stmt|;
block|}
name|hdr_old
operator|.
name|bh_datalen
operator|=
name|pktlen
expr_stmt|;
name|hdr_old
operator|.
name|bh_hdrlen
operator|=
name|hdrlen
expr_stmt|;
name|hdr_old
operator|.
name|bh_caplen
operator|=
name|caplen
expr_stmt|;
name|bpf_append_bytes
argument_list|(
name|d
argument_list|,
name|d
operator|->
name|bd_sbuf
argument_list|,
name|curlen
argument_list|,
operator|&
name|hdr_old
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr_old
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|copy
goto|;
block|}
endif|#
directive|endif
comment|/* 	 * Append the bpf header.  Note we append the actual header size, but 	 * move forward the length of the header plus padding. 	 */
name|bzero
argument_list|(
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_timestamp
condition|)
name|bpf_bintime2ts
argument_list|(
name|bt
argument_list|,
operator|&
name|hdr
operator|.
name|bh_tstamp
argument_list|,
name|tstype
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|bh_datalen
operator|=
name|pktlen
expr_stmt|;
name|hdr
operator|.
name|bh_hdrlen
operator|=
name|hdrlen
expr_stmt|;
name|hdr
operator|.
name|bh_caplen
operator|=
name|caplen
expr_stmt|;
name|bpf_append_bytes
argument_list|(
name|d
argument_list|,
name|d
operator|->
name|bd_sbuf
argument_list|,
name|curlen
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the packet data into the store buffer and update its length. 	 */
ifndef|#
directive|ifndef
name|BURN_BRIDGES
name|copy
label|:
endif|#
directive|endif
call|(
modifier|*
name|cpfn
call|)
argument_list|(
name|d
argument_list|,
name|d
operator|->
name|bd_sbuf
argument_list|,
name|curlen
operator|+
name|hdrlen
argument_list|,
name|pkt
argument_list|,
name|caplen
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_slen
operator|=
name|curlen
operator|+
name|totlen
expr_stmt|;
if|if
condition|(
name|do_wakeup
condition|)
name|bpf_wakeup
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free buffers currently in use by a descriptor.  * Called on close.  */
end_comment

begin_function
specifier|static
name|void
name|bpf_freed
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|)
block|{
comment|/* 	 * We don't need to lock out interrupts since this descriptor has 	 * been detached from its interface and it yet hasn't been marked 	 * free. 	 */
name|bpf_free
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_rfilter
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|d
operator|->
name|bd_rfilter
argument_list|,
name|M_BPF
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BPF_JITTER
if|if
condition|(
name|d
operator|->
name|bd_bfilter
operator|!=
name|NULL
condition|)
name|bpf_destroy_jit_filter
argument_list|(
name|d
operator|->
name|bd_bfilter
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|d
operator|->
name|bd_wfilter
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|d
operator|->
name|bd_wfilter
argument_list|,
name|M_BPF
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|d
operator|->
name|bd_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attach an interface to bpf.  dlt is the link layer type; hdrlen is the  * fixed size of the link header (variable length headers not yet supported).  */
end_comment

begin_function
name|void
name|bpfattach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int
name|dlt
parameter_list|,
name|u_int
name|hdrlen
parameter_list|)
block|{
name|bpfattach2
argument_list|(
name|ifp
argument_list|,
name|dlt
argument_list|,
name|hdrlen
argument_list|,
operator|&
name|ifp
operator|->
name|if_bpf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attach an interface to bpf.  ifp is a pointer to the structure  * defining the interface to be attached, dlt is the link layer type,  * and hdrlen is the fixed size of the link header (variable length  * headers are not yet supporrted).  */
end_comment

begin_function
name|void
name|bpfattach2
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int
name|dlt
parameter_list|,
name|u_int
name|hdrlen
parameter_list|,
name|struct
name|bpf_if
modifier|*
modifier|*
name|driverp
parameter_list|)
block|{
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bp
argument_list|)
argument_list|,
name|M_BPF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"bpfattach"
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|bp
operator|->
name|bif_dlist
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|bp
operator|->
name|bif_wlist
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bif_ifp
operator|=
name|ifp
expr_stmt|;
name|bp
operator|->
name|bif_dlt
operator|=
name|dlt
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|bp
operator|->
name|bif_lock
argument_list|,
literal|"bpf interface lock"
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|*
name|driverp
operator|==
name|NULL
argument_list|,
operator|(
literal|"bpfattach2: driverp already initialized"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|driverp
operator|=
name|bp
expr_stmt|;
name|BPF_LOCK
argument_list|()
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|bpf_iflist
argument_list|,
name|bp
argument_list|,
name|bif_next
argument_list|)
expr_stmt|;
name|BPF_UNLOCK
argument_list|()
expr_stmt|;
name|bp
operator|->
name|bif_hdrlen
operator|=
name|hdrlen
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"bpf attached\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Detach bpf from an interface. This involves detaching each descriptor  * associated with the interface. Notify each descriptor as it's detached  * so that any sleepers wake up and get ENXIO.  */
end_comment

begin_function
name|void
name|bpfdetach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|,
modifier|*
name|bp_temp
decl_stmt|;
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
name|int
name|ndetached
decl_stmt|;
name|ndetached
operator|=
literal|0
expr_stmt|;
name|BPF_LOCK
argument_list|()
expr_stmt|;
comment|/* Find all bpf_if struct's which reference ifp and detach them. */
name|LIST_FOREACH_SAFE
argument_list|(
argument|bp
argument_list|,
argument|&bpf_iflist
argument_list|,
argument|bif_next
argument_list|,
argument|bp_temp
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|!=
name|bp
operator|->
name|bif_ifp
condition|)
continue|continue;
name|LIST_REMOVE
argument_list|(
name|bp
argument_list|,
name|bif_next
argument_list|)
expr_stmt|;
comment|/* Add to to-be-freed list */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|bpf_freelist
argument_list|,
name|bp
argument_list|,
name|bif_next
argument_list|)
expr_stmt|;
name|ndetached
operator|++
expr_stmt|;
comment|/* 		 * Delay freeing bp till interface is detached 		 * and all routes through this interface are removed. 		 * Mark bp as detached to restrict new consumers. 		 */
name|BPFIF_WLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bp
operator|->
name|flags
operator||=
name|BPFIF_FLAG_DYING
expr_stmt|;
name|BPFIF_WUNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_NET
argument_list|,
literal|"%s: sheduling free for encap %d (%p) for if %p"
argument_list|,
name|__func__
argument_list|,
name|bp
operator|->
name|bif_dlt
argument_list|,
name|bp
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
comment|/* Free common descriptors */
while|while
condition|(
operator|(
name|d
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|bp
operator|->
name|bif_dlist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bpf_detachd_locked
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|bpf_wakeup
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
comment|/* Free writer-only descriptors */
while|while
condition|(
operator|(
name|d
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|bp
operator|->
name|bif_wlist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bpf_detachd_locked
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|bpf_wakeup
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
block|}
name|BPF_UNLOCK
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|ndetached
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"bpfdetach: %s was not attached\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Interface departure handler.  * Note departure event does not guarantee interface is going down.  * Interface renaming is currently done via departure/arrival event set.  *  * Departure handled is called after all routes pointing to  * given interface are removed and interface is in down state  * restricting any packets to be sent/received. We assume it is now safe  * to free data allocated by BPF.  */
end_comment

begin_function
specifier|static
name|void
name|bpf_ifdetach
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|,
modifier|*
name|bp_temp
decl_stmt|;
name|int
name|nmatched
init|=
literal|0
decl_stmt|;
name|BPF_LOCK
argument_list|()
expr_stmt|;
comment|/* 	 * Find matching entries in free list. 	 * Nothing should be found if bpfdetach() was not called. 	 */
name|LIST_FOREACH_SAFE
argument_list|(
argument|bp
argument_list|,
argument|&bpf_freelist
argument_list|,
argument|bif_next
argument_list|,
argument|bp_temp
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|!=
name|bp
operator|->
name|bif_ifp
condition|)
continue|continue;
name|CTR3
argument_list|(
name|KTR_NET
argument_list|,
literal|"%s: freeing BPF instance %p for interface %p"
argument_list|,
name|__func__
argument_list|,
name|bp
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bp
argument_list|,
name|bif_next
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|bp
operator|->
name|bif_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
argument_list|,
name|M_BPF
argument_list|)
expr_stmt|;
name|nmatched
operator|++
expr_stmt|;
block|}
name|BPF_UNLOCK
argument_list|()
expr_stmt|;
comment|/* 	 * Note that we cannot zero other pointers to 	 * custom DLTs possibly used by given interface. 	 */
if|if
condition|(
name|nmatched
operator|!=
literal|0
condition|)
name|ifp
operator|->
name|if_bpf
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a list of available data link type of the interface.  */
end_comment

begin_function
specifier|static
name|int
name|bpf_getdltlist
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|,
name|struct
name|bpf_dltlist
modifier|*
name|bfl
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|;
name|BPF_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|ifp
operator|=
name|d
operator|->
name|bd_bif
operator|->
name|bif_ifp
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&bpf_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|bif_ifp
operator|!=
name|ifp
condition|)
continue|continue;
if|if
condition|(
name|bfl
operator|->
name|bfl_list
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|n
operator|>=
name|bfl
operator|->
name|bfl_len
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|bp
operator|->
name|bif_dlt
argument_list|,
name|bfl
operator|->
name|bfl_list
operator|+
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|n
operator|++
expr_stmt|;
block|}
name|bfl
operator|->
name|bfl_len
operator|=
name|n
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the data link type of a BPF instance.  */
end_comment

begin_function
specifier|static
name|int
name|bpf_setdlt
parameter_list|(
name|struct
name|bpf_d
modifier|*
name|d
parameter_list|,
name|u_int
name|dlt
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|opromisc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|;
name|BPF_LOCK_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|->
name|bif_dlt
operator|==
name|dlt
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ifp
operator|=
name|d
operator|->
name|bd_bif
operator|->
name|bif_ifp
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&bpf_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|bif_ifp
operator|==
name|ifp
operator|&&
name|bp
operator|->
name|bif_dlt
operator|==
name|dlt
condition|)
break|break;
block|}
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|opromisc
operator|=
name|d
operator|->
name|bd_promisc
expr_stmt|;
name|bpf_attachd
argument_list|(
name|d
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|BPFD_LOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|reset_d
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|opromisc
condition|)
block|{
name|error
operator|=
name|ifpromisc
argument_list|(
name|bp
operator|->
name|bif_ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|if_printf
argument_list|(
name|bp
operator|->
name|bif_ifp
argument_list|,
literal|"bpf_setdlt: ifpromisc failed (%d)\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|else
name|d
operator|->
name|bd_promisc
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|bp
operator|==
name|NULL
condition|?
name|EINVAL
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bpf_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|bpf_mtx
argument_list|,
literal|"bpf global lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|bpf_iflist
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|bpf_freelist
argument_list|)
expr_stmt|;
name|dev
operator|=
name|make_dev
argument_list|(
operator|&
name|bpf_cdevsw
argument_list|,
literal|0
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"bpf"
argument_list|)
expr_stmt|;
comment|/* For compatibility */
name|make_dev_alias
argument_list|(
name|dev
argument_list|,
literal|"bpf0"
argument_list|)
expr_stmt|;
comment|/* Register interface departure handler */
name|bpf_ifdetach_cookie
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|ifnet_departure_event
argument_list|,
name|bpf_ifdetach
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Zero out the various packet counters associated with all of the bpf  * descriptors.  At some point, we will probably want to get a bit more  * granular and allow the user to specify descriptors to be zeroed.  */
end_comment

begin_function
specifier|static
name|void
name|bpf_zero_counters
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|;
name|struct
name|bpf_d
modifier|*
name|bd
decl_stmt|;
name|BPF_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&bpf_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
name|BPFIF_RLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bd
argument_list|,
argument|&bp->bif_dlist
argument_list|,
argument|bd_next
argument_list|)
block|{
name|BPFD_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|bd
operator|->
name|bd_rcount
operator|=
literal|0
expr_stmt|;
name|bd
operator|->
name|bd_dcount
operator|=
literal|0
expr_stmt|;
name|bd
operator|->
name|bd_fcount
operator|=
literal|0
expr_stmt|;
name|bd
operator|->
name|bd_wcount
operator|=
literal|0
expr_stmt|;
name|bd
operator|->
name|bd_wfcount
operator|=
literal|0
expr_stmt|;
name|bd
operator|->
name|bd_zcopy
operator|=
literal|0
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
block|}
name|BPFIF_RUNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|BPF_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fill filter statistics  */
end_comment

begin_function
specifier|static
name|void
name|bpfstats_fill_xbpf
parameter_list|(
name|struct
name|xbpf_d
modifier|*
name|d
parameter_list|,
name|struct
name|bpf_d
modifier|*
name|bd
parameter_list|)
block|{
name|bzero
argument_list|(
name|d
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|)
expr_stmt|;
name|BPFD_LOCK_ASSERT
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_structsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
expr_stmt|;
comment|/* XXX: reading should be protected by global lock */
name|d
operator|->
name|bd_immediate
operator|=
name|bd
operator|->
name|bd_immediate
expr_stmt|;
name|d
operator|->
name|bd_promisc
operator|=
name|bd
operator|->
name|bd_promisc
expr_stmt|;
name|d
operator|->
name|bd_hdrcmplt
operator|=
name|bd
operator|->
name|bd_hdrcmplt
expr_stmt|;
name|d
operator|->
name|bd_direction
operator|=
name|bd
operator|->
name|bd_direction
expr_stmt|;
name|d
operator|->
name|bd_feedback
operator|=
name|bd
operator|->
name|bd_feedback
expr_stmt|;
name|d
operator|->
name|bd_async
operator|=
name|bd
operator|->
name|bd_async
expr_stmt|;
name|d
operator|->
name|bd_rcount
operator|=
name|bd
operator|->
name|bd_rcount
expr_stmt|;
name|d
operator|->
name|bd_dcount
operator|=
name|bd
operator|->
name|bd_dcount
expr_stmt|;
name|d
operator|->
name|bd_fcount
operator|=
name|bd
operator|->
name|bd_fcount
expr_stmt|;
name|d
operator|->
name|bd_sig
operator|=
name|bd
operator|->
name|bd_sig
expr_stmt|;
name|d
operator|->
name|bd_slen
operator|=
name|bd
operator|->
name|bd_slen
expr_stmt|;
name|d
operator|->
name|bd_hlen
operator|=
name|bd
operator|->
name|bd_hlen
expr_stmt|;
name|d
operator|->
name|bd_bufsize
operator|=
name|bd
operator|->
name|bd_bufsize
expr_stmt|;
name|d
operator|->
name|bd_pid
operator|=
name|bd
operator|->
name|bd_pid
expr_stmt|;
name|strlcpy
argument_list|(
name|d
operator|->
name|bd_ifname
argument_list|,
name|bd
operator|->
name|bd_bif
operator|->
name|bif_ifp
operator|->
name|if_xname
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_locked
operator|=
name|bd
operator|->
name|bd_locked
expr_stmt|;
name|d
operator|->
name|bd_wcount
operator|=
name|bd
operator|->
name|bd_wcount
expr_stmt|;
name|d
operator|->
name|bd_wdcount
operator|=
name|bd
operator|->
name|bd_wdcount
expr_stmt|;
name|d
operator|->
name|bd_wfcount
operator|=
name|bd
operator|->
name|bd_wfcount
expr_stmt|;
name|d
operator|->
name|bd_zcopy
operator|=
name|bd
operator|->
name|bd_zcopy
expr_stmt|;
name|d
operator|->
name|bd_bufmode
operator|=
name|bd
operator|->
name|bd_bufmode
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle `netstat -B' stats request  */
end_comment

begin_function
specifier|static
name|int
name|bpf_stats_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|xbpf_d
name|zerostats
decl_stmt|;
name|struct
name|xbpf_d
modifier|*
name|xbdbuf
decl_stmt|,
modifier|*
name|xbd
decl_stmt|,
name|tempstats
decl_stmt|;
name|int
name|index
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|;
name|struct
name|bpf_d
modifier|*
name|bd
decl_stmt|;
comment|/* 	 * XXX This is not technically correct. It is possible for non 	 * privileged users to open bpf devices. It would make sense 	 * if the users who opened the devices were able to retrieve 	 * the statistics for them, too. 	 */
name|error
operator|=
name|priv_check
argument_list|(
name|req
operator|->
name|td
argument_list|,
name|PRIV_NET_BPF
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * Check to see if the user is requesting that the counters be 	 * zeroed out.  Explicitly check that the supplied data is zeroed, 	 * as we aren't allowing the user to set the counters currently. 	 */
if|if
condition|(
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|req
operator|->
name|newlen
operator|!=
sizeof|sizeof
argument_list|(
name|tempstats
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|memset
argument_list|(
operator|&
name|tempstats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tempstats
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_IN
argument_list|(
name|req
argument_list|,
operator|&
name|tempstats
argument_list|,
sizeof|sizeof
argument_list|(
name|tempstats
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|tempstats
argument_list|,
operator|&
name|zerostats
argument_list|,
sizeof|sizeof
argument_list|(
name|tempstats
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|bpf_zero_counters
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|req
operator|->
name|oldptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
literal|0
argument_list|,
name|bpf_bpfd_cnt
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|xbd
argument_list|)
argument_list|)
operator|)
return|;
if|if
condition|(
name|bpf_bpfd_cnt
operator|==
literal|0
condition|)
return|return
operator|(
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
return|;
name|xbdbuf
operator|=
name|malloc
argument_list|(
name|req
operator|->
name|oldlen
argument_list|,
name|M_BPF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|BPF_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|oldlen
operator|<
operator|(
name|bpf_bpfd_cnt
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|xbd
argument_list|)
operator|)
condition|)
block|{
name|BPF_UNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|xbdbuf
argument_list|,
name|M_BPF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|index
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&bpf_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
name|BPFIF_RLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* Send writers-only first */
name|LIST_FOREACH
argument_list|(
argument|bd
argument_list|,
argument|&bp->bif_wlist
argument_list|,
argument|bd_next
argument_list|)
block|{
name|xbd
operator|=
operator|&
name|xbdbuf
index|[
name|index
operator|++
index|]
expr_stmt|;
name|BPFD_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|bpfstats_fill_xbpf
argument_list|(
name|xbd
argument_list|,
name|bd
argument_list|)
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
block|}
name|LIST_FOREACH
argument_list|(
argument|bd
argument_list|,
argument|&bp->bif_dlist
argument_list|,
argument|bd_next
argument_list|)
block|{
name|xbd
operator|=
operator|&
name|xbdbuf
index|[
name|index
operator|++
index|]
expr_stmt|;
name|BPFD_LOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|bpfstats_fill_xbpf
argument_list|(
name|xbd
argument_list|,
name|bd
argument_list|)
expr_stmt|;
name|BPFD_UNLOCK
argument_list|(
name|bd
argument_list|)
expr_stmt|;
block|}
name|BPFIF_RUNLOCK
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|BPF_UNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|xbdbuf
argument_list|,
name|index
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|xbd
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|xbdbuf
argument_list|,
name|M_BPF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|bpfdev
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|bpf_drvinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !DEV_BPF&& !NETGRAPH_BPF */
end_comment

begin_comment
comment|/*  * NOP stubs to allow bpf-using drivers to load and function.  *  * A 'better' implementation would allow the core bpf functionality  * to be loaded at runtime.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bpf_if
name|bp_null
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|bpf_tap
parameter_list|(
name|struct
name|bpf_if
modifier|*
name|bp
parameter_list|,
name|u_char
modifier|*
name|pkt
parameter_list|,
name|u_int
name|pktlen
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|bpf_mtap
parameter_list|(
name|struct
name|bpf_if
modifier|*
name|bp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|bpf_mtap2
parameter_list|(
name|struct
name|bpf_if
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|d
parameter_list|,
name|u_int
name|l
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|bpfattach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int
name|dlt
parameter_list|,
name|u_int
name|hdrlen
parameter_list|)
block|{
name|bpfattach2
argument_list|(
name|ifp
argument_list|,
name|dlt
argument_list|,
name|hdrlen
argument_list|,
operator|&
name|ifp
operator|->
name|if_bpf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bpfattach2
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int
name|dlt
parameter_list|,
name|u_int
name|hdrlen
parameter_list|,
name|struct
name|bpf_if
modifier|*
modifier|*
name|driverp
parameter_list|)
block|{
operator|*
name|driverp
operator|=
operator|&
name|bp_null
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bpfdetach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{ }
end_function

begin_function
name|u_int
name|bpf_filter
parameter_list|(
specifier|const
name|struct
name|bpf_insn
modifier|*
name|pc
parameter_list|,
name|u_char
modifier|*
name|p
parameter_list|,
name|u_int
name|wirelen
parameter_list|,
name|u_int
name|buflen
parameter_list|)
block|{
return|return
operator|-
literal|1
return|;
comment|/* "no filter" behaviour */
block|}
end_function

begin_function
name|int
name|bpf_validate
parameter_list|(
specifier|const
name|struct
name|bpf_insn
modifier|*
name|f
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
literal|0
return|;
comment|/* false */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DEV_BPF&& !NETGRAPH_BPF */
end_comment

end_unit

