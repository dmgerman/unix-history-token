begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1990, 1991, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from the Stanford/CMU enet packet filter,  * (net/enet.c) distributed as part of 4.3BSD, and code contributed  * to Berkeley by Steven McCanne and Van Jacobson both of Lawrence  * Berkeley Laboratory.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      @(#)bpf.c	8.2 (Berkeley) 3/28/94  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"bpf.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__GNUC__
end_ifndef

begin_define
define|#
directive|define
name|inline
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|inline
value|__inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ttycom.h>
end_include

begin_include
include|#
directive|include
file|<sys/filedesc.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|sparc
argument_list|)
operator|&&
name|BSD
operator|<
literal|199103
end_if

begin_include
include|#
directive|include
file|<sys/stream.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/bpfdesc.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_BPF
argument_list|,
literal|"BPF"
argument_list|,
literal|"BPF data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|NBPF
operator|>
literal|0
end_if

begin_comment
comment|/*  * Older BSDs don't have kernel malloc.  */
end_comment

begin_if
if|#
directive|if
name|BSD
operator|<
literal|199103
end_if

begin_extern
extern|extern bcopy(
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|caddr_t
name|bpf_alloc
parameter_list|()
function_decl|;
end_function_decl

begin_include
include|#
directive|include
file|<net/bpf_compat.h>
end_include

begin_define
define|#
directive|define
name|BPF_BUFSIZE
value|(MCLBYTES-8)
end_define

begin_define
define|#
directive|define
name|UIOMOVE
parameter_list|(
name|cp
parameter_list|,
name|len
parameter_list|,
name|code
parameter_list|,
name|uio
parameter_list|)
value|uiomove(cp, len, code, uio)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BPF_BUFSIZE
value|4096
end_define

begin_define
define|#
directive|define
name|UIOMOVE
parameter_list|(
name|cp
parameter_list|,
name|len
parameter_list|,
name|code
parameter_list|,
name|uio
parameter_list|)
value|uiomove(cp, len, uio)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PRINET
value|26
end_define

begin_comment
comment|/* interruptible */
end_comment

begin_comment
comment|/*  * The default read buffer size is patchable.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bpf_bufsize
init|=
name|BPF_BUFSIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|bpf_bufsize
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|bpf_bufsize
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|bpf_maxbufsize
init|=
name|BPF_MAXBUFSIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|bpf_maxbufsize
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|bpf_maxbufsize
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  *  bpf_iflist is the list of interfaces; each corresponds to an ifnet  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bpf_if
modifier|*
name|bpf_iflist
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bpf_allocbufs
name|__P
argument_list|(
operator|(
expr|struct
name|bpf_d
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bpf_attachd
name|__P
argument_list|(
operator|(
expr|struct
name|bpf_d
operator|*
name|d
operator|,
expr|struct
name|bpf_if
operator|*
name|bp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bpf_detachd
name|__P
argument_list|(
operator|(
expr|struct
name|bpf_d
operator|*
name|d
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bpf_freed
name|__P
argument_list|(
operator|(
expr|struct
name|bpf_d
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|bpf_mcopy
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
name|void
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bpf_movein
name|__P
argument_list|(
operator|(
expr|struct
name|uio
operator|*
operator|,
name|int
operator|,
expr|struct
name|mbuf
operator|*
operator|*
operator|,
expr|struct
name|sockaddr
operator|*
operator|,
name|int
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bpf_setif
name|__P
argument_list|(
operator|(
expr|struct
name|bpf_d
operator|*
operator|,
expr|struct
name|ifreq
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|inline
name|void
name|bpf_wakeup
name|__P
argument_list|(
operator|(
expr|struct
name|bpf_d
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|catchpacket
name|__P
argument_list|(
operator|(
expr|struct
name|bpf_d
operator|*
operator|,
name|u_char
operator|*
operator|,
name|u_int
operator|,
name|u_int
operator|,
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
name|void
operator|*
argument_list|,
name|size_t
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|reset_d
name|__P
argument_list|(
operator|(
expr|struct
name|bpf_d
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|bpf_setf
name|__P
argument_list|(
operator|(
expr|struct
name|bpf_d
operator|*
operator|,
expr|struct
name|bpf_program
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_open_t
name|bpfopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|bpfclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_read_t
name|bpfread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_write_t
name|bpfwrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|bpfioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_poll_t
name|bpfpoll
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|23
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|bpf_cdevsw
init|=
block|{
comment|/* open */
name|bpfopen
block|,
comment|/* close */
name|bpfclose
block|,
comment|/* read */
name|bpfread
block|,
comment|/* write */
name|bpfwrite
block|,
comment|/* ioctl */
name|bpfioctl
block|,
comment|/* poll */
name|bpfpoll
block|,
comment|/* mmap */
name|nommap
block|,
comment|/* strategy */
name|nostrategy
block|,
comment|/* name */
literal|"bpf"
block|,
comment|/* maj */
name|CDEV_MAJOR
block|,
comment|/* dump */
name|nodump
block|,
comment|/* psize */
name|nopsize
block|,
comment|/* flags */
literal|0
block|,
comment|/* bmaj */
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|bpf_movein
parameter_list|(
name|uio
parameter_list|,
name|linktype
parameter_list|,
name|mp
parameter_list|,
name|sockp
parameter_list|,
name|datlen
parameter_list|)
specifier|register
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|linktype
decl_stmt|,
decl|*
name|datlen
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|sockaddr
modifier|*
name|sockp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|hlen
decl_stmt|;
comment|/* 	 * Build a sockaddr based on the data link layer type. 	 * We do this at this level because the ethernet header 	 * is copied directly into the data field of the sockaddr. 	 * In the case of SLIP, there is no header and the packet 	 * is forwarded as is. 	 * Also, we are careful to leave room at the front of the mbuf 	 * for the link level header. 	 */
switch|switch
condition|(
name|linktype
condition|)
block|{
case|case
name|DLT_SLIP
case|:
name|sockp
operator|->
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
name|hlen
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DLT_EN10MB
case|:
name|sockp
operator|->
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
comment|/* XXX Would MAXLINKHDR be better? */
name|hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
break|break;
case|case
name|DLT_FDDI
case|:
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__bsdi__
argument_list|)
name|sockp
operator|->
name|sa_family
operator|=
name|AF_IMPLINK
expr_stmt|;
name|hlen
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|sockp
operator|->
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
comment|/* XXX 4(FORMAC)+6(dst)+6(src)+3(LLC)+5(SNAP) */
name|hlen
operator|=
literal|24
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|DLT_RAW
case|:
case|case
name|DLT_NULL
case|:
name|sockp
operator|->
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|hlen
operator|=
literal|0
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|__FreeBSD__
case|case
name|DLT_ATM_RFC1483
case|:
comment|/* 		 * en atm driver requires 4-byte atm pseudo header. 		 * though it isn't standard, vpi:vci needs to be 		 * specified anyway. 		 */
name|sockp
operator|->
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|hlen
operator|=
literal|12
expr_stmt|;
comment|/* XXX 4(ATM_PH) + 3(LLC) + 5(SNAP) */
break|break;
endif|#
directive|endif
case|case
name|DLT_PPP
case|:
name|sockp
operator|->
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|hlen
operator|=
literal|4
expr_stmt|;
comment|/* This should match PPP_HDRLEN */
break|break;
default|default:
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|len
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
operator|*
name|datlen
operator|=
name|len
operator|-
name|hlen
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|len
operator|>
name|MCLBYTES
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_WAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
if|if
condition|(
name|len
operator|>
name|MHLEN
condition|)
block|{
if|#
directive|if
name|BSD
operator|>=
literal|199103
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
else|#
directive|else
name|MCLGET
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|!=
name|MCLBYTES
condition|)
block|{
endif|#
directive|endif
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
comment|/* 	 * Make room for link header. 	 */
if|if
condition|(
name|hlen
operator|!=
literal|0
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|hlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|hlen
expr_stmt|;
if|#
directive|if
name|BSD
operator|>=
literal|199103
name|m
operator|->
name|m_data
operator|+=
name|hlen
expr_stmt|;
comment|/* XXX */
else|#
directive|else
name|m
operator|->
name|m_off
operator|+=
name|hlen
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|UIOMOVE
argument_list|(
operator|(
name|caddr_t
operator|)
name|sockp
operator|->
name|sa_data
argument_list|,
name|hlen
argument_list|,
name|UIO_WRITE
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
block|}
name|error
operator|=
name|UIOMOVE
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
operator|-
name|hlen
argument_list|,
name|UIO_WRITE
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * Attach file to the bpf interface, i.e. make d listen on bp.  * Must be called at splimp.  */
specifier|static
name|void
name|bpf_attachd
parameter_list|(
name|d
parameter_list|,
name|bp
parameter_list|)
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|;
block|{
comment|/* 	 * Point d at bp, and add d to the interface's list of listeners. 	 * Finally, point the driver's bpf cookie at the interface so 	 * it will divert packets to bpf. 	 */
name|d
operator|->
name|bd_bif
operator|=
name|bp
expr_stmt|;
name|d
operator|->
name|bd_next
operator|=
name|bp
operator|->
name|bif_dlist
expr_stmt|;
name|bp
operator|->
name|bif_dlist
operator|=
name|d
expr_stmt|;
name|bp
operator|->
name|bif_ifp
operator|->
name|if_bpf
operator|=
name|bp
expr_stmt|;
block|}
comment|/*  * Detach a file from its interface.  */
specifier|static
name|void
name|bpf_detachd
parameter_list|(
name|d
parameter_list|)
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|bpf_d
modifier|*
modifier|*
name|p
decl_stmt|;
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
name|d
operator|->
name|bd_bif
expr_stmt|;
comment|/* 	 * Check if this descriptor had requested promiscuous mode. 	 * If so, turn it off. 	 */
if|if
condition|(
name|d
operator|->
name|bd_promisc
condition|)
block|{
name|d
operator|->
name|bd_promisc
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|ifpromisc
argument_list|(
name|bp
operator|->
name|bif_ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENXIO
condition|)
block|{
comment|/* 			 * ENXIO can happen if a pccard is unplugged 			 * Something is really wrong if we were able to put 			 * the driver into promiscuous mode, but can't 			 * take it out. 			 */
name|printf
argument_list|(
literal|"%s%d: ifpromisc failed %d\n"
argument_list|,
name|bp
operator|->
name|bif_ifp
operator|->
name|if_name
argument_list|,
name|bp
operator|->
name|bif_ifp
operator|->
name|if_unit
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Remove d from the interface's descriptor list. */
name|p
operator|=
operator|&
name|bp
operator|->
name|bif_dlist
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
name|d
condition|)
block|{
name|p
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|bd_next
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"bpf_detachd: descriptor not in list"
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
operator|(
operator|*
name|p
operator|)
operator|->
name|bd_next
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bif_dlist
operator|==
literal|0
condition|)
comment|/* 		 * Let the driver know that there are no more listeners. 		 */
name|d
operator|->
name|bd_bif
operator|->
name|bif_ifp
operator|->
name|if_bpf
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_bif
operator|=
literal|0
expr_stmt|;
block|}
comment|/*  * Open ethernet device.  Returns ENXIO for illegal minor device number,  * EBUSY if file is open by another process.  */
comment|/* ARGSUSED */
specifier|static
name|int
name|bpfopen
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|,
name|fmt
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|fmt
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|p_prison
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|d
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
comment|/* 	 * Each minor can be opened by only one process.  If the requested  	 * minor is in use, return EBUSY. 	 */
if|if
condition|(
name|d
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
operator|(
name|dev
operator|->
name|si_flags
operator|&
name|SI_NAMED
operator|)
operator|==
literal|0
condition|)
name|make_dev
argument_list|(
operator|&
name|bpf_cdevsw
argument_list|,
name|minor
argument_list|(
name|dev
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"bpf%d"
argument_list|,
name|dev2unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|d
argument_list|,
expr|struct
name|bpf_d
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|d
argument_list|)
argument_list|,
name|M_BPF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|dev
operator|->
name|si_drv1
operator|=
name|d
expr_stmt|;
name|d
operator|->
name|bd_bufsize
operator|=
name|bpf_bufsize
expr_stmt|;
name|d
operator|->
name|bd_sig
operator|=
name|SIGIO
expr_stmt|;
name|d
operator|->
name|bd_seesent
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Close the descriptor by detaching it from its interface,  * deallocating its buffers, and marking it free.  */
comment|/* ARGSUSED */
specifier|static
name|int
name|bpfclose
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|,
name|fmt
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|fmt
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|funsetown
argument_list|(
name|d
operator|->
name|bd_sigio
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_bif
condition|)
name|bpf_detachd
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|bpf_freed
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|dev
operator|->
name|si_drv1
operator|=
literal|0
expr_stmt|;
name|FREE
argument_list|(
name|d
argument_list|,
name|M_BPF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Support for SunOS, which does not have tsleep.  */
if|#
directive|if
name|BSD
operator|<
literal|199103
specifier|static
name|bpf_timeout
argument_list|(
argument|arg
argument_list|)
name|caddr_t
name|arg
expr_stmt|;
block|{
name|struct
name|bpf_d
modifier|*
name|d
init|=
operator|(
expr|struct
name|bpf_d
operator|*
operator|)
name|arg
decl_stmt|;
name|d
operator|->
name|bd_timedout
operator|=
literal|1
expr_stmt|;
name|wakeup
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|BPF_SLEEP
parameter_list|(
name|chan
parameter_list|,
name|pri
parameter_list|,
name|s
parameter_list|,
name|t
parameter_list|)
value|bpf_sleep((struct bpf_d *)chan)
name|int
name|bpf_sleep
parameter_list|(
name|d
parameter_list|)
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
block|{
specifier|register
name|int
name|rto
init|=
name|d
operator|->
name|bd_rtout
decl_stmt|;
specifier|register
name|int
name|st
decl_stmt|;
if|if
condition|(
name|rto
operator|!=
literal|0
condition|)
block|{
name|d
operator|->
name|bd_timedout
operator|=
literal|0
expr_stmt|;
name|timeout
argument_list|(
name|bpf_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|d
argument_list|,
name|rto
argument_list|)
expr_stmt|;
block|}
name|st
operator|=
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|d
argument_list|,
name|PRINET
operator||
name|PCATCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|rto
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|bd_timedout
operator|==
literal|0
condition|)
name|untimeout
argument_list|(
name|bpf_timeout
argument_list|,
operator|(
name|caddr_t
operator|)
name|d
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|st
operator|==
literal|0
condition|)
return|return
name|EWOULDBLOCK
return|;
block|}
return|return
operator|(
name|st
operator|!=
literal|0
operator|)
condition|?
name|EINTR
else|:
literal|0
return|;
block|}
else|#
directive|else
define|#
directive|define
name|BPF_SLEEP
value|tsleep
endif|#
directive|endif
comment|/*  * Rotate the packet buffers in descriptor d.  Move the store buffer  * into the hold slot, and the free buffer into the store slot.  * Zero the length of the new store buffer.  */
define|#
directive|define
name|ROTATE_BUFFERS
parameter_list|(
name|d
parameter_list|)
define|\
value|(d)->bd_hbuf = (d)->bd_sbuf; \ 	(d)->bd_hlen = (d)->bd_slen; \ 	(d)->bd_sbuf = (d)->bd_fbuf; \ 	(d)->bd_slen = 0; \ 	(d)->bd_fbuf = 0;
comment|/*  *  bpfread - read next chunk of packets from buffers  */
specifier|static
name|int
name|bpfread
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|ioflag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
specifier|register
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|ioflag
decl_stmt|;
block|{
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * Restrict application to use a buffer the same size as 	 * as kernel buffers. 	 */
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|!=
name|d
operator|->
name|bd_bufsize
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * If the hold buffer is empty, then do a timed sleep, which 	 * ends when the timeout expires or when enough packets 	 * have arrived to fill the store buffer. 	 */
while|while
condition|(
name|d
operator|->
name|bd_hbuf
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|bd_immediate
operator|&&
name|d
operator|->
name|bd_slen
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * A packet(s) either arrived since the previous 			 * read or arrived while we were asleep. 			 * Rotate the buffers and return what's here. 			 */
name|ROTATE_BUFFERS
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * No data is available, check to see if the bpf device 		 * is still pointed at a real interface.  If not, return 		 * ENXIO so that the userland process knows to rebind 		 * it before using it again. 		 */
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|ioflag
operator|&
name|IO_NDELAY
condition|)
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
else|else
name|error
operator|=
name|BPF_SLEEP
argument_list|(
operator|(
name|caddr_t
operator|)
name|d
argument_list|,
name|PRINET
operator||
name|PCATCH
argument_list|,
literal|"bpf"
argument_list|,
name|d
operator|->
name|bd_rtout
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EINTR
operator|||
name|error
operator|==
name|ERESTART
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
block|{
comment|/* 			 * On a timeout, return what's in the buffer, 			 * which may be nothing.  If there is something 			 * in the store buffer, we can rotate the buffers. 			 */
if|if
condition|(
name|d
operator|->
name|bd_hbuf
condition|)
comment|/* 				 * We filled up the buffer in between 				 * getting the timeout and arriving 				 * here, so we don't need to rotate. 				 */
break|break;
if|if
condition|(
name|d
operator|->
name|bd_slen
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ROTATE_BUFFERS
argument_list|(
name|d
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * At this point, we know we have something in the hold slot. 	 */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Move data from hold buffer into user space. 	 * We know the entire buffer is transferred since 	 * we checked above that the read buffer is bpf_bufsize bytes. 	 */
name|error
operator|=
name|UIOMOVE
argument_list|(
name|d
operator|->
name|bd_hbuf
argument_list|,
name|d
operator|->
name|bd_hlen
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|d
operator|->
name|bd_fbuf
operator|=
name|d
operator|->
name|bd_hbuf
expr_stmt|;
name|d
operator|->
name|bd_hbuf
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_hlen
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * If there are processes sleeping on this descriptor, wake them up.  */
specifier|static
specifier|inline
name|void
name|bpf_wakeup
parameter_list|(
name|d
parameter_list|)
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
block|{
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_async
operator|&&
name|d
operator|->
name|bd_sig
operator|&&
name|d
operator|->
name|bd_sigio
condition|)
name|pgsigio
argument_list|(
name|d
operator|->
name|bd_sigio
argument_list|,
name|d
operator|->
name|bd_sig
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|BSD
operator|>=
literal|199103
name|selwakeup
argument_list|(
operator|&
name|d
operator|->
name|bd_sel
argument_list|)
expr_stmt|;
comment|/* XXX */
name|d
operator|->
name|bd_sel
operator|.
name|si_pid
operator|=
literal|0
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|d
operator|->
name|bd_selproc
condition|)
block|{
name|selwakeup
argument_list|(
name|d
operator|->
name|bd_selproc
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|bd_selcoll
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_selcoll
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_selproc
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
specifier|static
name|int
name|bpfwrite
parameter_list|(
name|dev
parameter_list|,
name|uio
parameter_list|,
name|ioflag
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|ioflag
decl_stmt|;
block|{
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
specifier|static
name|struct
name|sockaddr
name|dst
decl_stmt|;
name|int
name|datlen
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|ifp
operator|=
name|d
operator|->
name|bd_bif
operator|->
name|bif_ifp
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|bpf_movein
argument_list|(
name|uio
argument_list|,
operator|(
name|int
operator|)
name|d
operator|->
name|bd_bif
operator|->
name|bif_dlt
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|dst
argument_list|,
operator|&
name|datlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|datlen
operator|>
name|ifp
operator|->
name|if_mtu
condition|)
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
if|if
condition|(
name|d
operator|->
name|bd_hdrcmplt
condition|)
name|dst
operator|.
name|sa_family
operator|=
name|pseudo_AF_HDRCMPLT
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|#
directive|if
name|BSD
operator|>=
literal|199103
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
operator|&
name|dst
argument_list|,
operator|(
expr|struct
name|rtentry
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
operator|&
name|dst
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * The driver frees the mbuf. 	 */
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * Reset a descriptor by flushing its packet buffer and clearing the  * receive and drop counts.  Should be called at splimp.  */
specifier|static
name|void
name|reset_d
parameter_list|(
name|d
parameter_list|)
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
block|{
if|if
condition|(
name|d
operator|->
name|bd_hbuf
condition|)
block|{
comment|/* Free the hold buffer. */
name|d
operator|->
name|bd_fbuf
operator|=
name|d
operator|->
name|bd_hbuf
expr_stmt|;
name|d
operator|->
name|bd_hbuf
operator|=
literal|0
expr_stmt|;
block|}
name|d
operator|->
name|bd_slen
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_hlen
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_rcount
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_dcount
operator|=
literal|0
expr_stmt|;
block|}
comment|/*  *  FIONREAD		Check for read packet available.  *  SIOCGIFADDR		Get interface address - convenient hook to driver.  *  BIOCGBLEN		Get buffer len [for read()].  *  BIOCSETF		Set ethernet read filter.  *  BIOCFLUSH		Flush read packet buffer.  *  BIOCPROMISC		Put interface into promiscuous mode.  *  BIOCGDLT		Get link layer type.  *  BIOCGETIF		Get interface name.  *  BIOCSETIF		Set interface.  *  BIOCSRTIMEOUT	Set read timeout.  *  BIOCGRTIMEOUT	Get read timeout.  *  BIOCGSTATS		Get packet stats.  *  BIOCIMMEDIATE	Set immediate mode.  *  BIOCVERSION		Get filter language version.  *  BIOCGHDRCMPLT	Get "header already complete" flag  *  BIOCSHDRCMPLT	Set "header already complete" flag  *  BIOCGSEESENT	Get "see packets sent" flag  *  BIOCSSEESENT	Set "see packets sent" flag  */
comment|/* ARGSUSED */
specifier|static
name|int
name|bpfioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|addr
parameter_list|,
name|flags
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
init|=
name|dev
operator|->
name|si_drv1
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
comment|/* 	 * Check for read packet available. 	 */
case|case
name|FIONREAD
case|:
block|{
name|int
name|n
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|n
operator|=
name|d
operator|->
name|bd_slen
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_hbuf
condition|)
name|n
operator|+=
name|d
operator|->
name|bd_hlen
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|n
expr_stmt|;
break|break;
block|}
case|case
name|SIOCGIFADDR
case|:
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|ifp
operator|=
name|d
operator|->
name|bd_bif
operator|->
name|bif_ifp
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_ioctl
call|)
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* 	 * Get buffer len [for read()]. 	 */
case|case
name|BIOCGBLEN
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
operator|=
name|d
operator|->
name|bd_bufsize
expr_stmt|;
break|break;
comment|/* 	 * Set buffer length. 	 */
case|case
name|BIOCSBLEN
case|:
if|#
directive|if
name|BSD
operator|<
literal|199103
name|error
operator|=
name|EINVAL
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|!=
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
specifier|register
name|u_int
name|size
init|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|bpf_maxbufsize
condition|)
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
operator|=
name|size
operator|=
name|bpf_maxbufsize
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|<
name|BPF_MINBUFSIZE
condition|)
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
operator|=
name|size
operator|=
name|BPF_MINBUFSIZE
expr_stmt|;
name|d
operator|->
name|bd_bufsize
operator|=
name|size
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
comment|/* 	 * Set link layer read filter. 	 */
case|case
name|BIOCSETF
case|:
name|error
operator|=
name|bpf_setf
argument_list|(
name|d
argument_list|,
operator|(
expr|struct
name|bpf_program
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Flush read packet buffer. 	 */
case|case
name|BIOCFLUSH
case|:
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|reset_d
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Put interface into promiscuous mode. 	 */
case|case
name|BIOCPROMISC
case|:
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
literal|0
condition|)
block|{
comment|/* 			 * No interface attached yet. 			 */
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_promisc
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ifpromisc
argument_list|(
name|d
operator|->
name|bd_bif
operator|->
name|bif_ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|d
operator|->
name|bd_promisc
operator|=
literal|1
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Get device parameters. 	 */
case|case
name|BIOCGDLT
case|:
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
operator|=
name|d
operator|->
name|bd_bif
operator|->
name|bif_dlt
expr_stmt|;
break|break;
comment|/* 	 * Get interface name. 	 */
case|case
name|BIOCGETIF
case|:
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
literal|0
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|struct
name|ifnet
modifier|*
specifier|const
name|ifp
init|=
name|d
operator|->
name|bd_bif
operator|->
name|bif_ifp
decl_stmt|;
name|struct
name|ifreq
modifier|*
specifier|const
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|addr
decl_stmt|;
name|snprintf
argument_list|(
name|ifr
operator|->
name|ifr_name
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
operator|->
name|ifr_name
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Set interface. 	 */
case|case
name|BIOCSETIF
case|:
name|error
operator|=
name|bpf_setif
argument_list|(
name|d
argument_list|,
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * Set read timeout. 	 */
case|case
name|BIOCSRTIMEOUT
case|:
block|{
name|struct
name|timeval
modifier|*
name|tv
init|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|addr
decl_stmt|;
comment|/* 			 * Subtract 1 tick from tvtohz() since this isn't 			 * a one-shot timer. 			 */
if|if
condition|(
operator|(
name|error
operator|=
name|itimerfix
argument_list|(
name|tv
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|d
operator|->
name|bd_rtout
operator|=
name|tvtohz
argument_list|(
name|tv
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 	 * Get read timeout. 	 */
case|case
name|BIOCGRTIMEOUT
case|:
block|{
name|struct
name|timeval
modifier|*
name|tv
init|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|addr
decl_stmt|;
name|tv
operator|->
name|tv_sec
operator|=
name|d
operator|->
name|bd_rtout
operator|/
name|hz
expr_stmt|;
name|tv
operator|->
name|tv_usec
operator|=
operator|(
name|d
operator|->
name|bd_rtout
operator|%
name|hz
operator|)
operator|*
name|tick
expr_stmt|;
break|break;
block|}
comment|/* 	 * Get packet stats. 	 */
case|case
name|BIOCGSTATS
case|:
block|{
name|struct
name|bpf_stat
modifier|*
name|bs
init|=
operator|(
expr|struct
name|bpf_stat
operator|*
operator|)
name|addr
decl_stmt|;
name|bs
operator|->
name|bs_recv
operator|=
name|d
operator|->
name|bd_rcount
expr_stmt|;
name|bs
operator|->
name|bs_drop
operator|=
name|d
operator|->
name|bd_dcount
expr_stmt|;
break|break;
block|}
comment|/* 	 * Set immediate mode. 	 */
case|case
name|BIOCIMMEDIATE
case|:
name|d
operator|->
name|bd_immediate
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
name|BIOCVERSION
case|:
block|{
name|struct
name|bpf_version
modifier|*
name|bv
init|=
operator|(
expr|struct
name|bpf_version
operator|*
operator|)
name|addr
decl_stmt|;
name|bv
operator|->
name|bv_major
operator|=
name|BPF_MAJOR_VERSION
expr_stmt|;
name|bv
operator|->
name|bv_minor
operator|=
name|BPF_MINOR_VERSION
expr_stmt|;
break|break;
block|}
comment|/* 	 * Get "header already complete" flag 	 */
case|case
name|BIOCGHDRCMPLT
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
operator|=
name|d
operator|->
name|bd_hdrcmplt
expr_stmt|;
break|break;
comment|/* 	 * Set "header already complete" flag 	 */
case|case
name|BIOCSHDRCMPLT
case|:
name|d
operator|->
name|bd_hdrcmplt
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
condition|?
literal|1
else|:
literal|0
expr_stmt|;
break|break;
comment|/* 	 * Get "see sent packets" flag 	 */
case|case
name|BIOCGSEESENT
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
operator|=
name|d
operator|->
name|bd_seesent
expr_stmt|;
break|break;
comment|/* 	 * Set "see sent packets" flag 	 */
case|case
name|BIOCSSEESENT
case|:
name|d
operator|->
name|bd_seesent
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
name|FIONBIO
case|:
comment|/* Non-blocking I/O */
break|break;
case|case
name|FIOASYNC
case|:
comment|/* Send signal on receive packets */
name|d
operator|->
name|bd_async
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
name|FIOSETOWN
case|:
name|error
operator|=
name|fsetown
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
argument_list|,
operator|&
name|d
operator|->
name|bd_sigio
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIOGETOWN
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
name|fgetown
argument_list|(
name|d
operator|->
name|bd_sigio
argument_list|)
expr_stmt|;
break|break;
comment|/* This is deprecated, FIOSETOWN should be used instead. */
case|case
name|TIOCSPGRP
case|:
name|error
operator|=
name|fsetown
argument_list|(
operator|-
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|)
argument_list|,
operator|&
name|d
operator|->
name|bd_sigio
argument_list|)
expr_stmt|;
break|break;
comment|/* This is deprecated, FIOGETOWN should be used instead. */
case|case
name|TIOCGPGRP
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|addr
operator|=
operator|-
name|fgetown
argument_list|(
name|d
operator|->
name|bd_sigio
argument_list|)
expr_stmt|;
break|break;
case|case
name|BIOCSRSIG
case|:
comment|/* Set receive signal */
block|{
name|u_int
name|sig
decl_stmt|;
name|sig
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|sig
operator|>=
name|NSIG
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|d
operator|->
name|bd_sig
operator|=
name|sig
expr_stmt|;
break|break;
block|}
case|case
name|BIOCGRSIG
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|addr
operator|=
name|d
operator|->
name|bd_sig
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/*  * Set d's packet filter program to fp.  If this file already has a filter,  * free it and replace it.  Returns EINVAL for bogus requests.  */
specifier|static
name|int
name|bpf_setf
parameter_list|(
name|d
parameter_list|,
name|fp
parameter_list|)
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
name|struct
name|bpf_program
modifier|*
name|fp
decl_stmt|;
block|{
name|struct
name|bpf_insn
modifier|*
name|fcode
decl_stmt|,
modifier|*
name|old
decl_stmt|;
name|u_int
name|flen
decl_stmt|,
name|size
decl_stmt|;
name|int
name|s
decl_stmt|;
name|old
operator|=
name|d
operator|->
name|bd_filter
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|bf_insns
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|bf_len
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|d
operator|->
name|bd_filter
operator|=
literal|0
expr_stmt|;
name|reset_d
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|!=
literal|0
condition|)
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|old
argument_list|,
name|M_BPF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|flen
operator|=
name|fp
operator|->
name|bf_len
expr_stmt|;
if|if
condition|(
name|flen
operator|>
name|BPF_MAXINSNS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|size
operator|=
name|flen
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|fp
operator|->
name|bf_insns
argument_list|)
expr_stmt|;
name|fcode
operator|=
operator|(
expr|struct
name|bpf_insn
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|,
name|M_BPF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|fp
operator|->
name|bf_insns
argument_list|,
operator|(
name|caddr_t
operator|)
name|fcode
argument_list|,
name|size
argument_list|)
operator|==
literal|0
operator|&&
name|bpf_validate
argument_list|(
name|fcode
argument_list|,
operator|(
name|int
operator|)
name|flen
argument_list|)
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|d
operator|->
name|bd_filter
operator|=
name|fcode
expr_stmt|;
name|reset_d
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|!=
literal|0
condition|)
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|old
argument_list|,
name|M_BPF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|fcode
argument_list|,
name|M_BPF
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/*  * Detach a file from its current interface (if attached at all) and attach  * to the interface indicated by the name stored in ifr.  * Return an errno or 0.  */
specifier|static
name|int
name|bpf_setif
parameter_list|(
name|d
parameter_list|,
name|ifr
parameter_list|)
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
block|{
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|theywant
decl_stmt|;
name|theywant
operator|=
name|ifunit
argument_list|(
name|ifr
operator|->
name|ifr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|theywant
operator|==
literal|0
condition|)
return|return
name|ENXIO
return|;
comment|/* 	 * Look through attached interfaces for the named one. 	 */
for|for
control|(
name|bp
operator|=
name|bpf_iflist
init|;
name|bp
operator|!=
literal|0
condition|;
name|bp
operator|=
name|bp
operator|->
name|bif_next
control|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|bp
operator|->
name|bif_ifp
decl_stmt|;
if|if
condition|(
name|ifp
operator|==
literal|0
operator|||
name|ifp
operator|!=
name|theywant
condition|)
continue|continue;
comment|/* 		 * We found the requested interface. 		 * If it's not up, return an error. 		 * Allocate the packet buffers if we need to. 		 * If we're already attached to requested interface, 		 * just flush the buffer. 		 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENETDOWN
operator|)
return|;
if|if
condition|(
name|d
operator|->
name|bd_sbuf
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|bpf_allocbufs
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|d
operator|->
name|bd_bif
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|bd_bif
condition|)
comment|/* 				 * Detach if attached to something else. 				 */
name|bpf_detachd
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|bpf_attachd
argument_list|(
name|d
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
name|reset_d
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Not found. */
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/*  * Support for select() and poll() system calls  *  * Return true iff the specific operation will not block indefinitely.  * Otherwise, return false but make a note that a selwakeup() must be done.  */
name|int
name|bpfpoll
parameter_list|(
name|dev
parameter_list|,
name|events
parameter_list|,
name|p
parameter_list|)
specifier|register
name|dev_t
name|dev
decl_stmt|;
name|int
name|events
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|int
name|revents
init|=
literal|0
decl_stmt|;
comment|/* 	 * An imitation of the FIONREAD ioctl code. 	 */
name|d
operator|=
name|dev
operator|->
name|si_drv1
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
condition|)
block|{
if|if
condition|(
name|d
operator|->
name|bd_hlen
operator|!=
literal|0
operator|||
operator|(
name|d
operator|->
name|bd_immediate
operator|&&
name|d
operator|->
name|bd_slen
operator|!=
literal|0
operator|)
condition|)
name|revents
operator||=
name|events
operator|&
operator|(
name|POLLIN
operator||
name|POLLRDNORM
operator|)
expr_stmt|;
else|else
name|selrecord
argument_list|(
name|p
argument_list|,
operator|&
name|d
operator|->
name|bd_sel
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|revents
operator|)
return|;
block|}
comment|/*  * Incoming linkage from device drivers.  Process the packet pkt, of length  * pktlen, which is stored in a contiguous buffer.  The packet is parsed  * by each process' filter, and if accepted, stashed into the corresponding  * buffer.  */
name|void
name|bpf_tap
parameter_list|(
name|ifp
parameter_list|,
name|pkt
parameter_list|,
name|pktlen
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|pkt
decl_stmt|;
specifier|register
name|u_int
name|pktlen
decl_stmt|;
block|{
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|;
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
specifier|register
name|u_int
name|slen
decl_stmt|;
comment|/* 	 * Note that the ipl does not have to be raised at this point. 	 * The only problem that could arise here is that if two different 	 * interfaces shared any data.  This is not the case. 	 */
name|bp
operator|=
name|ifp
operator|->
name|if_bpf
expr_stmt|;
for|for
control|(
name|d
operator|=
name|bp
operator|->
name|bif_dlist
init|;
name|d
operator|!=
literal|0
condition|;
name|d
operator|=
name|d
operator|->
name|bd_next
control|)
block|{
operator|++
name|d
operator|->
name|bd_rcount
expr_stmt|;
name|slen
operator|=
name|bpf_filter
argument_list|(
name|d
operator|->
name|bd_filter
argument_list|,
name|pkt
argument_list|,
name|pktlen
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|!=
literal|0
condition|)
name|catchpacket
argument_list|(
name|d
argument_list|,
name|pkt
argument_list|,
name|pktlen
argument_list|,
name|slen
argument_list|,
name|bcopy
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * Copy data from an mbuf chain into a buffer.  This code is derived  * from m_copydata in sys/uipc_mbuf.c.  */
specifier|static
name|void
name|bpf_mcopy
parameter_list|(
name|src_arg
parameter_list|,
name|dst_arg
parameter_list|,
name|len
parameter_list|)
specifier|const
name|void
modifier|*
name|src_arg
decl_stmt|;
name|void
modifier|*
name|dst_arg
decl_stmt|;
specifier|register
name|size_t
name|len
decl_stmt|;
block|{
specifier|register
specifier|const
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|u_int
name|count
decl_stmt|;
name|u_char
modifier|*
name|dst
decl_stmt|;
name|m
operator|=
name|src_arg
expr_stmt|;
name|dst
operator|=
name|dst_arg
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"bpf_mcopy"
argument_list|)
expr_stmt|;
name|count
operator|=
name|min
argument_list|(
name|m
operator|->
name|m_len
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|dst
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|dst
operator|+=
name|count
expr_stmt|;
name|len
operator|-=
name|count
expr_stmt|;
block|}
block|}
comment|/*  * Incoming linkage from device drivers, when packet is in an mbuf chain.  */
name|void
name|bpf_mtap
parameter_list|(
name|ifp
parameter_list|,
name|m
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|bpf_if
modifier|*
name|bp
init|=
name|ifp
operator|->
name|if_bpf
decl_stmt|;
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
name|u_int
name|pktlen
decl_stmt|,
name|slen
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|pktlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m0
operator|=
name|m
init|;
name|m0
operator|!=
literal|0
condition|;
name|m0
operator|=
name|m0
operator|->
name|m_next
control|)
name|pktlen
operator|+=
name|m0
operator|->
name|m_len
expr_stmt|;
for|for
control|(
name|d
operator|=
name|bp
operator|->
name|bif_dlist
init|;
name|d
operator|!=
literal|0
condition|;
name|d
operator|=
name|d
operator|->
name|bd_next
control|)
block|{
if|if
condition|(
operator|!
name|d
operator|->
name|bd_seesent
operator|&&
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|==
name|NULL
operator|)
condition|)
continue|continue;
operator|++
name|d
operator|->
name|bd_rcount
expr_stmt|;
name|slen
operator|=
name|bpf_filter
argument_list|(
name|d
operator|->
name|bd_filter
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|m
argument_list|,
name|pktlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|slen
operator|!=
literal|0
condition|)
name|catchpacket
argument_list|(
name|d
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|m
argument_list|,
name|pktlen
argument_list|,
name|slen
argument_list|,
name|bpf_mcopy
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * Move the packet data from interface memory (pkt) into the  * store buffer.  Return 1 if it's time to wakeup a listener (buffer full),  * otherwise 0.  "copy" is the routine called to do the actual data  * transfer.  bcopy is passed in to copy contiguous chunks, while  * bpf_mcopy is passed in to copy mbuf chains.  In the latter case,  * pkt is really an mbuf.  */
specifier|static
name|void
name|catchpacket
argument_list|(
name|d
argument_list|,
name|pkt
argument_list|,
name|pktlen
argument_list|,
name|snaplen
argument_list|,
name|cpfn
argument_list|)
decl|register struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|pkt
decl_stmt|;
specifier|register
name|u_int
name|pktlen
decl_stmt|,
name|snaplen
decl_stmt|;
specifier|register
name|void
argument_list|(
argument|*cpfn
argument_list|)
name|__P
argument_list|(
operator|(
specifier|const
name|void
operator|*
operator|,
name|void
operator|*
operator|,
name|size_t
operator|)
argument_list|)
expr_stmt|;
block|{
specifier|register
name|struct
name|bpf_hdr
modifier|*
name|hp
decl_stmt|;
specifier|register
name|int
name|totlen
decl_stmt|,
name|curlen
decl_stmt|;
specifier|register
name|int
name|hdrlen
init|=
name|d
operator|->
name|bd_bif
operator|->
name|bif_hdrlen
decl_stmt|;
comment|/* 	 * Figure out how many bytes to move.  If the packet is 	 * greater or equal to the snapshot length, transfer that 	 * much.  Otherwise, transfer the whole packet (unless 	 * we hit the buffer size limit). 	 */
name|totlen
operator|=
name|hdrlen
operator|+
name|min
argument_list|(
name|snaplen
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|totlen
operator|>
name|d
operator|->
name|bd_bufsize
condition|)
name|totlen
operator|=
name|d
operator|->
name|bd_bufsize
expr_stmt|;
comment|/* 	 * Round up the end of the previous packet to the next longword. 	 */
name|curlen
operator|=
name|BPF_WORDALIGN
argument_list|(
name|d
operator|->
name|bd_slen
argument_list|)
expr_stmt|;
if|if
condition|(
name|curlen
operator|+
name|totlen
operator|>
name|d
operator|->
name|bd_bufsize
condition|)
block|{
comment|/* 		 * This packet will overflow the storage buffer. 		 * Rotate the buffers if we can, then wakeup any 		 * pending reads. 		 */
if|if
condition|(
name|d
operator|->
name|bd_fbuf
operator|==
literal|0
condition|)
block|{
comment|/* 			 * We haven't completed the previous read yet, 			 * so drop the packet. 			 */
operator|++
name|d
operator|->
name|bd_dcount
expr_stmt|;
return|return;
block|}
name|ROTATE_BUFFERS
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|bpf_wakeup
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|curlen
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|d
operator|->
name|bd_immediate
condition|)
comment|/* 		 * Immediate mode is set.  A packet arrived so any 		 * reads should be woken up. 		 */
name|bpf_wakeup
argument_list|(
name|d
argument_list|)
expr_stmt|;
comment|/* 	 * Append the bpf header. 	 */
name|hp
operator|=
operator|(
expr|struct
name|bpf_hdr
operator|*
operator|)
operator|(
name|d
operator|->
name|bd_sbuf
operator|+
name|curlen
operator|)
expr_stmt|;
if|#
directive|if
name|BSD
operator|>=
literal|199103
name|microtime
argument_list|(
operator|&
name|hp
operator|->
name|bh_tstamp
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|sun
argument_list|)
name|uniqtime
argument_list|(
operator|&
name|hp
operator|->
name|bh_tstamp
argument_list|)
expr_stmt|;
else|#
directive|else
name|hp
operator|->
name|bh_tstamp
operator|=
name|time
expr_stmt|;
endif|#
directive|endif
name|hp
operator|->
name|bh_datalen
operator|=
name|pktlen
expr_stmt|;
name|hp
operator|->
name|bh_hdrlen
operator|=
name|hdrlen
expr_stmt|;
comment|/* 	 * Copy the packet data into the store buffer and update its length. 	 */
call|(
modifier|*
name|cpfn
call|)
argument_list|(
name|pkt
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|hp
operator|+
name|hdrlen
argument_list|,
operator|(
name|hp
operator|->
name|bh_caplen
operator|=
name|totlen
operator|-
name|hdrlen
operator|)
argument_list|)
expr_stmt|;
name|d
operator|->
name|bd_slen
operator|=
name|curlen
operator|+
name|totlen
expr_stmt|;
block|}
comment|/*  * Initialize all nonzero fields of a descriptor.  */
specifier|static
name|int
name|bpf_allocbufs
parameter_list|(
name|d
parameter_list|)
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
block|{
name|d
operator|->
name|bd_fbuf
operator|=
operator|(
name|caddr_t
operator|)
name|malloc
argument_list|(
name|d
operator|->
name|bd_bufsize
argument_list|,
name|M_BPF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_fbuf
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|d
operator|->
name|bd_sbuf
operator|=
operator|(
name|caddr_t
operator|)
name|malloc
argument_list|(
name|d
operator|->
name|bd_bufsize
argument_list|,
name|M_BPF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_sbuf
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|d
operator|->
name|bd_fbuf
argument_list|,
name|M_BPF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|d
operator|->
name|bd_slen
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|bd_hlen
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*  * Free buffers currently in use by a descriptor.  * Called on close.  */
specifier|static
name|void
name|bpf_freed
parameter_list|(
name|d
parameter_list|)
specifier|register
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
block|{
comment|/* 	 * We don't need to lock out interrupts since this descriptor has 	 * been detached from its interface and it yet hasn't been marked 	 * free. 	 */
if|if
condition|(
name|d
operator|->
name|bd_sbuf
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|d
operator|->
name|bd_sbuf
argument_list|,
name|M_BPF
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_hbuf
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|d
operator|->
name|bd_hbuf
argument_list|,
name|M_BPF
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|->
name|bd_fbuf
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|d
operator|->
name|bd_fbuf
argument_list|,
name|M_BPF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|d
operator|->
name|bd_filter
condition|)
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|d
operator|->
name|bd_filter
argument_list|,
name|M_BPF
argument_list|)
expr_stmt|;
block|}
comment|/*  * Attach an interface to bpf.  driverp is a pointer to a (struct bpf_if *)  * in the driver's softc; dlt is the link layer type; hdrlen is the fixed  * size of the link header (variable length headers not yet supported).  */
name|void
name|bpfattach
parameter_list|(
name|ifp
parameter_list|,
name|dlt
parameter_list|,
name|hdrlen
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int
name|dlt
decl_stmt|,
name|hdrlen
decl_stmt|;
block|{
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
operator|(
expr|struct
name|bpf_if
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bp
argument_list|)
argument_list|,
name|M_BPF
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"bpfattach"
argument_list|)
expr_stmt|;
name|bp
operator|->
name|bif_dlist
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|bif_ifp
operator|=
name|ifp
expr_stmt|;
name|bp
operator|->
name|bif_dlt
operator|=
name|dlt
expr_stmt|;
name|bp
operator|->
name|bif_next
operator|=
name|bpf_iflist
expr_stmt|;
name|bpf_iflist
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|bif_ifp
operator|->
name|if_bpf
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Compute the length of the bpf header.  This is not necessarily 	 * equal to SIZEOF_BPF_HDR because we want to insert spacing such 	 * that the network layer header begins on a longword boundary (for 	 * performance reasons and to alleviate alignment restrictions). 	 */
name|bp
operator|->
name|bif_hdrlen
operator|=
name|BPF_WORDALIGN
argument_list|(
name|hdrlen
operator|+
name|SIZEOF_BPF_HDR
argument_list|)
operator|-
name|hdrlen
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"bpf: %s%d attached\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
comment|/*  * Detach bpf from an interface.  This involves detaching each descriptor  * associated with the interface, and leaving bd_bif NULL.  Notify each  * descriptor as it's detached so that any sleepers wake up and get  * ENXIO.  */
name|void
name|bpfdetach
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|bpf_if
modifier|*
name|bp
decl_stmt|,
modifier|*
name|bp_prev
decl_stmt|;
name|struct
name|bpf_d
modifier|*
name|d
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* Locate BPF interface information */
name|bp_prev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|bpf_iflist
init|;
name|bp
operator|!=
name|NULL
condition|;
name|bp
operator|=
name|bp
operator|->
name|bif_next
control|)
block|{
if|if
condition|(
name|ifp
operator|==
name|bp
operator|->
name|bif_ifp
condition|)
break|break;
name|bp_prev
operator|=
name|bp
expr_stmt|;
block|}
comment|/* Interface wasn't attached */
if|if
condition|(
name|bp
operator|->
name|bif_ifp
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bpfdetach: %s%d was not attached\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|d
operator|=
name|bp
operator|->
name|bif_dlist
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bpf_detachd
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|bpf_wakeup
argument_list|(
name|d
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp_prev
condition|)
block|{
name|bp_prev
operator|->
name|bif_next
operator|=
name|bp
operator|->
name|bif_next
expr_stmt|;
block|}
else|else
block|{
name|bpf_iflist
operator|=
name|bp
operator|->
name|bif_next
expr_stmt|;
block|}
name|free
argument_list|(
name|bp
argument_list|,
name|M_BPF
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|bpf_drvinit
name|__P
argument_list|(
operator|(
name|void
operator|*
name|unused
operator|)
argument_list|)
decl_stmt|;
specifier|static
name|void
name|bpf_clone
name|__P
argument_list|(
operator|(
name|void
operator|*
name|arg
operator|,
name|char
operator|*
name|name
operator|,
name|int
name|namelen
operator|,
name|dev_t
operator|*
name|dev
operator|)
argument_list|)
decl_stmt|;
specifier|static
name|void
name|bpf_clone
parameter_list|(
name|arg
parameter_list|,
name|name
parameter_list|,
name|namelen
parameter_list|,
name|dev
parameter_list|)
name|void
modifier|*
name|arg
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|dev_t
modifier|*
name|dev
decl_stmt|;
block|{
name|int
name|u
decl_stmt|;
if|if
condition|(
operator|*
name|dev
operator|!=
name|NODEV
condition|)
return|return;
if|if
condition|(
name|dev_stdclone
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
literal|"bpf"
argument_list|,
operator|&
name|u
argument_list|)
operator|!=
literal|1
condition|)
return|return;
operator|*
name|dev
operator|=
name|make_dev
argument_list|(
operator|&
name|bpf_cdevsw
argument_list|,
name|unit2minor
argument_list|(
name|u
argument_list|)
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"bpf%d"
argument_list|,
name|u
argument_list|)
expr_stmt|;
operator|(
operator|*
name|dev
operator|)
operator|->
name|si_flags
operator||=
name|SI_CHEAPCLONE
expr_stmt|;
return|return;
block|}
specifier|static
name|void
name|bpf_drvinit
parameter_list|(
name|unused
parameter_list|)
name|void
modifier|*
name|unused
decl_stmt|;
block|{
name|EVENTHANDLER_REGISTER
argument_list|(
name|dev_clone
argument_list|,
name|bpf_clone
argument_list|,
literal|0
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|bpf_cdevsw
argument_list|)
expr_stmt|;
block|}
name|SYSINIT
argument_list|(
argument|bpfdev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|bpf_drvinit
argument_list|,
argument|NULL
argument_list|)
else|#
directive|else
comment|/* !BPF */
comment|/*  * NOP stubs to allow bpf-using drivers to load and function.  *  * A 'better' implementation would allow the core bpf functionality  * to be loaded at runtime.  */
name|void
name|bpf_tap
parameter_list|(
name|ifp
parameter_list|,
name|pkt
parameter_list|,
name|pktlen
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|pkt
decl_stmt|;
specifier|register
name|u_int
name|pktlen
decl_stmt|;
block|{ }
name|void
name|bpf_mtap
parameter_list|(
name|ifp
parameter_list|,
name|m
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{ }
name|void
name|bpfattach
parameter_list|(
name|ifp
parameter_list|,
name|dlt
parameter_list|,
name|hdrlen
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int
name|dlt
decl_stmt|,
name|hdrlen
decl_stmt|;
block|{ }
name|void
name|bpfdetach
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{ }
name|u_int
name|bpf_filter
parameter_list|(
name|pc
parameter_list|,
name|p
parameter_list|,
name|wirelen
parameter_list|,
name|buflen
parameter_list|)
specifier|register
specifier|const
name|struct
name|bpf_insn
modifier|*
name|pc
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|p
decl_stmt|;
name|u_int
name|wirelen
decl_stmt|;
specifier|register
name|u_int
name|buflen
decl_stmt|;
block|{
return|return
operator|-
literal|1
return|;
comment|/* "no filter" behaviour */
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !BPF */
end_comment

end_unit

