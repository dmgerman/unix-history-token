begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: if_bridge.c,v 1.31 2005/06/01 19:45:34 jdc Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright 2001 Wasabi Systems, Inc.  * All rights reserved.  *  * Written by Jason R. Thorpe for Wasabi Systems, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed for the NetBSD Project by  *	Wasabi Systems, Inc.  * 4. The name of Wasabi Systems, Inc. may not be used to endorse  *    or promote products derived from this software without specific prior  *    written permission.  *  * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1999, 2000 Jason L. Wright (jason@thought.net)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * OpenBSD: if_bridge.c,v 1.60 2001/06/15 03:38:33 itojun Exp  */
end_comment

begin_comment
comment|/*  * Network interface bridge support.  *  * TODO:  *  *	- Currently only supports Ethernet-like interfaces (Ethernet,  *	  802.11, VLANs on Ethernet, etc.)  Figure out a nice way  *	  to bridge other types of interfaces (FDDI-FDDI, and maybe  *	  consider heterogeneous bridges).  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_comment
comment|/* for net/if.h */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_comment
comment|/* string functions */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_clone.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/pfil.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_ifattach.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/ip_carp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<net/bridgestp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_bridgevar.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_comment
comment|/*  * Size of the route hash table.  Must be a power of two.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BRIDGE_RTHASH_SIZE
end_ifndef

begin_define
define|#
directive|define
name|BRIDGE_RTHASH_SIZE
value|1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BRIDGE_RTHASH_MASK
value|(BRIDGE_RTHASH_SIZE - 1)
end_define

begin_comment
comment|/*  * Default maximum number of addresses to cache.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BRIDGE_RTABLE_MAX
end_ifndef

begin_define
define|#
directive|define
name|BRIDGE_RTABLE_MAX
value|2000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Timeout (in seconds) for entries learned dynamically.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BRIDGE_RTABLE_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|BRIDGE_RTABLE_TIMEOUT
value|(20 * 60)
end_define

begin_comment
comment|/* same as ARP */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Number of seconds between walks of the route list.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BRIDGE_RTABLE_PRUNE_PERIOD
end_ifndef

begin_define
define|#
directive|define
name|BRIDGE_RTABLE_PRUNE_PERIOD
value|(5 * 60)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * List of capabilities to possibly mask on the member interface.  */
end_comment

begin_define
define|#
directive|define
name|BRIDGE_IFCAPS_MASK
value|(IFCAP_TOE|IFCAP_TSO|IFCAP_TXCSUM|\ 					 IFCAP_TXCSUM_IPV6)
end_define

begin_comment
comment|/*  * List of capabilities to strip  */
end_comment

begin_define
define|#
directive|define
name|BRIDGE_IFCAPS_STRIP
value|IFCAP_LRO
end_define

begin_comment
comment|/*  * Bridge interface list entry.  */
end_comment

begin_struct
struct|struct
name|bridge_iflist
block|{
name|LIST_ENTRY
argument_list|(
argument|bridge_iflist
argument_list|)
name|bif_next
expr_stmt|;
name|struct
name|ifnet
modifier|*
name|bif_ifp
decl_stmt|;
comment|/* member if */
name|struct
name|bstp_port
name|bif_stp
decl_stmt|;
comment|/* STP state */
name|uint32_t
name|bif_flags
decl_stmt|;
comment|/* member if flags */
name|int
name|bif_savedcaps
decl_stmt|;
comment|/* saved capabilities */
name|uint32_t
name|bif_addrmax
decl_stmt|;
comment|/* max # of addresses */
name|uint32_t
name|bif_addrcnt
decl_stmt|;
comment|/* cur. # of addresses */
name|uint32_t
name|bif_addrexceeded
decl_stmt|;
comment|/* # of address violations */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Bridge route node.  */
end_comment

begin_struct
struct|struct
name|bridge_rtnode
block|{
name|LIST_ENTRY
argument_list|(
argument|bridge_rtnode
argument_list|)
name|brt_hash
expr_stmt|;
comment|/* hash table linkage */
name|LIST_ENTRY
argument_list|(
argument|bridge_rtnode
argument_list|)
name|brt_list
expr_stmt|;
comment|/* list linkage */
name|struct
name|bridge_iflist
modifier|*
name|brt_dst
decl_stmt|;
comment|/* destination if */
name|unsigned
name|long
name|brt_expire
decl_stmt|;
comment|/* expiration time */
name|uint8_t
name|brt_flags
decl_stmt|;
comment|/* address flags */
name|uint8_t
name|brt_addr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|uint16_t
name|brt_vlan
decl_stmt|;
comment|/* vlan id */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|brt_ifp
value|brt_dst->bif_ifp
end_define

begin_comment
comment|/*  * Software state for each bridge.  */
end_comment

begin_struct
struct|struct
name|bridge_softc
block|{
name|struct
name|ifnet
modifier|*
name|sc_ifp
decl_stmt|;
comment|/* make this an interface */
name|LIST_ENTRY
argument_list|(
argument|bridge_softc
argument_list|)
name|sc_list
expr_stmt|;
name|struct
name|mtx
name|sc_mtx
decl_stmt|;
name|struct
name|cv
name|sc_cv
decl_stmt|;
name|uint32_t
name|sc_brtmax
decl_stmt|;
comment|/* max # of addresses */
name|uint32_t
name|sc_brtcnt
decl_stmt|;
comment|/* cur. # of addresses */
name|uint32_t
name|sc_brttimeout
decl_stmt|;
comment|/* rt timeout in seconds */
name|struct
name|callout
name|sc_brcallout
decl_stmt|;
comment|/* bridge callout */
name|uint32_t
name|sc_iflist_ref
decl_stmt|;
comment|/* refcount for sc_iflist */
name|uint32_t
name|sc_iflist_xcnt
decl_stmt|;
comment|/* refcount for sc_iflist */
name|LIST_HEAD
argument_list|(
argument_list|,
argument|bridge_iflist
argument_list|)
name|sc_iflist
expr_stmt|;
comment|/* member interface list */
name|LIST_HEAD
argument_list|(,
name|bridge_rtnode
argument_list|)
operator|*
name|sc_rthash
expr_stmt|;
comment|/* our forwarding table */
name|LIST_HEAD
argument_list|(
argument_list|,
argument|bridge_rtnode
argument_list|)
name|sc_rtlist
expr_stmt|;
comment|/* list version of above */
name|uint32_t
name|sc_rthash_key
decl_stmt|;
comment|/* key for hash */
name|LIST_HEAD
argument_list|(
argument_list|,
argument|bridge_iflist
argument_list|)
name|sc_spanlist
expr_stmt|;
comment|/* span ports list */
name|struct
name|bstp_state
name|sc_stp
decl_stmt|;
comment|/* STP state */
name|uint32_t
name|sc_brtexceeded
decl_stmt|;
comment|/* # of cache drops */
name|struct
name|ifnet
modifier|*
name|sc_ifaddr
decl_stmt|;
comment|/* member mac copied from */
name|u_char
name|sc_defaddr
index|[
literal|6
index|]
decl_stmt|;
comment|/* Default MAC address */
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|mtx
argument_list|,
name|bridge_list_mtx
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_bridge_list_mtx
value|VNET(bridge_list_mtx)
end_define

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|bridge_detach_cookie
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bridge_rtable_prune_period
init|=
name|BRIDGE_RTABLE_PRUNE_PERIOD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uma_zone_t
name|bridge_rtnode_zone
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|bridge_clone_create
parameter_list|(
name|struct
name|if_clone
modifier|*
parameter_list|,
name|int
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_clone_destroy
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_mutecaps
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_set_ifcap
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|bridge_iflist
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_ifdetach
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_dummynet
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|bridge_input
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_output
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|struct
name|rtentry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_enqueue
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_rtdelete
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_forward
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|bridge_iflist
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_timer
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_broadcast
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_span
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_rtupdate
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|uint16_t
parameter_list|,
name|struct
name|bridge_iflist
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ifnet
modifier|*
name|bridge_rtlookup
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_rttrim
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_rtage
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_rtflush
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_rtdaddr
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_rtable_init
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_rtable_fini
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_rtnode_addr_cmp
parameter_list|(
specifier|const
name|uint8_t
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|bridge_rtnode
modifier|*
name|bridge_rtnode_lookup
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_rtnode_insert
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|bridge_rtnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_rtnode_destroy
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|bridge_rtnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_rtable_expire
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_state_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|bridge_iflist
modifier|*
name|bridge_lookup_member
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|bridge_iflist
modifier|*
name|bridge_lookup_member_if
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_delete_member
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|bridge_iflist
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_delete_span
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|bridge_iflist
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_add
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_del
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_gifflags
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_sifflags
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_scache
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_gcache
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_gifs
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_rts
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_saddr
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_sto
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_gto
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_daddr
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_flush
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_gpri
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_spri
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_ght
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_sht
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_gfd
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_sfd
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_gma
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_sma
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_sifprio
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_sifcost
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_sifmaxaddr
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_addspan
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_delspan
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_gbparam
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_grte
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_gifsstp
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_sproto
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_stxhc
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_pfil
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ip_checkbasic
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function_decl
specifier|static
name|int
name|bridge_ip6_checkbasic
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_function_decl
specifier|static
name|int
name|bridge_fragment
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|struct
name|ether_header
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|llc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_linkstate
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_linkcheck
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|bridge_linkstate_p
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* The default bridge vlan is 1 (IEEE 802.1Q-2003 Table 9-2) */
end_comment

begin_define
define|#
directive|define
name|VLANTAGOF
parameter_list|(
name|_m
parameter_list|)
define|\
value|(_m->m_flags& M_VLANTAG) ? EVL_VLANOFTAG(_m->m_pkthdr.ether_vtag) : 1
end_define

begin_decl_stmt
specifier|static
name|struct
name|bstp_cb_ops
name|bridge_ops
init|=
block|{
operator|.
name|bcb_state
operator|=
name|bridge_state_change
block|,
operator|.
name|bcb_rtage
operator|=
name|bridge_rtable_expire
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_link
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_net_link
argument_list|,
name|IFT_BRIDGE
argument_list|,
name|bridge
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Bridge"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* only pass IP[46] packets when pfil is enabled */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|pfil_onlyip
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pfil_onlyip
value|VNET(pfil_onlyip)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_link_bridge
argument_list|,
name|OID_AUTO
argument_list|,
name|pfil_onlyip
argument_list|,
name|CTLFLAG_RWTUN
operator||
name|CTLFLAG_VNET
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|pfil_onlyip
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Only pass IP packets when pfil is enabled"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* run pfil hooks on the bridge interface */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|pfil_bridge
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pfil_bridge
value|VNET(pfil_bridge)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_link_bridge
argument_list|,
name|OID_AUTO
argument_list|,
name|pfil_bridge
argument_list|,
name|CTLFLAG_RWTUN
operator||
name|CTLFLAG_VNET
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|pfil_bridge
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Packet filter on the bridge interface"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* layer2 filter with ipfw */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|pfil_ipfw
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pfil_ipfw
value|VNET(pfil_ipfw)
end_define

begin_comment
comment|/* layer2 ARP filter with ipfw */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|pfil_ipfw_arp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pfil_ipfw_arp
value|VNET(pfil_ipfw_arp)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_link_bridge
argument_list|,
name|OID_AUTO
argument_list|,
name|ipfw_arp
argument_list|,
name|CTLFLAG_RWTUN
operator||
name|CTLFLAG_VNET
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|pfil_ipfw_arp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Filter ARP packets through IPFW layer2"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* run pfil hooks on the member interface */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|pfil_member
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pfil_member
value|VNET(pfil_member)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_link_bridge
argument_list|,
name|OID_AUTO
argument_list|,
name|pfil_member
argument_list|,
name|CTLFLAG_RWTUN
operator||
name|CTLFLAG_VNET
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|pfil_member
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Packet filter on the member interface"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* run pfil hooks on the physical interface for locally destined packets */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|pfil_local_phys
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_pfil_local_phys
value|VNET(pfil_local_phys)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_link_bridge
argument_list|,
name|OID_AUTO
argument_list|,
name|pfil_local_phys
argument_list|,
name|CTLFLAG_RWTUN
operator||
name|CTLFLAG_VNET
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|pfil_local_phys
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Packet filter on the physical interface for locally destined packets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* log STP state changes */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|log_stp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_log_stp
value|VNET(log_stp)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_link_bridge
argument_list|,
name|OID_AUTO
argument_list|,
name|log_stp
argument_list|,
name|CTLFLAG_RWTUN
operator||
name|CTLFLAG_VNET
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|log_stp
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Log STP state changes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* share MAC with first bridge member */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|bridge_inherit_mac
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_bridge_inherit_mac
value|VNET(bridge_inherit_mac)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_link_bridge
argument_list|,
name|OID_AUTO
argument_list|,
name|inherit_mac
argument_list|,
name|CTLFLAG_RWTUN
operator||
name|CTLFLAG_VNET
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|bridge_inherit_mac
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Inherit MAC address from the first bridge member"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|allow_llz_overlap
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_allow_llz_overlap
value|VNET(allow_llz_overlap)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_link_bridge
argument_list|,
name|OID_AUTO
argument_list|,
name|allow_llz_overlap
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLFLAG_VNET
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|allow_llz_overlap
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Allow overlap of link-local scope "
literal|"zones of a bridge interface and the member interfaces"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|bridge_control
block|{
name|int
function_decl|(
modifier|*
name|bc_func
function_decl|)
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|int
name|bc_argsize
decl_stmt|;
name|int
name|bc_flags
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|BC_F_COPYIN
value|0x01
end_define

begin_comment
comment|/* copy arguments in */
end_comment

begin_define
define|#
directive|define
name|BC_F_COPYOUT
value|0x02
end_define

begin_comment
comment|/* copy arguments out */
end_comment

begin_define
define|#
directive|define
name|BC_F_SUSER
value|0x04
end_define

begin_comment
comment|/* do super-user check */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|bridge_control
name|bridge_control_table
index|[]
init|=
block|{
block|{
name|bridge_ioctl_add
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_del
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_gifflags
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_sifflags
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_scache
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_gcache
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_gifs
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbifconf
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_rts
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbaconf
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_saddr
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbareq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_sto
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_gto
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_daddr
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbareq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_flush
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_gpri
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_spri
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_ght
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_sht
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_gfd
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_sfd
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_gma
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_sma
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_sifprio
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_sifcost
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_addspan
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_delspan
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_gbparam
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbropreq
argument_list|)
block|,
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_grte
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_gifsstp
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbpstpconf
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_sproto
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_stxhc
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_sifmaxaddr
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,  }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|bridge_control_table_size
init|=
name|nitems
argument_list|(
name|bridge_control_table
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|LIST_HEAD
argument_list|(,
name|bridge_softc
argument_list|)
argument_list|,
name|bridge_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_bridge_list
value|VNET(bridge_list)
end_define

begin_define
define|#
directive|define
name|BRIDGE_LIST_LOCK_INIT
parameter_list|(
name|x
parameter_list|)
value|mtx_init(&V_bridge_list_mtx,	\ 					    "if_bridge list", NULL, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|BRIDGE_LIST_LOCK_DESTROY
parameter_list|(
name|x
parameter_list|)
value|mtx_destroy(&V_bridge_list_mtx)
end_define

begin_define
define|#
directive|define
name|BRIDGE_LIST_LOCK
parameter_list|(
name|x
parameter_list|)
value|mtx_lock(&V_bridge_list_mtx)
end_define

begin_define
define|#
directive|define
name|BRIDGE_LIST_UNLOCK
parameter_list|(
name|x
parameter_list|)
value|mtx_unlock(&V_bridge_list_mtx)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|if_clone
operator|*
argument_list|,
name|bridge_cloner
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_bridge_cloner
value|VNET(bridge_cloner)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
name|bridge_name
index|[]
init|=
literal|"bridge"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|vnet_bridge_init
parameter_list|(
specifier|const
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|BRIDGE_LIST_LOCK_INIT
argument_list|()
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|V_bridge_list
argument_list|)
expr_stmt|;
name|V_bridge_cloner
operator|=
name|if_clone_simple
argument_list|(
name|bridge_name
argument_list|,
name|bridge_clone_create
argument_list|,
name|bridge_clone_destroy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|VNET_SYSINIT
argument_list|(
name|vnet_bridge_init
argument_list|,
name|SI_SUB_PROTO_IFATTACHDOMAIN
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|vnet_bridge_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|vnet_bridge_uninit
parameter_list|(
specifier|const
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|if_clone_detach
argument_list|(
name|V_bridge_cloner
argument_list|)
expr_stmt|;
name|V_bridge_cloner
operator|=
name|NULL
expr_stmt|;
name|BRIDGE_LIST_LOCK_DESTROY
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|VNET_SYSUNINIT
argument_list|(
name|vnet_bridge_uninit
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|vnet_bridge_uninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|bridge_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|bridge_rtnode_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"bridge_rtnode"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bridge_rtnode
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bridge_input_p
operator|=
name|bridge_input
expr_stmt|;
name|bridge_output_p
operator|=
name|bridge_output
expr_stmt|;
name|bridge_dn_p
operator|=
name|bridge_dummynet
expr_stmt|;
name|bridge_linkstate_p
operator|=
name|bridge_linkstate
expr_stmt|;
name|bridge_detach_cookie
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|ifnet_departure_event
argument_list|,
name|bridge_ifdetach
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|ifnet_departure_event
argument_list|,
name|bridge_detach_cookie
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|bridge_rtnode_zone
argument_list|)
expr_stmt|;
name|bridge_input_p
operator|=
name|NULL
expr_stmt|;
name|bridge_output_p
operator|=
name|NULL
expr_stmt|;
name|bridge_dn_p
operator|=
name|NULL
expr_stmt|;
name|bridge_linkstate_p
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|bridge_mod
init|=
block|{
literal|"if_bridge"
block|,
name|bridge_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|if_bridge
argument_list|,
name|bridge_mod
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|if_bridge
argument_list|,
name|bridgestp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * handler for net.link.bridge.ipfw  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_pfil_ipfw
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|enable
init|=
name|V_pfil_ipfw
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|enable
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|enable
operator|&=
literal|1
expr_stmt|;
if|if
condition|(
name|enable
operator|!=
name|V_pfil_ipfw
condition|)
block|{
name|V_pfil_ipfw
operator|=
name|enable
expr_stmt|;
comment|/* 		 * Disable pfil so that ipfw doesnt run twice, if the user 		 * really wants both then they can re-enable pfil_bridge and/or 		 * pfil_member. Also allow non-ip packets as ipfw can filter by 		 * layer2 type. 		 */
if|if
condition|(
name|V_pfil_ipfw
condition|)
block|{
name|V_pfil_onlyip
operator|=
literal|0
expr_stmt|;
name|V_pfil_bridge
operator|=
literal|0
expr_stmt|;
name|V_pfil_member
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_link_bridge
argument_list|,
name|OID_AUTO
argument_list|,
name|ipfw
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_VNET
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|pfil_ipfw
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|sysctl_pfil_ipfw
argument_list|,
literal|"I"
argument_list|,
literal|"Layer2 filter with IPFW"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * bridge_clone_create:  *  *	Create a new bridge instance.  */
end_comment

begin_function
specifier|static
name|int
name|bridge_clone_create
parameter_list|(
name|struct
name|if_clone
modifier|*
name|ifc
parameter_list|,
name|int
name|unit
parameter_list|,
name|caddr_t
name|params
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
decl_stmt|,
modifier|*
name|sc2
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|bifp
decl_stmt|,
modifier|*
name|ifp
decl_stmt|;
name|int
name|fb
decl_stmt|,
name|retry
decl_stmt|;
name|unsigned
name|long
name|hostid
decl_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|BRIDGE_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_brtmax
operator|=
name|BRIDGE_RTABLE_MAX
expr_stmt|;
name|sc
operator|->
name|sc_brttimeout
operator|=
name|BRIDGE_RTABLE_TIMEOUT
expr_stmt|;
comment|/* Initialize our routing table. */
name|bridge_rtable_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_brcallout
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_iflist
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_spanlist
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|bridge_name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|bridge_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_transmit
operator|=
name|bridge_transmit
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|bridge_qflush
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|bridge_init
expr_stmt|;
name|ifp
operator|->
name|if_type
operator|=
name|IFT_BRIDGE
expr_stmt|;
comment|/* 	 * Generate an ethernet address with a locally administered address. 	 * 	 * Since we are using random ethernet addresses for the bridge, it is 	 * possible that we might have address collisions, so make sure that 	 * this hardware address isn't already in use on another bridge. 	 * The first try uses the hostid and falls back to arc4rand(). 	 */
name|fb
operator|=
literal|0
expr_stmt|;
name|getcredhostid
argument_list|(
name|curthread
operator|->
name|td_ucred
argument_list|,
operator|&
name|hostid
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|fb
operator|||
name|hostid
operator|==
literal|0
condition|)
block|{
name|arc4rand
argument_list|(
name|sc
operator|->
name|sc_defaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_defaddr
index|[
literal|0
index|]
operator|&=
operator|~
literal|1
expr_stmt|;
comment|/* clear multicast bit */
name|sc
operator|->
name|sc_defaddr
index|[
literal|0
index|]
operator||=
literal|2
expr_stmt|;
comment|/* set the LAA bit */
block|}
else|else
block|{
name|sc
operator|->
name|sc_defaddr
index|[
literal|0
index|]
operator|=
literal|0x2
expr_stmt|;
name|sc
operator|->
name|sc_defaddr
index|[
literal|1
index|]
operator|=
operator|(
name|hostid
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|sc_defaddr
index|[
literal|2
index|]
operator|=
operator|(
name|hostid
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|sc_defaddr
index|[
literal|3
index|]
operator|=
operator|(
name|hostid
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|sc_defaddr
index|[
literal|4
index|]
operator|=
name|hostid
operator|&
literal|0xff
expr_stmt|;
name|sc
operator|->
name|sc_defaddr
index|[
literal|5
index|]
operator|=
name|ifp
operator|->
name|if_dunit
operator|&
literal|0xff
expr_stmt|;
block|}
name|fb
operator|=
literal|1
expr_stmt|;
name|retry
operator|=
literal|0
expr_stmt|;
name|BRIDGE_LIST_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sc2
argument_list|,
argument|&V_bridge_list
argument_list|,
argument|sc_list
argument_list|)
block|{
name|bifp
operator|=
name|sc2
operator|->
name|sc_ifp
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|sc
operator|->
name|sc_defaddr
argument_list|,
name|IF_LLADDR
argument_list|(
name|bifp
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|retry
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|BRIDGE_LIST_UNLOCK
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|retry
operator|==
literal|1
condition|)
do|;
name|bstp_attach
argument_list|(
operator|&
name|sc
operator|->
name|sc_stp
argument_list|,
operator|&
name|bridge_ops
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|sc
operator|->
name|sc_defaddr
argument_list|)
expr_stmt|;
comment|/* Now undo some of the damage... */
name|ifp
operator|->
name|if_baudrate
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_type
operator|=
name|IFT_BRIDGE
expr_stmt|;
name|BRIDGE_LIST_LOCK
argument_list|()
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|V_bridge_list
argument_list|,
name|sc
argument_list|,
name|sc_list
argument_list|)
expr_stmt|;
name|BRIDGE_LIST_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_clone_destroy:  *  *	Destroy a bridge instance.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_clone_destroy
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bridge_stop
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
while|while
condition|(
operator|(
name|bif
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_iflist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|bridge_delete_member
argument_list|(
name|sc
argument_list|,
name|bif
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|bif
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_spanlist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bridge_delete_span
argument_list|(
name|sc
argument_list|,
name|bif
argument_list|)
expr_stmt|;
block|}
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_brcallout
argument_list|)
expr_stmt|;
name|BRIDGE_LIST_LOCK
argument_list|()
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sc
argument_list|,
name|sc_list
argument_list|)
expr_stmt|;
name|BRIDGE_LIST_UNLOCK
argument_list|()
expr_stmt|;
name|bstp_detach
argument_list|(
operator|&
name|sc
operator|->
name|sc_stp
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* Tear down the routing table. */
name|bridge_rtable_fini
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BRIDGE_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_ioctl:  *  *	Handle a control request from the operator.  */
end_comment

begin_function
specifier|static
name|int
name|bridge_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
union|union
block|{
name|struct
name|ifbreq
name|ifbreq
decl_stmt|;
name|struct
name|ifbifconf
name|ifbifconf
decl_stmt|;
name|struct
name|ifbareq
name|ifbareq
decl_stmt|;
name|struct
name|ifbaconf
name|ifbaconf
decl_stmt|;
name|struct
name|ifbrparam
name|ifbrparam
decl_stmt|;
name|struct
name|ifbropreq
name|ifbropreq
decl_stmt|;
block|}
name|args
union|;
name|struct
name|ifdrv
modifier|*
name|ifd
init|=
operator|(
expr|struct
name|ifdrv
operator|*
operator|)
name|data
decl_stmt|;
specifier|const
name|struct
name|bridge_control
modifier|*
name|bc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
break|break;
case|case
name|SIOCGDRVSPEC
case|:
case|case
name|SIOCSDRVSPEC
case|:
if|if
condition|(
name|ifd
operator|->
name|ifd_cmd
operator|>=
name|bridge_control_table_size
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|bc
operator|=
operator|&
name|bridge_control_table
index|[
name|ifd
operator|->
name|ifd_cmd
index|]
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|SIOCGDRVSPEC
operator|&&
operator|(
name|bc
operator|->
name|bc_flags
operator|&
name|BC_F_COPYOUT
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|SIOCSDRVSPEC
operator|&&
operator|(
name|bc
operator|->
name|bc_flags
operator|&
name|BC_F_COPYOUT
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bc
operator|->
name|bc_flags
operator|&
name|BC_F_SUSER
condition|)
block|{
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NET_BRIDGE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
if|if
condition|(
name|ifd
operator|->
name|ifd_len
operator|!=
name|bc
operator|->
name|bc_argsize
operator|||
name|ifd
operator|->
name|ifd_len
operator|>
sizeof|sizeof
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|bzero
argument_list|(
operator|&
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bc
operator|->
name|bc_flags
operator|&
name|BC_F_COPYIN
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|ifd
operator|->
name|ifd_data
argument_list|,
operator|&
name|args
argument_list|,
name|ifd
operator|->
name|ifd_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|bc
operator|->
name|bc_func
call|)
argument_list|(
name|sc
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|bc
operator|->
name|bc_flags
operator|&
name|BC_F_COPYOUT
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|args
argument_list|,
name|ifd
operator|->
name|ifd_data
argument_list|,
name|ifd
operator|->
name|ifd_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
comment|/* 			 * If interface is marked down and it is running, 			 * then stop and disable it. 			 */
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bridge_stop
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
comment|/* 			 * If interface is marked up and it is stopped, then 			 * start it. 			 */
call|(
modifier|*
name|ifp
operator|->
name|if_init
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMTU
case|:
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|<
literal|576
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_iflist
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
break|break;
block|}
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
if|if
condition|(
name|bif
operator|->
name|bif_ifp
operator|->
name|if_mtu
operator|!=
name|ifr
operator|->
name|ifr_mtu
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s: invalid MTU: %u(%s)"
literal|" != %d\n"
argument_list|,
name|sc
operator|->
name|sc_ifp
operator|->
name|if_xname
argument_list|,
name|bif
operator|->
name|bif_ifp
operator|->
name|if_mtu
argument_list|,
name|bif
operator|->
name|bif_ifp
operator|->
name|if_xname
argument_list|,
name|ifr
operator|->
name|ifr_mtu
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|sc
operator|->
name|sc_ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 		 * drop the lock as ether_ioctl() will call bridge_start() and 		 * cause the lock to be recursed. 		 */
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_mutecaps:  *  *	Clear or restore unwanted capabilities on the member interface  */
end_comment

begin_function
specifier|static
name|void
name|bridge_mutecaps
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|int
name|enabled
decl_stmt|,
name|mask
decl_stmt|;
comment|/* Initial bitmask of capabilities to test */
name|mask
operator|=
name|BRIDGE_IFCAPS_MASK
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
comment|/* Every member must support it or its disabled */
name|mask
operator|&=
name|bif
operator|->
name|bif_savedcaps
expr_stmt|;
block|}
name|BRIDGE_XLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
name|enabled
operator|=
name|bif
operator|->
name|bif_ifp
operator|->
name|if_capenable
expr_stmt|;
name|enabled
operator|&=
operator|~
name|BRIDGE_IFCAPS_STRIP
expr_stmt|;
comment|/* strip off mask bits and enable them again if allowed */
name|enabled
operator|&=
operator|~
name|BRIDGE_IFCAPS_MASK
expr_stmt|;
name|enabled
operator||=
name|mask
expr_stmt|;
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bridge_set_ifcap
argument_list|(
name|sc
argument_list|,
name|bif
argument_list|,
name|enabled
argument_list|)
expr_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|BRIDGE_XDROP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bridge_set_ifcap
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bridge_iflist
modifier|*
name|bif
parameter_list|,
name|int
name|set
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|bif
operator|->
name|bif_ifp
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|BRIDGE_UNLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ifr
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
name|ifr
operator|.
name|ifr_reqcap
operator|=
name|set
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|!=
name|set
condition|)
block|{
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_ioctl
call|)
argument_list|(
name|ifp
argument_list|,
name|SIOCSIFCAP
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|if_printf
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
literal|"error setting capabilities on %s: %d\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
operator|~
name|set
operator|)
operator|!=
literal|0
condition|)
name|if_printf
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
literal|"can't disable some capabilities on %s: 0x%x\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|ifp
operator|->
name|if_capenable
operator|&
operator|~
name|set
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * bridge_lookup_member:  *  *	Lookup a bridge member interface.  */
end_comment

begin_function
specifier|static
name|struct
name|bridge_iflist
modifier|*
name|bridge_lookup_member
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
name|ifp
operator|=
name|bif
operator|->
name|bif_ifp
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ifp
operator|->
name|if_xname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|bif
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_lookup_member_if:  *  *	Lookup a bridge member interface by ifnet*.  */
end_comment

begin_function
specifier|static
name|struct
name|bridge_iflist
modifier|*
name|bridge_lookup_member_if
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|member_ifp
parameter_list|)
block|{
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
if|if
condition|(
name|bif
operator|->
name|bif_ifp
operator|==
name|member_ifp
condition|)
return|return
operator|(
name|bif
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_delete_member:  *  *	Delete the specified member interface.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_delete_member
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bridge_iflist
modifier|*
name|bif
parameter_list|,
name|int
name|gone
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifs
init|=
name|bif
operator|->
name|bif_ifp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|fif
init|=
name|NULL
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
condition|)
name|bstp_disable
argument_list|(
operator|&
name|bif
operator|->
name|bif_stp
argument_list|)
expr_stmt|;
name|ifs
operator|->
name|if_bridge
operator|=
name|NULL
expr_stmt|;
name|BRIDGE_XLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bif
argument_list|,
name|bif_next
argument_list|)
expr_stmt|;
name|BRIDGE_XDROP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * If removing the interface that gave the bridge its mac address, set 	 * the mac address of the bridge to the address of the next member, or 	 * to its default address if no members are left. 	 */
if|if
condition|(
name|V_bridge_inherit_mac
operator|&&
name|sc
operator|->
name|sc_ifaddr
operator|==
name|ifs
condition|)
block|{
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_iflist
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_defaddr
argument_list|,
name|IF_LLADDR
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifaddr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|fif
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_iflist
argument_list|)
operator|->
name|bif_ifp
expr_stmt|;
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|fif
argument_list|)
argument_list|,
name|IF_LLADDR
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifaddr
operator|=
name|fif
expr_stmt|;
block|}
name|EVENTHANDLER_INVOKE
argument_list|(
name|iflladdr_event
argument_list|,
name|sc
operator|->
name|sc_ifp
argument_list|)
expr_stmt|;
block|}
name|bridge_linkcheck
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bridge_mutecaps
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* recalcuate now this interface is removed */
name|bridge_rtdelete
argument_list|(
name|sc
argument_list|,
name|ifs
argument_list|,
name|IFBF_FLUSHALL
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|bif
operator|->
name|bif_addrcnt
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: %d bridge routes referenced"
operator|,
name|__func__
operator|,
name|bif
operator|->
name|bif_addrcnt
operator|)
argument_list|)
expr_stmt|;
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gone
condition|)
block|{
switch|switch
condition|(
name|ifs
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ETHER
case|:
case|case
name|IFT_L2VLAN
case|:
comment|/* 			 * Take the interface out of promiscuous mode, but only 			 * if it was promiscuous in the first place. It might 			 * not be if we're in the bridge_ioctl_add() error path. 			 */
if|if
condition|(
name|ifs
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
condition|)
operator|(
name|void
operator|)
name|ifpromisc
argument_list|(
name|ifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IFT_GIF
case|:
break|break;
default|default:
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|panic
argument_list|(
literal|"bridge_delete_member: impossible"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
comment|/* reneable any interface capabilities */
name|bridge_set_ifcap
argument_list|(
name|sc
argument_list|,
name|bif
argument_list|,
name|bif
operator|->
name|bif_savedcaps
argument_list|)
expr_stmt|;
block|}
name|bstp_destroy
argument_list|(
operator|&
name|bif
operator|->
name|bif_stp
argument_list|)
expr_stmt|;
comment|/* prepare to free */
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bif
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_delete_span:  *  *	Delete the specified span interface.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_delete_span
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bridge_iflist
modifier|*
name|bif
parameter_list|)
block|{
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|bif
operator|->
name|bif_ifp
operator|->
name|if_bridge
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: not a span interface"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bif
argument_list|,
name|bif_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bif
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_add
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifs
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ifs
operator|=
name|ifunit
argument_list|(
name|req
operator|->
name|ifbr_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifs
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|ifs
operator|->
name|if_ioctl
operator|==
name|NULL
condition|)
comment|/* must be supported */
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* If it's in the span list, it can't be a member. */
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_spanlist
argument_list|,
argument|bif_next
argument_list|)
if|if
condition|(
name|ifs
operator|==
name|bif
operator|->
name|bif_ifp
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|ifs
operator|->
name|if_bridge
operator|==
name|sc
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
if|if
condition|(
name|ifs
operator|->
name|if_bridge
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
switch|switch
condition|(
name|ifs
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ETHER
case|:
case|case
name|IFT_L2VLAN
case|:
case|case
name|IFT_GIF
case|:
comment|/* permitted interface types */
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|INET6
comment|/* 	 * Two valid inet6 addresses with link-local scope must not be 	 * on the parent interface and the member interfaces at the 	 * same time.  This restriction is needed to prevent violation 	 * of link-local scope zone.  Attempts to add a member 	 * interface which has inet6 addresses when the parent has 	 * inet6 triggers removal of all inet6 addresses on the member 	 * interface. 	 */
comment|/* Check if the parent interface has a link-local scope addr. */
if|if
condition|(
name|V_allow_llz_overlap
operator|==
literal|0
operator|&&
name|in6ifa_llaonifp
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If any, remove all inet6 addresses from the member 		 * interfaces. 		 */
name|BRIDGE_XLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
if|if
condition|(
name|in6ifa_llaonifp
argument_list|(
name|bif
operator|->
name|bif_ifp
argument_list|)
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|in6_ifdetach
argument_list|(
name|bif
operator|->
name|bif_ifp
argument_list|)
expr_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|if_printf
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
literal|"IPv6 addresses on %s have been removed "
literal|"before adding it as a member to prevent "
literal|"IPv6 address scope violation.\n"
argument_list|,
name|bif
operator|->
name|bif_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
block|}
name|BRIDGE_XDROP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|in6ifa_llaonifp
argument_list|(
name|ifs
argument_list|)
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|in6_ifdetach
argument_list|(
name|ifs
argument_list|)
expr_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|if_printf
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
literal|"IPv6 addresses on %s have been removed "
literal|"before adding it as a member to prevent "
literal|"IPv6 address scope violation.\n"
argument_list|,
name|ifs
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Allow the first Ethernet member to define the MTU */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_iflist
argument_list|)
condition|)
name|sc
operator|->
name|sc_ifp
operator|->
name|if_mtu
operator|=
name|ifs
operator|->
name|if_mtu
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_mtu
operator|!=
name|ifs
operator|->
name|if_mtu
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
literal|"invalid MTU: %u(%s) != %u\n"
argument_list|,
name|ifs
operator|->
name|if_mtu
argument_list|,
name|ifs
operator|->
name|if_xname
argument_list|,
name|sc
operator|->
name|sc_ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|bif
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bif
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bif
operator|->
name|bif_ifp
operator|=
name|ifs
expr_stmt|;
name|bif
operator|->
name|bif_flags
operator|=
name|IFBIF_LEARNING
operator||
name|IFBIF_DISCOVER
expr_stmt|;
name|bif
operator|->
name|bif_savedcaps
operator|=
name|ifs
operator|->
name|if_capenable
expr_stmt|;
comment|/* 	 * Assign the interface's MAC address to the bridge if it's the first 	 * member and the MAC address of the bridge has not been changed from 	 * the default randomly generated one. 	 */
if|if
condition|(
name|V_bridge_inherit_mac
operator|&&
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_iflist
argument_list|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|IF_LLADDR
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_defaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifs
argument_list|)
argument_list|,
name|IF_LLADDR
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifaddr
operator|=
name|ifs
expr_stmt|;
name|EVENTHANDLER_INVOKE
argument_list|(
name|iflladdr_event
argument_list|,
name|sc
operator|->
name|sc_ifp
argument_list|)
expr_stmt|;
block|}
name|ifs
operator|->
name|if_bridge
operator|=
name|sc
expr_stmt|;
name|bstp_create
argument_list|(
operator|&
name|sc
operator|->
name|sc_stp
argument_list|,
operator|&
name|bif
operator|->
name|bif_stp
argument_list|,
name|bif
operator|->
name|bif_ifp
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: XLOCK HERE!?! 	 * 	 * NOTE: insert_***HEAD*** should be safe for the traversals. 	 */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_iflist
argument_list|,
name|bif
argument_list|,
name|bif_next
argument_list|)
expr_stmt|;
comment|/* Set interface capabilities to the intersection set of all members */
name|bridge_mutecaps
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bridge_linkcheck
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Place the interface into promiscuous mode */
switch|switch
condition|(
name|ifs
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ETHER
case|:
case|case
name|IFT_L2VLAN
case|:
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifpromisc
argument_list|(
name|ifs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
name|bridge_delete_member
argument_list|(
name|sc
argument_list|,
name|bif
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_del
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|bif
operator|=
name|bridge_lookup_member
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifbr_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|bridge_delete_member
argument_list|(
name|sc
argument_list|,
name|bif
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_gifflags
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|bstp_port
modifier|*
name|bp
decl_stmt|;
name|bif
operator|=
name|bridge_lookup_member
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifbr_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|bp
operator|=
operator|&
name|bif
operator|->
name|bif_stp
expr_stmt|;
name|req
operator|->
name|ifbr_ifsflags
operator|=
name|bif
operator|->
name|bif_flags
expr_stmt|;
name|req
operator|->
name|ifbr_state
operator|=
name|bp
operator|->
name|bp_state
expr_stmt|;
name|req
operator|->
name|ifbr_priority
operator|=
name|bp
operator|->
name|bp_priority
expr_stmt|;
name|req
operator|->
name|ifbr_path_cost
operator|=
name|bp
operator|->
name|bp_path_cost
expr_stmt|;
name|req
operator|->
name|ifbr_portno
operator|=
name|bif
operator|->
name|bif_ifp
operator|->
name|if_index
operator|&
literal|0xfff
expr_stmt|;
name|req
operator|->
name|ifbr_proto
operator|=
name|bp
operator|->
name|bp_protover
expr_stmt|;
name|req
operator|->
name|ifbr_role
operator|=
name|bp
operator|->
name|bp_role
expr_stmt|;
name|req
operator|->
name|ifbr_stpflags
operator|=
name|bp
operator|->
name|bp_flags
expr_stmt|;
name|req
operator|->
name|ifbr_addrcnt
operator|=
name|bif
operator|->
name|bif_addrcnt
expr_stmt|;
name|req
operator|->
name|ifbr_addrmax
operator|=
name|bif
operator|->
name|bif_addrmax
expr_stmt|;
name|req
operator|->
name|ifbr_addrexceeded
operator|=
name|bif
operator|->
name|bif_addrexceeded
expr_stmt|;
comment|/* Copy STP state options as flags */
if|if
condition|(
name|bp
operator|->
name|bp_operedge
condition|)
name|req
operator|->
name|ifbr_ifsflags
operator||=
name|IFBIF_BSTP_EDGE
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_flags
operator|&
name|BSTP_PORT_AUTOEDGE
condition|)
name|req
operator|->
name|ifbr_ifsflags
operator||=
name|IFBIF_BSTP_AUTOEDGE
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_ptp_link
condition|)
name|req
operator|->
name|ifbr_ifsflags
operator||=
name|IFBIF_BSTP_PTP
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_flags
operator|&
name|BSTP_PORT_AUTOPTP
condition|)
name|req
operator|->
name|ifbr_ifsflags
operator||=
name|IFBIF_BSTP_AUTOPTP
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_flags
operator|&
name|BSTP_PORT_ADMEDGE
condition|)
name|req
operator|->
name|ifbr_ifsflags
operator||=
name|IFBIF_BSTP_ADMEDGE
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_flags
operator|&
name|BSTP_PORT_ADMCOST
condition|)
name|req
operator|->
name|ifbr_ifsflags
operator||=
name|IFBIF_BSTP_ADMCOST
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_sifflags
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|bstp_port
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bif
operator|=
name|bridge_lookup_member
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifbr_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|bp
operator|=
operator|&
name|bif
operator|->
name|bif_stp
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|ifbr_ifsflags
operator|&
name|IFBIF_SPAN
condition|)
comment|/* SPAN is readonly */
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|req
operator|->
name|ifbr_ifsflags
operator|&
name|IFBIF_STP
condition|)
block|{
if|if
condition|(
operator|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|bstp_enable
argument_list|(
operator|&
name|bif
operator|->
name|bif_stp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
operator|)
operator|!=
literal|0
condition|)
name|bstp_disable
argument_list|(
operator|&
name|bif
operator|->
name|bif_stp
argument_list|)
expr_stmt|;
block|}
comment|/* Pass on STP flags */
name|bstp_set_edge
argument_list|(
name|bp
argument_list|,
name|req
operator|->
name|ifbr_ifsflags
operator|&
name|IFBIF_BSTP_EDGE
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|bstp_set_autoedge
argument_list|(
name|bp
argument_list|,
name|req
operator|->
name|ifbr_ifsflags
operator|&
name|IFBIF_BSTP_AUTOEDGE
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|bstp_set_ptp
argument_list|(
name|bp
argument_list|,
name|req
operator|->
name|ifbr_ifsflags
operator|&
name|IFBIF_BSTP_PTP
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|bstp_set_autoptp
argument_list|(
name|bp
argument_list|,
name|req
operator|->
name|ifbr_ifsflags
operator|&
name|IFBIF_BSTP_AUTOPTP
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* Save the bits relating to the bridge */
name|bif
operator|->
name|bif_flags
operator|=
name|req
operator|->
name|ifbr_ifsflags
operator|&
name|IFBIFMASK
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_scache
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|sc
operator|->
name|sc_brtmax
operator|=
name|param
operator|->
name|ifbrp_csize
expr_stmt|;
name|bridge_rttrim
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_gcache
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|param
operator|->
name|ifbrp_csize
operator|=
name|sc
operator|->
name|sc_brtmax
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_gifs
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbifconf
modifier|*
name|bifc
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|ifbreq
name|breq
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|outbuf
decl_stmt|;
name|int
name|count
decl_stmt|,
name|buflen
decl_stmt|,
name|len
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
name|count
operator|++
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_spanlist
argument_list|,
argument|bif_next
argument_list|)
name|count
operator|++
expr_stmt|;
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
operator|*
name|count
expr_stmt|;
if|if
condition|(
name|bifc
operator|->
name|ifbic_len
operator|==
literal|0
condition|)
block|{
name|bifc
operator|->
name|ifbic_len
operator|=
name|buflen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|outbuf
operator|=
name|malloc
argument_list|(
name|buflen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|outbuf
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|bifc
operator|->
name|ifbic_len
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|breq
argument_list|,
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
condition|)
break|break;
name|strlcpy
argument_list|(
name|breq
operator|.
name|ifbr_ifsname
argument_list|,
name|bif
operator|->
name|bif_ifp
operator|->
name|if_xname
argument_list|,
sizeof|sizeof
argument_list|(
name|breq
operator|.
name|ifbr_ifsname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill in the ifbreq structure */
name|error
operator|=
name|bridge_ioctl_gifflags
argument_list|(
name|sc
argument_list|,
operator|&
name|breq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|breq
argument_list|,
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
expr_stmt|;
block|}
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_spanlist
argument_list|,
argument|bif_next
argument_list|)
block|{
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
condition|)
break|break;
name|strlcpy
argument_list|(
name|breq
operator|.
name|ifbr_ifsname
argument_list|,
name|bif
operator|->
name|bif_ifp
operator|->
name|if_xname
argument_list|,
sizeof|sizeof
argument_list|(
name|breq
operator|.
name|ifbr_ifsname
argument_list|)
argument_list|)
expr_stmt|;
name|breq
operator|.
name|ifbr_ifsflags
operator|=
name|bif
operator|->
name|bif_flags
expr_stmt|;
name|breq
operator|.
name|ifbr_portno
operator|=
name|bif
operator|->
name|bif_ifp
operator|->
name|if_index
operator|&
literal|0xfff
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|breq
argument_list|,
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
expr_stmt|;
block|}
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bifc
operator|->
name|ifbic_len
operator|=
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
operator|*
name|count
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|outbuf
argument_list|,
name|bifc
operator|->
name|ifbic_req
argument_list|,
name|bifc
operator|->
name|ifbic_len
argument_list|)
expr_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|outbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_rts
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbaconf
modifier|*
name|bac
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|;
name|struct
name|ifbareq
name|bareq
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|outbuf
decl_stmt|;
name|int
name|count
decl_stmt|,
name|buflen
decl_stmt|,
name|len
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|bac
operator|->
name|ifbac_len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|count
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|brt
argument_list|,
argument|&sc->sc_rtlist
argument_list|,
argument|brt_list
argument_list|)
name|count
operator|++
expr_stmt|;
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|bareq
argument_list|)
operator|*
name|count
expr_stmt|;
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|outbuf
operator|=
name|malloc
argument_list|(
name|buflen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|outbuf
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|bac
operator|->
name|ifbac_len
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|bareq
argument_list|,
sizeof|sizeof
argument_list|(
name|bareq
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|brt
argument_list|,
argument|&sc->sc_rtlist
argument_list|,
argument|brt_list
argument_list|)
block|{
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|bareq
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|strlcpy
argument_list|(
name|bareq
operator|.
name|ifba_ifsname
argument_list|,
name|brt
operator|->
name|brt_ifp
operator|->
name|if_xname
argument_list|,
sizeof|sizeof
argument_list|(
name|bareq
operator|.
name|ifba_ifsname
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bareq
operator|.
name|ifba_dst
argument_list|,
name|brt
operator|->
name|brt_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|brt
operator|->
name|brt_addr
argument_list|)
argument_list|)
expr_stmt|;
name|bareq
operator|.
name|ifba_vlan
operator|=
name|brt
operator|->
name|brt_vlan
expr_stmt|;
if|if
condition|(
operator|(
name|brt
operator|->
name|brt_flags
operator|&
name|IFBAF_TYPEMASK
operator|)
operator|==
name|IFBAF_DYNAMIC
operator|&&
name|time_uptime
operator|<
name|brt
operator|->
name|brt_expire
condition|)
name|bareq
operator|.
name|ifba_expire
operator|=
name|brt
operator|->
name|brt_expire
operator|-
name|time_uptime
expr_stmt|;
else|else
name|bareq
operator|.
name|ifba_expire
operator|=
literal|0
expr_stmt|;
name|bareq
operator|.
name|ifba_flags
operator|=
name|brt
operator|->
name|brt_flags
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|bareq
argument_list|,
sizeof|sizeof
argument_list|(
name|bareq
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|bareq
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|bareq
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bac
operator|->
name|ifbac_len
operator|=
sizeof|sizeof
argument_list|(
name|bareq
argument_list|)
operator|*
name|count
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|outbuf
argument_list|,
name|bac
operator|->
name|ifbac_req
argument_list|,
name|bac
operator|->
name|ifbac_len
argument_list|)
expr_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|outbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_saddr
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbareq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bif
operator|=
name|bridge_lookup_member
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifba_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|error
operator|=
name|bridge_rtupdate
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifba_dst
argument_list|,
name|req
operator|->
name|ifba_vlan
argument_list|,
name|bif
argument_list|,
literal|1
argument_list|,
name|req
operator|->
name|ifba_flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_sto
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|sc
operator|->
name|sc_brttimeout
operator|=
name|param
operator|->
name|ifbrp_ctime
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_gto
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|param
operator|->
name|ifbrp_ctime
operator|=
name|sc
operator|->
name|sc_brttimeout
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_daddr
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbareq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
return|return
operator|(
name|bridge_rtdaddr
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifba_dst
argument_list|,
name|req
operator|->
name|ifba_vlan
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_flush
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|bridge_rtflush
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifbr_ifsflags
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_gpri
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|struct
name|bstp_state
modifier|*
name|bs
init|=
operator|&
name|sc
operator|->
name|sc_stp
decl_stmt|;
name|param
operator|->
name|ifbrp_prio
operator|=
name|bs
operator|->
name|bs_bridge_priority
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_spri
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
return|return
operator|(
name|bstp_set_priority
argument_list|(
operator|&
name|sc
operator|->
name|sc_stp
argument_list|,
name|param
operator|->
name|ifbrp_prio
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_ght
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|struct
name|bstp_state
modifier|*
name|bs
init|=
operator|&
name|sc
operator|->
name|sc_stp
decl_stmt|;
name|param
operator|->
name|ifbrp_hellotime
operator|=
name|bs
operator|->
name|bs_bridge_htime
operator|>>
literal|8
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_sht
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
return|return
operator|(
name|bstp_set_htime
argument_list|(
operator|&
name|sc
operator|->
name|sc_stp
argument_list|,
name|param
operator|->
name|ifbrp_hellotime
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_gfd
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|struct
name|bstp_state
modifier|*
name|bs
init|=
operator|&
name|sc
operator|->
name|sc_stp
decl_stmt|;
name|param
operator|->
name|ifbrp_fwddelay
operator|=
name|bs
operator|->
name|bs_bridge_fdelay
operator|>>
literal|8
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_sfd
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
return|return
operator|(
name|bstp_set_fdelay
argument_list|(
operator|&
name|sc
operator|->
name|sc_stp
argument_list|,
name|param
operator|->
name|ifbrp_fwddelay
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_gma
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|struct
name|bstp_state
modifier|*
name|bs
init|=
operator|&
name|sc
operator|->
name|sc_stp
decl_stmt|;
name|param
operator|->
name|ifbrp_maxage
operator|=
name|bs
operator|->
name|bs_bridge_max_age
operator|>>
literal|8
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_sma
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
return|return
operator|(
name|bstp_set_maxage
argument_list|(
operator|&
name|sc
operator|->
name|sc_stp
argument_list|,
name|param
operator|->
name|ifbrp_maxage
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_sifprio
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|bif
operator|=
name|bridge_lookup_member
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifbr_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
return|return
operator|(
name|bstp_set_port_priority
argument_list|(
operator|&
name|bif
operator|->
name|bif_stp
argument_list|,
name|req
operator|->
name|ifbr_priority
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_sifcost
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|bif
operator|=
name|bridge_lookup_member
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifbr_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
return|return
operator|(
name|bstp_set_path_cost
argument_list|(
operator|&
name|bif
operator|->
name|bif_stp
argument_list|,
name|req
operator|->
name|ifbr_path_cost
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_sifmaxaddr
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|bif
operator|=
name|bridge_lookup_member
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifbr_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|bif
operator|->
name|bif_addrmax
operator|=
name|req
operator|->
name|ifbr_addrmax
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_addspan
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifs
decl_stmt|;
name|ifs
operator|=
name|ifunit
argument_list|(
name|req
operator|->
name|ifbr_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifs
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_spanlist
argument_list|,
argument|bif_next
argument_list|)
if|if
condition|(
name|ifs
operator|==
name|bif
operator|->
name|bif_ifp
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|ifs
operator|->
name|if_bridge
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
switch|switch
condition|(
name|ifs
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ETHER
case|:
case|case
name|IFT_GIF
case|:
case|case
name|IFT_L2VLAN
case|:
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|bif
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bif
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bif
operator|->
name|bif_ifp
operator|=
name|ifs
expr_stmt|;
name|bif
operator|->
name|bif_flags
operator|=
name|IFBIF_SPAN
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_spanlist
argument_list|,
name|bif
argument_list|,
name|bif_next
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_delspan
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifs
decl_stmt|;
name|ifs
operator|=
name|ifunit
argument_list|(
name|req
operator|->
name|ifbr_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifs
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_spanlist
argument_list|,
argument|bif_next
argument_list|)
if|if
condition|(
name|ifs
operator|==
name|bif
operator|->
name|bif_ifp
condition|)
break|break;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|bridge_delete_span
argument_list|(
name|sc
argument_list|,
name|bif
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_gbparam
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbropreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bstp_state
modifier|*
name|bs
init|=
operator|&
name|sc
operator|->
name|sc_stp
decl_stmt|;
name|struct
name|bstp_port
modifier|*
name|root_port
decl_stmt|;
name|req
operator|->
name|ifbop_maxage
operator|=
name|bs
operator|->
name|bs_bridge_max_age
operator|>>
literal|8
expr_stmt|;
name|req
operator|->
name|ifbop_hellotime
operator|=
name|bs
operator|->
name|bs_bridge_htime
operator|>>
literal|8
expr_stmt|;
name|req
operator|->
name|ifbop_fwddelay
operator|=
name|bs
operator|->
name|bs_bridge_fdelay
operator|>>
literal|8
expr_stmt|;
name|root_port
operator|=
name|bs
operator|->
name|bs_root_port
expr_stmt|;
if|if
condition|(
name|root_port
operator|==
name|NULL
condition|)
name|req
operator|->
name|ifbop_root_port
operator|=
literal|0
expr_stmt|;
else|else
name|req
operator|->
name|ifbop_root_port
operator|=
name|root_port
operator|->
name|bp_ifp
operator|->
name|if_index
expr_stmt|;
name|req
operator|->
name|ifbop_holdcount
operator|=
name|bs
operator|->
name|bs_txholdcount
expr_stmt|;
name|req
operator|->
name|ifbop_priority
operator|=
name|bs
operator|->
name|bs_bridge_priority
expr_stmt|;
name|req
operator|->
name|ifbop_protocol
operator|=
name|bs
operator|->
name|bs_protover
expr_stmt|;
name|req
operator|->
name|ifbop_root_path_cost
operator|=
name|bs
operator|->
name|bs_root_pv
operator|.
name|pv_cost
expr_stmt|;
name|req
operator|->
name|ifbop_bridgeid
operator|=
name|bs
operator|->
name|bs_bridge_pv
operator|.
name|pv_dbridge_id
expr_stmt|;
name|req
operator|->
name|ifbop_designated_root
operator|=
name|bs
operator|->
name|bs_root_pv
operator|.
name|pv_root_id
expr_stmt|;
name|req
operator|->
name|ifbop_designated_bridge
operator|=
name|bs
operator|->
name|bs_root_pv
operator|.
name|pv_dbridge_id
expr_stmt|;
name|req
operator|->
name|ifbop_last_tc_time
operator|.
name|tv_sec
operator|=
name|bs
operator|->
name|bs_last_tc_time
operator|.
name|tv_sec
expr_stmt|;
name|req
operator|->
name|ifbop_last_tc_time
operator|.
name|tv_usec
operator|=
name|bs
operator|->
name|bs_last_tc_time
operator|.
name|tv_usec
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_grte
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|param
operator|->
name|ifbrp_cexceeded
operator|=
name|sc
operator|->
name|sc_brtexceeded
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_gifsstp
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbpstpconf
modifier|*
name|bifstp
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|bstp_port
modifier|*
name|bp
decl_stmt|;
name|struct
name|ifbpstpreq
name|bpreq
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|outbuf
decl_stmt|;
name|int
name|count
decl_stmt|,
name|buflen
decl_stmt|,
name|len
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
operator|)
operator|!=
literal|0
condition|)
name|count
operator|++
expr_stmt|;
block|}
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|bpreq
argument_list|)
operator|*
name|count
expr_stmt|;
if|if
condition|(
name|bifstp
operator|->
name|ifbpstp_len
operator|==
literal|0
condition|)
block|{
name|bifstp
operator|->
name|ifbpstp_len
operator|=
name|buflen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|outbuf
operator|=
name|malloc
argument_list|(
name|buflen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|outbuf
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|bifstp
operator|->
name|ifbpstp_len
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|bpreq
argument_list|,
sizeof|sizeof
argument_list|(
name|bpreq
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|bpreq
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|bp
operator|=
operator|&
name|bif
operator|->
name|bif_stp
expr_stmt|;
name|bpreq
operator|.
name|ifbp_portno
operator|=
name|bif
operator|->
name|bif_ifp
operator|->
name|if_index
operator|&
literal|0xfff
expr_stmt|;
name|bpreq
operator|.
name|ifbp_fwd_trans
operator|=
name|bp
operator|->
name|bp_forward_transitions
expr_stmt|;
name|bpreq
operator|.
name|ifbp_design_cost
operator|=
name|bp
operator|->
name|bp_desg_pv
operator|.
name|pv_cost
expr_stmt|;
name|bpreq
operator|.
name|ifbp_design_port
operator|=
name|bp
operator|->
name|bp_desg_pv
operator|.
name|pv_port_id
expr_stmt|;
name|bpreq
operator|.
name|ifbp_design_bridge
operator|=
name|bp
operator|->
name|bp_desg_pv
operator|.
name|pv_dbridge_id
expr_stmt|;
name|bpreq
operator|.
name|ifbp_design_root
operator|=
name|bp
operator|->
name|bp_desg_pv
operator|.
name|pv_root_id
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|bpreq
argument_list|,
sizeof|sizeof
argument_list|(
name|bpreq
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|bpreq
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|bpreq
argument_list|)
expr_stmt|;
block|}
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bifstp
operator|->
name|ifbpstp_len
operator|=
sizeof|sizeof
argument_list|(
name|bpreq
argument_list|)
operator|*
name|count
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|outbuf
argument_list|,
name|bifstp
operator|->
name|ifbpstp_req
argument_list|,
name|bifstp
operator|->
name|ifbpstp_len
argument_list|)
expr_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|outbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_sproto
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
return|return
operator|(
name|bstp_set_protocol
argument_list|(
operator|&
name|sc
operator|->
name|sc_stp
argument_list|,
name|param
operator|->
name|ifbrp_proto
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_stxhc
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
return|return
operator|(
name|bstp_set_holdcount
argument_list|(
operator|&
name|sc
operator|->
name|sc_stp
argument_list|,
name|param
operator|->
name|ifbrp_txhc
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_ifdetach:  *  *	Detach an interface from a bridge.  Called when a member  *	interface is detaching.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_ifdetach
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_bridge
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RENAMING
condition|)
return|return;
if|if
condition|(
name|V_bridge_cloner
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * This detach handler can be called after 		 * vnet_bridge_uninit().  Just return in that case. 		 */
return|return;
block|}
comment|/* Check if the interface is a bridge member */
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bif
operator|=
name|bridge_lookup_member_if
argument_list|(
name|sc
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|!=
name|NULL
condition|)
name|bridge_delete_member
argument_list|(
name|sc
argument_list|,
name|bif
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check if the interface is a span port */
name|BRIDGE_LIST_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sc
argument_list|,
argument|&V_bridge_list
argument_list|,
argument|sc_list
argument_list|)
block|{
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_spanlist
argument_list|,
argument|bif_next
argument_list|)
if|if
condition|(
name|ifp
operator|==
name|bif
operator|->
name|bif_ifp
condition|)
block|{
name|bridge_delete_span
argument_list|(
name|sc
argument_list|,
name|bif
argument_list|)
expr_stmt|;
break|break;
block|}
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|BRIDGE_LIST_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_init:  *  *	Initialize a bridge interface.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|bridge_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
return|return;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_brcallout
argument_list|,
name|bridge_rtable_prune_period
operator|*
name|hz
argument_list|,
name|bridge_timer
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|bstp_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_stp
argument_list|)
expr_stmt|;
comment|/* Initialize Spanning Tree */
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_stop:  *  *	Stop the bridge interface.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|disable
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_brcallout
argument_list|)
expr_stmt|;
name|bstp_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_stp
argument_list|)
expr_stmt|;
name|bridge_rtflush
argument_list|(
name|sc
argument_list|,
name|IFBF_FLUSHDYN
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_enqueue:  *  *	Enqueue a packet on a bridge member interface.  *  */
end_comment

begin_function
specifier|static
name|int
name|bridge_enqueue
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|dst_ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|short
name|mflags
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
comment|/* We may be sending a fragment so traverse the mbuf */
for|for
control|(
init|;
name|m
condition|;
name|m
operator|=
name|m0
control|)
block|{
name|m0
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|mflags
operator|=
name|m
operator|->
name|m_flags
expr_stmt|;
comment|/* 		 * If underlying interface can not do VLAN tag insertion itself 		 * then attach a packet tag that holds it. 		 */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_VLANTAG
operator|)
operator|&&
operator|(
name|dst_ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_VLAN_HWTAGGING
operator|)
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|ether_vlanencap
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|dst_ifp
argument_list|,
literal|"unable to prepend VLAN header\n"
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|dst_ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_VLANTAG
expr_stmt|;
block|}
name|M_ASSERTPKTHDR
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* We shouldn't transmit mbuf without pkthdr */
if|if
condition|(
operator|(
name|err
operator|=
name|dst_ifp
operator|->
name|if_transmit
argument_list|(
name|dst_ifp
argument_list|,
name|m
argument_list|)
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
name|if_inc_counter
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
name|IFCOUNTER_OPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
name|IFCOUNTER_OBYTES
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|mflags
operator|&
name|M_MCAST
condition|)
name|if_inc_counter
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
name|IFCOUNTER_OMCASTS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_dummynet:  *  * 	Receive a queued packet from dummynet and pass it on to the output  * 	interface.  *  *	The mbuf has the Ethernet header already attached.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_dummynet
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_bridge
expr_stmt|;
comment|/* 	 * The packet didnt originate from a member interface. This should only 	 * ever happen if a member interface is removed while packets are 	 * queued for it. 	 */
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|PFIL_HOOKED
argument_list|(
operator|&
name|V_inet_pfil_hook
argument_list|)
ifdef|#
directive|ifdef
name|INET6
operator|||
name|PFIL_HOOKED
argument_list|(
operator|&
name|V_inet6_pfil_hook
argument_list|)
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|bridge_pfil
argument_list|(
operator|&
name|m
argument_list|,
name|sc
operator|->
name|sc_ifp
argument_list|,
name|ifp
argument_list|,
name|PFIL_OUT
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
block|}
name|bridge_enqueue
argument_list|(
name|sc
argument_list|,
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_output:  *  *	Send output from a bridge member interface.  This  *	performs the bridging function for locally originated  *	packets.  *  *	The mbuf has the Ethernet header already attached.  We must  *	enqueue or free the mbuf before returning.  */
end_comment

begin_function
specifier|static
name|int
name|bridge_output
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|dst_if
decl_stmt|;
name|struct
name|bridge_softc
modifier|*
name|sc
decl_stmt|;
name|uint16_t
name|vlan
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|ETHER_HDR_LEN
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_bridge
expr_stmt|;
name|vlan
operator|=
name|VLANTAGOF
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * If bridge is down, but the original output interface is up, 	 * go ahead and send out that interface.  Otherwise, the packet 	 * is dropped below. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|dst_if
operator|=
name|ifp
expr_stmt|;
goto|goto
name|sendunicast
goto|;
block|}
comment|/* 	 * If the packet is a multicast, or we don't know a better way to 	 * get there, send to all interfaces. 	 */
if|if
condition|(
name|ETHER_IS_MULTICAST
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
condition|)
name|dst_if
operator|=
name|NULL
expr_stmt|;
else|else
name|dst_if
operator|=
name|bridge_rtlookup
argument_list|(
name|sc
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|,
name|vlan
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_if
operator|==
name|NULL
condition|)
block|{
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|used
init|=
literal|0
decl_stmt|;
name|bridge_span
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|BRIDGE_LOCK2REF
argument_list|(
name|sc
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
name|dst_if
operator|=
name|bif
operator|->
name|bif_ifp
expr_stmt|;
if|if
condition|(
name|dst_if
operator|->
name|if_type
operator|==
name|IFT_GIF
condition|)
continue|continue;
if|if
condition|(
operator|(
name|dst_if
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 			 * If this is not the original output interface, 			 * and the interface is participating in spanning 			 * tree, make sure the port is in a state that 			 * allows forwarding. 			 */
if|if
condition|(
name|dst_if
operator|!=
name|ifp
operator|&&
operator|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
operator|)
operator|&&
name|bif
operator|->
name|bif_stp
operator|.
name|bp_state
operator|==
name|BSTP_IFSTATE_DISCARDING
condition|)
continue|continue;
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|bif
argument_list|,
name|bif_next
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|used
operator|=
literal|1
expr_stmt|;
name|mc
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
name|mc
operator|=
name|m_copypacket
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|==
name|NULL
condition|)
block|{
name|if_inc_counter
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|bridge_enqueue
argument_list|(
name|sc
argument_list|,
name|dst_if
argument_list|,
name|mc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|used
operator|==
literal|0
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|BRIDGE_UNREF
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sendunicast
label|:
comment|/* 	 * XXX Spanning tree consideration here? 	 */
name|bridge_span
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dst_if
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bridge_enqueue
argument_list|(
name|sc
argument_list|,
name|dst_if
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_transmit:  *  *	Do output on a bridge.  *  */
end_comment

begin_function
specifier|static
name|int
name|bridge_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|dst_if
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dst_if
operator|=
name|bridge_rtlookup
argument_list|(
name|sc
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|bridge_enqueue
argument_list|(
name|sc
argument_list|,
name|dst_if
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
name|bridge_broadcast
argument_list|(
name|sc
argument_list|,
name|ifp
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The ifp->if_qflush entry point for if_bridge(4) is no-op.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
name|__unused
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  * bridge_forward:  *  *	The forwarding function of the bridge.  *  *	NOTE: Releases the lock on return.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_forward
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bridge_iflist
modifier|*
name|sbif
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|bridge_iflist
modifier|*
name|dbif
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|src_if
decl_stmt|,
modifier|*
name|dst_if
decl_stmt|,
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|uint16_t
name|vlan
decl_stmt|;
name|uint8_t
modifier|*
name|dst
decl_stmt|;
name|int
name|error
decl_stmt|;
name|src_if
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IBYTES
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|vlan
operator|=
name|VLANTAGOF
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sbif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
operator|)
operator|&&
name|sbif
operator|->
name|bif_stp
operator|.
name|bp_state
operator|==
name|BSTP_IFSTATE_DISCARDING
condition|)
goto|goto
name|drop
goto|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|dst
operator|=
name|eh
operator|->
name|ether_dhost
expr_stmt|;
comment|/* If the interface is learning, record the address. */
if|if
condition|(
name|sbif
operator|->
name|bif_flags
operator|&
name|IFBIF_LEARNING
condition|)
block|{
name|error
operator|=
name|bridge_rtupdate
argument_list|(
name|sc
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|,
name|vlan
argument_list|,
name|sbif
argument_list|,
literal|0
argument_list|,
name|IFBAF_DYNAMIC
argument_list|)
expr_stmt|;
comment|/* 		 * If the interface has addresses limits then deny any source 		 * that is not in the cache. 		 */
if|if
condition|(
name|error
operator|&&
name|sbif
operator|->
name|bif_addrmax
condition|)
goto|goto
name|drop
goto|;
block|}
if|if
condition|(
operator|(
name|sbif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
operator|)
operator|!=
literal|0
operator|&&
name|sbif
operator|->
name|bif_stp
operator|.
name|bp_state
operator|==
name|BSTP_IFSTATE_LEARNING
condition|)
goto|goto
name|drop
goto|;
comment|/* 	 * At this point, the port either doesn't participate 	 * in spanning tree or it is in the forwarding state. 	 */
comment|/* 	 * If the packet is unicast, destined for someone on 	 * "this" side of the bridge, drop it. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|dst_if
operator|=
name|bridge_rtlookup
argument_list|(
name|sc
argument_list|,
name|dst
argument_list|,
name|vlan
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_if
operator|==
name|dst_if
condition|)
goto|goto
name|drop
goto|;
block|}
else|else
block|{
comment|/* 		 * Check if its a reserved multicast address, any address 		 * listed in 802.1D section 7.12.6 may not be forwarded by the 		 * bridge. 		 * This is currently 01-80-C2-00-00-00 to 01-80-C2-00-00-0F 		 */
if|if
condition|(
name|dst
index|[
literal|0
index|]
operator|==
literal|0x01
operator|&&
name|dst
index|[
literal|1
index|]
operator|==
literal|0x80
operator|&&
name|dst
index|[
literal|2
index|]
operator|==
literal|0xc2
operator|&&
name|dst
index|[
literal|3
index|]
operator|==
literal|0x00
operator|&&
name|dst
index|[
literal|4
index|]
operator|==
literal|0x00
operator|&&
name|dst
index|[
literal|5
index|]
operator|<=
literal|0x0f
condition|)
goto|goto
name|drop
goto|;
comment|/* ...forward it to all interfaces. */
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IMCASTS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dst_if
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * If we have a destination interface which is a member of our bridge, 	 * OR this is a unicast packet, push it through the bpf(4) machinery. 	 * For broadcast or multicast packets, don't bother because it will 	 * be reinjected into ether_input. We do this before we pass the packets 	 * through the pfil(9) framework, as it is possible that pfil(9) will 	 * drop the packet, or possibly modify it, making it difficult to debug 	 * firewall issues on the bridge. 	 */
if|if
condition|(
name|dst_if
operator|!=
name|NULL
operator|||
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
operator|)
operator|==
literal|0
condition|)
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* run the packet filter */
if|if
condition|(
name|PFIL_HOOKED
argument_list|(
operator|&
name|V_inet_pfil_hook
argument_list|)
ifdef|#
directive|ifdef
name|INET6
operator|||
name|PFIL_HOOKED
argument_list|(
operator|&
name|V_inet6_pfil_hook
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bridge_pfil
argument_list|(
operator|&
name|m
argument_list|,
name|ifp
argument_list|,
name|src_if
argument_list|,
name|PFIL_IN
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dst_if
operator|==
name|NULL
condition|)
block|{
name|bridge_broadcast
argument_list|(
name|sc
argument_list|,
name|src_if
argument_list|,
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * At this point, we're dealing with a unicast frame 	 * going to a different interface. 	 */
if|if
condition|(
operator|(
name|dst_if
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
goto|goto
name|drop
goto|;
name|dbif
operator|=
name|bridge_lookup_member_if
argument_list|(
name|sc
argument_list|,
name|dst_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbif
operator|==
name|NULL
condition|)
comment|/* Not a member of the bridge (anymore?) */
goto|goto
name|drop
goto|;
comment|/* Private segments can not talk to each other */
if|if
condition|(
name|sbif
operator|->
name|bif_flags
operator|&
name|dbif
operator|->
name|bif_flags
operator|&
name|IFBIF_PRIVATE
condition|)
goto|goto
name|drop
goto|;
if|if
condition|(
operator|(
name|dbif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
operator|)
operator|&&
name|dbif
operator|->
name|bif_stp
operator|.
name|bp_state
operator|==
name|BSTP_IFSTATE_DISCARDING
condition|)
goto|goto
name|drop
goto|;
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|PFIL_HOOKED
argument_list|(
operator|&
name|V_inet_pfil_hook
argument_list|)
ifdef|#
directive|ifdef
name|INET6
operator|||
name|PFIL_HOOKED
argument_list|(
operator|&
name|V_inet6_pfil_hook
argument_list|)
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|bridge_pfil
argument_list|(
operator|&
name|m
argument_list|,
name|ifp
argument_list|,
name|dst_if
argument_list|,
name|PFIL_OUT
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
block|}
name|bridge_enqueue
argument_list|(
name|sc
argument_list|,
name|dst_if
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return;
name|drop
label|:
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_input:  *  *	Receive input from a member interface.  Queue the packet for  *	bridging if it is not for us.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|bridge_input
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_bridge
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|,
modifier|*
name|bif2
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|bifp
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mc
decl_stmt|,
modifier|*
name|mc2
decl_stmt|;
name|uint16_t
name|vlan
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|m
operator|)
return|;
name|bifp
operator|=
name|sc
operator|->
name|sc_ifp
expr_stmt|;
name|vlan
operator|=
name|VLANTAGOF
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Implement support for bridge monitoring. If this flag has been 	 * set on this interface, discard the packet once we push it through 	 * the bpf(4) machinery, but before we do, increment the byte and 	 * packet counters associated with this interface. 	 */
if|if
condition|(
operator|(
name|bifp
operator|->
name|if_flags
operator|&
name|IFF_MONITOR
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|bifp
expr_stmt|;
name|ETHER_BPF_MTAP
argument_list|(
name|bifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|bifp
argument_list|,
name|IFCOUNTER_IPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|bifp
argument_list|,
name|IFCOUNTER_IBYTES
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bif
operator|=
name|bridge_lookup_member_if
argument_list|(
name|sc
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|bridge_span
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
condition|)
block|{
comment|/* Tap off 802.1D packets; they do not get forwarded. */
if|if
condition|(
name|memcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|bstp_etheraddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|bstp_input
argument_list|(
operator|&
name|bif
operator|->
name|bif_stp
argument_list|,
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* consumes mbuf */
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
operator|)
operator|&&
name|bif
operator|->
name|bif_stp
operator|.
name|bp_state
operator|==
name|BSTP_IFSTATE_DISCARDING
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
comment|/* 		 * Make a deep copy of the packet and enqueue the copy 		 * for bridge processing; return the original packet for 		 * local processing. 		 */
name|mc
operator|=
name|m_dup
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|==
name|NULL
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
comment|/* Perform the bridge forwarding function with the copy. */
name|bridge_forward
argument_list|(
name|sc
argument_list|,
name|bif
argument_list|,
name|mc
argument_list|)
expr_stmt|;
comment|/* 		 * Reinject the mbuf as arriving on the bridge so we have a 		 * chance at claiming multicast packets. We can not loop back 		 * here from ether_input as a bridge is never a member of a 		 * bridge. 		 */
name|KASSERT
argument_list|(
name|bifp
operator|->
name|if_bridge
operator|==
name|NULL
argument_list|,
operator|(
literal|"loop created in bridge_input"
operator|)
argument_list|)
expr_stmt|;
name|mc2
operator|=
name|m_dup
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc2
operator|!=
name|NULL
condition|)
block|{
comment|/* Keep the layer3 header aligned */
name|int
name|i
init|=
name|min
argument_list|(
name|mc2
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|max_protohdr
argument_list|)
decl_stmt|;
name|mc2
operator|=
name|m_copyup
argument_list|(
name|mc2
argument_list|,
name|i
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mc2
operator|!=
name|NULL
condition|)
block|{
name|mc2
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|bifp
expr_stmt|;
call|(
modifier|*
name|bifp
operator|->
name|if_input
call|)
argument_list|(
name|bifp
argument_list|,
name|mc2
argument_list|)
expr_stmt|;
block|}
comment|/* Return the original packet for local processing. */
return|return
operator|(
name|m
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
operator|)
operator|&&
name|bif
operator|->
name|bif_stp
operator|.
name|bp_state
operator|==
name|BSTP_IFSTATE_DISCARDING
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
if|#
directive|if
operator|(
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
operator|)
define|#
directive|define
name|OR_CARP_CHECK_WE_ARE_DST
parameter_list|(
name|iface
parameter_list|)
define|\
value||| ((iface)->if_carp \&& (*carp_forus_p)((iface), eh->ether_dhost))
define|#
directive|define
name|OR_CARP_CHECK_WE_ARE_SRC
parameter_list|(
name|iface
parameter_list|)
define|\
value||| ((iface)->if_carp \&& (*carp_forus_p)((iface), eh->ether_shost))
else|#
directive|else
define|#
directive|define
name|OR_CARP_CHECK_WE_ARE_DST
parameter_list|(
name|iface
parameter_list|)
define|#
directive|define
name|OR_CARP_CHECK_WE_ARE_SRC
parameter_list|(
name|iface
parameter_list|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
define|#
directive|define
name|OR_PFIL_HOOKED_INET6
define|\
value||| PFIL_HOOKED(&V_inet6_pfil_hook)
else|#
directive|else
define|#
directive|define
name|OR_PFIL_HOOKED_INET6
endif|#
directive|endif
define|#
directive|define
name|GRAB_OUR_PACKETS
parameter_list|(
name|iface
parameter_list|)
define|\
value|if ((iface)->if_type == IFT_GIF) \ 		continue; \
comment|/* It is destined for us. */
value|\ 	if (memcmp(IF_LLADDR((iface)), eh->ether_dhost,  ETHER_ADDR_LEN) == 0 \ 	    OR_CARP_CHECK_WE_ARE_DST((iface))				\ 	    ) {								\ 		if ((iface)->if_type == IFT_BRIDGE) {			\ 			ETHER_BPF_MTAP(iface, m);			\ 			if_inc_counter(iface, IFCOUNTER_IPACKETS, 1);				\ 			if_inc_counter(iface, IFCOUNTER_IBYTES, m->m_pkthdr.len);		\
comment|/* Filter on the physical interface. */
value|\ 			if (V_pfil_local_phys&&			\ 			    (PFIL_HOOKED(&V_inet_pfil_hook)		\ 			     OR_PFIL_HOOKED_INET6)) {			\ 				if (bridge_pfil(&m, NULL, ifp,		\ 				    PFIL_IN) != 0 || m == NULL) {	\ 					BRIDGE_UNLOCK(sc);		\ 					return (NULL);			\ 				}					\ 				eh = mtod(m, struct ether_header *);	\ 			}						\ 		}							\ 		if (bif->bif_flags& IFBIF_LEARNING) {			\ 			error = bridge_rtupdate(sc, eh->ether_shost,	\ 			    vlan, bif, 0, IFBAF_DYNAMIC);		\ 			if (error&& bif->bif_addrmax) {		\ 				BRIDGE_UNLOCK(sc);			\ 				m_freem(m);				\ 				return (NULL);				\ 			}						\ 		}							\ 		m->m_pkthdr.rcvif = iface;				\ 		BRIDGE_UNLOCK(sc);					\ 		return (m);						\ 	}								\ 									\
comment|/* We just received a packet that we sent out. */
value|\ 	if (memcmp(IF_LLADDR((iface)), eh->ether_shost, ETHER_ADDR_LEN) == 0 \ 	    OR_CARP_CHECK_WE_ARE_SRC((iface))			\ 	    ) {								\ 		BRIDGE_UNLOCK(sc);					\ 		m_freem(m);						\ 		return (NULL);						\ 	}
comment|/* 	 * Unicast.  Make sure it's not for the bridge. 	 */
do|do
block|{
name|GRAB_OUR_PACKETS
argument_list|(
argument|bifp
argument_list|)
block|}
do|while
condition|(
literal|0
condition|)
do|;
comment|/* 	 * Give a chance for ifp at first priority. This will help when	the 	 * packet comes through the interface like VLAN's with the same MACs 	 * on several interfaces from the same bridge. This also will save 	 * some CPU cycles in case the destination interface and the input 	 * interface (eq ifp) are the same. 	 */
do|do
block|{
name|GRAB_OUR_PACKETS
argument_list|(
argument|ifp
argument_list|)
block|}
do|while
condition|(
literal|0
condition|)
do|;
comment|/* Now check the all bridge members. */
name|LIST_FOREACH
argument_list|(
argument|bif2
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
name|GRAB_OUR_PACKETS
argument_list|(
argument|bif2->bif_ifp
argument_list|)
block|}
undef|#
directive|undef
name|OR_CARP_CHECK_WE_ARE_DST
undef|#
directive|undef
name|OR_CARP_CHECK_WE_ARE_SRC
undef|#
directive|undef
name|OR_PFIL_HOOKED_INET6
undef|#
directive|undef
name|GRAB_OUR_PACKETS
comment|/* Perform the bridge forwarding function. */
name|bridge_forward
argument_list|(
name|sc
argument_list|,
name|bif
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_broadcast:  *  *	Send a frame to all interfaces that are members of  *	the bridge, except for the one on which the packet  *	arrived.  *  *	NOTE: Releases the lock on return.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_broadcast
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|src_if
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|runfilt
parameter_list|)
block|{
name|struct
name|bridge_iflist
modifier|*
name|dbif
decl_stmt|,
modifier|*
name|sbif
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|dst_if
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|used
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|sbif
operator|=
name|bridge_lookup_member_if
argument_list|(
name|sc
argument_list|,
name|src_if
argument_list|)
expr_stmt|;
name|BRIDGE_LOCK2REF
argument_list|(
name|sc
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Filter on the bridge interface before broadcasting */
if|if
condition|(
name|runfilt
operator|&&
operator|(
name|PFIL_HOOKED
argument_list|(
operator|&
name|V_inet_pfil_hook
argument_list|)
ifdef|#
directive|ifdef
name|INET6
operator|||
name|PFIL_HOOKED
argument_list|(
operator|&
name|V_inet6_pfil_hook
argument_list|)
endif|#
directive|endif
operator|)
condition|)
block|{
if|if
condition|(
name|bridge_pfil
argument_list|(
operator|&
name|m
argument_list|,
name|sc
operator|->
name|sc_ifp
argument_list|,
name|NULL
argument_list|,
name|PFIL_OUT
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
block|}
name|LIST_FOREACH
argument_list|(
argument|dbif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
name|dst_if
operator|=
name|dbif
operator|->
name|bif_ifp
expr_stmt|;
if|if
condition|(
name|dst_if
operator|==
name|src_if
condition|)
continue|continue;
comment|/* Private segments can not talk to each other */
if|if
condition|(
name|sbif
operator|&&
operator|(
name|sbif
operator|->
name|bif_flags
operator|&
name|dbif
operator|->
name|bif_flags
operator|&
name|IFBIF_PRIVATE
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|dbif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
operator|)
operator|&&
name|dbif
operator|->
name|bif_stp
operator|.
name|bp_state
operator|==
name|BSTP_IFSTATE_DISCARDING
condition|)
continue|continue;
if|if
condition|(
operator|(
name|dbif
operator|->
name|bif_flags
operator|&
name|IFBIF_DISCOVER
operator|)
operator|==
literal|0
operator|&&
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|dst_if
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|dbif
argument_list|,
name|bif_next
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|mc
operator|=
name|m
expr_stmt|;
name|used
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|mc
operator|=
name|m_dup
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|==
name|NULL
condition|)
block|{
name|if_inc_counter
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 		 * Filter on the output interface. Pass a NULL bridge interface 		 * pointer so we do not redundantly filter on the bridge for 		 * each interface we broadcast on. 		 */
if|if
condition|(
name|runfilt
operator|&&
operator|(
name|PFIL_HOOKED
argument_list|(
operator|&
name|V_inet_pfil_hook
argument_list|)
ifdef|#
directive|ifdef
name|INET6
operator|||
name|PFIL_HOOKED
argument_list|(
operator|&
name|V_inet6_pfil_hook
argument_list|)
endif|#
directive|endif
operator|)
condition|)
block|{
if|if
condition|(
name|used
operator|==
literal|0
condition|)
block|{
comment|/* Keep the layer3 header aligned */
name|i
operator|=
name|min
argument_list|(
name|mc
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|max_protohdr
argument_list|)
expr_stmt|;
name|mc
operator|=
name|m_copyup
argument_list|(
name|mc
argument_list|,
name|i
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|==
name|NULL
condition|)
block|{
name|if_inc_counter
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|bridge_pfil
argument_list|(
operator|&
name|mc
argument_list|,
name|NULL
argument_list|,
name|dst_if
argument_list|,
name|PFIL_OUT
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|mc
operator|==
name|NULL
condition|)
continue|continue;
block|}
name|bridge_enqueue
argument_list|(
name|sc
argument_list|,
name|dst_if
argument_list|,
name|mc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|used
operator|==
literal|0
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|out
label|:
name|BRIDGE_UNREF
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_span:  *  *	Duplicate a packet out one or more interfaces that are in span mode,  *	the original mbuf is unmodified.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_span
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|dst_if
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mc
decl_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_spanlist
argument_list|)
condition|)
return|return;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_spanlist
argument_list|,
argument|bif_next
argument_list|)
block|{
name|dst_if
operator|=
name|bif
operator|->
name|bif_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|dst_if
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|mc
operator|=
name|m_copypacket
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|==
name|NULL
condition|)
block|{
name|if_inc_counter
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bridge_enqueue
argument_list|(
name|sc
argument_list|,
name|dst_if
argument_list|,
name|mc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * bridge_rtupdate:  *  *	Add a bridge routing entry.  */
end_comment

begin_function
specifier|static
name|int
name|bridge_rtupdate
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|dst
parameter_list|,
name|uint16_t
name|vlan
parameter_list|,
name|struct
name|bridge_iflist
modifier|*
name|bif
parameter_list|,
name|int
name|setflags
parameter_list|,
name|uint8_t
name|flags
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|;
name|int
name|error
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Check the source address is valid and not multicast. */
if|if
condition|(
name|ETHER_IS_MULTICAST
argument_list|(
name|dst
argument_list|)
operator|||
operator|(
name|dst
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|dst
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|dst
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|dst
index|[
literal|3
index|]
operator|==
literal|0
operator|&&
name|dst
index|[
literal|4
index|]
operator|==
literal|0
operator|&&
name|dst
index|[
literal|5
index|]
operator|==
literal|0
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 802.1p frames map to vlan 1 */
if|if
condition|(
name|vlan
operator|==
literal|0
condition|)
name|vlan
operator|=
literal|1
expr_stmt|;
comment|/* 	 * A route for this destination might already exist.  If so, 	 * update it, otherwise create a new one. 	 */
if|if
condition|(
operator|(
name|brt
operator|=
name|bridge_rtnode_lookup
argument_list|(
name|sc
argument_list|,
name|dst
argument_list|,
name|vlan
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_brtcnt
operator|>=
name|sc
operator|->
name|sc_brtmax
condition|)
block|{
name|sc
operator|->
name|sc_brtexceeded
operator|++
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
comment|/* Check per interface address limits (if enabled) */
if|if
condition|(
name|bif
operator|->
name|bif_addrmax
operator|&&
name|bif
operator|->
name|bif_addrcnt
operator|>=
name|bif
operator|->
name|bif_addrmax
condition|)
block|{
name|bif
operator|->
name|bif_addrexceeded
operator|++
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
comment|/* 		 * Allocate a new bridge forwarding node, and 		 * initialize the expiration time and Ethernet 		 * address. 		 */
name|brt
operator|=
name|uma_zalloc
argument_list|(
name|bridge_rtnode_zone
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|brt
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STICKY
condition|)
name|brt
operator|->
name|brt_flags
operator|=
name|IFBAF_STICKY
expr_stmt|;
else|else
name|brt
operator|->
name|brt_flags
operator|=
name|IFBAF_DYNAMIC
expr_stmt|;
name|memcpy
argument_list|(
name|brt
operator|->
name|brt_addr
argument_list|,
name|dst
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|brt
operator|->
name|brt_vlan
operator|=
name|vlan
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bridge_rtnode_insert
argument_list|(
name|sc
argument_list|,
name|brt
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|uma_zfree
argument_list|(
name|bridge_rtnode_zone
argument_list|,
name|brt
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|brt
operator|->
name|brt_dst
operator|=
name|bif
expr_stmt|;
name|bif
operator|->
name|bif_addrcnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|brt
operator|->
name|brt_flags
operator|&
name|IFBAF_TYPEMASK
operator|)
operator|==
name|IFBAF_DYNAMIC
operator|&&
name|brt
operator|->
name|brt_dst
operator|!=
name|bif
condition|)
block|{
name|brt
operator|->
name|brt_dst
operator|->
name|bif_addrcnt
operator|--
expr_stmt|;
name|brt
operator|->
name|brt_dst
operator|=
name|bif
expr_stmt|;
name|brt
operator|->
name|brt_dst
operator|->
name|bif_addrcnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|IFBAF_TYPEMASK
operator|)
operator|==
name|IFBAF_DYNAMIC
condition|)
name|brt
operator|->
name|brt_expire
operator|=
name|time_uptime
operator|+
name|sc
operator|->
name|sc_brttimeout
expr_stmt|;
if|if
condition|(
name|setflags
condition|)
name|brt
operator|->
name|brt_flags
operator|=
name|flags
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_rtlookup:  *  *	Lookup the destination interface for an address.  */
end_comment

begin_function
specifier|static
name|struct
name|ifnet
modifier|*
name|bridge_rtlookup
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|,
name|uint16_t
name|vlan
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|brt
operator|=
name|bridge_rtnode_lookup
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|vlan
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|brt
operator|->
name|brt_ifp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_rttrim:  *  *	Trim the routine table so that we have a number  *	of routing entries less than or equal to the  *	maximum number.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_rttrim
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|,
modifier|*
name|nbrt
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Make sure we actually need to do this. */
if|if
condition|(
name|sc
operator|->
name|sc_brtcnt
operator|<=
name|sc
operator|->
name|sc_brtmax
condition|)
return|return;
comment|/* Force an aging cycle; this might trim enough addresses. */
name|bridge_rtage
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_brtcnt
operator|<=
name|sc
operator|->
name|sc_brtmax
condition|)
return|return;
name|LIST_FOREACH_SAFE
argument_list|(
argument|brt
argument_list|,
argument|&sc->sc_rtlist
argument_list|,
argument|brt_list
argument_list|,
argument|nbrt
argument_list|)
block|{
if|if
condition|(
operator|(
name|brt
operator|->
name|brt_flags
operator|&
name|IFBAF_TYPEMASK
operator|)
operator|==
name|IFBAF_DYNAMIC
condition|)
block|{
name|bridge_rtnode_destroy
argument_list|(
name|sc
argument_list|,
name|brt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_brtcnt
operator|<=
name|sc
operator|->
name|sc_brtmax
condition|)
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * bridge_timer:  *  *	Aging timer for the bridge.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bridge_rtage
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_brcallout
argument_list|,
name|bridge_rtable_prune_period
operator|*
name|hz
argument_list|,
name|bridge_timer
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_rtage:  *  *	Perform an aging cycle.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_rtage
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|,
modifier|*
name|nbrt
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|brt
argument_list|,
argument|&sc->sc_rtlist
argument_list|,
argument|brt_list
argument_list|,
argument|nbrt
argument_list|)
block|{
if|if
condition|(
operator|(
name|brt
operator|->
name|brt_flags
operator|&
name|IFBAF_TYPEMASK
operator|)
operator|==
name|IFBAF_DYNAMIC
condition|)
block|{
if|if
condition|(
name|time_uptime
operator|>=
name|brt
operator|->
name|brt_expire
condition|)
name|bridge_rtnode_destroy
argument_list|(
name|sc
argument_list|,
name|brt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * bridge_rtflush:  *  *	Remove all dynamic addresses from the bridge.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_rtflush
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|int
name|full
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|,
modifier|*
name|nbrt
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|brt
argument_list|,
argument|&sc->sc_rtlist
argument_list|,
argument|brt_list
argument_list|,
argument|nbrt
argument_list|)
block|{
if|if
condition|(
name|full
operator|||
operator|(
name|brt
operator|->
name|brt_flags
operator|&
name|IFBAF_TYPEMASK
operator|)
operator|==
name|IFBAF_DYNAMIC
condition|)
name|bridge_rtnode_destroy
argument_list|(
name|sc
argument_list|,
name|brt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * bridge_rtdaddr:  *  *	Remove an address from the table.  */
end_comment

begin_function
specifier|static
name|int
name|bridge_rtdaddr
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|,
name|uint16_t
name|vlan
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * If vlan is zero then we want to delete for all vlans so the lookup 	 * may return more than one. 	 */
while|while
condition|(
operator|(
name|brt
operator|=
name|bridge_rtnode_lookup
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|,
name|vlan
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bridge_rtnode_destroy
argument_list|(
name|sc
argument_list|,
name|brt
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|found
condition|?
literal|0
else|:
name|ENOENT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_rtdelete:  *  *	Delete routes to a speicifc member interface.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_rtdelete
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|full
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|,
modifier|*
name|nbrt
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|brt
argument_list|,
argument|&sc->sc_rtlist
argument_list|,
argument|brt_list
argument_list|,
argument|nbrt
argument_list|)
block|{
if|if
condition|(
name|brt
operator|->
name|brt_ifp
operator|==
name|ifp
operator|&&
operator|(
name|full
operator|||
operator|(
name|brt
operator|->
name|brt_flags
operator|&
name|IFBAF_TYPEMASK
operator|)
operator|==
name|IFBAF_DYNAMIC
operator|)
condition|)
name|bridge_rtnode_destroy
argument_list|(
name|sc
argument_list|,
name|brt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * bridge_rtable_init:  *  *	Initialize the route table for this bridge.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_rtable_init
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|sc
operator|->
name|sc_rthash
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|sc_rthash
argument_list|)
operator|*
name|BRIDGE_RTHASH_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BRIDGE_RTHASH_SIZE
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rthash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rthash_key
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rtlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_rtable_fini:  *  *	Deconstruct the route table for this bridge.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_rtable_fini
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_brtcnt
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: %d bridge routes referenced"
operator|,
name|__func__
operator|,
name|sc
operator|->
name|sc_brtcnt
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sc_rthash
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The following hash function is adapted from "Hash Functions" by Bob Jenkins  * ("Algorithm Alley", Dr. Dobbs Journal, September 1997).  */
end_comment

begin_define
define|#
directive|define
name|mix
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
define|\
value|do {									\ 	a -= b; a -= c; a ^= (c>> 13);					\ 	b -= c; b -= a; b ^= (a<< 8);					\ 	c -= a; c -= b; c ^= (b>> 13);					\ 	a -= b; a -= c; a ^= (c>> 12);					\ 	b -= c; b -= a; b ^= (a<< 16);					\ 	c -= a; c -= b; c ^= (b>> 5);					\ 	a -= b; a -= c; a ^= (c>> 3);					\ 	b -= c; b -= a; b ^= (a<< 10);					\ 	c -= a; c -= b; c ^= (b>> 15);					\ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_function
specifier|static
name|__inline
name|uint32_t
name|bridge_rthash
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
name|uint32_t
name|a
init|=
literal|0x9e3779b9
decl_stmt|,
name|b
init|=
literal|0x9e3779b9
decl_stmt|,
name|c
init|=
name|sc
operator|->
name|sc_rthash_key
decl_stmt|;
name|b
operator|+=
name|addr
index|[
literal|5
index|]
operator|<<
literal|8
expr_stmt|;
name|b
operator|+=
name|addr
index|[
literal|4
index|]
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|mix
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|&
name|BRIDGE_RTHASH_MASK
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|mix
end_undef

begin_function
specifier|static
name|int
name|bridge_rtnode_addr_cmp
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|a
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|b
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|d
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
operator|&&
name|d
operator|==
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
operator|(
operator|(
name|int
operator|)
name|a
index|[
name|i
index|]
operator|)
operator|-
operator|(
operator|(
name|int
operator|)
name|b
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|d
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_rtnode_lookup:  *  *	Look up a bridge route node for the specified destination. Compare the  *	vlan id or if zero then just return the first match.  */
end_comment

begin_function
specifier|static
name|struct
name|bridge_rtnode
modifier|*
name|bridge_rtnode_lookup
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|,
name|uint16_t
name|vlan
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|;
name|uint32_t
name|hash
decl_stmt|;
name|int
name|dir
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hash
operator|=
name|bridge_rthash
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|brt
argument_list|,
argument|&sc->sc_rthash[hash]
argument_list|,
argument|brt_hash
argument_list|)
block|{
name|dir
operator|=
name|bridge_rtnode_addr_cmp
argument_list|(
name|addr
argument_list|,
name|brt
operator|->
name|brt_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
literal|0
operator|&&
operator|(
name|brt
operator|->
name|brt_vlan
operator|==
name|vlan
operator|||
name|vlan
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|brt
operator|)
return|;
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_rtnode_insert:  *  *	Insert the specified bridge node into the route table.  We  *	assume the entry is not already in the table.  */
end_comment

begin_function
specifier|static
name|int
name|bridge_rtnode_insert
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bridge_rtnode
modifier|*
name|brt
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|lbrt
decl_stmt|;
name|uint32_t
name|hash
decl_stmt|;
name|int
name|dir
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hash
operator|=
name|bridge_rthash
argument_list|(
name|sc
argument_list|,
name|brt
operator|->
name|brt_addr
argument_list|)
expr_stmt|;
name|lbrt
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rthash
index|[
name|hash
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbrt
operator|==
name|NULL
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_rthash
index|[
name|hash
index|]
argument_list|,
name|brt
argument_list|,
name|brt_hash
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
do|do
block|{
name|dir
operator|=
name|bridge_rtnode_addr_cmp
argument_list|(
name|brt
operator|->
name|brt_addr
argument_list|,
name|lbrt
operator|->
name|brt_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
literal|0
operator|&&
name|brt
operator|->
name|brt_vlan
operator|==
name|lbrt
operator|->
name|brt_vlan
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
block|{
name|LIST_INSERT_BEFORE
argument_list|(
name|lbrt
argument_list|,
name|brt
argument_list|,
name|brt_hash
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|lbrt
argument_list|,
name|brt_hash
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|LIST_INSERT_AFTER
argument_list|(
name|lbrt
argument_list|,
name|brt
argument_list|,
name|brt_hash
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|lbrt
operator|=
name|LIST_NEXT
argument_list|(
name|lbrt
argument_list|,
name|brt_hash
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|lbrt
operator|!=
name|NULL
condition|)
do|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|panic
argument_list|(
literal|"bridge_rtnode_insert: impossible"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|out
label|:
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_rtlist
argument_list|,
name|brt
argument_list|,
name|brt_list
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_brtcnt
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_rtnode_destroy:  *  *	Destroy a bridge rtnode.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_rtnode_destroy
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bridge_rtnode
modifier|*
name|brt
parameter_list|)
block|{
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|brt
argument_list|,
name|brt_hash
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|brt
argument_list|,
name|brt_list
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_brtcnt
operator|--
expr_stmt|;
name|brt
operator|->
name|brt_dst
operator|->
name|bif_addrcnt
operator|--
expr_stmt|;
name|uma_zfree
argument_list|(
name|bridge_rtnode_zone
argument_list|,
name|brt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_rtable_expire:  *  *	Set the expiry time for all routes on an interface.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_rtable_expire
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|age
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_bridge
decl_stmt|;
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * If the age is zero then flush, otherwise set all the expiry times to 	 * age for the interface 	 */
if|if
condition|(
name|age
operator|==
literal|0
condition|)
name|bridge_rtdelete
argument_list|(
name|sc
argument_list|,
name|ifp
argument_list|,
name|IFBF_FLUSHDYN
argument_list|)
expr_stmt|;
else|else
block|{
name|LIST_FOREACH
argument_list|(
argument|brt
argument_list|,
argument|&sc->sc_rtlist
argument_list|,
argument|brt_list
argument_list|)
block|{
comment|/* Cap the expiry time to 'age' */
if|if
condition|(
name|brt
operator|->
name|brt_ifp
operator|==
name|ifp
operator|&&
name|brt
operator|->
name|brt_expire
operator|>
name|time_uptime
operator|+
name|age
operator|&&
operator|(
name|brt
operator|->
name|brt_flags
operator|&
name|IFBAF_TYPEMASK
operator|)
operator|==
name|IFBAF_DYNAMIC
condition|)
name|brt
operator|->
name|brt_expire
operator|=
name|time_uptime
operator|+
name|age
expr_stmt|;
block|}
block|}
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_state_change:  *  *	Callback from the bridgestp code when a port changes states.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_state_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_bridge
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|stpstates
index|[]
init|=
block|{
literal|"disabled"
block|,
literal|"listening"
block|,
literal|"learning"
block|,
literal|"forwarding"
block|,
literal|"blocking"
block|,
literal|"discarding"
block|}
decl_stmt|;
name|CURVNET_SET
argument_list|(
name|ifp
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
if|if
condition|(
name|V_log_stp
condition|)
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s: state changed to %s on %s\n"
argument_list|,
name|sc
operator|->
name|sc_ifp
operator|->
name|if_xname
argument_list|,
name|stpstates
index|[
name|state
index|]
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send bridge packets through pfil if they are one of the types pfil can deal  * with, or if they are ARP or REVARP.  (pfil will pass ARP and REVARP without  * question.) If *bifp or *ifp are NULL then packet filtering is skipped for  * that interface.  */
end_comment

begin_function
specifier|static
name|int
name|bridge_pfil
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|struct
name|ifnet
modifier|*
name|bifp
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|int
name|snap
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|,
name|hlen
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh1
decl_stmt|,
name|eh2
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|llc
name|llc1
decl_stmt|;
name|u_int16_t
name|ether_type
decl_stmt|;
name|snap
operator|=
literal|0
expr_stmt|;
name|error
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Default error if not error == 0 */
if|#
directive|if
literal|0
comment|/* we may return with the IP fields swapped, ensure its not shared */
block|KASSERT(M_WRITABLE(*mp), ("%s: modifying a shared mbuf", __func__));
endif|#
directive|endif
if|if
condition|(
name|V_pfil_bridge
operator|==
literal|0
operator|&&
name|V_pfil_member
operator|==
literal|0
operator|&&
name|V_pfil_ipfw
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* filtering is disabled */
name|i
operator|=
name|min
argument_list|(
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|max_protohdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|<
name|i
condition|)
block|{
operator|*
name|mp
operator|=
name|m_pullup
argument_list|(
operator|*
name|mp
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: m_pullup failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|eh1
operator|=
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|ether_type
operator|=
name|ntohs
argument_list|(
name|eh1
operator|->
name|ether_type
argument_list|)
expr_stmt|;
comment|/* 	 * Check for SNAP/LLC. 	 */
if|if
condition|(
name|ether_type
operator|<
name|ETHERMTU
condition|)
block|{
name|struct
name|llc
modifier|*
name|llc2
init|=
operator|(
expr|struct
name|llc
operator|*
operator|)
operator|(
name|eh1
operator|+
literal|1
operator|)
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|>=
name|ETHER_HDR_LEN
operator|+
literal|8
operator|&&
name|llc2
operator|->
name|llc_dsap
operator|==
name|LLC_SNAP_LSAP
operator|&&
name|llc2
operator|->
name|llc_ssap
operator|==
name|LLC_SNAP_LSAP
operator|&&
name|llc2
operator|->
name|llc_control
operator|==
name|LLC_UI
condition|)
block|{
name|ether_type
operator|=
name|htons
argument_list|(
name|llc2
operator|->
name|llc_un
operator|.
name|type_snap
operator|.
name|ether_type
argument_list|)
expr_stmt|;
name|snap
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * If we're trying to filter bridge traffic, don't look at anything 	 * other than IP and ARP traffic.  If the filter doesn't understand 	 * IPv6, don't allow IPv6 through the bridge either.  This is lame 	 * since if we really wanted, say, an AppleTalk filter, we are hosed, 	 * but of course we don't have an AppleTalk filter to begin with. 	 * (Note that since pfil doesn't understand ARP it will pass *ALL* 	 * ARP traffic.) 	 */
switch|switch
condition|(
name|ether_type
condition|)
block|{
case|case
name|ETHERTYPE_ARP
case|:
case|case
name|ETHERTYPE_REVARP
case|:
if|if
condition|(
name|V_pfil_ipfw_arp
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Automatically pass */
break|break;
case|case
name|ETHERTYPE_IP
case|:
ifdef|#
directive|ifdef
name|INET6
case|case
name|ETHERTYPE_IPV6
case|:
endif|#
directive|endif
comment|/* INET6 */
break|break;
default|default:
comment|/* 			 * Check to see if the user wants to pass non-ip 			 * packets, these will not be checked by pfil(9) and 			 * passed unconditionally so the default is to drop. 			 */
if|if
condition|(
name|V_pfil_onlyip
condition|)
goto|goto
name|bad
goto|;
block|}
comment|/* Run the packet through pfil before stripping link headers */
if|if
condition|(
name|PFIL_HOOKED
argument_list|(
operator|&
name|V_link_pfil_hook
argument_list|)
operator|&&
name|V_pfil_ipfw
operator|!=
literal|0
operator|&&
name|dir
operator|==
name|PFIL_OUT
operator|&&
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|pfil_run_hooks
argument_list|(
operator|&
name|V_link_pfil_hook
argument_list|,
name|mp
argument_list|,
name|ifp
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
operator|||
name|error
operator|!=
literal|0
condition|)
comment|/* packet consumed by filter */
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* Strip off the Ethernet header and keep a copy. */
name|m_copydata
argument_list|(
operator|*
name|mp
argument_list|,
literal|0
argument_list|,
name|ETHER_HDR_LEN
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|eh2
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
operator|*
name|mp
argument_list|,
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
comment|/* Strip off snap header, if present */
if|if
condition|(
name|snap
condition|)
block|{
name|m_copydata
argument_list|(
operator|*
name|mp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|llc1
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
operator|*
name|mp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check the IP header for alignment and errors 	 */
if|if
condition|(
name|dir
operator|==
name|PFIL_IN
condition|)
block|{
switch|switch
condition|(
name|ether_type
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
name|error
operator|=
name|bridge_ip_checkbasic
argument_list|(
name|mp
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|ETHERTYPE_IPV6
case|:
name|error
operator|=
name|bridge_ip6_checkbasic
argument_list|(
name|mp
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
default|default:
name|error
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Run the packet through pfil 	 */
switch|switch
condition|(
name|ether_type
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
comment|/* 		 * Run pfil on the member interface and the bridge, both can 		 * be skipped by clearing pfil_member or pfil_bridge. 		 * 		 * Keep the order: 		 *   in_if -> bridge_if -> out_if 		 */
if|if
condition|(
name|V_pfil_bridge
operator|&&
name|dir
operator|==
name|PFIL_OUT
operator|&&
name|bifp
operator|!=
name|NULL
condition|)
name|error
operator|=
name|pfil_run_hooks
argument_list|(
operator|&
name|V_inet_pfil_hook
argument_list|,
name|mp
argument_list|,
name|bifp
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
operator|||
name|error
operator|!=
literal|0
condition|)
comment|/* filter may consume */
break|break;
if|if
condition|(
name|V_pfil_member
operator|&&
name|ifp
operator|!=
name|NULL
condition|)
name|error
operator|=
name|pfil_run_hooks
argument_list|(
operator|&
name|V_inet_pfil_hook
argument_list|,
name|mp
argument_list|,
name|ifp
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
operator|||
name|error
operator|!=
literal|0
condition|)
comment|/* filter may consume */
break|break;
if|if
condition|(
name|V_pfil_bridge
operator|&&
name|dir
operator|==
name|PFIL_IN
operator|&&
name|bifp
operator|!=
name|NULL
condition|)
name|error
operator|=
name|pfil_run_hooks
argument_list|(
operator|&
name|V_inet_pfil_hook
argument_list|,
name|mp
argument_list|,
name|bifp
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
operator|||
name|error
operator|!=
literal|0
condition|)
comment|/* filter may consume */
break|break;
comment|/* check if we need to fragment the packet */
comment|/* bridge_fragment generates a mbuf chain of packets */
comment|/* that already include eth headers */
if|if
condition|(
name|V_pfil_member
operator|&&
name|ifp
operator|!=
name|NULL
operator|&&
name|dir
operator|==
name|PFIL_OUT
condition|)
block|{
name|i
operator|=
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|ifp
operator|->
name|if_mtu
condition|)
block|{
name|error
operator|=
name|bridge_fragment
argument_list|(
name|ifp
argument_list|,
name|mp
argument_list|,
operator|&
name|eh2
argument_list|,
name|snap
argument_list|,
operator|&
name|llc1
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* Recalculate the ip checksum. */
name|ip
operator|=
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|hlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|hlen
operator|>
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|mp
operator|=
name|m_pullup
argument_list|(
operator|*
name|mp
argument_list|,
name|hlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|ip
operator|=
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
block|}
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hlen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
name|ip
operator|->
name|ip_sum
operator|=
name|in_cksum_hdr
argument_list|(
name|ip
argument_list|)
expr_stmt|;
else|else
name|ip
operator|->
name|ip_sum
operator|=
name|in_cksum
argument_list|(
operator|*
name|mp
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|ETHERTYPE_IPV6
case|:
if|if
condition|(
name|V_pfil_bridge
operator|&&
name|dir
operator|==
name|PFIL_OUT
operator|&&
name|bifp
operator|!=
name|NULL
condition|)
name|error
operator|=
name|pfil_run_hooks
argument_list|(
operator|&
name|V_inet6_pfil_hook
argument_list|,
name|mp
argument_list|,
name|bifp
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
operator|||
name|error
operator|!=
literal|0
condition|)
comment|/* filter may consume */
break|break;
if|if
condition|(
name|V_pfil_member
operator|&&
name|ifp
operator|!=
name|NULL
condition|)
name|error
operator|=
name|pfil_run_hooks
argument_list|(
operator|&
name|V_inet6_pfil_hook
argument_list|,
name|mp
argument_list|,
name|ifp
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
operator|||
name|error
operator|!=
literal|0
condition|)
comment|/* filter may consume */
break|break;
if|if
condition|(
name|V_pfil_bridge
operator|&&
name|dir
operator|==
name|PFIL_IN
operator|&&
name|bifp
operator|!=
name|NULL
condition|)
name|error
operator|=
name|pfil_run_hooks
argument_list|(
operator|&
name|V_inet6_pfil_hook
argument_list|,
name|mp
argument_list|,
name|bifp
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
name|error
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Finally, put everything back the way it was and return 	 */
if|if
condition|(
name|snap
condition|)
block|{
name|M_PREPEND
argument_list|(
operator|*
name|mp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bcopy
argument_list|(
operator|&
name|llc1
argument_list|,
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|M_PREPEND
argument_list|(
operator|*
name|mp
argument_list|,
name|ETHER_HDR_LEN
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bcopy
argument_list|(
operator|&
name|eh2
argument_list|,
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform basic checks on header size since  * pfil assumes ip_input has already processed  * it for it.  Cut-and-pasted from ip_input.c.  * Given how simple the IPv6 version is,  * does the IPv4 version really need to be  * this complicated?  *  * XXX Should we update ipstat here, or not?  * XXX Right now we update ipstat but not  * XXX csum_counter.  */
end_comment

begin_function
specifier|static
name|int
name|bridge_ip_checkbasic
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|mp
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|len
decl_stmt|,
name|hlen
decl_stmt|;
name|u_short
name|sum
decl_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|IP_HDR_ALIGNED_P
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_copyup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|,
operator|(
name|max_linkhdr
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* XXXJRT new stat, please */
name|KMOD_IPSTAT_INC
argument_list|(
name|ips_toosmall
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|KMOD_IPSTAT_INC
argument_list|(
name|ips_toosmall
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|ip
operator|->
name|ip_v
operator|!=
name|IPVERSION
condition|)
block|{
name|KMOD_IPSTAT_INC
argument_list|(
name|ips_badvers
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|hlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
comment|/* minimum header length */
name|KMOD_IPSTAT_INC
argument_list|(
name|ips_badhlen
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|hlen
operator|>
name|m
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|KMOD_IPSTAT_INC
argument_list|(
name|ips_badhlen
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP_CHECKED
condition|)
block|{
name|sum
operator|=
operator|!
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP_VALID
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hlen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
name|sum
operator|=
name|in_cksum_hdr
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sum
condition|)
block|{
name|KMOD_IPSTAT_INC
argument_list|(
name|ips_badsum
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Retrieve the packet length. */
name|len
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
comment|/* 	 * Check for additional length bogosity 	 */
if|if
condition|(
name|len
operator|<
name|hlen
condition|)
block|{
name|KMOD_IPSTAT_INC
argument_list|(
name|ips_badlen
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Check that the amount of data in the buffers 	 * is as at least much as the IP header would have us expect. 	 * Drop packet if shorter than we expect. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|len
condition|)
block|{
name|KMOD_IPSTAT_INC
argument_list|(
name|ips_tooshort
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Checks out, proceed */
operator|*
name|mp
operator|=
name|m
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
operator|*
name|mp
operator|=
name|m
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_comment
comment|/*  * Same as above, but for IPv6.  * Cut-and-pasted from ip6_input.c.  * XXX Should we update ip6stat, or not?  */
end_comment

begin_function
specifier|static
name|int
name|bridge_ip6_checkbasic
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|mp
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
comment|/* 	 * If the IPv6 header is not aligned, slurp it up into a new 	 * mbuf with space for link headers, in the event we forward 	 * it.  Otherwise, if it is aligned, make sure the entire base 	 * IPv6 header is in the first mbuf of the chain. 	 */
if|if
condition|(
name|IP6_HDR_ALIGNED_P
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|inifp
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|m_copyup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
operator|(
name|max_linkhdr
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* XXXJRT new stat, please */
name|IP6STAT_INC
argument_list|(
name|ip6s_toosmall
argument_list|)
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|inifp
argument_list|,
name|ifs6_in_hdrerr
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|inifp
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|IP6STAT_INC
argument_list|(
name|ip6s_toosmall
argument_list|)
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|inifp
argument_list|,
name|ifs6_in_hdrerr
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ip6
operator|->
name|ip6_vfc
operator|&
name|IPV6_VERSION_MASK
operator|)
operator|!=
name|IPV6_VERSION
condition|)
block|{
name|IP6STAT_INC
argument_list|(
name|ip6s_badvers
argument_list|)
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_hdrerr
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Checks out, proceed */
operator|*
name|mp
operator|=
name|m
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
operator|*
name|mp
operator|=
name|m
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_comment
comment|/*  * bridge_fragment:  *  *	Fragment mbuf chain in multiple packets and prepend ethernet header.  */
end_comment

begin_function
specifier|static
name|int
name|bridge_fragment
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|struct
name|ether_header
modifier|*
name|eh
parameter_list|,
name|int
name|snap
parameter_list|,
name|struct
name|llc
modifier|*
name|llc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|mp
decl_stmt|,
modifier|*
name|nextpkt
init|=
name|NULL
decl_stmt|,
modifier|*
name|mprev
init|=
name|NULL
decl_stmt|,
modifier|*
name|mcur
init|=
name|NULL
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|error
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|dropit
goto|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator||=
name|CSUM_IP
expr_stmt|;
name|error
operator|=
name|ip_fragment
argument_list|(
name|ip
argument_list|,
operator|&
name|m
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|,
name|ifp
operator|->
name|if_hwassist
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|dropit
goto|;
comment|/* 	 * Walk the chain and re-add the Ethernet header for 	 * each mbuf packet. 	 */
for|for
control|(
name|mcur
operator|=
name|m
init|;
name|mcur
condition|;
name|mcur
operator|=
name|mcur
operator|->
name|m_nextpkt
control|)
block|{
name|nextpkt
operator|=
name|mcur
operator|->
name|m_nextpkt
expr_stmt|;
name|mcur
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|snap
condition|)
block|{
name|M_PREPEND
argument_list|(
name|mcur
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcur
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
if|if
condition|(
name|mprev
operator|!=
name|NULL
condition|)
name|mprev
operator|->
name|m_nextpkt
operator|=
name|nextpkt
expr_stmt|;
goto|goto
name|dropit
goto|;
block|}
name|bcopy
argument_list|(
name|llc
argument_list|,
name|mtod
argument_list|(
name|mcur
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|M_PREPEND
argument_list|(
name|mcur
argument_list|,
name|ETHER_HDR_LEN
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcur
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
if|if
condition|(
name|mprev
operator|!=
name|NULL
condition|)
name|mprev
operator|->
name|m_nextpkt
operator|=
name|nextpkt
expr_stmt|;
goto|goto
name|dropit
goto|;
block|}
name|bcopy
argument_list|(
name|eh
argument_list|,
name|mtod
argument_list|(
name|mcur
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
comment|/* 		 * The previous two M_PREPEND could have inserted one or two 		 * mbufs in front so we have to update the previous packet's 		 * m_nextpkt. 		 */
name|mcur
operator|->
name|m_nextpkt
operator|=
name|nextpkt
expr_stmt|;
if|if
condition|(
name|mprev
operator|!=
name|NULL
condition|)
name|mprev
operator|->
name|m_nextpkt
operator|=
name|mcur
expr_stmt|;
else|else
block|{
comment|/* The first mbuf in the original chain needs to be 			 * updated. */
operator|*
name|mp
operator|=
name|mcur
expr_stmt|;
block|}
name|mprev
operator|=
name|mcur
expr_stmt|;
block|}
name|KMOD_IPSTAT_INC
argument_list|(
name|ips_fragmented
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|dropit
label|:
for|for
control|(
name|mcur
operator|=
operator|*
name|mp
init|;
name|mcur
condition|;
name|mcur
operator|=
name|m
control|)
block|{
comment|/* droping the full packet chain */
name|m
operator|=
name|mcur
operator|->
name|m_nextpkt
expr_stmt|;
name|m_freem
argument_list|(
name|mcur
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bridge_linkstate
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_bridge
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bif
operator|=
name|bridge_lookup_member_if
argument_list|(
name|sc
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
name|bridge_linkcheck
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bstp_linkstate
argument_list|(
operator|&
name|bif
operator|->
name|bif_stp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bridge_linkcheck
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|int
name|new_link
decl_stmt|,
name|hasls
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|new_link
operator|=
name|LINK_STATE_DOWN
expr_stmt|;
name|hasls
operator|=
literal|0
expr_stmt|;
comment|/* Our link is considered up if at least one of our ports is active */
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
if|if
condition|(
name|bif
operator|->
name|bif_ifp
operator|->
name|if_capabilities
operator|&
name|IFCAP_LINKSTATE
condition|)
name|hasls
operator|++
expr_stmt|;
if|if
condition|(
name|bif
operator|->
name|bif_ifp
operator|->
name|if_link_state
operator|==
name|LINK_STATE_UP
condition|)
block|{
name|new_link
operator|=
name|LINK_STATE_UP
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_iflist
argument_list|)
operator|&&
operator|!
name|hasls
condition|)
block|{
comment|/* If no interfaces support link-state then we default to up */
name|new_link
operator|=
name|LINK_STATE_UP
expr_stmt|;
block|}
name|if_link_state_change
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
name|new_link
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

