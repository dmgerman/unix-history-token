begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: if_bridge.c,v 1.31 2005/06/01 19:45:34 jdc Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright 2001 Wasabi Systems, Inc.  * All rights reserved.  *  * Written by Jason R. Thorpe for Wasabi Systems, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed for the NetBSD Project by  *	Wasabi Systems, Inc.  * 4. The name of Wasabi Systems, Inc. may not be used to endorse  *    or promote products derived from this software without specific prior  *    written permission.  *  * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1999, 2000 Jason L. Wright (jason@thought.net)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Jason L. Wright  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * OpenBSD: if_bridge.c,v 1.60 2001/06/15 03:38:33 itojun Exp  */
end_comment

begin_comment
comment|/*  * Network interface bridge support.  *  * TODO:  *  *	- Currently only supports Ethernet-like interfaces (Ethernet,  *	  802.11, VLANs on Ethernet, etc.)  Figure out a nice way  *	  to bridge other types of interfaces (FDDI-FDDI, and maybe  *	  consider heterogenous bridges).  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_carp.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_comment
comment|/* for net/if.h */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_comment
comment|/* string functions */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_clone.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/pfil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_comment
comment|/* for struct arpcom */
end_comment

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_CARP
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip_carp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_comment
comment|/* for struct arpcom */
end_comment

begin_include
include|#
directive|include
file|<net/bridgestp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_bridgevar.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_fw.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_dummynet.h>
end_include

begin_comment
comment|/*  * Size of the route hash table.  Must be a power of two.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BRIDGE_RTHASH_SIZE
end_ifndef

begin_define
define|#
directive|define
name|BRIDGE_RTHASH_SIZE
value|1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BRIDGE_RTHASH_MASK
value|(BRIDGE_RTHASH_SIZE - 1)
end_define

begin_comment
comment|/*  * Maximum number of addresses to cache.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BRIDGE_RTABLE_MAX
end_ifndef

begin_define
define|#
directive|define
name|BRIDGE_RTABLE_MAX
value|100
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Timeout (in seconds) for entries learned dynamically.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BRIDGE_RTABLE_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|BRIDGE_RTABLE_TIMEOUT
value|(20 * 60)
end_define

begin_comment
comment|/* same as ARP */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Number of seconds between walks of the route list.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BRIDGE_RTABLE_PRUNE_PERIOD
end_ifndef

begin_define
define|#
directive|define
name|BRIDGE_RTABLE_PRUNE_PERIOD
value|(5 * 60)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * List of capabilities to mask on the member interface.  */
end_comment

begin_define
define|#
directive|define
name|BRIDGE_IFCAPS_MASK
value|IFCAP_TXCSUM
end_define

begin_comment
comment|/*  * Bridge interface list entry.  */
end_comment

begin_struct
struct|struct
name|bridge_iflist
block|{
name|LIST_ENTRY
argument_list|(
argument|bridge_iflist
argument_list|)
name|bif_next
expr_stmt|;
name|struct
name|ifnet
modifier|*
name|bif_ifp
decl_stmt|;
comment|/* member if */
name|struct
name|bstp_port
name|bif_stp
decl_stmt|;
comment|/* STP state */
name|uint32_t
name|bif_flags
decl_stmt|;
comment|/* member if flags */
name|int
name|bif_mutecap
decl_stmt|;
comment|/* member muted caps */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Bridge route node.  */
end_comment

begin_struct
struct|struct
name|bridge_rtnode
block|{
name|LIST_ENTRY
argument_list|(
argument|bridge_rtnode
argument_list|)
name|brt_hash
expr_stmt|;
comment|/* hash table linkage */
name|LIST_ENTRY
argument_list|(
argument|bridge_rtnode
argument_list|)
name|brt_list
expr_stmt|;
comment|/* list linkage */
name|struct
name|ifnet
modifier|*
name|brt_ifp
decl_stmt|;
comment|/* destination if */
name|unsigned
name|long
name|brt_expire
decl_stmt|;
comment|/* expiration time */
name|uint8_t
name|brt_flags
decl_stmt|;
comment|/* address flags */
name|uint8_t
name|brt_addr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Software state for each bridge.  */
end_comment

begin_struct
struct|struct
name|bridge_softc
block|{
name|struct
name|ifnet
modifier|*
name|sc_ifp
decl_stmt|;
comment|/* make this an interface */
name|LIST_ENTRY
argument_list|(
argument|bridge_softc
argument_list|)
name|sc_list
expr_stmt|;
name|struct
name|mtx
name|sc_mtx
decl_stmt|;
name|struct
name|cv
name|sc_cv
decl_stmt|;
name|uint32_t
name|sc_brtmax
decl_stmt|;
comment|/* max # of addresses */
name|uint32_t
name|sc_brtcnt
decl_stmt|;
comment|/* cur. # of addresses */
name|uint32_t
name|sc_brttimeout
decl_stmt|;
comment|/* rt timeout in seconds */
name|struct
name|callout
name|sc_brcallout
decl_stmt|;
comment|/* bridge callout */
name|uint32_t
name|sc_iflist_ref
decl_stmt|;
comment|/* refcount for sc_iflist */
name|uint32_t
name|sc_iflist_xcnt
decl_stmt|;
comment|/* refcount for sc_iflist */
name|LIST_HEAD
argument_list|(
argument_list|,
argument|bridge_iflist
argument_list|)
name|sc_iflist
expr_stmt|;
comment|/* member interface list */
name|LIST_HEAD
argument_list|(,
name|bridge_rtnode
argument_list|)
operator|*
name|sc_rthash
expr_stmt|;
comment|/* our forwarding table */
name|LIST_HEAD
argument_list|(
argument_list|,
argument|bridge_rtnode
argument_list|)
name|sc_rtlist
expr_stmt|;
comment|/* list version of above */
name|uint32_t
name|sc_rthash_key
decl_stmt|;
comment|/* key for hash */
name|LIST_HEAD
argument_list|(
argument_list|,
argument|bridge_iflist
argument_list|)
name|sc_spanlist
expr_stmt|;
comment|/* span ports list */
name|struct
name|bstp_state
name|sc_stp
decl_stmt|;
comment|/* STP state */
name|uint32_t
name|sc_brtexceeded
decl_stmt|;
comment|/* # of cache drops */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|bridge_list_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|eventhandler_tag
name|bridge_detach_cookie
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|bridge_rtable_prune_period
init|=
name|BRIDGE_RTABLE_PRUNE_PERIOD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uma_zone_t
name|bridge_rtnode_zone
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|bridge_clone_create
parameter_list|(
name|struct
name|if_clone
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_clone_destroy
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_mutecaps
parameter_list|(
name|struct
name|bridge_iflist
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_ifdetach
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_dummynet
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|bridge_input
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_output
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|struct
name|rtentry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_enqueue
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_rtdelete
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_forward
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_timer
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_broadcast
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_span
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_rtupdate
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|struct
name|bridge_iflist
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ifnet
modifier|*
name|bridge_rtlookup
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_rttrim
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_rtage
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_rtflush
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_rtdaddr
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_rtable_init
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_rtable_fini
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_rtnode_addr_cmp
parameter_list|(
specifier|const
name|uint8_t
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|bridge_rtnode
modifier|*
name|bridge_rtnode_lookup
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_rtnode_insert
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|bridge_rtnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_rtnode_destroy
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|bridge_rtnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_rtable_expire
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_state_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|bridge_iflist
modifier|*
name|bridge_lookup_member
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|bridge_iflist
modifier|*
name|bridge_lookup_member_if
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_delete_member
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|bridge_iflist
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_delete_span
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|bridge_iflist
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_add
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_del
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_gifflags
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_sifflags
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_scache
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_gcache
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_gifs
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_rts
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_saddr
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_sto
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_gto
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_daddr
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_flush
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_gpri
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_spri
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_ght
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_sht
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_gfd
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_sfd
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_gma
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_sma
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_sifprio
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_sifcost
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_addspan
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_delspan
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_gbparam
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_grte
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_gifsstp
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_sproto
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ioctl_stxhc
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_pfil
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ip_checkbasic
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function_decl
specifier|static
name|int
name|bridge_ip6_checkbasic
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_function_decl
specifier|static
name|int
name|bridge_fragment
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ether_header
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|llc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_link
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_link
argument_list|,
name|IFT_BRIDGE
argument_list|,
name|bridge
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Bridge"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pfil_onlyip
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* only pass IP[46] packets when pfil is enabled */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pfil_bridge
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* run pfil hooks on the bridge interface */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pfil_member
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* run pfil hooks on the member interface */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pfil_ipfw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* layer2 filter with ipfw */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pfil_ipfw_arp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* layer2 filter with ipfw */
end_comment

begin_decl_stmt
specifier|static
name|int
name|log_stp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* log STP state changes */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_link_bridge
argument_list|,
name|OID_AUTO
argument_list|,
name|pfil_onlyip
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pfil_onlyip
argument_list|,
literal|0
argument_list|,
literal|"Only pass IP packets when pfil is enabled"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_link_bridge
argument_list|,
name|OID_AUTO
argument_list|,
name|ipfw_arp
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pfil_ipfw_arp
argument_list|,
literal|0
argument_list|,
literal|"Filter ARP packets through IPFW layer2"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_link_bridge
argument_list|,
name|OID_AUTO
argument_list|,
name|pfil_bridge
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pfil_bridge
argument_list|,
literal|0
argument_list|,
literal|"Packet filter on the bridge interface"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_link_bridge
argument_list|,
name|OID_AUTO
argument_list|,
name|pfil_member
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pfil_member
argument_list|,
literal|0
argument_list|,
literal|"Packet filter on the member interface"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_link_bridge
argument_list|,
name|OID_AUTO
argument_list|,
name|log_stp
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|log_stp
argument_list|,
literal|0
argument_list|,
literal|"Log STP state changes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|bridge_control
block|{
name|int
function_decl|(
modifier|*
name|bc_func
function_decl|)
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|int
name|bc_argsize
decl_stmt|;
name|int
name|bc_flags
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|BC_F_COPYIN
value|0x01
end_define

begin_comment
comment|/* copy arguments in */
end_comment

begin_define
define|#
directive|define
name|BC_F_COPYOUT
value|0x02
end_define

begin_comment
comment|/* copy arguments out */
end_comment

begin_define
define|#
directive|define
name|BC_F_SUSER
value|0x04
end_define

begin_comment
comment|/* do super-user check */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|bridge_control
name|bridge_control_table
index|[]
init|=
block|{
block|{
name|bridge_ioctl_add
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_del
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_gifflags
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_sifflags
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_scache
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_gcache
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_gifs
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbifconf
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_rts
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbaconf
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_saddr
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbareq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_sto
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_gto
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_daddr
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbareq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_flush
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_gpri
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_spri
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_ght
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_sht
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_gfd
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_sfd
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_gma
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_sma
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_sifprio
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_sifcost
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_addspan
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_delspan
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_gbparam
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbropreq
argument_list|)
block|,
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_grte
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_gifsstp
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbpstpconf
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_sproto
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_stxhc
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|bridge_control_table_size
init|=
sizeof|sizeof
argument_list|(
name|bridge_control_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|bridge_control_table
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_char
name|etherbroadcastaddr
index|[
name|ETHER_ADDR_LEN
index|]
init|=
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|LIST_HEAD
argument_list|(
argument_list|,
argument|bridge_softc
argument_list|)
end_macro

begin_expr_stmt
name|bridge_list
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|IFC_SIMPLE_DECLARE
argument_list|(
name|bridge
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|bridge_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|mtx_init
argument_list|(
operator|&
name|bridge_list_mtx
argument_list|,
literal|"if_bridge list"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|if_clone_attach
argument_list|(
operator|&
name|bridge_cloner
argument_list|)
expr_stmt|;
name|bridge_rtnode_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"bridge_rtnode"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bridge_rtnode
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|bridge_list
argument_list|)
expr_stmt|;
name|bridge_input_p
operator|=
name|bridge_input
expr_stmt|;
name|bridge_output_p
operator|=
name|bridge_output
expr_stmt|;
name|bridge_dn_p
operator|=
name|bridge_dummynet
expr_stmt|;
name|bstp_linkstate_p
operator|=
name|bstp_linkstate
expr_stmt|;
name|bridge_detach_cookie
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|ifnet_departure_event
argument_list|,
name|bridge_ifdetach
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|ifnet_departure_event
argument_list|,
name|bridge_detach_cookie
argument_list|)
expr_stmt|;
name|if_clone_detach
argument_list|(
operator|&
name|bridge_cloner
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|bridge_list
argument_list|)
condition|)
name|bridge_clone_destroy
argument_list|(
name|LIST_FIRST
argument_list|(
operator|&
name|bridge_list
argument_list|)
operator|->
name|sc_ifp
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|bridge_rtnode_zone
argument_list|)
expr_stmt|;
name|bridge_input_p
operator|=
name|NULL
expr_stmt|;
name|bridge_output_p
operator|=
name|NULL
expr_stmt|;
name|bridge_dn_p
operator|=
name|NULL
expr_stmt|;
name|bstp_linkstate_p
operator|=
name|NULL
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|bridge_list_mtx
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|bridge_mod
init|=
block|{
literal|"if_bridge"
block|,
name|bridge_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|if_bridge
argument_list|,
name|bridge_mod
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|if_bridge
argument_list|,
name|bridgestp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * handler for net.link.bridge.pfil_ipfw  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_pfil_ipfw
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|enable
init|=
name|pfil_ipfw
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|enable
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|enable
operator|=
operator|(
name|enable
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|enable
operator|!=
name|pfil_ipfw
condition|)
block|{
name|pfil_ipfw
operator|=
name|enable
expr_stmt|;
comment|/* 		 * Disable pfil so that ipfw doesnt run twice, if the user 		 * really wants both then they can re-enable pfil_bridge and/or 		 * pfil_member. Also allow non-ip packets as ipfw can filter by 		 * layer2 type. 		 */
if|if
condition|(
name|pfil_ipfw
condition|)
block|{
name|pfil_onlyip
operator|=
literal|0
expr_stmt|;
name|pfil_bridge
operator|=
literal|0
expr_stmt|;
name|pfil_member
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_link_bridge
argument_list|,
name|OID_AUTO
argument_list|,
name|ipfw
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|pfil_ipfw
argument_list|,
literal|0
argument_list|,
operator|&
name|sysctl_pfil_ipfw
argument_list|,
literal|"I"
argument_list|,
literal|"Layer2 filter with IPFW"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * bridge_clone_create:  *  *	Create a new bridge instance.  */
end_comment

begin_function
specifier|static
name|int
name|bridge_clone_create
parameter_list|(
name|struct
name|if_clone
modifier|*
name|ifc
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
decl_stmt|,
modifier|*
name|sc2
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|bifp
decl_stmt|,
modifier|*
name|ifp
decl_stmt|;
name|u_char
name|eaddr
index|[
literal|6
index|]
decl_stmt|;
name|int
name|retry
decl_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|BRIDGE_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|sc
operator|->
name|sc_brtmax
operator|=
name|BRIDGE_RTABLE_MAX
expr_stmt|;
name|sc
operator|->
name|sc_brttimeout
operator|=
name|BRIDGE_RTABLE_TIMEOUT
expr_stmt|;
comment|/* Initialize our routing table. */
name|bridge_rtable_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_brcallout
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_iflist
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_spanlist
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|ifc
operator|->
name|ifc_name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|bridge_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|bridge_start
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|bridge_init
expr_stmt|;
name|ifp
operator|->
name|if_type
operator|=
name|IFT_BRIDGE
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifqmaxlen
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|ifqmaxlen
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
comment|/* 	 * Generate a random ethernet address with a locally administered 	 * address. 	 * 	 * Since we are using random ethernet addresses for the bridge, it is 	 * possible that we might have address collisions, so make sure that 	 * this hardware address isn't already in use on another bridge. 	 */
for|for
control|(
name|retry
operator|=
literal|1
init|;
name|retry
operator|!=
literal|0
condition|;
control|)
block|{
name|arc4rand
argument_list|(
name|eaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|eaddr
index|[
literal|0
index|]
operator|&=
operator|~
literal|1
expr_stmt|;
comment|/* clear multicast bit */
name|eaddr
index|[
literal|0
index|]
operator||=
literal|2
expr_stmt|;
comment|/* set the LAA bit */
name|retry
operator|=
literal|0
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bridge_list_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sc2
argument_list|,
argument|&bridge_list
argument_list|,
argument|sc_list
argument_list|)
block|{
name|bifp
operator|=
name|sc2
operator|->
name|sc_ifp
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|eaddr
argument_list|,
name|IF_LLADDR
argument_list|(
name|bifp
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
name|retry
operator|=
literal|1
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|bridge_list_mtx
argument_list|)
expr_stmt|;
block|}
name|bstp_attach
argument_list|(
operator|&
name|sc
operator|->
name|sc_stp
argument_list|,
name|bridge_state_change
argument_list|,
name|bridge_rtable_expire
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
comment|/* Now undo some of the damage... */
name|ifp
operator|->
name|if_baudrate
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_type
operator|=
name|IFT_BRIDGE
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bridge_list_mtx
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|bridge_list
argument_list|,
name|sc
argument_list|,
name|sc_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bridge_list_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_clone_destroy:  *  *	Destroy a bridge instance.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_clone_destroy
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bridge_stop
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
while|while
condition|(
operator|(
name|bif
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_iflist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|bridge_delete_member
argument_list|(
name|sc
argument_list|,
name|bif
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|bif
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_spanlist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bridge_delete_span
argument_list|(
name|sc
argument_list|,
name|bif
argument_list|)
expr_stmt|;
block|}
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_brcallout
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bridge_list_mtx
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sc
argument_list|,
name|sc_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bridge_list_mtx
argument_list|)
expr_stmt|;
name|bstp_detach
argument_list|(
operator|&
name|sc
operator|->
name|sc_stp
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_free_type
argument_list|(
name|ifp
argument_list|,
name|IFT_ETHER
argument_list|)
expr_stmt|;
comment|/* Tear down the routing table. */
name|bridge_rtable_fini
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BRIDGE_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_ioctl:  *  *	Handle a control request from the operator.  */
end_comment

begin_function
specifier|static
name|int
name|bridge_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
union|union
block|{
name|struct
name|ifbreq
name|ifbreq
decl_stmt|;
name|struct
name|ifbifconf
name|ifbifconf
decl_stmt|;
name|struct
name|ifbareq
name|ifbareq
decl_stmt|;
name|struct
name|ifbaconf
name|ifbaconf
decl_stmt|;
name|struct
name|ifbrparam
name|ifbrparam
decl_stmt|;
name|struct
name|ifbropreq
name|ifbropreq
decl_stmt|;
block|}
name|args
union|;
name|struct
name|ifdrv
modifier|*
name|ifd
init|=
operator|(
expr|struct
name|ifdrv
operator|*
operator|)
name|data
decl_stmt|;
specifier|const
name|struct
name|bridge_control
modifier|*
name|bc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
break|break;
case|case
name|SIOCGDRVSPEC
case|:
case|case
name|SIOCSDRVSPEC
case|:
if|if
condition|(
name|ifd
operator|->
name|ifd_cmd
operator|>=
name|bridge_control_table_size
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|bc
operator|=
operator|&
name|bridge_control_table
index|[
name|ifd
operator|->
name|ifd_cmd
index|]
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|SIOCGDRVSPEC
operator|&&
operator|(
name|bc
operator|->
name|bc_flags
operator|&
name|BC_F_COPYOUT
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|SIOCSDRVSPEC
operator|&&
operator|(
name|bc
operator|->
name|bc_flags
operator|&
name|BC_F_COPYOUT
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bc
operator|->
name|bc_flags
operator|&
name|BC_F_SUSER
condition|)
block|{
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
if|if
condition|(
name|ifd
operator|->
name|ifd_len
operator|!=
name|bc
operator|->
name|bc_argsize
operator|||
name|ifd
operator|->
name|ifd_len
operator|>
sizeof|sizeof
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|bzero
argument_list|(
operator|&
name|args
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bc
operator|->
name|bc_flags
operator|&
name|BC_F_COPYIN
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|ifd
operator|->
name|ifd_data
argument_list|,
operator|&
name|args
argument_list|,
name|ifd
operator|->
name|ifd_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|error
operator|=
call|(
modifier|*
name|bc
operator|->
name|bc_func
call|)
argument_list|(
name|sc
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|bc
operator|->
name|bc_flags
operator|&
name|BC_F_COPYOUT
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|args
argument_list|,
name|ifd
operator|->
name|ifd_data
argument_list|,
name|ifd
operator|->
name|ifd_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
comment|/* 			 * If interface is marked down and it is running, 			 * then stop and disable it. 			 */
name|bridge_stop
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
comment|/* 			 * If interface is marked up and it is stopped, then 			 * start it. 			 */
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_init
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMTU
case|:
comment|/* Do not allow the MTU to be changed on the bridge */
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
default|default:
comment|/* 		 * drop the lock as ether_ioctl() will call bridge_start() and 		 * cause the lock to be recursed. 		 */
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|BRIDGE_LOCKED
argument_list|(
name|sc
argument_list|)
condition|)
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_mutecaps:  *  *	Clear or restore unwanted capabilities on the member interface  */
end_comment

begin_function
specifier|static
name|void
name|bridge_mutecaps
parameter_list|(
name|struct
name|bridge_iflist
modifier|*
name|bif
parameter_list|,
name|int
name|mute
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|bif
operator|->
name|bif_ifp
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_ioctl
operator|==
name|NULL
condition|)
return|return;
name|bzero
argument_list|(
operator|&
name|ifr
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr
argument_list|)
argument_list|)
expr_stmt|;
name|ifr
operator|.
name|ifr_reqcap
operator|=
name|ifp
operator|->
name|if_capenable
expr_stmt|;
if|if
condition|(
name|mute
condition|)
block|{
comment|/* mask off and save capabilities */
name|bif
operator|->
name|bif_mutecap
operator|=
name|ifr
operator|.
name|ifr_reqcap
operator|&
name|BRIDGE_IFCAPS_MASK
expr_stmt|;
if|if
condition|(
name|bif
operator|->
name|bif_mutecap
operator|!=
literal|0
condition|)
name|ifr
operator|.
name|ifr_reqcap
operator|&=
operator|~
name|BRIDGE_IFCAPS_MASK
expr_stmt|;
block|}
else|else
comment|/* restore muted capabilities */
name|ifr
operator|.
name|ifr_reqcap
operator||=
name|bif
operator|->
name|bif_mutecap
expr_stmt|;
if|if
condition|(
name|bif
operator|->
name|bif_mutecap
operator|!=
literal|0
condition|)
block|{
name|IFF_LOCKGIANT
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_ioctl
call|)
argument_list|(
name|ifp
argument_list|,
name|SIOCSIFCAP
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
argument_list|)
expr_stmt|;
name|IFF_UNLOCKGIANT
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * bridge_lookup_member:  *  *	Lookup a bridge member interface.  */
end_comment

begin_function
specifier|static
name|struct
name|bridge_iflist
modifier|*
name|bridge_lookup_member
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
name|ifp
operator|=
name|bif
operator|->
name|bif_ifp
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ifp
operator|->
name|if_xname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|bif
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_lookup_member_if:  *  *	Lookup a bridge member interface by ifnet*.  */
end_comment

begin_function
specifier|static
name|struct
name|bridge_iflist
modifier|*
name|bridge_lookup_member_if
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|member_ifp
parameter_list|)
block|{
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
if|if
condition|(
name|bif
operator|->
name|bif_ifp
operator|==
name|member_ifp
condition|)
return|return
operator|(
name|bif
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_delete_member:  *  *	Delete the specified member interface.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_delete_member
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bridge_iflist
modifier|*
name|bif
parameter_list|,
name|int
name|gone
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifs
init|=
name|bif
operator|->
name|bif_ifp
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gone
condition|)
block|{
switch|switch
condition|(
name|ifs
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ETHER
case|:
case|case
name|IFT_L2VLAN
case|:
comment|/* 			 * Take the interface out of promiscuous mode. 			 */
operator|(
name|void
operator|)
name|ifpromisc
argument_list|(
name|ifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bridge_mutecaps
argument_list|(
name|bif
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IFT_GIF
case|:
break|break;
default|default:
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|panic
argument_list|(
literal|"bridge_delete_member: impossible"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
if|if
condition|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
condition|)
name|bstp_disable
argument_list|(
operator|&
name|bif
operator|->
name|bif_stp
argument_list|)
expr_stmt|;
name|ifs
operator|->
name|if_bridge
operator|=
name|NULL
expr_stmt|;
name|BRIDGE_XLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bif
argument_list|,
name|bif_next
argument_list|)
expr_stmt|;
name|BRIDGE_XDROP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bridge_rtdelete
argument_list|(
name|sc
argument_list|,
name|ifs
argument_list|,
name|IFBF_FLUSHALL
argument_list|)
expr_stmt|;
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bstp_destroy
argument_list|(
operator|&
name|bif
operator|->
name|bif_stp
argument_list|)
expr_stmt|;
comment|/* prepare to free */
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bif
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_delete_span:  *  *	Delete the specified span interface.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_delete_span
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bridge_iflist
modifier|*
name|bif
parameter_list|)
block|{
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|bif
operator|->
name|bif_ifp
operator|->
name|if_bridge
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: not a span interface"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bif
argument_list|,
name|bif_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bif
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_add
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifs
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ifs
operator|=
name|ifunit
argument_list|(
name|req
operator|->
name|ifbr_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifs
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* If it's in the span list, it can't be a member. */
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_spanlist
argument_list|,
argument|bif_next
argument_list|)
if|if
condition|(
name|ifs
operator|==
name|bif
operator|->
name|bif_ifp
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Allow the first Ethernet member to define the MTU */
if|if
condition|(
name|ifs
operator|->
name|if_type
operator|!=
name|IFT_GIF
condition|)
block|{
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_iflist
argument_list|)
condition|)
name|sc
operator|->
name|sc_ifp
operator|->
name|if_mtu
operator|=
name|ifs
operator|->
name|if_mtu
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_mtu
operator|!=
name|ifs
operator|->
name|if_mtu
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
literal|"invalid MTU for %s\n"
argument_list|,
name|ifs
operator|->
name|if_xname
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ifs
operator|->
name|if_bridge
operator|==
name|sc
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
if|if
condition|(
name|ifs
operator|->
name|if_bridge
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|bif
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bif
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bif
operator|->
name|bif_ifp
operator|=
name|ifs
expr_stmt|;
name|bif
operator|->
name|bif_flags
operator|=
name|IFBIF_LEARNING
operator||
name|IFBIF_DISCOVER
expr_stmt|;
switch|switch
condition|(
name|ifs
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ETHER
case|:
case|case
name|IFT_L2VLAN
case|:
comment|/* 		 * Place the interface into promiscuous mode. 		 */
name|error
operator|=
name|ifpromisc
argument_list|(
name|ifs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|bridge_mutecaps
argument_list|(
name|bif
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|IFT_GIF
case|:
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ifs
operator|->
name|if_bridge
operator|=
name|sc
expr_stmt|;
name|bstp_create
argument_list|(
operator|&
name|sc
operator|->
name|sc_stp
argument_list|,
operator|&
name|bif
operator|->
name|bif_stp
argument_list|,
name|bif
operator|->
name|bif_ifp
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: XLOCK HERE!?! 	 * 	 * NOTE: insert_***HEAD*** should be safe for the traversals. 	 */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_iflist
argument_list|,
name|bif
argument_list|,
name|bif_next
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|bif
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|bif
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_del
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|bif
operator|=
name|bridge_lookup_member
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifbr_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|bridge_delete_member
argument_list|(
name|sc
argument_list|,
name|bif
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_gifflags
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|bstp_port
modifier|*
name|bp
decl_stmt|;
name|bif
operator|=
name|bridge_lookup_member
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifbr_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|bp
operator|=
operator|&
name|bif
operator|->
name|bif_stp
expr_stmt|;
name|req
operator|->
name|ifbr_ifsflags
operator|=
name|bif
operator|->
name|bif_flags
expr_stmt|;
name|req
operator|->
name|ifbr_state
operator|=
name|bp
operator|->
name|bp_state
expr_stmt|;
name|req
operator|->
name|ifbr_priority
operator|=
name|bp
operator|->
name|bp_priority
expr_stmt|;
name|req
operator|->
name|ifbr_path_cost
operator|=
name|bp
operator|->
name|bp_path_cost
expr_stmt|;
name|req
operator|->
name|ifbr_portno
operator|=
name|bif
operator|->
name|bif_ifp
operator|->
name|if_index
operator|&
literal|0xfff
expr_stmt|;
name|req
operator|->
name|ifbr_proto
operator|=
name|bp
operator|->
name|bp_protover
expr_stmt|;
name|req
operator|->
name|ifbr_role
operator|=
name|bp
operator|->
name|bp_role
expr_stmt|;
name|req
operator|->
name|ifbr_stpflags
operator|=
name|bp
operator|->
name|bp_flags
expr_stmt|;
comment|/* Copy STP state options as flags */
if|if
condition|(
name|bp
operator|->
name|bp_operedge
condition|)
name|req
operator|->
name|ifbr_ifsflags
operator||=
name|IFBIF_BSTP_EDGE
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_flags
operator|&
name|BSTP_PORT_AUTOEDGE
condition|)
name|req
operator|->
name|ifbr_ifsflags
operator||=
name|IFBIF_BSTP_AUTOEDGE
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_ptp_link
condition|)
name|req
operator|->
name|ifbr_ifsflags
operator||=
name|IFBIF_BSTP_PTP
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_flags
operator|&
name|BSTP_PORT_AUTOPTP
condition|)
name|req
operator|->
name|ifbr_ifsflags
operator||=
name|IFBIF_BSTP_AUTOPTP
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_flags
operator|&
name|BSTP_PORT_ADMEDGE
condition|)
name|req
operator|->
name|ifbr_ifsflags
operator||=
name|IFBIF_BSTP_ADMEDGE
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|bp_flags
operator|&
name|BSTP_PORT_ADMCOST
condition|)
name|req
operator|->
name|ifbr_ifsflags
operator||=
name|IFBIF_BSTP_ADMCOST
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_sifflags
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|bstp_port
modifier|*
name|bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bif
operator|=
name|bridge_lookup_member
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifbr_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|bp
operator|=
operator|&
name|bif
operator|->
name|bif_stp
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|ifbr_ifsflags
operator|&
name|IFBIF_SPAN
condition|)
comment|/* SPAN is readonly */
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|req
operator|->
name|ifbr_ifsflags
operator|&
name|IFBIF_STP
condition|)
block|{
if|if
condition|(
operator|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|bstp_enable
argument_list|(
operator|&
name|bif
operator|->
name|bif_stp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
operator|)
operator|!=
literal|0
condition|)
name|bstp_disable
argument_list|(
operator|&
name|bif
operator|->
name|bif_stp
argument_list|)
expr_stmt|;
block|}
comment|/* Pass on STP flags */
name|bstp_set_edge
argument_list|(
name|bp
argument_list|,
name|req
operator|->
name|ifbr_ifsflags
operator|&
name|IFBIF_BSTP_EDGE
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|bstp_set_autoedge
argument_list|(
name|bp
argument_list|,
name|req
operator|->
name|ifbr_ifsflags
operator|&
name|IFBIF_BSTP_AUTOEDGE
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|bstp_set_ptp
argument_list|(
name|bp
argument_list|,
name|req
operator|->
name|ifbr_ifsflags
operator|&
name|IFBIF_BSTP_PTP
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|bstp_set_autoptp
argument_list|(
name|bp
argument_list|,
name|req
operator|->
name|ifbr_ifsflags
operator|&
name|IFBIF_BSTP_AUTOPTP
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
comment|/* Save the bits relating to the bridge */
name|bif
operator|->
name|bif_flags
operator|=
name|req
operator|->
name|ifbr_ifsflags
operator|&
name|IFBIFMASK
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_scache
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|sc
operator|->
name|sc_brtmax
operator|=
name|param
operator|->
name|ifbrp_csize
expr_stmt|;
name|bridge_rttrim
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_gcache
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|param
operator|->
name|ifbrp_csize
operator|=
name|sc
operator|->
name|sc_brtmax
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_gifs
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbifconf
modifier|*
name|bifc
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|ifbreq
name|breq
decl_stmt|;
name|int
name|count
decl_stmt|,
name|len
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
name|count
operator|++
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_spanlist
argument_list|,
argument|bif_next
argument_list|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|bifc
operator|->
name|ifbic_len
operator|==
literal|0
condition|)
block|{
name|bifc
operator|->
name|ifbic_len
operator|=
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
operator|*
name|count
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|bifc
operator|->
name|ifbic_len
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|breq
argument_list|,
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
condition|)
break|break;
name|strlcpy
argument_list|(
name|breq
operator|.
name|ifbr_ifsname
argument_list|,
name|bif
operator|->
name|bif_ifp
operator|->
name|if_xname
argument_list|,
sizeof|sizeof
argument_list|(
name|breq
operator|.
name|ifbr_ifsname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill in the ifbreq structure */
name|error
operator|=
name|bridge_ioctl_gifflags
argument_list|(
name|sc
argument_list|,
operator|&
name|breq
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|breq
argument_list|,
name|bifc
operator|->
name|ifbic_req
operator|+
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|count
operator|++
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
expr_stmt|;
block|}
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_spanlist
argument_list|,
argument|bif_next
argument_list|)
block|{
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
condition|)
break|break;
name|strlcpy
argument_list|(
name|breq
operator|.
name|ifbr_ifsname
argument_list|,
name|bif
operator|->
name|bif_ifp
operator|->
name|if_xname
argument_list|,
sizeof|sizeof
argument_list|(
name|breq
operator|.
name|ifbr_ifsname
argument_list|)
argument_list|)
expr_stmt|;
name|breq
operator|.
name|ifbr_ifsflags
operator|=
name|bif
operator|->
name|bif_flags
expr_stmt|;
name|breq
operator|.
name|ifbr_portno
operator|=
name|bif
operator|->
name|bif_ifp
operator|->
name|if_index
operator|&
literal|0xfff
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|breq
argument_list|,
name|bifc
operator|->
name|ifbic_req
operator|+
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|count
operator|++
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
expr_stmt|;
block|}
name|bifc
operator|->
name|ifbic_len
operator|=
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
operator|*
name|count
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_rts
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbaconf
modifier|*
name|bac
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|;
name|struct
name|ifbareq
name|bareq
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|bac
operator|->
name|ifbac_len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|len
operator|=
name|bac
operator|->
name|ifbac_len
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|bareq
argument_list|,
sizeof|sizeof
argument_list|(
name|bareq
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|brt
argument_list|,
argument|&sc->sc_rtlist
argument_list|,
argument|brt_list
argument_list|)
block|{
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|bareq
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|strlcpy
argument_list|(
name|bareq
operator|.
name|ifba_ifsname
argument_list|,
name|brt
operator|->
name|brt_ifp
operator|->
name|if_xname
argument_list|,
sizeof|sizeof
argument_list|(
name|bareq
operator|.
name|ifba_ifsname
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bareq
operator|.
name|ifba_dst
argument_list|,
name|brt
operator|->
name|brt_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|brt
operator|->
name|brt_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|brt
operator|->
name|brt_flags
operator|&
name|IFBAF_TYPEMASK
operator|)
operator|==
name|IFBAF_DYNAMIC
operator|&&
name|time_uptime
operator|<
name|brt
operator|->
name|brt_expire
condition|)
name|bareq
operator|.
name|ifba_expire
operator|=
name|brt
operator|->
name|brt_expire
operator|-
name|time_uptime
expr_stmt|;
else|else
name|bareq
operator|.
name|ifba_expire
operator|=
literal|0
expr_stmt|;
name|bareq
operator|.
name|ifba_flags
operator|=
name|brt
operator|->
name|brt_flags
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|bareq
argument_list|,
name|bac
operator|->
name|ifbac_req
operator|+
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|bareq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|count
operator|++
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|bareq
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|bac
operator|->
name|ifbac_len
operator|=
sizeof|sizeof
argument_list|(
name|bareq
argument_list|)
operator|*
name|count
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_saddr
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbareq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|int
name|error
decl_stmt|;
name|bif
operator|=
name|bridge_lookup_member
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifba_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|error
operator|=
name|bridge_rtupdate
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifba_dst
argument_list|,
name|bif
argument_list|,
literal|1
argument_list|,
name|req
operator|->
name|ifba_flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_sto
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|sc
operator|->
name|sc_brttimeout
operator|=
name|param
operator|->
name|ifbrp_ctime
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_gto
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|param
operator|->
name|ifbrp_ctime
operator|=
name|sc
operator|->
name|sc_brttimeout
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_daddr
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbareq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
return|return
operator|(
name|bridge_rtdaddr
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifba_dst
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_flush
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|bridge_rtflush
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifbr_ifsflags
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_gpri
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|struct
name|bstp_state
modifier|*
name|bs
init|=
operator|&
name|sc
operator|->
name|sc_stp
decl_stmt|;
name|param
operator|->
name|ifbrp_prio
operator|=
name|bs
operator|->
name|bs_bridge_priority
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_spri
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
return|return
operator|(
name|bstp_set_priority
argument_list|(
operator|&
name|sc
operator|->
name|sc_stp
argument_list|,
name|param
operator|->
name|ifbrp_prio
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_ght
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|struct
name|bstp_state
modifier|*
name|bs
init|=
operator|&
name|sc
operator|->
name|sc_stp
decl_stmt|;
name|param
operator|->
name|ifbrp_hellotime
operator|=
name|bs
operator|->
name|bs_bridge_htime
operator|>>
literal|8
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_sht
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
return|return
operator|(
name|bstp_set_htime
argument_list|(
operator|&
name|sc
operator|->
name|sc_stp
argument_list|,
name|param
operator|->
name|ifbrp_hellotime
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_gfd
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|struct
name|bstp_state
modifier|*
name|bs
init|=
operator|&
name|sc
operator|->
name|sc_stp
decl_stmt|;
name|param
operator|->
name|ifbrp_fwddelay
operator|=
name|bs
operator|->
name|bs_bridge_fdelay
operator|>>
literal|8
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_sfd
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
return|return
operator|(
name|bstp_set_fdelay
argument_list|(
operator|&
name|sc
operator|->
name|sc_stp
argument_list|,
name|param
operator|->
name|ifbrp_fwddelay
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_gma
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|struct
name|bstp_state
modifier|*
name|bs
init|=
operator|&
name|sc
operator|->
name|sc_stp
decl_stmt|;
name|param
operator|->
name|ifbrp_maxage
operator|=
name|bs
operator|->
name|bs_bridge_max_age
operator|>>
literal|8
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_sma
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
return|return
operator|(
name|bstp_set_maxage
argument_list|(
operator|&
name|sc
operator|->
name|sc_stp
argument_list|,
name|param
operator|->
name|ifbrp_maxage
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_sifprio
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|bif
operator|=
name|bridge_lookup_member
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifbr_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
return|return
operator|(
name|bstp_set_port_priority
argument_list|(
operator|&
name|bif
operator|->
name|bif_stp
argument_list|,
name|req
operator|->
name|ifbr_priority
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_sifcost
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|bif
operator|=
name|bridge_lookup_member
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifbr_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
return|return
operator|(
name|bstp_set_path_cost
argument_list|(
operator|&
name|bif
operator|->
name|bif_stp
argument_list|,
name|req
operator|->
name|ifbr_path_cost
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_addspan
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifs
decl_stmt|;
name|ifs
operator|=
name|ifunit
argument_list|(
name|req
operator|->
name|ifbr_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifs
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_spanlist
argument_list|,
argument|bif_next
argument_list|)
if|if
condition|(
name|ifs
operator|==
name|bif
operator|->
name|bif_ifp
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
name|ifs
operator|->
name|if_bridge
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
switch|switch
condition|(
name|ifs
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ETHER
case|:
case|case
name|IFT_GIF
case|:
case|case
name|IFT_L2VLAN
case|:
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|bif
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bif
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|bif
operator|->
name|bif_ifp
operator|=
name|ifs
expr_stmt|;
name|bif
operator|->
name|bif_flags
operator|=
name|IFBIF_SPAN
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_spanlist
argument_list|,
name|bif
argument_list|,
name|bif_next
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_delspan
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifs
decl_stmt|;
name|ifs
operator|=
name|ifunit
argument_list|(
name|req
operator|->
name|ifbr_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifs
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_spanlist
argument_list|,
argument|bif_next
argument_list|)
if|if
condition|(
name|ifs
operator|==
name|bif
operator|->
name|bif_ifp
condition|)
break|break;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|bridge_delete_span
argument_list|(
name|sc
argument_list|,
name|bif
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_gbparam
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbropreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bstp_state
modifier|*
name|bs
init|=
operator|&
name|sc
operator|->
name|sc_stp
decl_stmt|;
name|struct
name|bstp_port
modifier|*
name|root_port
decl_stmt|;
name|req
operator|->
name|ifbop_maxage
operator|=
name|bs
operator|->
name|bs_bridge_max_age
operator|>>
literal|8
expr_stmt|;
name|req
operator|->
name|ifbop_hellotime
operator|=
name|bs
operator|->
name|bs_bridge_htime
operator|>>
literal|8
expr_stmt|;
name|req
operator|->
name|ifbop_fwddelay
operator|=
name|bs
operator|->
name|bs_bridge_fdelay
operator|>>
literal|8
expr_stmt|;
name|root_port
operator|=
name|bs
operator|->
name|bs_root_port
expr_stmt|;
if|if
condition|(
name|root_port
operator|==
name|NULL
condition|)
name|req
operator|->
name|ifbop_root_port
operator|=
literal|0
expr_stmt|;
else|else
name|req
operator|->
name|ifbop_root_port
operator|=
name|root_port
operator|->
name|bp_ifp
operator|->
name|if_index
expr_stmt|;
name|req
operator|->
name|ifbop_holdcount
operator|=
name|bs
operator|->
name|bs_txholdcount
expr_stmt|;
name|req
operator|->
name|ifbop_priority
operator|=
name|bs
operator|->
name|bs_bridge_priority
expr_stmt|;
name|req
operator|->
name|ifbop_protocol
operator|=
name|bs
operator|->
name|bs_protover
expr_stmt|;
name|req
operator|->
name|ifbop_root_path_cost
operator|=
name|bs
operator|->
name|bs_root_pv
operator|.
name|pv_cost
expr_stmt|;
name|req
operator|->
name|ifbop_bridgeid
operator|=
name|bs
operator|->
name|bs_bridge_pv
operator|.
name|pv_dbridge_id
expr_stmt|;
name|req
operator|->
name|ifbop_designated_root
operator|=
name|bs
operator|->
name|bs_root_pv
operator|.
name|pv_root_id
expr_stmt|;
name|req
operator|->
name|ifbop_designated_bridge
operator|=
name|bs
operator|->
name|bs_root_pv
operator|.
name|pv_dbridge_id
expr_stmt|;
name|req
operator|->
name|ifbop_last_tc_time
operator|.
name|tv_sec
operator|=
name|bs
operator|->
name|bs_last_tc_time
operator|.
name|tv_sec
expr_stmt|;
name|req
operator|->
name|ifbop_last_tc_time
operator|.
name|tv_usec
operator|=
name|bs
operator|->
name|bs_last_tc_time
operator|.
name|tv_usec
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_grte
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|param
operator|->
name|ifbrp_cexceeded
operator|=
name|sc
operator|->
name|sc_brtexceeded
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_gifsstp
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbpstpconf
modifier|*
name|bifstp
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|bstp_port
modifier|*
name|bp
decl_stmt|;
name|struct
name|ifbpstpreq
name|bpreq
decl_stmt|;
name|int
name|count
decl_stmt|,
name|len
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
operator|)
operator|!=
literal|0
condition|)
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bifstp
operator|->
name|ifbpstp_len
operator|==
literal|0
condition|)
block|{
name|bifstp
operator|->
name|ifbpstp_len
operator|=
sizeof|sizeof
argument_list|(
name|bpreq
argument_list|)
operator|*
name|count
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|bifstp
operator|->
name|ifbpstp_len
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|bpreq
argument_list|,
sizeof|sizeof
argument_list|(
name|bpreq
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|bpreq
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|bp
operator|=
operator|&
name|bif
operator|->
name|bif_stp
expr_stmt|;
name|bpreq
operator|.
name|ifbp_portno
operator|=
name|bif
operator|->
name|bif_ifp
operator|->
name|if_index
operator|&
literal|0xfff
expr_stmt|;
name|bpreq
operator|.
name|ifbp_fwd_trans
operator|=
name|bp
operator|->
name|bp_forward_transitions
expr_stmt|;
name|bpreq
operator|.
name|ifbp_design_cost
operator|=
name|bp
operator|->
name|bp_desg_pv
operator|.
name|pv_cost
expr_stmt|;
name|bpreq
operator|.
name|ifbp_design_port
operator|=
name|bp
operator|->
name|bp_desg_pv
operator|.
name|pv_port_id
expr_stmt|;
name|bpreq
operator|.
name|ifbp_design_bridge
operator|=
name|bp
operator|->
name|bp_desg_pv
operator|.
name|pv_dbridge_id
expr_stmt|;
name|bpreq
operator|.
name|ifbp_design_root
operator|=
name|bp
operator|->
name|bp_desg_pv
operator|.
name|pv_root_id
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|bpreq
argument_list|,
name|bifstp
operator|->
name|ifbpstp_req
operator|+
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|bpreq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|count
operator|++
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|bpreq
argument_list|)
expr_stmt|;
block|}
name|bifstp
operator|->
name|ifbpstp_len
operator|=
sizeof|sizeof
argument_list|(
name|bpreq
argument_list|)
operator|*
name|count
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_sproto
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
return|return
operator|(
name|bstp_set_protocol
argument_list|(
operator|&
name|sc
operator|->
name|sc_stp
argument_list|,
name|param
operator|->
name|ifbrp_proto
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bridge_ioctl_stxhc
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
return|return
operator|(
name|bstp_set_holdcount
argument_list|(
operator|&
name|sc
operator|->
name|sc_stp
argument_list|,
name|param
operator|->
name|ifbrp_txhc
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_ifdetach:  *  *	Detach an interface from a bridge.  Called when a member  *	interface is detaching.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_ifdetach
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_bridge
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
comment|/* Check if the interface is a bridge member */
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bif
operator|=
name|bridge_lookup_member_if
argument_list|(
name|sc
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|!=
name|NULL
condition|)
name|bridge_delete_member
argument_list|(
name|sc
argument_list|,
name|bif
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check if the interface is a span port */
name|mtx_lock
argument_list|(
operator|&
name|bridge_list_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sc
argument_list|,
argument|&bridge_list
argument_list|,
argument|sc_list
argument_list|)
block|{
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_spanlist
argument_list|,
argument|bif_next
argument_list|)
if|if
condition|(
name|ifp
operator|==
name|bif
operator|->
name|bif_ifp
condition|)
block|{
name|bridge_delete_span
argument_list|(
name|sc
argument_list|,
name|bif
argument_list|)
expr_stmt|;
break|break;
block|}
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|bridge_list_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_init:  *  *	Initialize a bridge interface.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|bridge_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
return|return;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_brcallout
argument_list|,
name|bridge_rtable_prune_period
operator|*
name|hz
argument_list|,
name|bridge_timer
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|bstp_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_stp
argument_list|)
expr_stmt|;
comment|/* Initialize Spanning Tree */
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_stop:  *  *	Stop the bridge interface.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|disable
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_brcallout
argument_list|)
expr_stmt|;
name|bstp_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_stp
argument_list|)
expr_stmt|;
name|bridge_rtflush
argument_list|(
name|sc
argument_list|,
name|IFBF_FLUSHDYN
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_enqueue:  *  *	Enqueue a packet on a bridge member interface.  *  */
end_comment

begin_function
specifier|static
name|void
name|bridge_enqueue
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|dst_ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|short
name|mflags
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|mflags
operator|=
name|m
operator|->
name|m_flags
expr_stmt|;
comment|/* We may be sending a fragment so traverse the mbuf */
for|for
control|(
init|;
name|m
condition|;
name|m
operator|=
name|m0
control|)
block|{
name|m0
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|IFQ_ENQUEUE
argument_list|(
operator|&
name|dst_ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_obytes
operator|+=
name|len
expr_stmt|;
name|dst_ifp
operator|->
name|if_obytes
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|mflags
operator|&
name|M_MCAST
condition|)
block|{
name|sc
operator|->
name|sc_ifp
operator|->
name|if_omcasts
operator|++
expr_stmt|;
name|dst_ifp
operator|->
name|if_omcasts
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|dst_ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
operator|==
literal|0
condition|)
call|(
modifier|*
name|dst_ifp
operator|->
name|if_start
call|)
argument_list|(
name|dst_ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_dummynet:  *  * 	Receive a queued packet from dummynet and pass it on to the output  * 	interface.  *  *	The mbuf has the Ethernet header already attached.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_dummynet
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_bridge
expr_stmt|;
comment|/* 	 * The packet didnt originate from a member interface. This should only 	 * ever happen if a member interface is removed while packets are 	 * queued for it. 	 */
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|inet_pfil_hook
operator|.
name|ph_busy_count
operator|>=
literal|0
ifdef|#
directive|ifdef
name|INET6
operator|||
name|inet6_pfil_hook
operator|.
name|ph_busy_count
operator|>=
literal|0
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|bridge_pfil
argument_list|(
operator|&
name|m
argument_list|,
name|sc
operator|->
name|sc_ifp
argument_list|,
name|ifp
argument_list|,
name|PFIL_OUT
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
block|}
name|bridge_enqueue
argument_list|(
name|sc
argument_list|,
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_output:  *  *	Send output from a bridge member interface.  This  *	performs the bridging function for locally originated  *	packets.  *  *	The mbuf has the Ethernet header already attached.  We must  *	enqueue or free the mbuf before returning.  */
end_comment

begin_function
specifier|static
name|int
name|bridge_output
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|dst_if
decl_stmt|;
name|struct
name|bridge_softc
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|ETHER_HDR_LEN
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_bridge
expr_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * If bridge is down, but the original output interface is up, 	 * go ahead and send out that interface.  Otherwise, the packet 	 * is dropped below. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|dst_if
operator|=
name|ifp
expr_stmt|;
goto|goto
name|sendunicast
goto|;
block|}
comment|/* 	 * If the packet is a multicast, or we don't know a better way to 	 * get there, send to all interfaces. 	 */
if|if
condition|(
name|ETHER_IS_MULTICAST
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
condition|)
name|dst_if
operator|=
name|NULL
expr_stmt|;
else|else
name|dst_if
operator|=
name|bridge_rtlookup
argument_list|(
name|sc
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_if
operator|==
name|NULL
condition|)
block|{
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|used
init|=
literal|0
decl_stmt|;
name|bridge_span
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|BRIDGE_LOCK2REF
argument_list|(
name|sc
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
name|dst_if
operator|=
name|bif
operator|->
name|bif_ifp
expr_stmt|;
if|if
condition|(
name|dst_if
operator|->
name|if_type
operator|==
name|IFT_GIF
condition|)
continue|continue;
if|if
condition|(
operator|(
name|dst_if
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 			 * If this is not the original output interface, 			 * and the interface is participating in spanning 			 * tree, make sure the port is in a state that 			 * allows forwarding. 			 */
if|if
condition|(
name|dst_if
operator|!=
name|ifp
operator|&&
operator|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
operator|)
operator|&&
name|bif
operator|->
name|bif_stp
operator|.
name|bp_state
operator|==
name|BSTP_IFSTATE_DISCARDING
condition|)
continue|continue;
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|bif
argument_list|,
name|bif_next
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|used
operator|=
literal|1
expr_stmt|;
name|mc
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
name|mc
operator|=
name|m_copypacket
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
name|bridge_enqueue
argument_list|(
name|sc
argument_list|,
name|dst_if
argument_list|,
name|mc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|used
operator|==
literal|0
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|BRIDGE_UNREF
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sendunicast
label|:
comment|/* 	 * XXX Spanning tree consideration here? 	 */
name|bridge_span
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dst_if
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bridge_enqueue
argument_list|(
name|sc
argument_list|,
name|dst_if
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_start:  *  *	Start output on a bridge.  *  */
end_comment

begin_function
specifier|static
name|void
name|bridge_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|dst_if
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|IFQ_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
break|break;
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|dst_if
operator|=
name|NULL
expr_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|dst_if
operator|=
name|bridge_rtlookup
argument_list|(
name|sc
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dst_if
operator|==
name|NULL
condition|)
name|bridge_broadcast
argument_list|(
name|sc
argument_list|,
name|ifp
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bridge_enqueue
argument_list|(
name|sc
argument_list|,
name|dst_if
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_forward:  *  *	The forwarding function of the bridge.  *  *	NOTE: Releases the lock on return.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_forward
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|src_if
decl_stmt|,
modifier|*
name|dst_if
decl_stmt|,
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|src_if
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_ibytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* 	 * Look up the bridge_iflist. 	 */
name|bif
operator|=
name|bridge_lookup_member_if
argument_list|(
name|sc
argument_list|,
name|src_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
block|{
comment|/* Interface is not a bridge member (anymore?) */
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
operator|)
operator|&&
name|bif
operator|->
name|bif_stp
operator|.
name|bp_state
operator|==
name|BSTP_IFSTATE_DISCARDING
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * If the interface is learning, and the source 	 * address is valid and not multicast, record 	 * the address. 	 */
if|if
condition|(
operator|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_LEARNING
operator|)
operator|!=
literal|0
operator|&&
name|ETHER_IS_MULTICAST
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|eh
operator|->
name|ether_shost
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|eh
operator|->
name|ether_shost
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|eh
operator|->
name|ether_shost
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|eh
operator|->
name|ether_shost
index|[
literal|3
index|]
operator|==
literal|0
operator|&&
name|eh
operator|->
name|ether_shost
index|[
literal|4
index|]
operator|==
literal|0
operator|&&
name|eh
operator|->
name|ether_shost
index|[
literal|5
index|]
operator|==
literal|0
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|bridge_rtupdate
argument_list|(
name|sc
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|,
name|bif
argument_list|,
literal|0
argument_list|,
name|IFBAF_DYNAMIC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
operator|)
operator|!=
literal|0
operator|&&
name|bif
operator|->
name|bif_stp
operator|.
name|bp_state
operator|==
name|BSTP_IFSTATE_LEARNING
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * At this point, the port either doesn't participate 	 * in spanning tree or it is in the forwarding state. 	 */
comment|/* 	 * If the packet is unicast, destined for someone on 	 * "this" side of the bridge, drop it. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|dst_if
operator|=
name|bridge_rtlookup
argument_list|(
name|sc
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_if
operator|==
name|dst_if
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* ...forward it to all interfaces. */
name|sc
operator|->
name|sc_ifp
operator|->
name|if_imcasts
operator|++
expr_stmt|;
name|dst_if
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * If we have a destination interface which is a member of our bridge, 	 * OR this is a unicast packet, push it through the bpf(4) machinery. 	 * For broadcast or multicast packets, don't bother because it will 	 * be reinjected into ether_input. We do this before we pass the packets 	 * through the pfil(9) framework, as it is possible that pfil(9) will 	 * drop the packet, or possibly modify it, making it difficult to debug 	 * firewall issues on the bridge. 	 */
if|if
condition|(
name|dst_if
operator|!=
name|NULL
operator|||
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
operator|)
operator|==
literal|0
condition|)
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* run the packet filter */
if|if
condition|(
name|inet_pfil_hook
operator|.
name|ph_busy_count
operator|>=
literal|0
ifdef|#
directive|ifdef
name|INET6
operator|||
name|inet6_pfil_hook
operator|.
name|ph_busy_count
operator|>=
literal|0
endif|#
directive|endif
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bridge_pfil
argument_list|(
operator|&
name|m
argument_list|,
name|ifp
argument_list|,
name|src_if
argument_list|,
name|PFIL_IN
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dst_if
operator|==
name|NULL
condition|)
block|{
name|bridge_broadcast
argument_list|(
name|sc
argument_list|,
name|src_if
argument_list|,
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * At this point, we're dealing with a unicast frame 	 * going to a different interface. 	 */
if|if
condition|(
operator|(
name|dst_if
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|bif
operator|=
name|bridge_lookup_member_if
argument_list|(
name|sc
argument_list|,
name|dst_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
block|{
comment|/* Not a member of the bridge (anymore?) */
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
operator|)
operator|&&
name|bif
operator|->
name|bif_stp
operator|.
name|bp_state
operator|==
name|BSTP_IFSTATE_DISCARDING
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|inet_pfil_hook
operator|.
name|ph_busy_count
operator|>=
literal|0
ifdef|#
directive|ifdef
name|INET6
operator|||
name|inet6_pfil_hook
operator|.
name|ph_busy_count
operator|>=
literal|0
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|bridge_pfil
argument_list|(
operator|&
name|m
argument_list|,
name|sc
operator|->
name|sc_ifp
argument_list|,
name|dst_if
argument_list|,
name|PFIL_OUT
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
block|}
name|bridge_enqueue
argument_list|(
name|sc
argument_list|,
name|dst_if
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_input:  *  *	Receive input from a member interface.  Queue the packet for  *	bridging if it is not for us.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|bridge_input
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_bridge
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|,
modifier|*
name|bif2
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|bifp
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mc
decl_stmt|,
modifier|*
name|mc2
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|m
operator|)
return|;
name|bifp
operator|=
name|sc
operator|->
name|sc_ifp
expr_stmt|;
comment|/* 	 * Implement support for bridge monitoring. If this flag has been 	 * set on this interface, discard the packet once we push it through 	 * the bpf(4) machinery, but before we do, increment the byte and 	 * packet counters associated with this interface. 	 */
if|if
condition|(
operator|(
name|bifp
operator|->
name|if_flags
operator|&
name|IFF_MONITOR
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|bifp
expr_stmt|;
name|BPF_MTAP
argument_list|(
name|bifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|bifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|bifp
operator|->
name|if_ibytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bif
operator|=
name|bridge_lookup_member_if
argument_list|(
name|sc
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|IF_LLADDR
argument_list|(
name|bifp
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If the packet is for us, set the packets source as the 		 * bridge, and return the packet back to ether_input for 		 * local processing. 		 */
comment|/* Note where to send the reply to */
if|if
condition|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_LEARNING
condition|)
operator|(
name|void
operator|)
name|bridge_rtupdate
argument_list|(
name|sc
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|,
name|bif
argument_list|,
literal|0
argument_list|,
name|IFBAF_DYNAMIC
argument_list|)
expr_stmt|;
comment|/* Mark the packet as arriving on the bridge interface */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|bifp
expr_stmt|;
name|BPF_MTAP
argument_list|(
name|bifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|bifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
name|bridge_span
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|ETHER_IS_MULTICAST
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
condition|)
block|{
comment|/* Tap off 802.1D packets; they do not get forwarded. */
if|if
condition|(
name|memcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|bstp_etheraddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|bstp_input
argument_list|(
operator|&
name|bif
operator|->
name|bif_stp
argument_list|,
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
operator|)
operator|&&
name|bif
operator|->
name|bif_stp
operator|.
name|bp_state
operator|==
name|BSTP_IFSTATE_DISCARDING
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
if|if
condition|(
name|bcmp
argument_list|(
name|etherbroadcastaddr
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|,
sizeof|sizeof
argument_list|(
name|etherbroadcastaddr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
name|m
operator|->
name|m_flags
operator||=
name|M_BCAST
expr_stmt|;
else|else
name|m
operator|->
name|m_flags
operator||=
name|M_MCAST
expr_stmt|;
comment|/* 		 * Make a deep copy of the packet and enqueue the copy 		 * for bridge processing; return the original packet for 		 * local processing. 		 */
name|mc
operator|=
name|m_dup
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|==
name|NULL
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
comment|/* Perform the bridge forwarding function with the copy. */
name|bridge_forward
argument_list|(
name|sc
argument_list|,
name|mc
argument_list|)
expr_stmt|;
comment|/* 		 * Reinject the mbuf as arriving on the bridge so we have a 		 * chance at claiming multicast packets. We can not loop back 		 * here from ether_input as a bridge is never a member of a 		 * bridge. 		 */
name|KASSERT
argument_list|(
name|bifp
operator|->
name|if_bridge
operator|==
name|NULL
argument_list|,
operator|(
literal|"loop created in bridge_input"
operator|)
argument_list|)
expr_stmt|;
name|mc2
operator|=
name|m_dup
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc2
operator|!=
name|NULL
condition|)
block|{
comment|/* Keep the layer3 header aligned */
name|int
name|i
init|=
name|min
argument_list|(
name|mc2
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|max_protohdr
argument_list|)
decl_stmt|;
name|mc2
operator|=
name|m_copyup
argument_list|(
name|mc2
argument_list|,
name|i
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mc2
operator|!=
name|NULL
condition|)
block|{
name|mc2
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|bifp
expr_stmt|;
call|(
modifier|*
name|bifp
operator|->
name|if_input
call|)
argument_list|(
name|bifp
argument_list|,
name|mc2
argument_list|)
expr_stmt|;
block|}
comment|/* Return the original packet for local processing. */
return|return
operator|(
name|m
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
operator|)
operator|&&
name|bif
operator|->
name|bif_stp
operator|.
name|bp_state
operator|==
name|BSTP_IFSTATE_DISCARDING
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
comment|/* 	 * Unicast.  Make sure it's not for us. 	 */
name|LIST_FOREACH
argument_list|(
argument|bif2
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
if|if
condition|(
name|bif2
operator|->
name|bif_ifp
operator|->
name|if_type
operator|==
name|IFT_GIF
condition|)
continue|continue;
comment|/* It is destined for us. */
if|if
condition|(
name|memcmp
argument_list|(
name|IF_LLADDR
argument_list|(
name|bif2
operator|->
name|bif_ifp
argument_list|)
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
ifdef|#
directive|ifdef
name|DEV_CARP
operator|||
operator|(
name|bif2
operator|->
name|bif_ifp
operator|->
name|if_carp
operator|&&
name|carp_forus
argument_list|(
name|bif2
operator|->
name|bif_ifp
operator|->
name|if_carp
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|)
operator|)
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_LEARNING
condition|)
operator|(
name|void
operator|)
name|bridge_rtupdate
argument_list|(
name|sc
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|,
name|bif
argument_list|,
literal|0
argument_list|,
name|IFBAF_DYNAMIC
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|bif2
operator|->
name|bif_ifp
expr_stmt|;
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
comment|/* We just received a packet that we sent out. */
if|if
condition|(
name|memcmp
argument_list|(
name|IF_LLADDR
argument_list|(
name|bif2
operator|->
name|bif_ifp
argument_list|)
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
ifdef|#
directive|ifdef
name|DEV_CARP
operator|||
operator|(
name|bif2
operator|->
name|bif_ifp
operator|->
name|if_carp
operator|&&
name|carp_forus
argument_list|(
name|bif2
operator|->
name|bif_ifp
operator|->
name|if_carp
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|)
operator|)
endif|#
directive|endif
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* Perform the bridge forwarding function. */
name|bridge_forward
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_broadcast:  *  *	Send a frame to all interfaces that are members of  *	the bridge, except for the one on which the packet  *	arrived.  *  *	NOTE: Releases the lock on return.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_broadcast
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|src_if
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|runfilt
parameter_list|)
block|{
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|dst_if
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|used
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|BRIDGE_LOCK2REF
argument_list|(
name|sc
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Filter on the bridge interface before broadcasting */
if|if
condition|(
name|runfilt
operator|&&
operator|(
name|inet_pfil_hook
operator|.
name|ph_busy_count
operator|>=
literal|0
ifdef|#
directive|ifdef
name|INET6
operator|||
name|inet6_pfil_hook
operator|.
name|ph_busy_count
operator|>=
literal|0
endif|#
directive|endif
operator|)
condition|)
block|{
if|if
condition|(
name|bridge_pfil
argument_list|(
operator|&
name|m
argument_list|,
name|sc
operator|->
name|sc_ifp
argument_list|,
name|NULL
argument_list|,
name|PFIL_OUT
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
block|}
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
name|dst_if
operator|=
name|bif
operator|->
name|bif_ifp
expr_stmt|;
if|if
condition|(
name|dst_if
operator|==
name|src_if
condition|)
continue|continue;
if|if
condition|(
operator|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
operator|)
operator|&&
name|bif
operator|->
name|bif_stp
operator|.
name|bp_state
operator|==
name|BSTP_IFSTATE_DISCARDING
condition|)
continue|continue;
if|if
condition|(
operator|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_DISCOVER
operator|)
operator|==
literal|0
operator|&&
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|dst_if
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|bif
argument_list|,
name|bif_next
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|mc
operator|=
name|m
expr_stmt|;
name|used
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|mc
operator|=
name|m_dup
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 		 * Filter on the output interface. Pass a NULL bridge interface 		 * pointer so we do not redundantly filter on the bridge for 		 * each interface we broadcast on. 		 */
if|if
condition|(
name|runfilt
operator|&&
operator|(
name|inet_pfil_hook
operator|.
name|ph_busy_count
operator|>=
literal|0
ifdef|#
directive|ifdef
name|INET6
operator|||
name|inet6_pfil_hook
operator|.
name|ph_busy_count
operator|>=
literal|0
endif|#
directive|endif
operator|)
condition|)
block|{
if|if
condition|(
name|used
operator|==
literal|0
condition|)
block|{
comment|/* Keep the layer3 header aligned */
name|i
operator|=
name|min
argument_list|(
name|mc
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|max_protohdr
argument_list|)
expr_stmt|;
name|mc
operator|=
name|m_copyup
argument_list|(
name|mc
argument_list|,
name|i
argument_list|,
name|ETHER_ALIGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|bridge_pfil
argument_list|(
operator|&
name|mc
argument_list|,
name|NULL
argument_list|,
name|dst_if
argument_list|,
name|PFIL_OUT
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|mc
operator|==
name|NULL
condition|)
continue|continue;
block|}
name|bridge_enqueue
argument_list|(
name|sc
argument_list|,
name|dst_if
argument_list|,
name|mc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|used
operator|==
literal|0
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|out
label|:
name|BRIDGE_UNREF
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_span:  *  *	Duplicate a packet out one or more interfaces that are in span mode,  *	the original mbuf is unmodified.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_span
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|dst_if
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mc
decl_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_spanlist
argument_list|)
condition|)
return|return;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_spanlist
argument_list|,
argument|bif_next
argument_list|)
block|{
name|dst_if
operator|=
name|bif
operator|->
name|bif_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|dst_if
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|mc
operator|=
name|m_copypacket
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
continue|continue;
block|}
name|bridge_enqueue
argument_list|(
name|sc
argument_list|,
name|dst_if
argument_list|,
name|mc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * bridge_rtupdate:  *  *	Add a bridge routing entry.  */
end_comment

begin_function
specifier|static
name|int
name|bridge_rtupdate
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|dst
parameter_list|,
name|struct
name|bridge_iflist
modifier|*
name|bif
parameter_list|,
name|int
name|setflags
parameter_list|,
name|uint8_t
name|flags
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|dst_if
init|=
name|bif
operator|->
name|bif_ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * A route for this destination might already exist.  If so, 	 * update it, otherwise create a new one. 	 */
if|if
condition|(
operator|(
name|brt
operator|=
name|bridge_rtnode_lookup
argument_list|(
name|sc
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_brtcnt
operator|>=
name|sc
operator|->
name|sc_brtmax
condition|)
block|{
name|sc
operator|->
name|sc_brtexceeded
operator|++
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
comment|/* 		 * Allocate a new bridge forwarding node, and 		 * initialize the expiration time and Ethernet 		 * address. 		 */
name|brt
operator|=
name|uma_zalloc
argument_list|(
name|bridge_rtnode_zone
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|brt
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STICKY
condition|)
name|brt
operator|->
name|brt_flags
operator|=
name|IFBAF_STICKY
expr_stmt|;
else|else
name|brt
operator|->
name|brt_flags
operator|=
name|IFBAF_DYNAMIC
expr_stmt|;
name|brt
operator|->
name|brt_ifp
operator|=
name|dst_if
expr_stmt|;
name|memcpy
argument_list|(
name|brt
operator|->
name|brt_addr
argument_list|,
name|dst
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bridge_rtnode_insert
argument_list|(
name|sc
argument_list|,
name|brt
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|uma_zfree
argument_list|(
name|bridge_rtnode_zone
argument_list|,
name|brt
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|brt
operator|->
name|brt_flags
operator|&
name|IFBAF_TYPEMASK
operator|)
operator|==
name|IFBAF_DYNAMIC
condition|)
name|brt
operator|->
name|brt_ifp
operator|=
name|dst_if
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|IFBAF_TYPEMASK
operator|)
operator|==
name|IFBAF_DYNAMIC
condition|)
name|brt
operator|->
name|brt_expire
operator|=
name|time_uptime
operator|+
name|sc
operator|->
name|sc_brttimeout
expr_stmt|;
if|if
condition|(
name|setflags
condition|)
name|brt
operator|->
name|brt_flags
operator|=
name|flags
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_rtlookup:  *  *	Lookup the destination interface for an address.  */
end_comment

begin_function
specifier|static
name|struct
name|ifnet
modifier|*
name|bridge_rtlookup
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|brt
operator|=
name|bridge_rtnode_lookup
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|brt
operator|->
name|brt_ifp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_rttrim:  *  *	Trim the routine table so that we have a number  *	of routing entries less than or equal to the  *	maximum number.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_rttrim
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|,
modifier|*
name|nbrt
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Make sure we actually need to do this. */
if|if
condition|(
name|sc
operator|->
name|sc_brtcnt
operator|<=
name|sc
operator|->
name|sc_brtmax
condition|)
return|return;
comment|/* Force an aging cycle; this might trim enough addresses. */
name|bridge_rtage
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_brtcnt
operator|<=
name|sc
operator|->
name|sc_brtmax
condition|)
return|return;
name|LIST_FOREACH_SAFE
argument_list|(
argument|brt
argument_list|,
argument|&sc->sc_rtlist
argument_list|,
argument|brt_list
argument_list|,
argument|nbrt
argument_list|)
block|{
if|if
condition|(
operator|(
name|brt
operator|->
name|brt_flags
operator|&
name|IFBAF_TYPEMASK
operator|)
operator|==
name|IFBAF_DYNAMIC
condition|)
block|{
name|bridge_rtnode_destroy
argument_list|(
name|sc
argument_list|,
name|brt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_brtcnt
operator|<=
name|sc
operator|->
name|sc_brtmax
condition|)
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * bridge_timer:  *  *	Aging timer for the bridge.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bridge_rtage
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_brcallout
argument_list|,
name|bridge_rtable_prune_period
operator|*
name|hz
argument_list|,
name|bridge_timer
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_rtage:  *  *	Perform an aging cycle.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_rtage
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|,
modifier|*
name|nbrt
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|brt
argument_list|,
argument|&sc->sc_rtlist
argument_list|,
argument|brt_list
argument_list|,
argument|nbrt
argument_list|)
block|{
if|if
condition|(
operator|(
name|brt
operator|->
name|brt_flags
operator|&
name|IFBAF_TYPEMASK
operator|)
operator|==
name|IFBAF_DYNAMIC
condition|)
block|{
if|if
condition|(
name|time_uptime
operator|>=
name|brt
operator|->
name|brt_expire
condition|)
name|bridge_rtnode_destroy
argument_list|(
name|sc
argument_list|,
name|brt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * bridge_rtflush:  *  *	Remove all dynamic addresses from the bridge.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_rtflush
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|int
name|full
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|,
modifier|*
name|nbrt
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|brt
argument_list|,
argument|&sc->sc_rtlist
argument_list|,
argument|brt_list
argument_list|,
argument|nbrt
argument_list|)
block|{
if|if
condition|(
name|full
operator|||
operator|(
name|brt
operator|->
name|brt_flags
operator|&
name|IFBAF_TYPEMASK
operator|)
operator|==
name|IFBAF_DYNAMIC
condition|)
name|bridge_rtnode_destroy
argument_list|(
name|sc
argument_list|,
name|brt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * bridge_rtdaddr:  *  *	Remove an address from the table.  */
end_comment

begin_function
specifier|static
name|int
name|bridge_rtdaddr
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|brt
operator|=
name|bridge_rtnode_lookup
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|bridge_rtnode_destroy
argument_list|(
name|sc
argument_list|,
name|brt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_rtdelete:  *  *	Delete routes to a speicifc member interface.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_rtdelete
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|full
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|,
modifier|*
name|nbrt
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|brt
argument_list|,
argument|&sc->sc_rtlist
argument_list|,
argument|brt_list
argument_list|,
argument|nbrt
argument_list|)
block|{
if|if
condition|(
name|brt
operator|->
name|brt_ifp
operator|==
name|ifp
operator|&&
operator|(
name|full
operator|||
operator|(
name|brt
operator|->
name|brt_flags
operator|&
name|IFBAF_TYPEMASK
operator|)
operator|==
name|IFBAF_DYNAMIC
operator|)
condition|)
name|bridge_rtnode_destroy
argument_list|(
name|sc
argument_list|,
name|brt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * bridge_rtable_init:  *  *	Initialize the route table for this bridge.  */
end_comment

begin_function
specifier|static
name|int
name|bridge_rtable_init
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|sc
operator|->
name|sc_rthash
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|sc_rthash
argument_list|)
operator|*
name|BRIDGE_RTHASH_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rthash
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BRIDGE_RTHASH_SIZE
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rthash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rthash_key
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rtlist
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_rtable_fini:  *  *	Deconstruct the route table for this bridge.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_rtable_fini
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|sc_rthash
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The following hash function is adapted from "Hash Functions" by Bob Jenkins  * ("Algorithm Alley", Dr. Dobbs Journal, September 1997).  */
end_comment

begin_define
define|#
directive|define
name|mix
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
define|\
value|do {									\ 	a -= b; a -= c; a ^= (c>> 13);					\ 	b -= c; b -= a; b ^= (a<< 8);					\ 	c -= a; c -= b; c ^= (b>> 13);					\ 	a -= b; a -= c; a ^= (c>> 12);					\ 	b -= c; b -= a; b ^= (a<< 16);					\ 	c -= a; c -= b; c ^= (b>> 5);					\ 	a -= b; a -= c; a ^= (c>> 3);					\ 	b -= c; b -= a; b ^= (a<< 10);					\ 	c -= a; c -= b; c ^= (b>> 15);					\ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_function
specifier|static
name|__inline
name|uint32_t
name|bridge_rthash
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
name|uint32_t
name|a
init|=
literal|0x9e3779b9
decl_stmt|,
name|b
init|=
literal|0x9e3779b9
decl_stmt|,
name|c
init|=
name|sc
operator|->
name|sc_rthash_key
decl_stmt|;
name|b
operator|+=
name|addr
index|[
literal|5
index|]
operator|<<
literal|8
expr_stmt|;
name|b
operator|+=
name|addr
index|[
literal|4
index|]
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|mix
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|&
name|BRIDGE_RTHASH_MASK
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|mix
end_undef

begin_function
specifier|static
name|int
name|bridge_rtnode_addr_cmp
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|a
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|b
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|d
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|d
operator|=
literal|0
init|;
name|i
operator|<
name|ETHER_ADDR_LEN
operator|&&
name|d
operator|==
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
operator|(
operator|(
name|int
operator|)
name|a
index|[
name|i
index|]
operator|)
operator|-
operator|(
operator|(
name|int
operator|)
name|b
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|d
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_rtnode_lookup:  *  *	Look up a bridge route node for the specified destination.  */
end_comment

begin_function
specifier|static
name|struct
name|bridge_rtnode
modifier|*
name|bridge_rtnode_lookup
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|;
name|uint32_t
name|hash
decl_stmt|;
name|int
name|dir
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hash
operator|=
name|bridge_rthash
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|brt
argument_list|,
argument|&sc->sc_rthash[hash]
argument_list|,
argument|brt_hash
argument_list|)
block|{
name|dir
operator|=
name|bridge_rtnode_addr_cmp
argument_list|(
name|addr
argument_list|,
name|brt
operator|->
name|brt_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
literal|0
condition|)
return|return
operator|(
name|brt
operator|)
return|;
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_rtnode_insert:  *  *	Insert the specified bridge node into the route table.  We  *	assume the entry is not already in the table.  */
end_comment

begin_function
specifier|static
name|int
name|bridge_rtnode_insert
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bridge_rtnode
modifier|*
name|brt
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|lbrt
decl_stmt|;
name|uint32_t
name|hash
decl_stmt|;
name|int
name|dir
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hash
operator|=
name|bridge_rthash
argument_list|(
name|sc
argument_list|,
name|brt
operator|->
name|brt_addr
argument_list|)
expr_stmt|;
name|lbrt
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rthash
index|[
name|hash
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbrt
operator|==
name|NULL
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_rthash
index|[
name|hash
index|]
argument_list|,
name|brt
argument_list|,
name|brt_hash
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
do|do
block|{
name|dir
operator|=
name|bridge_rtnode_addr_cmp
argument_list|(
name|brt
operator|->
name|brt_addr
argument_list|,
name|lbrt
operator|->
name|brt_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
literal|0
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
block|{
name|LIST_INSERT_BEFORE
argument_list|(
name|lbrt
argument_list|,
name|brt
argument_list|,
name|brt_hash
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|lbrt
argument_list|,
name|brt_hash
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|LIST_INSERT_AFTER
argument_list|(
name|lbrt
argument_list|,
name|brt
argument_list|,
name|brt_hash
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|lbrt
operator|=
name|LIST_NEXT
argument_list|(
name|lbrt
argument_list|,
name|brt_hash
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|lbrt
operator|!=
name|NULL
condition|)
do|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|panic
argument_list|(
literal|"bridge_rtnode_insert: impossible"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|out
label|:
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_rtlist
argument_list|,
name|brt
argument_list|,
name|brt_list
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_brtcnt
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_rtnode_destroy:  *  *	Destroy a bridge rtnode.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_rtnode_destroy
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bridge_rtnode
modifier|*
name|brt
parameter_list|)
block|{
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|brt
argument_list|,
name|brt_hash
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|brt
argument_list|,
name|brt_list
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_brtcnt
operator|--
expr_stmt|;
name|uma_zfree
argument_list|(
name|bridge_rtnode_zone
argument_list|,
name|brt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_rtable_expire:  *  *	Set the expiry time for all routes on an interface.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_rtable_expire
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|age
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_bridge
decl_stmt|;
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * If the age is zero then flush, otherwise set all the expiry times to 	 * age for the interface 	 */
if|if
condition|(
name|age
operator|==
literal|0
condition|)
name|bridge_rtdelete
argument_list|(
name|sc
argument_list|,
name|ifp
argument_list|,
name|IFBF_FLUSHDYN
argument_list|)
expr_stmt|;
else|else
block|{
name|LIST_FOREACH
argument_list|(
argument|brt
argument_list|,
argument|&sc->sc_rtlist
argument_list|,
argument|brt_list
argument_list|)
block|{
comment|/* Cap the expiry time to 'age' */
if|if
condition|(
name|brt
operator|->
name|brt_ifp
operator|==
name|ifp
operator|&&
name|brt
operator|->
name|brt_expire
operator|>
name|time_uptime
operator|+
name|age
operator|&&
operator|(
name|brt
operator|->
name|brt_flags
operator|&
name|IFBAF_TYPEMASK
operator|)
operator|==
name|IFBAF_DYNAMIC
condition|)
name|brt
operator|->
name|brt_expire
operator|=
name|time_uptime
operator|+
name|age
expr_stmt|;
block|}
block|}
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_state_change:  *  *	Callback from the bridgestp code when a port changes states.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_state_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_bridge
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|stpstates
index|[]
init|=
block|{
literal|"disabled"
block|,
literal|"listening"
block|,
literal|"learning"
block|,
literal|"forwarding"
block|,
literal|"blocking"
block|,
literal|"discarding"
block|}
decl_stmt|;
if|if
condition|(
name|log_stp
condition|)
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"%s: state changed to %s on %s\n"
argument_list|,
name|sc
operator|->
name|sc_ifp
operator|->
name|if_xname
argument_list|,
name|stpstates
index|[
name|state
index|]
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send bridge packets through pfil if they are one of the types pfil can deal  * with, or if they are ARP or REVARP.  (pfil will pass ARP and REVARP without  * question.) If *bifp or *ifp are NULL then packet filtering is skipped for  * that interface.  */
end_comment

begin_function
specifier|static
name|int
name|bridge_pfil
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|struct
name|ifnet
modifier|*
name|bifp
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|int
name|snap
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|,
name|hlen
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh1
decl_stmt|,
name|eh2
decl_stmt|;
name|struct
name|ip_fw_args
name|args
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|llc
name|llc1
decl_stmt|;
name|u_int16_t
name|ether_type
decl_stmt|;
name|snap
operator|=
literal|0
expr_stmt|;
name|error
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Default error if not error == 0 */
comment|/* we may return with the IP fields swapped, ensure its not shared */
name|KASSERT
argument_list|(
name|M_WRITABLE
argument_list|(
operator|*
name|mp
argument_list|)
argument_list|,
operator|(
literal|"%s: modifying a shared mbuf"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfil_bridge
operator|==
literal|0
operator|&&
name|pfil_member
operator|==
literal|0
operator|&&
name|pfil_ipfw
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* filtering is disabled */
name|i
operator|=
name|min
argument_list|(
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|max_protohdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|<
name|i
condition|)
block|{
operator|*
name|mp
operator|=
name|m_pullup
argument_list|(
operator|*
name|mp
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: m_pullup failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|eh1
operator|=
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|ether_type
operator|=
name|ntohs
argument_list|(
name|eh1
operator|->
name|ether_type
argument_list|)
expr_stmt|;
comment|/* 	 * Check for SNAP/LLC. 	 */
if|if
condition|(
name|ether_type
operator|<
name|ETHERMTU
condition|)
block|{
name|struct
name|llc
modifier|*
name|llc2
init|=
operator|(
expr|struct
name|llc
operator|*
operator|)
operator|(
name|eh1
operator|+
literal|1
operator|)
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|>=
name|ETHER_HDR_LEN
operator|+
literal|8
operator|&&
name|llc2
operator|->
name|llc_dsap
operator|==
name|LLC_SNAP_LSAP
operator|&&
name|llc2
operator|->
name|llc_ssap
operator|==
name|LLC_SNAP_LSAP
operator|&&
name|llc2
operator|->
name|llc_control
operator|==
name|LLC_UI
condition|)
block|{
name|ether_type
operator|=
name|htons
argument_list|(
name|llc2
operator|->
name|llc_un
operator|.
name|type_snap
operator|.
name|ether_type
argument_list|)
expr_stmt|;
name|snap
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * If we're trying to filter bridge traffic, don't look at anything 	 * other than IP and ARP traffic.  If the filter doesn't understand 	 * IPv6, don't allow IPv6 through the bridge either.  This is lame 	 * since if we really wanted, say, an AppleTalk filter, we are hosed, 	 * but of course we don't have an AppleTalk filter to begin with. 	 * (Note that since pfil doesn't understand ARP it will pass *ALL* 	 * ARP traffic.) 	 */
switch|switch
condition|(
name|ether_type
condition|)
block|{
case|case
name|ETHERTYPE_ARP
case|:
case|case
name|ETHERTYPE_REVARP
case|:
if|if
condition|(
name|pfil_ipfw_arp
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Automatically pass */
break|break;
case|case
name|ETHERTYPE_IP
case|:
ifdef|#
directive|ifdef
name|INET6
case|case
name|ETHERTYPE_IPV6
case|:
endif|#
directive|endif
comment|/* INET6 */
break|break;
default|default:
comment|/* 			 * Check to see if the user wants to pass non-ip 			 * packets, these will not be checked by pfil(9) and 			 * passed unconditionally so the default is to drop. 			 */
if|if
condition|(
name|pfil_onlyip
condition|)
goto|goto
name|bad
goto|;
block|}
comment|/* Strip off the Ethernet header and keep a copy. */
name|m_copydata
argument_list|(
operator|*
name|mp
argument_list|,
literal|0
argument_list|,
name|ETHER_HDR_LEN
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|eh2
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
operator|*
name|mp
argument_list|,
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
comment|/* Strip off snap header, if present */
if|if
condition|(
name|snap
condition|)
block|{
name|m_copydata
argument_list|(
operator|*
name|mp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|llc1
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
operator|*
name|mp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check the IP header for alignment and errors 	 */
if|if
condition|(
name|dir
operator|==
name|PFIL_IN
condition|)
block|{
switch|switch
condition|(
name|ether_type
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
name|error
operator|=
name|bridge_ip_checkbasic
argument_list|(
name|mp
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|ETHERTYPE_IPV6
case|:
name|error
operator|=
name|bridge_ip6_checkbasic
argument_list|(
name|mp
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET6 */
default|default:
name|error
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|IPFW_LOADED
operator|&&
name|pfil_ipfw
operator|!=
literal|0
operator|&&
name|dir
operator|==
name|PFIL_OUT
operator|&&
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
operator|-
literal|1
expr_stmt|;
name|args
operator|.
name|rule
operator|=
name|ip_dn_claim_rule
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|rule
operator|!=
name|NULL
operator|&&
name|fw_one_pass
condition|)
goto|goto
name|ipfwpass
goto|;
comment|/* packet already partially processed */
name|args
operator|.
name|m
operator|=
operator|*
name|mp
expr_stmt|;
name|args
operator|.
name|oif
operator|=
name|ifp
expr_stmt|;
name|args
operator|.
name|next_hop
operator|=
name|NULL
expr_stmt|;
name|args
operator|.
name|eh
operator|=
operator|&
name|eh2
expr_stmt|;
name|args
operator|.
name|inp
operator|=
name|NULL
expr_stmt|;
comment|/* used by ipfw uid/gid/jail rules */
name|i
operator|=
name|ip_fw_chk_ptr
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|args
operator|.
name|m
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|DUMMYNET_LOADED
operator|&&
operator|(
name|i
operator|==
name|IP_FW_DUMMYNET
operator|)
condition|)
block|{
comment|/* put the Ethernet header back on */
name|M_PREPEND
argument_list|(
operator|*
name|mp
argument_list|,
name|ETHER_HDR_LEN
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bcopy
argument_list|(
operator|&
name|eh2
argument_list|,
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
comment|/* 			 * Pass the pkt to dummynet, which consumes it. The 			 * packet will return to us via bridge_dummynet(). 			 */
name|args
operator|.
name|oif
operator|=
name|ifp
expr_stmt|;
name|ip_dn_io_ptr
argument_list|(
operator|*
name|mp
argument_list|,
name|DN_TO_IFB_FWD
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|i
operator|!=
name|IP_FW_PASS
condition|)
comment|/* drop */
goto|goto
name|bad
goto|;
block|}
name|ipfwpass
label|:
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Run the packet through pfil 	 */
switch|switch
condition|(
name|ether_type
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
comment|/* 		 * before calling the firewall, swap fields the same as 		 * IP does. here we assume the header is contiguous 		 */
name|ip
operator|=
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
expr_stmt|;
comment|/* 		 * Run pfil on the member interface and the bridge, both can 		 * be skipped by clearing pfil_member or pfil_bridge. 		 * 		 * Keep the order: 		 *   in_if -> bridge_if -> out_if 		 */
if|if
condition|(
name|pfil_bridge
operator|&&
name|dir
operator|==
name|PFIL_OUT
operator|&&
name|bifp
operator|!=
name|NULL
condition|)
name|error
operator|=
name|pfil_run_hooks
argument_list|(
operator|&
name|inet_pfil_hook
argument_list|,
name|mp
argument_list|,
name|bifp
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
operator|||
name|error
operator|!=
literal|0
condition|)
comment|/* filter may consume */
break|break;
if|if
condition|(
name|pfil_member
operator|&&
name|ifp
operator|!=
name|NULL
condition|)
name|error
operator|=
name|pfil_run_hooks
argument_list|(
operator|&
name|inet_pfil_hook
argument_list|,
name|mp
argument_list|,
name|ifp
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
operator|||
name|error
operator|!=
literal|0
condition|)
comment|/* filter may consume */
break|break;
if|if
condition|(
name|pfil_bridge
operator|&&
name|dir
operator|==
name|PFIL_IN
operator|&&
name|bifp
operator|!=
name|NULL
condition|)
name|error
operator|=
name|pfil_run_hooks
argument_list|(
operator|&
name|inet_pfil_hook
argument_list|,
name|mp
argument_list|,
name|bifp
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
operator|||
name|error
operator|!=
literal|0
condition|)
comment|/* filter may consume */
break|break;
comment|/* check if we need to fragment the packet */
if|if
condition|(
name|pfil_member
operator|&&
name|ifp
operator|!=
name|NULL
operator|&&
name|dir
operator|==
name|PFIL_OUT
condition|)
block|{
name|i
operator|=
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|ifp
operator|->
name|if_mtu
condition|)
block|{
name|error
operator|=
name|bridge_fragment
argument_list|(
name|ifp
argument_list|,
operator|*
name|mp
argument_list|,
operator|&
name|eh2
argument_list|,
name|snap
argument_list|,
operator|&
name|llc1
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* Recalculate the ip checksum and restore byte ordering */
name|ip
operator|=
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|hlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|hlen
operator|>
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|mp
operator|=
name|m_pullup
argument_list|(
operator|*
name|mp
argument_list|,
name|hlen
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|ip
operator|=
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
block|}
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hlen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
name|ip
operator|->
name|ip_sum
operator|=
name|in_cksum_hdr
argument_list|(
name|ip
argument_list|)
expr_stmt|;
else|else
name|ip
operator|->
name|ip_sum
operator|=
name|in_cksum
argument_list|(
operator|*
name|mp
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|ETHERTYPE_IPV6
case|:
if|if
condition|(
name|pfil_bridge
operator|&&
name|dir
operator|==
name|PFIL_OUT
operator|&&
name|bifp
operator|!=
name|NULL
condition|)
name|error
operator|=
name|pfil_run_hooks
argument_list|(
operator|&
name|inet6_pfil_hook
argument_list|,
name|mp
argument_list|,
name|bifp
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
operator|||
name|error
operator|!=
literal|0
condition|)
comment|/* filter may consume */
break|break;
if|if
condition|(
name|pfil_member
operator|&&
name|ifp
operator|!=
name|NULL
condition|)
name|error
operator|=
name|pfil_run_hooks
argument_list|(
operator|&
name|inet6_pfil_hook
argument_list|,
name|mp
argument_list|,
name|ifp
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
operator|||
name|error
operator|!=
literal|0
condition|)
comment|/* filter may consume */
break|break;
if|if
condition|(
name|pfil_bridge
operator|&&
name|dir
operator|==
name|PFIL_IN
operator|&&
name|bifp
operator|!=
name|NULL
condition|)
name|error
operator|=
name|pfil_run_hooks
argument_list|(
operator|&
name|inet6_pfil_hook
argument_list|,
name|mp
argument_list|,
name|bifp
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
name|error
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Finally, put everything back the way it was and return 	 */
if|if
condition|(
name|snap
condition|)
block|{
name|M_PREPEND
argument_list|(
operator|*
name|mp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bcopy
argument_list|(
operator|&
name|llc1
argument_list|,
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|M_PREPEND
argument_list|(
operator|*
name|mp
argument_list|,
name|ETHER_HDR_LEN
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bcopy
argument_list|(
operator|&
name|eh2
argument_list|,
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform basic checks on header size since  * pfil assumes ip_input has already processed  * it for it.  Cut-and-pasted from ip_input.c.  * Given how simple the IPv6 version is,  * does the IPv4 version really need to be  * this complicated?  *  * XXX Should we update ipstat here, or not?  * XXX Right now we update ipstat but not  * XXX csum_counter.  */
end_comment

begin_function
specifier|static
name|int
name|bridge_ip_checkbasic
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|mp
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|len
decl_stmt|,
name|hlen
decl_stmt|;
name|u_short
name|sum
decl_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|IP_HDR_ALIGNED_P
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_copyup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|,
operator|(
name|max_linkhdr
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* XXXJRT new stat, please */
name|ipstat
operator|.
name|ips_toosmall
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ipstat
operator|.
name|ips_toosmall
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|ip
operator|->
name|ip_v
operator|!=
name|IPVERSION
condition|)
block|{
name|ipstat
operator|.
name|ips_badvers
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|hlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
comment|/* minimum header length */
name|ipstat
operator|.
name|ips_badhlen
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|hlen
operator|>
name|m
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipstat
operator|.
name|ips_badhlen
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP_CHECKED
condition|)
block|{
name|sum
operator|=
operator|!
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP_VALID
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hlen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
name|sum
operator|=
name|in_cksum_hdr
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sum
condition|)
block|{
name|ipstat
operator|.
name|ips_badsum
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Retrieve the packet length. */
name|len
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
comment|/* 	 * Check for additional length bogosity 	 */
if|if
condition|(
name|len
operator|<
name|hlen
condition|)
block|{
name|ipstat
operator|.
name|ips_badlen
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Check that the amount of data in the buffers 	 * is as at least much as the IP header would have us expect. 	 * Drop packet if shorter than we expect. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|len
condition|)
block|{
name|ipstat
operator|.
name|ips_tooshort
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Checks out, proceed */
operator|*
name|mp
operator|=
name|m
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
operator|*
name|mp
operator|=
name|m
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_comment
comment|/*  * Same as above, but for IPv6.  * Cut-and-pasted from ip6_input.c.  * XXX Should we update ip6stat, or not?  */
end_comment

begin_function
specifier|static
name|int
name|bridge_ip6_checkbasic
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|mp
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
comment|/* 	 * If the IPv6 header is not aligned, slurp it up into a new 	 * mbuf with space for link headers, in the event we forward 	 * it.  Otherwise, if it is aligned, make sure the entire base 	 * IPv6 header is in the first mbuf of the chain. 	 */
if|if
condition|(
name|IP6_HDR_ALIGNED_P
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|inifp
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|m_copyup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
operator|(
name|max_linkhdr
operator|+
literal|3
operator|)
operator|&
operator|~
literal|3
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* XXXJRT new stat, please */
name|ip6stat
operator|.
name|ip6s_toosmall
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|inifp
argument_list|,
name|ifs6_in_hdrerr
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|inifp
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_toosmall
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|inifp
argument_list|,
name|ifs6_in_hdrerr
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ip6
operator|->
name|ip6_vfc
operator|&
name|IPV6_VERSION_MASK
operator|)
operator|!=
name|IPV6_VERSION
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_badvers
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_hdrerr
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Checks out, proceed */
operator|*
name|mp
operator|=
name|m
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
operator|*
name|mp
operator|=
name|m
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_comment
comment|/*  * bridge_fragment:  *  *	Return a fragmented mbuf chain.  */
end_comment

begin_function
specifier|static
name|int
name|bridge_fragment
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ether_header
modifier|*
name|eh
parameter_list|,
name|int
name|snap
parameter_list|,
name|struct
name|llc
modifier|*
name|llc
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|error
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|error
operator|=
name|ip_fragment
argument_list|(
name|ip
argument_list|,
operator|&
name|m
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|,
name|ifp
operator|->
name|if_hwassist
argument_list|,
name|CSUM_DELAY_IP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* walk the chain and re-add the Ethernet header */
for|for
control|(
name|m0
operator|=
name|m
init|;
name|m0
condition|;
name|m0
operator|=
name|m0
operator|->
name|m_nextpkt
control|)
block|{
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|snap
condition|)
block|{
name|M_PREPEND
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
continue|continue;
block|}
name|bcopy
argument_list|(
name|llc
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|M_PREPEND
argument_list|(
name|m0
argument_list|,
name|ETHER_HDR_LEN
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
continue|continue;
block|}
name|bcopy
argument_list|(
name|eh
argument_list|,
name|mtod
argument_list|(
name|m0
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
block|}
else|else
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|ipstat
operator|.
name|ips_fragmented
operator|++
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|out
label|:
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

