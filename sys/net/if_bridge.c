begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: if_bridge.c,v 1.31 2005/06/01 19:45:34 jdc Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright 2001 Wasabi Systems, Inc.  * All rights reserved.  *  * Written by Jason R. Thorpe for Wasabi Systems, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed for the NetBSD Project by  *	Wasabi Systems, Inc.  * 4. The name of Wasabi Systems, Inc. may not be used to endorse  *    or promote products derived from this software without specific prior  *    written permission.  *  * THIS SOFTWARE IS PROVIDED BY WASABI SYSTEMS, INC. ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL WASABI SYSTEMS, INC  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1999, 2000 Jason L. Wright (jason@thought.net)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Jason L. Wright  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN  * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  * OpenBSD: if_bridge.c,v 1.60 2001/06/15 03:38:33 itojun Exp  */
end_comment

begin_comment
comment|/*  * Network interface bridge support.  *  * TODO:  *  *	- Currently only supports Ethernet-like interfaces (Ethernet,  *	  802.11, VLANs on Ethernet, etc.)  Figure out a nice way  *	  to bridge other types of interfaces (FDDI-FDDI, and maybe  *	  consider heterogenous bridges).  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_comment
comment|/* for net/if.h */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ctype.h>
end_include

begin_comment
comment|/* string functions */
end_comment

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/random.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_clone.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/pfil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_comment
comment|/* for struct arpcom */
end_comment

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_comment
comment|/* for struct arpcom */
end_comment

begin_include
include|#
directive|include
file|<net/if_bridgevar.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_fw.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_dummynet.h>
end_include

begin_comment
comment|/*  * Size of the route hash table.  Must be a power of two.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BRIDGE_RTHASH_SIZE
end_ifndef

begin_define
define|#
directive|define
name|BRIDGE_RTHASH_SIZE
value|1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BRIDGE_RTHASH_MASK
value|(BRIDGE_RTHASH_SIZE - 1)
end_define

begin_comment
comment|/*  * Maximum number of addresses to cache.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BRIDGE_RTABLE_MAX
end_ifndef

begin_define
define|#
directive|define
name|BRIDGE_RTABLE_MAX
value|100
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Spanning tree defaults.  */
end_comment

begin_define
define|#
directive|define
name|BSTP_DEFAULT_MAX_AGE
value|(20 * 256)
end_define

begin_define
define|#
directive|define
name|BSTP_DEFAULT_HELLO_TIME
value|(2 * 256)
end_define

begin_define
define|#
directive|define
name|BSTP_DEFAULT_FORWARD_DELAY
value|(15 * 256)
end_define

begin_define
define|#
directive|define
name|BSTP_DEFAULT_HOLD_TIME
value|(1 * 256)
end_define

begin_define
define|#
directive|define
name|BSTP_DEFAULT_BRIDGE_PRIORITY
value|0x8000
end_define

begin_define
define|#
directive|define
name|BSTP_DEFAULT_PORT_PRIORITY
value|0x80
end_define

begin_define
define|#
directive|define
name|BSTP_DEFAULT_PATH_COST
value|55
end_define

begin_comment
comment|/*  * Timeout (in seconds) for entries learned dynamically.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BRIDGE_RTABLE_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|BRIDGE_RTABLE_TIMEOUT
value|(20 * 60)
end_define

begin_comment
comment|/* same as ARP */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Number of seconds between walks of the route list.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BRIDGE_RTABLE_PRUNE_PERIOD
end_ifndef

begin_define
define|#
directive|define
name|BRIDGE_RTABLE_PRUNE_PERIOD
value|(5 * 60)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|bridge_list_mtx
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|struct
name|mbuf
modifier|*
function_decl|(
modifier|*
name|bridge_input_p
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
function_decl|(
modifier|*
name|bridge_output_p
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|struct
name|rtentry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
function_decl|(
modifier|*
name|bridge_dn_p
function_decl|)
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|bridge_rtable_prune_period
init|=
name|BRIDGE_RTABLE_PRUNE_PERIOD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uma_zone_t
name|bridge_rtnode_zone
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|bridge_clone_create
parameter_list|(
name|struct
name|if_clone
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bridge_clone_destroy
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bridge_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bridge_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bridge_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bridge_forward
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bridge_timer
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bridge_broadcast
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_rtupdate
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|ifnet
modifier|*
name|bridge_rtlookup
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bridge_rttrim
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bridge_rtage
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bridge_rtflush
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_rtdaddr
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_rtable_init
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bridge_rtable_fini
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|bridge_rtnode
modifier|*
name|bridge_rtnode_lookup
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_rtnode_insert
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|bridge_rtnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bridge_rtnode_destroy
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|bridge_rtnode
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|bridge_iflist
modifier|*
name|bridge_lookup_member
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|bridge_iflist
modifier|*
name|bridge_lookup_member_if
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|bridge_delete_member
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|struct
name|bridge_iflist
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_ioctl_add
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_ioctl_del
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_ioctl_gifflags
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_ioctl_sifflags
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_ioctl_scache
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_ioctl_gcache
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_ioctl_gifs
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_ioctl_rts
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_ioctl_saddr
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_ioctl_sto
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_ioctl_gto
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_ioctl_daddr
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_ioctl_flush
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_ioctl_gpri
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_ioctl_spri
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_ioctl_ght
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_ioctl_sht
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_ioctl_gfd
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_ioctl_sfd
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_ioctl_gma
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_ioctl_sma
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_ioctl_sifprio
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|bridge_ioctl_sifcost
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_pfil
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bridge_ip_checkbasic
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function_decl
specifier|static
name|int
name|bridge_ip6_checkbasic
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_link
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_link
argument_list|,
name|IFT_BRIDGE
argument_list|,
name|bridge
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Bridge"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pfil_bridge
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* run pfil hooks on the bridge interface */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pfil_member
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* run pfil hooks on the member interface */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pfil_ipfw
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* layer2 filter with ipfw */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_link_bridge
argument_list|,
name|OID_AUTO
argument_list|,
name|pfil_bridge
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pfil_bridge
argument_list|,
literal|0
argument_list|,
literal|"Packet filter on the bridge interface"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_link_bridge
argument_list|,
name|OID_AUTO
argument_list|,
name|pfil_member
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pfil_member
argument_list|,
literal|0
argument_list|,
literal|"Packet filter on the member interface"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|bridge_control
block|{
name|int
function_decl|(
modifier|*
name|bc_func
function_decl|)
parameter_list|(
name|struct
name|bridge_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|int
name|bc_argsize
decl_stmt|;
name|int
name|bc_flags
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|BC_F_COPYIN
value|0x01
end_define

begin_comment
comment|/* copy arguments in */
end_comment

begin_define
define|#
directive|define
name|BC_F_COPYOUT
value|0x02
end_define

begin_comment
comment|/* copy arguments out */
end_comment

begin_define
define|#
directive|define
name|BC_F_SUSER
value|0x04
end_define

begin_comment
comment|/* do super-user check */
end_comment

begin_decl_stmt
specifier|const
name|struct
name|bridge_control
name|bridge_control_table
index|[]
init|=
block|{
block|{
name|bridge_ioctl_add
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_del
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_gifflags
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_sifflags
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_scache
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_gcache
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_gifs
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbifconf
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_rts
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbaconf
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_saddr
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbareq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_sto
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_gto
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_daddr
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbareq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_flush
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_gpri
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_spri
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_ght
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_sht
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_gfd
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_sfd
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_gma
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYOUT
block|}
block|,
block|{
name|bridge_ioctl_sma
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbrparam
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_sifprio
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|,
block|{
name|bridge_ioctl_sifcost
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ifbreq
argument_list|)
block|,
name|BC_F_COPYIN
operator||
name|BC_F_SUSER
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|bridge_control_table_size
init|=
sizeof|sizeof
argument_list|(
name|bridge_control_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|bridge_control_table
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_macro
name|LIST_HEAD
argument_list|(
argument_list|,
argument|bridge_softc
argument_list|)
end_macro

begin_expr_stmt
name|bridge_list
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|IFC_SIMPLE_DECLARE
argument_list|(
name|bridge
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|bridge_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|mtx_init
argument_list|(
operator|&
name|bridge_list_mtx
argument_list|,
literal|"if_bridge list"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|if_clone_attach
argument_list|(
operator|&
name|bridge_cloner
argument_list|)
expr_stmt|;
name|bridge_rtnode_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"bridge_rtnode"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|bridge_rtnode
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|bridge_list
argument_list|)
expr_stmt|;
name|bridge_input_p
operator|=
name|bridge_input
expr_stmt|;
name|bridge_output_p
operator|=
name|bridge_output
expr_stmt|;
name|bridge_dn_p
operator|=
name|bridge_dummynet
expr_stmt|;
name|bstp_linkstate_p
operator|=
name|bstp_linkstate
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|if_clone_detach
argument_list|(
operator|&
name|bridge_cloner
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|bridge_list
argument_list|)
condition|)
name|bridge_clone_destroy
argument_list|(
name|LIST_FIRST
argument_list|(
operator|&
name|bridge_list
argument_list|)
operator|->
name|sc_ifp
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|bridge_rtnode_zone
argument_list|)
expr_stmt|;
name|bridge_input_p
operator|=
name|NULL
expr_stmt|;
name|bridge_output_p
operator|=
name|NULL
expr_stmt|;
name|bridge_dn_p
operator|=
name|NULL
expr_stmt|;
name|bstp_linkstate_p
operator|=
name|NULL
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|bridge_list_mtx
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|EOPNOTSUPP
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|bridge_mod
init|=
block|{
literal|"if_bridge"
block|,
name|bridge_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|if_bridge
argument_list|,
name|bridge_mod
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * handler for net.link.bridge.pfil_ipfw  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_pfil_ipfw
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|enable
init|=
name|pfil_ipfw
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|enable
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|enable
operator|=
operator|(
name|enable
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|enable
operator|!=
name|pfil_ipfw
condition|)
block|{
name|pfil_ipfw
operator|=
name|enable
expr_stmt|;
comment|/* 	 * Disable pfil so that ipfw doesnt run twice, if the user really wants 	 * both then they can re-enable pfil_bridge and/or pfil_member. 	 */
if|if
condition|(
name|pfil_ipfw
condition|)
block|{
name|pfil_bridge
operator|=
literal|0
expr_stmt|;
name|pfil_member
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
name|error
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_link_bridge
argument_list|,
name|OID_AUTO
argument_list|,
name|ipfw
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|pfil_ipfw
argument_list|,
literal|0
argument_list|,
operator|&
name|sysctl_pfil_ipfw
argument_list|,
literal|"I"
argument_list|,
literal|"Layer2 filter with IPFW"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * bridge_clone_create:  *  *	Create a new bridge instance.  */
end_comment

begin_function
name|int
name|bridge_clone_create
parameter_list|(
name|struct
name|if_clone
modifier|*
name|ifc
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_char
name|eaddr
index|[
literal|6
index|]
decl_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|BRIDGE_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|sc
operator|->
name|sc_brtmax
operator|=
name|BRIDGE_RTABLE_MAX
expr_stmt|;
name|sc
operator|->
name|sc_brttimeout
operator|=
name|BRIDGE_RTABLE_TIMEOUT
expr_stmt|;
name|sc
operator|->
name|sc_bridge_max_age
operator|=
name|BSTP_DEFAULT_MAX_AGE
expr_stmt|;
name|sc
operator|->
name|sc_bridge_hello_time
operator|=
name|BSTP_DEFAULT_HELLO_TIME
expr_stmt|;
name|sc
operator|->
name|sc_bridge_forward_delay
operator|=
name|BSTP_DEFAULT_FORWARD_DELAY
expr_stmt|;
name|sc
operator|->
name|sc_bridge_priority
operator|=
name|BSTP_DEFAULT_BRIDGE_PRIORITY
expr_stmt|;
name|sc
operator|->
name|sc_hold_time
operator|=
name|BSTP_DEFAULT_HOLD_TIME
expr_stmt|;
comment|/* Initialize our routing table. */
name|bridge_rtable_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_brcallout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_bstpcallout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_iflist
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|ifc
operator|->
name|ifc_name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ETHERMTU
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|bridge_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|bridge_output
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|bridge_start
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|bridge_init
expr_stmt|;
name|ifp
operator|->
name|if_type
operator|=
name|IFT_BRIDGE
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifqmaxlen
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|ifqmaxlen
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_hdrlen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
comment|/* 	 * Generate a random ethernet address and use the private AC:DE:48 	 * OUI code. 	 */
name|arc4rand
argument_list|(
name|eaddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|eaddr
index|[
literal|0
index|]
operator|=
literal|0xAC
expr_stmt|;
name|eaddr
index|[
literal|1
index|]
operator|=
literal|0xDE
expr_stmt|;
name|eaddr
index|[
literal|2
index|]
operator|=
literal|0x48
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
comment|/* Now undo some of the damage... */
name|ifp
operator|->
name|if_baudrate
operator|=
literal|0
expr_stmt|;
name|ifp
operator|->
name|if_type
operator|=
name|IFT_BRIDGE
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bridge_list_mtx
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|bridge_list
argument_list|,
name|sc
argument_list|,
name|sc_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bridge_list_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_clone_destroy:  *  *	Destroy a bridge instance.  */
end_comment

begin_function
name|void
name|bridge_clone_destroy
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bridge_stop
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|bif
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_iflist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|bridge_delete_member
argument_list|(
name|sc
argument_list|,
name|bif
argument_list|)
expr_stmt|;
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|bridge_list_mtx
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sc
argument_list|,
name|sc_list
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|bridge_list_mtx
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_free_type
argument_list|(
name|ifp
argument_list|,
name|IFT_ETHER
argument_list|)
expr_stmt|;
comment|/* Tear down the routing table. */
name|bridge_rtable_fini
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BRIDGE_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_ioctl:  *  *	Handle a control request from the operator.  */
end_comment

begin_function
name|int
name|bridge_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
union|union
block|{
name|struct
name|ifbreq
name|ifbreq
decl_stmt|;
name|struct
name|ifbifconf
name|ifbifconf
decl_stmt|;
name|struct
name|ifbareq
name|ifbareq
decl_stmt|;
name|struct
name|ifbaconf
name|ifbaconf
decl_stmt|;
name|struct
name|ifbrparam
name|ifbrparam
decl_stmt|;
block|}
name|args
union|;
name|struct
name|ifdrv
modifier|*
name|ifd
init|=
operator|(
expr|struct
name|ifdrv
operator|*
operator|)
name|data
decl_stmt|;
specifier|const
name|struct
name|bridge_control
modifier|*
name|bc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCGDRVSPEC
case|:
case|case
name|SIOCSDRVSPEC
case|:
if|if
condition|(
name|ifd
operator|->
name|ifd_cmd
operator|>=
name|bridge_control_table_size
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|bc
operator|=
operator|&
name|bridge_control_table
index|[
name|ifd
operator|->
name|ifd_cmd
index|]
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|SIOCGDRVSPEC
operator|&&
operator|(
name|bc
operator|->
name|bc_flags
operator|&
name|BC_F_COPYOUT
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|SIOCSDRVSPEC
operator|&&
operator|(
name|bc
operator|->
name|bc_flags
operator|&
name|BC_F_COPYOUT
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bc
operator|->
name|bc_flags
operator|&
name|BC_F_SUSER
condition|)
block|{
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
if|if
condition|(
name|ifd
operator|->
name|ifd_len
operator|!=
name|bc
operator|->
name|bc_argsize
operator|||
name|ifd
operator|->
name|ifd_len
operator|>
sizeof|sizeof
argument_list|(
name|args
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bc
operator|->
name|bc_flags
operator|&
name|BC_F_COPYIN
condition|)
block|{
name|error
operator|=
name|copyin
argument_list|(
name|ifd
operator|->
name|ifd_data
argument_list|,
operator|&
name|args
argument_list|,
name|ifd
operator|->
name|ifd_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|error
operator|=
call|(
modifier|*
name|bc
operator|->
name|bc_func
call|)
argument_list|(
name|sc
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|bc
operator|->
name|bc_flags
operator|&
name|BC_F_COPYOUT
condition|)
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|args
argument_list|,
name|ifd
operator|->
name|ifd_data
argument_list|,
name|ifd
operator|->
name|ifd_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
operator|)
operator|==
name|IFF_RUNNING
condition|)
block|{
comment|/* 			 * If interface is marked down and it is running, 			 * then stop and disable it. 			 */
name|bridge_stop
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
operator|)
operator|==
name|IFF_UP
condition|)
block|{
comment|/* 			 * If interface is marked up and it is stopped, then 			 * start it. 			 */
call|(
modifier|*
name|ifp
operator|->
name|if_init
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMTU
case|:
comment|/* Do not allow the MTU to be changed on the bridge */
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
default|default:
comment|/*  		 * drop the lock as ether_ioctl() will call bridge_start() and 		 * cause the lock to be recursed. 		 */
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|BRIDGE_LOCKED
argument_list|(
name|sc
argument_list|)
condition|)
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_lookup_member:  *  *	Lookup a bridge member interface.  */
end_comment

begin_function
name|struct
name|bridge_iflist
modifier|*
name|bridge_lookup_member
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
name|ifp
operator|=
name|bif
operator|->
name|bif_ifp
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ifp
operator|->
name|if_xname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|bif
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_lookup_member_if:  *  *	Lookup a bridge member interface by ifnet*.  */
end_comment

begin_function
name|struct
name|bridge_iflist
modifier|*
name|bridge_lookup_member_if
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|member_ifp
parameter_list|)
block|{
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
if|if
condition|(
name|bif
operator|->
name|bif_ifp
operator|==
name|member_ifp
condition|)
return|return
operator|(
name|bif
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_delete_member:  *  *	Delete the specified member interface.  */
end_comment

begin_function
name|void
name|bridge_delete_member
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bridge_iflist
modifier|*
name|bif
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifs
init|=
name|bif
operator|->
name|bif_ifp
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ifs
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ETHER
case|:
comment|/* 		 * Take the interface out of promiscuous mode. 		 */
operator|(
name|void
operator|)
name|ifpromisc
argument_list|(
name|ifs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|panic
argument_list|(
literal|"bridge_delete_member: impossible"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|ifs
operator|->
name|if_bridge
operator|=
name|NULL
expr_stmt|;
name|BRIDGE_XLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|bif
argument_list|,
name|bif_next
argument_list|)
expr_stmt|;
name|BRIDGE_XDROP
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bridge_rtdelete
argument_list|(
name|sc
argument_list|,
name|ifs
argument_list|,
name|IFBF_FLUSHALL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bif
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|bstp_initialization
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bridge_ioctl_add
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
init|=
name|NULL
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifs
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifs
operator|=
name|ifunit
argument_list|(
name|req
operator|->
name|ifbr_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifs
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_mtu
operator|!=
name|ifs
operator|->
name|if_mtu
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ifs
operator|->
name|if_bridge
operator|==
name|sc
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
if|if
condition|(
name|ifs
operator|->
name|if_bridge
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|bif
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|bif
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
switch|switch
condition|(
name|ifs
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ETHER
case|:
case|case
name|IFT_L2VLAN
case|:
comment|/* 		 * Place the interface into promiscuous mode. 		 */
name|error
operator|=
name|ifpromisc
argument_list|(
name|ifs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bif
operator|->
name|bif_ifp
operator|=
name|ifs
expr_stmt|;
name|bif
operator|->
name|bif_flags
operator|=
name|IFBIF_LEARNING
operator||
name|IFBIF_DISCOVER
expr_stmt|;
name|bif
operator|->
name|bif_priority
operator|=
name|BSTP_DEFAULT_PORT_PRIORITY
expr_stmt|;
name|bif
operator|->
name|bif_path_cost
operator|=
name|BSTP_DEFAULT_PATH_COST
expr_stmt|;
name|ifs
operator|->
name|if_bridge
operator|=
name|sc
expr_stmt|;
comment|/* 	 * XXX: XLOCK HERE!?! 	 * 	 * NOTE: insert_***HEAD*** should be safe for the traversals. 	 */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_iflist
argument_list|,
name|bif
argument_list|,
name|bif_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|bstp_initialization
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|bstp_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|bif
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|bif
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bridge_ioctl_del
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bif
operator|=
name|bridge_lookup_member
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifbr_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|bridge_delete_member
argument_list|(
name|sc
argument_list|,
name|bif
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bridge_ioctl_gifflags
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bif
operator|=
name|bridge_lookup_member
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifbr_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|req
operator|->
name|ifbr_ifsflags
operator|=
name|bif
operator|->
name|bif_flags
expr_stmt|;
name|req
operator|->
name|ifbr_state
operator|=
name|bif
operator|->
name|bif_state
expr_stmt|;
name|req
operator|->
name|ifbr_priority
operator|=
name|bif
operator|->
name|bif_priority
expr_stmt|;
name|req
operator|->
name|ifbr_path_cost
operator|=
name|bif
operator|->
name|bif_path_cost
expr_stmt|;
name|req
operator|->
name|ifbr_portno
operator|=
name|bif
operator|->
name|bif_ifp
operator|->
name|if_index
operator|&
literal|0xff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bridge_ioctl_sifflags
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bif
operator|=
name|bridge_lookup_member
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifbr_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
if|if
condition|(
name|req
operator|->
name|ifbr_ifsflags
operator|&
name|IFBIF_STP
condition|)
block|{
switch|switch
condition|(
name|bif
operator|->
name|bif_ifp
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ETHER
case|:
comment|/* These can do spanning tree. */
break|break;
default|default:
comment|/* Nothing else can. */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
name|bif
operator|->
name|bif_flags
operator|=
name|req
operator|->
name|ifbr_ifsflags
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|bstp_initialization
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bridge_ioctl_scache
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_brtmax
operator|=
name|param
operator|->
name|ifbrp_csize
expr_stmt|;
name|bridge_rttrim
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bridge_ioctl_gcache
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|param
operator|->
name|ifbrp_csize
operator|=
name|sc
operator|->
name|sc_brtmax
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bridge_ioctl_gifs
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbifconf
modifier|*
name|bifc
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|ifbreq
name|breq
decl_stmt|;
name|int
name|count
decl_stmt|,
name|len
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|bifc
operator|->
name|ifbic_len
operator|==
literal|0
condition|)
block|{
name|bifc
operator|->
name|ifbic_len
operator|=
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
operator|*
name|count
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|bifc
operator|->
name|ifbic_len
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
condition|)
break|break;
name|strlcpy
argument_list|(
name|breq
operator|.
name|ifbr_ifsname
argument_list|,
name|bif
operator|->
name|bif_ifp
operator|->
name|if_xname
argument_list|,
sizeof|sizeof
argument_list|(
name|breq
operator|.
name|ifbr_ifsname
argument_list|)
argument_list|)
expr_stmt|;
name|breq
operator|.
name|ifbr_ifsflags
operator|=
name|bif
operator|->
name|bif_flags
expr_stmt|;
name|breq
operator|.
name|ifbr_state
operator|=
name|bif
operator|->
name|bif_state
expr_stmt|;
name|breq
operator|.
name|ifbr_priority
operator|=
name|bif
operator|->
name|bif_priority
expr_stmt|;
name|breq
operator|.
name|ifbr_path_cost
operator|=
name|bif
operator|->
name|bif_path_cost
expr_stmt|;
name|breq
operator|.
name|ifbr_portno
operator|=
name|bif
operator|->
name|bif_ifp
operator|->
name|if_index
operator|&
literal|0xff
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|breq
argument_list|,
name|bifc
operator|->
name|ifbic_req
operator|+
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|count
operator|++
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
expr_stmt|;
block|}
name|bifc
operator|->
name|ifbic_len
operator|=
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
operator|*
name|count
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bridge_ioctl_rts
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbaconf
modifier|*
name|bac
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|;
name|struct
name|ifbareq
name|bareq
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bac
operator|->
name|ifbac_len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|getmicrotime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|len
operator|=
name|bac
operator|->
name|ifbac_len
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|brt
argument_list|,
argument|&sc->sc_rtlist
argument_list|,
argument|brt_list
argument_list|)
block|{
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|bareq
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|strlcpy
argument_list|(
name|bareq
operator|.
name|ifba_ifsname
argument_list|,
name|brt
operator|->
name|brt_ifp
operator|->
name|if_xname
argument_list|,
sizeof|sizeof
argument_list|(
name|bareq
operator|.
name|ifba_ifsname
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|bareq
operator|.
name|ifba_dst
argument_list|,
name|brt
operator|->
name|brt_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|brt
operator|->
name|brt_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|brt
operator|->
name|brt_flags
operator|&
name|IFBAF_TYPEMASK
operator|)
operator|==
name|IFBAF_DYNAMIC
operator|&&
name|tv
operator|.
name|tv_sec
operator|<
name|brt
operator|->
name|brt_expire
condition|)
name|bareq
operator|.
name|ifba_expire
operator|=
name|brt
operator|->
name|brt_expire
operator|-
name|tv
operator|.
name|tv_sec
expr_stmt|;
else|else
name|bareq
operator|.
name|ifba_expire
operator|=
literal|0
expr_stmt|;
name|bareq
operator|.
name|ifba_flags
operator|=
name|brt
operator|->
name|brt_flags
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|bareq
argument_list|,
name|bac
operator|->
name|ifbac_req
operator|+
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|bareq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|count
operator|++
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|bareq
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|bac
operator|->
name|ifbac_len
operator|=
sizeof|sizeof
argument_list|(
name|bareq
argument_list|)
operator|*
name|count
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bridge_ioctl_saddr
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbareq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|int
name|error
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bif
operator|=
name|bridge_lookup_member
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifba_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|error
operator|=
name|bridge_rtupdate
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifba_dst
argument_list|,
name|bif
operator|->
name|bif_ifp
argument_list|,
literal|1
argument_list|,
name|req
operator|->
name|ifba_flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bridge_ioctl_sto
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_brttimeout
operator|=
name|param
operator|->
name|ifbrp_ctime
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bridge_ioctl_gto
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|param
operator|->
name|ifbrp_ctime
operator|=
name|sc
operator|->
name|sc_brttimeout
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bridge_ioctl_daddr
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbareq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|bridge_rtdaddr
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifba_dst
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bridge_ioctl_flush
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bridge_rtflush
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifbr_ifsflags
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bridge_ioctl_gpri
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|param
operator|->
name|ifbrp_prio
operator|=
name|sc
operator|->
name|sc_bridge_priority
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bridge_ioctl_spri
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_bridge_priority
operator|=
name|param
operator|->
name|ifbrp_prio
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|bstp_initialization
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bridge_ioctl_ght
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|param
operator|->
name|ifbrp_hellotime
operator|=
name|sc
operator|->
name|sc_bridge_hello_time
operator|>>
literal|8
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bridge_ioctl_sht
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|param
operator|->
name|ifbrp_hellotime
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|->
name|sc_bridge_hello_time
operator|=
name|param
operator|->
name|ifbrp_hellotime
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|bstp_initialization
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bridge_ioctl_gfd
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|param
operator|->
name|ifbrp_fwddelay
operator|=
name|sc
operator|->
name|sc_bridge_forward_delay
operator|>>
literal|8
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bridge_ioctl_sfd
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|param
operator|->
name|ifbrp_fwddelay
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|->
name|sc_bridge_forward_delay
operator|=
name|param
operator|->
name|ifbrp_fwddelay
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|bstp_initialization
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bridge_ioctl_gma
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|param
operator|->
name|ifbrp_maxage
operator|=
name|sc
operator|->
name|sc_bridge_max_age
operator|>>
literal|8
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bridge_ioctl_sma
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbrparam
modifier|*
name|param
init|=
name|arg
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|param
operator|->
name|ifbrp_maxage
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|->
name|sc_bridge_max_age
operator|=
name|param
operator|->
name|ifbrp_maxage
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|bstp_initialization
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bridge_ioctl_sifprio
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bif
operator|=
name|bridge_lookup_member
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifbr_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|bif
operator|->
name|bif_priority
operator|=
name|req
operator|->
name|ifbr_priority
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|bstp_initialization
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bridge_ioctl_sifcost
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ifbreq
modifier|*
name|req
init|=
name|arg
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bif
operator|=
name|bridge_lookup_member
argument_list|(
name|sc
argument_list|,
name|req
operator|->
name|ifbr_ifsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|bif
operator|->
name|bif_path_cost
operator|=
name|req
operator|->
name|ifbr_path_cost
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|bstp_initialization
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_ifdetach:  *  *	Detach an interface from a bridge.  Called when a member  *	interface is detaching.  */
end_comment

begin_function
name|void
name|bridge_ifdetach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_bridge
decl_stmt|;
name|struct
name|ifbreq
name|breq
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|breq
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|breq
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|breq
operator|.
name|ifbr_ifsname
argument_list|,
sizeof|sizeof
argument_list|(
name|breq
operator|.
name|ifbr_ifsname
argument_list|)
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|bridge_ioctl_del
argument_list|(
name|sc
argument_list|,
operator|&
name|breq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_init:  *  *	Initialize a bridge interface.  */
end_comment

begin_function
specifier|static
name|void
name|bridge_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|bridge_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
return|return;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_brcallout
argument_list|,
name|bridge_rtable_prune_period
operator|*
name|hz
argument_list|,
name|bridge_timer
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
name|bstp_initialization
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * bridge_stop:  *  *	Stop the bridge interface.  */
end_comment

begin_function
name|void
name|bridge_stop
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|disable
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_brcallout
argument_list|)
expr_stmt|;
name|bstp_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bridge_rtflush
argument_list|(
name|sc
argument_list|,
name|IFBF_FLUSHDYN
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_RUNNING
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_enqueue:  *  *	Enqueue a packet on a bridge member interface.  *  */
end_comment

begin_function
name|__inline
name|void
name|bridge_enqueue
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|dst_ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|runfilt
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|err
decl_stmt|;
name|short
name|mflags
decl_stmt|;
comment|/* 	 * Clear any in-bound checksum flags for this packet. 	 */
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|runfilt
operator|&&
name|inet_pfil_hook
operator|.
name|ph_busy_count
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|bridge_pfil
argument_list|(
operator|&
name|m
argument_list|,
name|sc
operator|->
name|sc_ifp
argument_list|,
name|dst_ifp
argument_list|,
name|PFIL_OUT
argument_list|)
operator|!=
literal|0
condition|)
return|return;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|mflags
operator|=
name|m
operator|->
name|m_flags
expr_stmt|;
name|IFQ_ENQUEUE
argument_list|(
operator|&
name|dst_ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_obytes
operator|+=
name|len
expr_stmt|;
name|dst_ifp
operator|->
name|if_obytes
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|mflags
operator|&
name|M_MCAST
condition|)
block|{
name|sc
operator|->
name|sc_ifp
operator|->
name|if_omcasts
operator|++
expr_stmt|;
name|dst_ifp
operator|->
name|if_omcasts
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|dst_ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|==
literal|0
condition|)
call|(
modifier|*
name|dst_ifp
operator|->
name|if_start
call|)
argument_list|(
name|dst_ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_dummynet:  *  * 	Receive a queued packet from dummynet and pass it on to the output  * 	interface.  *  *	The mbuf has the Ethernet header already attached.  */
end_comment

begin_function
name|void
name|bridge_dummynet
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_bridge
expr_stmt|;
comment|/* 	 * The packet didnt originate from a member interface. This should only 	 * ever happen if a member interface is removed while packets are 	 * queued for it. 	 */
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|bridge_enqueue
argument_list|(
name|sc
argument_list|,
name|ifp
argument_list|,
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_output:  *  *	Send output from a bridge member interface.  This  *	performs the bridging function for locally originated  *	packets.  *  *	The mbuf has the Ethernet header already attached.  We must  *	enqueue or free the mbuf before returning.  */
end_comment

begin_function
name|int
name|bridge_output
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|)
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|dst_if
decl_stmt|;
name|struct
name|bridge_softc
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|ETHER_HDR_LEN
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_bridge
expr_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * If bridge is down, but the original output interface is up, 	 * go ahead and send out that interface.  Otherwise, the packet 	 * is dropped below. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|dst_if
operator|=
name|ifp
expr_stmt|;
goto|goto
name|sendunicast
goto|;
block|}
comment|/* 	 * If the packet is a multicast, or we don't know a better way to 	 * get there, send to all interfaces. 	 */
if|if
condition|(
name|ETHER_IS_MULTICAST
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
condition|)
name|dst_if
operator|=
name|NULL
expr_stmt|;
else|else
name|dst_if
operator|=
name|bridge_rtlookup
argument_list|(
name|sc
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_if
operator|==
name|NULL
condition|)
block|{
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|used
init|=
literal|0
decl_stmt|;
name|BRIDGE_LOCK2REF
argument_list|(
name|sc
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
name|dst_if
operator|=
name|bif
operator|->
name|bif_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|dst_if
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 			 * If this is not the original output interface, 			 * and the interface is participating in spanning 			 * tree, make sure the port is in a state that 			 * allows forwarding. 			 */
if|if
condition|(
name|dst_if
operator|!=
name|ifp
operator|&&
operator|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|bif
operator|->
name|bif_state
condition|)
block|{
case|case
name|BSTP_IFSTATE_BLOCKING
case|:
case|case
name|BSTP_IFSTATE_LISTENING
case|:
case|case
name|BSTP_IFSTATE_DISABLED
case|:
continue|continue;
block|}
block|}
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|bif
argument_list|,
name|bif_next
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|used
operator|=
literal|1
expr_stmt|;
name|mc
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
name|mc
operator|=
name|m_copym
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
name|bridge_enqueue
argument_list|(
name|sc
argument_list|,
name|dst_if
argument_list|,
name|mc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|used
operator|==
literal|0
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|BRIDGE_UNREF
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sendunicast
label|:
comment|/* 	 * XXX Spanning tree consideration here? 	 */
if|if
condition|(
operator|(
name|dst_if
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bridge_enqueue
argument_list|(
name|sc
argument_list|,
name|dst_if
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_start:  *  *	Start output on a bridge.  *  */
end_comment

begin_function
name|void
name|bridge_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|dst_if
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_OACTIVE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|IFQ_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
break|break;
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|dst_if
operator|=
name|NULL
expr_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|dst_if
operator|=
name|bridge_rtlookup
argument_list|(
name|sc
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dst_if
operator|==
name|NULL
condition|)
name|bridge_broadcast
argument_list|(
name|sc
argument_list|,
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|else
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bridge_enqueue
argument_list|(
name|sc
argument_list|,
name|dst_if
argument_list|,
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_OACTIVE
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * bridge_forward:  *  *	The forwarding function of the bridge.  *  *	NOTE: Releases the lock on return.  */
end_comment

begin_function
name|void
name|bridge_forward
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|src_if
decl_stmt|,
modifier|*
name|dst_if
decl_stmt|,
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|src_if
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_ibytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* 	 * Look up the bridge_iflist. 	 */
name|bif
operator|=
name|bridge_lookup_member_if
argument_list|(
name|sc
argument_list|,
name|src_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
block|{
comment|/* Interface is not a bridge member (anymore?) */
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
condition|)
block|{
switch|switch
condition|(
name|bif
operator|->
name|bif_state
condition|)
block|{
case|case
name|BSTP_IFSTATE_BLOCKING
case|:
case|case
name|BSTP_IFSTATE_LISTENING
case|:
case|case
name|BSTP_IFSTATE_DISABLED
case|:
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * If the interface is learning, and the source 	 * address is valid and not multicast, record 	 * the address. 	 */
if|if
condition|(
operator|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_LEARNING
operator|)
operator|!=
literal|0
operator|&&
name|ETHER_IS_MULTICAST
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|eh
operator|->
name|ether_shost
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|eh
operator|->
name|ether_shost
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|eh
operator|->
name|ether_shost
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
name|eh
operator|->
name|ether_shost
index|[
literal|3
index|]
operator|==
literal|0
operator|&&
name|eh
operator|->
name|ether_shost
index|[
literal|4
index|]
operator|==
literal|0
operator|&&
name|eh
operator|->
name|ether_shost
index|[
literal|5
index|]
operator|==
literal|0
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|bridge_rtupdate
argument_list|(
name|sc
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|,
name|src_if
argument_list|,
literal|0
argument_list|,
name|IFBAF_DYNAMIC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
operator|)
operator|!=
literal|0
operator|&&
name|bif
operator|->
name|bif_state
operator|==
name|BSTP_IFSTATE_LEARNING
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * At this point, the port either doesn't participate 	 * in spanning tree or it is in the forwarding state. 	 */
comment|/* 	 * If the packet is unicast, destined for someone on 	 * "this" side of the bridge, drop it. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|dst_if
operator|=
name|bridge_rtlookup
argument_list|(
name|sc
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_if
operator|==
name|dst_if
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* ...forward it to all interfaces. */
name|sc
operator|->
name|sc_ifp
operator|->
name|if_imcasts
operator|++
expr_stmt|;
name|dst_if
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* run the packet filter */
if|if
condition|(
name|inet_pfil_hook
operator|.
name|ph_busy_count
operator|>=
literal|0
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bridge_pfil
argument_list|(
operator|&
name|m
argument_list|,
name|ifp
argument_list|,
name|src_if
argument_list|,
name|PFIL_IN
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dst_if
operator|==
name|NULL
condition|)
block|{
comment|/* tap off packets passing the bridge */
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|bridge_broadcast
argument_list|(
name|sc
argument_list|,
name|src_if
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * At this point, we're dealing with a unicast frame 	 * going to a different interface. 	 */
if|if
condition|(
operator|(
name|dst_if
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|bif
operator|=
name|bridge_lookup_member_if
argument_list|(
name|sc
argument_list|,
name|dst_if
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
block|{
comment|/* Not a member of the bridge (anymore?) */
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
condition|)
block|{
switch|switch
condition|(
name|bif
operator|->
name|bif_state
condition|)
block|{
case|case
name|BSTP_IFSTATE_DISABLED
case|:
case|case
name|BSTP_IFSTATE_BLOCKING
case|:
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* tap off packets passing the bridge */
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bridge_enqueue
argument_list|(
name|sc
argument_list|,
name|dst_if
argument_list|,
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_input:  *  *	Receive input from a member interface.  Queue the packet for  *	bridging if it is not for us.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|bridge_input
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_bridge
decl_stmt|;
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mc
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|m
operator|)
return|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bif
operator|=
name|bridge_lookup_member_if
argument_list|(
name|sc
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bif
operator|==
name|NULL
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|IFP2ENADDR
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If the packet is for us, set the packets source as the 		 * bridge, and return the packet back to ether_input for 		 * local processing. 		 */
comment|/* XXX Do we tap the packet for the member interface too? 		 * BPF_MTAP(&m->m_pkthdr.rcvif, m); 		 */
comment|/* Mark the packet as arriving on the bridge interface */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|sc
operator|->
name|sc_ifp
expr_stmt|;
name|BPF_MTAP
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
condition|)
block|{
comment|/* Tap off 802.1D packets; they do not get forwarded. */
if|if
condition|(
name|memcmp
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|bstp_etheraddr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|bstp_input
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
condition|)
block|{
switch|switch
condition|(
name|bif
operator|->
name|bif_state
condition|)
block|{
case|case
name|BSTP_IFSTATE_BLOCKING
case|:
case|case
name|BSTP_IFSTATE_LISTENING
case|:
case|case
name|BSTP_IFSTATE_DISABLED
case|:
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
block|}
comment|/* 		 * Make a deep copy of the packet and enqueue the copy 		 * for bridge processing; return the original packet for 		 * local processing. 		 */
name|mc
operator|=
name|m_dup
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|==
name|NULL
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
comment|/* Perform the bridge forwarding function with the copy. */
name|bridge_forward
argument_list|(
name|sc
argument_list|,
name|mc
argument_list|)
expr_stmt|;
comment|/* Return the original packet for local processing. */
return|return
operator|(
name|m
operator|)
return|;
block|}
if|if
condition|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
condition|)
block|{
switch|switch
condition|(
name|bif
operator|->
name|bif_state
condition|)
block|{
case|case
name|BSTP_IFSTATE_BLOCKING
case|:
case|case
name|BSTP_IFSTATE_LISTENING
case|:
case|case
name|BSTP_IFSTATE_DISABLED
case|:
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
block|}
comment|/* 	 * Unicast.  Make sure it's not for us. 	 */
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
comment|/* It is destined for us. */
if|if
condition|(
name|memcmp
argument_list|(
name|IF_LLADDR
argument_list|(
name|bif
operator|->
name|bif_ifp
argument_list|)
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_LEARNING
condition|)
operator|(
name|void
operator|)
name|bridge_rtupdate
argument_list|(
name|sc
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|,
name|ifp
argument_list|,
literal|0
argument_list|,
name|IFBAF_DYNAMIC
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|bif
operator|->
name|bif_ifp
expr_stmt|;
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
comment|/* We just received a packet that we sent out. */
if|if
condition|(
name|memcmp
argument_list|(
name|IF_LLADDR
argument_list|(
name|bif
operator|->
name|bif_ifp
argument_list|)
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* Perform the bridge forwarding function. */
name|bridge_forward
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_broadcast:  *  *	Send a frame to all interfaces that are members of  *	the bridge, except for the one on which the packet  *	arrived.  *  *	NOTE: Releases the lock on return.  */
end_comment

begin_function
name|void
name|bridge_broadcast
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|src_if
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|bridge_iflist
modifier|*
name|bif
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|dst_if
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|used
init|=
literal|0
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BRIDGE_LOCK2REF
argument_list|(
name|sc
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|LIST_FOREACH
argument_list|(
argument|bif
argument_list|,
argument|&sc->sc_iflist
argument_list|,
argument|bif_next
argument_list|)
block|{
name|dst_if
operator|=
name|bif
operator|->
name|bif_ifp
expr_stmt|;
if|if
condition|(
name|dst_if
operator|==
name|src_if
condition|)
continue|continue;
if|if
condition|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_STP
condition|)
block|{
switch|switch
condition|(
name|bif
operator|->
name|bif_state
condition|)
block|{
case|case
name|BSTP_IFSTATE_BLOCKING
case|:
case|case
name|BSTP_IFSTATE_DISABLED
case|:
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|bif
operator|->
name|bif_flags
operator|&
name|IFBIF_DISCOVER
operator|)
operator|==
literal|0
operator|&&
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|dst_if
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|bif
argument_list|,
name|bif_next
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|mc
operator|=
name|m
expr_stmt|;
name|used
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|mc
operator|=
name|m_copym
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
name|bridge_enqueue
argument_list|(
name|sc
argument_list|,
name|dst_if
argument_list|,
name|mc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|used
operator|==
literal|0
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|BRIDGE_UNREF
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_rtupdate:  *  *	Add a bridge routing entry.  */
end_comment

begin_function
name|int
name|bridge_rtupdate
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|dst
parameter_list|,
name|struct
name|ifnet
modifier|*
name|dst_if
parameter_list|,
name|int
name|setflags
parameter_list|,
name|uint8_t
name|flags
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|error
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * A route for this destination might already exist.  If so, 	 * update it, otherwise create a new one. 	 */
name|getmicrotime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|brt
operator|=
name|bridge_rtnode_lookup
argument_list|(
name|sc
argument_list|,
name|dst
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_brtcnt
operator|>=
name|sc
operator|->
name|sc_brtmax
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* 		 * Allocate a new bridge forwarding node, and 		 * initialize the expiration time and Ethernet 		 * address. 		 */
name|brt
operator|=
name|uma_zalloc
argument_list|(
name|bridge_rtnode_zone
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|brt
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|brt
operator|->
name|brt_expire
operator|=
name|tv
operator|.
name|tv_sec
operator|+
name|sc
operator|->
name|sc_brttimeout
expr_stmt|;
name|brt
operator|->
name|brt_flags
operator|=
name|IFBAF_DYNAMIC
expr_stmt|;
name|memcpy
argument_list|(
name|brt
operator|->
name|brt_addr
argument_list|,
name|dst
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|bridge_rtnode_insert
argument_list|(
name|sc
argument_list|,
name|brt
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|uma_zfree
argument_list|(
name|bridge_rtnode_zone
argument_list|,
name|brt
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|brt
operator|->
name|brt_ifp
operator|=
name|dst_if
expr_stmt|;
if|if
condition|(
name|setflags
condition|)
block|{
name|brt
operator|->
name|brt_flags
operator|=
name|flags
expr_stmt|;
name|brt
operator|->
name|brt_expire
operator|=
operator|(
name|flags
operator|&
name|IFBAF_STATIC
operator|)
condition|?
literal|0
else|:
name|tv
operator|.
name|tv_sec
operator|+
name|sc
operator|->
name|sc_brttimeout
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_rtlookup:  *  *	Lookup the destination interface for an address.  */
end_comment

begin_function
name|struct
name|ifnet
modifier|*
name|bridge_rtlookup
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|brt
operator|=
name|bridge_rtnode_lookup
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|brt
operator|->
name|brt_ifp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_rttrim:  *  *	Trim the routine table so that we have a number  *	of routing entries less than or equal to the  *	maximum number.  */
end_comment

begin_function
name|void
name|bridge_rttrim
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|,
modifier|*
name|nbrt
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Make sure we actually need to do this. */
if|if
condition|(
name|sc
operator|->
name|sc_brtcnt
operator|<=
name|sc
operator|->
name|sc_brtmax
condition|)
return|return;
comment|/* Force an aging cycle; this might trim enough addresses. */
name|bridge_rtage
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_brtcnt
operator|<=
name|sc
operator|->
name|sc_brtmax
condition|)
return|return;
for|for
control|(
name|brt
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rtlist
argument_list|)
init|;
name|brt
operator|!=
name|NULL
condition|;
name|brt
operator|=
name|nbrt
control|)
block|{
name|nbrt
operator|=
name|LIST_NEXT
argument_list|(
name|brt
argument_list|,
name|brt_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|brt
operator|->
name|brt_flags
operator|&
name|IFBAF_TYPEMASK
operator|)
operator|==
name|IFBAF_DYNAMIC
condition|)
block|{
name|bridge_rtnode_destroy
argument_list|(
name|sc
argument_list|,
name|brt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_brtcnt
operator|<=
name|sc
operator|->
name|sc_brtmax
condition|)
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * bridge_timer:  *  *	Aging timer for the bridge.  */
end_comment

begin_function
name|void
name|bridge_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|bridge_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|BRIDGE_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bridge_rtage
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BRIDGE_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
condition|)
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_brcallout
argument_list|,
name|bridge_rtable_prune_period
operator|*
name|hz
argument_list|,
name|bridge_timer
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * bridge_rtage:  *  *	Perform an aging cycle.  */
end_comment

begin_function
name|void
name|bridge_rtage
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|,
modifier|*
name|nbrt
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
for|for
control|(
name|brt
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rtlist
argument_list|)
init|;
name|brt
operator|!=
name|NULL
condition|;
name|brt
operator|=
name|nbrt
control|)
block|{
name|nbrt
operator|=
name|LIST_NEXT
argument_list|(
name|brt
argument_list|,
name|brt_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|brt
operator|->
name|brt_flags
operator|&
name|IFBAF_TYPEMASK
operator|)
operator|==
name|IFBAF_DYNAMIC
condition|)
block|{
if|if
condition|(
name|tv
operator|.
name|tv_sec
operator|>=
name|brt
operator|->
name|brt_expire
condition|)
name|bridge_rtnode_destroy
argument_list|(
name|sc
argument_list|,
name|brt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * bridge_rtflush:  *  *	Remove all dynamic addresses from the bridge.  */
end_comment

begin_function
name|void
name|bridge_rtflush
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|int
name|full
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|,
modifier|*
name|nbrt
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|brt
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rtlist
argument_list|)
init|;
name|brt
operator|!=
name|NULL
condition|;
name|brt
operator|=
name|nbrt
control|)
block|{
name|nbrt
operator|=
name|LIST_NEXT
argument_list|(
name|brt
argument_list|,
name|brt_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|full
operator|||
operator|(
name|brt
operator|->
name|brt_flags
operator|&
name|IFBAF_TYPEMASK
operator|)
operator|==
name|IFBAF_DYNAMIC
condition|)
name|bridge_rtnode_destroy
argument_list|(
name|sc
argument_list|,
name|brt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * bridge_rtdaddr:  *  *	Remove an address from the table.  */
end_comment

begin_function
name|int
name|bridge_rtdaddr
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|brt
operator|=
name|bridge_rtnode_lookup
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|bridge_rtnode_destroy
argument_list|(
name|sc
argument_list|,
name|brt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_rtdelete:  *  *	Delete routes to a speicifc member interface.  */
end_comment

begin_function
name|void
name|bridge_rtdelete
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|full
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|,
modifier|*
name|nbrt
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
for|for
control|(
name|brt
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rtlist
argument_list|)
init|;
name|brt
operator|!=
name|NULL
condition|;
name|brt
operator|=
name|nbrt
control|)
block|{
name|nbrt
operator|=
name|LIST_NEXT
argument_list|(
name|brt
argument_list|,
name|brt_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|brt
operator|->
name|brt_ifp
operator|==
name|ifp
operator|&&
operator|(
name|full
operator|||
operator|(
name|brt
operator|->
name|brt_flags
operator|&
name|IFBAF_TYPEMASK
operator|)
operator|==
name|IFBAF_DYNAMIC
operator|)
condition|)
name|bridge_rtnode_destroy
argument_list|(
name|sc
argument_list|,
name|brt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * bridge_rtable_init:  *  *	Initialize the route table for this bridge.  */
end_comment

begin_function
name|int
name|bridge_rtable_init
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|sc
operator|->
name|sc_rthash
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|sc_rthash
argument_list|)
operator|*
name|BRIDGE_RTHASH_SIZE
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rthash
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BRIDGE_RTHASH_SIZE
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rthash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rthash_key
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_rtlist
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_rtable_fini:  *  *	Deconstruct the route table for this bridge.  */
end_comment

begin_function
name|void
name|bridge_rtable_fini
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|sc_rthash
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The following hash function is adapted from "Hash Functions" by Bob Jenkins  * ("Algorithm Alley", Dr. Dobbs Journal, September 1997).  */
end_comment

begin_define
define|#
directive|define
name|mix
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
define|\
value|do {									\ 	a -= b; a -= c; a ^= (c>> 13);					\ 	b -= c; b -= a; b ^= (a<< 8);					\ 	c -= a; c -= b; c ^= (b>> 13);					\ 	a -= b; a -= c; a ^= (c>> 12);					\ 	b -= c; b -= a; b ^= (a<< 16);					\ 	c -= a; c -= b; c ^= (b>> 5);					\ 	a -= b; a -= c; a ^= (c>> 3);					\ 	b -= c; b -= a; b ^= (a<< 10);					\ 	c -= a; c -= b; c ^= (b>> 15);					\ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_function
specifier|static
name|__inline
name|uint32_t
name|bridge_rthash
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
name|uint32_t
name|a
init|=
literal|0x9e3779b9
decl_stmt|,
name|b
init|=
literal|0x9e3779b9
decl_stmt|,
name|c
init|=
name|sc
operator|->
name|sc_rthash_key
decl_stmt|;
name|b
operator|+=
name|addr
index|[
literal|5
index|]
operator|<<
literal|8
expr_stmt|;
name|b
operator|+=
name|addr
index|[
literal|4
index|]
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|mix
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|&
name|BRIDGE_RTHASH_MASK
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|mix
end_undef

begin_comment
comment|/*  * bridge_rtnode_lookup:  *  *	Look up a bridge route node for the specified destination.  */
end_comment

begin_function
name|struct
name|bridge_rtnode
modifier|*
name|bridge_rtnode_lookup
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|brt
decl_stmt|;
name|uint32_t
name|hash
decl_stmt|;
name|int
name|dir
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hash
operator|=
name|bridge_rthash
argument_list|(
name|sc
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|brt
argument_list|,
argument|&sc->sc_rthash[hash]
argument_list|,
argument|brt_hash
argument_list|)
block|{
name|dir
operator|=
name|memcmp
argument_list|(
name|addr
argument_list|,
name|brt
operator|->
name|brt_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
literal|0
condition|)
return|return
operator|(
name|brt
operator|)
return|;
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_rtnode_insert:  *  *	Insert the specified bridge node into the route table.  We  *	assume the entry is not already in the table.  */
end_comment

begin_function
name|int
name|bridge_rtnode_insert
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bridge_rtnode
modifier|*
name|brt
parameter_list|)
block|{
name|struct
name|bridge_rtnode
modifier|*
name|lbrt
decl_stmt|;
name|uint32_t
name|hash
decl_stmt|;
name|int
name|dir
decl_stmt|;
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|hash
operator|=
name|bridge_rthash
argument_list|(
name|sc
argument_list|,
name|brt
operator|->
name|brt_addr
argument_list|)
expr_stmt|;
name|lbrt
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_rthash
index|[
name|hash
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|lbrt
operator|==
name|NULL
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_rthash
index|[
name|hash
index|]
argument_list|,
name|brt
argument_list|,
name|brt_hash
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
do|do
block|{
name|dir
operator|=
name|memcmp
argument_list|(
name|brt
operator|->
name|brt_addr
argument_list|,
name|lbrt
operator|->
name|brt_addr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
literal|0
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
if|if
condition|(
name|dir
operator|>
literal|0
condition|)
block|{
name|LIST_INSERT_BEFORE
argument_list|(
name|lbrt
argument_list|,
name|brt
argument_list|,
name|brt_hash
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|lbrt
argument_list|,
name|brt_hash
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|LIST_INSERT_AFTER
argument_list|(
name|lbrt
argument_list|,
name|brt
argument_list|,
name|brt_hash
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|lbrt
operator|=
name|LIST_NEXT
argument_list|(
name|lbrt
argument_list|,
name|brt_hash
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|lbrt
operator|!=
name|NULL
condition|)
do|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|panic
argument_list|(
literal|"bridge_rtnode_insert: impossible"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|out
label|:
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_rtlist
argument_list|,
name|brt
argument_list|,
name|brt_list
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_brtcnt
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bridge_rtnode_destroy:  *  *	Destroy a bridge rtnode.  */
end_comment

begin_function
name|void
name|bridge_rtnode_destroy
parameter_list|(
name|struct
name|bridge_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|bridge_rtnode
modifier|*
name|brt
parameter_list|)
block|{
name|BRIDGE_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|brt
argument_list|,
name|brt_hash
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|brt
argument_list|,
name|brt_list
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_brtcnt
operator|--
expr_stmt|;
name|uma_zfree
argument_list|(
name|bridge_rtnode_zone
argument_list|,
name|brt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send bridge packets through pfil if they are one of the types pfil can deal  * with, or if they are ARP or REVARP.  (pfil will pass ARP and REVARP without  * question.)  */
end_comment

begin_function
specifier|static
name|int
name|bridge_pfil
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|struct
name|ifnet
modifier|*
name|bifp
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dir
parameter_list|)
block|{
name|int
name|snap
decl_stmt|,
name|error
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh1
decl_stmt|,
name|eh2
decl_stmt|;
name|struct
name|ip_fw_args
name|args
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|llc
name|llc1
decl_stmt|;
name|u_int16_t
name|ether_type
decl_stmt|;
name|snap
operator|=
literal|0
expr_stmt|;
name|error
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Default error if not error == 0 */
name|i
operator|=
name|min
argument_list|(
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|max_protohdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|<
name|i
condition|)
block|{
operator|*
name|mp
operator|=
name|m_pullup
argument_list|(
operator|*
name|mp
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: m_pullup failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|eh1
operator|=
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|ether_type
operator|=
name|ntohs
argument_list|(
name|eh1
operator|->
name|ether_type
argument_list|)
expr_stmt|;
comment|/* 	 * Check for SNAP/LLC. 	 */
if|if
condition|(
name|ether_type
operator|<
name|ETHERMTU
condition|)
block|{
name|struct
name|llc
modifier|*
name|llc2
init|=
operator|(
expr|struct
name|llc
operator|*
operator|)
operator|(
name|eh1
operator|+
literal|1
operator|)
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_len
operator|>=
name|ETHER_HDR_LEN
operator|+
literal|8
operator|&&
name|llc2
operator|->
name|llc_dsap
operator|==
name|LLC_SNAP_LSAP
operator|&&
name|llc2
operator|->
name|llc_ssap
operator|==
name|LLC_SNAP_LSAP
operator|&&
name|llc2
operator|->
name|llc_control
operator|==
name|LLC_UI
condition|)
block|{
name|ether_type
operator|=
name|htons
argument_list|(
name|llc2
operator|->
name|llc_un
operator|.
name|type_snap
operator|.
name|ether_type
argument_list|)
expr_stmt|;
name|snap
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * If we're trying to filter bridge traffic, don't look at anything 	 * other than IP and ARP traffic.  If the filter doesn't understand 	 * IPv6, don't allow IPv6 through the bridge either.  This is lame 	 * since if we really wanted, say, an AppleTalk filter, we are hosed, 	 * but of course we don't have an AppleTalk filter to begin with. 	 * (Note that since pfil doesn't understand ARP it will pass *ALL* 	 * ARP traffic.) 	 */
switch|switch
condition|(
name|ether_type
condition|)
block|{
case|case
name|ETHERTYPE_ARP
case|:
case|case
name|ETHERTYPE_REVARP
case|:
return|return
literal|0
return|;
comment|/* Automatically pass */
case|case
name|ETHERTYPE_IP
case|:
ifdef|#
directive|ifdef
name|INET6
case|case
name|ETHERTYPE_IPV6
case|:
endif|#
directive|endif
comment|/* INET6 */
break|break;
default|default:
comment|/* 			 * ipfw allows layer2 protocol filtering using 			 * 'mac-type' so we will let the packet past, if 			 * ipfw is disabled then drop it. 			 */
if|if
condition|(
operator|!
name|IPFW_LOADED
operator|||
name|pfil_ipfw
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
block|}
comment|/* Strip off the Ethernet header and keep a copy. */
name|m_copydata
argument_list|(
operator|*
name|mp
argument_list|,
literal|0
argument_list|,
name|ETHER_HDR_LEN
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|eh2
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
operator|*
name|mp
argument_list|,
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
comment|/* Strip off snap header, if present */
if|if
condition|(
name|snap
condition|)
block|{
name|m_copydata
argument_list|(
operator|*
name|mp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|llc1
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
operator|*
name|mp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IPFW_LOADED
operator|&&
name|pfil_ipfw
operator|!=
literal|0
operator|&&
name|dir
operator|==
name|PFIL_OUT
condition|)
block|{
name|args
operator|.
name|rule
operator|=
name|ip_dn_claim_rule
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|.
name|rule
operator|!=
name|NULL
operator|&&
name|fw_one_pass
condition|)
goto|goto
name|ipfwpass
goto|;
comment|/* packet already partially processed */
name|args
operator|.
name|m
operator|=
operator|*
name|mp
expr_stmt|;
name|args
operator|.
name|oif
operator|=
name|ifp
expr_stmt|;
name|args
operator|.
name|next_hop
operator|=
name|NULL
expr_stmt|;
name|args
operator|.
name|eh
operator|=
operator|&
name|eh2
expr_stmt|;
name|i
operator|=
name|ip_fw_chk_ptr
argument_list|(
operator|&
name|args
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|args
operator|.
name|m
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
return|return
name|error
return|;
if|if
condition|(
name|DUMMYNET_LOADED
operator|&&
operator|(
name|i
operator|==
name|IP_FW_DUMMYNET
operator|)
condition|)
block|{
comment|/* put the Ethernet header back on */
name|M_PREPEND
argument_list|(
operator|*
name|mp
argument_list|,
name|ETHER_HDR_LEN
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
return|return
name|error
return|;
name|bcopy
argument_list|(
operator|&
name|eh2
argument_list|,
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
comment|/* 			 * Pass the pkt to dummynet, which consumes it. The 			 * packet will return to us via bridge_dummynet(). 			 */
name|args
operator|.
name|oif
operator|=
name|ifp
expr_stmt|;
name|ip_dn_io_ptr
argument_list|(
operator|*
name|mp
argument_list|,
name|DN_TO_IFB_FWD
argument_list|,
operator|&
name|args
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|i
operator|!=
name|IP_FW_PASS
condition|)
comment|/* drop */
goto|goto
name|bad
goto|;
block|}
name|ipfwpass
label|:
comment|/* 	 * Check basic packet sanity and run pfil through pfil. 	 */
switch|switch
condition|(
name|ether_type
condition|)
block|{
case|case
name|ETHERTYPE_IP
case|:
name|error
operator|=
operator|(
name|dir
operator|==
name|PFIL_IN
operator|)
condition|?
name|bridge_ip_checkbasic
argument_list|(
name|mp
argument_list|)
else|:
literal|0
expr_stmt|;
comment|/* 		 * before calling the firewall, swap fields the same as 		 * IP does. here we assume the header is contiguous 		 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|ip
operator|=
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 		 * Run pfil on the member interface and the bridge, both can 		 * be skipped by clearing pfil_member or pfil_bridge. 		 * 		 * Keep the order: 		 *   in_if -> bridge_if -> out_if 		 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|pfil_bridge
operator|&&
name|dir
operator|==
name|PFIL_OUT
condition|)
name|error
operator|=
name|pfil_run_hooks
argument_list|(
operator|&
name|inet_pfil_hook
argument_list|,
name|mp
argument_list|,
name|bifp
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
comment|/* filter may consume */
break|break;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|pfil_member
condition|)
name|error
operator|=
name|pfil_run_hooks
argument_list|(
operator|&
name|inet_pfil_hook
argument_list|,
name|mp
argument_list|,
name|ifp
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
comment|/* filter may consume */
break|break;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|pfil_bridge
operator|&&
name|dir
operator|==
name|PFIL_IN
condition|)
name|error
operator|=
name|pfil_run_hooks
argument_list|(
operator|&
name|inet_pfil_hook
argument_list|,
name|mp
argument_list|,
name|bifp
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Restore ip and the fields ntohs()'d. */
if|if
condition|(
operator|*
name|mp
operator|!=
name|NULL
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
name|ip
operator|=
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|ETHERTYPE_IPV6
case|:
name|error
operator|=
operator|(
name|dir
operator|==
name|PFIL_IN
operator|)
condition|?
name|bridge_ip6_checkbasic
argument_list|(
name|mp
argument_list|)
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|pfil_bridge
operator|&&
name|dir
operator|==
name|PFIL_OUT
condition|)
name|error
operator|=
name|pfil_run_hooks
argument_list|(
operator|&
name|inet6_pfil_hook
argument_list|,
name|mp
argument_list|,
name|bifp
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
comment|/* filter may consume */
break|break;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|pfil_member
condition|)
name|error
operator|=
name|pfil_run_hooks
argument_list|(
operator|&
name|inet6_pfil_hook
argument_list|,
name|mp
argument_list|,
name|ifp
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
comment|/* filter may consume */
break|break;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|pfil_bridge
operator|&&
name|dir
operator|==
name|PFIL_IN
condition|)
name|error
operator|=
name|pfil_run_hooks
argument_list|(
operator|&
name|inet6_pfil_hook
argument_list|,
name|mp
argument_list|,
name|bifp
argument_list|,
name|dir
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default :
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
return|return
name|error
return|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
name|error
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Finally, put everything back the way it was and return 	 */
if|if
condition|(
name|snap
condition|)
block|{
name|M_PREPEND
argument_list|(
operator|*
name|mp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
return|return
name|error
return|;
name|bcopy
argument_list|(
operator|&
name|llc1
argument_list|,
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|M_PREPEND
argument_list|(
operator|*
name|mp
argument_list|,
name|ETHER_HDR_LEN
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
return|return
name|error
return|;
name|bcopy
argument_list|(
operator|&
name|eh2
argument_list|,
name|mtod
argument_list|(
operator|*
name|mp
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad
label|:
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Perform basic checks on header size since  * pfil assumes ip_input has already processed  * it for it.  Cut-and-pasted from ip_input.c.  * Given how simple the IPv6 version is,  * does the IPv4 version really need to be  * this complicated?  *  * XXX Should we update ipstat here, or not?  * XXX Right now we update ipstat but not  * XXX csum_counter.  */
end_comment

begin_function
specifier|static
name|int
name|bridge_ip_checkbasic
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|mp
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|len
decl_stmt|,
name|hlen
decl_stmt|;
name|u_short
name|sum
decl_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ipstat
operator|.
name|ips_toosmall
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|ip
operator|->
name|ip_v
operator|!=
name|IPVERSION
condition|)
block|{
name|ipstat
operator|.
name|ips_badvers
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|hlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
comment|/* minimum header length */
name|ipstat
operator|.
name|ips_badhlen
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|hlen
operator|>
name|m
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipstat
operator|.
name|ips_badhlen
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP_CHECKED
condition|)
block|{
name|sum
operator|=
operator|!
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP_VALID
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hlen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
name|sum
operator|=
name|in_cksum_hdr
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sum
condition|)
block|{
name|ipstat
operator|.
name|ips_badsum
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Retrieve the packet length. */
name|len
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
comment|/* 	 * Check for additional length bogosity 	 */
if|if
condition|(
name|len
operator|<
name|hlen
condition|)
block|{
name|ipstat
operator|.
name|ips_badlen
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Check that the amount of data in the buffers 	 * is as at least much as the IP header would have us expect. 	 * Drop packet if shorter than we expect. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|len
condition|)
block|{
name|ipstat
operator|.
name|ips_tooshort
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Checks out, proceed */
operator|*
name|mp
operator|=
name|m
expr_stmt|;
return|return
literal|0
return|;
name|bad
label|:
operator|*
name|mp
operator|=
name|m
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_comment
comment|/*  * Same as above, but for IPv6.  * Cut-and-pasted from ip6_input.c.  * XXX Should we update ip6stat, or not?  */
end_comment

begin_function
specifier|static
name|int
name|bridge_ip6_checkbasic
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|mp
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
comment|/* 	 * If the IPv6 header is not aligned, slurp it up into a new 	 * mbuf with space for link headers, in the event we forward 	 * it.  Otherwise, if it is aligned, make sure the entire base 	 * IPv6 header is in the first mbuf of the chain.  	if (IP6_HDR_ALIGNED_P(mtod(m, caddr_t)) == 0) { 		struct ifnet *inifp = m->m_pkthdr.rcvif; 		if ((m = m_copyup(m, sizeof(struct ip6_hdr), 			    (max_linkhdr + 3)& ~3)) == NULL) { 			* XXXJRT new stat, please * 			ip6stat.ip6s_toosmall++; 			in6_ifstat_inc(inifp, ifs6_in_hdrerr); 			goto bad; 		} 	} else */
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|inifp
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_toosmall
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|inifp
argument_list|,
name|ifs6_in_hdrerr
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ip6
operator|->
name|ip6_vfc
operator|&
name|IPV6_VERSION_MASK
operator|)
operator|!=
name|IPV6_VERSION
condition|)
block|{
name|ip6stat
operator|.
name|ip6s_badvers
operator|++
expr_stmt|;
name|in6_ifstat_inc
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ifs6_in_hdrerr
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Checks out, proceed */
operator|*
name|mp
operator|=
name|m
expr_stmt|;
return|return
literal|0
return|;
name|bad
label|:
operator|*
name|mp
operator|=
name|m
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

end_unit

