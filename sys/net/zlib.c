begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * This file is derived from various .h and .c files from the zlib-0.95  * distribution by Jean-loup Gailly and Mark Adler, with some additions  * by Paul Mackerras to aid in implementing Deflate compression and  * decompression for PPP packets.  See zlib.h for conditions of  * distribution and use.  *  * Changes that have been made include:  * - changed functions not used outside this file to "local"  * - added minCompression parameter to deflateInit2  * - added Z_PACKET_FLUSH (see zlib.h for details)  * - added inflateIncomp  *  * $Id: zlib.c,v 1.1.2.1 1997/07/01 20:44:10 peter Exp $  */
end_comment

begin_comment
comment|/*   *  ==FILEVERSION 970501==  *  * This marker is used by the Linux installation script to determine  * whether an up-to-date version of this file is already installed.  */
end_comment

begin_comment
comment|/*+++++*/
end_comment

begin_comment
comment|/* zutil.h -- internal interface and configuration of the compression library  * Copyright (C) 1995 Jean-loup Gailly.  * For conditions of distribution and use, see copyright notice in zlib.h  */
end_comment

begin_comment
comment|/* WARNING: this file should *not* be used by applications. It is    part of the implementation of the compression library and is    subject to change. Applications should only use zlib.h.  */
end_comment

begin_comment
comment|/* From: zutil.h,v 1.9 1995/05/03 17:27:12 jloup Exp */
end_comment

begin_define
define|#
directive|define
name|_Z_UTIL_H
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<net/zlib.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"zlib.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|local
end_ifndef

begin_define
define|#
directive|define
name|local
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* compile with -Dlocal if your debugger can't find static symbols */
end_comment

begin_define
define|#
directive|define
name|FAR
end_define

begin_typedef
typedef|typedef
name|unsigned
name|char
name|uch
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uch
name|FAR
name|uchf
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|short
name|ush
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|ush
name|FAR
name|ushf
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|long
name|ulg
typedef|;
end_typedef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|z_errmsg
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indexed by 1-zlib_error */
end_comment

begin_define
define|#
directive|define
name|ERR_RETURN
parameter_list|(
name|strm
parameter_list|,
name|err
parameter_list|)
value|return (strm->msg=z_errmsg[1-err], err)
end_define

begin_comment
comment|/* To be used only when the state is known to be valid */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|((void *) 0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* common constants */
end_comment

begin_define
define|#
directive|define
name|DEFLATED
value|8
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|DEF_WBITS
end_ifndef

begin_define
define|#
directive|define
name|DEF_WBITS
value|MAX_WBITS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* default windowBits for decompression. MAX_WBITS is for compression only */
end_comment

begin_if
if|#
directive|if
name|MAX_MEM_LEVEL
operator|>=
literal|8
end_if

begin_define
define|#
directive|define
name|DEF_MEM_LEVEL
value|8
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DEF_MEM_LEVEL
value|MAX_MEM_LEVEL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* default memLevel */
end_comment

begin_define
define|#
directive|define
name|STORED_BLOCK
value|0
end_define

begin_define
define|#
directive|define
name|STATIC_TREES
value|1
end_define

begin_define
define|#
directive|define
name|DYN_TREES
value|2
end_define

begin_comment
comment|/* The three kinds of block type */
end_comment

begin_define
define|#
directive|define
name|MIN_MATCH
value|3
end_define

begin_define
define|#
directive|define
name|MAX_MATCH
value|258
end_define

begin_comment
comment|/* The minimum and maximum match lengths */
end_comment

begin_comment
comment|/* functions */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|KERNEL
argument_list|)
operator|||
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_define
define|#
directive|define
name|zmemcpy
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|,
name|n
parameter_list|)
value|bcopy((s), (d), (n))
end_define

begin_define
define|#
directive|define
name|zmemzero
value|bzero
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__KERNEL__
argument_list|)
end_if

begin_comment
comment|/* Assume this is Linux */
end_comment

begin_include
include|#
directive|include
file|<linux/string.h>
end_include

begin_define
define|#
directive|define
name|zmemcpy
value|memcpy
end_define

begin_define
define|#
directive|define
name|zmemzero
parameter_list|(
name|dest
parameter_list|,
name|len
parameter_list|)
value|memset(dest, 0, len)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* not kernel */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STDC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_MEMCPY
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_MEMCPY
argument_list|)
end_if

begin_define
define|#
directive|define
name|HAVE_MEMCPY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_MEMCPY
end_ifdef

begin_define
define|#
directive|define
name|zmemcpy
value|memcpy
end_define

begin_define
define|#
directive|define
name|zmemzero
parameter_list|(
name|dest
parameter_list|,
name|len
parameter_list|)
value|memset(dest, 0, len)
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|extern
name|void
name|zmemcpy
name|OF
argument_list|(
operator|(
name|Bytef
operator|*
name|dest
operator|,
name|Bytef
operator|*
name|source
operator|,
name|uInt
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|zmemzero
name|OF
argument_list|(
operator|(
name|Bytef
operator|*
name|dest
operator|,
name|uInt
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __KERNEL__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KERNEL */
end_comment

begin_comment
comment|/* Diagnostic functions */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_ZLIB
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|verbose
end_ifndef

begin_define
define|#
directive|define
name|verbose
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|Assert
parameter_list|(
name|cond
parameter_list|,
name|msg
parameter_list|)
value|{if(!(cond)) z_error(msg);}
end_define

begin_define
define|#
directive|define
name|Trace
parameter_list|(
name|x
parameter_list|)
value|fprintf x
end_define

begin_define
define|#
directive|define
name|Tracev
parameter_list|(
name|x
parameter_list|)
value|{if (verbose) fprintf x ;}
end_define

begin_define
define|#
directive|define
name|Tracevv
parameter_list|(
name|x
parameter_list|)
value|{if (verbose>1) fprintf x ;}
end_define

begin_define
define|#
directive|define
name|Tracec
parameter_list|(
name|c
parameter_list|,
name|x
parameter_list|)
value|{if (verbose&& (c)) fprintf x ;}
end_define

begin_define
define|#
directive|define
name|Tracecv
parameter_list|(
name|c
parameter_list|,
name|x
parameter_list|)
value|{if (verbose>1&& (c)) fprintf x ;}
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|Assert
parameter_list|(
name|cond
parameter_list|,
name|msg
parameter_list|)
end_define

begin_define
define|#
directive|define
name|Trace
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|Tracev
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|Tracevv
parameter_list|(
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|Tracec
parameter_list|(
name|c
parameter_list|,
name|x
parameter_list|)
end_define

begin_define
define|#
directive|define
name|Tracecv
parameter_list|(
name|c
parameter_list|,
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|uLong
argument_list|(
argument|*check_func
argument_list|)
name|OF
argument_list|(
operator|(
name|uLong
name|check
operator|,
name|Bytef
operator|*
name|buf
operator|,
name|uInt
name|len
operator|)
argument_list|)
expr_stmt|;
end_typedef

begin_comment
comment|/* voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size)); */
end_comment

begin_comment
comment|/* void   zcfree  OF((voidpf opaque, voidpf ptr)); */
end_comment

begin_define
define|#
directive|define
name|ZALLOC
parameter_list|(
name|strm
parameter_list|,
name|items
parameter_list|,
name|size
parameter_list|)
define|\
value|(*((strm)->zalloc))((strm)->opaque, (items), (size))
end_define

begin_define
define|#
directive|define
name|ZALLOC_INIT
parameter_list|(
name|strm
parameter_list|,
name|items
parameter_list|,
name|size
parameter_list|)
define|\
value|(*((strm)->zalloc_init))((strm)->opaque, (items), (size))
end_define

begin_define
define|#
directive|define
name|ZFREE
parameter_list|(
name|strm
parameter_list|,
name|addr
parameter_list|,
name|size
parameter_list|)
define|\
value|(*((strm)->zfree))((strm)->opaque, (voidpf)(addr), (size))
end_define

begin_define
define|#
directive|define
name|TRY_FREE
parameter_list|(
name|s
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
value|{if (p) ZFREE(s, p, n);}
end_define

begin_comment
comment|/* deflate.h -- internal compression state  * Copyright (C) 1995 Jean-loup Gailly  * For conditions of distribution and use, see copyright notice in zlib.h   */
end_comment

begin_comment
comment|/* WARNING: this file should *not* be used by applications. It is    part of the implementation of the compression library and is    subject to change. Applications should only use zlib.h.  */
end_comment

begin_comment
comment|/*+++++*/
end_comment

begin_comment
comment|/* From: deflate.h,v 1.5 1995/05/03 17:27:09 jloup Exp */
end_comment

begin_comment
comment|/* ===========================================================================  * Internal compression state.  */
end_comment

begin_comment
comment|/* Data type */
end_comment

begin_define
define|#
directive|define
name|Z_BINARY
value|0
end_define

begin_define
define|#
directive|define
name|ASCII
value|1
end_define

begin_define
define|#
directive|define
name|UNKNOWN
value|2
end_define

begin_define
define|#
directive|define
name|LENGTH_CODES
value|29
end_define

begin_comment
comment|/* number of length codes, not counting the special END_BLOCK code */
end_comment

begin_define
define|#
directive|define
name|LITERALS
value|256
end_define

begin_comment
comment|/* number of literal bytes 0..255 */
end_comment

begin_define
define|#
directive|define
name|L_CODES
value|(LITERALS+1+LENGTH_CODES)
end_define

begin_comment
comment|/* number of Literal or Length codes, including the END_BLOCK code */
end_comment

begin_define
define|#
directive|define
name|D_CODES
value|30
end_define

begin_comment
comment|/* number of distance codes */
end_comment

begin_define
define|#
directive|define
name|BL_CODES
value|19
end_define

begin_comment
comment|/* number of codes used to transfer the bit lengths */
end_comment

begin_define
define|#
directive|define
name|HEAP_SIZE
value|(2*L_CODES+1)
end_define

begin_comment
comment|/* maximum heap size */
end_comment

begin_define
define|#
directive|define
name|MAX_BITS
value|15
end_define

begin_comment
comment|/* All codes must not exceed MAX_BITS bits */
end_comment

begin_define
define|#
directive|define
name|INIT_STATE
value|42
end_define

begin_define
define|#
directive|define
name|BUSY_STATE
value|113
end_define

begin_define
define|#
directive|define
name|FLUSH_STATE
value|124
end_define

begin_define
define|#
directive|define
name|FINISH_STATE
value|666
end_define

begin_comment
comment|/* Stream status */
end_comment

begin_comment
comment|/* Data structure describing a single value and its code string. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ct_data_s
block|{
union|union
block|{
name|ush
name|freq
decl_stmt|;
comment|/* frequency count */
name|ush
name|code
decl_stmt|;
comment|/* bit string */
block|}
name|fc
union|;
union|union
block|{
name|ush
name|dad
decl_stmt|;
comment|/* father node in Huffman tree */
name|ush
name|len
decl_stmt|;
comment|/* length of bit string */
block|}
name|dl
union|;
block|}
name|FAR
name|ct_data
typedef|;
end_typedef

begin_define
define|#
directive|define
name|Freq
value|fc.freq
end_define

begin_define
define|#
directive|define
name|Code
value|fc.code
end_define

begin_define
define|#
directive|define
name|Dad
value|dl.dad
end_define

begin_define
define|#
directive|define
name|Len
value|dl.len
end_define

begin_typedef
typedef|typedef
name|struct
name|static_tree_desc_s
name|static_tree_desc
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|tree_desc_s
block|{
name|ct_data
modifier|*
name|dyn_tree
decl_stmt|;
comment|/* the dynamic tree */
name|int
name|max_code
decl_stmt|;
comment|/* largest code with non zero frequency */
name|static_tree_desc
modifier|*
name|stat_desc
decl_stmt|;
comment|/* the corresponding static tree */
block|}
name|FAR
name|tree_desc
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|ush
name|Pos
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|Pos
name|FAR
name|Posf
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|IPos
typedef|;
end_typedef

begin_comment
comment|/* A Pos is an index in the character window. We use short instead of int to  * save space in the various tables. IPos is used only for parameter passing.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|deflate_state
block|{
name|z_stream
modifier|*
name|strm
decl_stmt|;
comment|/* pointer back to this zlib stream */
name|int
name|status
decl_stmt|;
comment|/* as the name implies */
name|Bytef
modifier|*
name|pending_buf
decl_stmt|;
comment|/* output still pending */
name|Bytef
modifier|*
name|pending_out
decl_stmt|;
comment|/* next pending byte to output to the stream */
name|int
name|pending
decl_stmt|;
comment|/* nb of bytes in the pending buffer */
name|uLong
name|adler
decl_stmt|;
comment|/* adler32 of uncompressed data */
name|int
name|noheader
decl_stmt|;
comment|/* suppress zlib header and adler32 */
name|Byte
name|data_type
decl_stmt|;
comment|/* UNKNOWN, Z_BINARY or ASCII */
name|Byte
name|method
decl_stmt|;
comment|/* STORED (for zip only) or DEFLATED */
name|int
name|minCompr
decl_stmt|;
comment|/* min size decrease for Z_FLUSH_NOSTORE */
comment|/* used by deflate.c: */
name|uInt
name|w_size
decl_stmt|;
comment|/* LZ77 window size (32K by default) */
name|uInt
name|w_bits
decl_stmt|;
comment|/* log2(w_size)  (8..16) */
name|uInt
name|w_mask
decl_stmt|;
comment|/* w_size - 1 */
name|Bytef
modifier|*
name|window
decl_stmt|;
comment|/* Sliding window. Input bytes are read into the second half of the window,      * and move to the first half later to keep a dictionary of at least wSize      * bytes. With this organization, matches are limited to a distance of      * wSize-MAX_MATCH bytes, but this ensures that IO is always      * performed with a length multiple of the block size. Also, it limits      * the window size to 64K, which is quite useful on MSDOS.      * To do: use the user input buffer as sliding window.      */
name|ulg
name|window_size
decl_stmt|;
comment|/* Actual size of window: 2*wSize, except when the user input buffer      * is directly used as sliding window.      */
name|Posf
modifier|*
name|prev
decl_stmt|;
comment|/* Link to older string with same hash index. To limit the size of this      * array to 64K, this link is maintained only for the last 32K strings.      * An index in this array is thus a window index modulo 32K.      */
name|Posf
modifier|*
name|head
decl_stmt|;
comment|/* Heads of the hash chains or NIL. */
name|uInt
name|ins_h
decl_stmt|;
comment|/* hash index of string to be inserted */
name|uInt
name|hash_size
decl_stmt|;
comment|/* number of elements in hash table */
name|uInt
name|hash_bits
decl_stmt|;
comment|/* log2(hash_size) */
name|uInt
name|hash_mask
decl_stmt|;
comment|/* hash_size-1 */
name|uInt
name|hash_shift
decl_stmt|;
comment|/* Number of bits by which ins_h must be shifted at each input      * step. It must be such that after MIN_MATCH steps, the oldest      * byte no longer takes part in the hash key, that is:      *   hash_shift * MIN_MATCH>= hash_bits      */
name|long
name|block_start
decl_stmt|;
comment|/* Window position at the beginning of the current output block. Gets      * negative when the window is moved backwards.      */
name|uInt
name|match_length
decl_stmt|;
comment|/* length of best match */
name|IPos
name|prev_match
decl_stmt|;
comment|/* previous match */
name|int
name|match_available
decl_stmt|;
comment|/* set if previous match exists */
name|uInt
name|strstart
decl_stmt|;
comment|/* start of string to insert */
name|uInt
name|match_start
decl_stmt|;
comment|/* start of matching string */
name|uInt
name|lookahead
decl_stmt|;
comment|/* number of valid bytes ahead in window */
name|uInt
name|prev_length
decl_stmt|;
comment|/* Length of the best match at previous step. Matches not greater than this      * are discarded. This is used in the lazy match evaluation.      */
name|uInt
name|max_chain_length
decl_stmt|;
comment|/* To speed up deflation, hash chains are never searched beyond this      * length.  A higher limit improves compression ratio but degrades the      * speed.      */
name|uInt
name|max_lazy_match
decl_stmt|;
comment|/* Attempt to find a better match only when the current match is strictly      * smaller than this value. This mechanism is used only for compression      * levels>= 4.      */
define|#
directive|define
name|max_insert_length
value|max_lazy_match
comment|/* Insert new strings in the hash table only if the match length is not      * greater than this length. This saves time but degrades compression.      * max_insert_length is used only for compression levels<= 3.      */
name|int
name|level
decl_stmt|;
comment|/* compression level (1..9) */
name|int
name|strategy
decl_stmt|;
comment|/* favor or force Huffman coding*/
name|uInt
name|good_match
decl_stmt|;
comment|/* Use a faster search when the previous match is longer than this */
name|int
name|nice_match
decl_stmt|;
comment|/* Stop searching when current match exceeds this */
comment|/* used by trees.c: */
comment|/* Didn't use ct_data typedef below to supress compiler warning */
name|struct
name|ct_data_s
name|dyn_ltree
index|[
name|HEAP_SIZE
index|]
decl_stmt|;
comment|/* literal and length tree */
name|struct
name|ct_data_s
name|dyn_dtree
index|[
literal|2
operator|*
name|D_CODES
operator|+
literal|1
index|]
decl_stmt|;
comment|/* distance tree */
name|struct
name|ct_data_s
name|bl_tree
index|[
literal|2
operator|*
name|BL_CODES
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Huffman tree for bit lengths */
name|struct
name|tree_desc_s
name|l_desc
decl_stmt|;
comment|/* desc. for literal tree */
name|struct
name|tree_desc_s
name|d_desc
decl_stmt|;
comment|/* desc. for distance tree */
name|struct
name|tree_desc_s
name|bl_desc
decl_stmt|;
comment|/* desc. for bit length tree */
name|ush
name|bl_count
index|[
name|MAX_BITS
operator|+
literal|1
index|]
decl_stmt|;
comment|/* number of codes at each bit length for an optimal tree */
name|int
name|heap
index|[
literal|2
operator|*
name|L_CODES
operator|+
literal|1
index|]
decl_stmt|;
comment|/* heap used to build the Huffman trees */
name|int
name|heap_len
decl_stmt|;
comment|/* number of elements in the heap */
name|int
name|heap_max
decl_stmt|;
comment|/* element of largest frequency */
comment|/* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.      * The same heap array is used to build all trees.      */
name|uch
name|depth
index|[
literal|2
operator|*
name|L_CODES
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Depth of each subtree used as tie breaker for trees of equal frequency      */
name|uchf
modifier|*
name|l_buf
decl_stmt|;
comment|/* buffer for literals or lengths */
name|uInt
name|lit_bufsize
decl_stmt|;
comment|/* Size of match buffer for literals/lengths.  There are 4 reasons for      * limiting lit_bufsize to 64K:      *   - frequencies can be kept in 16 bit counters      *   - if compression is not successful for the first block, all input      *     data is still in the window so we can still emit a stored block even      *     when input comes from standard input.  (This can also be done for      *     all blocks if lit_bufsize is not greater than 32K.)      *   - if compression is not successful for a file smaller than 64K, we can      *     even emit a stored file instead of a stored block (saving 5 bytes).      *     This is applicable only for zip (not gzip or zlib).      *   - creating new Huffman trees less frequently may not provide fast      *     adaptation to changes in the input data statistics. (Take for      *     example a binary file with poorly compressible code followed by      *     a highly compressible string table.) Smaller buffer sizes give      *     fast adaptation but have of course the overhead of transmitting      *     trees more frequently.      *   - I can't count above 4      */
name|uInt
name|last_lit
decl_stmt|;
comment|/* running index in l_buf */
name|ushf
modifier|*
name|d_buf
decl_stmt|;
comment|/* Buffer for distances. To simplify the code, d_buf and l_buf have      * the same number of elements. To use different lengths, an extra flag      * array would be necessary.      */
name|ulg
name|opt_len
decl_stmt|;
comment|/* bit length of current block with optimal trees */
name|ulg
name|static_len
decl_stmt|;
comment|/* bit length of current block with static trees */
name|ulg
name|compressed_len
decl_stmt|;
comment|/* total bit length of compressed file */
name|uInt
name|matches
decl_stmt|;
comment|/* number of string matches in current block */
name|int
name|last_eob_len
decl_stmt|;
comment|/* bit length of EOB code for last block */
ifdef|#
directive|ifdef
name|DEBUG_ZLIB
name|ulg
name|bits_sent
decl_stmt|;
comment|/* bit length of the compressed data */
endif|#
directive|endif
name|ush
name|bi_buf
decl_stmt|;
comment|/* Output buffer. bits are inserted starting at the bottom (least      * significant bits).      */
name|int
name|bi_valid
decl_stmt|;
comment|/* Number of valid bits in bi_buf.  All bits above the last valid bit      * are always zero.      */
name|uInt
name|blocks_in_packet
decl_stmt|;
comment|/* Number of blocks produced since the last time Z_PACKET_FLUSH      * was used.      */
block|}
name|FAR
name|deflate_state
typedef|;
end_typedef

begin_comment
comment|/* Output a byte on the stream.  * IN assertion: there is enough room in pending_buf.  */
end_comment

begin_define
define|#
directive|define
name|put_byte
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|)
value|{s->pending_buf[s->pending++] = (c);}
end_define

begin_define
define|#
directive|define
name|MIN_LOOKAHEAD
value|(MAX_MATCH+MIN_MATCH+1)
end_define

begin_comment
comment|/* Minimum amount of lookahead, except at the end of the input file.  * See deflate.c for comments about the MIN_MATCH+1.  */
end_comment

begin_define
define|#
directive|define
name|MAX_DIST
parameter_list|(
name|s
parameter_list|)
value|((s)->w_size-MIN_LOOKAHEAD)
end_define

begin_comment
comment|/* In order to simplify the code, particularly on 16 bit machines, match  * distances are limited to MAX_DIST instead of WSIZE.  */
end_comment

begin_comment
comment|/* in trees.c */
end_comment

begin_decl_stmt
name|local
name|void
name|ct_init
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|ct_tally
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|int
name|dist
operator|,
name|int
name|lc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|ulg
name|ct_flush_block
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|charf
operator|*
name|buf
operator|,
name|ulg
name|stored_len
operator|,
name|int
name|flush
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|ct_align
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|ct_stored_block
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|charf
operator|*
name|buf
operator|,
name|ulg
name|stored_len
operator|,
name|int
name|eof
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|ct_stored_type_only
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*+++++*/
end_comment

begin_comment
comment|/* deflate.c -- compress data using the deflation algorithm  * Copyright (C) 1995 Jean-loup Gailly.  * For conditions of distribution and use, see copyright notice in zlib.h   */
end_comment

begin_comment
comment|/*  *  ALGORITHM  *  *      The "deflation" process depends on being able to identify portions  *      of the input text which are identical to earlier input (within a  *      sliding window trailing behind the input currently being processed).  *  *      The most straightforward technique turns out to be the fastest for  *      most input files: try all possible matches and select the longest.  *      The key feature of this algorithm is that insertions into the string  *      dictionary are very simple and thus fast, and deletions are avoided  *      completely. Insertions are performed at each input character, whereas  *      string matches are performed only when the previous match ends. So it  *      is preferable to spend more time in matches to allow very fast string  *      insertions and avoid deletions. The matching algorithm for small  *      strings is inspired from that of Rabin& Karp. A brute force approach  *      is used to find longer strings when a small match has been found.  *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze  *      (by Leonid Broukhis).  *         A previous version of this file used a more sophisticated algorithm  *      (by Fiala and Greene) which is guaranteed to run in linear amortized  *      time, but has a larger average cost, uses more memory and is patented.  *      However the F&G algorithm may be faster for some highly redundant  *      files if the parameter max_chain_length (described below) is too large.  *  *  ACKNOWLEDGEMENTS  *  *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and  *      I found it in 'freeze' written by Leonid Broukhis.  *      Thanks to many people for bug reports and testing.  *  *  REFERENCES  *  *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".  *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc  *  *      A description of the Rabin and Karp algorithm is given in the book  *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.  *  *      Fiala,E.R., and Greene,D.H.  *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595  *  */
end_comment

begin_comment
comment|/* From: deflate.c,v 1.8 1995/05/03 17:27:08 jloup Exp */
end_comment

begin_decl_stmt
name|local
name|char
name|zlib_copyright
index|[]
init|=
literal|" deflate Copyright 1995 Jean-loup Gailly "
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*   If you use the zlib library in a product, an acknowledgment is welcome   in the documentation of your product. If for some reason you cannot   include such an acknowledgment, I would appreciate that you keep this   copyright string in the executable of your product.  */
end_comment

begin_define
define|#
directive|define
name|NIL
value|0
end_define

begin_comment
comment|/* Tail of hash chains */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TOO_FAR
end_ifndef

begin_define
define|#
directive|define
name|TOO_FAR
value|4096
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */
end_comment

begin_define
define|#
directive|define
name|MIN_LOOKAHEAD
value|(MAX_MATCH+MIN_MATCH+1)
end_define

begin_comment
comment|/* Minimum amount of lookahead, except at the end of the input file.  * See deflate.c for comments about the MIN_MATCH+1.  */
end_comment

begin_comment
comment|/* Values for max_lazy_match, good_match and max_chain_length, depending on  * the desired pack level (0..9). The values given below have been tuned to  * exclude worst case performance for pathological files. Better values may be  * found for specific files.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|config_s
block|{
name|ush
name|good_length
decl_stmt|;
comment|/* reduce lazy search above this match length */
name|ush
name|max_lazy
decl_stmt|;
comment|/* do not perform lazy search above this match length */
name|ush
name|nice_length
decl_stmt|;
comment|/* quit search above this match length */
name|ush
name|max_chain
decl_stmt|;
block|}
name|config
typedef|;
end_typedef

begin_decl_stmt
name|local
name|config
name|configuration_table
index|[
literal|10
index|]
init|=
block|{
comment|/*      good lazy nice chain */
comment|/* 0 */
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* store only */
comment|/* 1 */
block|{
literal|4
block|,
literal|4
block|,
literal|8
block|,
literal|4
block|}
block|,
comment|/* maximum speed, no lazy matches */
comment|/* 2 */
block|{
literal|4
block|,
literal|5
block|,
literal|16
block|,
literal|8
block|}
block|,
comment|/* 3 */
block|{
literal|4
block|,
literal|6
block|,
literal|32
block|,
literal|32
block|}
block|,
comment|/* 4 */
block|{
literal|4
block|,
literal|4
block|,
literal|16
block|,
literal|16
block|}
block|,
comment|/* lazy matches */
comment|/* 5 */
block|{
literal|8
block|,
literal|16
block|,
literal|32
block|,
literal|32
block|}
block|,
comment|/* 6 */
block|{
literal|8
block|,
literal|16
block|,
literal|128
block|,
literal|128
block|}
block|,
comment|/* 7 */
block|{
literal|8
block|,
literal|32
block|,
literal|128
block|,
literal|256
block|}
block|,
comment|/* 8 */
block|{
literal|32
block|,
literal|128
block|,
literal|258
block|,
literal|1024
block|}
block|,
comment|/* 9 */
block|{
literal|32
block|,
literal|258
block|,
literal|258
block|,
literal|4096
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum compression */
end_comment

begin_comment
comment|/* Note: the deflate() code requires max_lazy>= MIN_MATCH and max_chain>= 4  * For deflate_fast() (levels<= 3) good is ignored and lazy has a different  * meaning.  */
end_comment

begin_define
define|#
directive|define
name|EQUAL
value|0
end_define

begin_comment
comment|/* result of memcmp for equal strings */
end_comment

begin_comment
comment|/* ===========================================================================  *  Prototypes for local functions.  */
end_comment

begin_decl_stmt
name|local
name|void
name|fill_window
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|deflate_fast
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|int
name|flush
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|deflate_slow
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|int
name|flush
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|lm_init
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|longest_match
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|IPos
name|cur_match
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|putShortMSB
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|uInt
name|b
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|flush_pending
name|OF
argument_list|(
operator|(
name|z_stream
operator|*
name|strm
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|read_buf
name|OF
argument_list|(
operator|(
name|z_stream
operator|*
name|strm
operator|,
name|charf
operator|*
name|buf
operator|,
name|unsigned
name|size
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ASMV
end_ifdef

begin_decl_stmt
name|void
name|match_init
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* asm code initialization */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_ZLIB
end_ifdef

begin_decl_stmt
name|local
name|void
name|check_match
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|IPos
name|start
operator|,
name|IPos
name|match
operator|,
name|int
name|length
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ===========================================================================  * Update a hash value with the given input byte  * IN  assertion: all calls to to UPDATE_HASH are made with consecutive  *    input characters, so that a running hash key can be computed from the  *    previous key instead of complete recalculation each time.  */
end_comment

begin_define
define|#
directive|define
name|UPDATE_HASH
parameter_list|(
name|s
parameter_list|,
name|h
parameter_list|,
name|c
parameter_list|)
value|(h = (((h)<<s->hash_shift) ^ (c))& s->hash_mask)
end_define

begin_comment
comment|/* ===========================================================================  * Insert string str in the dictionary and set match_head to the previous head  * of the hash chain (the most recent string with same hash key). Return  * the previous length of the hash chain.  * IN  assertion: all calls to to INSERT_STRING are made with consecutive  *    input characters and the first MIN_MATCH bytes of str are valid  *    (except for the last MIN_MATCH-1 bytes of the input file).  */
end_comment

begin_define
define|#
directive|define
name|INSERT_STRING
parameter_list|(
name|s
parameter_list|,
name|str
parameter_list|,
name|match_head
parameter_list|)
define|\
value|(UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \     s->prev[(str)& s->w_mask] = match_head = s->head[s->ins_h], \     s->head[s->ins_h] = (str))
end_define

begin_comment
comment|/* ===========================================================================  * Initialize the hash table (avoiding 64K overflow for 16 bit systems).  * prev[] will be initialized on the fly.  */
end_comment

begin_define
define|#
directive|define
name|CLEAR_HASH
parameter_list|(
name|s
parameter_list|)
define|\
value|s->head[s->hash_size-1] = NIL; \     zmemzero((charf *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));
end_define

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|int
name|deflateInit
parameter_list|(
name|strm
parameter_list|,
name|level
parameter_list|)
name|z_stream
modifier|*
name|strm
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
return|return
name|deflateInit2
argument_list|(
name|strm
argument_list|,
name|level
argument_list|,
name|DEFLATED
argument_list|,
name|MAX_WBITS
argument_list|,
name|DEF_MEM_LEVEL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
comment|/* To do: ignore strm->next_in if we use it as window */
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|int
name|deflateInit2
parameter_list|(
name|strm
parameter_list|,
name|level
parameter_list|,
name|method
parameter_list|,
name|windowBits
parameter_list|,
name|memLevel
parameter_list|,
name|strategy
parameter_list|,
name|minCompression
parameter_list|)
name|z_stream
modifier|*
name|strm
decl_stmt|;
name|int
name|level
decl_stmt|;
name|int
name|method
decl_stmt|;
name|int
name|windowBits
decl_stmt|;
name|int
name|memLevel
decl_stmt|;
name|int
name|strategy
decl_stmt|;
name|int
name|minCompression
decl_stmt|;
block|{
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|int
name|noheader
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|strm
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|strm
operator|->
name|msg
operator|=
name|Z_NULL
expr_stmt|;
comment|/*    if (strm->zalloc == Z_NULL) strm->zalloc = zcalloc; */
comment|/*    if (strm->zfree == Z_NULL) strm->zfree = zcfree; */
if|if
condition|(
name|level
operator|==
name|Z_DEFAULT_COMPRESSION
condition|)
name|level
operator|=
literal|6
expr_stmt|;
if|if
condition|(
name|windowBits
operator|<
literal|0
condition|)
block|{
comment|/* undocumented feature: suppress zlib header */
name|noheader
operator|=
literal|1
expr_stmt|;
name|windowBits
operator|=
operator|-
name|windowBits
expr_stmt|;
block|}
if|if
condition|(
name|memLevel
operator|<
literal|1
operator|||
name|memLevel
operator|>
name|MAX_MEM_LEVEL
operator|||
name|method
operator|!=
name|DEFLATED
operator|||
name|windowBits
operator|<
literal|8
operator|||
name|windowBits
operator|>
literal|15
operator|||
name|level
operator|<
literal|1
operator|||
name|level
operator|>
literal|9
condition|)
block|{
return|return
name|Z_STREAM_ERROR
return|;
block|}
name|s
operator|=
operator|(
name|deflate_state
operator|*
operator|)
name|ZALLOC_INIT
argument_list|(
name|strm
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|deflate_state
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|Z_NULL
condition|)
return|return
name|Z_MEM_ERROR
return|;
name|strm
operator|->
name|state
operator|=
operator|(
expr|struct
name|internal_state
name|FAR
operator|*
operator|)
name|s
expr_stmt|;
name|s
operator|->
name|strm
operator|=
name|strm
expr_stmt|;
name|s
operator|->
name|noheader
operator|=
name|noheader
expr_stmt|;
name|s
operator|->
name|w_bits
operator|=
name|windowBits
expr_stmt|;
name|s
operator|->
name|w_size
operator|=
literal|1
operator|<<
name|s
operator|->
name|w_bits
expr_stmt|;
name|s
operator|->
name|w_mask
operator|=
name|s
operator|->
name|w_size
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|hash_bits
operator|=
name|memLevel
operator|+
literal|7
expr_stmt|;
name|s
operator|->
name|hash_size
operator|=
literal|1
operator|<<
name|s
operator|->
name|hash_bits
expr_stmt|;
name|s
operator|->
name|hash_mask
operator|=
name|s
operator|->
name|hash_size
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|hash_shift
operator|=
operator|(
operator|(
name|s
operator|->
name|hash_bits
operator|+
name|MIN_MATCH
operator|-
literal|1
operator|)
operator|/
name|MIN_MATCH
operator|)
expr_stmt|;
name|s
operator|->
name|window
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|ZALLOC_INIT
argument_list|(
name|strm
argument_list|,
name|s
operator|->
name|w_size
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|Byte
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|prev
operator|=
operator|(
name|Posf
operator|*
operator|)
name|ZALLOC_INIT
argument_list|(
name|strm
argument_list|,
name|s
operator|->
name|w_size
argument_list|,
sizeof|sizeof
argument_list|(
name|Pos
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|head
operator|=
operator|(
name|Posf
operator|*
operator|)
name|ZALLOC_INIT
argument_list|(
name|strm
argument_list|,
name|s
operator|->
name|hash_size
argument_list|,
sizeof|sizeof
argument_list|(
name|Pos
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|lit_bufsize
operator|=
literal|1
operator|<<
operator|(
name|memLevel
operator|+
literal|6
operator|)
expr_stmt|;
comment|/* 16K elements by default */
name|s
operator|->
name|pending_buf
operator|=
operator|(
name|uchf
operator|*
operator|)
name|ZALLOC_INIT
argument_list|(
name|strm
argument_list|,
name|s
operator|->
name|lit_bufsize
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|ush
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|window
operator|==
name|Z_NULL
operator|||
name|s
operator|->
name|prev
operator|==
name|Z_NULL
operator|||
name|s
operator|->
name|head
operator|==
name|Z_NULL
operator|||
name|s
operator|->
name|pending_buf
operator|==
name|Z_NULL
condition|)
block|{
name|strm
operator|->
name|msg
operator|=
name|z_errmsg
index|[
literal|1
operator|-
name|Z_MEM_ERROR
index|]
expr_stmt|;
name|deflateEnd
argument_list|(
name|strm
argument_list|)
expr_stmt|;
return|return
name|Z_MEM_ERROR
return|;
block|}
name|s
operator|->
name|d_buf
operator|=
operator|(
name|ushf
operator|*
operator|)
operator|&
operator|(
name|s
operator|->
name|pending_buf
index|[
name|s
operator|->
name|lit_bufsize
index|]
operator|)
expr_stmt|;
name|s
operator|->
name|l_buf
operator|=
operator|(
name|uchf
operator|*
operator|)
operator|&
operator|(
name|s
operator|->
name|pending_buf
index|[
literal|3
operator|*
name|s
operator|->
name|lit_bufsize
index|]
operator|)
expr_stmt|;
comment|/* We overlay pending_buf and d_buf+l_buf. This works since the average      * output size for (length,distance) codes is<= 32 bits (worst case      * is 15+15+13=33).      */
name|s
operator|->
name|level
operator|=
name|level
expr_stmt|;
name|s
operator|->
name|strategy
operator|=
name|strategy
expr_stmt|;
name|s
operator|->
name|method
operator|=
operator|(
name|Byte
operator|)
name|method
expr_stmt|;
name|s
operator|->
name|minCompr
operator|=
name|minCompression
expr_stmt|;
name|s
operator|->
name|blocks_in_packet
operator|=
literal|0
expr_stmt|;
return|return
name|deflateReset
argument_list|(
name|strm
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|int
name|deflateReset
parameter_list|(
name|strm
parameter_list|)
name|z_stream
modifier|*
name|strm
decl_stmt|;
block|{
name|deflate_state
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|strm
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|state
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|zalloc
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|zfree
operator|==
name|Z_NULL
operator|||
name|strm
operator|->
name|zalloc_init
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|strm
operator|->
name|total_in
operator|=
name|strm
operator|->
name|total_out
operator|=
literal|0
expr_stmt|;
name|strm
operator|->
name|msg
operator|=
name|Z_NULL
expr_stmt|;
comment|/* use zfree if we ever allocate msg dynamically */
name|strm
operator|->
name|data_type
operator|=
name|Z_UNKNOWN
expr_stmt|;
name|s
operator|=
operator|(
name|deflate_state
operator|*
operator|)
name|strm
operator|->
name|state
expr_stmt|;
name|s
operator|->
name|pending
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|pending_out
operator|=
name|s
operator|->
name|pending_buf
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|noheader
operator|<
literal|0
condition|)
block|{
name|s
operator|->
name|noheader
operator|=
literal|0
expr_stmt|;
comment|/* was set to -1 by deflate(..., Z_FINISH); */
block|}
name|s
operator|->
name|status
operator|=
name|s
operator|->
name|noheader
condition|?
name|BUSY_STATE
else|:
name|INIT_STATE
expr_stmt|;
name|s
operator|->
name|adler
operator|=
literal|1
expr_stmt|;
name|ct_init
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|lm_init
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_comment
comment|/* =========================================================================  * Put a short in the pending buffer. The 16-bit value is put in MSB order.  * IN assertion: the stream state is correct and there is enough room in  * pending_buf.  */
end_comment

begin_function
name|local
name|void
name|putShortMSB
parameter_list|(
name|s
parameter_list|,
name|b
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|uInt
name|b
decl_stmt|;
block|{
name|put_byte
argument_list|(
name|s
argument_list|,
call|(
name|Byte
call|)
argument_list|(
name|b
operator|>>
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|put_byte
argument_list|(
name|s
argument_list|,
call|(
name|Byte
call|)
argument_list|(
name|b
operator|&
literal|0xff
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* =========================================================================  * Flush as much pending output as possible.  */
end_comment

begin_function
name|local
name|void
name|flush_pending
parameter_list|(
name|strm
parameter_list|)
name|z_stream
modifier|*
name|strm
decl_stmt|;
block|{
name|deflate_state
modifier|*
name|state
init|=
operator|(
name|deflate_state
operator|*
operator|)
name|strm
operator|->
name|state
decl_stmt|;
name|unsigned
name|len
init|=
name|state
operator|->
name|pending
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|strm
operator|->
name|avail_out
condition|)
name|len
operator|=
name|strm
operator|->
name|avail_out
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|strm
operator|->
name|next_out
operator|!=
name|NULL
condition|)
block|{
name|zmemcpy
argument_list|(
name|strm
operator|->
name|next_out
argument_list|,
name|state
operator|->
name|pending_out
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strm
operator|->
name|next_out
operator|+=
name|len
expr_stmt|;
block|}
name|state
operator|->
name|pending_out
operator|+=
name|len
expr_stmt|;
name|strm
operator|->
name|total_out
operator|+=
name|len
expr_stmt|;
name|strm
operator|->
name|avail_out
operator|-=
name|len
expr_stmt|;
name|state
operator|->
name|pending
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|state
operator|->
name|pending
operator|==
literal|0
condition|)
block|{
name|state
operator|->
name|pending_out
operator|=
name|state
operator|->
name|pending_buf
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|int
name|deflate
parameter_list|(
name|strm
parameter_list|,
name|flush
parameter_list|)
name|z_stream
modifier|*
name|strm
decl_stmt|;
name|int
name|flush
decl_stmt|;
block|{
name|deflate_state
modifier|*
name|state
init|=
operator|(
name|deflate_state
operator|*
operator|)
name|strm
operator|->
name|state
decl_stmt|;
if|if
condition|(
name|strm
operator|==
name|Z_NULL
operator|||
name|state
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
if|if
condition|(
name|strm
operator|->
name|next_in
operator|==
name|Z_NULL
operator|&&
name|strm
operator|->
name|avail_in
operator|!=
literal|0
condition|)
block|{
name|ERR_RETURN
argument_list|(
name|strm
argument_list|,
name|Z_STREAM_ERROR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strm
operator|->
name|avail_out
operator|==
literal|0
condition|)
name|ERR_RETURN
argument_list|(
name|strm
argument_list|,
name|Z_BUF_ERROR
argument_list|)
expr_stmt|;
name|state
operator|->
name|strm
operator|=
name|strm
expr_stmt|;
comment|/* just in case */
comment|/* Write the zlib header */
if|if
condition|(
name|state
operator|->
name|status
operator|==
name|INIT_STATE
condition|)
block|{
name|uInt
name|header
init|=
operator|(
name|DEFLATED
operator|+
operator|(
operator|(
name|state
operator|->
name|w_bits
operator|-
literal|8
operator|)
operator|<<
literal|4
operator|)
operator|)
operator|<<
literal|8
decl_stmt|;
name|uInt
name|level_flags
init|=
operator|(
name|state
operator|->
name|level
operator|-
literal|1
operator|)
operator|>>
literal|1
decl_stmt|;
if|if
condition|(
name|level_flags
operator|>
literal|3
condition|)
name|level_flags
operator|=
literal|3
expr_stmt|;
name|header
operator||=
operator|(
name|level_flags
operator|<<
literal|6
operator|)
expr_stmt|;
name|header
operator|+=
literal|31
operator|-
operator|(
name|header
operator|%
literal|31
operator|)
expr_stmt|;
name|state
operator|->
name|status
operator|=
name|BUSY_STATE
expr_stmt|;
name|putShortMSB
argument_list|(
name|state
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
comment|/* Flush as much pending output as possible */
if|if
condition|(
name|state
operator|->
name|pending
operator|!=
literal|0
condition|)
block|{
name|flush_pending
argument_list|(
name|strm
argument_list|)
expr_stmt|;
if|if
condition|(
name|strm
operator|->
name|avail_out
operator|==
literal|0
condition|)
return|return
name|Z_OK
return|;
block|}
comment|/* If we came back in here to get the last output from      * a previous flush, we're done for now.      */
if|if
condition|(
name|state
operator|->
name|status
operator|==
name|FLUSH_STATE
condition|)
block|{
name|state
operator|->
name|status
operator|=
name|BUSY_STATE
expr_stmt|;
if|if
condition|(
name|flush
operator|!=
name|Z_NO_FLUSH
operator|&&
name|flush
operator|!=
name|Z_FINISH
condition|)
return|return
name|Z_OK
return|;
block|}
comment|/* User must not provide more input after the first FINISH: */
if|if
condition|(
name|state
operator|->
name|status
operator|==
name|FINISH_STATE
operator|&&
name|strm
operator|->
name|avail_in
operator|!=
literal|0
condition|)
block|{
name|ERR_RETURN
argument_list|(
name|strm
argument_list|,
name|Z_BUF_ERROR
argument_list|)
expr_stmt|;
block|}
comment|/* Start a new block or continue the current one.      */
if|if
condition|(
name|strm
operator|->
name|avail_in
operator|!=
literal|0
operator|||
name|state
operator|->
name|lookahead
operator|!=
literal|0
operator|||
operator|(
name|flush
operator|==
name|Z_FINISH
operator|&&
name|state
operator|->
name|status
operator|!=
name|FINISH_STATE
operator|)
condition|)
block|{
name|int
name|quit
decl_stmt|;
if|if
condition|(
name|flush
operator|==
name|Z_FINISH
condition|)
block|{
name|state
operator|->
name|status
operator|=
name|FINISH_STATE
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|->
name|level
operator|<=
literal|3
condition|)
block|{
name|quit
operator|=
name|deflate_fast
argument_list|(
name|state
argument_list|,
name|flush
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|quit
operator|=
name|deflate_slow
argument_list|(
name|state
argument_list|,
name|flush
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|quit
operator|||
name|strm
operator|->
name|avail_out
operator|==
literal|0
condition|)
return|return
name|Z_OK
return|;
comment|/* If flush != Z_NO_FLUSH&& avail_out == 0, the next call          * of deflate should use the same flush parameter to make sure          * that the flush is complete. So we don't have to output an          * empty block here, this will be done at next call. This also          * ensures that for a very small output buffer, we emit at most          * one empty block.          */
block|}
comment|/* If a flush was requested, we have a little more to output now. */
if|if
condition|(
name|flush
operator|!=
name|Z_NO_FLUSH
operator|&&
name|flush
operator|!=
name|Z_FINISH
operator|&&
name|state
operator|->
name|status
operator|!=
name|FINISH_STATE
condition|)
block|{
switch|switch
condition|(
name|flush
condition|)
block|{
case|case
name|Z_PARTIAL_FLUSH
case|:
name|ct_align
argument_list|(
name|state
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_PACKET_FLUSH
case|:
comment|/* Output just the 3-bit `stored' block type value, 	       but not a zero length. */
name|ct_stored_type_only
argument_list|(
name|state
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ct_stored_block
argument_list|(
name|state
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* For a full flush, this empty block will be recognized 	     * as a special marker by inflate_sync(). 	     */
if|if
condition|(
name|flush
operator|==
name|Z_FULL_FLUSH
condition|)
block|{
name|CLEAR_HASH
argument_list|(
name|state
argument_list|)
expr_stmt|;
comment|/* forget history */
block|}
block|}
name|flush_pending
argument_list|(
name|strm
argument_list|)
expr_stmt|;
if|if
condition|(
name|strm
operator|->
name|avail_out
operator|==
literal|0
condition|)
block|{
comment|/* We'll have to come back to get the rest of the output; 	     * this ensures we don't output a second zero-length stored 	     * block (or whatever). 	     */
name|state
operator|->
name|status
operator|=
name|FLUSH_STATE
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
block|}
name|Assert
argument_list|(
name|strm
operator|->
name|avail_out
operator|>
literal|0
argument_list|,
literal|"bug2"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flush
operator|!=
name|Z_FINISH
condition|)
return|return
name|Z_OK
return|;
if|if
condition|(
name|state
operator|->
name|noheader
condition|)
return|return
name|Z_STREAM_END
return|;
comment|/* Write the zlib trailer (adler32) */
name|putShortMSB
argument_list|(
name|state
argument_list|,
call|(
name|uInt
call|)
argument_list|(
name|state
operator|->
name|adler
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|putShortMSB
argument_list|(
name|state
argument_list|,
call|(
name|uInt
call|)
argument_list|(
name|state
operator|->
name|adler
operator|&
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
name|flush_pending
argument_list|(
name|strm
argument_list|)
expr_stmt|;
comment|/* If avail_out is zero, the application will call deflate again      * to flush the rest.      */
name|state
operator|->
name|noheader
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* write the trailer only once! */
return|return
name|state
operator|->
name|pending
operator|!=
literal|0
condition|?
name|Z_OK
else|:
name|Z_STREAM_END
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|int
name|deflateEnd
parameter_list|(
name|strm
parameter_list|)
name|z_stream
modifier|*
name|strm
decl_stmt|;
block|{
name|deflate_state
modifier|*
name|state
init|=
operator|(
name|deflate_state
operator|*
operator|)
name|strm
operator|->
name|state
decl_stmt|;
if|if
condition|(
name|strm
operator|==
name|Z_NULL
operator|||
name|state
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|TRY_FREE
argument_list|(
name|strm
argument_list|,
name|state
operator|->
name|window
argument_list|,
name|state
operator|->
name|w_size
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|Byte
argument_list|)
argument_list|)
expr_stmt|;
name|TRY_FREE
argument_list|(
name|strm
argument_list|,
name|state
operator|->
name|prev
argument_list|,
name|state
operator|->
name|w_size
operator|*
sizeof|sizeof
argument_list|(
name|Pos
argument_list|)
argument_list|)
expr_stmt|;
name|TRY_FREE
argument_list|(
name|strm
argument_list|,
name|state
operator|->
name|head
argument_list|,
name|state
operator|->
name|hash_size
operator|*
sizeof|sizeof
argument_list|(
name|Pos
argument_list|)
argument_list|)
expr_stmt|;
name|TRY_FREE
argument_list|(
name|strm
argument_list|,
name|state
operator|->
name|pending_buf
argument_list|,
name|state
operator|->
name|lit_bufsize
operator|*
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|ush
argument_list|)
argument_list|)
expr_stmt|;
name|ZFREE
argument_list|(
name|strm
argument_list|,
name|state
argument_list|,
sizeof|sizeof
argument_list|(
name|deflate_state
argument_list|)
argument_list|)
expr_stmt|;
name|strm
operator|->
name|state
operator|=
name|Z_NULL
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Read a new buffer from the current input stream, update the adler32  * and total number of bytes read.  */
end_comment

begin_function
name|local
name|int
name|read_buf
parameter_list|(
name|strm
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
name|z_stream
modifier|*
name|strm
decl_stmt|;
name|charf
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|size
decl_stmt|;
block|{
name|unsigned
name|len
init|=
name|strm
operator|->
name|avail_in
decl_stmt|;
name|deflate_state
modifier|*
name|state
init|=
operator|(
name|deflate_state
operator|*
operator|)
name|strm
operator|->
name|state
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|size
condition|)
name|len
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|strm
operator|->
name|avail_in
operator|-=
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|->
name|noheader
condition|)
block|{
name|state
operator|->
name|adler
operator|=
name|adler32
argument_list|(
name|state
operator|->
name|adler
argument_list|,
name|strm
operator|->
name|next_in
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|zmemcpy
argument_list|(
name|buf
argument_list|,
name|strm
operator|->
name|next_in
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strm
operator|->
name|next_in
operator|+=
name|len
expr_stmt|;
name|strm
operator|->
name|total_in
operator|+=
name|len
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|len
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Initialize the "longest match" routines for a new zlib stream  */
end_comment

begin_function
name|local
name|void
name|lm_init
parameter_list|(
name|s
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
block|{
name|s
operator|->
name|window_size
operator|=
operator|(
name|ulg
operator|)
literal|2L
operator|*
name|s
operator|->
name|w_size
expr_stmt|;
name|CLEAR_HASH
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Set the default configuration parameters:      */
name|s
operator|->
name|max_lazy_match
operator|=
name|configuration_table
index|[
name|s
operator|->
name|level
index|]
operator|.
name|max_lazy
expr_stmt|;
name|s
operator|->
name|good_match
operator|=
name|configuration_table
index|[
name|s
operator|->
name|level
index|]
operator|.
name|good_length
expr_stmt|;
name|s
operator|->
name|nice_match
operator|=
name|configuration_table
index|[
name|s
operator|->
name|level
index|]
operator|.
name|nice_length
expr_stmt|;
name|s
operator|->
name|max_chain_length
operator|=
name|configuration_table
index|[
name|s
operator|->
name|level
index|]
operator|.
name|max_chain
expr_stmt|;
name|s
operator|->
name|strstart
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|block_start
operator|=
literal|0L
expr_stmt|;
name|s
operator|->
name|lookahead
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|match_length
operator|=
name|MIN_MATCH
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|match_available
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|ins_h
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ASMV
name|match_init
argument_list|()
expr_stmt|;
comment|/* initialize the asm code */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Set match_start to the longest match starting at the given string and  * return its length. Matches shorter or equal to prev_length are discarded,  * in which case the result is equal to prev_length and match_start is  * garbage.  * IN assertions: cur_match is the head of the hash chain for the current  *   string (strstart) and its distance is<= MAX_DIST, and prev_length>= 1  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ASMV
end_ifndef

begin_comment
comment|/* For 80x86 and 680x0, an optimized version will be provided in match.asm or  * match.S. The code will be functionally equivalent.  */
end_comment

begin_function
name|local
name|int
name|longest_match
parameter_list|(
name|s
parameter_list|,
name|cur_match
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|IPos
name|cur_match
decl_stmt|;
comment|/* current match */
block|{
name|unsigned
name|chain_length
init|=
name|s
operator|->
name|max_chain_length
decl_stmt|;
comment|/* max hash chain length */
specifier|register
name|Bytef
modifier|*
name|scan
init|=
name|s
operator|->
name|window
operator|+
name|s
operator|->
name|strstart
decl_stmt|;
comment|/* current string */
specifier|register
name|Bytef
modifier|*
name|match
decl_stmt|;
comment|/* matched string */
specifier|register
name|int
name|len
decl_stmt|;
comment|/* length of current match */
name|int
name|best_len
init|=
name|s
operator|->
name|prev_length
decl_stmt|;
comment|/* best match length so far */
name|IPos
name|limit
init|=
name|s
operator|->
name|strstart
operator|>
operator|(
name|IPos
operator|)
name|MAX_DIST
argument_list|(
name|s
argument_list|)
condition|?
name|s
operator|->
name|strstart
operator|-
operator|(
name|IPos
operator|)
name|MAX_DIST
argument_list|(
name|s
argument_list|)
else|:
name|NIL
decl_stmt|;
comment|/* Stop when cur_match becomes<= limit. To simplify the code,      * we prevent matches with the string of window index 0.      */
name|Posf
modifier|*
name|prev
init|=
name|s
operator|->
name|prev
decl_stmt|;
name|uInt
name|wmask
init|=
name|s
operator|->
name|w_mask
decl_stmt|;
ifdef|#
directive|ifdef
name|UNALIGNED_OK
comment|/* Compare two bytes at a time. Note: this is not always beneficial.      * Try with and without -DUNALIGNED_OK to check.      */
specifier|register
name|Bytef
modifier|*
name|strend
init|=
name|s
operator|->
name|window
operator|+
name|s
operator|->
name|strstart
operator|+
name|MAX_MATCH
operator|-
literal|1
decl_stmt|;
specifier|register
name|ush
name|scan_start
init|=
operator|*
operator|(
name|ushf
operator|*
operator|)
name|scan
decl_stmt|;
specifier|register
name|ush
name|scan_end
init|=
operator|*
operator|(
name|ushf
operator|*
operator|)
operator|(
name|scan
operator|+
name|best_len
operator|-
literal|1
operator|)
decl_stmt|;
else|#
directive|else
specifier|register
name|Bytef
modifier|*
name|strend
init|=
name|s
operator|->
name|window
operator|+
name|s
operator|->
name|strstart
operator|+
name|MAX_MATCH
decl_stmt|;
specifier|register
name|Byte
name|scan_end1
init|=
name|scan
index|[
name|best_len
operator|-
literal|1
index|]
decl_stmt|;
specifier|register
name|Byte
name|scan_end
init|=
name|scan
index|[
name|best_len
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* The code is optimized for HASH_BITS>= 8 and MAX_MATCH-2 multiple of 16.      * It is easy to get rid of this optimization if necessary.      */
name|Assert
argument_list|(
name|s
operator|->
name|hash_bits
operator|>=
literal|8
operator|&&
name|MAX_MATCH
operator|==
literal|258
argument_list|,
literal|"Code too clever"
argument_list|)
expr_stmt|;
comment|/* Do not waste too much time if we already have a good match: */
if|if
condition|(
name|s
operator|->
name|prev_length
operator|>=
name|s
operator|->
name|good_match
condition|)
block|{
name|chain_length
operator|>>=
literal|2
expr_stmt|;
block|}
name|Assert
argument_list|(
operator|(
name|ulg
operator|)
name|s
operator|->
name|strstart
operator|<=
name|s
operator|->
name|window_size
operator|-
name|MIN_LOOKAHEAD
argument_list|,
literal|"need lookahead"
argument_list|)
expr_stmt|;
do|do
block|{
name|Assert
argument_list|(
name|cur_match
operator|<
name|s
operator|->
name|strstart
argument_list|,
literal|"no future"
argument_list|)
expr_stmt|;
name|match
operator|=
name|s
operator|->
name|window
operator|+
name|cur_match
expr_stmt|;
comment|/* Skip to next match if the match length cannot increase          * or if the match length is less than 2:          */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|UNALIGNED_OK
argument_list|)
operator|&&
name|MAX_MATCH
operator|==
literal|258
operator|)
comment|/* This code assumes sizeof(unsigned short) == 2. Do not use          * UNALIGNED_OK if your compiler uses a different size.          */
if|if
condition|(
operator|*
operator|(
name|ushf
operator|*
operator|)
operator|(
name|match
operator|+
name|best_len
operator|-
literal|1
operator|)
operator|!=
name|scan_end
operator|||
operator|*
operator|(
name|ushf
operator|*
operator|)
name|match
operator|!=
name|scan_start
condition|)
continue|continue;
comment|/* It is not necessary to compare scan[2] and match[2] since they are          * always equal when the other bytes match, given that the hash keys          * are equal and that HASH_BITS>= 8. Compare 2 bytes at a time at          * strstart+3, +5, ... up to strstart+257. We check for insufficient          * lookahead only every 4th comparison; the 128th check will be made          * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is          * necessary to put more guard bytes at the end of the window, or          * to check more often for insufficient lookahead.          */
name|Assert
argument_list|(
name|scan
index|[
literal|2
index|]
operator|==
name|match
index|[
literal|2
index|]
argument_list|,
literal|"scan[2]?"
argument_list|)
expr_stmt|;
name|scan
operator|++
operator|,
name|match
operator|++
expr_stmt|;
do|do
block|{         }
do|while
condition|(
operator|*
operator|(
name|ushf
operator|*
operator|)
operator|(
name|scan
operator|+=
literal|2
operator|)
operator|==
operator|*
operator|(
name|ushf
operator|*
operator|)
operator|(
name|match
operator|+=
literal|2
operator|)
operator|&&
operator|*
operator|(
name|ushf
operator|*
operator|)
operator|(
name|scan
operator|+=
literal|2
operator|)
operator|==
operator|*
operator|(
name|ushf
operator|*
operator|)
operator|(
name|match
operator|+=
literal|2
operator|)
operator|&&
operator|*
operator|(
name|ushf
operator|*
operator|)
operator|(
name|scan
operator|+=
literal|2
operator|)
operator|==
operator|*
operator|(
name|ushf
operator|*
operator|)
operator|(
name|match
operator|+=
literal|2
operator|)
operator|&&
operator|*
operator|(
name|ushf
operator|*
operator|)
operator|(
name|scan
operator|+=
literal|2
operator|)
operator|==
operator|*
operator|(
name|ushf
operator|*
operator|)
operator|(
name|match
operator|+=
literal|2
operator|)
operator|&&
name|scan
operator|<
name|strend
condition|)
do|;
comment|/* The funny "do {}" generates better code on most compilers */
comment|/* Here, scan<= window+strstart+257 */
name|Assert
argument_list|(
name|scan
operator|<=
name|s
operator|->
name|window
operator|+
call|(
name|unsigned
call|)
argument_list|(
name|s
operator|->
name|window_size
operator|-
literal|1
argument_list|)
argument_list|,
literal|"wild scan"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|scan
operator|==
operator|*
name|match
condition|)
name|scan
operator|++
expr_stmt|;
name|len
operator|=
operator|(
name|MAX_MATCH
operator|-
literal|1
operator|)
operator|-
call|(
name|int
call|)
argument_list|(
name|strend
operator|-
name|scan
argument_list|)
expr_stmt|;
name|scan
operator|=
name|strend
operator|-
operator|(
name|MAX_MATCH
operator|-
literal|1
operator|)
expr_stmt|;
else|#
directive|else
comment|/* UNALIGNED_OK */
if|if
condition|(
name|match
index|[
name|best_len
index|]
operator|!=
name|scan_end
operator|||
name|match
index|[
name|best_len
operator|-
literal|1
index|]
operator|!=
name|scan_end1
operator|||
operator|*
name|match
operator|!=
operator|*
name|scan
operator|||
operator|*
operator|++
name|match
operator|!=
name|scan
index|[
literal|1
index|]
condition|)
continue|continue;
comment|/* The check at best_len-1 can be removed because it will be made          * again later. (This heuristic is not always a win.)          * It is not necessary to compare scan[2] and match[2] since they          * are always equal when the other bytes match, given that          * the hash keys are equal and that HASH_BITS>= 8.          */
name|scan
operator|+=
literal|2
operator|,
name|match
operator|++
expr_stmt|;
name|Assert
argument_list|(
operator|*
name|scan
operator|==
operator|*
name|match
argument_list|,
literal|"match[2]?"
argument_list|)
expr_stmt|;
comment|/* We check for insufficient lookahead only every 8th comparison;          * the 256th check will be made at strstart+258.          */
do|do
block|{         }
do|while
condition|(
operator|*
operator|++
name|scan
operator|==
operator|*
operator|++
name|match
operator|&&
operator|*
operator|++
name|scan
operator|==
operator|*
operator|++
name|match
operator|&&
operator|*
operator|++
name|scan
operator|==
operator|*
operator|++
name|match
operator|&&
operator|*
operator|++
name|scan
operator|==
operator|*
operator|++
name|match
operator|&&
operator|*
operator|++
name|scan
operator|==
operator|*
operator|++
name|match
operator|&&
operator|*
operator|++
name|scan
operator|==
operator|*
operator|++
name|match
operator|&&
operator|*
operator|++
name|scan
operator|==
operator|*
operator|++
name|match
operator|&&
operator|*
operator|++
name|scan
operator|==
operator|*
operator|++
name|match
operator|&&
name|scan
operator|<
name|strend
condition|)
do|;
name|Assert
argument_list|(
name|scan
operator|<=
name|s
operator|->
name|window
operator|+
call|(
name|unsigned
call|)
argument_list|(
name|s
operator|->
name|window_size
operator|-
literal|1
argument_list|)
argument_list|,
literal|"wild scan"
argument_list|)
expr_stmt|;
name|len
operator|=
name|MAX_MATCH
operator|-
call|(
name|int
call|)
argument_list|(
name|strend
operator|-
name|scan
argument_list|)
expr_stmt|;
name|scan
operator|=
name|strend
operator|-
name|MAX_MATCH
expr_stmt|;
endif|#
directive|endif
comment|/* UNALIGNED_OK */
if|if
condition|(
name|len
operator|>
name|best_len
condition|)
block|{
name|s
operator|->
name|match_start
operator|=
name|cur_match
expr_stmt|;
name|best_len
operator|=
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|s
operator|->
name|nice_match
condition|)
break|break;
ifdef|#
directive|ifdef
name|UNALIGNED_OK
name|scan_end
operator|=
operator|*
operator|(
name|ushf
operator|*
operator|)
operator|(
name|scan
operator|+
name|best_len
operator|-
literal|1
operator|)
expr_stmt|;
else|#
directive|else
name|scan_end1
operator|=
name|scan
index|[
name|best_len
operator|-
literal|1
index|]
expr_stmt|;
name|scan_end
operator|=
name|scan
index|[
name|best_len
index|]
expr_stmt|;
endif|#
directive|endif
block|}
block|}
do|while
condition|(
operator|(
name|cur_match
operator|=
name|prev
index|[
name|cur_match
operator|&
name|wmask
index|]
operator|)
operator|>
name|limit
operator|&&
operator|--
name|chain_length
operator|!=
literal|0
condition|)
do|;
return|return
name|best_len
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ASMV */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_ZLIB
end_ifdef

begin_comment
comment|/* ===========================================================================  * Check that the match at match_start is indeed a match.  */
end_comment

begin_function
name|local
name|void
name|check_match
parameter_list|(
name|s
parameter_list|,
name|start
parameter_list|,
name|match
parameter_list|,
name|length
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|IPos
name|start
decl_stmt|,
name|match
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
comment|/* check that the match is indeed a match */
if|if
condition|(
name|memcmp
argument_list|(
operator|(
name|charf
operator|*
operator|)
name|s
operator|->
name|window
operator|+
name|match
argument_list|,
operator|(
name|charf
operator|*
operator|)
name|s
operator|->
name|window
operator|+
name|start
argument_list|,
name|length
argument_list|)
operator|!=
name|EQUAL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" start %u, match %u, length %d\n"
argument_list|,
name|start
argument_list|,
name|match
argument_list|,
name|length
argument_list|)
expr_stmt|;
do|do
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c%c"
argument_list|,
name|s
operator|->
name|window
index|[
name|match
operator|++
index|]
argument_list|,
name|s
operator|->
name|window
index|[
name|start
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|length
operator|!=
literal|0
condition|)
do|;
name|z_error
argument_list|(
literal|"invalid match"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|verbose
operator|>
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\\[%d,%d]"
argument_list|,
name|start
operator|-
name|match
argument_list|,
name|length
argument_list|)
expr_stmt|;
do|do
block|{
name|putc
argument_list|(
name|s
operator|->
name|window
index|[
name|start
operator|++
index|]
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|length
operator|!=
literal|0
condition|)
do|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|check_match
parameter_list|(
name|s
parameter_list|,
name|start
parameter_list|,
name|match
parameter_list|,
name|length
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ===========================================================================  * Fill the window when the lookahead becomes insufficient.  * Updates strstart and lookahead.  *  * IN assertion: lookahead< MIN_LOOKAHEAD  * OUT assertions: strstart<= window_size-MIN_LOOKAHEAD  *    At least one byte has been read, or avail_in == 0; reads are  *    performed for at least two bytes (required for the zip translate_eol  *    option -- not supported here).  */
end_comment

begin_function
name|local
name|void
name|fill_window
parameter_list|(
name|s
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|unsigned
name|n
decl_stmt|,
name|m
decl_stmt|;
specifier|register
name|Posf
modifier|*
name|p
decl_stmt|;
name|unsigned
name|more
decl_stmt|;
comment|/* Amount of free space at the end of the window. */
name|uInt
name|wsize
init|=
name|s
operator|->
name|w_size
decl_stmt|;
do|do
block|{
name|more
operator|=
call|(
name|unsigned
call|)
argument_list|(
name|s
operator|->
name|window_size
operator|-
operator|(
name|ulg
operator|)
name|s
operator|->
name|lookahead
operator|-
operator|(
name|ulg
operator|)
name|s
operator|->
name|strstart
argument_list|)
expr_stmt|;
comment|/* Deal with !@#$% 64K limit: */
if|if
condition|(
name|more
operator|==
literal|0
operator|&&
name|s
operator|->
name|strstart
operator|==
literal|0
operator|&&
name|s
operator|->
name|lookahead
operator|==
literal|0
condition|)
block|{
name|more
operator|=
name|wsize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|more
operator|==
call|(
name|unsigned
call|)
argument_list|(
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* Very unlikely, but possible on 16 bit machine if strstart == 0              * and lookahead == 1 (input done one byte at time)              */
name|more
operator|--
expr_stmt|;
comment|/* If the window is almost full and there is insufficient lookahead,          * move the upper half to the lower one to make room in the upper half.          */
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|strstart
operator|>=
name|wsize
operator|+
name|MAX_DIST
argument_list|(
name|s
argument_list|)
condition|)
block|{
comment|/* By the IN assertion, the window is not empty so we can't confuse              * more == 0 with more == 64K on a 16 bit machine.              */
name|zmemcpy
argument_list|(
operator|(
name|charf
operator|*
operator|)
name|s
operator|->
name|window
argument_list|,
operator|(
name|charf
operator|*
operator|)
name|s
operator|->
name|window
operator|+
name|wsize
argument_list|,
operator|(
name|unsigned
operator|)
name|wsize
argument_list|)
expr_stmt|;
name|s
operator|->
name|match_start
operator|-=
name|wsize
expr_stmt|;
name|s
operator|->
name|strstart
operator|-=
name|wsize
expr_stmt|;
comment|/* we now have strstart>= MAX_DIST */
name|s
operator|->
name|block_start
operator|-=
operator|(
name|long
operator|)
name|wsize
expr_stmt|;
comment|/* Slide the hash table (could be avoided with 32 bit values                at the expense of memory usage):              */
name|n
operator|=
name|s
operator|->
name|hash_size
expr_stmt|;
name|p
operator|=
operator|&
name|s
operator|->
name|head
index|[
name|n
index|]
expr_stmt|;
do|do
block|{
name|m
operator|=
operator|*
operator|--
name|p
expr_stmt|;
operator|*
name|p
operator|=
call|(
name|Pos
call|)
argument_list|(
name|m
operator|>=
name|wsize
condition|?
name|m
operator|-
name|wsize
else|:
name|NIL
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
condition|)
do|;
name|n
operator|=
name|wsize
expr_stmt|;
name|p
operator|=
operator|&
name|s
operator|->
name|prev
index|[
name|n
index|]
expr_stmt|;
do|do
block|{
name|m
operator|=
operator|*
operator|--
name|p
expr_stmt|;
operator|*
name|p
operator|=
call|(
name|Pos
call|)
argument_list|(
name|m
operator|>=
name|wsize
condition|?
name|m
operator|-
name|wsize
else|:
name|NIL
argument_list|)
expr_stmt|;
comment|/* If n is not on any hash chain, prev[n] is garbage but                  * its value will never be used.                  */
block|}
do|while
condition|(
operator|--
name|n
condition|)
do|;
name|more
operator|+=
name|wsize
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|strm
operator|->
name|avail_in
operator|==
literal|0
condition|)
return|return;
comment|/* If there was no sliding:          *    strstart<= WSIZE+MAX_DIST-1&& lookahead<= MIN_LOOKAHEAD - 1&&          *    more == window_size - lookahead - strstart          * => more>= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)          * => more>= window_size - 2*WSIZE + 2          * In the BIG_MEM or MMAP case (not yet supported),          *   window_size == input_size + MIN_LOOKAHEAD&&          *   strstart + s->lookahead<= input_size => more>= MIN_LOOKAHEAD.          * Otherwise, window_size == 2*WSIZE so more>= 2.          * If there was sliding, more>= WSIZE. So in all cases, more>= 2.          */
name|Assert
argument_list|(
name|more
operator|>=
literal|2
argument_list|,
literal|"more< 2"
argument_list|)
expr_stmt|;
name|n
operator|=
name|read_buf
argument_list|(
name|s
operator|->
name|strm
argument_list|,
operator|(
name|charf
operator|*
operator|)
name|s
operator|->
name|window
operator|+
name|s
operator|->
name|strstart
operator|+
name|s
operator|->
name|lookahead
argument_list|,
name|more
argument_list|)
expr_stmt|;
name|s
operator|->
name|lookahead
operator|+=
name|n
expr_stmt|;
comment|/* Initialize the hash value now that we have some input: */
if|if
condition|(
name|s
operator|->
name|lookahead
operator|>=
name|MIN_MATCH
condition|)
block|{
name|s
operator|->
name|ins_h
operator|=
name|s
operator|->
name|window
index|[
name|s
operator|->
name|strstart
index|]
expr_stmt|;
name|UPDATE_HASH
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|ins_h
argument_list|,
name|s
operator|->
name|window
index|[
name|s
operator|->
name|strstart
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|MIN_MATCH
operator|!=
literal|3
name|Call
name|UPDATE_HASH
argument_list|()
name|MIN_MATCH
operator|-
literal|3
name|more
name|times
endif|#
directive|endif
block|}
comment|/* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,          * but this is not important since only literal bytes will be emitted.          */
block|}
do|while
condition|(
name|s
operator|->
name|lookahead
operator|<
name|MIN_LOOKAHEAD
operator|&&
name|s
operator|->
name|strm
operator|->
name|avail_in
operator|!=
literal|0
condition|)
do|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Flush the current block, with given end-of-file flag.  * IN assertion: strstart is set to the end of the current match.  */
end_comment

begin_define
define|#
directive|define
name|FLUSH_BLOCK_ONLY
parameter_list|(
name|s
parameter_list|,
name|flush
parameter_list|)
value|{ \    ct_flush_block(s, (s->block_start>= 0L ? \            (charf *)&s->window[(unsigned)s->block_start] : \            (charf *)Z_NULL), (long)s->strstart - s->block_start, (flush)); \    s->block_start = s->strstart; \    flush_pending(s->strm); \    Tracev((stderr,"[FLUSH]")); \ }
end_define

begin_comment
comment|/* Same but force premature exit if necessary. */
end_comment

begin_define
define|#
directive|define
name|FLUSH_BLOCK
parameter_list|(
name|s
parameter_list|,
name|flush
parameter_list|)
value|{ \    FLUSH_BLOCK_ONLY(s, flush); \    if (s->strm->avail_out == 0) return 1; \ }
end_define

begin_comment
comment|/* ===========================================================================  * Compress as much as possible from the input stream, return true if  * processing was terminated prematurely (no more input or output space).  * This function does not perform lazy evaluationof matches and inserts  * new strings in the dictionary only for unmatched strings or for short  * matches. It is used only for the fast compression options.  */
end_comment

begin_function
name|local
name|int
name|deflate_fast
parameter_list|(
name|s
parameter_list|,
name|flush
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|int
name|flush
decl_stmt|;
block|{
name|IPos
name|hash_head
init|=
name|NIL
decl_stmt|;
comment|/* head of the hash chain */
name|int
name|bflush
decl_stmt|;
comment|/* set if current block must be flushed */
name|s
operator|->
name|prev_length
operator|=
name|MIN_MATCH
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Make sure that we always have enough lookahead, except          * at the end of the input file. We need MAX_MATCH bytes          * for the next match, plus MIN_MATCH bytes to insert the          * string following the next match.          */
if|if
condition|(
name|s
operator|->
name|lookahead
operator|<
name|MIN_LOOKAHEAD
condition|)
block|{
name|fill_window
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|lookahead
operator|<
name|MIN_LOOKAHEAD
operator|&&
name|flush
operator|==
name|Z_NO_FLUSH
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|s
operator|->
name|lookahead
operator|==
literal|0
condition|)
break|break;
comment|/* flush the current block */
block|}
comment|/* Insert the string window[strstart .. strstart+2] in the          * dictionary, and set hash_head to the head of the hash chain:          */
if|if
condition|(
name|s
operator|->
name|lookahead
operator|>=
name|MIN_MATCH
condition|)
block|{
name|INSERT_STRING
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|strstart
argument_list|,
name|hash_head
argument_list|)
expr_stmt|;
block|}
comment|/* Find the longest match, discarding those<= prev_length.          * At this point we have always match_length< MIN_MATCH          */
if|if
condition|(
name|hash_head
operator|!=
name|NIL
operator|&&
name|s
operator|->
name|strstart
operator|-
name|hash_head
operator|<=
name|MAX_DIST
argument_list|(
name|s
argument_list|)
condition|)
block|{
comment|/* To simplify the code, we prevent matches with the string              * of window index 0 (in particular we have to avoid a match              * of the string with itself at the start of the input file).              */
if|if
condition|(
name|s
operator|->
name|strategy
operator|!=
name|Z_HUFFMAN_ONLY
condition|)
block|{
name|s
operator|->
name|match_length
operator|=
name|longest_match
argument_list|(
name|s
argument_list|,
name|hash_head
argument_list|)
expr_stmt|;
block|}
comment|/* longest_match() sets match_start */
if|if
condition|(
name|s
operator|->
name|match_length
operator|>
name|s
operator|->
name|lookahead
condition|)
name|s
operator|->
name|match_length
operator|=
name|s
operator|->
name|lookahead
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|->
name|match_length
operator|>=
name|MIN_MATCH
condition|)
block|{
name|check_match
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|strstart
argument_list|,
name|s
operator|->
name|match_start
argument_list|,
name|s
operator|->
name|match_length
argument_list|)
expr_stmt|;
name|bflush
operator|=
name|ct_tally
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|strstart
operator|-
name|s
operator|->
name|match_start
argument_list|,
name|s
operator|->
name|match_length
operator|-
name|MIN_MATCH
argument_list|)
expr_stmt|;
name|s
operator|->
name|lookahead
operator|-=
name|s
operator|->
name|match_length
expr_stmt|;
comment|/* Insert new strings in the hash table only if the match length              * is not too large. This saves time but degrades compression.              */
if|if
condition|(
name|s
operator|->
name|match_length
operator|<=
name|s
operator|->
name|max_insert_length
operator|&&
name|s
operator|->
name|lookahead
operator|>=
name|MIN_MATCH
condition|)
block|{
name|s
operator|->
name|match_length
operator|--
expr_stmt|;
comment|/* string at strstart already in hash table */
do|do
block|{
name|s
operator|->
name|strstart
operator|++
expr_stmt|;
name|INSERT_STRING
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|strstart
argument_list|,
name|hash_head
argument_list|)
expr_stmt|;
comment|/* strstart never exceeds WSIZE-MAX_MATCH, so there are                      * always MIN_MATCH bytes ahead.                      */
block|}
do|while
condition|(
operator|--
name|s
operator|->
name|match_length
operator|!=
literal|0
condition|)
do|;
name|s
operator|->
name|strstart
operator|++
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|strstart
operator|+=
name|s
operator|->
name|match_length
expr_stmt|;
name|s
operator|->
name|match_length
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|ins_h
operator|=
name|s
operator|->
name|window
index|[
name|s
operator|->
name|strstart
index|]
expr_stmt|;
name|UPDATE_HASH
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|ins_h
argument_list|,
name|s
operator|->
name|window
index|[
name|s
operator|->
name|strstart
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|#
directive|if
name|MIN_MATCH
operator|!=
literal|3
name|Call
name|UPDATE_HASH
argument_list|()
name|MIN_MATCH
operator|-
literal|3
name|more
name|times
endif|#
directive|endif
comment|/* If lookahead< MIN_MATCH, ins_h is garbage, but it does not                  * matter since it will be recomputed at next deflate call.                  */
block|}
block|}
else|else
block|{
comment|/* No match, output a literal byte */
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"%c"
operator|,
name|s
operator|->
name|window
index|[
name|s
operator|->
name|strstart
index|]
operator|)
argument_list|)
expr_stmt|;
name|bflush
operator|=
name|ct_tally
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|window
index|[
name|s
operator|->
name|strstart
index|]
argument_list|)
expr_stmt|;
name|s
operator|->
name|lookahead
operator|--
expr_stmt|;
name|s
operator|->
name|strstart
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|bflush
condition|)
name|FLUSH_BLOCK
argument_list|(
name|s
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
block|}
name|FLUSH_BLOCK
argument_list|(
name|s
argument_list|,
name|flush
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* normal exit */
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Same as above, but achieves better compression. We use a lazy  * evaluation for matches: a match is finally adopted only if there is  * no better match at the next window position.  */
end_comment

begin_function
name|local
name|int
name|deflate_slow
parameter_list|(
name|s
parameter_list|,
name|flush
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|int
name|flush
decl_stmt|;
block|{
name|IPos
name|hash_head
init|=
name|NIL
decl_stmt|;
comment|/* head of hash chain */
name|int
name|bflush
decl_stmt|;
comment|/* set if current block must be flushed */
comment|/* Process the input block. */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Make sure that we always have enough lookahead, except          * at the end of the input file. We need MAX_MATCH bytes          * for the next match, plus MIN_MATCH bytes to insert the          * string following the next match.          */
if|if
condition|(
name|s
operator|->
name|lookahead
operator|<
name|MIN_LOOKAHEAD
condition|)
block|{
name|fill_window
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|lookahead
operator|<
name|MIN_LOOKAHEAD
operator|&&
name|flush
operator|==
name|Z_NO_FLUSH
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|s
operator|->
name|lookahead
operator|==
literal|0
condition|)
break|break;
comment|/* flush the current block */
block|}
comment|/* Insert the string window[strstart .. strstart+2] in the          * dictionary, and set hash_head to the head of the hash chain:          */
if|if
condition|(
name|s
operator|->
name|lookahead
operator|>=
name|MIN_MATCH
condition|)
block|{
name|INSERT_STRING
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|strstart
argument_list|,
name|hash_head
argument_list|)
expr_stmt|;
block|}
comment|/* Find the longest match, discarding those<= prev_length.          */
name|s
operator|->
name|prev_length
operator|=
name|s
operator|->
name|match_length
operator|,
name|s
operator|->
name|prev_match
operator|=
name|s
operator|->
name|match_start
expr_stmt|;
name|s
operator|->
name|match_length
operator|=
name|MIN_MATCH
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|hash_head
operator|!=
name|NIL
operator|&&
name|s
operator|->
name|prev_length
operator|<
name|s
operator|->
name|max_lazy_match
operator|&&
name|s
operator|->
name|strstart
operator|-
name|hash_head
operator|<=
name|MAX_DIST
argument_list|(
name|s
argument_list|)
condition|)
block|{
comment|/* To simplify the code, we prevent matches with the string              * of window index 0 (in particular we have to avoid a match              * of the string with itself at the start of the input file).              */
if|if
condition|(
name|s
operator|->
name|strategy
operator|!=
name|Z_HUFFMAN_ONLY
condition|)
block|{
name|s
operator|->
name|match_length
operator|=
name|longest_match
argument_list|(
name|s
argument_list|,
name|hash_head
argument_list|)
expr_stmt|;
block|}
comment|/* longest_match() sets match_start */
if|if
condition|(
name|s
operator|->
name|match_length
operator|>
name|s
operator|->
name|lookahead
condition|)
name|s
operator|->
name|match_length
operator|=
name|s
operator|->
name|lookahead
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|match_length
operator|<=
literal|5
operator|&&
operator|(
name|s
operator|->
name|strategy
operator|==
name|Z_FILTERED
operator|||
operator|(
name|s
operator|->
name|match_length
operator|==
name|MIN_MATCH
operator|&&
name|s
operator|->
name|strstart
operator|-
name|s
operator|->
name|match_start
operator|>
name|TOO_FAR
operator|)
operator|)
condition|)
block|{
comment|/* If prev_match is also MIN_MATCH, match_start is garbage                  * but we will ignore the current match anyway.                  */
name|s
operator|->
name|match_length
operator|=
name|MIN_MATCH
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* If there was a match at the previous step and the current          * match is not better, output the previous match:          */
if|if
condition|(
name|s
operator|->
name|prev_length
operator|>=
name|MIN_MATCH
operator|&&
name|s
operator|->
name|match_length
operator|<=
name|s
operator|->
name|prev_length
condition|)
block|{
name|uInt
name|max_insert
init|=
name|s
operator|->
name|strstart
operator|+
name|s
operator|->
name|lookahead
operator|-
name|MIN_MATCH
decl_stmt|;
comment|/* Do not insert strings in hash table beyond this. */
name|check_match
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|strstart
operator|-
literal|1
argument_list|,
name|s
operator|->
name|prev_match
argument_list|,
name|s
operator|->
name|prev_length
argument_list|)
expr_stmt|;
name|bflush
operator|=
name|ct_tally
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|strstart
operator|-
literal|1
operator|-
name|s
operator|->
name|prev_match
argument_list|,
name|s
operator|->
name|prev_length
operator|-
name|MIN_MATCH
argument_list|)
expr_stmt|;
comment|/* Insert in hash table all strings up to the end of the match.              * strstart-1 and strstart are already inserted. If there is not              * enough lookahead, the last two strings are not inserted in              * the hash table.              */
name|s
operator|->
name|lookahead
operator|-=
name|s
operator|->
name|prev_length
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|prev_length
operator|-=
literal|2
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|++
name|s
operator|->
name|strstart
operator|<=
name|max_insert
condition|)
block|{
name|INSERT_STRING
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|strstart
argument_list|,
name|hash_head
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|s
operator|->
name|prev_length
operator|!=
literal|0
condition|)
do|;
name|s
operator|->
name|match_available
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|match_length
operator|=
name|MIN_MATCH
operator|-
literal|1
expr_stmt|;
name|s
operator|->
name|strstart
operator|++
expr_stmt|;
if|if
condition|(
name|bflush
condition|)
name|FLUSH_BLOCK
argument_list|(
name|s
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|match_available
condition|)
block|{
comment|/* If there was no match at the previous position, output a              * single literal. If there was a match but the current match              * is longer, truncate the previous match to a single literal.              */
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"%c"
operator|,
name|s
operator|->
name|window
index|[
name|s
operator|->
name|strstart
operator|-
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct_tally
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|window
index|[
name|s
operator|->
name|strstart
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|FLUSH_BLOCK_ONLY
argument_list|(
name|s
argument_list|,
name|Z_NO_FLUSH
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|strstart
operator|++
expr_stmt|;
name|s
operator|->
name|lookahead
operator|--
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|strm
operator|->
name|avail_out
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* There is no previous match to compare with, wait for              * the next step to decide.              */
name|s
operator|->
name|match_available
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|strstart
operator|++
expr_stmt|;
name|s
operator|->
name|lookahead
operator|--
expr_stmt|;
block|}
block|}
name|Assert
argument_list|(
name|flush
operator|!=
name|Z_NO_FLUSH
argument_list|,
literal|"no flush?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|match_available
condition|)
block|{
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"%c"
operator|,
name|s
operator|->
name|window
index|[
name|s
operator|->
name|strstart
operator|-
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|ct_tally
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
name|s
operator|->
name|window
index|[
name|s
operator|->
name|strstart
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|s
operator|->
name|match_available
operator|=
literal|0
expr_stmt|;
block|}
name|FLUSH_BLOCK
argument_list|(
name|s
argument_list|,
name|flush
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*+++++*/
end_comment

begin_comment
comment|/* trees.c -- output deflated data using Huffman coding  * Copyright (C) 1995 Jean-loup Gailly  * For conditions of distribution and use, see copyright notice in zlib.h   */
end_comment

begin_comment
comment|/*  *  ALGORITHM  *  *      The "deflation" process uses several Huffman trees. The more  *      common source values are represented by shorter bit sequences.  *  *      Each code tree is stored in a compressed form which is itself  * a Huffman encoding of the lengths of all the code strings (in  * ascending order by source values).  The actual code strings are  * reconstructed from the lengths in the inflate process, as described  * in the deflate specification.  *  *  REFERENCES  *  *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".  *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc  *  *      Storer, James A.  *          Data Compression:  Methods and Theory, pp. 49-50.  *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.  *  *      Sedgewick, R.  *          Algorithms, p290.  *          Addison-Wesley, 1983. ISBN 0-201-06672-6.  */
end_comment

begin_comment
comment|/* From: trees.c,v 1.5 1995/05/03 17:27:12 jloup Exp */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_ZLIB
end_ifdef

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ===========================================================================  * Constants  */
end_comment

begin_define
define|#
directive|define
name|MAX_BL_BITS
value|7
end_define

begin_comment
comment|/* Bit length codes must not exceed MAX_BL_BITS bits */
end_comment

begin_define
define|#
directive|define
name|END_BLOCK
value|256
end_define

begin_comment
comment|/* end of block literal code */
end_comment

begin_define
define|#
directive|define
name|REP_3_6
value|16
end_define

begin_comment
comment|/* repeat previous bit length 3-6 times (2 bits of repeat count) */
end_comment

begin_define
define|#
directive|define
name|REPZ_3_10
value|17
end_define

begin_comment
comment|/* repeat a zero length 3-10 times  (3 bits of repeat count) */
end_comment

begin_define
define|#
directive|define
name|REPZ_11_138
value|18
end_define

begin_comment
comment|/* repeat a zero length 11-138 times  (7 bits of repeat count) */
end_comment

begin_decl_stmt
name|local
name|int
name|extra_lbits
index|[
name|LENGTH_CODES
index|]
comment|/* extra bits for each length code */
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|extra_dbits
index|[
name|D_CODES
index|]
comment|/* extra bits for each distance code */
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|8
block|,
literal|8
block|,
literal|9
block|,
literal|9
block|,
literal|10
block|,
literal|10
block|,
literal|11
block|,
literal|11
block|,
literal|12
block|,
literal|12
block|,
literal|13
block|,
literal|13
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|extra_blbits
index|[
name|BL_CODES
index|]
comment|/* extra bits for each bit length code */
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|3
block|,
literal|7
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|uch
name|bl_order
index|[
name|BL_CODES
index|]
init|=
block|{
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|0
block|,
literal|8
block|,
literal|7
block|,
literal|9
block|,
literal|6
block|,
literal|10
block|,
literal|5
block|,
literal|11
block|,
literal|4
block|,
literal|12
block|,
literal|3
block|,
literal|13
block|,
literal|2
block|,
literal|14
block|,
literal|1
block|,
literal|15
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The lengths of the bit length codes are sent in order of decreasing  * probability, to avoid transmitting the lengths for unused bit length codes.  */
end_comment

begin_define
define|#
directive|define
name|Buf_size
value|(8 * 2*sizeof(char))
end_define

begin_comment
comment|/* Number of bits used within bi_buf. (bi_buf might be implemented on  * more than 16 bits on some systems.)  */
end_comment

begin_comment
comment|/* ===========================================================================  * Local data. These are initialized only once.  * To do: initialize at compile time to be completely reentrant. ???  */
end_comment

begin_decl_stmt
name|local
name|ct_data
name|static_ltree
index|[
name|L_CODES
operator|+
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The static literal tree. Since the bit lengths are imposed, there is no  * need for the L_CODES extra codes used during heap construction. However  * The codes 286 and 287 are needed to build a canonical tree (see ct_init  * below).  */
end_comment

begin_decl_stmt
name|local
name|ct_data
name|static_dtree
index|[
name|D_CODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The static distance tree. (Actually a trivial tree since all codes use  * 5 bits.)  */
end_comment

begin_decl_stmt
name|local
name|uch
name|dist_code
index|[
literal|512
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* distance codes. The first 256 values correspond to the distances  * 3 .. 258, the last 256 values correspond to the top 8 bits of  * the 15 bit distances.  */
end_comment

begin_decl_stmt
name|local
name|uch
name|length_code
index|[
name|MAX_MATCH
operator|-
name|MIN_MATCH
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length code for each normalized match length (0 == MIN_MATCH) */
end_comment

begin_decl_stmt
name|local
name|int
name|base_length
index|[
name|LENGTH_CODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First normalized length for each code (0 = MIN_MATCH) */
end_comment

begin_decl_stmt
name|local
name|int
name|base_dist
index|[
name|D_CODES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First normalized distance for each code (0 = distance of 1) */
end_comment

begin_struct
struct|struct
name|static_tree_desc_s
block|{
name|ct_data
modifier|*
name|static_tree
decl_stmt|;
comment|/* static tree or NULL */
name|intf
modifier|*
name|extra_bits
decl_stmt|;
comment|/* extra bits for each code or NULL */
name|int
name|extra_base
decl_stmt|;
comment|/* base index for extra_bits */
name|int
name|elems
decl_stmt|;
comment|/* max number of elements in the tree */
name|int
name|max_length
decl_stmt|;
comment|/* max bit length for the codes */
block|}
struct|;
end_struct

begin_decl_stmt
name|local
name|static_tree_desc
name|static_l_desc
init|=
block|{
name|static_ltree
block|,
name|extra_lbits
block|,
name|LITERALS
operator|+
literal|1
block|,
name|L_CODES
block|,
name|MAX_BITS
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|static_tree_desc
name|static_d_desc
init|=
block|{
name|static_dtree
block|,
name|extra_dbits
block|,
literal|0
block|,
name|D_CODES
block|,
name|MAX_BITS
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|static_tree_desc
name|static_bl_desc
init|=
block|{
operator|(
name|ct_data
operator|*
operator|)
literal|0
block|,
name|extra_blbits
block|,
literal|0
block|,
name|BL_CODES
block|,
name|MAX_BL_BITS
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ===========================================================================  * Local (static) routines in this file.  */
end_comment

begin_decl_stmt
name|local
name|void
name|ct_static_init
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|init_block
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|pqdownheap
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|ct_data
operator|*
name|tree
operator|,
name|int
name|k
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|gen_bitlen
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|tree_desc
operator|*
name|desc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|gen_codes
name|OF
argument_list|(
operator|(
name|ct_data
operator|*
name|tree
operator|,
name|int
name|max_code
operator|,
name|ushf
operator|*
name|bl_count
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|build_tree
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|tree_desc
operator|*
name|desc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|scan_tree
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|ct_data
operator|*
name|tree
operator|,
name|int
name|max_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|send_tree
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|ct_data
operator|*
name|tree
operator|,
name|int
name|max_code
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|build_bl_tree
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|send_all_trees
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|int
name|lcodes
operator|,
name|int
name|dcodes
operator|,
name|int
name|blcodes
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|compress_block
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|ct_data
operator|*
name|ltree
operator|,
name|ct_data
operator|*
name|dtree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|set_data_type
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|unsigned
name|bi_reverse
name|OF
argument_list|(
operator|(
name|unsigned
name|value
operator|,
name|int
name|length
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|bi_windup
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|bi_flush
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|copy_block
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|charf
operator|*
name|buf
operator|,
name|unsigned
name|len
operator|,
name|int
name|header
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|DEBUG_ZLIB
end_ifndef

begin_define
define|#
directive|define
name|send_code
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|,
name|tree
parameter_list|)
value|send_bits(s, tree[c].Code, tree[c].Len)
end_define

begin_comment
comment|/* Send a code of the given tree. c and tree must not have side effects */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* DEBUG_ZLIB */
end_comment

begin_define
define|#
directive|define
name|send_code
parameter_list|(
name|s
parameter_list|,
name|c
parameter_list|,
name|tree
parameter_list|)
define|\
value|{ if (verbose>1) fprintf(stderr,"\ncd %3d ",(c)); \        send_bits(s, tree[c].Code, tree[c].Len); }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|d_code
parameter_list|(
name|dist
parameter_list|)
define|\
value|((dist)< 256 ? dist_code[dist] : dist_code[256+((dist)>>7)])
end_define

begin_comment
comment|/* Mapping from a distance to a distance code. dist is the distance - 1 and  * must not have side effects. dist_code[256] and dist_code[257] are never  * used.  */
end_comment

begin_comment
comment|/* ===========================================================================  * Output a short LSB first on the stream.  * IN assertion: there is enough room in pendingBuf.  */
end_comment

begin_define
define|#
directive|define
name|put_short
parameter_list|(
name|s
parameter_list|,
name|w
parameter_list|)
value|{ \     put_byte(s, (uch)((w)& 0xff)); \     put_byte(s, (uch)((ush)(w)>> 8)); \ }
end_define

begin_comment
comment|/* ===========================================================================  * Send a value on a given number of bits.  * IN assertion: length<= 16 and value fits in length bits.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_ZLIB
end_ifdef

begin_decl_stmt
name|local
name|void
name|send_bits
name|OF
argument_list|(
operator|(
name|deflate_state
operator|*
name|s
operator|,
name|int
name|value
operator|,
name|int
name|length
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|local
name|void
name|send_bits
parameter_list|(
name|s
parameter_list|,
name|value
parameter_list|,
name|length
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|int
name|value
decl_stmt|;
comment|/* value to send */
name|int
name|length
decl_stmt|;
comment|/* number of bits */
block|{
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|" l %2d v %4x "
operator|,
name|length
operator|,
name|value
operator|)
argument_list|)
expr_stmt|;
name|Assert
argument_list|(
name|length
operator|>
literal|0
operator|&&
name|length
operator|<=
literal|15
argument_list|,
literal|"invalid length"
argument_list|)
expr_stmt|;
name|s
operator|->
name|bits_sent
operator|+=
operator|(
name|ulg
operator|)
name|length
expr_stmt|;
comment|/* If not enough room in bi_buf, use (valid) bits from bi_buf and      * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))      * unused bits in value.      */
if|if
condition|(
name|s
operator|->
name|bi_valid
operator|>
operator|(
name|int
operator|)
name|Buf_size
operator|-
name|length
condition|)
block|{
name|s
operator|->
name|bi_buf
operator||=
operator|(
name|value
operator|<<
name|s
operator|->
name|bi_valid
operator|)
expr_stmt|;
name|put_short
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|bi_buf
argument_list|)
expr_stmt|;
name|s
operator|->
name|bi_buf
operator|=
operator|(
name|ush
operator|)
name|value
operator|>>
operator|(
name|Buf_size
operator|-
name|s
operator|->
name|bi_valid
operator|)
expr_stmt|;
name|s
operator|->
name|bi_valid
operator|+=
name|length
operator|-
name|Buf_size
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|bi_buf
operator||=
name|value
operator|<<
name|s
operator|->
name|bi_valid
expr_stmt|;
name|s
operator|->
name|bi_valid
operator|+=
name|length
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !DEBUG_ZLIB */
end_comment

begin_define
define|#
directive|define
name|send_bits
parameter_list|(
name|s
parameter_list|,
name|value
parameter_list|,
name|length
parameter_list|)
define|\
value|{ int len = length;\   if (s->bi_valid> (int)Buf_size - len) {\     int val = value;\     s->bi_buf |= (val<< s->bi_valid);\     put_short(s, s->bi_buf);\     s->bi_buf = (ush)val>> (Buf_size - s->bi_valid);\     s->bi_valid += len - Buf_size;\   } else {\     s->bi_buf |= (value)<< s->bi_valid;\     s->bi_valid += len;\   }\ }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG_ZLIB */
end_comment

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(a>= b ? a : b)
end_define

begin_comment
comment|/* the arguments must not have side effects */
end_comment

begin_comment
comment|/* ===========================================================================  * Initialize the various 'constant' tables.  * To do: do this at compile time.  */
end_comment

begin_function
name|local
name|void
name|ct_static_init
parameter_list|()
block|{
name|int
name|n
decl_stmt|;
comment|/* iterates over tree elements */
name|int
name|bits
decl_stmt|;
comment|/* bit counter */
name|int
name|length
decl_stmt|;
comment|/* length value */
name|int
name|code
decl_stmt|;
comment|/* code value */
name|int
name|dist
decl_stmt|;
comment|/* distance index */
name|ush
name|bl_count
index|[
name|MAX_BITS
operator|+
literal|1
index|]
decl_stmt|;
comment|/* number of codes at each bit length for an optimal tree */
comment|/* Initialize the mapping length (0..255) -> length code (0..28) */
name|length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|code
operator|=
literal|0
init|;
name|code
operator|<
name|LENGTH_CODES
operator|-
literal|1
condition|;
name|code
operator|++
control|)
block|{
name|base_length
index|[
name|code
index|]
operator|=
name|length
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
literal|1
operator|<<
name|extra_lbits
index|[
name|code
index|]
operator|)
condition|;
name|n
operator|++
control|)
block|{
name|length_code
index|[
name|length
operator|++
index|]
operator|=
operator|(
name|uch
operator|)
name|code
expr_stmt|;
block|}
block|}
name|Assert
argument_list|(
name|length
operator|==
literal|256
argument_list|,
literal|"ct_static_init: length != 256"
argument_list|)
expr_stmt|;
comment|/* Note that the length 255 (match length 258) can be represented      * in two different ways: code 284 + 5 bits or code 285, so we      * overwrite length_code[255] to use the best encoding:      */
name|length_code
index|[
name|length
operator|-
literal|1
index|]
operator|=
operator|(
name|uch
operator|)
name|code
expr_stmt|;
comment|/* Initialize the mapping dist (0..32K) -> dist code (0..29) */
name|dist
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|code
operator|=
literal|0
init|;
name|code
operator|<
literal|16
condition|;
name|code
operator|++
control|)
block|{
name|base_dist
index|[
name|code
index|]
operator|=
name|dist
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
literal|1
operator|<<
name|extra_dbits
index|[
name|code
index|]
operator|)
condition|;
name|n
operator|++
control|)
block|{
name|dist_code
index|[
name|dist
operator|++
index|]
operator|=
operator|(
name|uch
operator|)
name|code
expr_stmt|;
block|}
block|}
name|Assert
argument_list|(
name|dist
operator|==
literal|256
argument_list|,
literal|"ct_static_init: dist != 256"
argument_list|)
expr_stmt|;
name|dist
operator|>>=
literal|7
expr_stmt|;
comment|/* from now on, all distances are divided by 128 */
for|for
control|(
init|;
name|code
operator|<
name|D_CODES
condition|;
name|code
operator|++
control|)
block|{
name|base_dist
index|[
name|code
index|]
operator|=
name|dist
operator|<<
literal|7
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
literal|1
operator|<<
operator|(
name|extra_dbits
index|[
name|code
index|]
operator|-
literal|7
operator|)
operator|)
condition|;
name|n
operator|++
control|)
block|{
name|dist_code
index|[
literal|256
operator|+
name|dist
operator|++
index|]
operator|=
operator|(
name|uch
operator|)
name|code
expr_stmt|;
block|}
block|}
name|Assert
argument_list|(
name|dist
operator|==
literal|256
argument_list|,
literal|"ct_static_init: 256+dist != 512"
argument_list|)
expr_stmt|;
comment|/* Construct the codes of the static literal tree */
for|for
control|(
name|bits
operator|=
literal|0
init|;
name|bits
operator|<=
name|MAX_BITS
condition|;
name|bits
operator|++
control|)
name|bl_count
index|[
name|bits
index|]
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|n
operator|<=
literal|143
condition|)
name|static_ltree
index|[
name|n
operator|++
index|]
operator|.
name|Len
operator|=
literal|8
operator|,
name|bl_count
index|[
literal|8
index|]
operator|++
expr_stmt|;
while|while
condition|(
name|n
operator|<=
literal|255
condition|)
name|static_ltree
index|[
name|n
operator|++
index|]
operator|.
name|Len
operator|=
literal|9
operator|,
name|bl_count
index|[
literal|9
index|]
operator|++
expr_stmt|;
while|while
condition|(
name|n
operator|<=
literal|279
condition|)
name|static_ltree
index|[
name|n
operator|++
index|]
operator|.
name|Len
operator|=
literal|7
operator|,
name|bl_count
index|[
literal|7
index|]
operator|++
expr_stmt|;
while|while
condition|(
name|n
operator|<=
literal|287
condition|)
name|static_ltree
index|[
name|n
operator|++
index|]
operator|.
name|Len
operator|=
literal|8
operator|,
name|bl_count
index|[
literal|8
index|]
operator|++
expr_stmt|;
comment|/* Codes 286 and 287 do not exist, but we must include them in the      * tree construction to get a canonical Huffman tree (longest code      * all ones)      */
name|gen_codes
argument_list|(
operator|(
name|ct_data
operator|*
operator|)
name|static_ltree
argument_list|,
name|L_CODES
operator|+
literal|1
argument_list|,
name|bl_count
argument_list|)
expr_stmt|;
comment|/* The static distance tree is trivial: */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|D_CODES
condition|;
name|n
operator|++
control|)
block|{
name|static_dtree
index|[
name|n
index|]
operator|.
name|Len
operator|=
literal|5
expr_stmt|;
name|static_dtree
index|[
name|n
index|]
operator|.
name|Code
operator|=
name|bi_reverse
argument_list|(
name|n
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Initialize the tree data structures for a new zlib stream.  */
end_comment

begin_function
name|local
name|void
name|ct_init
parameter_list|(
name|s
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|static_dtree
index|[
literal|0
index|]
operator|.
name|Len
operator|==
literal|0
condition|)
block|{
name|ct_static_init
argument_list|()
expr_stmt|;
comment|/* To do: at compile time */
block|}
name|s
operator|->
name|compressed_len
operator|=
literal|0L
expr_stmt|;
name|s
operator|->
name|l_desc
operator|.
name|dyn_tree
operator|=
name|s
operator|->
name|dyn_ltree
expr_stmt|;
name|s
operator|->
name|l_desc
operator|.
name|stat_desc
operator|=
operator|&
name|static_l_desc
expr_stmt|;
name|s
operator|->
name|d_desc
operator|.
name|dyn_tree
operator|=
name|s
operator|->
name|dyn_dtree
expr_stmt|;
name|s
operator|->
name|d_desc
operator|.
name|stat_desc
operator|=
operator|&
name|static_d_desc
expr_stmt|;
name|s
operator|->
name|bl_desc
operator|.
name|dyn_tree
operator|=
name|s
operator|->
name|bl_tree
expr_stmt|;
name|s
operator|->
name|bl_desc
operator|.
name|stat_desc
operator|=
operator|&
name|static_bl_desc
expr_stmt|;
name|s
operator|->
name|bi_buf
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|bi_valid
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|last_eob_len
operator|=
literal|8
expr_stmt|;
comment|/* enough lookahead for inflate */
ifdef|#
directive|ifdef
name|DEBUG_ZLIB
name|s
operator|->
name|bits_sent
operator|=
literal|0L
expr_stmt|;
endif|#
directive|endif
name|s
operator|->
name|blocks_in_packet
operator|=
literal|0
expr_stmt|;
comment|/* Initialize the first block of the first file: */
name|init_block
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Initialize a new block.  */
end_comment

begin_function
name|local
name|void
name|init_block
parameter_list|(
name|s
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
comment|/* iterates over tree elements */
comment|/* Initialize the trees. */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|L_CODES
condition|;
name|n
operator|++
control|)
name|s
operator|->
name|dyn_ltree
index|[
name|n
index|]
operator|.
name|Freq
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|D_CODES
condition|;
name|n
operator|++
control|)
name|s
operator|->
name|dyn_dtree
index|[
name|n
index|]
operator|.
name|Freq
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|BL_CODES
condition|;
name|n
operator|++
control|)
name|s
operator|->
name|bl_tree
index|[
name|n
index|]
operator|.
name|Freq
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|dyn_ltree
index|[
name|END_BLOCK
index|]
operator|.
name|Freq
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|opt_len
operator|=
name|s
operator|->
name|static_len
operator|=
literal|0L
expr_stmt|;
name|s
operator|->
name|last_lit
operator|=
name|s
operator|->
name|matches
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|SMALLEST
value|1
end_define

begin_comment
comment|/* Index within the heap array of least frequent node in the Huffman tree */
end_comment

begin_comment
comment|/* ===========================================================================  * Remove the smallest element from the heap and recreate the heap with  * one less element. Updates heap and heap_len.  */
end_comment

begin_define
define|#
directive|define
name|pqremove
parameter_list|(
name|s
parameter_list|,
name|tree
parameter_list|,
name|top
parameter_list|)
define|\
value|{\     top = s->heap[SMALLEST]; \     s->heap[SMALLEST] = s->heap[s->heap_len--]; \     pqdownheap(s, tree, SMALLEST); \ }
end_define

begin_comment
comment|/* ===========================================================================  * Compares to subtrees, using the tree depth as tie breaker when  * the subtrees have equal frequency. This minimizes the worst case length.  */
end_comment

begin_define
define|#
directive|define
name|smaller
parameter_list|(
name|tree
parameter_list|,
name|n
parameter_list|,
name|m
parameter_list|,
name|depth
parameter_list|)
define|\
value|(tree[n].Freq< tree[m].Freq || \    (tree[n].Freq == tree[m].Freq&& depth[n]<= depth[m]))
end_define

begin_comment
comment|/* ===========================================================================  * Restore the heap property by moving down the tree starting at node k,  * exchanging a node with the smallest of its two sons if necessary, stopping  * when the heap property is re-established (each father smaller than its  * two sons).  */
end_comment

begin_function
name|local
name|void
name|pqdownheap
parameter_list|(
name|s
parameter_list|,
name|tree
parameter_list|,
name|k
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|ct_data
modifier|*
name|tree
decl_stmt|;
comment|/* the tree to restore */
name|int
name|k
decl_stmt|;
comment|/* node to move down */
block|{
name|int
name|v
init|=
name|s
operator|->
name|heap
index|[
name|k
index|]
decl_stmt|;
name|int
name|j
init|=
name|k
operator|<<
literal|1
decl_stmt|;
comment|/* left son of k */
while|while
condition|(
name|j
operator|<=
name|s
operator|->
name|heap_len
condition|)
block|{
comment|/* Set j to the smallest of the two sons: */
if|if
condition|(
name|j
operator|<
name|s
operator|->
name|heap_len
operator|&&
name|smaller
argument_list|(
name|tree
argument_list|,
name|s
operator|->
name|heap
index|[
name|j
operator|+
literal|1
index|]
argument_list|,
name|s
operator|->
name|heap
index|[
name|j
index|]
argument_list|,
name|s
operator|->
name|depth
argument_list|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
block|}
comment|/* Exit if v is smaller than both sons */
if|if
condition|(
name|smaller
argument_list|(
name|tree
argument_list|,
name|v
argument_list|,
name|s
operator|->
name|heap
index|[
name|j
index|]
argument_list|,
name|s
operator|->
name|depth
argument_list|)
condition|)
break|break;
comment|/* Exchange v with the smallest son */
name|s
operator|->
name|heap
index|[
name|k
index|]
operator|=
name|s
operator|->
name|heap
index|[
name|j
index|]
expr_stmt|;
name|k
operator|=
name|j
expr_stmt|;
comment|/* And continue down the tree, setting j to the left son of k */
name|j
operator|<<=
literal|1
expr_stmt|;
block|}
name|s
operator|->
name|heap
index|[
name|k
index|]
operator|=
name|v
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Compute the optimal bit lengths for a tree and update the total bit length  * for the current block.  * IN assertion: the fields freq and dad are set, heap[heap_max] and  *    above are the tree nodes sorted by increasing frequency.  * OUT assertions: the field len is set to the optimal bit length, the  *     array bl_count contains the frequencies for each bit length.  *     The length opt_len is updated; static_len is also updated if stree is  *     not null.  */
end_comment

begin_function
name|local
name|void
name|gen_bitlen
parameter_list|(
name|s
parameter_list|,
name|desc
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|tree_desc
modifier|*
name|desc
decl_stmt|;
comment|/* the tree descriptor */
block|{
name|ct_data
modifier|*
name|tree
init|=
name|desc
operator|->
name|dyn_tree
decl_stmt|;
name|int
name|max_code
init|=
name|desc
operator|->
name|max_code
decl_stmt|;
name|ct_data
modifier|*
name|stree
init|=
name|desc
operator|->
name|stat_desc
operator|->
name|static_tree
decl_stmt|;
name|intf
modifier|*
name|extra
init|=
name|desc
operator|->
name|stat_desc
operator|->
name|extra_bits
decl_stmt|;
name|int
name|base
init|=
name|desc
operator|->
name|stat_desc
operator|->
name|extra_base
decl_stmt|;
name|int
name|max_length
init|=
name|desc
operator|->
name|stat_desc
operator|->
name|max_length
decl_stmt|;
name|int
name|h
decl_stmt|;
comment|/* heap index */
name|int
name|n
decl_stmt|,
name|m
decl_stmt|;
comment|/* iterate over the tree elements */
name|int
name|bits
decl_stmt|;
comment|/* bit length */
name|int
name|xbits
decl_stmt|;
comment|/* extra bits */
name|ush
name|f
decl_stmt|;
comment|/* frequency */
name|int
name|overflow
init|=
literal|0
decl_stmt|;
comment|/* number of elements with bit length too large */
for|for
control|(
name|bits
operator|=
literal|0
init|;
name|bits
operator|<=
name|MAX_BITS
condition|;
name|bits
operator|++
control|)
name|s
operator|->
name|bl_count
index|[
name|bits
index|]
operator|=
literal|0
expr_stmt|;
comment|/* In a first pass, compute the optimal bit lengths (which may      * overflow in the case of the bit length tree).      */
name|tree
index|[
name|s
operator|->
name|heap
index|[
name|s
operator|->
name|heap_max
index|]
index|]
operator|.
name|Len
operator|=
literal|0
expr_stmt|;
comment|/* root of the heap */
for|for
control|(
name|h
operator|=
name|s
operator|->
name|heap_max
operator|+
literal|1
init|;
name|h
operator|<
name|HEAP_SIZE
condition|;
name|h
operator|++
control|)
block|{
name|n
operator|=
name|s
operator|->
name|heap
index|[
name|h
index|]
expr_stmt|;
name|bits
operator|=
name|tree
index|[
name|tree
index|[
name|n
index|]
operator|.
name|Dad
index|]
operator|.
name|Len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|bits
operator|>
name|max_length
condition|)
name|bits
operator|=
name|max_length
operator|,
name|overflow
operator|++
expr_stmt|;
name|tree
index|[
name|n
index|]
operator|.
name|Len
operator|=
operator|(
name|ush
operator|)
name|bits
expr_stmt|;
comment|/* We overwrite tree[n].Dad which is no longer needed */
if|if
condition|(
name|n
operator|>
name|max_code
condition|)
continue|continue;
comment|/* not a leaf node */
name|s
operator|->
name|bl_count
index|[
name|bits
index|]
operator|++
expr_stmt|;
name|xbits
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|base
condition|)
name|xbits
operator|=
name|extra
index|[
name|n
operator|-
name|base
index|]
expr_stmt|;
name|f
operator|=
name|tree
index|[
name|n
index|]
operator|.
name|Freq
expr_stmt|;
name|s
operator|->
name|opt_len
operator|+=
operator|(
name|ulg
operator|)
name|f
operator|*
operator|(
name|bits
operator|+
name|xbits
operator|)
expr_stmt|;
if|if
condition|(
name|stree
condition|)
name|s
operator|->
name|static_len
operator|+=
operator|(
name|ulg
operator|)
name|f
operator|*
operator|(
name|stree
index|[
name|n
index|]
operator|.
name|Len
operator|+
name|xbits
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|overflow
operator|==
literal|0
condition|)
return|return;
name|Trace
argument_list|(
operator|(
name|stderr
operator|,
literal|"\nbit length overflow\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* This happens for example on obj2 and pic of the Calgary corpus */
comment|/* Find the first bit length which could increase: */
do|do
block|{
name|bits
operator|=
name|max_length
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|s
operator|->
name|bl_count
index|[
name|bits
index|]
operator|==
literal|0
condition|)
name|bits
operator|--
expr_stmt|;
name|s
operator|->
name|bl_count
index|[
name|bits
index|]
operator|--
expr_stmt|;
comment|/* move one leaf down the tree */
name|s
operator|->
name|bl_count
index|[
name|bits
operator|+
literal|1
index|]
operator|+=
literal|2
expr_stmt|;
comment|/* move one overflow item as its brother */
name|s
operator|->
name|bl_count
index|[
name|max_length
index|]
operator|--
expr_stmt|;
comment|/* The brother of the overflow item also moves one step up,          * but this does not affect bl_count[max_length]          */
name|overflow
operator|-=
literal|2
expr_stmt|;
block|}
do|while
condition|(
name|overflow
operator|>
literal|0
condition|)
do|;
comment|/* Now recompute all bit lengths, scanning in increasing frequency.      * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all      * lengths instead of fixing only the wrong ones. This idea is taken      * from 'ar' written by Haruhiko Okumura.)      */
for|for
control|(
name|bits
operator|=
name|max_length
init|;
name|bits
operator|!=
literal|0
condition|;
name|bits
operator|--
control|)
block|{
name|n
operator|=
name|s
operator|->
name|bl_count
index|[
name|bits
index|]
expr_stmt|;
while|while
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
name|m
operator|=
name|s
operator|->
name|heap
index|[
operator|--
name|h
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|>
name|max_code
condition|)
continue|continue;
if|if
condition|(
name|tree
index|[
name|m
index|]
operator|.
name|Len
operator|!=
operator|(
name|unsigned
operator|)
name|bits
condition|)
block|{
name|Trace
argument_list|(
operator|(
name|stderr
operator|,
literal|"code %d bits %d->%d\n"
operator|,
name|m
operator|,
name|tree
index|[
name|m
index|]
operator|.
name|Len
operator|,
name|bits
operator|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|opt_len
operator|+=
operator|(
operator|(
name|long
operator|)
name|bits
operator|-
operator|(
name|long
operator|)
name|tree
index|[
name|m
index|]
operator|.
name|Len
operator|)
operator|*
operator|(
name|long
operator|)
name|tree
index|[
name|m
index|]
operator|.
name|Freq
expr_stmt|;
name|tree
index|[
name|m
index|]
operator|.
name|Len
operator|=
operator|(
name|ush
operator|)
name|bits
expr_stmt|;
block|}
name|n
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Generate the codes for a given tree and bit counts (which need not be  * optimal).  * IN assertion: the array bl_count contains the bit length statistics for  * the given tree and the field len is set for all tree elements.  * OUT assertion: the field code is set for all tree elements of non  *     zero code length.  */
end_comment

begin_function
name|local
name|void
name|gen_codes
parameter_list|(
name|tree
parameter_list|,
name|max_code
parameter_list|,
name|bl_count
parameter_list|)
name|ct_data
modifier|*
name|tree
decl_stmt|;
comment|/* the tree to decorate */
name|int
name|max_code
decl_stmt|;
comment|/* largest code with non zero frequency */
name|ushf
modifier|*
name|bl_count
decl_stmt|;
comment|/* number of codes at each bit length */
block|{
name|ush
name|next_code
index|[
name|MAX_BITS
operator|+
literal|1
index|]
decl_stmt|;
comment|/* next code value for each bit length */
name|ush
name|code
init|=
literal|0
decl_stmt|;
comment|/* running code value */
name|int
name|bits
decl_stmt|;
comment|/* bit index */
name|int
name|n
decl_stmt|;
comment|/* code index */
comment|/* The distribution counts are first used to generate the code values      * without bit reversal.      */
for|for
control|(
name|bits
operator|=
literal|1
init|;
name|bits
operator|<=
name|MAX_BITS
condition|;
name|bits
operator|++
control|)
block|{
name|next_code
index|[
name|bits
index|]
operator|=
name|code
operator|=
operator|(
name|code
operator|+
name|bl_count
index|[
name|bits
operator|-
literal|1
index|]
operator|)
operator|<<
literal|1
expr_stmt|;
block|}
comment|/* Check that the bit counts in bl_count are consistent. The last code      * must be all ones.      */
name|Assert
argument_list|(
name|code
operator|+
name|bl_count
index|[
name|MAX_BITS
index|]
operator|-
literal|1
operator|==
operator|(
literal|1
operator|<<
name|MAX_BITS
operator|)
operator|-
literal|1
argument_list|,
literal|"inconsistent bit counts"
argument_list|)
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"\ngen_codes: max_code %d "
operator|,
name|max_code
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
name|max_code
condition|;
name|n
operator|++
control|)
block|{
name|int
name|len
init|=
name|tree
index|[
name|n
index|]
operator|.
name|Len
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
continue|continue;
comment|/* Now reverse the bits */
name|tree
index|[
name|n
index|]
operator|.
name|Code
operator|=
name|bi_reverse
argument_list|(
name|next_code
index|[
name|len
index|]
operator|++
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|Tracec
argument_list|(
name|tree
operator|!=
name|static_ltree
argument_list|,
operator|(
name|stderr
operator|,
literal|"\nn %3d %c l %2d c %4x (%x) "
operator|,
name|n
operator|,
operator|(
name|isgraph
argument_list|(
name|n
argument_list|)
condition|?
name|n
else|:
literal|' '
operator|)
operator|,
name|len
operator|,
name|tree
index|[
name|n
index|]
operator|.
name|Code
operator|,
name|next_code
index|[
name|len
index|]
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Construct one Huffman tree and assigns the code bit strings and lengths.  * Update the total bit length for the current block.  * IN assertion: the field freq is set for all tree elements.  * OUT assertions: the fields len and code are set to the optimal bit length  *     and corresponding code. The length opt_len is updated; static_len is  *     also updated if stree is not null. The field max_code is set.  */
end_comment

begin_function
name|local
name|void
name|build_tree
parameter_list|(
name|s
parameter_list|,
name|desc
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|tree_desc
modifier|*
name|desc
decl_stmt|;
comment|/* the tree descriptor */
block|{
name|ct_data
modifier|*
name|tree
init|=
name|desc
operator|->
name|dyn_tree
decl_stmt|;
name|ct_data
modifier|*
name|stree
init|=
name|desc
operator|->
name|stat_desc
operator|->
name|static_tree
decl_stmt|;
name|int
name|elems
init|=
name|desc
operator|->
name|stat_desc
operator|->
name|elems
decl_stmt|;
name|int
name|n
decl_stmt|,
name|m
decl_stmt|;
comment|/* iterate over heap elements */
name|int
name|max_code
init|=
operator|-
literal|1
decl_stmt|;
comment|/* largest code with non zero frequency */
name|int
name|node
decl_stmt|;
comment|/* new node being created */
comment|/* Construct the initial heap, with least frequent element in      * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].      * heap[0] is not used.      */
name|s
operator|->
name|heap_len
operator|=
literal|0
operator|,
name|s
operator|->
name|heap_max
operator|=
name|HEAP_SIZE
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|elems
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|tree
index|[
name|n
index|]
operator|.
name|Freq
operator|!=
literal|0
condition|)
block|{
name|s
operator|->
name|heap
index|[
operator|++
operator|(
name|s
operator|->
name|heap_len
operator|)
index|]
operator|=
name|max_code
operator|=
name|n
expr_stmt|;
name|s
operator|->
name|depth
index|[
name|n
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|tree
index|[
name|n
index|]
operator|.
name|Len
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* The pkzip format requires that at least one distance code exists,      * and that at least one bit should be sent even if there is only one      * possible code. So to avoid special checks later on we force at least      * two codes of non zero frequency.      */
while|while
condition|(
name|s
operator|->
name|heap_len
operator|<
literal|2
condition|)
block|{
name|node
operator|=
name|s
operator|->
name|heap
index|[
operator|++
operator|(
name|s
operator|->
name|heap_len
operator|)
index|]
operator|=
operator|(
name|max_code
operator|<
literal|2
condition|?
operator|++
name|max_code
else|:
literal|0
operator|)
expr_stmt|;
name|tree
index|[
name|node
index|]
operator|.
name|Freq
operator|=
literal|1
expr_stmt|;
name|s
operator|->
name|depth
index|[
name|node
index|]
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|opt_len
operator|--
expr_stmt|;
if|if
condition|(
name|stree
condition|)
name|s
operator|->
name|static_len
operator|-=
name|stree
index|[
name|node
index|]
operator|.
name|Len
expr_stmt|;
comment|/* node is 0 or 1 so it does not have extra bits */
block|}
name|desc
operator|->
name|max_code
operator|=
name|max_code
expr_stmt|;
comment|/* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,      * establish sub-heaps of increasing lengths:      */
for|for
control|(
name|n
operator|=
name|s
operator|->
name|heap_len
operator|/
literal|2
init|;
name|n
operator|>=
literal|1
condition|;
name|n
operator|--
control|)
name|pqdownheap
argument_list|(
name|s
argument_list|,
name|tree
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* Construct the Huffman tree by repeatedly combining the least two      * frequent nodes.      */
name|node
operator|=
name|elems
expr_stmt|;
comment|/* next internal node of the tree */
do|do
block|{
name|pqremove
argument_list|(
name|s
argument_list|,
name|tree
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* n = node of least frequency */
name|m
operator|=
name|s
operator|->
name|heap
index|[
name|SMALLEST
index|]
expr_stmt|;
comment|/* m = node of next least frequency */
name|s
operator|->
name|heap
index|[
operator|--
operator|(
name|s
operator|->
name|heap_max
operator|)
index|]
operator|=
name|n
expr_stmt|;
comment|/* keep the nodes sorted by frequency */
name|s
operator|->
name|heap
index|[
operator|--
operator|(
name|s
operator|->
name|heap_max
operator|)
index|]
operator|=
name|m
expr_stmt|;
comment|/* Create a new node father of n and m */
name|tree
index|[
name|node
index|]
operator|.
name|Freq
operator|=
name|tree
index|[
name|n
index|]
operator|.
name|Freq
operator|+
name|tree
index|[
name|m
index|]
operator|.
name|Freq
expr_stmt|;
name|s
operator|->
name|depth
index|[
name|node
index|]
operator|=
call|(
name|uch
call|)
argument_list|(
name|MAX
argument_list|(
name|s
operator|->
name|depth
index|[
name|n
index|]
argument_list|,
name|s
operator|->
name|depth
index|[
name|m
index|]
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|tree
index|[
name|n
index|]
operator|.
name|Dad
operator|=
name|tree
index|[
name|m
index|]
operator|.
name|Dad
operator|=
operator|(
name|ush
operator|)
name|node
expr_stmt|;
ifdef|#
directive|ifdef
name|DUMP_BL_TREE
if|if
condition|(
name|tree
operator|==
name|s
operator|->
name|bl_tree
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nnode %d(%d), sons %d(%d) %d(%d)"
argument_list|,
name|node
argument_list|,
name|tree
index|[
name|node
index|]
operator|.
name|Freq
argument_list|,
name|n
argument_list|,
name|tree
index|[
name|n
index|]
operator|.
name|Freq
argument_list|,
name|m
argument_list|,
name|tree
index|[
name|m
index|]
operator|.
name|Freq
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* and insert the new node in the heap */
name|s
operator|->
name|heap
index|[
name|SMALLEST
index|]
operator|=
name|node
operator|++
expr_stmt|;
name|pqdownheap
argument_list|(
name|s
argument_list|,
name|tree
argument_list|,
name|SMALLEST
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|s
operator|->
name|heap_len
operator|>=
literal|2
condition|)
do|;
name|s
operator|->
name|heap
index|[
operator|--
operator|(
name|s
operator|->
name|heap_max
operator|)
index|]
operator|=
name|s
operator|->
name|heap
index|[
name|SMALLEST
index|]
expr_stmt|;
comment|/* At this point, the fields freq and dad are set. We can now      * generate the bit lengths.      */
name|gen_bitlen
argument_list|(
name|s
argument_list|,
operator|(
name|tree_desc
operator|*
operator|)
name|desc
argument_list|)
expr_stmt|;
comment|/* The field len is now set, we can generate the bit codes */
name|gen_codes
argument_list|(
operator|(
name|ct_data
operator|*
operator|)
name|tree
argument_list|,
name|max_code
argument_list|,
name|s
operator|->
name|bl_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Scan a literal or distance tree to determine the frequencies of the codes  * in the bit length tree.  */
end_comment

begin_function
name|local
name|void
name|scan_tree
parameter_list|(
name|s
parameter_list|,
name|tree
parameter_list|,
name|max_code
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|ct_data
modifier|*
name|tree
decl_stmt|;
comment|/* the tree to be scanned */
name|int
name|max_code
decl_stmt|;
comment|/* and its largest code of non zero frequency */
block|{
name|int
name|n
decl_stmt|;
comment|/* iterates over all tree elements */
name|int
name|prevlen
init|=
operator|-
literal|1
decl_stmt|;
comment|/* last emitted length */
name|int
name|curlen
decl_stmt|;
comment|/* length of current code */
name|int
name|nextlen
init|=
name|tree
index|[
literal|0
index|]
operator|.
name|Len
decl_stmt|;
comment|/* length of next code */
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* repeat count of the current code */
name|int
name|max_count
init|=
literal|7
decl_stmt|;
comment|/* max repeat count */
name|int
name|min_count
init|=
literal|4
decl_stmt|;
comment|/* min repeat count */
if|if
condition|(
name|nextlen
operator|==
literal|0
condition|)
name|max_count
operator|=
literal|138
operator|,
name|min_count
operator|=
literal|3
expr_stmt|;
name|tree
index|[
name|max_code
operator|+
literal|1
index|]
operator|.
name|Len
operator|=
operator|(
name|ush
operator|)
literal|0xffff
expr_stmt|;
comment|/* guard */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
name|max_code
condition|;
name|n
operator|++
control|)
block|{
name|curlen
operator|=
name|nextlen
expr_stmt|;
name|nextlen
operator|=
name|tree
index|[
name|n
operator|+
literal|1
index|]
operator|.
name|Len
expr_stmt|;
if|if
condition|(
operator|++
name|count
operator|<
name|max_count
operator|&&
name|curlen
operator|==
name|nextlen
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|count
operator|<
name|min_count
condition|)
block|{
name|s
operator|->
name|bl_tree
index|[
name|curlen
index|]
operator|.
name|Freq
operator|+=
name|count
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curlen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|curlen
operator|!=
name|prevlen
condition|)
name|s
operator|->
name|bl_tree
index|[
name|curlen
index|]
operator|.
name|Freq
operator|++
expr_stmt|;
name|s
operator|->
name|bl_tree
index|[
name|REP_3_6
index|]
operator|.
name|Freq
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|<=
literal|10
condition|)
block|{
name|s
operator|->
name|bl_tree
index|[
name|REPZ_3_10
index|]
operator|.
name|Freq
operator|++
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|bl_tree
index|[
name|REPZ_11_138
index|]
operator|.
name|Freq
operator|++
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|prevlen
operator|=
name|curlen
expr_stmt|;
if|if
condition|(
name|nextlen
operator|==
literal|0
condition|)
block|{
name|max_count
operator|=
literal|138
operator|,
name|min_count
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curlen
operator|==
name|nextlen
condition|)
block|{
name|max_count
operator|=
literal|6
operator|,
name|min_count
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|max_count
operator|=
literal|7
operator|,
name|min_count
operator|=
literal|4
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Send a literal or distance tree in compressed form, using the codes in  * bl_tree.  */
end_comment

begin_function
name|local
name|void
name|send_tree
parameter_list|(
name|s
parameter_list|,
name|tree
parameter_list|,
name|max_code
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|ct_data
modifier|*
name|tree
decl_stmt|;
comment|/* the tree to be scanned */
name|int
name|max_code
decl_stmt|;
comment|/* and its largest code of non zero frequency */
block|{
name|int
name|n
decl_stmt|;
comment|/* iterates over all tree elements */
name|int
name|prevlen
init|=
operator|-
literal|1
decl_stmt|;
comment|/* last emitted length */
name|int
name|curlen
decl_stmt|;
comment|/* length of current code */
name|int
name|nextlen
init|=
name|tree
index|[
literal|0
index|]
operator|.
name|Len
decl_stmt|;
comment|/* length of next code */
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* repeat count of the current code */
name|int
name|max_count
init|=
literal|7
decl_stmt|;
comment|/* max repeat count */
name|int
name|min_count
init|=
literal|4
decl_stmt|;
comment|/* min repeat count */
comment|/* tree[max_code+1].Len = -1; */
comment|/* guard already set */
if|if
condition|(
name|nextlen
operator|==
literal|0
condition|)
name|max_count
operator|=
literal|138
operator|,
name|min_count
operator|=
literal|3
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<=
name|max_code
condition|;
name|n
operator|++
control|)
block|{
name|curlen
operator|=
name|nextlen
expr_stmt|;
name|nextlen
operator|=
name|tree
index|[
name|n
operator|+
literal|1
index|]
operator|.
name|Len
expr_stmt|;
if|if
condition|(
operator|++
name|count
operator|<
name|max_count
operator|&&
name|curlen
operator|==
name|nextlen
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
name|count
operator|<
name|min_count
condition|)
block|{
do|do
block|{
name|send_code
argument_list|(
name|s
argument_list|,
name|curlen
argument_list|,
name|s
operator|->
name|bl_tree
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|count
operator|!=
literal|0
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|curlen
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|curlen
operator|!=
name|prevlen
condition|)
block|{
name|send_code
argument_list|(
name|s
argument_list|,
name|curlen
argument_list|,
name|s
operator|->
name|bl_tree
argument_list|)
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
name|Assert
argument_list|(
name|count
operator|>=
literal|3
operator|&&
name|count
operator|<=
literal|6
argument_list|,
literal|" 3_6?"
argument_list|)
expr_stmt|;
name|send_code
argument_list|(
name|s
argument_list|,
name|REP_3_6
argument_list|,
name|s
operator|->
name|bl_tree
argument_list|)
expr_stmt|;
name|send_bits
argument_list|(
name|s
argument_list|,
name|count
operator|-
literal|3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|<=
literal|10
condition|)
block|{
name|send_code
argument_list|(
name|s
argument_list|,
name|REPZ_3_10
argument_list|,
name|s
operator|->
name|bl_tree
argument_list|)
expr_stmt|;
name|send_bits
argument_list|(
name|s
argument_list|,
name|count
operator|-
literal|3
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|send_code
argument_list|(
name|s
argument_list|,
name|REPZ_11_138
argument_list|,
name|s
operator|->
name|bl_tree
argument_list|)
expr_stmt|;
name|send_bits
argument_list|(
name|s
argument_list|,
name|count
operator|-
literal|11
argument_list|,
literal|7
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|prevlen
operator|=
name|curlen
expr_stmt|;
if|if
condition|(
name|nextlen
operator|==
literal|0
condition|)
block|{
name|max_count
operator|=
literal|138
operator|,
name|min_count
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|curlen
operator|==
name|nextlen
condition|)
block|{
name|max_count
operator|=
literal|6
operator|,
name|min_count
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|max_count
operator|=
literal|7
operator|,
name|min_count
operator|=
literal|4
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Construct the Huffman tree for the bit lengths and return the index in  * bl_order of the last bit length code to send.  */
end_comment

begin_function
name|local
name|int
name|build_bl_tree
parameter_list|(
name|s
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|max_blindex
decl_stmt|;
comment|/* index of last bit length code of non zero freq */
comment|/* Determine the bit length frequencies for literal and distance trees */
name|scan_tree
argument_list|(
name|s
argument_list|,
operator|(
name|ct_data
operator|*
operator|)
name|s
operator|->
name|dyn_ltree
argument_list|,
name|s
operator|->
name|l_desc
operator|.
name|max_code
argument_list|)
expr_stmt|;
name|scan_tree
argument_list|(
name|s
argument_list|,
operator|(
name|ct_data
operator|*
operator|)
name|s
operator|->
name|dyn_dtree
argument_list|,
name|s
operator|->
name|d_desc
operator|.
name|max_code
argument_list|)
expr_stmt|;
comment|/* Build the bit length tree: */
name|build_tree
argument_list|(
name|s
argument_list|,
operator|(
name|tree_desc
operator|*
operator|)
operator|(
operator|&
operator|(
name|s
operator|->
name|bl_desc
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* opt_len now includes the length of the tree representations, except      * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.      */
comment|/* Determine the number of bit length codes to send. The pkzip format      * requires that at least 4 bit length codes be sent. (appnote.txt says      * 3 but the actual value used is 4.)      */
for|for
control|(
name|max_blindex
operator|=
name|BL_CODES
operator|-
literal|1
init|;
name|max_blindex
operator|>=
literal|3
condition|;
name|max_blindex
operator|--
control|)
block|{
if|if
condition|(
name|s
operator|->
name|bl_tree
index|[
name|bl_order
index|[
name|max_blindex
index|]
index|]
operator|.
name|Len
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* Update opt_len to include the bit length tree and counts */
name|s
operator|->
name|opt_len
operator|+=
literal|3
operator|*
operator|(
name|max_blindex
operator|+
literal|1
operator|)
operator|+
literal|5
operator|+
literal|5
operator|+
literal|4
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"\ndyn trees: dyn %ld, stat %ld"
operator|,
name|s
operator|->
name|opt_len
operator|,
name|s
operator|->
name|static_len
operator|)
argument_list|)
expr_stmt|;
return|return
name|max_blindex
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Send the header for a block using dynamic Huffman trees: the counts, the  * lengths of the bit length codes, the literal tree and the distance tree.  * IN assertion: lcodes>= 257, dcodes>= 1, blcodes>= 4.  */
end_comment

begin_function
name|local
name|void
name|send_all_trees
parameter_list|(
name|s
parameter_list|,
name|lcodes
parameter_list|,
name|dcodes
parameter_list|,
name|blcodes
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|int
name|lcodes
decl_stmt|,
name|dcodes
decl_stmt|,
name|blcodes
decl_stmt|;
comment|/* number of codes for each tree */
block|{
name|int
name|rank
decl_stmt|;
comment|/* index in bl_order */
name|Assert
argument_list|(
name|lcodes
operator|>=
literal|257
operator|&&
name|dcodes
operator|>=
literal|1
operator|&&
name|blcodes
operator|>=
literal|4
argument_list|,
literal|"not enough codes"
argument_list|)
expr_stmt|;
name|Assert
argument_list|(
name|lcodes
operator|<=
name|L_CODES
operator|&&
name|dcodes
operator|<=
name|D_CODES
operator|&&
name|blcodes
operator|<=
name|BL_CODES
argument_list|,
literal|"too many codes"
argument_list|)
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"\nbl counts: "
operator|)
argument_list|)
expr_stmt|;
name|send_bits
argument_list|(
name|s
argument_list|,
name|lcodes
operator|-
literal|257
argument_list|,
literal|5
argument_list|)
expr_stmt|;
comment|/* not +255 as stated in appnote.txt */
name|send_bits
argument_list|(
name|s
argument_list|,
name|dcodes
operator|-
literal|1
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|send_bits
argument_list|(
name|s
argument_list|,
name|blcodes
operator|-
literal|4
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* not -3 as stated in appnote.txt */
for|for
control|(
name|rank
operator|=
literal|0
init|;
name|rank
operator|<
name|blcodes
condition|;
name|rank
operator|++
control|)
block|{
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"\nbl code %2d "
operator|,
name|bl_order
index|[
name|rank
index|]
operator|)
argument_list|)
expr_stmt|;
name|send_bits
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|bl_tree
index|[
name|bl_order
index|[
name|rank
index|]
index|]
operator|.
name|Len
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"\nbl tree: sent %ld"
operator|,
name|s
operator|->
name|bits_sent
operator|)
argument_list|)
expr_stmt|;
name|send_tree
argument_list|(
name|s
argument_list|,
operator|(
name|ct_data
operator|*
operator|)
name|s
operator|->
name|dyn_ltree
argument_list|,
name|lcodes
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* literal tree */
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"\nlit tree: sent %ld"
operator|,
name|s
operator|->
name|bits_sent
operator|)
argument_list|)
expr_stmt|;
name|send_tree
argument_list|(
name|s
argument_list|,
operator|(
name|ct_data
operator|*
operator|)
name|s
operator|->
name|dyn_dtree
argument_list|,
name|dcodes
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* distance tree */
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"\ndist tree: sent %ld"
operator|,
name|s
operator|->
name|bits_sent
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Send a stored block  */
end_comment

begin_function
name|local
name|void
name|ct_stored_block
parameter_list|(
name|s
parameter_list|,
name|buf
parameter_list|,
name|stored_len
parameter_list|,
name|eof
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|charf
modifier|*
name|buf
decl_stmt|;
comment|/* input block */
name|ulg
name|stored_len
decl_stmt|;
comment|/* length of input block */
name|int
name|eof
decl_stmt|;
comment|/* true if this is the last block for a file */
block|{
name|send_bits
argument_list|(
name|s
argument_list|,
operator|(
name|STORED_BLOCK
operator|<<
literal|1
operator|)
operator|+
name|eof
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* send block type */
name|s
operator|->
name|compressed_len
operator|=
operator|(
name|s
operator|->
name|compressed_len
operator|+
literal|3
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7L
expr_stmt|;
name|s
operator|->
name|compressed_len
operator|+=
operator|(
name|stored_len
operator|+
literal|4
operator|)
operator|<<
literal|3
expr_stmt|;
name|copy_block
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
operator|(
name|unsigned
operator|)
name|stored_len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* with header */
block|}
end_function

begin_comment
comment|/* Send just the `stored block' type code without any length bytes or data.  */
end_comment

begin_function
name|local
name|void
name|ct_stored_type_only
parameter_list|(
name|s
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
block|{
name|send_bits
argument_list|(
name|s
argument_list|,
operator|(
name|STORED_BLOCK
operator|<<
literal|1
operator|)
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|bi_windup
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|compressed_len
operator|=
operator|(
name|s
operator|->
name|compressed_len
operator|+
literal|3
operator|)
operator|&
operator|~
literal|7L
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Send one empty static block to give enough lookahead for inflate.  * This takes 10 bits, of which 7 may remain in the bit buffer.  * The current inflate code requires 9 bits of lookahead. If the EOB  * code for the previous block was coded on 5 bits or less, inflate  * may have only 5+3 bits of lookahead to decode this EOB.  * (There are no problems if the previous block is stored or fixed.)  */
end_comment

begin_function
name|local
name|void
name|ct_align
parameter_list|(
name|s
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
block|{
name|send_bits
argument_list|(
name|s
argument_list|,
name|STATIC_TREES
operator|<<
literal|1
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|send_code
argument_list|(
name|s
argument_list|,
name|END_BLOCK
argument_list|,
name|static_ltree
argument_list|)
expr_stmt|;
name|s
operator|->
name|compressed_len
operator|+=
literal|10L
expr_stmt|;
comment|/* 3 for block type, 7 for EOB */
name|bi_flush
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Of the 10 bits for the empty block, we have already sent      * (10 - bi_valid) bits. The lookahead for the EOB of the previous      * block was thus its length plus what we have just sent.      */
if|if
condition|(
name|s
operator|->
name|last_eob_len
operator|+
literal|10
operator|-
name|s
operator|->
name|bi_valid
operator|<
literal|9
condition|)
block|{
name|send_bits
argument_list|(
name|s
argument_list|,
name|STATIC_TREES
operator|<<
literal|1
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|send_code
argument_list|(
name|s
argument_list|,
name|END_BLOCK
argument_list|,
name|static_ltree
argument_list|)
expr_stmt|;
name|s
operator|->
name|compressed_len
operator|+=
literal|10L
expr_stmt|;
name|bi_flush
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|last_eob_len
operator|=
literal|7
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Determine the best encoding for the current block: dynamic trees, static  * trees or store, and output the encoded block to the zip file. This function  * returns the total compressed length for the file so far.  */
end_comment

begin_function
name|local
name|ulg
name|ct_flush_block
parameter_list|(
name|s
parameter_list|,
name|buf
parameter_list|,
name|stored_len
parameter_list|,
name|flush
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|charf
modifier|*
name|buf
decl_stmt|;
comment|/* input block, or NULL if too old */
name|ulg
name|stored_len
decl_stmt|;
comment|/* length of input block */
name|int
name|flush
decl_stmt|;
comment|/* Z_FINISH if this is the last block for a file */
block|{
name|ulg
name|opt_lenb
decl_stmt|,
name|static_lenb
decl_stmt|;
comment|/* opt_len and static_len in bytes */
name|int
name|max_blindex
decl_stmt|;
comment|/* index of last bit length code of non zero freq */
name|int
name|eof
init|=
name|flush
operator|==
name|Z_FINISH
decl_stmt|;
operator|++
name|s
operator|->
name|blocks_in_packet
expr_stmt|;
comment|/* Check if the file is ascii or binary */
if|if
condition|(
name|s
operator|->
name|data_type
operator|==
name|UNKNOWN
condition|)
name|set_data_type
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Construct the literal and distance trees */
name|build_tree
argument_list|(
name|s
argument_list|,
operator|(
name|tree_desc
operator|*
operator|)
operator|(
operator|&
operator|(
name|s
operator|->
name|l_desc
operator|)
operator|)
argument_list|)
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"\nlit data: dyn %ld, stat %ld"
operator|,
name|s
operator|->
name|opt_len
operator|,
name|s
operator|->
name|static_len
operator|)
argument_list|)
expr_stmt|;
name|build_tree
argument_list|(
name|s
argument_list|,
operator|(
name|tree_desc
operator|*
operator|)
operator|(
operator|&
operator|(
name|s
operator|->
name|d_desc
operator|)
operator|)
argument_list|)
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"\ndist data: dyn %ld, stat %ld"
operator|,
name|s
operator|->
name|opt_len
operator|,
name|s
operator|->
name|static_len
operator|)
argument_list|)
expr_stmt|;
comment|/* At this point, opt_len and static_len are the total bit lengths of      * the compressed block data, excluding the tree representations.      */
comment|/* Build the bit length tree for the above two trees, and get the index      * in bl_order of the last bit length code to send.      */
name|max_blindex
operator|=
name|build_bl_tree
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Determine the best encoding. Compute first the block length in bytes */
name|opt_lenb
operator|=
operator|(
name|s
operator|->
name|opt_len
operator|+
literal|3
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
name|static_lenb
operator|=
operator|(
name|s
operator|->
name|static_len
operator|+
literal|3
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u "
operator|,
name|opt_lenb
operator|,
name|s
operator|->
name|opt_len
operator|,
name|static_lenb
operator|,
name|s
operator|->
name|static_len
operator|,
name|stored_len
operator|,
name|s
operator|->
name|last_lit
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|static_lenb
operator|<=
name|opt_lenb
condition|)
name|opt_lenb
operator|=
name|static_lenb
expr_stmt|;
comment|/* If compression failed and this is the first and last block,      * and if the .zip file can be seeked (to rewrite the local header),      * the whole file is transformed into a stored file:      */
ifdef|#
directive|ifdef
name|STORED_FILE_OK
ifdef|#
directive|ifdef
name|FORCE_STORED_FILE
if|if
condition|(
name|eof
operator|&&
name|compressed_len
operator|==
literal|0L
condition|)
comment|/* force stored file */
else|#
directive|else
if|if
condition|(
name|stored_len
operator|<=
name|opt_lenb
operator|&&
name|eof
operator|&&
name|s
operator|->
name|compressed_len
operator|==
literal|0L
operator|&&
name|seekable
argument_list|()
condition|)
endif|#
directive|endif
block|{
comment|/* Since LIT_BUFSIZE<= 2*WSIZE, the input data must be there: */
if|if
condition|(
name|buf
operator|==
operator|(
name|charf
operator|*
operator|)
literal|0
condition|)
name|error
argument_list|(
literal|"block vanished"
argument_list|)
expr_stmt|;
name|copy_block
argument_list|(
name|buf
argument_list|,
operator|(
name|unsigned
operator|)
name|stored_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* without header */
name|s
operator|->
name|compressed_len
operator|=
name|stored_len
operator|<<
literal|3
expr_stmt|;
name|s
operator|->
name|method
operator|=
name|STORED
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
comment|/* STORED_FILE_OK */
comment|/* For Z_PACKET_FLUSH, if we don't achieve the required minimum      * compression, and this block contains all the data since the last      * time we used Z_PACKET_FLUSH, then just omit this block completely      * from the output.      */
if|if
condition|(
name|flush
operator|==
name|Z_PACKET_FLUSH
operator|&&
name|s
operator|->
name|blocks_in_packet
operator|==
literal|1
operator|&&
name|opt_lenb
operator|>
name|stored_len
operator|-
name|s
operator|->
name|minCompr
condition|)
block|{
name|s
operator|->
name|blocks_in_packet
operator|=
literal|0
expr_stmt|;
comment|/* output nothing */
block|}
elseif|else
ifdef|#
directive|ifdef
name|FORCE_STORED
if|if
condition|(
name|buf
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
comment|/* force stored block */
else|#
directive|else
if|if
condition|(
name|stored_len
operator|+
literal|4
operator|<=
name|opt_lenb
operator|&&
name|buf
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
comment|/* 4: two words for the lengths */
endif|#
directive|endif
block|{
comment|/* The test buf != NULL is only necessary if LIT_BUFSIZE> WSIZE.          * Otherwise we can't have processed more than WSIZE input bytes since          * the last block flush, because compression would have been          * successful. If LIT_BUFSIZE<= WSIZE, it is never too late to          * transform a block into a stored block.          */
name|ct_stored_block
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|stored_len
argument_list|,
name|eof
argument_list|)
expr_stmt|;
block|}
elseif|else
ifdef|#
directive|ifdef
name|FORCE_STATIC
if|if
condition|(
name|static_lenb
operator|>=
literal|0
condition|)
comment|/* force static trees */
else|#
directive|else
if|if
condition|(
name|static_lenb
operator|==
name|opt_lenb
condition|)
endif|#
directive|endif
block|{
name|send_bits
argument_list|(
name|s
argument_list|,
operator|(
name|STATIC_TREES
operator|<<
literal|1
operator|)
operator|+
name|eof
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|compress_block
argument_list|(
name|s
argument_list|,
operator|(
name|ct_data
operator|*
operator|)
name|static_ltree
argument_list|,
operator|(
name|ct_data
operator|*
operator|)
name|static_dtree
argument_list|)
expr_stmt|;
name|s
operator|->
name|compressed_len
operator|+=
literal|3
operator|+
name|s
operator|->
name|static_len
expr_stmt|;
block|}
else|else
block|{
name|send_bits
argument_list|(
name|s
argument_list|,
operator|(
name|DYN_TREES
operator|<<
literal|1
operator|)
operator|+
name|eof
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|send_all_trees
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|l_desc
operator|.
name|max_code
operator|+
literal|1
argument_list|,
name|s
operator|->
name|d_desc
operator|.
name|max_code
operator|+
literal|1
argument_list|,
name|max_blindex
operator|+
literal|1
argument_list|)
expr_stmt|;
name|compress_block
argument_list|(
name|s
argument_list|,
operator|(
name|ct_data
operator|*
operator|)
name|s
operator|->
name|dyn_ltree
argument_list|,
operator|(
name|ct_data
operator|*
operator|)
name|s
operator|->
name|dyn_dtree
argument_list|)
expr_stmt|;
name|s
operator|->
name|compressed_len
operator|+=
literal|3
operator|+
name|s
operator|->
name|opt_len
expr_stmt|;
block|}
name|Assert
argument_list|(
name|s
operator|->
name|compressed_len
operator|==
name|s
operator|->
name|bits_sent
argument_list|,
literal|"bad compressed size"
argument_list|)
expr_stmt|;
name|init_block
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|eof
condition|)
block|{
name|bi_windup
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|->
name|compressed_len
operator|+=
literal|7
expr_stmt|;
comment|/* align on byte boundary */
block|}
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"\ncomprlen %lu(%lu) "
operator|,
name|s
operator|->
name|compressed_len
operator|>>
literal|3
operator|,
name|s
operator|->
name|compressed_len
operator|-
literal|7
operator|*
name|eof
operator|)
argument_list|)
expr_stmt|;
return|return
name|s
operator|->
name|compressed_len
operator|>>
literal|3
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Save the match info and tally the frequency counts. Return true if  * the current block must be flushed.  */
end_comment

begin_function
name|local
name|int
name|ct_tally
parameter_list|(
name|s
parameter_list|,
name|dist
parameter_list|,
name|lc
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|int
name|dist
decl_stmt|;
comment|/* distance of matched string */
name|int
name|lc
decl_stmt|;
comment|/* match length-MIN_MATCH or unmatched char (if dist==0) */
block|{
name|s
operator|->
name|d_buf
index|[
name|s
operator|->
name|last_lit
index|]
operator|=
operator|(
name|ush
operator|)
name|dist
expr_stmt|;
name|s
operator|->
name|l_buf
index|[
name|s
operator|->
name|last_lit
operator|++
index|]
operator|=
operator|(
name|uch
operator|)
name|lc
expr_stmt|;
if|if
condition|(
name|dist
operator|==
literal|0
condition|)
block|{
comment|/* lc is the unmatched char */
name|s
operator|->
name|dyn_ltree
index|[
name|lc
index|]
operator|.
name|Freq
operator|++
expr_stmt|;
block|}
else|else
block|{
name|s
operator|->
name|matches
operator|++
expr_stmt|;
comment|/* Here, lc is the match length - MIN_MATCH */
name|dist
operator|--
expr_stmt|;
comment|/* dist = match distance - 1 */
name|Assert
argument_list|(
operator|(
name|ush
operator|)
name|dist
operator|<
operator|(
name|ush
operator|)
name|MAX_DIST
argument_list|(
name|s
argument_list|)
operator|&&
operator|(
name|ush
operator|)
name|lc
operator|<=
call|(
name|ush
call|)
argument_list|(
name|MAX_MATCH
operator|-
name|MIN_MATCH
argument_list|)
operator|&&
operator|(
name|ush
operator|)
name|d_code
argument_list|(
name|dist
argument_list|)
operator|<
operator|(
name|ush
operator|)
name|D_CODES
argument_list|,
literal|"ct_tally: bad match"
argument_list|)
expr_stmt|;
name|s
operator|->
name|dyn_ltree
index|[
name|length_code
index|[
name|lc
index|]
operator|+
name|LITERALS
operator|+
literal|1
index|]
operator|.
name|Freq
operator|++
expr_stmt|;
name|s
operator|->
name|dyn_dtree
index|[
name|d_code
argument_list|(
name|dist
argument_list|)
index|]
operator|.
name|Freq
operator|++
expr_stmt|;
block|}
comment|/* Try to guess if it is profitable to stop the current block here */
if|if
condition|(
name|s
operator|->
name|level
operator|>
literal|2
operator|&&
operator|(
name|s
operator|->
name|last_lit
operator|&
literal|0xfff
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Compute an upper bound for the compressed length */
name|ulg
name|out_length
init|=
operator|(
name|ulg
operator|)
name|s
operator|->
name|last_lit
operator|*
literal|8L
decl_stmt|;
name|ulg
name|in_length
init|=
operator|(
name|ulg
operator|)
name|s
operator|->
name|strstart
operator|-
name|s
operator|->
name|block_start
decl_stmt|;
name|int
name|dcode
decl_stmt|;
for|for
control|(
name|dcode
operator|=
literal|0
init|;
name|dcode
operator|<
name|D_CODES
condition|;
name|dcode
operator|++
control|)
block|{
name|out_length
operator|+=
operator|(
name|ulg
operator|)
name|s
operator|->
name|dyn_dtree
index|[
name|dcode
index|]
operator|.
name|Freq
operator|*
operator|(
literal|5L
operator|+
name|extra_dbits
index|[
name|dcode
index|]
operator|)
expr_stmt|;
block|}
name|out_length
operator|>>=
literal|3
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"\nlast_lit %u, in %ld, out ~%ld(%ld%%) "
operator|,
name|s
operator|->
name|last_lit
operator|,
name|in_length
operator|,
name|out_length
operator|,
literal|100L
operator|-
name|out_length
operator|*
literal|100L
operator|/
name|in_length
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|matches
operator|<
name|s
operator|->
name|last_lit
operator|/
literal|2
operator|&&
name|out_length
operator|<
name|in_length
operator|/
literal|2
condition|)
return|return
literal|1
return|;
block|}
return|return
operator|(
name|s
operator|->
name|last_lit
operator|==
name|s
operator|->
name|lit_bufsize
operator|-
literal|1
operator|)
return|;
comment|/* We avoid equality with lit_bufsize because of wraparound at 64K      * on 16 bit machines and because stored blocks are restricted to      * 64K-1 bytes.      */
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Send the block data compressed using the given Huffman trees  */
end_comment

begin_function
name|local
name|void
name|compress_block
parameter_list|(
name|s
parameter_list|,
name|ltree
parameter_list|,
name|dtree
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|ct_data
modifier|*
name|ltree
decl_stmt|;
comment|/* literal tree */
name|ct_data
modifier|*
name|dtree
decl_stmt|;
comment|/* distance tree */
block|{
name|unsigned
name|dist
decl_stmt|;
comment|/* distance of matched string */
name|int
name|lc
decl_stmt|;
comment|/* match length or unmatched char (if dist == 0) */
name|unsigned
name|lx
init|=
literal|0
decl_stmt|;
comment|/* running index in l_buf */
name|unsigned
name|code
decl_stmt|;
comment|/* the code to send */
name|int
name|extra
decl_stmt|;
comment|/* number of extra bits to send */
if|if
condition|(
name|s
operator|->
name|last_lit
operator|!=
literal|0
condition|)
do|do
block|{
name|dist
operator|=
name|s
operator|->
name|d_buf
index|[
name|lx
index|]
expr_stmt|;
name|lc
operator|=
name|s
operator|->
name|l_buf
index|[
name|lx
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|dist
operator|==
literal|0
condition|)
block|{
name|send_code
argument_list|(
name|s
argument_list|,
name|lc
argument_list|,
name|ltree
argument_list|)
expr_stmt|;
comment|/* send a literal byte */
name|Tracecv
argument_list|(
name|isgraph
argument_list|(
name|lc
argument_list|)
argument_list|,
operator|(
name|stderr
operator|,
literal|" '%c' "
operator|,
name|lc
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Here, lc is the match length - MIN_MATCH */
name|code
operator|=
name|length_code
index|[
name|lc
index|]
expr_stmt|;
name|send_code
argument_list|(
name|s
argument_list|,
name|code
operator|+
name|LITERALS
operator|+
literal|1
argument_list|,
name|ltree
argument_list|)
expr_stmt|;
comment|/* send the length code */
name|extra
operator|=
name|extra_lbits
index|[
name|code
index|]
expr_stmt|;
if|if
condition|(
name|extra
operator|!=
literal|0
condition|)
block|{
name|lc
operator|-=
name|base_length
index|[
name|code
index|]
expr_stmt|;
name|send_bits
argument_list|(
name|s
argument_list|,
name|lc
argument_list|,
name|extra
argument_list|)
expr_stmt|;
comment|/* send the extra length bits */
block|}
name|dist
operator|--
expr_stmt|;
comment|/* dist is now the match distance - 1 */
name|code
operator|=
name|d_code
argument_list|(
name|dist
argument_list|)
expr_stmt|;
name|Assert
argument_list|(
name|code
operator|<
name|D_CODES
argument_list|,
literal|"bad d_code"
argument_list|)
expr_stmt|;
name|send_code
argument_list|(
name|s
argument_list|,
name|code
argument_list|,
name|dtree
argument_list|)
expr_stmt|;
comment|/* send the distance code */
name|extra
operator|=
name|extra_dbits
index|[
name|code
index|]
expr_stmt|;
if|if
condition|(
name|extra
operator|!=
literal|0
condition|)
block|{
name|dist
operator|-=
name|base_dist
index|[
name|code
index|]
expr_stmt|;
name|send_bits
argument_list|(
name|s
argument_list|,
name|dist
argument_list|,
name|extra
argument_list|)
expr_stmt|;
comment|/* send the extra distance bits */
block|}
block|}
comment|/* literal or match pair ? */
comment|/* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
name|Assert
argument_list|(
name|s
operator|->
name|pending
operator|<
name|s
operator|->
name|lit_bufsize
operator|+
literal|2
operator|*
name|lx
argument_list|,
literal|"pendingBuf overflow"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|lx
operator|<
name|s
operator|->
name|last_lit
condition|)
do|;
name|send_code
argument_list|(
name|s
argument_list|,
name|END_BLOCK
argument_list|,
name|ltree
argument_list|)
expr_stmt|;
name|s
operator|->
name|last_eob_len
operator|=
name|ltree
index|[
name|END_BLOCK
index|]
operator|.
name|Len
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Set the data type to ASCII or Z_BINARY, using a crude approximation:  * binary if more than 20% of the bytes are<= 6 or>= 128, ascii otherwise.  * IN assertion: the fields freq of dyn_ltree are set and the total of all  * frequencies does not exceed 64K (to fit in an int on 16 bit machines).  */
end_comment

begin_function
name|local
name|void
name|set_data_type
parameter_list|(
name|s
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|unsigned
name|ascii_freq
init|=
literal|0
decl_stmt|;
name|unsigned
name|bin_freq
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|n
operator|<
literal|7
condition|)
name|bin_freq
operator|+=
name|s
operator|->
name|dyn_ltree
index|[
name|n
operator|++
index|]
operator|.
name|Freq
expr_stmt|;
while|while
condition|(
name|n
operator|<
literal|128
condition|)
name|ascii_freq
operator|+=
name|s
operator|->
name|dyn_ltree
index|[
name|n
operator|++
index|]
operator|.
name|Freq
expr_stmt|;
while|while
condition|(
name|n
operator|<
name|LITERALS
condition|)
name|bin_freq
operator|+=
name|s
operator|->
name|dyn_ltree
index|[
name|n
operator|++
index|]
operator|.
name|Freq
expr_stmt|;
name|s
operator|->
name|data_type
operator|=
call|(
name|Byte
call|)
argument_list|(
name|bin_freq
operator|>
operator|(
name|ascii_freq
operator|>>
literal|2
operator|)
condition|?
name|Z_BINARY
else|:
name|ASCII
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Reverse the first len bits of a code, using straightforward code (a faster  * method would use a table)  * IN assertion: 1<= len<= 15  */
end_comment

begin_function
name|local
name|unsigned
name|bi_reverse
parameter_list|(
name|code
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|code
decl_stmt|;
comment|/* the value to invert */
name|int
name|len
decl_stmt|;
comment|/* its bit length */
block|{
specifier|register
name|unsigned
name|res
init|=
literal|0
decl_stmt|;
do|do
block|{
name|res
operator||=
name|code
operator|&
literal|1
expr_stmt|;
name|code
operator|>>=
literal|1
operator|,
name|res
operator|<<=
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|len
operator|>
literal|0
condition|)
do|;
return|return
name|res
operator|>>
literal|1
return|;
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Flush the bit buffer, keeping at most 7 bits in it.  */
end_comment

begin_function
name|local
name|void
name|bi_flush
parameter_list|(
name|s
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|bi_valid
operator|==
literal|16
condition|)
block|{
name|put_short
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|bi_buf
argument_list|)
expr_stmt|;
name|s
operator|->
name|bi_buf
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|bi_valid
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|bi_valid
operator|>=
literal|8
condition|)
block|{
name|put_byte
argument_list|(
name|s
argument_list|,
operator|(
name|Byte
operator|)
name|s
operator|->
name|bi_buf
argument_list|)
expr_stmt|;
name|s
operator|->
name|bi_buf
operator|>>=
literal|8
expr_stmt|;
name|s
operator|->
name|bi_valid
operator|-=
literal|8
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Flush the bit buffer and align the output on a byte boundary  */
end_comment

begin_function
name|local
name|void
name|bi_windup
parameter_list|(
name|s
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|bi_valid
operator|>
literal|8
condition|)
block|{
name|put_short
argument_list|(
name|s
argument_list|,
name|s
operator|->
name|bi_buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|s
operator|->
name|bi_valid
operator|>
literal|0
condition|)
block|{
name|put_byte
argument_list|(
name|s
argument_list|,
operator|(
name|Byte
operator|)
name|s
operator|->
name|bi_buf
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|bi_buf
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|bi_valid
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_ZLIB
name|s
operator|->
name|bits_sent
operator|=
operator|(
name|s
operator|->
name|bits_sent
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* ===========================================================================  * Copy a stored block, storing first the length and its  * one's complement if requested.  */
end_comment

begin_function
name|local
name|void
name|copy_block
parameter_list|(
name|s
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|,
name|header
parameter_list|)
name|deflate_state
modifier|*
name|s
decl_stmt|;
name|charf
modifier|*
name|buf
decl_stmt|;
comment|/* the input data */
name|unsigned
name|len
decl_stmt|;
comment|/* its length */
name|int
name|header
decl_stmt|;
comment|/* true if block header must be written */
block|{
name|bi_windup
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* align on byte boundary */
name|s
operator|->
name|last_eob_len
operator|=
literal|8
expr_stmt|;
comment|/* enough lookahead for inflate */
if|if
condition|(
name|header
condition|)
block|{
name|put_short
argument_list|(
name|s
argument_list|,
operator|(
name|ush
operator|)
name|len
argument_list|)
expr_stmt|;
name|put_short
argument_list|(
name|s
argument_list|,
operator|(
name|ush
operator|)
operator|~
name|len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_ZLIB
name|s
operator|->
name|bits_sent
operator|+=
literal|2
operator|*
literal|16
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|DEBUG_ZLIB
name|s
operator|->
name|bits_sent
operator|+=
operator|(
name|ulg
operator|)
name|len
operator|<<
literal|3
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|len
operator|--
condition|)
block|{
name|put_byte
argument_list|(
name|s
argument_list|,
operator|*
name|buf
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*+++++*/
end_comment

begin_comment
comment|/* infblock.h -- header to use infblock.c  * Copyright (C) 1995 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h   */
end_comment

begin_comment
comment|/* WARNING: this file should *not* be used by applications. It is    part of the implementation of the compression library and is    subject to change. Applications should only use zlib.h.  */
end_comment

begin_struct_decl
struct_decl|struct
name|inflate_blocks_state
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|struct
name|inflate_blocks_state
name|FAR
name|inflate_blocks_statef
typedef|;
end_typedef

begin_decl_stmt
name|local
name|inflate_blocks_statef
modifier|*
name|inflate_blocks_new
name|OF
argument_list|(
operator|(
name|z_stream
operator|*
name|z
operator|,
name|check_func
name|c
operator|,
comment|/* check function */
name|uInt
name|w
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* window size */
end_comment

begin_decl_stmt
name|local
name|int
name|inflate_blocks
name|OF
argument_list|(
operator|(
name|inflate_blocks_statef
operator|*
operator|,
name|z_stream
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initial return code */
end_comment

begin_decl_stmt
name|local
name|void
name|inflate_blocks_reset
name|OF
argument_list|(
operator|(
name|inflate_blocks_statef
operator|*
operator|,
name|z_stream
operator|*
operator|,
name|uLongf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* check value on output */
end_comment

begin_decl_stmt
name|local
name|int
name|inflate_blocks_free
name|OF
argument_list|(
operator|(
name|inflate_blocks_statef
operator|*
operator|,
name|z_stream
operator|*
operator|,
name|uLongf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* check value on output */
end_comment

begin_decl_stmt
name|local
name|int
name|inflate_addhistory
name|OF
argument_list|(
operator|(
name|inflate_blocks_statef
operator|*
operator|,
name|z_stream
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|inflate_packet_flush
name|OF
argument_list|(
operator|(
name|inflate_blocks_statef
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*+++++*/
end_comment

begin_comment
comment|/* inftrees.h -- header to use inftrees.c  * Copyright (C) 1995 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h   */
end_comment

begin_comment
comment|/* WARNING: this file should *not* be used by applications. It is    part of the implementation of the compression library and is    subject to change. Applications should only use zlib.h.  */
end_comment

begin_comment
comment|/* Huffman code lookup table entry--this entry is four bytes for machines    that have 16-bit pointers (e.g. PC's in the small or medium model). */
end_comment

begin_typedef
typedef|typedef
name|struct
name|inflate_huft_s
name|FAR
name|inflate_huft
typedef|;
end_typedef

begin_struct
struct|struct
name|inflate_huft_s
block|{
union|union
block|{
struct|struct
block|{
name|Byte
name|Exop
decl_stmt|;
comment|/* number of extra bits or operation */
name|Byte
name|Bits
decl_stmt|;
comment|/* number of bits in this code or subcode */
block|}
name|what
struct|;
name|uInt
name|Nalloc
decl_stmt|;
comment|/* number of these allocated here */
name|Bytef
modifier|*
name|pad
decl_stmt|;
comment|/* pad structure to a power of 2 (4 bytes for */
block|}
name|word
union|;
comment|/*  16-bit, 8 bytes for 32-bit machines) */
union|union
block|{
name|uInt
name|Base
decl_stmt|;
comment|/* literal, length base, or distance base */
name|inflate_huft
modifier|*
name|Next
decl_stmt|;
comment|/* pointer to next level of table */
block|}
name|more
union|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_ZLIB
end_ifdef

begin_decl_stmt
name|local
name|uInt
name|inflate_hufts
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|local
name|int
name|inflate_trees_bits
name|OF
argument_list|(
operator|(
name|uIntf
operator|*
operator|,
comment|/* 19 code lengths */
name|uIntf
operator|*
operator|,
comment|/* bits tree desired/actual depth */
name|inflate_huft
operator|*
name|FAR
operator|*
operator|,
comment|/* bits tree result */
name|z_stream
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for zalloc, zfree functions */
end_comment

begin_decl_stmt
name|local
name|int
name|inflate_trees_dynamic
name|OF
argument_list|(
operator|(
name|uInt
operator|,
comment|/* number of literal/length codes */
name|uInt
operator|,
comment|/* number of distance codes */
name|uIntf
operator|*
operator|,
comment|/* that many (total) code lengths */
name|uIntf
operator|*
operator|,
comment|/* literal desired/actual bit depth */
name|uIntf
operator|*
operator|,
comment|/* distance desired/actual bit depth */
name|inflate_huft
operator|*
name|FAR
operator|*
operator|,
comment|/* literal/length tree result */
name|inflate_huft
operator|*
name|FAR
operator|*
operator|,
comment|/* distance tree result */
name|z_stream
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for zalloc, zfree functions */
end_comment

begin_decl_stmt
name|local
name|int
name|inflate_trees_fixed
name|OF
argument_list|(
operator|(
name|uIntf
operator|*
operator|,
comment|/* literal desired/actual bit depth */
name|uIntf
operator|*
operator|,
comment|/* distance desired/actual bit depth */
name|inflate_huft
operator|*
name|FAR
operator|*
operator|,
comment|/* literal/length tree result */
name|inflate_huft
operator|*
name|FAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* distance tree result */
end_comment

begin_decl_stmt
name|local
name|int
name|inflate_trees_free
name|OF
argument_list|(
operator|(
name|inflate_huft
operator|*
operator|,
comment|/* tables to free */
name|z_stream
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for zfree function */
end_comment

begin_comment
comment|/*+++++*/
end_comment

begin_comment
comment|/* infcodes.h -- header to use infcodes.c  * Copyright (C) 1995 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h   */
end_comment

begin_comment
comment|/* WARNING: this file should *not* be used by applications. It is    part of the implementation of the compression library and is    subject to change. Applications should only use zlib.h.  */
end_comment

begin_struct_decl
struct_decl|struct
name|inflate_codes_state
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|struct
name|inflate_codes_state
name|FAR
name|inflate_codes_statef
typedef|;
end_typedef

begin_decl_stmt
name|local
name|inflate_codes_statef
modifier|*
name|inflate_codes_new
name|OF
argument_list|(
operator|(
name|uInt
operator|,
name|uInt
operator|,
name|inflate_huft
operator|*
operator|,
name|inflate_huft
operator|*
operator|,
name|z_stream
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|inflate_codes
name|OF
argument_list|(
operator|(
name|inflate_blocks_statef
operator|*
operator|,
name|z_stream
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|inflate_codes_free
name|OF
argument_list|(
operator|(
name|inflate_codes_statef
operator|*
operator|,
name|z_stream
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*+++++*/
end_comment

begin_comment
comment|/* inflate.c -- zlib interface to inflate modules  * Copyright (C) 1995 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h   */
end_comment

begin_comment
comment|/* inflate private state */
end_comment

begin_struct
struct|struct
name|internal_state
block|{
comment|/* mode */
enum|enum
block|{
name|METHOD
block|,
comment|/* waiting for method byte */
name|FLAG
block|,
comment|/* waiting for flag byte */
name|BLOCKS
block|,
comment|/* decompressing blocks */
name|CHECK4
block|,
comment|/* four check bytes to go */
name|CHECK3
block|,
comment|/* three check bytes to go */
name|CHECK2
block|,
comment|/* two check bytes to go */
name|CHECK1
block|,
comment|/* one check byte to go */
name|DONE
block|,
comment|/* finished check, done */
name|BAD
block|}
comment|/* got an error--stay here */
name|mode
enum|;
comment|/* current inflate mode */
comment|/* mode dependent information */
union|union
block|{
name|uInt
name|method
decl_stmt|;
comment|/* if FLAGS, method byte */
struct|struct
block|{
name|uLong
name|was
decl_stmt|;
comment|/* computed check value */
name|uLong
name|need
decl_stmt|;
comment|/* stream check value */
block|}
name|check
struct|;
comment|/* if CHECK, check values to compare */
name|uInt
name|marker
decl_stmt|;
comment|/* if BAD, inflateSync's marker bytes count */
block|}
name|sub
union|;
comment|/* submode */
comment|/* mode independent information */
name|int
name|nowrap
decl_stmt|;
comment|/* flag for no wrapper */
name|uInt
name|wbits
decl_stmt|;
comment|/* log2(window size)  (8..15, defaults to 15) */
name|inflate_blocks_statef
modifier|*
name|blocks
decl_stmt|;
comment|/* current inflate_blocks state */
block|}
struct|;
end_struct

begin_function
name|int
name|inflateReset
parameter_list|(
name|z
parameter_list|)
name|z_stream
modifier|*
name|z
decl_stmt|;
block|{
name|uLong
name|c
decl_stmt|;
if|if
condition|(
name|z
operator|==
name|Z_NULL
operator|||
name|z
operator|->
name|state
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|z
operator|->
name|total_in
operator|=
name|z
operator|->
name|total_out
operator|=
literal|0
expr_stmt|;
name|z
operator|->
name|msg
operator|=
name|Z_NULL
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|z
operator|->
name|state
operator|->
name|nowrap
condition|?
name|BLOCKS
else|:
name|METHOD
expr_stmt|;
name|inflate_blocks_reset
argument_list|(
name|z
operator|->
name|state
operator|->
name|blocks
argument_list|,
name|z
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
name|Trace
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate: reset\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_function
name|int
name|inflateEnd
parameter_list|(
name|z
parameter_list|)
name|z_stream
modifier|*
name|z
decl_stmt|;
block|{
name|uLong
name|c
decl_stmt|;
if|if
condition|(
name|z
operator|==
name|Z_NULL
operator|||
name|z
operator|->
name|state
operator|==
name|Z_NULL
operator|||
name|z
operator|->
name|zfree
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
if|if
condition|(
name|z
operator|->
name|state
operator|->
name|blocks
operator|!=
name|Z_NULL
condition|)
name|inflate_blocks_free
argument_list|(
name|z
operator|->
name|state
operator|->
name|blocks
argument_list|,
name|z
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
name|ZFREE
argument_list|(
name|z
argument_list|,
name|z
operator|->
name|state
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_state
argument_list|)
argument_list|)
expr_stmt|;
name|z
operator|->
name|state
operator|=
name|Z_NULL
expr_stmt|;
name|Trace
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate: end\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_function
name|int
name|inflateInit2
parameter_list|(
name|z
parameter_list|,
name|w
parameter_list|)
name|z_stream
modifier|*
name|z
decl_stmt|;
name|int
name|w
decl_stmt|;
block|{
comment|/* initialize state */
if|if
condition|(
name|z
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
comment|/*  if (z->zalloc == Z_NULL) z->zalloc = zcalloc; */
comment|/*  if (z->zfree == Z_NULL) z->zfree = zcfree; */
if|if
condition|(
operator|(
name|z
operator|->
name|state
operator|=
operator|(
expr|struct
name|internal_state
name|FAR
operator|*
operator|)
name|ZALLOC_INIT
argument_list|(
name|z
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|internal_state
argument_list|)
argument_list|)
operator|)
operator|==
name|Z_NULL
condition|)
return|return
name|Z_MEM_ERROR
return|;
name|z
operator|->
name|state
operator|->
name|blocks
operator|=
name|Z_NULL
expr_stmt|;
comment|/* handle undocumented nowrap option (no zlib header or check) */
name|z
operator|->
name|state
operator|->
name|nowrap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|w
operator|<
literal|0
condition|)
block|{
name|w
operator|=
operator|-
name|w
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|nowrap
operator|=
literal|1
expr_stmt|;
block|}
comment|/* set window size */
if|if
condition|(
name|w
operator|<
literal|8
operator|||
name|w
operator|>
literal|15
condition|)
block|{
name|inflateEnd
argument_list|(
name|z
argument_list|)
expr_stmt|;
return|return
name|Z_STREAM_ERROR
return|;
block|}
name|z
operator|->
name|state
operator|->
name|wbits
operator|=
operator|(
name|uInt
operator|)
name|w
expr_stmt|;
comment|/* create inflate_blocks state */
if|if
condition|(
operator|(
name|z
operator|->
name|state
operator|->
name|blocks
operator|=
name|inflate_blocks_new
argument_list|(
name|z
argument_list|,
name|z
operator|->
name|state
operator|->
name|nowrap
condition|?
name|Z_NULL
else|:
name|adler32
argument_list|,
literal|1
operator|<<
name|w
argument_list|)
operator|)
operator|==
name|Z_NULL
condition|)
block|{
name|inflateEnd
argument_list|(
name|z
argument_list|)
expr_stmt|;
return|return
name|Z_MEM_ERROR
return|;
block|}
name|Trace
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate: allocated\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* reset state */
name|inflateReset
argument_list|(
name|z
argument_list|)
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_function
name|int
name|inflateInit
parameter_list|(
name|z
parameter_list|)
name|z_stream
modifier|*
name|z
decl_stmt|;
block|{
return|return
name|inflateInit2
argument_list|(
name|z
argument_list|,
name|DEF_WBITS
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NEEDBYTE
value|{if(z->avail_in==0)goto empty;r=Z_OK;}
end_define

begin_define
define|#
directive|define
name|NEXTBYTE
value|(z->avail_in--,z->total_in++,*z->next_in++)
end_define

begin_function
name|int
name|inflate
parameter_list|(
name|z
parameter_list|,
name|f
parameter_list|)
name|z_stream
modifier|*
name|z
decl_stmt|;
name|int
name|f
decl_stmt|;
block|{
name|int
name|r
decl_stmt|;
name|uInt
name|b
decl_stmt|;
if|if
condition|(
name|z
operator|==
name|Z_NULL
operator|||
name|z
operator|->
name|next_in
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
name|r
operator|=
name|Z_BUF_ERROR
expr_stmt|;
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|z
operator|->
name|state
operator|->
name|mode
condition|)
block|{
case|case
name|METHOD
case|:
name|NEEDBYTE
if|if
condition|(
operator|(
operator|(
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|method
operator|=
name|NEXTBYTE
operator|)
operator|&
literal|0xf
operator|)
operator|!=
name|DEFLATED
condition|)
block|{
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|msg
operator|=
literal|"unknown compression method"
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
operator|=
literal|5
expr_stmt|;
comment|/* can't try inflateSync */
break|break;
block|}
if|if
condition|(
operator|(
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|method
operator|>>
literal|4
operator|)
operator|+
literal|8
operator|>
name|z
operator|->
name|state
operator|->
name|wbits
condition|)
block|{
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|msg
operator|=
literal|"invalid window size"
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
operator|=
literal|5
expr_stmt|;
comment|/* can't try inflateSync */
break|break;
block|}
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|FLAG
expr_stmt|;
case|case
name|FLAG
case|:
name|NEEDBYTE
if|if
condition|(
operator|(
name|b
operator|=
name|NEXTBYTE
operator|)
operator|&
literal|0x20
condition|)
block|{
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|msg
operator|=
literal|"invalid reserved bit"
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
operator|=
literal|5
expr_stmt|;
comment|/* can't try inflateSync */
break|break;
block|}
if|if
condition|(
operator|(
operator|(
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|method
operator|<<
literal|8
operator|)
operator|+
name|b
operator|)
operator|%
literal|31
condition|)
block|{
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|msg
operator|=
literal|"incorrect header check"
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
operator|=
literal|5
expr_stmt|;
comment|/* can't try inflateSync */
break|break;
block|}
name|Trace
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate: zlib header ok\n"
operator|)
argument_list|)
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BLOCKS
expr_stmt|;
case|case
name|BLOCKS
case|:
name|r
operator|=
name|inflate_blocks
argument_list|(
name|z
operator|->
name|state
operator|->
name|blocks
argument_list|,
name|z
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
name|Z_PACKET_FLUSH
operator|&&
name|z
operator|->
name|avail_in
operator|==
literal|0
operator|&&
name|z
operator|->
name|avail_out
operator|!=
literal|0
condition|)
name|r
operator|=
name|inflate_packet_flush
argument_list|(
name|z
operator|->
name|state
operator|->
name|blocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|Z_DATA_ERROR
condition|)
block|{
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
operator|=
literal|0
expr_stmt|;
comment|/* can try inflateSync */
break|break;
block|}
if|if
condition|(
name|r
operator|!=
name|Z_STREAM_END
condition|)
return|return
name|r
return|;
name|r
operator|=
name|Z_OK
expr_stmt|;
name|inflate_blocks_reset
argument_list|(
name|z
operator|->
name|state
operator|->
name|blocks
argument_list|,
name|z
argument_list|,
operator|&
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|was
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|->
name|state
operator|->
name|nowrap
condition|)
block|{
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|DONE
expr_stmt|;
break|break;
block|}
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|CHECK4
expr_stmt|;
case|case
name|CHECK4
case|:
name|NEEDBYTE
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
init|=
operator|(
name|uLong
operator|)
name|NEXTBYTE
operator|<<
literal|24
decl_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|CHECK3
expr_stmt|;
case|case
name|CHECK3
case|:
name|NEEDBYTE
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
operator|+=
operator|(
name|uLong
operator|)
name|NEXTBYTE
operator|<<
literal|16
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|CHECK2
expr_stmt|;
case|case
name|CHECK2
case|:
name|NEEDBYTE
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
operator|+=
operator|(
name|uLong
operator|)
name|NEXTBYTE
operator|<<
literal|8
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|CHECK1
expr_stmt|;
case|case
name|CHECK1
case|:
name|NEEDBYTE
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
operator|+=
operator|(
name|uLong
operator|)
name|NEXTBYTE
expr_stmt|;
if|if
condition|(
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|was
operator|!=
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|check
operator|.
name|need
condition|)
block|{
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|msg
operator|=
literal|"incorrect data check"
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
operator|=
literal|5
expr_stmt|;
comment|/* can't try inflateSync */
break|break;
block|}
name|Trace
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate: zlib check ok\n"
operator|)
argument_list|)
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|DONE
expr_stmt|;
case|case
name|DONE
case|:
return|return
name|Z_STREAM_END
return|;
case|case
name|BAD
case|:
return|return
name|Z_DATA_ERROR
return|;
default|default:
return|return
name|Z_STREAM_ERROR
return|;
block|}
name|empty
label|:
if|if
condition|(
name|f
operator|!=
name|Z_PACKET_FLUSH
condition|)
return|return
name|r
return|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
operator|=
literal|0
expr_stmt|;
comment|/* can try inflateSync */
return|return
name|Z_DATA_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * This subroutine adds the data at next_in/avail_in to the output history  * without performing any output.  The output buffer must be "caught up";  * i.e. no pending output (hence s->read equals s->write), and the state must  * be BLOCKS (i.e. we should be willing to see the start of a series of  * BLOCKS).  On exit, the output will also be caught up, and the checksum  * will have been updated if need be.  */
end_comment

begin_function
name|int
name|inflateIncomp
parameter_list|(
name|z
parameter_list|)
name|z_stream
modifier|*
name|z
decl_stmt|;
block|{
if|if
condition|(
name|z
operator|->
name|state
operator|->
name|mode
operator|!=
name|BLOCKS
condition|)
return|return
name|Z_DATA_ERROR
return|;
return|return
name|inflate_addhistory
argument_list|(
name|z
operator|->
name|state
operator|->
name|blocks
argument_list|,
name|z
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|inflateSync
parameter_list|(
name|z
parameter_list|)
name|z_stream
modifier|*
name|z
decl_stmt|;
block|{
name|uInt
name|n
decl_stmt|;
comment|/* number of bytes to look at */
name|Bytef
modifier|*
name|p
decl_stmt|;
comment|/* pointer to bytes */
name|uInt
name|m
decl_stmt|;
comment|/* number of marker bytes found in a row */
name|uLong
name|r
decl_stmt|,
name|w
decl_stmt|;
comment|/* temporaries to save total_in and total_out */
comment|/* set up */
if|if
condition|(
name|z
operator|==
name|Z_NULL
operator|||
name|z
operator|->
name|state
operator|==
name|Z_NULL
condition|)
return|return
name|Z_STREAM_ERROR
return|;
if|if
condition|(
name|z
operator|->
name|state
operator|->
name|mode
operator|!=
name|BAD
condition|)
block|{
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BAD
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|z
operator|->
name|avail_in
operator|)
operator|==
literal|0
condition|)
return|return
name|Z_BUF_ERROR
return|;
name|p
operator|=
name|z
operator|->
name|next_in
expr_stmt|;
name|m
operator|=
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
expr_stmt|;
comment|/* search */
while|while
condition|(
name|n
operator|&&
name|m
operator|<
literal|4
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
call|(
name|Byte
call|)
argument_list|(
name|m
operator|<
literal|2
condition|?
literal|0
else|:
literal|0xff
argument_list|)
condition|)
name|m
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
condition|)
name|m
operator|=
literal|0
expr_stmt|;
else|else
name|m
operator|=
literal|4
operator|-
name|m
expr_stmt|;
name|p
operator|++
operator|,
name|n
operator|--
expr_stmt|;
block|}
comment|/* restore */
name|z
operator|->
name|total_in
operator|+=
name|p
operator|-
name|z
operator|->
name|next_in
expr_stmt|;
name|z
operator|->
name|next_in
operator|=
name|p
expr_stmt|;
name|z
operator|->
name|avail_in
operator|=
name|n
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|sub
operator|.
name|marker
operator|=
name|m
expr_stmt|;
comment|/* return no joy or set up to restart on a new block */
if|if
condition|(
name|m
operator|!=
literal|4
condition|)
return|return
name|Z_DATA_ERROR
return|;
name|r
operator|=
name|z
operator|->
name|total_in
expr_stmt|;
name|w
operator|=
name|z
operator|->
name|total_out
expr_stmt|;
name|inflateReset
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|z
operator|->
name|total_in
operator|=
name|r
expr_stmt|;
name|z
operator|->
name|total_out
operator|=
name|w
expr_stmt|;
name|z
operator|->
name|state
operator|->
name|mode
operator|=
name|BLOCKS
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|NEEDBYTE
end_undef

begin_undef
undef|#
directive|undef
name|NEXTBYTE
end_undef

begin_comment
comment|/*+++++*/
end_comment

begin_comment
comment|/* infutil.h -- types and macros common to blocks and codes  * Copyright (C) 1995 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h   */
end_comment

begin_comment
comment|/* WARNING: this file should *not* be used by applications. It is    part of the implementation of the compression library and is    subject to change. Applications should only use zlib.h.  */
end_comment

begin_comment
comment|/* inflate blocks semi-private state */
end_comment

begin_struct
struct|struct
name|inflate_blocks_state
block|{
comment|/* mode */
enum|enum
block|{
name|TYPE
block|,
comment|/* get type bits (3, including end bit) */
name|LENS
block|,
comment|/* get lengths for stored */
name|STORED
block|,
comment|/* processing stored block */
name|TABLE
block|,
comment|/* get table lengths */
name|BTREE
block|,
comment|/* get bit lengths tree for a dynamic block */
name|DTREE
block|,
comment|/* get length, distance trees for a dynamic block */
name|CODES
block|,
comment|/* processing fixed or dynamic block */
name|DRY
block|,
comment|/* output remaining window bytes */
name|DONEB
block|,
comment|/* finished last block, done */
name|BADB
block|}
comment|/* got a data error--stuck here */
name|mode
enum|;
comment|/* current inflate_block mode */
comment|/* mode dependent information */
union|union
block|{
name|uInt
name|left
decl_stmt|;
comment|/* if STORED, bytes left to copy */
struct|struct
block|{
name|uInt
name|table
decl_stmt|;
comment|/* table lengths (14 bits) */
name|uInt
name|index
decl_stmt|;
comment|/* index into blens (or border) */
name|uIntf
modifier|*
name|blens
decl_stmt|;
comment|/* bit lengths of codes */
name|uInt
name|bb
decl_stmt|;
comment|/* bit length tree depth */
name|inflate_huft
modifier|*
name|tb
decl_stmt|;
comment|/* bit length decoding tree */
name|int
name|nblens
decl_stmt|;
comment|/* # elements allocated at blens */
block|}
name|trees
struct|;
comment|/* if DTREE, decoding info for trees */
struct|struct
block|{
name|inflate_huft
modifier|*
name|tl
decl_stmt|,
modifier|*
name|td
decl_stmt|;
comment|/* trees to free */
name|inflate_codes_statef
modifier|*
name|codes
decl_stmt|;
block|}
name|decode
struct|;
comment|/* if CODES, current state */
block|}
name|sub
union|;
comment|/* submode */
name|uInt
name|last
decl_stmt|;
comment|/* true if this block is the last block */
comment|/* mode independent information */
name|uInt
name|bitk
decl_stmt|;
comment|/* bits in bit buffer */
name|uLong
name|bitb
decl_stmt|;
comment|/* bit buffer */
name|Bytef
modifier|*
name|window
decl_stmt|;
comment|/* sliding window */
name|Bytef
modifier|*
name|end
decl_stmt|;
comment|/* one byte after sliding window */
name|Bytef
modifier|*
name|read
decl_stmt|;
comment|/* window read pointer */
name|Bytef
modifier|*
name|write
decl_stmt|;
comment|/* window write pointer */
name|check_func
name|checkfn
decl_stmt|;
comment|/* check function */
name|uLong
name|check
decl_stmt|;
comment|/* check on output */
block|}
struct|;
end_struct

begin_comment
comment|/* defines for inflate input/output */
end_comment

begin_comment
comment|/*   update pointers and return */
end_comment

begin_define
define|#
directive|define
name|UPDBITS
value|{s->bitb=b;s->bitk=k;}
end_define

begin_define
define|#
directive|define
name|UPDIN
value|{z->avail_in=n;z->total_in+=p-z->next_in;z->next_in=p;}
end_define

begin_define
define|#
directive|define
name|UPDOUT
value|{s->write=q;}
end_define

begin_define
define|#
directive|define
name|UPDATE
value|{UPDBITS UPDIN UPDOUT}
end_define

begin_define
define|#
directive|define
name|LEAVE
value|{UPDATE return inflate_flush(s,z,r);}
end_define

begin_comment
comment|/*   get bytes and bits */
end_comment

begin_define
define|#
directive|define
name|LOADIN
value|{p=z->next_in;n=z->avail_in;b=s->bitb;k=s->bitk;}
end_define

begin_define
define|#
directive|define
name|NEEDBYTE
value|{if(n)r=Z_OK;else LEAVE}
end_define

begin_define
define|#
directive|define
name|NEXTBYTE
value|(n--,*p++)
end_define

begin_define
define|#
directive|define
name|NEEDBITS
parameter_list|(
name|j
parameter_list|)
value|{while(k<(j)){NEEDBYTE;b|=((uLong)NEXTBYTE)<<k;k+=8;}}
end_define

begin_define
define|#
directive|define
name|DUMPBITS
parameter_list|(
name|j
parameter_list|)
value|{b>>=(j);k-=(j);}
end_define

begin_comment
comment|/*   output bytes */
end_comment

begin_define
define|#
directive|define
name|WAVAIL
value|(q<s->read?s->read-q-1:s->end-q)
end_define

begin_define
define|#
directive|define
name|LOADOUT
value|{q=s->write;m=WAVAIL;}
end_define

begin_define
define|#
directive|define
name|WRAP
value|{if(q==s->end&&s->read!=s->window){q=s->window;m=WAVAIL;}}
end_define

begin_define
define|#
directive|define
name|FLUSH
value|{UPDOUT r=inflate_flush(s,z,r); LOADOUT}
end_define

begin_define
define|#
directive|define
name|NEEDOUT
value|{if(m==0){WRAP if(m==0){FLUSH WRAP if(m==0) LEAVE}}r=Z_OK;}
end_define

begin_define
define|#
directive|define
name|OUTBYTE
parameter_list|(
name|a
parameter_list|)
value|{*q++=(Byte)(a);m--;}
end_define

begin_comment
comment|/*   load local pointers */
end_comment

begin_define
define|#
directive|define
name|LOAD
value|{LOADIN LOADOUT}
end_define

begin_comment
comment|/* And'ing with mask[n] masks the lower n bits */
end_comment

begin_decl_stmt
name|local
name|uInt
name|inflate_mask
index|[]
init|=
block|{
literal|0x0000
block|,
literal|0x0001
block|,
literal|0x0003
block|,
literal|0x0007
block|,
literal|0x000f
block|,
literal|0x001f
block|,
literal|0x003f
block|,
literal|0x007f
block|,
literal|0x00ff
block|,
literal|0x01ff
block|,
literal|0x03ff
block|,
literal|0x07ff
block|,
literal|0x0fff
block|,
literal|0x1fff
block|,
literal|0x3fff
block|,
literal|0x7fff
block|,
literal|0xffff
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* copy as much as possible from the sliding window to the output area */
end_comment

begin_decl_stmt
name|local
name|int
name|inflate_flush
name|OF
argument_list|(
operator|(
name|inflate_blocks_statef
operator|*
operator|,
name|z_stream
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*+++++*/
end_comment

begin_comment
comment|/* inffast.h -- header to use inffast.c  * Copyright (C) 1995 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h   */
end_comment

begin_comment
comment|/* WARNING: this file should *not* be used by applications. It is    part of the implementation of the compression library and is    subject to change. Applications should only use zlib.h.  */
end_comment

begin_decl_stmt
name|local
name|int
name|inflate_fast
name|OF
argument_list|(
operator|(
name|uInt
operator|,
name|uInt
operator|,
name|inflate_huft
operator|*
operator|,
name|inflate_huft
operator|*
operator|,
name|inflate_blocks_statef
operator|*
operator|,
name|z_stream
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*+++++*/
end_comment

begin_comment
comment|/* infblock.c -- interpret and process block types to last block  * Copyright (C) 1995 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h   */
end_comment

begin_comment
comment|/* Table for deflate from PKZIP's appnote.txt. */
end_comment

begin_decl_stmt
name|local
name|uInt
name|border
index|[]
init|=
block|{
comment|/* Order of the bit length code lengths */
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|0
block|,
literal|8
block|,
literal|7
block|,
literal|9
block|,
literal|6
block|,
literal|10
block|,
literal|5
block|,
literal|11
block|,
literal|4
block|,
literal|12
block|,
literal|3
block|,
literal|13
block|,
literal|2
block|,
literal|14
block|,
literal|1
block|,
literal|15
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    Notes beyond the 1.93a appnote.txt:     1. Distance pointers never point before the beginning of the output       stream.    2. Distance pointers can point back across blocks, up to 32k away.    3. There is an implied maximum of 7 bits for the bit length table and       15 bits for the actual data.    4. If only one code exists, then it is encoded using one bit.  (Zero       would be more efficient, but perhaps a little confusing.)  If two       codes exist, they are coded using one bit each (0 and 1).    5. There is no way of sending zero distance codes--a dummy must be       sent if there are none.  (History: a pre 2.0 version of PKZIP would       store blocks with no distance codes, but this was discovered to be       too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow       zero distance codes, which is sent as one code of zero bits in       length.    6. There are up to 286 literal/length codes.  Code 256 represents the       end-of-block.  Note however that the static length tree defines       288 codes just to fill out the Huffman codes.  Codes 286 and 287       cannot be used though, since there is no length base or extra bits       defined for them.  Similarily, there are up to 30 distance codes.       However, static trees define 32 codes (all 5 bits) to fill out the       Huffman codes, but the last two had better not show up in the data.    7. Unzip can check dynamic Huffman blocks for complete code sets.       The exception is that a single code would not be complete (see #4).    8. The five bits following the block type is really the number of       literal codes sent minus 257.    9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits       (1+6+6).  Therefore, to output three times the length, you output       three codes (1+1+1), whereas to output four times the same length,       you only need two codes (1+3).  Hmm.   10. In the tree reconstruction algorithm, Code = Code + Increment       only if BitLength(i) is not zero.  (Pretty obvious.)   11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)   12. Note: length code 284 can represent 227-258, but length code 285       really is 258.  The last length deserves its own, short code       since it gets used a lot in very redundant files.  The length       258 is special since 258 - 3 (the min match length) is 255.   13. The literal/length and distance code bit lengths are read as a       single stream of lengths.  It is possible (and advantageous) for       a repeat code (16, 17, or 18) to go across the boundary between       the two sets of lengths.  */
end_comment

begin_function
name|local
name|void
name|inflate_blocks_reset
parameter_list|(
name|s
parameter_list|,
name|z
parameter_list|,
name|c
parameter_list|)
name|inflate_blocks_statef
modifier|*
name|s
decl_stmt|;
name|z_stream
modifier|*
name|z
decl_stmt|;
name|uLongf
modifier|*
name|c
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|checkfn
operator|!=
name|Z_NULL
condition|)
operator|*
name|c
operator|=
name|s
operator|->
name|check
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|mode
operator|==
name|BTREE
operator|||
name|s
operator|->
name|mode
operator|==
name|DTREE
condition|)
name|ZFREE
argument_list|(
name|z
argument_list|,
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|blens
argument_list|,
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|nblens
operator|*
sizeof|sizeof
argument_list|(
name|uInt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|mode
operator|==
name|CODES
condition|)
block|{
name|inflate_codes_free
argument_list|(
name|s
operator|->
name|sub
operator|.
name|decode
operator|.
name|codes
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|inflate_trees_free
argument_list|(
name|s
operator|->
name|sub
operator|.
name|decode
operator|.
name|td
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|inflate_trees_free
argument_list|(
name|s
operator|->
name|sub
operator|.
name|decode
operator|.
name|tl
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
name|s
operator|->
name|mode
operator|=
name|TYPE
expr_stmt|;
name|s
operator|->
name|bitk
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|bitb
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|read
operator|=
name|s
operator|->
name|write
operator|=
name|s
operator|->
name|window
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|checkfn
operator|!=
name|Z_NULL
condition|)
name|s
operator|->
name|check
operator|=
call|(
modifier|*
name|s
operator|->
name|checkfn
call|)
argument_list|(
literal|0L
argument_list|,
name|Z_NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|Trace
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:   blocks reset\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|local
name|inflate_blocks_statef
modifier|*
name|inflate_blocks_new
parameter_list|(
name|z
parameter_list|,
name|c
parameter_list|,
name|w
parameter_list|)
name|z_stream
modifier|*
name|z
decl_stmt|;
name|check_func
name|c
decl_stmt|;
name|uInt
name|w
decl_stmt|;
block|{
name|inflate_blocks_statef
modifier|*
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
operator|(
name|inflate_blocks_statef
operator|*
operator|)
name|ZALLOC_INIT
argument_list|(
name|z
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inflate_blocks_state
argument_list|)
argument_list|)
operator|)
operator|==
name|Z_NULL
condition|)
return|return
name|s
return|;
if|if
condition|(
operator|(
name|s
operator|->
name|window
operator|=
operator|(
name|Bytef
operator|*
operator|)
name|ZALLOC_INIT
argument_list|(
name|z
argument_list|,
literal|1
argument_list|,
name|w
argument_list|)
operator|)
operator|==
name|Z_NULL
condition|)
block|{
name|ZFREE
argument_list|(
name|z
argument_list|,
name|s
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inflate_blocks_state
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|Z_NULL
return|;
block|}
name|s
operator|->
name|end
operator|=
name|s
operator|->
name|window
operator|+
name|w
expr_stmt|;
name|s
operator|->
name|checkfn
operator|=
name|c
expr_stmt|;
name|s
operator|->
name|mode
operator|=
name|TYPE
expr_stmt|;
name|Trace
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:   blocks allocated\n"
operator|)
argument_list|)
expr_stmt|;
name|inflate_blocks_reset
argument_list|(
name|s
argument_list|,
name|z
argument_list|,
operator|&
name|s
operator|->
name|check
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|local
name|int
name|inflate_blocks
parameter_list|(
name|s
parameter_list|,
name|z
parameter_list|,
name|r
parameter_list|)
name|inflate_blocks_statef
modifier|*
name|s
decl_stmt|;
name|z_stream
modifier|*
name|z
decl_stmt|;
name|int
name|r
decl_stmt|;
block|{
name|uInt
name|t
decl_stmt|;
comment|/* temporary storage */
name|uLong
name|b
decl_stmt|;
comment|/* bit buffer */
name|uInt
name|k
decl_stmt|;
comment|/* bits in bit buffer */
name|Bytef
modifier|*
name|p
decl_stmt|;
comment|/* input data pointer */
name|uInt
name|n
decl_stmt|;
comment|/* bytes available there */
name|Bytef
modifier|*
name|q
decl_stmt|;
comment|/* output window write pointer */
name|uInt
name|m
decl_stmt|;
comment|/* bytes to end of window or read pointer */
comment|/* copy input/output information to locals (UPDATE macro restores) */
name|LOAD
comment|/* process input based on current state */
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|s
operator|->
name|mode
condition|)
block|{
case|case
name|TYPE
case|:
name|NEEDBITS
argument_list|(
literal|3
argument_list|)
name|t
operator|=
operator|(
name|uInt
operator|)
name|b
operator|&
literal|7
expr_stmt|;
name|s
operator|->
name|last
operator|=
name|t
operator|&
literal|1
expr_stmt|;
switch|switch
condition|(
name|t
operator|>>
literal|1
condition|)
block|{
case|case
literal|0
case|:
comment|/* stored */
name|Trace
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:     stored block%s\n"
operator|,
name|s
operator|->
name|last
condition|?
literal|" (last)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|DUMPBITS
argument_list|(
literal|3
argument_list|)
name|t
operator|=
name|k
operator|&
literal|7
expr_stmt|;
comment|/* go to byte boundary */
name|DUMPBITS
argument_list|(
argument|t
argument_list|)
name|s
operator|->
name|mode
operator|=
name|LENS
expr_stmt|;
comment|/* get length of stored block */
break|break;
case|case
literal|1
case|:
comment|/* fixed */
name|Trace
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:     fixed codes block%s\n"
operator|,
name|s
operator|->
name|last
condition|?
literal|" (last)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|{
name|uInt
name|bl
decl_stmt|,
name|bd
decl_stmt|;
name|inflate_huft
modifier|*
name|tl
decl_stmt|,
modifier|*
name|td
decl_stmt|;
name|inflate_trees_fixed
argument_list|(
operator|&
name|bl
argument_list|,
operator|&
name|bd
argument_list|,
operator|&
name|tl
argument_list|,
operator|&
name|td
argument_list|)
expr_stmt|;
name|s
operator|->
name|sub
operator|.
name|decode
operator|.
name|codes
operator|=
name|inflate_codes_new
argument_list|(
name|bl
argument_list|,
name|bd
argument_list|,
name|tl
argument_list|,
name|td
argument_list|,
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|sub
operator|.
name|decode
operator|.
name|codes
operator|==
name|Z_NULL
condition|)
block|{
name|r
operator|=
name|Z_MEM_ERROR
expr_stmt|;
name|LEAVE
block|}
name|s
operator|->
name|sub
operator|.
name|decode
operator|.
name|tl
operator|=
name|Z_NULL
expr_stmt|;
comment|/* don't try to free these */
name|s
operator|->
name|sub
operator|.
name|decode
operator|.
name|td
operator|=
name|Z_NULL
expr_stmt|;
block|}
name|DUMPBITS
argument_list|(
literal|3
argument_list|)
name|s
operator|->
name|mode
operator|=
name|CODES
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* dynamic */
name|Trace
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:     dynamic codes block%s\n"
operator|,
name|s
operator|->
name|last
condition|?
literal|" (last)"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|DUMPBITS
argument_list|(
literal|3
argument_list|)
name|s
operator|->
name|mode
operator|=
name|TABLE
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* illegal */
name|DUMPBITS
argument_list|(
literal|3
argument_list|)
name|s
operator|->
name|mode
operator|=
name|BADB
expr_stmt|;
name|z
operator|->
name|msg
operator|=
literal|"invalid block type"
expr_stmt|;
name|r
operator|=
name|Z_DATA_ERROR
expr_stmt|;
name|LEAVE
block|}
break|break;
case|case
name|LENS
case|:
name|NEEDBITS
argument_list|(
literal|32
argument_list|)
if|if
condition|(
operator|(
operator|(
operator|~
name|b
operator|)
operator|>>
literal|16
operator|)
operator|!=
operator|(
name|b
operator|&
literal|0xffff
operator|)
condition|)
block|{
name|s
operator|->
name|mode
operator|=
name|BADB
expr_stmt|;
name|z
operator|->
name|msg
operator|=
literal|"invalid stored block lengths"
expr_stmt|;
name|r
operator|=
name|Z_DATA_ERROR
expr_stmt|;
name|LEAVE
block|}
name|s
operator|->
name|sub
operator|.
name|left
operator|=
operator|(
name|uInt
operator|)
name|b
operator|&
literal|0xffff
expr_stmt|;
name|b
operator|=
name|k
operator|=
literal|0
expr_stmt|;
comment|/* dump bits */
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       stored length %u\n"
operator|,
name|s
operator|->
name|sub
operator|.
name|left
operator|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|mode
operator|=
name|s
operator|->
name|sub
operator|.
name|left
condition|?
name|STORED
else|:
name|TYPE
expr_stmt|;
break|break;
case|case
name|STORED
case|:
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|LEAVE
name|NEEDOUT
name|t
init|=
name|s
operator|->
name|sub
operator|.
name|left
decl_stmt|;
if|if
condition|(
name|t
operator|>
name|n
condition|)
name|t
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|t
operator|>
name|m
condition|)
name|t
operator|=
name|m
expr_stmt|;
name|zmemcpy
argument_list|(
name|q
argument_list|,
name|p
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|p
operator|+=
name|t
expr_stmt|;
name|n
operator|-=
name|t
expr_stmt|;
name|q
operator|+=
name|t
expr_stmt|;
name|m
operator|-=
name|t
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|sub
operator|.
name|left
operator|-=
name|t
operator|)
operator|!=
literal|0
condition|)
break|break;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       stored end, %lu total out\n"
operator|,
name|z
operator|->
name|total_out
operator|+
operator|(
name|q
operator|>=
name|s
operator|->
name|read
condition|?
name|q
operator|-
name|s
operator|->
name|read
else|:
operator|(
name|s
operator|->
name|end
operator|-
name|s
operator|->
name|read
operator|)
operator|+
operator|(
name|q
operator|-
name|s
operator|->
name|window
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|mode
operator|=
name|s
operator|->
name|last
condition|?
name|DRY
else|:
name|TYPE
expr_stmt|;
break|break;
case|case
name|TABLE
case|:
name|NEEDBITS
argument_list|(
literal|14
argument_list|)
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|table
operator|=
name|t
operator|=
operator|(
name|uInt
operator|)
name|b
operator|&
literal|0x3fff
expr_stmt|;
ifndef|#
directive|ifndef
name|PKZIP_BUG_WORKAROUND
if|if
condition|(
operator|(
name|t
operator|&
literal|0x1f
operator|)
operator|>
literal|29
operator|||
operator|(
operator|(
name|t
operator|>>
literal|5
operator|)
operator|&
literal|0x1f
operator|)
operator|>
literal|29
condition|)
block|{
name|s
operator|->
name|mode
operator|=
name|BADB
expr_stmt|;
name|z
operator|->
name|msg
operator|=
literal|"too many length or distance symbols"
expr_stmt|;
name|r
operator|=
name|Z_DATA_ERROR
expr_stmt|;
name|LEAVE
block|}
endif|#
directive|endif
name|t
operator|=
literal|258
operator|+
operator|(
name|t
operator|&
literal|0x1f
operator|)
operator|+
operator|(
operator|(
name|t
operator|>>
literal|5
operator|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|<
literal|19
condition|)
name|t
operator|=
literal|19
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|blens
operator|=
operator|(
name|uIntf
operator|*
operator|)
name|ZALLOC
argument_list|(
name|z
argument_list|,
name|t
argument_list|,
sizeof|sizeof
argument_list|(
name|uInt
argument_list|)
argument_list|)
operator|)
operator|==
name|Z_NULL
condition|)
block|{
name|r
operator|=
name|Z_MEM_ERROR
expr_stmt|;
name|LEAVE
block|}
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|nblens
operator|=
name|t
expr_stmt|;
name|DUMPBITS
argument_list|(
literal|14
argument_list|)
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       table sizes ok\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|mode
operator|=
name|BTREE
expr_stmt|;
case|case
name|BTREE
case|:
while|while
condition|(
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|index
operator|<
literal|4
operator|+
operator|(
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|table
operator|>>
literal|10
operator|)
condition|)
block|{
name|NEEDBITS
argument_list|(
literal|3
argument_list|)
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|blens
index|[
name|border
index|[
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|index
operator|++
index|]
index|]
operator|=
operator|(
name|uInt
operator|)
name|b
operator|&
literal|7
expr_stmt|;
name|DUMPBITS
argument_list|(
literal|3
argument_list|)
block|}
while|while
condition|(
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|index
operator|<
literal|19
condition|)
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|blens
index|[
name|border
index|[
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|index
operator|++
index|]
index|]
operator|=
literal|0
expr_stmt|;
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|bb
operator|=
literal|7
expr_stmt|;
name|t
operator|=
name|inflate_trees_bits
argument_list|(
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|blens
argument_list|,
operator|&
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|bb
argument_list|,
operator|&
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|tb
argument_list|,
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|Z_OK
condition|)
block|{
name|r
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|Z_DATA_ERROR
condition|)
name|s
operator|->
name|mode
operator|=
name|BADB
expr_stmt|;
name|LEAVE
block|}
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|index
operator|=
literal|0
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       bits tree ok\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|mode
operator|=
name|DTREE
expr_stmt|;
case|case
name|DTREE
case|:
while|while
condition|(
name|t
operator|=
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|table
operator|,
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|index
operator|<
literal|258
operator|+
operator|(
name|t
operator|&
literal|0x1f
operator|)
operator|+
operator|(
operator|(
name|t
operator|>>
literal|5
operator|)
operator|&
literal|0x1f
operator|)
condition|)
block|{
name|inflate_huft
modifier|*
name|h
decl_stmt|;
name|uInt
name|i
decl_stmt|,
name|j
decl_stmt|,
name|c
decl_stmt|;
name|t
operator|=
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|bb
expr_stmt|;
name|NEEDBITS
argument_list|(
argument|t
argument_list|)
name|h
operator|=
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|tb
operator|+
operator|(
operator|(
name|uInt
operator|)
name|b
operator|&
name|inflate_mask
index|[
name|t
index|]
operator|)
expr_stmt|;
name|t
operator|=
name|h
operator|->
name|word
operator|.
name|what
operator|.
name|Bits
expr_stmt|;
name|c
operator|=
name|h
operator|->
name|more
operator|.
name|Base
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|16
condition|)
block|{
name|DUMPBITS
argument_list|(
argument|t
argument_list|)
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|blens
index|[
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|index
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
else|else
comment|/* c == 16..18 */
block|{
name|i
operator|=
name|c
operator|==
literal|18
condition|?
literal|7
else|:
name|c
operator|-
literal|14
expr_stmt|;
name|j
operator|=
name|c
operator|==
literal|18
condition|?
literal|11
else|:
literal|3
expr_stmt|;
name|NEEDBITS
argument_list|(
argument|t + i
argument_list|)
name|DUMPBITS
argument_list|(
argument|t
argument_list|)
name|j
operator|+=
operator|(
name|uInt
operator|)
name|b
operator|&
name|inflate_mask
index|[
name|i
index|]
expr_stmt|;
name|DUMPBITS
argument_list|(
argument|i
argument_list|)
name|i
operator|=
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|index
expr_stmt|;
name|t
operator|=
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|table
expr_stmt|;
if|if
condition|(
name|i
operator|+
name|j
operator|>
literal|258
operator|+
operator|(
name|t
operator|&
literal|0x1f
operator|)
operator|+
operator|(
operator|(
name|t
operator|>>
literal|5
operator|)
operator|&
literal|0x1f
operator|)
operator|||
operator|(
name|c
operator|==
literal|16
operator|&&
name|i
operator|<
literal|1
operator|)
condition|)
block|{
name|s
operator|->
name|mode
operator|=
name|BADB
expr_stmt|;
name|z
operator|->
name|msg
operator|=
literal|"invalid bit length repeat"
expr_stmt|;
name|r
operator|=
name|Z_DATA_ERROR
expr_stmt|;
name|LEAVE
block|}
name|c
operator|=
name|c
operator|==
literal|16
condition|?
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|blens
index|[
name|i
operator|-
literal|1
index|]
else|:
literal|0
expr_stmt|;
do|do
block|{
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|blens
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|j
condition|)
do|;
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|index
operator|=
name|i
expr_stmt|;
block|}
block|}
name|inflate_trees_free
argument_list|(
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|tb
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|tb
operator|=
name|Z_NULL
expr_stmt|;
block|{
name|uInt
name|bl
decl_stmt|,
name|bd
decl_stmt|;
name|inflate_huft
modifier|*
name|tl
decl_stmt|,
modifier|*
name|td
decl_stmt|;
name|inflate_codes_statef
modifier|*
name|c
decl_stmt|;
name|bl
operator|=
literal|9
expr_stmt|;
comment|/* must be<= 9 for lookahead assumptions */
name|bd
operator|=
literal|6
expr_stmt|;
comment|/* must be<= 9 for lookahead assumptions */
name|t
operator|=
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|table
expr_stmt|;
name|t
operator|=
name|inflate_trees_dynamic
argument_list|(
literal|257
operator|+
operator|(
name|t
operator|&
literal|0x1f
operator|)
argument_list|,
literal|1
operator|+
operator|(
operator|(
name|t
operator|>>
literal|5
operator|)
operator|&
literal|0x1f
operator|)
argument_list|,
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|blens
argument_list|,
operator|&
name|bl
argument_list|,
operator|&
name|bd
argument_list|,
operator|&
name|tl
argument_list|,
operator|&
name|td
argument_list|,
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|Z_OK
condition|)
block|{
if|if
condition|(
name|t
operator|==
operator|(
name|uInt
operator|)
name|Z_DATA_ERROR
condition|)
name|s
operator|->
name|mode
operator|=
name|BADB
expr_stmt|;
name|r
operator|=
name|t
expr_stmt|;
name|LEAVE
block|}
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       trees ok\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|inflate_codes_new
argument_list|(
name|bl
argument_list|,
name|bd
argument_list|,
name|tl
argument_list|,
name|td
argument_list|,
name|z
argument_list|)
operator|)
operator|==
name|Z_NULL
condition|)
block|{
name|inflate_trees_free
argument_list|(
name|td
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|inflate_trees_free
argument_list|(
name|tl
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|r
operator|=
name|Z_MEM_ERROR
expr_stmt|;
name|LEAVE
block|}
name|ZFREE
argument_list|(
name|z
argument_list|,
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|blens
argument_list|,
name|s
operator|->
name|sub
operator|.
name|trees
operator|.
name|nblens
operator|*
sizeof|sizeof
argument_list|(
name|uInt
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|->
name|sub
operator|.
name|decode
operator|.
name|codes
operator|=
name|c
expr_stmt|;
name|s
operator|->
name|sub
operator|.
name|decode
operator|.
name|tl
operator|=
name|tl
expr_stmt|;
name|s
operator|->
name|sub
operator|.
name|decode
operator|.
name|td
operator|=
name|td
expr_stmt|;
block|}
name|s
operator|->
name|mode
operator|=
name|CODES
expr_stmt|;
case|case
name|CODES
case|:
name|UPDATE
if|if
condition|(
operator|(
name|r
operator|=
name|inflate_codes
argument_list|(
name|s
argument_list|,
name|z
argument_list|,
name|r
argument_list|)
operator|)
operator|!=
name|Z_STREAM_END
condition|)
return|return
name|inflate_flush
argument_list|(
name|s
argument_list|,
name|z
argument_list|,
name|r
argument_list|)
return|;
name|r
operator|=
name|Z_OK
expr_stmt|;
name|inflate_codes_free
argument_list|(
name|s
operator|->
name|sub
operator|.
name|decode
operator|.
name|codes
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|inflate_trees_free
argument_list|(
name|s
operator|->
name|sub
operator|.
name|decode
operator|.
name|td
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|inflate_trees_free
argument_list|(
name|s
operator|->
name|sub
operator|.
name|decode
operator|.
name|tl
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|LOAD
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       codes end, %lu total out\n"
operator|,
name|z
operator|->
name|total_out
operator|+
operator|(
name|q
operator|>=
name|s
operator|->
name|read
condition|?
name|q
operator|-
name|s
operator|->
name|read
else|:
operator|(
name|s
operator|->
name|end
operator|-
name|s
operator|->
name|read
operator|)
operator|+
operator|(
name|q
operator|-
name|s
operator|->
name|window
operator|)
operator|)
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
operator|->
name|last
condition|)
block|{
name|s
operator|->
name|mode
operator|=
name|TYPE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|k
operator|>
literal|7
condition|)
comment|/* return unused byte, if any */
block|{
name|Assert
argument_list|(
argument|k<
literal|16
argument_list|,
literal|"inflate_codes grabbed too many bytes"
argument_list|)
name|k
operator|-=
literal|8
expr_stmt|;
name|n
operator|++
expr_stmt|;
name|p
operator|--
expr_stmt|;
comment|/* can always return one */
block|}
name|s
operator|->
name|mode
operator|=
name|DRY
expr_stmt|;
case|case
name|DRY
case|:
name|FLUSH
if|if
condition|(
name|s
operator|->
name|read
operator|!=
name|s
operator|->
name|write
condition|)
name|LEAVE
name|s
operator|->
name|mode
init|=
name|DONEB
decl_stmt|;
case|case
name|DONEB
case|:
name|r
operator|=
name|Z_STREAM_END
expr_stmt|;
name|LEAVE
case|case
name|BADB
case|:
name|r
operator|=
name|Z_DATA_ERROR
expr_stmt|;
name|LEAVE
default|default:
name|r
operator|=
name|Z_STREAM_ERROR
expr_stmt|;
name|LEAVE
block|}
block|}
end_function

begin_function
name|local
name|int
name|inflate_blocks_free
parameter_list|(
name|s
parameter_list|,
name|z
parameter_list|,
name|c
parameter_list|)
name|inflate_blocks_statef
modifier|*
name|s
decl_stmt|;
name|z_stream
modifier|*
name|z
decl_stmt|;
name|uLongf
modifier|*
name|c
decl_stmt|;
block|{
name|inflate_blocks_reset
argument_list|(
name|s
argument_list|,
name|z
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ZFREE
argument_list|(
name|z
argument_list|,
name|s
operator|->
name|window
argument_list|,
name|s
operator|->
name|end
operator|-
name|s
operator|->
name|window
argument_list|)
expr_stmt|;
name|ZFREE
argument_list|(
name|z
argument_list|,
name|s
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inflate_blocks_state
argument_list|)
argument_list|)
expr_stmt|;
name|Trace
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:   blocks freed\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_comment
comment|/*  * This subroutine adds the data at next_in/avail_in to the output history  * without performing any output.  The output buffer must be "caught up";  * i.e. no pending output (hence s->read equals s->write), and the state must  * be BLOCKS (i.e. we should be willing to see the start of a series of  * BLOCKS).  On exit, the output will also be caught up, and the checksum  * will have been updated if need be.  */
end_comment

begin_function
name|local
name|int
name|inflate_addhistory
parameter_list|(
name|s
parameter_list|,
name|z
parameter_list|)
name|inflate_blocks_statef
modifier|*
name|s
decl_stmt|;
name|z_stream
modifier|*
name|z
decl_stmt|;
block|{
name|uLong
name|b
decl_stmt|;
comment|/* bit buffer */
comment|/* NOT USED HERE */
name|uInt
name|k
decl_stmt|;
comment|/* bits in bit buffer */
comment|/* NOT USED HERE */
name|uInt
name|t
decl_stmt|;
comment|/* temporary storage */
name|Bytef
modifier|*
name|p
decl_stmt|;
comment|/* input data pointer */
name|uInt
name|n
decl_stmt|;
comment|/* bytes available there */
name|Bytef
modifier|*
name|q
decl_stmt|;
comment|/* output window write pointer */
name|uInt
name|m
decl_stmt|;
comment|/* bytes to end of window or read pointer */
if|if
condition|(
name|s
operator|->
name|read
operator|!=
name|s
operator|->
name|write
condition|)
return|return
name|Z_STREAM_ERROR
return|;
if|if
condition|(
name|s
operator|->
name|mode
operator|!=
name|TYPE
condition|)
return|return
name|Z_DATA_ERROR
return|;
comment|/* we're ready to rock */
name|LOAD
comment|/* while there is input ready, copy to output buffer, moving      * pointers as needed.      */
while|while
condition|(
name|n
condition|)
block|{
name|t
operator|=
name|n
expr_stmt|;
comment|/* how many to do */
comment|/* is there room until end of buffer? */
if|if
condition|(
name|t
operator|>
name|m
condition|)
name|t
operator|=
name|m
expr_stmt|;
comment|/* update check information */
if|if
condition|(
name|s
operator|->
name|checkfn
operator|!=
name|Z_NULL
condition|)
name|s
operator|->
name|check
operator|=
call|(
modifier|*
name|s
operator|->
name|checkfn
call|)
argument_list|(
name|s
operator|->
name|check
argument_list|,
name|q
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|zmemcpy
argument_list|(
name|q
argument_list|,
name|p
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|q
operator|+=
name|t
expr_stmt|;
name|p
operator|+=
name|t
expr_stmt|;
name|n
operator|-=
name|t
expr_stmt|;
name|z
operator|->
name|total_out
operator|+=
name|t
expr_stmt|;
name|s
operator|->
name|read
operator|=
name|q
expr_stmt|;
comment|/* drag read pointer forward */
comment|/*      WRAP  */
comment|/* expand WRAP macro by hand to handle s->read */
if|if
condition|(
name|q
operator|==
name|s
operator|->
name|end
condition|)
block|{
name|s
operator|->
name|read
operator|=
name|q
operator|=
name|s
operator|->
name|window
expr_stmt|;
name|m
operator|=
name|WAVAIL
expr_stmt|;
block|}
block|}
name|UPDATE
return|return
name|Z_OK
return|;
block|}
end_function

begin_comment
comment|/*  * At the end of a Deflate-compressed PPP packet, we expect to have seen  * a `stored' block type value but not the (zero) length bytes.  */
end_comment

begin_function
name|local
name|int
name|inflate_packet_flush
parameter_list|(
name|s
parameter_list|)
name|inflate_blocks_statef
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|->
name|mode
operator|!=
name|LENS
condition|)
return|return
name|Z_DATA_ERROR
return|;
name|s
operator|->
name|mode
operator|=
name|TYPE
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_comment
comment|/*+++++*/
end_comment

begin_comment
comment|/* inftrees.c -- generate Huffman trees for efficient decoding  * Copyright (C) 1995 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h   */
end_comment

begin_comment
comment|/* simplify the use of the inflate_huft type with some defines */
end_comment

begin_define
define|#
directive|define
name|base
value|more.Base
end_define

begin_define
define|#
directive|define
name|next
value|more.Next
end_define

begin_define
define|#
directive|define
name|exop
value|word.what.Exop
end_define

begin_define
define|#
directive|define
name|bits
value|word.what.Bits
end_define

begin_decl_stmt
name|local
name|int
name|huft_build
name|OF
argument_list|(
operator|(
name|uIntf
operator|*
operator|,
comment|/* code lengths in bits */
name|uInt
operator|,
comment|/* number of codes */
name|uInt
operator|,
comment|/* number of "simple" codes */
name|uIntf
operator|*
operator|,
comment|/* list of base values for non-simple codes */
name|uIntf
operator|*
operator|,
comment|/* list of extra bits for non-simple codes */
name|inflate_huft
operator|*
name|FAR
operator|*
operator|,
comment|/* result: starting table */
name|uIntf
operator|*
operator|,
comment|/* maximum lookup bits (returns actual) */
name|z_stream
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for zalloc function */
end_comment

begin_decl_stmt
name|local
name|voidpf
name|falloc
name|OF
argument_list|(
operator|(
name|voidpf
operator|,
comment|/* opaque pointer (not used) */
name|uInt
operator|,
comment|/* number of items */
name|uInt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of item */
end_comment

begin_decl_stmt
name|local
name|void
name|ffree
name|OF
argument_list|(
operator|(
name|voidpf
name|q
operator|,
comment|/* opaque pointer (not used) */
name|voidpf
name|p
operator|,
comment|/* what to free (not used) */
name|uInt
name|n
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of bytes (not used) */
end_comment

begin_comment
comment|/* Tables for deflate from PKZIP's appnote.txt. */
end_comment

begin_decl_stmt
name|local
name|uInt
name|cplens
index|[]
init|=
block|{
comment|/* Copy lengths for literal codes 257..285 */
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|13
block|,
literal|15
block|,
literal|17
block|,
literal|19
block|,
literal|23
block|,
literal|27
block|,
literal|31
block|,
literal|35
block|,
literal|43
block|,
literal|51
block|,
literal|59
block|,
literal|67
block|,
literal|83
block|,
literal|99
block|,
literal|115
block|,
literal|131
block|,
literal|163
block|,
literal|195
block|,
literal|227
block|,
literal|258
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* actually lengths - 2; also see note #13 above about 258 */
end_comment

begin_decl_stmt
name|local
name|uInt
name|cplext
index|[]
init|=
block|{
comment|/* Extra bits for literal codes 257..285 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|0
block|,
literal|192
block|,
literal|192
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 192==invalid */
end_comment

begin_decl_stmt
name|local
name|uInt
name|cpdist
index|[]
init|=
block|{
comment|/* Copy offsets for distance codes 0..29 */
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|7
block|,
literal|9
block|,
literal|13
block|,
literal|17
block|,
literal|25
block|,
literal|33
block|,
literal|49
block|,
literal|65
block|,
literal|97
block|,
literal|129
block|,
literal|193
block|,
literal|257
block|,
literal|385
block|,
literal|513
block|,
literal|769
block|,
literal|1025
block|,
literal|1537
block|,
literal|2049
block|,
literal|3073
block|,
literal|4097
block|,
literal|6145
block|,
literal|8193
block|,
literal|12289
block|,
literal|16385
block|,
literal|24577
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|uInt
name|cpdext
index|[]
init|=
block|{
comment|/* Extra bits for distance codes */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|8
block|,
literal|8
block|,
literal|9
block|,
literal|9
block|,
literal|10
block|,
literal|10
block|,
literal|11
block|,
literal|11
block|,
literal|12
block|,
literal|12
block|,
literal|13
block|,
literal|13
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*    Huffman code decoding is performed using a multi-level table lookup.    The fastest way to decode is to simply build a lookup table whose    size is determined by the longest code.  However, the time it takes    to build this table can also be a factor if the data being decoded    is not very long.  The most common codes are necessarily the    shortest codes, so those codes dominate the decoding time, and hence    the speed.  The idea is you can have a shorter table that decodes the    shorter, more probable codes, and then point to subsidiary tables for    the longer codes.  The time it costs to decode the longer codes is    then traded against the time it takes to make longer tables.     This results of this trade are in the variables lbits and dbits    below.  lbits is the number of bits the first level table for literal/    length codes can decode in one step, and dbits is the same thing for    the distance codes.  Subsequent tables are also less than or equal to    those sizes.  These values may be adjusted either when all of the    codes are shorter than that, in which case the longest code length in    bits is used, or when the shortest code is *longer* than the requested    table size, in which case the length of the shortest code in bits is    used.     There are two different values for the two tables, since they code a    different number of possibilities each.  The literal/length table    codes 286 possible values, or in a flat code, a little over eight    bits.  The distance table codes 30 possible values, or a little less    than five bits, flat.  The optimum values for speed end up being    about one bit more than those, so lbits is 8+1 and dbits is 5+1.    The optimum values may differ though from machine to machine, and    possibly even between compilers.  Your mileage may vary.  */
end_comment

begin_comment
comment|/* If BMAX needs to be larger than 16, then h and x[] should be uLong. */
end_comment

begin_define
define|#
directive|define
name|BMAX
value|15
end_define

begin_comment
comment|/* maximum bit length of any code */
end_comment

begin_define
define|#
directive|define
name|N_MAX
value|288
end_define

begin_comment
comment|/* maximum number of codes in any set */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_ZLIB
end_ifdef

begin_decl_stmt
name|uInt
name|inflate_hufts
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|local
name|int
name|huft_build
parameter_list|(
name|b
parameter_list|,
name|n
parameter_list|,
name|s
parameter_list|,
name|d
parameter_list|,
name|e
parameter_list|,
name|t
parameter_list|,
name|m
parameter_list|,
name|zs
parameter_list|)
name|uIntf
modifier|*
name|b
decl_stmt|;
comment|/* code lengths in bits (all assumed<= BMAX) */
name|uInt
name|n
decl_stmt|;
comment|/* number of codes (assumed<= N_MAX) */
name|uInt
name|s
decl_stmt|;
comment|/* number of simple-valued codes (0..s-1) */
name|uIntf
modifier|*
name|d
decl_stmt|;
comment|/* list of base values for non-simple codes */
name|uIntf
modifier|*
name|e
decl_stmt|;
comment|/* list of extra bits for non-simple codes */
name|inflate_huft
modifier|*
name|FAR
modifier|*
name|t
decl_stmt|;
comment|/* result: starting table */
name|uIntf
modifier|*
name|m
decl_stmt|;
comment|/* maximum lookup bits, returns actual */
name|z_stream
modifier|*
name|zs
decl_stmt|;
comment|/* for zalloc function */
comment|/* Given a list of code lengths and a maximum table size, make a set of    tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR    if the given code set is incomplete (the tables are still built in this    case), Z_DATA_ERROR if the input is invalid (all zero length codes or an    over-subscribed set of lengths), or Z_MEM_ERROR if not enough memory. */
block|{
name|uInt
name|a
decl_stmt|;
comment|/* counter for codes of length k */
name|uInt
name|c
index|[
name|BMAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* bit length count table */
name|uInt
name|f
decl_stmt|;
comment|/* i repeats in table every f entries */
name|int
name|g
decl_stmt|;
comment|/* maximum code length */
name|int
name|h
decl_stmt|;
comment|/* table level */
specifier|register
name|uInt
name|i
decl_stmt|;
comment|/* counter, current code */
specifier|register
name|uInt
name|j
decl_stmt|;
comment|/* counter */
specifier|register
name|int
name|k
decl_stmt|;
comment|/* number of bits in current code */
name|int
name|l
decl_stmt|;
comment|/* bits per table (returned in m) */
specifier|register
name|uIntf
modifier|*
name|p
decl_stmt|;
comment|/* pointer into c[], b[], or v[] */
name|inflate_huft
modifier|*
name|q
decl_stmt|;
comment|/* points to current table */
name|struct
name|inflate_huft_s
name|r
decl_stmt|;
comment|/* table entry for structure assignment */
name|inflate_huft
modifier|*
name|u
index|[
name|BMAX
index|]
decl_stmt|;
comment|/* table stack */
name|uInt
name|v
index|[
name|N_MAX
index|]
decl_stmt|;
comment|/* values in order of bit length */
specifier|register
name|int
name|w
decl_stmt|;
comment|/* bits before this table == (l * h) */
name|uInt
name|x
index|[
name|BMAX
operator|+
literal|1
index|]
decl_stmt|;
comment|/* bit offsets, then code stack */
name|uIntf
modifier|*
name|xp
decl_stmt|;
comment|/* pointer into x */
name|int
name|y
decl_stmt|;
comment|/* number of dummy codes added */
name|uInt
name|z
decl_stmt|;
comment|/* number of entries in current table */
comment|/* Generate counts for each bit length */
name|p
operator|=
name|c
expr_stmt|;
define|#
directive|define
name|C0
value|*p++ = 0;
define|#
directive|define
name|C2
value|C0 C0 C0 C0
define|#
directive|define
name|C4
value|C2 C2 C2 C2
name|C4
comment|/* clear c[]--assume BMAX+1 is 16 */
name|p
init|=
name|b
decl_stmt|;
name|i
operator|=
name|n
expr_stmt|;
do|do
block|{
name|c
index|[
operator|*
name|p
operator|++
index|]
operator|++
expr_stmt|;
comment|/* assume all entries<= BMAX */
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
if|if
condition|(
name|c
index|[
literal|0
index|]
operator|==
name|n
condition|)
comment|/* null input--all zero length codes */
block|{
operator|*
name|t
operator|=
operator|(
name|inflate_huft
operator|*
operator|)
name|Z_NULL
expr_stmt|;
operator|*
name|m
operator|=
literal|0
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
comment|/* Find minimum and maximum length, bound *m by those */
name|l
operator|=
operator|*
name|m
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|BMAX
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|c
index|[
name|j
index|]
condition|)
break|break;
name|k
operator|=
name|j
expr_stmt|;
comment|/* minimum code length */
if|if
condition|(
operator|(
name|uInt
operator|)
name|l
operator|<
name|j
condition|)
name|l
operator|=
name|j
expr_stmt|;
for|for
control|(
name|i
operator|=
name|BMAX
init|;
name|i
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|c
index|[
name|i
index|]
condition|)
break|break;
name|g
operator|=
name|i
expr_stmt|;
comment|/* maximum code length */
if|if
condition|(
operator|(
name|uInt
operator|)
name|l
operator|>
name|i
condition|)
name|l
operator|=
name|i
expr_stmt|;
operator|*
name|m
operator|=
name|l
expr_stmt|;
comment|/* Adjust last length count to fill out codes, if needed */
for|for
control|(
name|y
operator|=
literal|1
operator|<<
name|j
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
operator|,
name|y
operator|<<=
literal|1
control|)
if|if
condition|(
operator|(
name|y
operator|-=
name|c
index|[
name|j
index|]
operator|)
operator|<
literal|0
condition|)
return|return
name|Z_DATA_ERROR
return|;
if|if
condition|(
operator|(
name|y
operator|-=
name|c
index|[
name|i
index|]
operator|)
operator|<
literal|0
condition|)
return|return
name|Z_DATA_ERROR
return|;
name|c
index|[
name|i
index|]
operator|+=
name|y
expr_stmt|;
comment|/* Generate starting offsets into the value table for each length */
name|x
index|[
literal|1
index|]
operator|=
name|j
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|c
operator|+
literal|1
expr_stmt|;
name|xp
operator|=
name|x
operator|+
literal|2
expr_stmt|;
while|while
condition|(
operator|--
name|i
condition|)
block|{
comment|/* note that i == g from above */
operator|*
name|xp
operator|++
operator|=
operator|(
name|j
operator|+=
operator|*
name|p
operator|++
operator|)
expr_stmt|;
block|}
comment|/* Make a table of values in order of bit lengths */
name|p
operator|=
name|b
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|j
operator|=
operator|*
name|p
operator|++
operator|)
operator|!=
literal|0
condition|)
name|v
index|[
name|x
index|[
name|j
index|]
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|n
condition|)
do|;
comment|/* Generate the Huffman codes and for each, make the table entries */
name|x
index|[
literal|0
index|]
operator|=
name|i
operator|=
literal|0
expr_stmt|;
comment|/* first Huffman code is zero */
name|p
operator|=
name|v
expr_stmt|;
comment|/* grab values in bit order */
name|h
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no tables yet--level -1 */
name|w
operator|=
operator|-
name|l
expr_stmt|;
comment|/* bits decoded == (l * h) */
name|u
index|[
literal|0
index|]
operator|=
operator|(
name|inflate_huft
operator|*
operator|)
name|Z_NULL
expr_stmt|;
comment|/* just to keep compilers happy */
name|q
operator|=
operator|(
name|inflate_huft
operator|*
operator|)
name|Z_NULL
expr_stmt|;
comment|/* ditto */
name|z
operator|=
literal|0
expr_stmt|;
comment|/* ditto */
comment|/* go through the bit lengths (k already is bits in shortest code) */
for|for
control|(
init|;
name|k
operator|<=
name|g
condition|;
name|k
operator|++
control|)
block|{
name|a
operator|=
name|c
index|[
name|k
index|]
expr_stmt|;
while|while
condition|(
name|a
operator|--
condition|)
block|{
comment|/* here i is the Huffman code of length k bits for value *p */
comment|/* make tables up to required level */
while|while
condition|(
name|k
operator|>
name|w
operator|+
name|l
condition|)
block|{
name|h
operator|++
expr_stmt|;
name|w
operator|+=
name|l
expr_stmt|;
comment|/* previous table always l bits */
comment|/* compute minimum size table less than or equal to l bits */
name|z
operator|=
operator|(
name|z
operator|=
name|g
operator|-
name|w
operator|)
operator|>
operator|(
name|uInt
operator|)
name|l
condition|?
name|l
else|:
name|z
expr_stmt|;
comment|/* table size upper limit */
if|if
condition|(
operator|(
name|f
operator|=
literal|1
operator|<<
operator|(
name|j
operator|=
name|k
operator|-
name|w
operator|)
operator|)
operator|>
name|a
operator|+
literal|1
condition|)
comment|/* try a k-w bit table */
block|{
comment|/* too few codes for k-w bit table */
name|f
operator|-=
name|a
operator|+
literal|1
expr_stmt|;
comment|/* deduct codes from patterns left */
name|xp
operator|=
name|c
operator|+
name|k
expr_stmt|;
if|if
condition|(
name|j
operator|<
name|z
condition|)
while|while
condition|(
operator|++
name|j
operator|<
name|z
condition|)
comment|/* try smaller tables up to z bits */
block|{
if|if
condition|(
operator|(
name|f
operator|<<=
literal|1
operator|)
operator|<=
operator|*
operator|++
name|xp
condition|)
break|break;
comment|/* enough codes to use up j bits */
name|f
operator|-=
operator|*
name|xp
expr_stmt|;
comment|/* else deduct codes from patterns */
block|}
block|}
name|z
operator|=
literal|1
operator|<<
name|j
expr_stmt|;
comment|/* table entries for j-bit table */
comment|/* allocate and link in new table */
if|if
condition|(
operator|(
name|q
operator|=
operator|(
name|inflate_huft
operator|*
operator|)
name|ZALLOC
argument_list|(
name|zs
argument_list|,
name|z
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|inflate_huft
argument_list|)
argument_list|)
operator|)
operator|==
name|Z_NULL
condition|)
block|{
if|if
condition|(
name|h
condition|)
name|inflate_trees_free
argument_list|(
name|u
index|[
literal|0
index|]
argument_list|,
name|zs
argument_list|)
expr_stmt|;
return|return
name|Z_MEM_ERROR
return|;
comment|/* not enough memory */
block|}
name|q
operator|->
name|word
operator|.
name|Nalloc
operator|=
name|z
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_ZLIB
name|inflate_hufts
operator|+=
name|z
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
operator|*
name|t
operator|=
name|q
operator|+
literal|1
expr_stmt|;
comment|/* link to list for huft_free() */
operator|*
operator|(
name|t
operator|=
operator|&
operator|(
name|q
operator|->
name|next
operator|)
operator|)
operator|=
name|Z_NULL
expr_stmt|;
name|u
index|[
name|h
index|]
operator|=
operator|++
name|q
expr_stmt|;
comment|/* table starts after link */
comment|/* connect to last table, if there is one */
if|if
condition|(
name|h
condition|)
block|{
name|x
index|[
name|h
index|]
operator|=
name|i
expr_stmt|;
comment|/* save pattern for backing up */
name|r
operator|.
name|bits
operator|=
operator|(
name|Byte
operator|)
name|l
expr_stmt|;
comment|/* bits to dump before this table */
name|r
operator|.
name|exop
operator|=
operator|(
name|Byte
operator|)
name|j
expr_stmt|;
comment|/* bits in this table */
name|r
operator|.
name|next
operator|=
name|q
expr_stmt|;
comment|/* pointer to this table */
name|j
operator|=
name|i
operator|>>
operator|(
name|w
operator|-
name|l
operator|)
expr_stmt|;
comment|/* (get around Turbo C bug) */
name|u
index|[
name|h
operator|-
literal|1
index|]
index|[
name|j
index|]
operator|=
name|r
expr_stmt|;
comment|/* connect to last table */
block|}
block|}
comment|/* set up table entry in r */
name|r
operator|.
name|bits
operator|=
call|(
name|Byte
call|)
argument_list|(
name|k
operator|-
name|w
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|v
operator|+
name|n
condition|)
name|r
operator|.
name|exop
operator|=
literal|128
operator|+
literal|64
expr_stmt|;
comment|/* out of values--invalid code */
elseif|else
if|if
condition|(
operator|*
name|p
operator|<
name|s
condition|)
block|{
name|r
operator|.
name|exop
operator|=
call|(
name|Byte
call|)
argument_list|(
operator|*
name|p
operator|<
literal|256
condition|?
literal|0
else|:
literal|32
operator|+
literal|64
argument_list|)
expr_stmt|;
comment|/* 256 is end-of-block */
name|r
operator|.
name|base
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* simple code is just the value */
block|}
else|else
block|{
name|r
operator|.
name|exop
operator|=
operator|(
name|Byte
operator|)
name|e
index|[
operator|*
name|p
operator|-
name|s
index|]
operator|+
literal|16
operator|+
literal|64
expr_stmt|;
comment|/* non-simple--look up in lists */
name|r
operator|.
name|base
operator|=
name|d
index|[
operator|*
name|p
operator|++
operator|-
name|s
index|]
expr_stmt|;
block|}
comment|/* fill code-like entries with r */
name|f
operator|=
literal|1
operator|<<
operator|(
name|k
operator|-
name|w
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|>>
name|w
init|;
name|j
operator|<
name|z
condition|;
name|j
operator|+=
name|f
control|)
name|q
index|[
name|j
index|]
operator|=
name|r
expr_stmt|;
comment|/* backwards increment the k-bit code i */
for|for
control|(
name|j
operator|=
literal|1
operator|<<
operator|(
name|k
operator|-
literal|1
operator|)
init|;
name|i
operator|&
name|j
condition|;
name|j
operator|>>=
literal|1
control|)
name|i
operator|^=
name|j
expr_stmt|;
name|i
operator|^=
name|j
expr_stmt|;
comment|/* backup over finished tables */
while|while
condition|(
operator|(
name|i
operator|&
operator|(
operator|(
literal|1
operator|<<
name|w
operator|)
operator|-
literal|1
operator|)
operator|)
operator|!=
name|x
index|[
name|h
index|]
condition|)
block|{
name|h
operator|--
expr_stmt|;
comment|/* don't need to update q */
name|w
operator|-=
name|l
expr_stmt|;
block|}
block|}
block|}
comment|/* Return Z_BUF_ERROR if we were given an incomplete table */
return|return
name|y
operator|!=
literal|0
operator|&&
name|g
operator|!=
literal|1
condition|?
name|Z_BUF_ERROR
else|:
name|Z_OK
return|;
block|}
end_function

begin_function
name|local
name|int
name|inflate_trees_bits
parameter_list|(
name|c
parameter_list|,
name|bb
parameter_list|,
name|tb
parameter_list|,
name|z
parameter_list|)
name|uIntf
modifier|*
name|c
decl_stmt|;
comment|/* 19 code lengths */
name|uIntf
modifier|*
name|bb
decl_stmt|;
comment|/* bits tree desired/actual depth */
name|inflate_huft
modifier|*
name|FAR
modifier|*
name|tb
decl_stmt|;
comment|/* bits tree result */
name|z_stream
modifier|*
name|z
decl_stmt|;
comment|/* for zfree function */
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|huft_build
argument_list|(
name|c
argument_list|,
literal|19
argument_list|,
literal|19
argument_list|,
operator|(
name|uIntf
operator|*
operator|)
name|Z_NULL
argument_list|,
operator|(
name|uIntf
operator|*
operator|)
name|Z_NULL
argument_list|,
name|tb
argument_list|,
name|bb
argument_list|,
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|Z_DATA_ERROR
condition|)
name|z
operator|->
name|msg
operator|=
literal|"oversubscribed dynamic bit lengths tree"
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|==
name|Z_BUF_ERROR
condition|)
block|{
name|inflate_trees_free
argument_list|(
operator|*
name|tb
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|z
operator|->
name|msg
operator|=
literal|"incomplete dynamic bit lengths tree"
expr_stmt|;
name|r
operator|=
name|Z_DATA_ERROR
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
name|local
name|int
name|inflate_trees_dynamic
parameter_list|(
name|nl
parameter_list|,
name|nd
parameter_list|,
name|c
parameter_list|,
name|bl
parameter_list|,
name|bd
parameter_list|,
name|tl
parameter_list|,
name|td
parameter_list|,
name|z
parameter_list|)
name|uInt
name|nl
decl_stmt|;
comment|/* number of literal/length codes */
name|uInt
name|nd
decl_stmt|;
comment|/* number of distance codes */
name|uIntf
modifier|*
name|c
decl_stmt|;
comment|/* that many (total) code lengths */
name|uIntf
modifier|*
name|bl
decl_stmt|;
comment|/* literal desired/actual bit depth */
name|uIntf
modifier|*
name|bd
decl_stmt|;
comment|/* distance desired/actual bit depth */
name|inflate_huft
modifier|*
name|FAR
modifier|*
name|tl
decl_stmt|;
comment|/* literal/length tree result */
name|inflate_huft
modifier|*
name|FAR
modifier|*
name|td
decl_stmt|;
comment|/* distance tree result */
name|z_stream
modifier|*
name|z
decl_stmt|;
comment|/* for zfree function */
block|{
name|int
name|r
decl_stmt|;
comment|/* build literal/length tree */
if|if
condition|(
operator|(
name|r
operator|=
name|huft_build
argument_list|(
name|c
argument_list|,
name|nl
argument_list|,
literal|257
argument_list|,
name|cplens
argument_list|,
name|cplext
argument_list|,
name|tl
argument_list|,
name|bl
argument_list|,
name|z
argument_list|)
operator|)
operator|!=
name|Z_OK
condition|)
block|{
if|if
condition|(
name|r
operator|==
name|Z_DATA_ERROR
condition|)
name|z
operator|->
name|msg
operator|=
literal|"oversubscribed literal/length tree"
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|==
name|Z_BUF_ERROR
condition|)
block|{
name|inflate_trees_free
argument_list|(
operator|*
name|tl
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|z
operator|->
name|msg
operator|=
literal|"incomplete literal/length tree"
expr_stmt|;
name|r
operator|=
name|Z_DATA_ERROR
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
comment|/* build distance tree */
if|if
condition|(
operator|(
name|r
operator|=
name|huft_build
argument_list|(
name|c
operator|+
name|nl
argument_list|,
name|nd
argument_list|,
literal|0
argument_list|,
name|cpdist
argument_list|,
name|cpdext
argument_list|,
name|td
argument_list|,
name|bd
argument_list|,
name|z
argument_list|)
operator|)
operator|!=
name|Z_OK
condition|)
block|{
if|if
condition|(
name|r
operator|==
name|Z_DATA_ERROR
condition|)
name|z
operator|->
name|msg
operator|=
literal|"oversubscribed literal/length tree"
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|==
name|Z_BUF_ERROR
condition|)
block|{
ifdef|#
directive|ifdef
name|PKZIP_BUG_WORKAROUND
name|r
operator|=
name|Z_OK
expr_stmt|;
block|}
else|#
directive|else
name|inflate_trees_free
argument_list|(
operator|*
name|td
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|z
operator|->
name|msg
operator|=
literal|"incomplete literal/length tree"
expr_stmt|;
name|r
operator|=
name|Z_DATA_ERROR
expr_stmt|;
block|}
name|inflate_trees_free
argument_list|(
operator|*
name|tl
argument_list|,
name|z
argument_list|)
expr_stmt|;
return|return
name|r
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* done */
end_comment

begin_return
return|return
name|Z_OK
return|;
end_return

begin_comment
unit|}
comment|/* build fixed tables only once--keep them here */
end_comment

begin_decl_stmt
unit|local
name|int
name|fixed_lock
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|int
name|fixed_built
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FIXEDH
value|530
end_define

begin_comment
comment|/* number of hufts used by fixed tables */
end_comment

begin_decl_stmt
name|local
name|uInt
name|fixed_left
init|=
name|FIXEDH
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|inflate_huft
name|fixed_mem
index|[
name|FIXEDH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|uInt
name|fixed_bl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|uInt
name|fixed_bd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|inflate_huft
modifier|*
name|fixed_tl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|inflate_huft
modifier|*
name|fixed_td
decl_stmt|;
end_decl_stmt

begin_function
name|local
name|voidpf
name|falloc
parameter_list|(
name|q
parameter_list|,
name|n
parameter_list|,
name|s
parameter_list|)
name|voidpf
name|q
decl_stmt|;
comment|/* opaque pointer (not used) */
name|uInt
name|n
decl_stmt|;
comment|/* number of items */
name|uInt
name|s
decl_stmt|;
comment|/* size of item */
block|{
name|Assert
argument_list|(
name|s
operator|==
sizeof|sizeof
argument_list|(
name|inflate_huft
argument_list|)
operator|&&
name|n
operator|<=
name|fixed_left
argument_list|,
literal|"inflate_trees falloc overflow"
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
name|s
operator|++
expr_stmt|;
comment|/* to make some compilers happy */
name|fixed_left
operator|-=
name|n
expr_stmt|;
return|return
call|(
name|voidpf
call|)
argument_list|(
name|fixed_mem
operator|+
name|fixed_left
argument_list|)
return|;
block|}
end_function

begin_function
name|local
name|void
name|ffree
parameter_list|(
name|q
parameter_list|,
name|p
parameter_list|,
name|n
parameter_list|)
name|voidpf
name|q
decl_stmt|;
name|voidpf
name|p
decl_stmt|;
name|uInt
name|n
decl_stmt|;
block|{
name|Assert
argument_list|(
literal|0
argument_list|,
literal|"inflate_trees ffree called!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
name|q
operator|=
name|p
expr_stmt|;
comment|/* to make some compilers happy */
block|}
end_function

begin_function
name|local
name|int
name|inflate_trees_fixed
parameter_list|(
name|bl
parameter_list|,
name|bd
parameter_list|,
name|tl
parameter_list|,
name|td
parameter_list|)
name|uIntf
modifier|*
name|bl
decl_stmt|;
comment|/* literal desired/actual bit depth */
name|uIntf
modifier|*
name|bd
decl_stmt|;
comment|/* distance desired/actual bit depth */
name|inflate_huft
modifier|*
name|FAR
modifier|*
name|tl
decl_stmt|;
comment|/* literal/length tree result */
name|inflate_huft
modifier|*
name|FAR
modifier|*
name|td
decl_stmt|;
comment|/* distance tree result */
block|{
comment|/* build fixed tables if not built already--lock out other instances */
while|while
condition|(
operator|++
name|fixed_lock
operator|>
literal|1
condition|)
name|fixed_lock
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|fixed_built
condition|)
block|{
name|int
name|k
decl_stmt|;
comment|/* temporary variable */
name|unsigned
name|c
index|[
literal|288
index|]
decl_stmt|;
comment|/* length list for huft_build */
name|z_stream
name|z
decl_stmt|;
comment|/* for falloc function */
comment|/* set up fake z_stream for memory routines */
name|z
operator|.
name|zalloc
operator|=
name|falloc
expr_stmt|;
name|z
operator|.
name|zfree
operator|=
name|ffree
expr_stmt|;
name|z
operator|.
name|opaque
operator|=
name|Z_NULL
expr_stmt|;
comment|/* literal table */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|144
condition|;
name|k
operator|++
control|)
name|c
index|[
name|k
index|]
operator|=
literal|8
expr_stmt|;
for|for
control|(
init|;
name|k
operator|<
literal|256
condition|;
name|k
operator|++
control|)
name|c
index|[
name|k
index|]
operator|=
literal|9
expr_stmt|;
for|for
control|(
init|;
name|k
operator|<
literal|280
condition|;
name|k
operator|++
control|)
name|c
index|[
name|k
index|]
operator|=
literal|7
expr_stmt|;
for|for
control|(
init|;
name|k
operator|<
literal|288
condition|;
name|k
operator|++
control|)
name|c
index|[
name|k
index|]
operator|=
literal|8
expr_stmt|;
name|fixed_bl
operator|=
literal|7
expr_stmt|;
name|huft_build
argument_list|(
name|c
argument_list|,
literal|288
argument_list|,
literal|257
argument_list|,
name|cplens
argument_list|,
name|cplext
argument_list|,
operator|&
name|fixed_tl
argument_list|,
operator|&
name|fixed_bl
argument_list|,
operator|&
name|z
argument_list|)
expr_stmt|;
comment|/* distance table */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|30
condition|;
name|k
operator|++
control|)
name|c
index|[
name|k
index|]
operator|=
literal|5
expr_stmt|;
name|fixed_bd
operator|=
literal|5
expr_stmt|;
name|huft_build
argument_list|(
name|c
argument_list|,
literal|30
argument_list|,
literal|0
argument_list|,
name|cpdist
argument_list|,
name|cpdext
argument_list|,
operator|&
name|fixed_td
argument_list|,
operator|&
name|fixed_bd
argument_list|,
operator|&
name|z
argument_list|)
expr_stmt|;
comment|/* done */
name|fixed_built
operator|=
literal|1
expr_stmt|;
block|}
name|fixed_lock
operator|--
expr_stmt|;
operator|*
name|bl
operator|=
name|fixed_bl
expr_stmt|;
operator|*
name|bd
operator|=
name|fixed_bd
expr_stmt|;
operator|*
name|tl
operator|=
name|fixed_tl
expr_stmt|;
operator|*
name|td
operator|=
name|fixed_td
expr_stmt|;
return|return
name|Z_OK
return|;
block|}
end_function

begin_function
name|local
name|int
name|inflate_trees_free
parameter_list|(
name|t
parameter_list|,
name|z
parameter_list|)
name|inflate_huft
modifier|*
name|t
decl_stmt|;
comment|/* table to free */
name|z_stream
modifier|*
name|z
decl_stmt|;
comment|/* for zfree function */
comment|/* Free the malloc'ed tables built by huft_build(), which makes a linked    list of the tables it made, with the links in a dummy first entry of    each table. */
block|{
specifier|register
name|inflate_huft
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* Go through linked list, freeing from the malloced (t[-1]) address. */
name|p
operator|=
name|t
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|Z_NULL
condition|)
block|{
name|q
operator|=
operator|(
operator|--
name|p
operator|)
operator|->
name|next
expr_stmt|;
name|ZFREE
argument_list|(
name|z
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|word
operator|.
name|Nalloc
operator|*
sizeof|sizeof
argument_list|(
name|inflate_huft
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
block|}
return|return
name|Z_OK
return|;
block|}
end_function

begin_comment
comment|/*+++++*/
end_comment

begin_comment
comment|/* infcodes.c -- process literals and length/distance pairs  * Copyright (C) 1995 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h   */
end_comment

begin_comment
comment|/* simplify the use of the inflate_huft type with some defines */
end_comment

begin_define
define|#
directive|define
name|base
value|more.Base
end_define

begin_define
define|#
directive|define
name|next
value|more.Next
end_define

begin_define
define|#
directive|define
name|exop
value|word.what.Exop
end_define

begin_define
define|#
directive|define
name|bits
value|word.what.Bits
end_define

begin_comment
comment|/* inflate codes private state */
end_comment

begin_struct
struct|struct
name|inflate_codes_state
block|{
comment|/* mode */
enum|enum
block|{
comment|/* waiting for "i:"=input, "o:"=output, "x:"=nothing */
name|START
block|,
comment|/* x: set up for LEN */
name|LEN
block|,
comment|/* i: get length/literal/eob next */
name|LENEXT
block|,
comment|/* i: getting length extra (have base) */
name|DIST
block|,
comment|/* i: get distance next */
name|DISTEXT
block|,
comment|/* i: getting distance extra */
name|COPY
block|,
comment|/* o: copying bytes in window, waiting for space */
name|LIT
block|,
comment|/* o: got literal, waiting for output space */
name|WASH
block|,
comment|/* o: got eob, possibly still output waiting */
name|END
block|,
comment|/* x: got eob and all data flushed */
name|BADCODE
block|}
comment|/* x: got error */
name|mode
enum|;
comment|/* current inflate_codes mode */
comment|/* mode dependent information */
name|uInt
name|len
decl_stmt|;
union|union
block|{
struct|struct
block|{
name|inflate_huft
modifier|*
name|tree
decl_stmt|;
comment|/* pointer into tree */
name|uInt
name|need
decl_stmt|;
comment|/* bits needed */
block|}
name|code
struct|;
comment|/* if LEN or DIST, where in tree */
name|uInt
name|lit
decl_stmt|;
comment|/* if LIT, literal */
struct|struct
block|{
name|uInt
name|get
decl_stmt|;
comment|/* bits to get for extra */
name|uInt
name|dist
decl_stmt|;
comment|/* distance back to copy from */
block|}
name|copy
struct|;
comment|/* if EXT or COPY, where and how much */
block|}
name|sub
union|;
comment|/* submode */
comment|/* mode independent information */
name|Byte
name|lbits
decl_stmt|;
comment|/* ltree bits decoded per branch */
name|Byte
name|dbits
decl_stmt|;
comment|/* dtree bits decoder per branch */
name|inflate_huft
modifier|*
name|ltree
decl_stmt|;
comment|/* literal/length/eob tree */
name|inflate_huft
modifier|*
name|dtree
decl_stmt|;
comment|/* distance tree */
block|}
struct|;
end_struct

begin_function
name|local
name|inflate_codes_statef
modifier|*
name|inflate_codes_new
parameter_list|(
name|bl
parameter_list|,
name|bd
parameter_list|,
name|tl
parameter_list|,
name|td
parameter_list|,
name|z
parameter_list|)
name|uInt
name|bl
decl_stmt|,
name|bd
decl_stmt|;
name|inflate_huft
modifier|*
name|tl
decl_stmt|,
decl|*
name|td
decl_stmt|;
end_function

begin_decl_stmt
name|z_stream
modifier|*
name|z
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|inflate_codes_statef
modifier|*
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
operator|(
name|inflate_codes_statef
operator|*
operator|)
name|ZALLOC
argument_list|(
name|z
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inflate_codes_state
argument_list|)
argument_list|)
operator|)
operator|!=
name|Z_NULL
condition|)
block|{
name|c
operator|->
name|mode
operator|=
name|START
expr_stmt|;
name|c
operator|->
name|lbits
operator|=
operator|(
name|Byte
operator|)
name|bl
expr_stmt|;
name|c
operator|->
name|dbits
operator|=
operator|(
name|Byte
operator|)
name|bd
expr_stmt|;
name|c
operator|->
name|ltree
operator|=
name|tl
expr_stmt|;
name|c
operator|->
name|dtree
operator|=
name|td
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       codes new\n"
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|c
return|;
block|}
end_block

begin_function
name|local
name|int
name|inflate_codes
parameter_list|(
name|s
parameter_list|,
name|z
parameter_list|,
name|r
parameter_list|)
name|inflate_blocks_statef
modifier|*
name|s
decl_stmt|;
name|z_stream
modifier|*
name|z
decl_stmt|;
name|int
name|r
decl_stmt|;
block|{
name|uInt
name|j
decl_stmt|;
comment|/* temporary storage */
name|inflate_huft
modifier|*
name|t
decl_stmt|;
comment|/* temporary pointer */
name|uInt
name|e
decl_stmt|;
comment|/* extra bits or operation */
name|uLong
name|b
decl_stmt|;
comment|/* bit buffer */
name|uInt
name|k
decl_stmt|;
comment|/* bits in bit buffer */
name|Bytef
modifier|*
name|p
decl_stmt|;
comment|/* input data pointer */
name|uInt
name|n
decl_stmt|;
comment|/* bytes available there */
name|Bytef
modifier|*
name|q
decl_stmt|;
comment|/* output window write pointer */
name|uInt
name|m
decl_stmt|;
comment|/* bytes to end of window or read pointer */
name|Bytef
modifier|*
name|f
decl_stmt|;
comment|/* pointer to copy strings from */
name|inflate_codes_statef
modifier|*
name|c
init|=
name|s
operator|->
name|sub
operator|.
name|decode
operator|.
name|codes
decl_stmt|;
comment|/* codes state */
comment|/* copy input/output information to locals (UPDATE macro restores) */
name|LOAD
comment|/* process input and output based on current state */
while|while
condition|(
literal|1
condition|)
switch|switch
condition|(
name|c
operator|->
name|mode
condition|)
block|{
comment|/* waiting for "i:"=input, "o:"=output, "x:"=nothing */
case|case
name|START
case|:
comment|/* x: set up for LEN */
ifndef|#
directive|ifndef
name|SLOW
if|if
condition|(
name|m
operator|>=
literal|258
operator|&&
name|n
operator|>=
literal|10
condition|)
block|{
name|UPDATE
name|r
init|=
name|inflate_fast
argument_list|(
name|c
operator|->
name|lbits
argument_list|,
name|c
operator|->
name|dbits
argument_list|,
name|c
operator|->
name|ltree
argument_list|,
name|c
operator|->
name|dtree
argument_list|,
name|s
argument_list|,
name|z
argument_list|)
decl_stmt|;
name|LOAD
if|if
condition|(
name|r
operator|!=
name|Z_OK
condition|)
block|{
name|c
operator|->
name|mode
operator|=
name|r
operator|==
name|Z_STREAM_END
condition|?
name|WASH
else|:
name|BADCODE
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
comment|/* !SLOW */
name|c
operator|->
name|sub
operator|.
name|code
operator|.
name|need
operator|=
name|c
operator|->
name|lbits
expr_stmt|;
name|c
operator|->
name|sub
operator|.
name|code
operator|.
name|tree
operator|=
name|c
operator|->
name|ltree
expr_stmt|;
name|c
operator|->
name|mode
operator|=
name|LEN
expr_stmt|;
case|case
name|LEN
case|:
comment|/* i: get length/literal/eob next */
name|j
operator|=
name|c
operator|->
name|sub
operator|.
name|code
operator|.
name|need
expr_stmt|;
name|NEEDBITS
argument_list|(
argument|j
argument_list|)
name|t
operator|=
name|c
operator|->
name|sub
operator|.
name|code
operator|.
name|tree
operator|+
operator|(
operator|(
name|uInt
operator|)
name|b
operator|&
name|inflate_mask
index|[
name|j
index|]
operator|)
expr_stmt|;
name|DUMPBITS
argument_list|(
argument|t->bits
argument_list|)
name|e
operator|=
call|(
name|uInt
call|)
argument_list|(
name|t
operator|->
name|exop
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
literal|0
condition|)
comment|/* literal */
block|{
name|c
operator|->
name|sub
operator|.
name|lit
operator|=
name|t
operator|->
name|base
expr_stmt|;
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
name|t
operator|->
name|base
operator|>=
literal|0x20
operator|&&
name|t
operator|->
name|base
operator|<
literal|0x7f
condition|?
literal|"inflate:         literal '%c'\n"
else|:
literal|"inflate:         literal 0x%02x\n"
operator|,
name|t
operator|->
name|base
operator|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|mode
operator|=
name|LIT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|e
operator|&
literal|16
condition|)
comment|/* length */
block|{
name|c
operator|->
name|sub
operator|.
name|copy
operator|.
name|get
operator|=
name|e
operator|&
literal|15
expr_stmt|;
name|c
operator|->
name|len
operator|=
name|t
operator|->
name|base
expr_stmt|;
name|c
operator|->
name|mode
operator|=
name|LENEXT
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|e
operator|&
literal|64
operator|)
operator|==
literal|0
condition|)
comment|/* next table */
block|{
name|c
operator|->
name|sub
operator|.
name|code
operator|.
name|need
operator|=
name|e
expr_stmt|;
name|c
operator|->
name|sub
operator|.
name|code
operator|.
name|tree
operator|=
name|t
operator|->
name|next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|e
operator|&
literal|32
condition|)
comment|/* end of block */
block|{
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:         end of block\n"
operator|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|mode
operator|=
name|WASH
expr_stmt|;
break|break;
block|}
name|c
operator|->
name|mode
operator|=
name|BADCODE
expr_stmt|;
comment|/* invalid code */
name|z
operator|->
name|msg
operator|=
literal|"invalid literal/length code"
expr_stmt|;
name|r
operator|=
name|Z_DATA_ERROR
expr_stmt|;
name|LEAVE
case|case
name|LENEXT
case|:
comment|/* i: getting length extra (have base) */
name|j
operator|=
name|c
operator|->
name|sub
operator|.
name|copy
operator|.
name|get
expr_stmt|;
name|NEEDBITS
argument_list|(
argument|j
argument_list|)
name|c
operator|->
name|len
operator|+=
operator|(
name|uInt
operator|)
name|b
operator|&
name|inflate_mask
index|[
name|j
index|]
expr_stmt|;
name|DUMPBITS
argument_list|(
argument|j
argument_list|)
name|c
operator|->
name|sub
operator|.
name|code
operator|.
name|need
operator|=
name|c
operator|->
name|dbits
expr_stmt|;
name|c
operator|->
name|sub
operator|.
name|code
operator|.
name|tree
operator|=
name|c
operator|->
name|dtree
expr_stmt|;
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:         length %u\n"
operator|,
name|c
operator|->
name|len
operator|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|mode
operator|=
name|DIST
expr_stmt|;
case|case
name|DIST
case|:
comment|/* i: get distance next */
name|j
operator|=
name|c
operator|->
name|sub
operator|.
name|code
operator|.
name|need
expr_stmt|;
name|NEEDBITS
argument_list|(
argument|j
argument_list|)
name|t
operator|=
name|c
operator|->
name|sub
operator|.
name|code
operator|.
name|tree
operator|+
operator|(
operator|(
name|uInt
operator|)
name|b
operator|&
name|inflate_mask
index|[
name|j
index|]
operator|)
expr_stmt|;
name|DUMPBITS
argument_list|(
argument|t->bits
argument_list|)
name|e
operator|=
call|(
name|uInt
call|)
argument_list|(
name|t
operator|->
name|exop
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|&
literal|16
condition|)
comment|/* distance */
block|{
name|c
operator|->
name|sub
operator|.
name|copy
operator|.
name|get
operator|=
name|e
operator|&
literal|15
expr_stmt|;
name|c
operator|->
name|sub
operator|.
name|copy
operator|.
name|dist
operator|=
name|t
operator|->
name|base
expr_stmt|;
name|c
operator|->
name|mode
operator|=
name|DISTEXT
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|e
operator|&
literal|64
operator|)
operator|==
literal|0
condition|)
comment|/* next table */
block|{
name|c
operator|->
name|sub
operator|.
name|code
operator|.
name|need
operator|=
name|e
expr_stmt|;
name|c
operator|->
name|sub
operator|.
name|code
operator|.
name|tree
operator|=
name|t
operator|->
name|next
expr_stmt|;
break|break;
block|}
name|c
operator|->
name|mode
operator|=
name|BADCODE
expr_stmt|;
comment|/* invalid code */
name|z
operator|->
name|msg
operator|=
literal|"invalid distance code"
expr_stmt|;
name|r
operator|=
name|Z_DATA_ERROR
expr_stmt|;
name|LEAVE
case|case
name|DISTEXT
case|:
comment|/* i: getting distance extra */
name|j
operator|=
name|c
operator|->
name|sub
operator|.
name|copy
operator|.
name|get
expr_stmt|;
name|NEEDBITS
argument_list|(
argument|j
argument_list|)
name|c
operator|->
name|sub
operator|.
name|copy
operator|.
name|dist
operator|+=
operator|(
name|uInt
operator|)
name|b
operator|&
name|inflate_mask
index|[
name|j
index|]
expr_stmt|;
name|DUMPBITS
argument_list|(
argument|j
argument_list|)
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:         distance %u\n"
operator|,
name|c
operator|->
name|sub
operator|.
name|copy
operator|.
name|dist
operator|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|mode
operator|=
name|COPY
expr_stmt|;
case|case
name|COPY
case|:
comment|/* o: copying bytes in window, waiting for space */
ifndef|#
directive|ifndef
name|__TURBOC__
comment|/* Turbo C bug for following expression */
name|f
operator|=
operator|(
name|uInt
operator|)
operator|(
name|q
operator|-
name|s
operator|->
name|window
operator|)
operator|<
name|c
operator|->
name|sub
operator|.
name|copy
operator|.
name|dist
condition|?
name|s
operator|->
name|end
operator|-
operator|(
name|c
operator|->
name|sub
operator|.
name|copy
operator|.
name|dist
operator|-
operator|(
name|q
operator|-
name|s
operator|->
name|window
operator|)
operator|)
else|:
name|q
operator|-
name|c
operator|->
name|sub
operator|.
name|copy
operator|.
name|dist
expr_stmt|;
else|#
directive|else
name|f
operator|=
name|q
operator|-
name|c
operator|->
name|sub
operator|.
name|copy
operator|.
name|dist
expr_stmt|;
if|if
condition|(
call|(
name|uInt
call|)
argument_list|(
name|q
operator|-
name|s
operator|->
name|window
argument_list|)
operator|<
name|c
operator|->
name|sub
operator|.
name|copy
operator|.
name|dist
condition|)
name|f
operator|=
name|s
operator|->
name|end
operator|-
operator|(
name|c
operator|->
name|sub
operator|.
name|copy
operator|.
name|dist
operator|-
operator|(
name|q
operator|-
name|s
operator|->
name|window
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|c
operator|->
name|len
condition|)
block|{
name|NEEDOUT
name|OUTBYTE
argument_list|(
operator|*
name|f
operator|++
argument_list|)
decl|if
argument_list|(
name|f
operator|==
name|s
operator|->
name|end
argument_list|)
name|f
init|=
name|s
operator|->
name|window
decl_stmt|;
name|c
operator|->
name|len
operator|--
expr_stmt|;
block|}
name|c
operator|->
name|mode
operator|=
name|START
expr_stmt|;
break|break;
case|case
name|LIT
case|:
comment|/* o: got literal, waiting for output space */
name|NEEDOUT
name|OUTBYTE
argument_list|(
name|c
operator|->
name|sub
operator|.
name|lit
argument_list|)
name|c
operator|->
name|mode
init|=
name|START
decl_stmt|;
break|break;
case|case
name|WASH
case|:
comment|/* o: got eob, possibly more output */
name|FLUSH
if|if
condition|(
name|s
operator|->
name|read
operator|!=
name|s
operator|->
name|write
condition|)
name|LEAVE
name|c
operator|->
name|mode
init|=
name|END
decl_stmt|;
case|case
name|END
case|:
name|r
operator|=
name|Z_STREAM_END
expr_stmt|;
name|LEAVE
case|case
name|BADCODE
case|:
comment|/* x: got error */
name|r
operator|=
name|Z_DATA_ERROR
expr_stmt|;
name|LEAVE
default|default:
name|r
operator|=
name|Z_STREAM_ERROR
expr_stmt|;
name|LEAVE
block|}
block|}
end_function

begin_function
name|local
name|void
name|inflate_codes_free
parameter_list|(
name|c
parameter_list|,
name|z
parameter_list|)
name|inflate_codes_statef
modifier|*
name|c
decl_stmt|;
name|z_stream
modifier|*
name|z
decl_stmt|;
block|{
name|ZFREE
argument_list|(
name|z
argument_list|,
name|c
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|inflate_codes_state
argument_list|)
argument_list|)
expr_stmt|;
name|Tracev
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:       codes free\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*+++++*/
end_comment

begin_comment
comment|/* inflate_util.c -- data and routines common to blocks and codes  * Copyright (C) 1995 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h   */
end_comment

begin_comment
comment|/* copy as much as possible from the sliding window to the output area */
end_comment

begin_function
name|local
name|int
name|inflate_flush
parameter_list|(
name|s
parameter_list|,
name|z
parameter_list|,
name|r
parameter_list|)
name|inflate_blocks_statef
modifier|*
name|s
decl_stmt|;
name|z_stream
modifier|*
name|z
decl_stmt|;
name|int
name|r
decl_stmt|;
block|{
name|uInt
name|n
decl_stmt|;
name|Bytef
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* local copies of source and destination pointers */
name|p
operator|=
name|z
operator|->
name|next_out
expr_stmt|;
name|q
operator|=
name|s
operator|->
name|read
expr_stmt|;
comment|/* compute number of bytes to copy as far as end of window */
name|n
operator|=
call|(
name|uInt
call|)
argument_list|(
operator|(
name|q
operator|<=
name|s
operator|->
name|write
condition|?
name|s
operator|->
name|write
else|:
name|s
operator|->
name|end
operator|)
operator|-
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|z
operator|->
name|avail_out
condition|)
name|n
operator|=
name|z
operator|->
name|avail_out
expr_stmt|;
if|if
condition|(
name|n
operator|&&
name|r
operator|==
name|Z_BUF_ERROR
condition|)
name|r
operator|=
name|Z_OK
expr_stmt|;
comment|/* update counters */
name|z
operator|->
name|avail_out
operator|-=
name|n
expr_stmt|;
name|z
operator|->
name|total_out
operator|+=
name|n
expr_stmt|;
comment|/* update check information */
if|if
condition|(
name|s
operator|->
name|checkfn
operator|!=
name|Z_NULL
condition|)
name|s
operator|->
name|check
operator|=
call|(
modifier|*
name|s
operator|->
name|checkfn
call|)
argument_list|(
name|s
operator|->
name|check
argument_list|,
name|q
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* copy as far as end of window */
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|zmemcpy
argument_list|(
name|p
argument_list|,
name|q
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|+=
name|n
expr_stmt|;
block|}
name|q
operator|+=
name|n
expr_stmt|;
comment|/* see if more to copy at beginning of window */
if|if
condition|(
name|q
operator|==
name|s
operator|->
name|end
condition|)
block|{
comment|/* wrap pointers */
name|q
operator|=
name|s
operator|->
name|window
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|write
operator|==
name|s
operator|->
name|end
condition|)
name|s
operator|->
name|write
operator|=
name|s
operator|->
name|window
expr_stmt|;
comment|/* compute bytes to copy */
name|n
operator|=
call|(
name|uInt
call|)
argument_list|(
name|s
operator|->
name|write
operator|-
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|z
operator|->
name|avail_out
condition|)
name|n
operator|=
name|z
operator|->
name|avail_out
expr_stmt|;
if|if
condition|(
name|n
operator|&&
name|r
operator|==
name|Z_BUF_ERROR
condition|)
name|r
operator|=
name|Z_OK
expr_stmt|;
comment|/* update counters */
name|z
operator|->
name|avail_out
operator|-=
name|n
expr_stmt|;
name|z
operator|->
name|total_out
operator|+=
name|n
expr_stmt|;
comment|/* update check information */
if|if
condition|(
name|s
operator|->
name|checkfn
operator|!=
name|Z_NULL
condition|)
name|s
operator|->
name|check
operator|=
call|(
modifier|*
name|s
operator|->
name|checkfn
call|)
argument_list|(
name|s
operator|->
name|check
argument_list|,
name|q
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* copy */
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|zmemcpy
argument_list|(
name|p
argument_list|,
name|q
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|p
operator|+=
name|n
expr_stmt|;
block|}
name|q
operator|+=
name|n
expr_stmt|;
block|}
comment|/* update pointers */
name|z
operator|->
name|next_out
operator|=
name|p
expr_stmt|;
name|s
operator|->
name|read
operator|=
name|q
expr_stmt|;
comment|/* done */
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*+++++*/
end_comment

begin_comment
comment|/* inffast.c -- process literals and length/distance pairs fast  * Copyright (C) 1995 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h   */
end_comment

begin_comment
comment|/* simplify the use of the inflate_huft type with some defines */
end_comment

begin_define
define|#
directive|define
name|base
value|more.Base
end_define

begin_define
define|#
directive|define
name|next
value|more.Next
end_define

begin_define
define|#
directive|define
name|exop
value|word.what.Exop
end_define

begin_define
define|#
directive|define
name|bits
value|word.what.Bits
end_define

begin_comment
comment|/* macros for bit input with no checking and for returning unused bytes */
end_comment

begin_define
define|#
directive|define
name|GRABBITS
parameter_list|(
name|j
parameter_list|)
value|{while(k<(j)){b|=((uLong)NEXTBYTE)<<k;k+=8;}}
end_define

begin_define
define|#
directive|define
name|UNGRAB
value|{n+=(c=k>>3);p-=c;k&=7;}
end_define

begin_comment
comment|/* Called with number of bytes left to write in window at least 258    (the maximum string length) and number of input bytes available    at least ten.  The ten bytes are six bytes for the longest length/    distance pair plus four bytes for overloading the bit buffer. */
end_comment

begin_function
name|local
name|int
name|inflate_fast
parameter_list|(
name|bl
parameter_list|,
name|bd
parameter_list|,
name|tl
parameter_list|,
name|td
parameter_list|,
name|s
parameter_list|,
name|z
parameter_list|)
name|uInt
name|bl
decl_stmt|,
name|bd
decl_stmt|;
name|inflate_huft
modifier|*
name|tl
decl_stmt|,
decl|*
name|td
decl_stmt|;
end_function

begin_decl_stmt
name|inflate_blocks_statef
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|z_stream
modifier|*
name|z
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|inflate_huft
modifier|*
name|t
decl_stmt|;
comment|/* temporary pointer */
name|uInt
name|e
decl_stmt|;
comment|/* extra bits or operation */
name|uLong
name|b
decl_stmt|;
comment|/* bit buffer */
name|uInt
name|k
decl_stmt|;
comment|/* bits in bit buffer */
name|Bytef
modifier|*
name|p
decl_stmt|;
comment|/* input data pointer */
name|uInt
name|n
decl_stmt|;
comment|/* bytes available there */
name|Bytef
modifier|*
name|q
decl_stmt|;
comment|/* output window write pointer */
name|uInt
name|m
decl_stmt|;
comment|/* bytes to end of window or read pointer */
name|uInt
name|ml
decl_stmt|;
comment|/* mask for literal/length tree */
name|uInt
name|md
decl_stmt|;
comment|/* mask for distance tree */
name|uInt
name|c
decl_stmt|;
comment|/* bytes to copy */
name|uInt
name|d
decl_stmt|;
comment|/* distance back to copy from */
name|Bytef
modifier|*
name|r
decl_stmt|;
comment|/* copy source pointer */
comment|/* load input, output, bit values */
name|LOAD
comment|/* initialize masks */
name|ml
init|=
name|inflate_mask
index|[
name|bl
index|]
decl_stmt|;
name|md
operator|=
name|inflate_mask
index|[
name|bd
index|]
expr_stmt|;
comment|/* do until not enough input or output space for fast loop */
do|do
block|{
comment|/* assume called with m>= 258&& n>= 10 */
comment|/* get literal/length code */
name|GRABBITS
argument_list|(
literal|20
argument_list|)
comment|/* max bits for literal/length code */
if|if
condition|(
operator|(
name|e
operator|=
operator|(
name|t
operator|=
name|tl
operator|+
operator|(
operator|(
name|uInt
operator|)
name|b
operator|&
name|ml
operator|)
operator|)
operator|->
name|exop
operator|)
operator|==
literal|0
condition|)
block|{
name|DUMPBITS
argument_list|(
argument|t->bits
argument_list|)
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
name|t
operator|->
name|base
operator|>=
literal|0x20
operator|&&
name|t
operator|->
name|base
operator|<
literal|0x7f
condition|?
literal|"inflate:         * literal '%c'\n"
else|:
literal|"inflate:         * literal 0x%02x\n"
operator|,
name|t
operator|->
name|base
operator|)
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|(
name|Byte
operator|)
name|t
operator|->
name|base
expr_stmt|;
name|m
operator|--
expr_stmt|;
continue|continue;
block|}
do|do
block|{
name|DUMPBITS
argument_list|(
argument|t->bits
argument_list|)
if|if
condition|(
name|e
operator|&
literal|16
condition|)
block|{
comment|/* get extra bits for length */
name|e
operator|&=
literal|15
expr_stmt|;
name|c
operator|=
name|t
operator|->
name|base
operator|+
operator|(
operator|(
name|uInt
operator|)
name|b
operator|&
name|inflate_mask
index|[
name|e
index|]
operator|)
expr_stmt|;
name|DUMPBITS
argument_list|(
argument|e
argument_list|)
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:         * length %u\n"
operator|,
name|c
operator|)
argument_list|)
expr_stmt|;
comment|/* decode distance base of block to copy */
name|GRABBITS
argument_list|(
literal|15
argument_list|)
expr_stmt|;
comment|/* max bits for distance code */
name|e
operator|=
operator|(
name|t
operator|=
name|td
operator|+
operator|(
operator|(
name|uInt
operator|)
name|b
operator|&
name|md
operator|)
operator|)
operator|->
name|exop
expr_stmt|;
do|do
block|{
name|DUMPBITS
argument_list|(
argument|t->bits
argument_list|)
if|if
condition|(
name|e
operator|&
literal|16
condition|)
block|{
comment|/* get extra bits to add to distance base */
name|e
operator|&=
literal|15
expr_stmt|;
name|GRABBITS
argument_list|(
argument|e
argument_list|)
comment|/* get extra bits (up to 13) */
name|d
operator|=
name|t
operator|->
name|base
operator|+
operator|(
operator|(
name|uInt
operator|)
name|b
operator|&
name|inflate_mask
index|[
name|e
index|]
operator|)
expr_stmt|;
name|DUMPBITS
argument_list|(
argument|e
argument_list|)
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:         * distance %u\n"
operator|,
name|d
operator|)
argument_list|)
expr_stmt|;
comment|/* do the copy */
name|m
operator|-=
name|c
expr_stmt|;
if|if
condition|(
call|(
name|uInt
call|)
argument_list|(
name|q
operator|-
name|s
operator|->
name|window
argument_list|)
operator|>=
name|d
condition|)
comment|/* offset before dest */
block|{
comment|/*  just copy */
name|r
operator|=
name|q
operator|-
name|d
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|*
name|r
operator|++
expr_stmt|;
name|c
operator|--
expr_stmt|;
comment|/* minimum count is three, */
operator|*
name|q
operator|++
operator|=
operator|*
name|r
operator|++
expr_stmt|;
name|c
operator|--
expr_stmt|;
comment|/*  so unroll loop a little */
block|}
else|else
comment|/* else offset after destination */
block|{
name|e
operator|=
name|d
operator|-
operator|(
name|q
operator|-
name|s
operator|->
name|window
operator|)
expr_stmt|;
comment|/* bytes from offset to end */
name|r
operator|=
name|s
operator|->
name|end
operator|-
name|e
expr_stmt|;
comment|/* pointer to offset */
if|if
condition|(
name|c
operator|>
name|e
condition|)
comment|/* if source crosses, */
block|{
name|c
operator|-=
name|e
expr_stmt|;
comment|/* copy to end of window */
do|do
block|{
operator|*
name|q
operator|++
operator|=
operator|*
name|r
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|e
condition|)
do|;
name|r
operator|=
name|s
operator|->
name|window
expr_stmt|;
comment|/* copy rest from start of window */
block|}
block|}
do|do
block|{
comment|/* copy all or what's left */
operator|*
name|q
operator|++
operator|=
operator|*
name|r
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|c
condition|)
do|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|e
operator|&
literal|64
operator|)
operator|==
literal|0
condition|)
name|e
operator|=
operator|(
name|t
operator|=
name|t
operator|->
name|next
operator|+
operator|(
operator|(
name|uInt
operator|)
name|b
operator|&
name|inflate_mask
index|[
name|e
index|]
operator|)
operator|)
operator|->
name|exop
expr_stmt|;
else|else
block|{
name|z
operator|->
name|msg
operator|=
literal|"invalid distance code"
expr_stmt|;
name|UNGRAB
name|UPDATE
return|return
name|Z_DATA_ERROR
return|;
block|}
block|}
do|while
condition|(
literal|1
condition|)
do|;
break|break;
block|}
if|if
condition|(
operator|(
name|e
operator|&
literal|64
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|e
operator|=
operator|(
name|t
operator|=
name|t
operator|->
name|next
operator|+
operator|(
operator|(
name|uInt
operator|)
name|b
operator|&
name|inflate_mask
index|[
name|e
index|]
operator|)
operator|)
operator|->
name|exop
operator|)
operator|==
literal|0
condition|)
block|{
name|DUMPBITS
argument_list|(
argument|t->bits
argument_list|)
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
name|t
operator|->
name|base
operator|>=
literal|0x20
operator|&&
name|t
operator|->
name|base
operator|<
literal|0x7f
condition|?
literal|"inflate:         * literal '%c'\n"
else|:
literal|"inflate:         * literal 0x%02x\n"
operator|,
name|t
operator|->
name|base
operator|)
argument_list|)
expr_stmt|;
operator|*
name|q
operator|++
operator|=
operator|(
name|Byte
operator|)
name|t
operator|->
name|base
expr_stmt|;
name|m
operator|--
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|e
operator|&
literal|32
condition|)
block|{
name|Tracevv
argument_list|(
operator|(
name|stderr
operator|,
literal|"inflate:         * end of block\n"
operator|)
argument_list|)
expr_stmt|;
name|UNGRAB
name|UPDATE
return|return
name|Z_STREAM_END
return|;
block|}
else|else
block|{
name|z
operator|->
name|msg
operator|=
literal|"invalid literal/length code"
expr_stmt|;
name|UNGRAB
name|UPDATE
return|return
name|Z_DATA_ERROR
return|;
block|}
block|}
do|while
condition|(
literal|1
condition|)
do|;
block|}
do|while
condition|(
name|m
operator|>=
literal|258
operator|&&
name|n
operator|>=
literal|10
condition|)
do|;
comment|/* not enough input or output--restore pointers and return */
name|UNGRAB
name|UPDATE
return|return
name|Z_OK
return|;
block|}
end_block

begin_comment
comment|/*+++++*/
end_comment

begin_comment
comment|/* zutil.c -- target dependent utility functions for the compression library  * Copyright (C) 1995 Jean-loup Gailly.  * For conditions of distribution and use, see copyright notice in zlib.h   */
end_comment

begin_comment
comment|/* From: zutil.c,v 1.8 1995/05/03 17:27:12 jloup Exp */
end_comment

begin_decl_stmt
name|char
modifier|*
name|zlib_version
init|=
name|ZLIB_VERSION
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|z_errmsg
index|[]
init|=
block|{
literal|"stream end"
block|,
comment|/* Z_STREAM_END    1 */
literal|""
block|,
comment|/* Z_OK            0 */
literal|"file error"
block|,
comment|/* Z_ERRNO        (-1) */
literal|"stream error"
block|,
comment|/* Z_STREAM_ERROR (-2) */
literal|"data error"
block|,
comment|/* Z_DATA_ERROR   (-3) */
literal|"insufficient memory"
block|,
comment|/* Z_MEM_ERROR    (-4) */
literal|"buffer error"
block|,
comment|/* Z_BUF_ERROR    (-5) */
literal|""
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*+++++*/
end_comment

begin_comment
comment|/* adler32.c -- compute the Adler-32 checksum of a data stream  * Copyright (C) 1995 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h   */
end_comment

begin_comment
comment|/* From: adler32.c,v 1.6 1995/05/03 17:27:08 jloup Exp */
end_comment

begin_define
define|#
directive|define
name|BASE
value|65521L
end_define

begin_comment
comment|/* largest prime smaller than 65536 */
end_comment

begin_define
define|#
directive|define
name|NMAX
value|5552
end_define

begin_comment
comment|/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1)<= 2^32-1 */
end_comment

begin_define
define|#
directive|define
name|DO1
parameter_list|(
name|buf
parameter_list|)
value|{s1 += *buf++; s2 += s1;}
end_define

begin_define
define|#
directive|define
name|DO2
parameter_list|(
name|buf
parameter_list|)
value|DO1(buf); DO1(buf);
end_define

begin_define
define|#
directive|define
name|DO4
parameter_list|(
name|buf
parameter_list|)
value|DO2(buf); DO2(buf);
end_define

begin_define
define|#
directive|define
name|DO8
parameter_list|(
name|buf
parameter_list|)
value|DO4(buf); DO4(buf);
end_define

begin_define
define|#
directive|define
name|DO16
parameter_list|(
name|buf
parameter_list|)
value|DO8(buf); DO8(buf);
end_define

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|uLong
name|adler32
parameter_list|(
name|adler
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|uLong
name|adler
decl_stmt|;
name|Bytef
modifier|*
name|buf
decl_stmt|;
name|uInt
name|len
decl_stmt|;
block|{
name|unsigned
name|long
name|s1
init|=
name|adler
operator|&
literal|0xffff
decl_stmt|;
name|unsigned
name|long
name|s2
init|=
operator|(
name|adler
operator|>>
literal|16
operator|)
operator|&
literal|0xffff
decl_stmt|;
name|int
name|k
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|Z_NULL
condition|)
return|return
literal|1L
return|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|k
operator|=
name|len
operator|<
name|NMAX
condition|?
name|len
else|:
name|NMAX
expr_stmt|;
name|len
operator|-=
name|k
expr_stmt|;
while|while
condition|(
name|k
operator|>=
literal|16
condition|)
block|{
name|DO16
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|k
operator|-=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|!=
literal|0
condition|)
do|do
block|{
name|DO1
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|k
condition|)
do|;
name|s1
operator|%=
name|BASE
expr_stmt|;
name|s2
operator|%=
name|BASE
expr_stmt|;
block|}
return|return
operator|(
name|s2
operator|<<
literal|16
operator|)
operator||
name|s1
return|;
block|}
end_function

end_unit

