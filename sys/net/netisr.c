begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2009 Robert N. M. Watson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * netisr is a packet dispatch service, allowing synchronous (directly  * dispatched) and asynchronous (deferred dispatch) processing of packets by  * registered protocol handlers.  Callers pass a protocol identifier and  * packet to netisr, along with a direct dispatch hint, and work will either  * be immediately processed by the registered handler, or passed to a  * software interrupt (SWI) thread for deferred dispatch.  Callers will  * generally select one or the other based on:  *  * - Whether directly dispatching a netisr handler lead to code reentrance or  *   lock recursion, such as entering the socket code from the socket code.  * - Whether directly dispatching a netisr handler lead to recursive  *   processing, such as when decapsulating several wrapped layers of tunnel  *   information (IPSEC within IPSEC within ...).  *  * Maintaining ordering for protocol streams is a critical design concern.  * Enforcing ordering limits the opportunity for concurrency, but maintains  * the strong ordering requirements found in some protocols, such as TCP.  Of  * related concern is CPU affinity--it is desirable to process all data  * associated with a particular stream on the same CPU over time in order to  * avoid acquiring locks associated with the connection on different CPUs,  * keep connection data in one cache, and to generally encourage associated  * user threads to live on the same CPU as the stream.  It's also desirable  * to avoid lock migration and contention where locks are associated with  * more than one flow.  *  * netisr supports several policy variations, represented by the  * NETISR_POLICY_* constants, allowing protocols to play various roles in  * identifying flows, assigning work to CPUs, etc.  These are described in  * netisr.h.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_device_polling.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rmlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_comment
comment|/*-  * Synchronize use and modification of the registered netisr data structures;  * acquire a read lock while modifying the set of registered protocols to  * prevent partially registered or unregistered protocols from being run.  *  * The following data structures and fields are protected by this lock:  *  * - The np array, including all fields of struct netisr_proto.  * - The nws array, including all fields of struct netisr_worker.  * - The nws_array array.  *  * Note: the NETISR_LOCKING define controls whether read locks are acquired  * in packet processing paths requiring netisr registration stability.  This  * is disabled by default as it can lead to measurable performance  * degradation even with rmlocks (3%-6% for loopback ping-pong traffic), and  * because netisr registration and unregistration is extremely rare at  * runtime.  If it becomes more common, this decision should be revisited.  *  * XXXRW: rmlocks don't support assertions.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|rmlock
name|netisr_rmlock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NETISR_LOCK_INIT
parameter_list|()
value|rm_init_flags(&netisr_rmlock, "netisr", \ 				    RM_NOWITNESS)
end_define

begin_define
define|#
directive|define
name|NETISR_LOCK_ASSERT
parameter_list|()
end_define

begin_define
define|#
directive|define
name|NETISR_RLOCK
parameter_list|(
name|tracker
parameter_list|)
value|rm_rlock(&netisr_rmlock, (tracker))
end_define

begin_define
define|#
directive|define
name|NETISR_RUNLOCK
parameter_list|(
name|tracker
parameter_list|)
value|rm_runlock(&netisr_rmlock, (tracker))
end_define

begin_define
define|#
directive|define
name|NETISR_WLOCK
parameter_list|()
value|rm_wlock(&netisr_rmlock)
end_define

begin_define
define|#
directive|define
name|NETISR_WUNLOCK
parameter_list|()
value|rm_wunlock(&netisr_rmlock)
end_define

begin_comment
comment|/* #define	NETISR_LOCKING */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net
argument_list|,
name|OID_AUTO
argument_list|,
name|isr
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"netisr"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*-  * Three direct dispatch policies are supported:  *  * - Always defer: all work is scheduled for a netisr, regardless of context.  *   (!direct)  *  * - Hybrid: if the executing context allows direct dispatch, and we're  *   running on the CPU the work would be done on, then direct dispatch if it  *   wouldn't violate ordering constraints on the workstream.  *   (direct&& !direct_force)  *  * - Always direct: if the executing context allows direct dispatch, always  *   direct dispatch.  (direct&& direct_force)  *  * Notice that changing the global policy could lead to short periods of  * misordered processing, but this is considered acceptable as compared to  * the complexity of enforcing ordering during policy changes.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|netisr_direct_force
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Always direct dispatch. */
end_comment

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"net.isr.direct_force"
argument_list|,
operator|&
name|netisr_direct_force
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_isr
argument_list|,
name|OID_AUTO
argument_list|,
name|direct_force
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netisr_direct_force
argument_list|,
literal|0
argument_list|,
literal|"Force direct dispatch"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|netisr_direct
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Enable direct dispatch. */
end_comment

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"net.isr.direct"
argument_list|,
operator|&
name|netisr_direct
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_isr
argument_list|,
name|OID_AUTO
argument_list|,
name|direct
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|netisr_direct
argument_list|,
literal|0
argument_list|,
literal|"Enable direct dispatch"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Allow the administrator to limit the number of threads (CPUs) to use for  * netisr.  We don't check netisr_maxthreads before creating the thread for  * CPU 0, so in practice we ignore values<= 1.  This must be set at boot.  * We will create at most one thread per CPU.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|netisr_maxthreads
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Max number of threads. */
end_comment

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"net.isr.maxthreads"
argument_list|,
operator|&
name|netisr_maxthreads
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_isr
argument_list|,
name|OID_AUTO
argument_list|,
name|maxthreads
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|netisr_maxthreads
argument_list|,
literal|0
argument_list|,
literal|"Use at most this many CPUs for netisr processing"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|netisr_bindthreads
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bind threads to CPUs. */
end_comment

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"net.isr.bindthreads"
argument_list|,
operator|&
name|netisr_bindthreads
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_isr
argument_list|,
name|OID_AUTO
argument_list|,
name|bindthreads
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|netisr_bindthreads
argument_list|,
literal|0
argument_list|,
literal|"Bind netisr threads to CPUs."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Limit per-workstream mbuf queue limits s to at most net.isr.maxqlimit,  * both for initial configuration and later modification using  * netisr_setqlimit().  */
end_comment

begin_define
define|#
directive|define
name|NETISR_DEFAULT_MAXQLIMIT
value|10240
end_define

begin_decl_stmt
specifier|static
name|u_int
name|netisr_maxqlimit
init|=
name|NETISR_DEFAULT_MAXQLIMIT
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"net.isr.maxqlimit"
argument_list|,
operator|&
name|netisr_maxqlimit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_isr
argument_list|,
name|OID_AUTO
argument_list|,
name|maxqlimit
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|netisr_maxqlimit
argument_list|,
literal|0
argument_list|,
literal|"Maximum netisr per-protocol, per-CPU queue depth."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The default per-workstream mbuf queue limit for protocols that don't  * initialize the nh_qlimit field of their struct netisr_handler.  If this is  * set above netisr_maxqlimit, we truncate it to the maximum during boot.  */
end_comment

begin_define
define|#
directive|define
name|NETISR_DEFAULT_DEFAULTQLIMIT
value|256
end_define

begin_decl_stmt
specifier|static
name|u_int
name|netisr_defaultqlimit
init|=
name|NETISR_DEFAULT_DEFAULTQLIMIT
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"net.isr.defaultqlimit"
argument_list|,
operator|&
name|netisr_defaultqlimit
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_isr
argument_list|,
name|OID_AUTO
argument_list|,
name|defaultqlimit
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|netisr_defaultqlimit
argument_list|,
literal|0
argument_list|,
literal|"Default netisr per-protocol, per-CPU queue limit if not set by protocol"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Each protocol is described by a struct netisr_proto, which holds all  * global per-protocol information.  This data structure is set up by  * netisr_register(), and derived from the public struct netisr_handler.  */
end_comment

begin_struct
struct|struct
name|netisr_proto
block|{
specifier|const
name|char
modifier|*
name|np_name
decl_stmt|;
comment|/* Character string protocol name. */
name|netisr_handler_t
modifier|*
name|np_handler
decl_stmt|;
comment|/* Protocol handler. */
name|netisr_m2flow_t
modifier|*
name|np_m2flow
decl_stmt|;
comment|/* Query flow for untagged packet. */
name|netisr_m2cpuid_t
modifier|*
name|np_m2cpuid
decl_stmt|;
comment|/* Query CPU to process packet on. */
name|netisr_drainedcpu_t
modifier|*
name|np_drainedcpu
decl_stmt|;
comment|/* Callback when drained a queue. */
name|u_int
name|np_qlimit
decl_stmt|;
comment|/* Maximum per-CPU queue depth. */
name|u_int
name|np_policy
decl_stmt|;
comment|/* Work placement policy. */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NETISR_MAXPROT
value|16
end_define

begin_comment
comment|/* Compile-time limit. */
end_comment

begin_comment
comment|/*  * The np array describes all registered protocols, indexed by protocol  * number.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|netisr_proto
name|np
index|[
name|NETISR_MAXPROT
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Protocol-specific work for each workstream is described by struct  * netisr_work.  Each work descriptor consists of an mbuf queue and  * statistics.  */
end_comment

begin_struct
struct|struct
name|netisr_work
block|{
comment|/* 	 * Packet queue, linked by m_nextpkt. 	 */
name|struct
name|mbuf
modifier|*
name|nw_head
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|nw_tail
decl_stmt|;
name|u_int
name|nw_len
decl_stmt|;
name|u_int
name|nw_qlimit
decl_stmt|;
name|u_int
name|nw_watermark
decl_stmt|;
comment|/* 	 * Statistics -- written unlocked, but mostly from curcpu. 	 */
name|u_int64_t
name|nw_dispatched
decl_stmt|;
comment|/* Number of direct dispatches. */
name|u_int64_t
name|nw_hybrid_dispatched
decl_stmt|;
comment|/* "" hybrid dispatches. */
name|u_int64_t
name|nw_qdrops
decl_stmt|;
comment|/* "" drops. */
name|u_int64_t
name|nw_queued
decl_stmt|;
comment|/* "" enqueues. */
name|u_int64_t
name|nw_handled
decl_stmt|;
comment|/* "" handled in worker. */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Workstreams hold a queue of ordered work across each protocol, and are  * described by netisr_workstream.  Each workstream is associated with a  * worker thread, which in turn is pinned to a CPU.  Work associated with a  * workstream can be processd in other threads during direct dispatch;  * concurrent processing is prevented by the NWS_RUNNING flag, which  * indicates that a thread is already processing the work queue.  It is  * important to prevent a directly dispatched packet from "skipping ahead" of  * work already in the workstream queue.  */
end_comment

begin_struct
struct|struct
name|netisr_workstream
block|{
name|struct
name|intr_event
modifier|*
name|nws_intr_event
decl_stmt|;
comment|/* Handler for stream. */
name|void
modifier|*
name|nws_swi_cookie
decl_stmt|;
comment|/* swi(9) cookie for stream. */
name|struct
name|mtx
name|nws_mtx
decl_stmt|;
comment|/* Synchronize work. */
name|u_int
name|nws_cpu
decl_stmt|;
comment|/* CPU pinning. */
name|u_int
name|nws_flags
decl_stmt|;
comment|/* Wakeup flags. */
name|u_int
name|nws_pendingbits
decl_stmt|;
comment|/* Scheduled protocols. */
comment|/* 	 * Each protocol has per-workstream data. 	 */
name|struct
name|netisr_work
name|nws_work
index|[
name|NETISR_MAXPROT
index|]
decl_stmt|;
block|}
name|__aligned
argument_list|(
name|CACHE_LINE_SIZE
argument_list|)
struct|;
end_struct

begin_comment
comment|/*  * Per-CPU workstream data.  */
end_comment

begin_expr_stmt
name|DPCPU_DEFINE
argument_list|(
expr|struct
name|netisr_workstream
argument_list|,
name|nws
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Map contiguous values between 0 and nws_count into CPU IDs appropriate for  * accessing workstreams.  This allows constructions of the form  * DPCPU_ID_GET(nws_array[arbitraryvalue % nws_count], nws).  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|nws_array
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Number of registered workstreams.  Will be at most the number of running  * CPUs once fully started.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|nws_count
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_isr
argument_list|,
name|OID_AUTO
argument_list|,
name|numthreads
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|nws_count
argument_list|,
literal|0
argument_list|,
literal|"Number of extant netisr threads."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Per-workstream flags.  */
end_comment

begin_define
define|#
directive|define
name|NWS_RUNNING
value|0x00000001
end_define

begin_comment
comment|/* Currently running in a thread. */
end_comment

begin_define
define|#
directive|define
name|NWS_DISPATCHING
value|0x00000002
end_define

begin_comment
comment|/* Currently being direct-dispatched. */
end_comment

begin_define
define|#
directive|define
name|NWS_SCHEDULED
value|0x00000004
end_define

begin_comment
comment|/* Signal issued. */
end_comment

begin_comment
comment|/*  * Synchronization for each workstream: a mutex protects all mutable fields  * in each stream, including per-protocol state (mbuf queues).  The SWI is  * woken up if asynchronous dispatch is required.  */
end_comment

begin_define
define|#
directive|define
name|NWS_LOCK
parameter_list|(
name|s
parameter_list|)
value|mtx_lock(&(s)->nws_mtx)
end_define

begin_define
define|#
directive|define
name|NWS_LOCK_ASSERT
parameter_list|(
name|s
parameter_list|)
value|mtx_assert(&(s)->nws_mtx, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|NWS_UNLOCK
parameter_list|(
name|s
parameter_list|)
value|mtx_unlock(&(s)->nws_mtx)
end_define

begin_define
define|#
directive|define
name|NWS_SIGNAL
parameter_list|(
name|s
parameter_list|)
value|swi_sched((s)->nws_swi_cookie, 0)
end_define

begin_comment
comment|/*  * Utility routines for protocols that implement their own mapping of flows  * to CPUs.  */
end_comment

begin_function
name|u_int
name|netisr_get_cpucount
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|nws_count
operator|)
return|;
block|}
end_function

begin_function
name|u_int
name|netisr_get_cpuid
parameter_list|(
name|u_int
name|cpunumber
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|cpunumber
operator|<
name|nws_count
argument_list|,
operator|(
literal|"%s: %u> %u"
operator|,
name|__func__
operator|,
name|cpunumber
operator|,
name|nws_count
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|nws_array
index|[
name|cpunumber
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The default implementation of flow -> CPU ID mapping.  *  * Non-static so that protocols can use it to map their own work to specific  * CPUs in a manner consistent to netisr for affinity purposes.  */
end_comment

begin_function
name|u_int
name|netisr_default_flow2cpu
parameter_list|(
name|u_int
name|flowid
parameter_list|)
block|{
return|return
operator|(
name|nws_array
index|[
name|flowid
operator|%
name|nws_count
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Register a new netisr handler, which requires initializing per-protocol  * fields for each workstream.  All netisr work is briefly suspended while  * the protocol is installed.  */
end_comment

begin_function
name|void
name|netisr_register
parameter_list|(
specifier|const
name|struct
name|netisr_handler
modifier|*
name|nhp
parameter_list|)
block|{
name|struct
name|netisr_work
modifier|*
name|npwp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|proto
decl_stmt|;
name|proto
operator|=
name|nhp
operator|->
name|nh_proto
expr_stmt|;
name|name
operator|=
name|nhp
operator|->
name|nh_name
expr_stmt|;
comment|/* 	 * Test that the requested registration is valid. 	 */
name|KASSERT
argument_list|(
name|nhp
operator|->
name|nh_name
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: nh_name NULL for %u"
operator|,
name|__func__
operator|,
name|proto
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nhp
operator|->
name|nh_handler
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: nh_handler NULL for %s"
operator|,
name|__func__
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nhp
operator|->
name|nh_policy
operator|==
name|NETISR_POLICY_SOURCE
operator|||
name|nhp
operator|->
name|nh_policy
operator|==
name|NETISR_POLICY_FLOW
operator|||
name|nhp
operator|->
name|nh_policy
operator|==
name|NETISR_POLICY_CPU
argument_list|,
operator|(
literal|"%s: unsupported nh_policy %u for %s"
operator|,
name|__func__
operator|,
name|nhp
operator|->
name|nh_policy
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nhp
operator|->
name|nh_policy
operator|==
name|NETISR_POLICY_FLOW
operator|||
name|nhp
operator|->
name|nh_m2flow
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: nh_policy != FLOW but m2flow defined for %s"
operator|,
name|__func__
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nhp
operator|->
name|nh_policy
operator|==
name|NETISR_POLICY_CPU
operator|||
name|nhp
operator|->
name|nh_m2cpuid
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: nh_policy != CPU but m2cpuid defined for %s"
operator|,
name|__func__
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nhp
operator|->
name|nh_policy
operator|!=
name|NETISR_POLICY_CPU
operator|||
name|nhp
operator|->
name|nh_m2cpuid
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: nh_policy == CPU but m2cpuid not defined for %s"
operator|,
name|__func__
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|proto
operator|<
name|NETISR_MAXPROT
argument_list|,
operator|(
literal|"%s(%u, %s): protocol too big"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Test that no existing registration exists for this protocol. 	 */
name|NETISR_WLOCK
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|np
index|[
name|proto
index|]
operator|.
name|np_name
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s(%u, %s): name present"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|np
index|[
name|proto
index|]
operator|.
name|np_handler
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s(%u, %s): handler present"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|np
index|[
name|proto
index|]
operator|.
name|np_name
operator|=
name|name
expr_stmt|;
name|np
index|[
name|proto
index|]
operator|.
name|np_handler
operator|=
name|nhp
operator|->
name|nh_handler
expr_stmt|;
name|np
index|[
name|proto
index|]
operator|.
name|np_m2flow
operator|=
name|nhp
operator|->
name|nh_m2flow
expr_stmt|;
name|np
index|[
name|proto
index|]
operator|.
name|np_m2cpuid
operator|=
name|nhp
operator|->
name|nh_m2cpuid
expr_stmt|;
name|np
index|[
name|proto
index|]
operator|.
name|np_drainedcpu
operator|=
name|nhp
operator|->
name|nh_drainedcpu
expr_stmt|;
if|if
condition|(
name|nhp
operator|->
name|nh_qlimit
operator|==
literal|0
condition|)
name|np
index|[
name|proto
index|]
operator|.
name|np_qlimit
operator|=
name|netisr_defaultqlimit
expr_stmt|;
elseif|else
if|if
condition|(
name|nhp
operator|->
name|nh_qlimit
operator|>
name|netisr_maxqlimit
condition|)
block|{
name|printf
argument_list|(
literal|"%s: %s requested queue limit %u capped to "
literal|"net.isr.maxqlimit %u\n"
argument_list|,
name|__func__
argument_list|,
name|name
argument_list|,
name|nhp
operator|->
name|nh_qlimit
argument_list|,
name|netisr_maxqlimit
argument_list|)
expr_stmt|;
name|np
index|[
name|proto
index|]
operator|.
name|np_qlimit
operator|=
name|netisr_maxqlimit
expr_stmt|;
block|}
else|else
name|np
index|[
name|proto
index|]
operator|.
name|np_qlimit
operator|=
name|nhp
operator|->
name|nh_qlimit
expr_stmt|;
name|np
index|[
name|proto
index|]
operator|.
name|np_policy
operator|=
name|nhp
operator|->
name|nh_policy
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|mp_maxid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
name|npwp
operator|=
operator|&
operator|(
name|DPCPU_ID_PTR
argument_list|(
name|i
argument_list|,
name|nws
argument_list|)
operator|)
operator|->
name|nws_work
index|[
name|proto
index|]
expr_stmt|;
name|bzero
argument_list|(
name|npwp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|npwp
argument_list|)
argument_list|)
expr_stmt|;
name|npwp
operator|->
name|nw_qlimit
operator|=
name|np
index|[
name|proto
index|]
operator|.
name|np_qlimit
expr_stmt|;
block|}
name|NETISR_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear drop counters across all workstreams for a protocol.  */
end_comment

begin_function
name|void
name|netisr_clearqdrops
parameter_list|(
specifier|const
name|struct
name|netisr_handler
modifier|*
name|nhp
parameter_list|)
block|{
name|struct
name|netisr_work
modifier|*
name|npwp
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
endif|#
directive|endif
name|u_int
name|i
decl_stmt|,
name|proto
decl_stmt|;
name|proto
operator|=
name|nhp
operator|->
name|nh_proto
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|name
operator|=
name|nhp
operator|->
name|nh_name
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|proto
operator|<
name|NETISR_MAXPROT
argument_list|,
operator|(
literal|"%s(%u): protocol too big for %s"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|NETISR_WLOCK
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|np
index|[
name|proto
index|]
operator|.
name|np_handler
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s(%u): protocol not registered for %s"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|mp_maxid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
name|npwp
operator|=
operator|&
operator|(
name|DPCPU_ID_PTR
argument_list|(
name|i
argument_list|,
name|nws
argument_list|)
operator|)
operator|->
name|nws_work
index|[
name|proto
index|]
expr_stmt|;
name|npwp
operator|->
name|nw_qdrops
operator|=
literal|0
expr_stmt|;
block|}
name|NETISR_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Query current drop counters across all workstreams for a protocol.  */
end_comment

begin_function
name|void
name|netisr_getqdrops
parameter_list|(
specifier|const
name|struct
name|netisr_handler
modifier|*
name|nhp
parameter_list|,
name|u_int64_t
modifier|*
name|qdropp
parameter_list|)
block|{
name|struct
name|netisr_work
modifier|*
name|npwp
decl_stmt|;
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
endif|#
directive|endif
name|u_int
name|i
decl_stmt|,
name|proto
decl_stmt|;
operator|*
name|qdropp
operator|=
literal|0
expr_stmt|;
name|proto
operator|=
name|nhp
operator|->
name|nh_proto
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|name
operator|=
name|nhp
operator|->
name|nh_name
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|proto
operator|<
name|NETISR_MAXPROT
argument_list|,
operator|(
literal|"%s(%u): protocol too big for %s"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|NETISR_RLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|np
index|[
name|proto
index|]
operator|.
name|np_handler
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s(%u): protocol not registered for %s"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|mp_maxid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
name|npwp
operator|=
operator|&
operator|(
name|DPCPU_ID_PTR
argument_list|(
name|i
argument_list|,
name|nws
argument_list|)
operator|)
operator|->
name|nws_work
index|[
name|proto
index|]
expr_stmt|;
operator|*
name|qdropp
operator|+=
name|npwp
operator|->
name|nw_qdrops
expr_stmt|;
block|}
name|NETISR_RUNLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Query current per-workstream queue limit for a protocol.  */
end_comment

begin_function
name|void
name|netisr_getqlimit
parameter_list|(
specifier|const
name|struct
name|netisr_handler
modifier|*
name|nhp
parameter_list|,
name|u_int
modifier|*
name|qlimitp
parameter_list|)
block|{
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
endif|#
directive|endif
name|u_int
name|proto
decl_stmt|;
name|proto
operator|=
name|nhp
operator|->
name|nh_proto
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|name
operator|=
name|nhp
operator|->
name|nh_name
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|proto
operator|<
name|NETISR_MAXPROT
argument_list|,
operator|(
literal|"%s(%u): protocol too big for %s"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|NETISR_RLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|np
index|[
name|proto
index|]
operator|.
name|np_handler
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s(%u): protocol not registered for %s"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
operator|*
name|qlimitp
operator|=
name|np
index|[
name|proto
index|]
operator|.
name|np_qlimit
expr_stmt|;
name|NETISR_RUNLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the queue limit across per-workstream queues for a protocol.  We  * simply change the limits, and don't drain overflowed packets as they will  * (hopefully) take care of themselves shortly.  */
end_comment

begin_function
name|int
name|netisr_setqlimit
parameter_list|(
specifier|const
name|struct
name|netisr_handler
modifier|*
name|nhp
parameter_list|,
name|u_int
name|qlimit
parameter_list|)
block|{
name|struct
name|netisr_work
modifier|*
name|npwp
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
endif|#
directive|endif
name|u_int
name|i
decl_stmt|,
name|proto
decl_stmt|;
if|if
condition|(
name|qlimit
operator|>
name|netisr_maxqlimit
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|proto
operator|=
name|nhp
operator|->
name|nh_proto
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|name
operator|=
name|nhp
operator|->
name|nh_name
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|proto
operator|<
name|NETISR_MAXPROT
argument_list|,
operator|(
literal|"%s(%u): protocol too big for %s"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|NETISR_WLOCK
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|np
index|[
name|proto
index|]
operator|.
name|np_handler
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s(%u): protocol not registered for %s"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|np
index|[
name|proto
index|]
operator|.
name|np_qlimit
operator|=
name|qlimit
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|mp_maxid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
name|npwp
operator|=
operator|&
operator|(
name|DPCPU_ID_PTR
argument_list|(
name|i
argument_list|,
name|nws
argument_list|)
operator|)
operator|->
name|nws_work
index|[
name|proto
index|]
expr_stmt|;
name|npwp
operator|->
name|nw_qlimit
operator|=
name|qlimit
expr_stmt|;
block|}
name|NETISR_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Drain all packets currently held in a particular protocol work queue.  */
end_comment

begin_function
specifier|static
name|void
name|netisr_drain_proto
parameter_list|(
name|struct
name|netisr_work
modifier|*
name|npwp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* 	 * We would assert the lock on the workstream but it's not passed in. 	 */
while|while
condition|(
operator|(
name|m
operator|=
name|npwp
operator|->
name|nw_head
operator|)
operator|!=
name|NULL
condition|)
block|{
name|npwp
operator|->
name|nw_head
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|npwp
operator|->
name|nw_head
operator|==
name|NULL
condition|)
name|npwp
operator|->
name|nw_tail
operator|=
name|NULL
expr_stmt|;
name|npwp
operator|->
name|nw_len
operator|--
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|npwp
operator|->
name|nw_tail
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: tail"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|npwp
operator|->
name|nw_len
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: len"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove the registration of a network protocol, which requires clearing  * per-protocol fields across all workstreams, including freeing all mbufs in  * the queues at time of unregister.  All work in netisr is briefly suspended  * while this takes place.  */
end_comment

begin_function
name|void
name|netisr_unregister
parameter_list|(
specifier|const
name|struct
name|netisr_handler
modifier|*
name|nhp
parameter_list|)
block|{
name|struct
name|netisr_work
modifier|*
name|npwp
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
endif|#
directive|endif
name|u_int
name|i
decl_stmt|,
name|proto
decl_stmt|;
name|proto
operator|=
name|nhp
operator|->
name|nh_proto
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|name
operator|=
name|nhp
operator|->
name|nh_name
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|proto
operator|<
name|NETISR_MAXPROT
argument_list|,
operator|(
literal|"%s(%u): protocol too big for %s"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|NETISR_WLOCK
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|np
index|[
name|proto
index|]
operator|.
name|np_handler
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s(%u): protocol not registered for %s"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|np
index|[
name|proto
index|]
operator|.
name|np_name
operator|=
name|NULL
expr_stmt|;
name|np
index|[
name|proto
index|]
operator|.
name|np_handler
operator|=
name|NULL
expr_stmt|;
name|np
index|[
name|proto
index|]
operator|.
name|np_m2flow
operator|=
name|NULL
expr_stmt|;
name|np
index|[
name|proto
index|]
operator|.
name|np_m2cpuid
operator|=
name|NULL
expr_stmt|;
name|np
index|[
name|proto
index|]
operator|.
name|np_qlimit
operator|=
literal|0
expr_stmt|;
name|np
index|[
name|proto
index|]
operator|.
name|np_policy
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|mp_maxid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
name|npwp
operator|=
operator|&
operator|(
name|DPCPU_ID_PTR
argument_list|(
name|i
argument_list|,
name|nws
argument_list|)
operator|)
operator|->
name|nws_work
index|[
name|proto
index|]
expr_stmt|;
name|netisr_drain_proto
argument_list|(
name|npwp
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|npwp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|npwp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|NETISR_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look up the workstream given a packet and source identifier.  Do this by  * checking the protocol's policy, and optionally call out to the protocol  * for assistance if required.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|netisr_select_cpuid
parameter_list|(
name|struct
name|netisr_proto
modifier|*
name|npp
parameter_list|,
name|uintptr_t
name|source
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u_int
modifier|*
name|cpuidp
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|NETISR_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/* 	 * In the event we have only one worker, shortcut and deliver to it 	 * without further ado. 	 */
if|if
condition|(
name|nws_count
operator|==
literal|1
condition|)
block|{
operator|*
name|cpuidp
operator|=
name|nws_array
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
comment|/* 	 * What happens next depends on the policy selected by the protocol. 	 * If we want to support per-interface policies, we should do that 	 * here first. 	 */
switch|switch
condition|(
name|npp
operator|->
name|np_policy
condition|)
block|{
case|case
name|NETISR_POLICY_CPU
case|:
return|return
operator|(
name|npp
operator|->
name|np_m2cpuid
argument_list|(
name|m
argument_list|,
name|source
argument_list|,
name|cpuidp
argument_list|)
operator|)
return|;
case|case
name|NETISR_POLICY_FLOW
case|:
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_FLOWID
operator|)
operator|&&
name|npp
operator|->
name|np_m2flow
operator|!=
name|NULL
condition|)
block|{
name|m
operator|=
name|npp
operator|->
name|np_m2flow
argument_list|(
name|m
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_FLOWID
condition|)
block|{
operator|*
name|cpuidp
operator|=
name|netisr_default_flow2cpu
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
comment|/* FALLTHROUGH */
case|case
name|NETISR_POLICY_SOURCE
case|:
name|ifp
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
operator|*
name|cpuidp
operator|=
name|nws_array
index|[
operator|(
name|ifp
operator|->
name|if_index
operator|+
name|source
operator|)
operator|%
name|nws_count
index|]
expr_stmt|;
else|else
operator|*
name|cpuidp
operator|=
name|nws_array
index|[
name|source
operator|%
name|nws_count
index|]
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"%s: invalid policy %u for %s"
argument_list|,
name|__func__
argument_list|,
name|npp
operator|->
name|np_policy
argument_list|,
name|npp
operator|->
name|np_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process packets associated with a workstream and protocol.  For reasons of  * fairness, we process up to one complete netisr queue at a time, moving the  * queue to a stack-local queue for processing, but do not loop refreshing  * from the global queue.  The caller is responsible for deciding whether to  * loop, and for setting the NWS_RUNNING flag.  The passed workstream will be  * locked on entry and relocked before return, but will be released while  * processing.  The number of packets processed is returned.  */
end_comment

begin_function
specifier|static
name|u_int
name|netisr_process_workstream_proto
parameter_list|(
name|struct
name|netisr_workstream
modifier|*
name|nwsp
parameter_list|,
name|u_int
name|proto
parameter_list|)
block|{
name|struct
name|netisr_work
name|local_npw
decl_stmt|,
modifier|*
name|npwp
decl_stmt|;
name|u_int
name|handled
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|NETISR_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|NWS_LOCK_ASSERT
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nwsp
operator|->
name|nws_flags
operator|&
name|NWS_RUNNING
argument_list|,
operator|(
literal|"%s(%u): not running"
operator|,
name|__func__
operator|,
name|proto
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|proto
operator|>=
literal|0
operator|&&
name|proto
operator|<
name|NETISR_MAXPROT
argument_list|,
operator|(
literal|"%s(%u): invalid proto\n"
operator|,
name|__func__
operator|,
name|proto
operator|)
argument_list|)
expr_stmt|;
name|npwp
operator|=
operator|&
name|nwsp
operator|->
name|nws_work
index|[
name|proto
index|]
expr_stmt|;
if|if
condition|(
name|npwp
operator|->
name|nw_len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Move the global work queue to a thread-local work queue. 	 * 	 * Notice that this means the effective maximum length of the queue 	 * is actually twice that of the maximum queue length specified in 	 * the protocol registration call. 	 */
name|handled
operator|=
name|npwp
operator|->
name|nw_len
expr_stmt|;
name|local_npw
operator|=
operator|*
name|npwp
expr_stmt|;
name|npwp
operator|->
name|nw_head
operator|=
name|NULL
expr_stmt|;
name|npwp
operator|->
name|nw_tail
operator|=
name|NULL
expr_stmt|;
name|npwp
operator|->
name|nw_len
operator|=
literal|0
expr_stmt|;
name|nwsp
operator|->
name|nws_pendingbits
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|proto
operator|)
expr_stmt|;
name|NWS_UNLOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|local_npw
operator|.
name|nw_head
operator|)
operator|!=
name|NULL
condition|)
block|{
name|local_npw
operator|.
name|nw_head
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|local_npw
operator|.
name|nw_head
operator|==
name|NULL
condition|)
name|local_npw
operator|.
name|nw_tail
operator|=
name|NULL
expr_stmt|;
name|local_npw
operator|.
name|nw_len
operator|--
expr_stmt|;
name|VNET_ASSERT
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|np
index|[
name|proto
index|]
operator|.
name|np_handler
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|local_npw
operator|.
name|nw_len
operator|==
literal|0
argument_list|,
operator|(
literal|"%s(%u): len %u"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|local_npw
operator|.
name|nw_len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
index|[
name|proto
index|]
operator|.
name|np_drainedcpu
condition|)
name|np
index|[
name|proto
index|]
operator|.
name|np_drainedcpu
argument_list|(
name|nwsp
operator|->
name|nws_cpu
argument_list|)
expr_stmt|;
name|NWS_LOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
name|npwp
operator|->
name|nw_handled
operator|+=
name|handled
expr_stmt|;
return|return
operator|(
name|handled
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SWI handler for netisr -- processes packets in a set of workstreams that  * it owns, woken up by calls to NWS_SIGNAL().  If this workstream is already  * being direct dispatched, go back to sleep and wait for the dispatching  * thread to wake us up again.  */
end_comment

begin_function
specifier|static
name|void
name|swi_net
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NETISR_LOCKING
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
endif|#
directive|endif
name|struct
name|netisr_workstream
modifier|*
name|nwsp
decl_stmt|;
name|u_int
name|bits
decl_stmt|,
name|prot
decl_stmt|;
name|nwsp
operator|=
name|arg
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
name|KASSERT
argument_list|(
name|nws_count
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: device_polling but nws_count != 1"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|netisr_poll
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NETISR_LOCKING
name|NETISR_RLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|NWS_LOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|nwsp
operator|->
name|nws_flags
operator|&
name|NWS_RUNNING
operator|)
argument_list|,
operator|(
literal|"swi_net: running"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwsp
operator|->
name|nws_flags
operator|&
name|NWS_DISPATCHING
condition|)
goto|goto
name|out
goto|;
name|nwsp
operator|->
name|nws_flags
operator||=
name|NWS_RUNNING
expr_stmt|;
name|nwsp
operator|->
name|nws_flags
operator|&=
operator|~
name|NWS_SCHEDULED
expr_stmt|;
while|while
condition|(
operator|(
name|bits
operator|=
name|nwsp
operator|->
name|nws_pendingbits
operator|)
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|prot
operator|=
name|ffs
argument_list|(
name|bits
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|prot
operator|--
expr_stmt|;
name|bits
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|prot
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|netisr_process_workstream_proto
argument_list|(
name|nwsp
argument_list|,
name|prot
argument_list|)
expr_stmt|;
block|}
block|}
name|nwsp
operator|->
name|nws_flags
operator|&=
operator|~
name|NWS_RUNNING
expr_stmt|;
name|out
label|:
name|NWS_UNLOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NETISR_LOCKING
name|NETISR_RUNLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEVICE_POLLING
name|netisr_pollmore
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|netisr_queue_workstream
parameter_list|(
name|struct
name|netisr_workstream
modifier|*
name|nwsp
parameter_list|,
name|u_int
name|proto
parameter_list|,
name|struct
name|netisr_work
modifier|*
name|npwp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
modifier|*
name|dosignalp
parameter_list|)
block|{
name|NWS_LOCK_ASSERT
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
operator|*
name|dosignalp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|npwp
operator|->
name|nw_len
operator|<
name|npwp
operator|->
name|nw_qlimit
condition|)
block|{
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|npwp
operator|->
name|nw_head
operator|==
name|NULL
condition|)
block|{
name|npwp
operator|->
name|nw_head
operator|=
name|m
expr_stmt|;
name|npwp
operator|->
name|nw_tail
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
name|npwp
operator|->
name|nw_tail
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
name|npwp
operator|->
name|nw_tail
operator|=
name|m
expr_stmt|;
block|}
name|npwp
operator|->
name|nw_len
operator|++
expr_stmt|;
if|if
condition|(
name|npwp
operator|->
name|nw_len
operator|>
name|npwp
operator|->
name|nw_watermark
condition|)
name|npwp
operator|->
name|nw_watermark
operator|=
name|npwp
operator|->
name|nw_len
expr_stmt|;
comment|/* 		 * We must set the bit regardless of NWS_RUNNING, so that 		 * swi_net() keeps calling netisr_process_workstream_proto(). 		 */
name|nwsp
operator|->
name|nws_pendingbits
operator||=
operator|(
literal|1
operator|<<
name|proto
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nwsp
operator|->
name|nws_flags
operator|&
operator|(
name|NWS_RUNNING
operator||
name|NWS_DISPATCHING
operator||
name|NWS_SCHEDULED
operator|)
operator|)
condition|)
block|{
name|nwsp
operator|->
name|nws_flags
operator||=
name|NWS_SCHEDULED
expr_stmt|;
operator|*
name|dosignalp
operator|=
literal|1
expr_stmt|;
comment|/* Defer until unlocked. */
block|}
name|npwp
operator|->
name|nw_queued
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|npwp
operator|->
name|nw_qdrops
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|netisr_queue_internal
parameter_list|(
name|u_int
name|proto
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u_int
name|cpuid
parameter_list|)
block|{
name|struct
name|netisr_workstream
modifier|*
name|nwsp
decl_stmt|;
name|struct
name|netisr_work
modifier|*
name|npwp
decl_stmt|;
name|int
name|dosignal
decl_stmt|,
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|NETISR_LOCKING
name|NETISR_LOCK_ASSERT
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|cpuid
operator|<=
name|mp_maxid
argument_list|,
operator|(
literal|"%s: cpuid too big (%u, %u)"
operator|,
name|__func__
operator|,
name|cpuid
operator|,
name|mp_maxid
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|CPU_ABSENT
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|(
literal|"%s: CPU %u absent"
operator|,
name|__func__
operator|,
name|cpuid
operator|)
argument_list|)
expr_stmt|;
name|dosignal
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|nwsp
operator|=
name|DPCPU_ID_PTR
argument_list|(
name|cpuid
argument_list|,
name|nws
argument_list|)
expr_stmt|;
name|npwp
operator|=
operator|&
name|nwsp
operator|->
name|nws_work
index|[
name|proto
index|]
expr_stmt|;
name|NWS_LOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
name|error
operator|=
name|netisr_queue_workstream
argument_list|(
name|nwsp
argument_list|,
name|proto
argument_list|,
name|npwp
argument_list|,
name|m
argument_list|,
operator|&
name|dosignal
argument_list|)
expr_stmt|;
name|NWS_UNLOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dosignal
condition|)
name|NWS_SIGNAL
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|netisr_queue_src
parameter_list|(
name|u_int
name|proto
parameter_list|,
name|uintptr_t
name|source
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NETISR_LOCKING
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
endif|#
directive|endif
name|u_int
name|cpuid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|proto
operator|<
name|NETISR_MAXPROT
argument_list|,
operator|(
literal|"%s: invalid proto %u"
operator|,
name|__func__
operator|,
name|proto
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NETISR_LOCKING
name|NETISR_RLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|np
index|[
name|proto
index|]
operator|.
name|np_handler
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: invalid proto %u"
operator|,
name|__func__
operator|,
name|proto
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|netisr_select_cpuid
argument_list|(
operator|&
name|np
index|[
name|proto
index|]
argument_list|,
name|source
argument_list|,
name|m
argument_list|,
operator|&
name|cpuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|!
name|CPU_ABSENT
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|(
literal|"%s: CPU %u absent"
operator|,
name|__func__
operator|,
name|cpuid
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|netisr_queue_internal
argument_list|(
name|proto
argument_list|,
name|m
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ENOBUFS
expr_stmt|;
ifdef|#
directive|ifdef
name|NETISR_LOCKING
name|NETISR_RUNLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|netisr_queue
parameter_list|(
name|u_int
name|proto
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
operator|(
name|netisr_queue_src
argument_list|(
name|proto
argument_list|,
literal|0
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dispatch a packet for netisr processing; direct dispatch is permitted by  * calling context.  */
end_comment

begin_function
name|int
name|netisr_dispatch_src
parameter_list|(
name|u_int
name|proto
parameter_list|,
name|uintptr_t
name|source
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NETISR_LOCKING
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
endif|#
directive|endif
name|struct
name|netisr_workstream
modifier|*
name|nwsp
decl_stmt|;
name|struct
name|netisr_work
modifier|*
name|npwp
decl_stmt|;
name|int
name|dosignal
decl_stmt|,
name|error
decl_stmt|;
name|u_int
name|cpuid
decl_stmt|;
comment|/* 	 * If direct dispatch is entirely disabled, fall back on queueing. 	 */
if|if
condition|(
operator|!
name|netisr_direct
condition|)
return|return
operator|(
name|netisr_queue_src
argument_list|(
name|proto
argument_list|,
name|source
argument_list|,
name|m
argument_list|)
operator|)
return|;
name|KASSERT
argument_list|(
name|proto
operator|<
name|NETISR_MAXPROT
argument_list|,
operator|(
literal|"%s: invalid proto %u"
operator|,
name|__func__
operator|,
name|proto
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NETISR_LOCKING
name|NETISR_RLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|np
index|[
name|proto
index|]
operator|.
name|np_handler
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: invalid proto %u"
operator|,
name|__func__
operator|,
name|proto
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If direct dispatch is forced, then unconditionally dispatch 	 * without a formal CPU selection.  Borrow the current CPU's stats, 	 * even if there's no worker on it.  In this case we don't update 	 * nws_flags because all netisr processing will be source ordered due 	 * to always being forced to directly dispatch. 	 */
if|if
condition|(
name|netisr_direct_force
condition|)
block|{
name|nwsp
operator|=
name|DPCPU_PTR
argument_list|(
name|nws
argument_list|)
expr_stmt|;
name|npwp
operator|=
operator|&
name|nwsp
operator|->
name|nws_work
index|[
name|proto
index|]
expr_stmt|;
name|npwp
operator|->
name|nw_dispatched
operator|++
expr_stmt|;
name|npwp
operator|->
name|nw_handled
operator|++
expr_stmt|;
name|np
index|[
name|proto
index|]
operator|.
name|np_handler
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
comment|/* 	 * Otherwise, we execute in a hybrid mode where we will try to direct 	 * dispatch if we're on the right CPU and the netisr worker isn't 	 * already running. 	 */
name|m
operator|=
name|netisr_select_cpuid
argument_list|(
operator|&
name|np
index|[
name|proto
index|]
argument_list|,
name|source
argument_list|,
name|m
argument_list|,
operator|&
name|cpuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|KASSERT
argument_list|(
operator|!
name|CPU_ABSENT
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|(
literal|"%s: CPU %u absent"
operator|,
name|__func__
operator|,
name|cpuid
operator|)
argument_list|)
expr_stmt|;
name|sched_pin
argument_list|()
expr_stmt|;
if|if
condition|(
name|cpuid
operator|!=
name|curcpu
condition|)
goto|goto
name|queue_fallback
goto|;
name|nwsp
operator|=
name|DPCPU_PTR
argument_list|(
name|nws
argument_list|)
expr_stmt|;
name|npwp
operator|=
operator|&
name|nwsp
operator|->
name|nws_work
index|[
name|proto
index|]
expr_stmt|;
comment|/*- 	 * We are willing to direct dispatch only if three conditions hold: 	 * 	 * (1) The netisr worker isn't already running, 	 * (2) Another thread isn't already directly dispatching, and 	 * (3) The netisr hasn't already been woken up. 	 */
name|NWS_LOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwsp
operator|->
name|nws_flags
operator|&
operator|(
name|NWS_RUNNING
operator||
name|NWS_DISPATCHING
operator||
name|NWS_SCHEDULED
operator|)
condition|)
block|{
name|error
operator|=
name|netisr_queue_workstream
argument_list|(
name|nwsp
argument_list|,
name|proto
argument_list|,
name|npwp
argument_list|,
name|m
argument_list|,
operator|&
name|dosignal
argument_list|)
expr_stmt|;
name|NWS_UNLOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dosignal
condition|)
name|NWS_SIGNAL
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
goto|goto
name|out_unpin
goto|;
block|}
comment|/* 	 * The current thread is now effectively the netisr worker, so set 	 * the dispatching flag to prevent concurrent processing of the 	 * stream from another thread (even the netisr worker), which could 	 * otherwise lead to effective misordering of the stream. 	 */
name|nwsp
operator|->
name|nws_flags
operator||=
name|NWS_DISPATCHING
expr_stmt|;
name|NWS_UNLOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
name|np
index|[
name|proto
index|]
operator|.
name|np_handler
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NWS_LOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
name|nwsp
operator|->
name|nws_flags
operator|&=
operator|~
name|NWS_DISPATCHING
expr_stmt|;
name|npwp
operator|->
name|nw_handled
operator|++
expr_stmt|;
name|npwp
operator|->
name|nw_hybrid_dispatched
operator|++
expr_stmt|;
comment|/* 	 * If other work was enqueued by another thread while we were direct 	 * dispatching, we need to signal the netisr worker to do that work. 	 * In the future, we might want to do some of that work in the 	 * current thread, rather than trigger further context switches.  If 	 * so, we'll want to establish a reasonable bound on the work done in 	 * the "borrowed" context. 	 */
if|if
condition|(
name|nwsp
operator|->
name|nws_pendingbits
operator|!=
literal|0
condition|)
block|{
name|nwsp
operator|->
name|nws_flags
operator||=
name|NWS_SCHEDULED
expr_stmt|;
name|dosignal
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|dosignal
operator|=
literal|0
expr_stmt|;
name|NWS_UNLOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dosignal
condition|)
name|NWS_SIGNAL
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out_unpin
goto|;
name|queue_fallback
label|:
name|error
operator|=
name|netisr_queue_internal
argument_list|(
name|proto
argument_list|,
name|m
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
name|out_unpin
label|:
name|sched_unpin
argument_list|()
expr_stmt|;
name|out_unlock
label|:
ifdef|#
directive|ifdef
name|NETISR_LOCKING
name|NETISR_RUNLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|netisr_dispatch
parameter_list|(
name|u_int
name|proto
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
operator|(
name|netisr_dispatch_src
argument_list|(
name|proto
argument_list|,
literal|0
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_comment
comment|/*  * Kernel polling borrows a netisr thread to run interface polling in; this  * function allows kernel polling to request that the netisr thread be  * scheduled even if no packets are pending for protocols.  */
end_comment

begin_function
name|void
name|netisr_sched_poll
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|netisr_workstream
modifier|*
name|nwsp
decl_stmt|;
name|nwsp
operator|=
name|DPCPU_ID_PTR
argument_list|(
name|nws_array
index|[
literal|0
index|]
argument_list|,
name|nws
argument_list|)
expr_stmt|;
name|NWS_SIGNAL
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|netisr_start_swi
parameter_list|(
name|u_int
name|cpuid
parameter_list|,
name|struct
name|pcpu
modifier|*
name|pc
parameter_list|)
block|{
name|char
name|swiname
index|[
literal|12
index|]
decl_stmt|;
name|struct
name|netisr_workstream
modifier|*
name|nwsp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
name|CPU_ABSENT
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|(
literal|"%s: CPU %u absent"
operator|,
name|__func__
operator|,
name|cpuid
operator|)
argument_list|)
expr_stmt|;
name|nwsp
operator|=
name|DPCPU_ID_PTR
argument_list|(
name|cpuid
argument_list|,
name|nws
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|nwsp
operator|->
name|nws_mtx
argument_list|,
literal|"netisr_mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|nwsp
operator|->
name|nws_cpu
operator|=
name|cpuid
expr_stmt|;
name|snprintf
argument_list|(
name|swiname
argument_list|,
sizeof|sizeof
argument_list|(
name|swiname
argument_list|)
argument_list|,
literal|"netisr %u"
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
name|error
operator|=
name|swi_add
argument_list|(
operator|&
name|nwsp
operator|->
name|nws_intr_event
argument_list|,
name|swiname
argument_list|,
name|swi_net
argument_list|,
name|nwsp
argument_list|,
name|SWI_NET
argument_list|,
name|INTR_MPSAFE
argument_list|,
operator|&
name|nwsp
operator|->
name|nws_swi_cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"%s: swi_add %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_netisr
operator|=
name|nwsp
operator|->
name|nws_intr_event
expr_stmt|;
if|if
condition|(
name|netisr_bindthreads
condition|)
block|{
name|error
operator|=
name|intr_event_bind
argument_list|(
name|nwsp
operator|->
name|nws_intr_event
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: cpu %u: intr_event_bind: %d"
argument_list|,
name|__func__
argument_list|,
name|cpuid
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|NETISR_WLOCK
argument_list|()
expr_stmt|;
name|nws_array
index|[
name|nws_count
index|]
operator|=
name|nwsp
operator|->
name|nws_cpu
expr_stmt|;
name|nws_count
operator|++
expr_stmt|;
name|NETISR_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the netisr subsystem.  We rely on BSS and static initialization  * of most fields in global data structures.  *  * Start a worker thread for the boot CPU so that we can support network  * traffic immediately in case the network stack is used before additional  * CPUs are started (for example, diskless boot).  */
end_comment

begin_function
specifier|static
name|void
name|netisr_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|curcpu
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: not on CPU 0"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|NETISR_LOCK_INIT
argument_list|()
expr_stmt|;
if|if
condition|(
name|netisr_maxthreads
operator|<
literal|1
condition|)
name|netisr_maxthreads
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|netisr_maxthreads
operator|>
name|mp_ncpus
condition|)
block|{
name|printf
argument_list|(
literal|"netisr_init: forcing maxthreads from %d to %d\n"
argument_list|,
name|netisr_maxthreads
argument_list|,
name|mp_ncpus
argument_list|)
expr_stmt|;
name|netisr_maxthreads
operator|=
name|mp_ncpus
expr_stmt|;
block|}
if|if
condition|(
name|netisr_defaultqlimit
operator|>
name|netisr_maxqlimit
condition|)
block|{
name|printf
argument_list|(
literal|"netisr_init: forcing defaultqlimit from %d to %d\n"
argument_list|,
name|netisr_defaultqlimit
argument_list|,
name|netisr_maxqlimit
argument_list|)
expr_stmt|;
name|netisr_defaultqlimit
operator|=
name|netisr_maxqlimit
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEVICE_POLLING
comment|/* 	 * The device polling code is not yet aware of how to deal with 	 * multiple netisr threads, so for the time being compiling in device 	 * polling disables parallel netisr workers. 	 */
if|if
condition|(
name|netisr_maxthreads
operator|!=
literal|1
operator|||
name|netisr_bindthreads
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"netisr_init: forcing maxthreads to 1 and "
literal|"bindthreads to 0 for device polling\n"
argument_list|)
expr_stmt|;
name|netisr_maxthreads
operator|=
literal|1
expr_stmt|;
name|netisr_bindthreads
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|netisr_start_swi
argument_list|(
name|curcpu
argument_list|,
name|pcpu_find
argument_list|(
name|curcpu
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|netisr_init
argument_list|,
name|SI_SUB_SOFTINTR
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|netisr_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Start worker threads for additional CPUs.  No attempt to gracefully handle  * work reassignment, we don't yet support dynamic reconfiguration.  */
end_comment

begin_function
specifier|static
name|void
name|netisr_start
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pcpu
modifier|*
name|pc
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|pc
argument_list|,
argument|&cpuhead
argument_list|,
argument|pc_allcpu
argument_list|)
block|{
if|if
condition|(
name|nws_count
operator|>=
name|netisr_maxthreads
condition|)
break|break;
comment|/* XXXRW: Is skipping absent CPUs still required here? */
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|pc
operator|->
name|pc_cpuid
argument_list|)
condition|)
continue|continue;
comment|/* Worker will already be present for boot CPU. */
if|if
condition|(
name|pc
operator|->
name|pc_netisr
operator|!=
name|NULL
condition|)
continue|continue;
name|netisr_start_swi
argument_list|(
name|pc
operator|->
name|pc_cpuid
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|netisr_start
argument_list|,
name|SI_SUB_SMP
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|netisr_start
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|netisr
argument_list|,
argument|db_show_netisr
argument_list|)
end_macro

begin_block
block|{
name|struct
name|netisr_workstream
modifier|*
name|nwsp
decl_stmt|;
name|struct
name|netisr_work
modifier|*
name|nwp
decl_stmt|;
name|int
name|first
decl_stmt|,
name|proto
decl_stmt|;
name|u_int
name|cpuid
decl_stmt|;
name|db_printf
argument_list|(
literal|"%3s %6s %5s %5s %5s %8s %8s %8s %8s\n"
argument_list|,
literal|"CPU"
argument_list|,
literal|"Proto"
argument_list|,
literal|"Len"
argument_list|,
literal|"WMark"
argument_list|,
literal|"Max"
argument_list|,
literal|"Disp"
argument_list|,
literal|"HDisp"
argument_list|,
literal|"Drop"
argument_list|,
literal|"Queue"
argument_list|)
expr_stmt|;
for|for
control|(
name|cpuid
operator|=
literal|0
init|;
name|cpuid
operator|<=
name|mp_maxid
condition|;
name|cpuid
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|cpuid
argument_list|)
condition|)
continue|continue;
name|nwsp
operator|=
name|DPCPU_ID_PTR
argument_list|(
name|cpuid
argument_list|,
name|nws
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwsp
operator|->
name|nws_intr_event
operator|==
name|NULL
condition|)
continue|continue;
name|first
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|proto
operator|=
literal|0
init|;
name|proto
operator|<
name|NETISR_MAXPROT
condition|;
name|proto
operator|++
control|)
block|{
if|if
condition|(
name|np
index|[
name|proto
index|]
operator|.
name|np_handler
operator|==
name|NULL
condition|)
continue|continue;
name|nwp
operator|=
operator|&
name|nwsp
operator|->
name|nws_work
index|[
name|proto
index|]
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|db_printf
argument_list|(
literal|"%3d "
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|db_printf
argument_list|(
literal|"%3s "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"%6s %5d %5d %5d %8ju %8ju %8ju %8ju\n"
argument_list|,
name|np
index|[
name|proto
index|]
operator|.
name|np_name
argument_list|,
name|nwp
operator|->
name|nw_len
argument_list|,
name|nwp
operator|->
name|nw_watermark
argument_list|,
name|nwp
operator|->
name|nw_qlimit
argument_list|,
name|nwp
operator|->
name|nw_dispatched
argument_list|,
name|nwp
operator|->
name|nw_hybrid_dispatched
argument_list|,
name|nwp
operator|->
name|nw_qdrops
argument_list|,
name|nwp
operator|->
name|nw_queued
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

