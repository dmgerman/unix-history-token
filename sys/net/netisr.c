begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2009 Robert N. M. Watson  * Copyright (c) 2010-2011 Juniper Networks, Inc.  * All rights reserved.  *  * This software was developed by Robert N. M. Watson under contract  * to Juniper Networks, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * netisr is a packet dispatch service, allowing synchronous (directly  * dispatched) and asynchronous (deferred dispatch) processing of packets by  * registered protocol handlers.  Callers pass a protocol identifier and  * packet to netisr, along with a direct dispatch hint, and work will either  * be immediately processed by the registered handler, or passed to a  * software interrupt (SWI) thread for deferred dispatch.  Callers will  * generally select one or the other based on:  *  * - Whether directly dispatching a netisr handler lead to code reentrance or  *   lock recursion, such as entering the socket code from the socket code.  * - Whether directly dispatching a netisr handler lead to recursive  *   processing, such as when decapsulating several wrapped layers of tunnel  *   information (IPSEC within IPSEC within ...).  *  * Maintaining ordering for protocol streams is a critical design concern.  * Enforcing ordering limits the opportunity for concurrency, but maintains  * the strong ordering requirements found in some protocols, such as TCP.  Of  * related concern is CPU affinity--it is desirable to process all data  * associated with a particular stream on the same CPU over time in order to  * avoid acquiring locks associated with the connection on different CPUs,  * keep connection data in one cache, and to generally encourage associated  * user threads to live on the same CPU as the stream.  It's also desirable  * to avoid lock migration and contention where locks are associated with  * more than one flow.  *  * netisr supports several policy variations, represented by the  * NETISR_POLICY_* constants, allowing protocols to play various roles in  * identifying flows, assigning work to CPUs, etc.  These are described in  * netisr.h.  */
end_comment

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_device_polling.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rmlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|_WANT_NETISR_INTERNAL
end_define

begin_comment
comment|/* Enable definitions from netisr_internal.h */
end_comment

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr_internal.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_comment
comment|/*-  * Synchronize use and modification of the registered netisr data structures;  * acquire a read lock while modifying the set of registered protocols to  * prevent partially registered or unregistered protocols from being run.  *  * The following data structures and fields are protected by this lock:  *  * - The netisr_proto array, including all fields of struct netisr_proto.  * - The nws array, including all fields of struct netisr_worker.  * - The nws_array array.  *  * Note: the NETISR_LOCKING define controls whether read locks are acquired  * in packet processing paths requiring netisr registration stability.  This  * is disabled by default as it can lead to measurable performance  * degradation even with rmlocks (3%-6% for loopback ping-pong traffic), and  * because netisr registration and unregistration is extremely rare at  * runtime.  If it becomes more common, this decision should be revisited.  *  * XXXRW: rmlocks don't support assertions.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|rmlock
name|netisr_rmlock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NETISR_LOCK_INIT
parameter_list|()
value|rm_init_flags(&netisr_rmlock, "netisr", \ 				    RM_NOWITNESS)
end_define

begin_define
define|#
directive|define
name|NETISR_LOCK_ASSERT
parameter_list|()
end_define

begin_define
define|#
directive|define
name|NETISR_RLOCK
parameter_list|(
name|tracker
parameter_list|)
value|rm_rlock(&netisr_rmlock, (tracker))
end_define

begin_define
define|#
directive|define
name|NETISR_RUNLOCK
parameter_list|(
name|tracker
parameter_list|)
value|rm_runlock(&netisr_rmlock, (tracker))
end_define

begin_define
define|#
directive|define
name|NETISR_WLOCK
parameter_list|()
value|rm_wlock(&netisr_rmlock)
end_define

begin_define
define|#
directive|define
name|NETISR_WUNLOCK
parameter_list|()
value|rm_wunlock(&netisr_rmlock)
end_define

begin_comment
comment|/* #define	NETISR_LOCKING */
end_comment

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_net
argument_list|,
name|OID_AUTO
argument_list|,
name|isr
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"netisr"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*-  * Three global direct dispatch policies are supported:  *  * NETISR_DISPATCH_DEFERRED: All work is deferred for a netisr, regardless of  * context (may be overriden by protocols).  *  * NETISR_DISPATCH_HYBRID: If the executing context allows direct dispatch,  * and we're running on the CPU the work would be performed on, then direct  * dispatch it if it wouldn't violate ordering constraints on the workstream.  *  * NETISR_DISPATCH_DIRECT: If the executing context allows direct dispatch,  * always direct dispatch.  (The default.)  *  * Notice that changing the global policy could lead to short periods of  * misordered processing, but this is considered acceptable as compared to  * the complexity of enforcing ordering during policy changes.  Protocols can  * override the global policy (when they're not doing that, they select  * NETISR_DISPATCH_DEFAULT).  */
end_comment

begin_define
define|#
directive|define
name|NETISR_DISPATCH_POLICY_DEFAULT
value|NETISR_DISPATCH_DIRECT
end_define

begin_define
define|#
directive|define
name|NETISR_DISPATCH_POLICY_MAXSTR
value|20
end_define

begin_comment
comment|/* Used for temporary buffers. */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|netisr_dispatch_policy
init|=
name|NETISR_DISPATCH_POLICY_DEFAULT
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|sysctl_netisr_dispatch_policy
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_isr
argument_list|,
name|OID_AUTO
argument_list|,
name|dispatch
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RWTUN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_netisr_dispatch_policy
argument_list|,
literal|"A"
argument_list|,
literal|"netisr dispatch policy"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Allow the administrator to limit the number of threads (CPUs) to use for  * netisr.  We don't check netisr_maxthreads before creating the thread for  * CPU 0. This must be set at boot. We will create at most one thread per CPU.  * By default we initialize this to 1 which would assign just 1 cpu (cpu0) and  * therefore only 1 workstream. If set to -1, netisr would use all cpus  * (mp_ncpus) and therefore would have those many workstreams. One workstream  * per thread (CPU).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|netisr_maxthreads
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Max number of threads. */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_isr
argument_list|,
name|OID_AUTO
argument_list|,
name|maxthreads
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|netisr_maxthreads
argument_list|,
literal|0
argument_list|,
literal|"Use at most this many CPUs for netisr processing"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|netisr_bindthreads
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Bind threads to CPUs. */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_isr
argument_list|,
name|OID_AUTO
argument_list|,
name|bindthreads
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|netisr_bindthreads
argument_list|,
literal|0
argument_list|,
literal|"Bind netisr threads to CPUs."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Limit per-workstream mbuf queue limits s to at most net.isr.maxqlimit,  * both for initial configuration and later modification using  * netisr_setqlimit().  */
end_comment

begin_define
define|#
directive|define
name|NETISR_DEFAULT_MAXQLIMIT
value|10240
end_define

begin_decl_stmt
specifier|static
name|u_int
name|netisr_maxqlimit
init|=
name|NETISR_DEFAULT_MAXQLIMIT
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_net_isr
argument_list|,
name|OID_AUTO
argument_list|,
name|maxqlimit
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|netisr_maxqlimit
argument_list|,
literal|0
argument_list|,
literal|"Maximum netisr per-protocol, per-CPU queue depth."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The default per-workstream mbuf queue limit for protocols that don't  * initialize the nh_qlimit field of their struct netisr_handler.  If this is  * set above netisr_maxqlimit, we truncate it to the maximum during boot.  */
end_comment

begin_define
define|#
directive|define
name|NETISR_DEFAULT_DEFAULTQLIMIT
value|256
end_define

begin_decl_stmt
specifier|static
name|u_int
name|netisr_defaultqlimit
init|=
name|NETISR_DEFAULT_DEFAULTQLIMIT
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_net_isr
argument_list|,
name|OID_AUTO
argument_list|,
name|defaultqlimit
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|netisr_defaultqlimit
argument_list|,
literal|0
argument_list|,
literal|"Default netisr per-protocol, per-CPU queue limit if not set by protocol"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Store and export the compile-time constant NETISR_MAXPROT limit on the  * number of protocols that can register with netisr at a time.  This is  * required for crashdump analysis, as it sizes netisr_proto[].  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|netisr_maxprot
init|=
name|NETISR_MAXPROT
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_net_isr
argument_list|,
name|OID_AUTO
argument_list|,
name|maxprot
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|netisr_maxprot
argument_list|,
literal|0
argument_list|,
literal|"Compile-time limit on the number of protocols supported by netisr."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The netisr_proto array describes all registered protocols, indexed by  * protocol number.  See netisr_internal.h for more details.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|netisr_proto
name|netisr_proto
index|[
name|NETISR_MAXPROT
index|]
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|VIMAGE
end_ifdef

begin_comment
comment|/*  * The netisr_enable array describes a per-VNET flag for registered  * protocols on whether this netisr is active in this VNET or not.  * netisr_register() will automatically enable the netisr for the  * default VNET and all currently active instances.  * netisr_unregister() will disable all active VNETs, including vnet0.  * Individual network stack instances can be enabled/disabled by the  * netisr_(un)register _vnet() functions.  * With this we keep the one netisr_proto per protocol but add a  * mechanism to stop netisr processing for vnet teardown.  * Apart from that we expect a VNET to always be enabled.  */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|u_int
argument_list|,
name|netisr_enable
index|[
name|NETISR_MAXPROT
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_netisr_enable
value|VNET(netisr_enable)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Per-CPU workstream data.  See netisr_internal.h for more details.  */
end_comment

begin_expr_stmt
name|DPCPU_DEFINE
argument_list|(
expr|struct
name|netisr_workstream
argument_list|,
name|nws
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Map contiguous values between 0 and nws_count into CPU IDs appropriate for  * accessing workstreams.  This allows constructions of the form  * DPCPU_ID_GET(nws_array[arbitraryvalue % nws_count], nws).  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|nws_array
index|[
name|MAXCPU
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Number of registered workstreams.  Will be at most the number of running  * CPUs once fully started.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|nws_count
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_net_isr
argument_list|,
name|OID_AUTO
argument_list|,
name|numthreads
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|nws_count
argument_list|,
literal|0
argument_list|,
literal|"Number of extant netisr threads."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Synchronization for each workstream: a mutex protects all mutable fields  * in each stream, including per-protocol state (mbuf queues).  The SWI is  * woken up if asynchronous dispatch is required.  */
end_comment

begin_define
define|#
directive|define
name|NWS_LOCK
parameter_list|(
name|s
parameter_list|)
value|mtx_lock(&(s)->nws_mtx)
end_define

begin_define
define|#
directive|define
name|NWS_LOCK_ASSERT
parameter_list|(
name|s
parameter_list|)
value|mtx_assert(&(s)->nws_mtx, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|NWS_UNLOCK
parameter_list|(
name|s
parameter_list|)
value|mtx_unlock(&(s)->nws_mtx)
end_define

begin_define
define|#
directive|define
name|NWS_SIGNAL
parameter_list|(
name|s
parameter_list|)
value|swi_sched((s)->nws_swi_cookie, 0)
end_define

begin_comment
comment|/*  * Utility routines for protocols that implement their own mapping of flows  * to CPUs.  */
end_comment

begin_function
name|u_int
name|netisr_get_cpucount
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|nws_count
operator|)
return|;
block|}
end_function

begin_function
name|u_int
name|netisr_get_cpuid
parameter_list|(
name|u_int
name|cpunumber
parameter_list|)
block|{
return|return
operator|(
name|nws_array
index|[
name|cpunumber
operator|%
name|nws_count
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The default implementation of flow -> CPU ID mapping.  *  * Non-static so that protocols can use it to map their own work to specific  * CPUs in a manner consistent to netisr for affinity purposes.  */
end_comment

begin_function
name|u_int
name|netisr_default_flow2cpu
parameter_list|(
name|u_int
name|flowid
parameter_list|)
block|{
return|return
operator|(
name|nws_array
index|[
name|flowid
operator|%
name|nws_count
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dispatch tunable and sysctl configuration.  */
end_comment

begin_struct
struct|struct
name|netisr_dispatch_table_entry
block|{
name|u_int
name|ndte_policy
decl_stmt|;
specifier|const
name|char
modifier|*
name|ndte_policy_str
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|netisr_dispatch_table_entry
name|netisr_dispatch_table
index|[]
init|=
block|{
block|{
name|NETISR_DISPATCH_DEFAULT
block|,
literal|"default"
block|}
block|,
block|{
name|NETISR_DISPATCH_DEFERRED
block|,
literal|"deferred"
block|}
block|,
block|{
name|NETISR_DISPATCH_HYBRID
block|,
literal|"hybrid"
block|}
block|,
block|{
name|NETISR_DISPATCH_DIRECT
block|,
literal|"direct"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|netisr_dispatch_policy_to_str
parameter_list|(
name|u_int
name|dispatch_policy
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|u_int
name|buflen
parameter_list|)
block|{
specifier|const
name|struct
name|netisr_dispatch_table_entry
modifier|*
name|ndtep
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|str
operator|=
literal|"unknown"
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|netisr_dispatch_table
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ndtep
operator|=
operator|&
name|netisr_dispatch_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ndtep
operator|->
name|ndte_policy
operator|==
name|dispatch_policy
condition|)
block|{
name|str
operator|=
name|ndtep
operator|->
name|ndte_policy_str
expr_stmt|;
break|break;
block|}
block|}
name|snprintf
argument_list|(
name|buffer
argument_list|,
name|buflen
argument_list|,
literal|"%s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|netisr_dispatch_policy_from_str
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|u_int
modifier|*
name|dispatch_policyp
parameter_list|)
block|{
specifier|const
name|struct
name|netisr_dispatch_table_entry
modifier|*
name|ndtep
decl_stmt|;
name|u_int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|netisr_dispatch_table
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|ndtep
operator|=
operator|&
name|netisr_dispatch_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ndtep
operator|->
name|ndte_policy_str
argument_list|,
name|str
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|dispatch_policyp
operator|=
name|ndtep
operator|->
name|ndte_policy
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_netisr_dispatch_policy
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
name|tmp
index|[
name|NETISR_DISPATCH_POLICY_MAXSTR
index|]
decl_stmt|;
name|u_int
name|dispatch_policy
decl_stmt|;
name|int
name|error
decl_stmt|;
name|netisr_dispatch_policy_to_str
argument_list|(
name|netisr_dispatch_policy
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|netisr_dispatch_policy_from_str
argument_list|(
name|tmp
argument_list|,
operator|&
name|dispatch_policy
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|dispatch_policy
operator|==
name|NETISR_DISPATCH_DEFAULT
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|netisr_dispatch_policy
operator|=
name|dispatch_policy
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Register a new netisr handler, which requires initializing per-protocol  * fields for each workstream.  All netisr work is briefly suspended while  * the protocol is installed.  */
end_comment

begin_function
name|void
name|netisr_register
parameter_list|(
specifier|const
name|struct
name|netisr_handler
modifier|*
name|nhp
parameter_list|)
block|{
name|VNET_ITERATOR_DECL
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|struct
name|netisr_work
modifier|*
name|npwp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|proto
decl_stmt|;
name|proto
operator|=
name|nhp
operator|->
name|nh_proto
expr_stmt|;
name|name
operator|=
name|nhp
operator|->
name|nh_name
expr_stmt|;
comment|/* 	 * Test that the requested registration is valid. 	 */
name|KASSERT
argument_list|(
name|nhp
operator|->
name|nh_name
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: nh_name NULL for %u"
operator|,
name|__func__
operator|,
name|proto
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nhp
operator|->
name|nh_handler
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: nh_handler NULL for %s"
operator|,
name|__func__
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nhp
operator|->
name|nh_policy
operator|==
name|NETISR_POLICY_SOURCE
operator|||
name|nhp
operator|->
name|nh_policy
operator|==
name|NETISR_POLICY_FLOW
operator|||
name|nhp
operator|->
name|nh_policy
operator|==
name|NETISR_POLICY_CPU
argument_list|,
operator|(
literal|"%s: unsupported nh_policy %u for %s"
operator|,
name|__func__
operator|,
name|nhp
operator|->
name|nh_policy
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nhp
operator|->
name|nh_policy
operator|==
name|NETISR_POLICY_FLOW
operator|||
name|nhp
operator|->
name|nh_m2flow
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: nh_policy != FLOW but m2flow defined for %s"
operator|,
name|__func__
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nhp
operator|->
name|nh_policy
operator|==
name|NETISR_POLICY_CPU
operator|||
name|nhp
operator|->
name|nh_m2cpuid
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: nh_policy != CPU but m2cpuid defined for %s"
operator|,
name|__func__
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nhp
operator|->
name|nh_policy
operator|!=
name|NETISR_POLICY_CPU
operator|||
name|nhp
operator|->
name|nh_m2cpuid
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: nh_policy == CPU but m2cpuid not defined for %s"
operator|,
name|__func__
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nhp
operator|->
name|nh_dispatch
operator|==
name|NETISR_DISPATCH_DEFAULT
operator|||
name|nhp
operator|->
name|nh_dispatch
operator|==
name|NETISR_DISPATCH_DEFERRED
operator|||
name|nhp
operator|->
name|nh_dispatch
operator|==
name|NETISR_DISPATCH_HYBRID
operator|||
name|nhp
operator|->
name|nh_dispatch
operator|==
name|NETISR_DISPATCH_DIRECT
argument_list|,
operator|(
literal|"%s: invalid nh_dispatch (%u)"
operator|,
name|__func__
operator|,
name|nhp
operator|->
name|nh_dispatch
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|proto
operator|<
name|NETISR_MAXPROT
argument_list|,
operator|(
literal|"%s(%u, %s): protocol too big"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Test that no existing registration exists for this protocol. 	 */
name|NETISR_WLOCK
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_name
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s(%u, %s): name present"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_handler
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s(%u, %s): handler present"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_name
operator|=
name|name
expr_stmt|;
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_handler
operator|=
name|nhp
operator|->
name|nh_handler
expr_stmt|;
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_m2flow
operator|=
name|nhp
operator|->
name|nh_m2flow
expr_stmt|;
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_m2cpuid
operator|=
name|nhp
operator|->
name|nh_m2cpuid
expr_stmt|;
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_drainedcpu
operator|=
name|nhp
operator|->
name|nh_drainedcpu
expr_stmt|;
if|if
condition|(
name|nhp
operator|->
name|nh_qlimit
operator|==
literal|0
condition|)
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_qlimit
operator|=
name|netisr_defaultqlimit
expr_stmt|;
elseif|else
if|if
condition|(
name|nhp
operator|->
name|nh_qlimit
operator|>
name|netisr_maxqlimit
condition|)
block|{
name|printf
argument_list|(
literal|"%s: %s requested queue limit %u capped to "
literal|"net.isr.maxqlimit %u\n"
argument_list|,
name|__func__
argument_list|,
name|name
argument_list|,
name|nhp
operator|->
name|nh_qlimit
argument_list|,
name|netisr_maxqlimit
argument_list|)
expr_stmt|;
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_qlimit
operator|=
name|netisr_maxqlimit
expr_stmt|;
block|}
else|else
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_qlimit
operator|=
name|nhp
operator|->
name|nh_qlimit
expr_stmt|;
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_policy
operator|=
name|nhp
operator|->
name|nh_policy
expr_stmt|;
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_dispatch
operator|=
name|nhp
operator|->
name|nh_dispatch
expr_stmt|;
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
name|npwp
operator|=
operator|&
operator|(
name|DPCPU_ID_PTR
argument_list|(
name|i
argument_list|,
name|nws
argument_list|)
operator|)
operator|->
name|nws_work
index|[
name|proto
index|]
expr_stmt|;
name|bzero
argument_list|(
name|npwp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|npwp
argument_list|)
argument_list|)
expr_stmt|;
name|npwp
operator|->
name|nw_qlimit
operator|=
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_qlimit
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|VIMAGE
comment|/* 	 * Test that we are in vnet0 and have a curvnet set. 	 */
name|KASSERT
argument_list|(
name|curvnet
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: curvnet is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|IS_DEFAULT_VNET
argument_list|(
name|curvnet
argument_list|)
argument_list|,
operator|(
literal|"%s: curvnet %p is not vnet0 %p"
operator|,
name|__func__
operator|,
name|curvnet
operator|,
name|vnet0
operator|)
argument_list|)
expr_stmt|;
name|VNET_LIST_RLOCK_NOSLEEP
argument_list|()
expr_stmt|;
name|VNET_FOREACH
argument_list|(
argument|vnet_iter
argument_list|)
block|{
name|CURVNET_SET
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|V_netisr_enable
index|[
name|proto
index|]
operator|=
literal|1
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
name|VNET_LIST_RUNLOCK_NOSLEEP
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|NETISR_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear drop counters across all workstreams for a protocol.  */
end_comment

begin_function
name|void
name|netisr_clearqdrops
parameter_list|(
specifier|const
name|struct
name|netisr_handler
modifier|*
name|nhp
parameter_list|)
block|{
name|struct
name|netisr_work
modifier|*
name|npwp
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
endif|#
directive|endif
name|u_int
name|i
decl_stmt|,
name|proto
decl_stmt|;
name|proto
operator|=
name|nhp
operator|->
name|nh_proto
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|name
operator|=
name|nhp
operator|->
name|nh_name
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|proto
operator|<
name|NETISR_MAXPROT
argument_list|,
operator|(
literal|"%s(%u): protocol too big for %s"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|NETISR_WLOCK
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_handler
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s(%u): protocol not registered for %s"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
name|npwp
operator|=
operator|&
operator|(
name|DPCPU_ID_PTR
argument_list|(
name|i
argument_list|,
name|nws
argument_list|)
operator|)
operator|->
name|nws_work
index|[
name|proto
index|]
expr_stmt|;
name|npwp
operator|->
name|nw_qdrops
operator|=
literal|0
expr_stmt|;
block|}
name|NETISR_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Query current drop counters across all workstreams for a protocol.  */
end_comment

begin_function
name|void
name|netisr_getqdrops
parameter_list|(
specifier|const
name|struct
name|netisr_handler
modifier|*
name|nhp
parameter_list|,
name|u_int64_t
modifier|*
name|qdropp
parameter_list|)
block|{
name|struct
name|netisr_work
modifier|*
name|npwp
decl_stmt|;
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
endif|#
directive|endif
name|u_int
name|i
decl_stmt|,
name|proto
decl_stmt|;
operator|*
name|qdropp
operator|=
literal|0
expr_stmt|;
name|proto
operator|=
name|nhp
operator|->
name|nh_proto
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|name
operator|=
name|nhp
operator|->
name|nh_name
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|proto
operator|<
name|NETISR_MAXPROT
argument_list|,
operator|(
literal|"%s(%u): protocol too big for %s"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|NETISR_RLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_handler
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s(%u): protocol not registered for %s"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
name|npwp
operator|=
operator|&
operator|(
name|DPCPU_ID_PTR
argument_list|(
name|i
argument_list|,
name|nws
argument_list|)
operator|)
operator|->
name|nws_work
index|[
name|proto
index|]
expr_stmt|;
operator|*
name|qdropp
operator|+=
name|npwp
operator|->
name|nw_qdrops
expr_stmt|;
block|}
name|NETISR_RUNLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Query current per-workstream queue limit for a protocol.  */
end_comment

begin_function
name|void
name|netisr_getqlimit
parameter_list|(
specifier|const
name|struct
name|netisr_handler
modifier|*
name|nhp
parameter_list|,
name|u_int
modifier|*
name|qlimitp
parameter_list|)
block|{
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
endif|#
directive|endif
name|u_int
name|proto
decl_stmt|;
name|proto
operator|=
name|nhp
operator|->
name|nh_proto
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|name
operator|=
name|nhp
operator|->
name|nh_name
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|proto
operator|<
name|NETISR_MAXPROT
argument_list|,
operator|(
literal|"%s(%u): protocol too big for %s"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|NETISR_RLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_handler
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s(%u): protocol not registered for %s"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
operator|*
name|qlimitp
operator|=
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_qlimit
expr_stmt|;
name|NETISR_RUNLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the queue limit across per-workstream queues for a protocol.  We  * simply change the limits, and don't drain overflowed packets as they will  * (hopefully) take care of themselves shortly.  */
end_comment

begin_function
name|int
name|netisr_setqlimit
parameter_list|(
specifier|const
name|struct
name|netisr_handler
modifier|*
name|nhp
parameter_list|,
name|u_int
name|qlimit
parameter_list|)
block|{
name|struct
name|netisr_work
modifier|*
name|npwp
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
endif|#
directive|endif
name|u_int
name|i
decl_stmt|,
name|proto
decl_stmt|;
if|if
condition|(
name|qlimit
operator|>
name|netisr_maxqlimit
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|proto
operator|=
name|nhp
operator|->
name|nh_proto
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|name
operator|=
name|nhp
operator|->
name|nh_name
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|proto
operator|<
name|NETISR_MAXPROT
argument_list|,
operator|(
literal|"%s(%u): protocol too big for %s"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|NETISR_WLOCK
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_handler
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s(%u): protocol not registered for %s"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_qlimit
operator|=
name|qlimit
expr_stmt|;
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
name|npwp
operator|=
operator|&
operator|(
name|DPCPU_ID_PTR
argument_list|(
name|i
argument_list|,
name|nws
argument_list|)
operator|)
operator|->
name|nws_work
index|[
name|proto
index|]
expr_stmt|;
name|npwp
operator|->
name|nw_qlimit
operator|=
name|qlimit
expr_stmt|;
block|}
name|NETISR_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Drain all packets currently held in a particular protocol work queue.  */
end_comment

begin_function
specifier|static
name|void
name|netisr_drain_proto
parameter_list|(
name|struct
name|netisr_work
modifier|*
name|npwp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* 	 * We would assert the lock on the workstream but it's not passed in. 	 */
while|while
condition|(
operator|(
name|m
operator|=
name|npwp
operator|->
name|nw_head
operator|)
operator|!=
name|NULL
condition|)
block|{
name|npwp
operator|->
name|nw_head
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|npwp
operator|->
name|nw_head
operator|==
name|NULL
condition|)
name|npwp
operator|->
name|nw_tail
operator|=
name|NULL
expr_stmt|;
name|npwp
operator|->
name|nw_len
operator|--
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|npwp
operator|->
name|nw_tail
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: tail"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|npwp
operator|->
name|nw_len
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: len"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove the registration of a network protocol, which requires clearing  * per-protocol fields across all workstreams, including freeing all mbufs in  * the queues at time of unregister.  All work in netisr is briefly suspended  * while this takes place.  */
end_comment

begin_function
name|void
name|netisr_unregister
parameter_list|(
specifier|const
name|struct
name|netisr_handler
modifier|*
name|nhp
parameter_list|)
block|{
name|VNET_ITERATOR_DECL
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|struct
name|netisr_work
modifier|*
name|npwp
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
endif|#
directive|endif
name|u_int
name|i
decl_stmt|,
name|proto
decl_stmt|;
name|proto
operator|=
name|nhp
operator|->
name|nh_proto
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|name
operator|=
name|nhp
operator|->
name|nh_name
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|proto
operator|<
name|NETISR_MAXPROT
argument_list|,
operator|(
literal|"%s(%u): protocol too big for %s"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
name|NETISR_WLOCK
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_handler
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s(%u): protocol not registered for %s"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|name
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VIMAGE
name|VNET_LIST_RLOCK_NOSLEEP
argument_list|()
expr_stmt|;
name|VNET_FOREACH
argument_list|(
argument|vnet_iter
argument_list|)
block|{
name|CURVNET_SET
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|V_netisr_enable
index|[
name|proto
index|]
operator|=
literal|0
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
name|VNET_LIST_RUNLOCK_NOSLEEP
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_name
operator|=
name|NULL
expr_stmt|;
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_handler
operator|=
name|NULL
expr_stmt|;
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_m2flow
operator|=
name|NULL
expr_stmt|;
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_m2cpuid
operator|=
name|NULL
expr_stmt|;
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_qlimit
operator|=
literal|0
expr_stmt|;
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_policy
operator|=
literal|0
expr_stmt|;
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
name|npwp
operator|=
operator|&
operator|(
name|DPCPU_ID_PTR
argument_list|(
name|i
argument_list|,
name|nws
argument_list|)
operator|)
operator|->
name|nws_work
index|[
name|proto
index|]
expr_stmt|;
name|netisr_drain_proto
argument_list|(
name|npwp
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|npwp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|npwp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|NETISR_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VIMAGE
end_ifdef

begin_function
name|void
name|netisr_register_vnet
parameter_list|(
specifier|const
name|struct
name|netisr_handler
modifier|*
name|nhp
parameter_list|)
block|{
name|u_int
name|proto
decl_stmt|;
name|proto
operator|=
name|nhp
operator|->
name|nh_proto
expr_stmt|;
name|KASSERT
argument_list|(
name|curvnet
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: curvnet is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|proto
operator|<
name|NETISR_MAXPROT
argument_list|,
operator|(
literal|"%s(%u): protocol too big for %s"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|nhp
operator|->
name|nh_name
operator|)
argument_list|)
expr_stmt|;
name|NETISR_WLOCK
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_handler
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s(%u): protocol not registered for %s"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|nhp
operator|->
name|nh_name
operator|)
argument_list|)
expr_stmt|;
name|V_netisr_enable
index|[
name|proto
index|]
operator|=
literal|1
expr_stmt|;
name|NETISR_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|netisr_drain_proto_vnet
parameter_list|(
name|struct
name|vnet
modifier|*
name|vnet
parameter_list|,
name|u_int
name|proto
parameter_list|)
block|{
name|struct
name|netisr_workstream
modifier|*
name|nwsp
decl_stmt|;
name|struct
name|netisr_work
modifier|*
name|npwp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mp
decl_stmt|,
modifier|*
name|n
decl_stmt|,
modifier|*
name|ne
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|vnet
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: vnet is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|NETISR_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
name|nwsp
operator|=
name|DPCPU_ID_PTR
argument_list|(
name|i
argument_list|,
name|nws
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwsp
operator|->
name|nws_intr_event
operator|==
name|NULL
condition|)
continue|continue;
name|npwp
operator|=
operator|&
name|nwsp
operator|->
name|nws_work
index|[
name|proto
index|]
expr_stmt|;
name|NWS_LOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
comment|/* 		 * Rather than dissecting and removing mbufs from the middle 		 * of the chain, we build a new chain if the packet stays and 		 * update the head and tail pointers at the end.  All packets 		 * matching the given vnet are freed. 		 */
name|m
operator|=
name|npwp
operator|->
name|nw_head
expr_stmt|;
name|n
operator|=
name|ne
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|mp
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|mp
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_vnet
operator|!=
name|vnet
condition|)
block|{
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|n
operator|=
name|ne
operator|=
name|mp
expr_stmt|;
block|}
else|else
block|{
name|ne
operator|->
name|m_nextpkt
operator|=
name|mp
expr_stmt|;
name|ne
operator|=
name|mp
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* This is a packet in the selected vnet. Free it. */
name|npwp
operator|->
name|nw_len
operator|--
expr_stmt|;
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
name|npwp
operator|->
name|nw_head
operator|=
name|n
expr_stmt|;
name|npwp
operator|->
name|nw_tail
operator|=
name|ne
expr_stmt|;
name|NWS_UNLOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|netisr_unregister_vnet
parameter_list|(
specifier|const
name|struct
name|netisr_handler
modifier|*
name|nhp
parameter_list|)
block|{
name|u_int
name|proto
decl_stmt|;
name|proto
operator|=
name|nhp
operator|->
name|nh_proto
expr_stmt|;
name|KASSERT
argument_list|(
name|curvnet
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: curvnet is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|proto
operator|<
name|NETISR_MAXPROT
argument_list|,
operator|(
literal|"%s(%u): protocol too big for %s"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|nhp
operator|->
name|nh_name
operator|)
argument_list|)
expr_stmt|;
name|NETISR_WLOCK
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_handler
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s(%u): protocol not registered for %s"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|nhp
operator|->
name|nh_name
operator|)
argument_list|)
expr_stmt|;
name|V_netisr_enable
index|[
name|proto
index|]
operator|=
literal|0
expr_stmt|;
name|netisr_drain_proto_vnet
argument_list|(
name|curvnet
argument_list|,
name|proto
argument_list|)
expr_stmt|;
name|NETISR_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Compose the global and per-protocol policies on dispatch, and return the  * dispatch policy to use.  */
end_comment

begin_function
specifier|static
name|u_int
name|netisr_get_dispatch
parameter_list|(
name|struct
name|netisr_proto
modifier|*
name|npp
parameter_list|)
block|{
comment|/* 	 * Protocol-specific configuration overrides the global default. 	 */
if|if
condition|(
name|npp
operator|->
name|np_dispatch
operator|!=
name|NETISR_DISPATCH_DEFAULT
condition|)
return|return
operator|(
name|npp
operator|->
name|np_dispatch
operator|)
return|;
return|return
operator|(
name|netisr_dispatch_policy
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up the workstream given a packet and source identifier.  Do this by  * checking the protocol's policy, and optionally call out to the protocol  * for assistance if required.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|netisr_select_cpuid
parameter_list|(
name|struct
name|netisr_proto
modifier|*
name|npp
parameter_list|,
name|u_int
name|dispatch_policy
parameter_list|,
name|uintptr_t
name|source
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u_int
modifier|*
name|cpuidp
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int
name|policy
decl_stmt|;
name|NETISR_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/* 	 * In the event we have only one worker, shortcut and deliver to it 	 * without further ado. 	 */
if|if
condition|(
name|nws_count
operator|==
literal|1
condition|)
block|{
operator|*
name|cpuidp
operator|=
name|nws_array
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
comment|/* 	 * What happens next depends on the policy selected by the protocol. 	 * If we want to support per-interface policies, we should do that 	 * here first. 	 */
name|policy
operator|=
name|npp
operator|->
name|np_policy
expr_stmt|;
if|if
condition|(
name|policy
operator|==
name|NETISR_POLICY_CPU
condition|)
block|{
name|m
operator|=
name|npp
operator|->
name|np_m2cpuid
argument_list|(
name|m
argument_list|,
name|source
argument_list|,
name|cpuidp
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 		 * It's possible for a protocol not to have a good idea about 		 * where to process a packet, in which case we fall back on 		 * the netisr code to decide.  In the hybrid case, return the 		 * current CPU ID, which will force an immediate direct 		 * dispatch.  In the queued case, fall back on the SOURCE 		 * policy. 		 */
if|if
condition|(
operator|*
name|cpuidp
operator|!=
name|NETISR_CPUID_NONE
condition|)
block|{
operator|*
name|cpuidp
operator|=
name|netisr_get_cpuid
argument_list|(
operator|*
name|cpuidp
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
if|if
condition|(
name|dispatch_policy
operator|==
name|NETISR_DISPATCH_HYBRID
condition|)
block|{
operator|*
name|cpuidp
operator|=
name|netisr_get_cpuid
argument_list|(
name|curcpu
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
name|policy
operator|=
name|NETISR_POLICY_SOURCE
expr_stmt|;
block|}
if|if
condition|(
name|policy
operator|==
name|NETISR_POLICY_FLOW
condition|)
block|{
if|if
condition|(
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
operator|==
name|M_HASHTYPE_NONE
operator|&&
name|npp
operator|->
name|np_m2flow
operator|!=
name|NULL
condition|)
block|{
name|m
operator|=
name|npp
operator|->
name|np_m2flow
argument_list|(
name|m
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
operator|!=
name|M_HASHTYPE_NONE
condition|)
block|{
operator|*
name|cpuidp
operator|=
name|netisr_default_flow2cpu
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
name|policy
operator|=
name|NETISR_POLICY_SOURCE
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|policy
operator|==
name|NETISR_POLICY_SOURCE
argument_list|,
operator|(
literal|"%s: invalid policy %u for %s"
operator|,
name|__func__
operator|,
name|npp
operator|->
name|np_policy
operator|,
name|npp
operator|->
name|np_name
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
operator|*
name|cpuidp
operator|=
name|nws_array
index|[
operator|(
name|ifp
operator|->
name|if_index
operator|+
name|source
operator|)
operator|%
name|nws_count
index|]
expr_stmt|;
else|else
operator|*
name|cpuidp
operator|=
name|nws_array
index|[
name|source
operator|%
name|nws_count
index|]
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process packets associated with a workstream and protocol.  For reasons of  * fairness, we process up to one complete netisr queue at a time, moving the  * queue to a stack-local queue for processing, but do not loop refreshing  * from the global queue.  The caller is responsible for deciding whether to  * loop, and for setting the NWS_RUNNING flag.  The passed workstream will be  * locked on entry and relocked before return, but will be released while  * processing.  The number of packets processed is returned.  */
end_comment

begin_function
specifier|static
name|u_int
name|netisr_process_workstream_proto
parameter_list|(
name|struct
name|netisr_workstream
modifier|*
name|nwsp
parameter_list|,
name|u_int
name|proto
parameter_list|)
block|{
name|struct
name|netisr_work
name|local_npw
decl_stmt|,
modifier|*
name|npwp
decl_stmt|;
name|u_int
name|handled
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|NETISR_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|NWS_LOCK_ASSERT
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nwsp
operator|->
name|nws_flags
operator|&
name|NWS_RUNNING
argument_list|,
operator|(
literal|"%s(%u): not running"
operator|,
name|__func__
operator|,
name|proto
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|proto
operator|>=
literal|0
operator|&&
name|proto
operator|<
name|NETISR_MAXPROT
argument_list|,
operator|(
literal|"%s(%u): invalid proto\n"
operator|,
name|__func__
operator|,
name|proto
operator|)
argument_list|)
expr_stmt|;
name|npwp
operator|=
operator|&
name|nwsp
operator|->
name|nws_work
index|[
name|proto
index|]
expr_stmt|;
if|if
condition|(
name|npwp
operator|->
name|nw_len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Move the global work queue to a thread-local work queue. 	 * 	 * Notice that this means the effective maximum length of the queue 	 * is actually twice that of the maximum queue length specified in 	 * the protocol registration call. 	 */
name|handled
operator|=
name|npwp
operator|->
name|nw_len
expr_stmt|;
name|local_npw
operator|=
operator|*
name|npwp
expr_stmt|;
name|npwp
operator|->
name|nw_head
operator|=
name|NULL
expr_stmt|;
name|npwp
operator|->
name|nw_tail
operator|=
name|NULL
expr_stmt|;
name|npwp
operator|->
name|nw_len
operator|=
literal|0
expr_stmt|;
name|nwsp
operator|->
name|nws_pendingbits
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|proto
operator|)
expr_stmt|;
name|NWS_UNLOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|local_npw
operator|.
name|nw_head
operator|)
operator|!=
name|NULL
condition|)
block|{
name|local_npw
operator|.
name|nw_head
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|local_npw
operator|.
name|nw_head
operator|==
name|NULL
condition|)
name|local_npw
operator|.
name|nw_tail
operator|=
name|NULL
expr_stmt|;
name|local_npw
operator|.
name|nw_len
operator|--
expr_stmt|;
name|VNET_ASSERT
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s:%d rcvif == NULL: m=%p"
operator|,
name|__func__
operator|,
name|__LINE__
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_handler
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|local_npw
operator|.
name|nw_len
operator|==
literal|0
argument_list|,
operator|(
literal|"%s(%u): len %u"
operator|,
name|__func__
operator|,
name|proto
operator|,
name|local_npw
operator|.
name|nw_len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_drainedcpu
condition|)
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_drainedcpu
argument_list|(
name|nwsp
operator|->
name|nws_cpu
argument_list|)
expr_stmt|;
name|NWS_LOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
name|npwp
operator|->
name|nw_handled
operator|+=
name|handled
expr_stmt|;
return|return
operator|(
name|handled
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * SWI handler for netisr -- processes packets in a set of workstreams that  * it owns, woken up by calls to NWS_SIGNAL().  If this workstream is already  * being direct dispatched, go back to sleep and wait for the dispatching  * thread to wake us up again.  */
end_comment

begin_function
specifier|static
name|void
name|swi_net
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NETISR_LOCKING
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
endif|#
directive|endif
name|struct
name|netisr_workstream
modifier|*
name|nwsp
decl_stmt|;
name|u_int
name|bits
decl_stmt|,
name|prot
decl_stmt|;
name|nwsp
operator|=
name|arg
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVICE_POLLING
name|KASSERT
argument_list|(
name|nws_count
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: device_polling but nws_count != 1"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|netisr_poll
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NETISR_LOCKING
name|NETISR_RLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|NWS_LOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|nwsp
operator|->
name|nws_flags
operator|&
name|NWS_RUNNING
operator|)
argument_list|,
operator|(
literal|"swi_net: running"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwsp
operator|->
name|nws_flags
operator|&
name|NWS_DISPATCHING
condition|)
goto|goto
name|out
goto|;
name|nwsp
operator|->
name|nws_flags
operator||=
name|NWS_RUNNING
expr_stmt|;
name|nwsp
operator|->
name|nws_flags
operator|&=
operator|~
name|NWS_SCHEDULED
expr_stmt|;
while|while
condition|(
operator|(
name|bits
operator|=
name|nwsp
operator|->
name|nws_pendingbits
operator|)
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|prot
operator|=
name|ffs
argument_list|(
name|bits
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|prot
operator|--
expr_stmt|;
name|bits
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|prot
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|netisr_process_workstream_proto
argument_list|(
name|nwsp
argument_list|,
name|prot
argument_list|)
expr_stmt|;
block|}
block|}
name|nwsp
operator|->
name|nws_flags
operator|&=
operator|~
name|NWS_RUNNING
expr_stmt|;
name|out
label|:
name|NWS_UNLOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NETISR_LOCKING
name|NETISR_RUNLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEVICE_POLLING
name|netisr_pollmore
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|netisr_queue_workstream
parameter_list|(
name|struct
name|netisr_workstream
modifier|*
name|nwsp
parameter_list|,
name|u_int
name|proto
parameter_list|,
name|struct
name|netisr_work
modifier|*
name|npwp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
modifier|*
name|dosignalp
parameter_list|)
block|{
name|NWS_LOCK_ASSERT
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
operator|*
name|dosignalp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|npwp
operator|->
name|nw_len
operator|<
name|npwp
operator|->
name|nw_qlimit
condition|)
block|{
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|npwp
operator|->
name|nw_head
operator|==
name|NULL
condition|)
block|{
name|npwp
operator|->
name|nw_head
operator|=
name|m
expr_stmt|;
name|npwp
operator|->
name|nw_tail
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
name|npwp
operator|->
name|nw_tail
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
name|npwp
operator|->
name|nw_tail
operator|=
name|m
expr_stmt|;
block|}
name|npwp
operator|->
name|nw_len
operator|++
expr_stmt|;
if|if
condition|(
name|npwp
operator|->
name|nw_len
operator|>
name|npwp
operator|->
name|nw_watermark
condition|)
name|npwp
operator|->
name|nw_watermark
operator|=
name|npwp
operator|->
name|nw_len
expr_stmt|;
comment|/* 		 * We must set the bit regardless of NWS_RUNNING, so that 		 * swi_net() keeps calling netisr_process_workstream_proto(). 		 */
name|nwsp
operator|->
name|nws_pendingbits
operator||=
operator|(
literal|1
operator|<<
name|proto
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nwsp
operator|->
name|nws_flags
operator|&
operator|(
name|NWS_RUNNING
operator||
name|NWS_DISPATCHING
operator||
name|NWS_SCHEDULED
operator|)
operator|)
condition|)
block|{
name|nwsp
operator|->
name|nws_flags
operator||=
name|NWS_SCHEDULED
expr_stmt|;
operator|*
name|dosignalp
operator|=
literal|1
expr_stmt|;
comment|/* Defer until unlocked. */
block|}
name|npwp
operator|->
name|nw_queued
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|npwp
operator|->
name|nw_qdrops
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|netisr_queue_internal
parameter_list|(
name|u_int
name|proto
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u_int
name|cpuid
parameter_list|)
block|{
name|struct
name|netisr_workstream
modifier|*
name|nwsp
decl_stmt|;
name|struct
name|netisr_work
modifier|*
name|npwp
decl_stmt|;
name|int
name|dosignal
decl_stmt|,
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|NETISR_LOCKING
name|NETISR_LOCK_ASSERT
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|cpuid
operator|<=
name|mp_maxid
argument_list|,
operator|(
literal|"%s: cpuid too big (%u, %u)"
operator|,
name|__func__
operator|,
name|cpuid
operator|,
name|mp_maxid
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|CPU_ABSENT
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|(
literal|"%s: CPU %u absent"
operator|,
name|__func__
operator|,
name|cpuid
operator|)
argument_list|)
expr_stmt|;
name|dosignal
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|nwsp
operator|=
name|DPCPU_ID_PTR
argument_list|(
name|cpuid
argument_list|,
name|nws
argument_list|)
expr_stmt|;
name|npwp
operator|=
operator|&
name|nwsp
operator|->
name|nws_work
index|[
name|proto
index|]
expr_stmt|;
name|NWS_LOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
name|error
operator|=
name|netisr_queue_workstream
argument_list|(
name|nwsp
argument_list|,
name|proto
argument_list|,
name|npwp
argument_list|,
name|m
argument_list|,
operator|&
name|dosignal
argument_list|)
expr_stmt|;
name|NWS_UNLOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dosignal
condition|)
name|NWS_SIGNAL
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|netisr_queue_src
parameter_list|(
name|u_int
name|proto
parameter_list|,
name|uintptr_t
name|source
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NETISR_LOCKING
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
endif|#
directive|endif
name|u_int
name|cpuid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|proto
operator|<
name|NETISR_MAXPROT
argument_list|,
operator|(
literal|"%s: invalid proto %u"
operator|,
name|__func__
operator|,
name|proto
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NETISR_LOCKING
name|NETISR_RLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_handler
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: invalid proto %u"
operator|,
name|__func__
operator|,
name|proto
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VIMAGE
if|if
condition|(
name|V_netisr_enable
index|[
name|proto
index|]
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOPROTOOPT
operator|)
return|;
block|}
endif|#
directive|endif
name|m
operator|=
name|netisr_select_cpuid
argument_list|(
operator|&
name|netisr_proto
index|[
name|proto
index|]
argument_list|,
name|NETISR_DISPATCH_DEFERRED
argument_list|,
name|source
argument_list|,
name|m
argument_list|,
operator|&
name|cpuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
operator|!
name|CPU_ABSENT
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|(
literal|"%s: CPU %u absent"
operator|,
name|__func__
operator|,
name|cpuid
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|netisr_queue_internal
argument_list|(
name|proto
argument_list|,
name|m
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ENOBUFS
expr_stmt|;
ifdef|#
directive|ifdef
name|NETISR_LOCKING
name|NETISR_RUNLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|netisr_queue
parameter_list|(
name|u_int
name|proto
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
operator|(
name|netisr_queue_src
argument_list|(
name|proto
argument_list|,
literal|0
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dispatch a packet for netisr processing; direct dispatch is permitted by  * calling context.  */
end_comment

begin_function
name|int
name|netisr_dispatch_src
parameter_list|(
name|u_int
name|proto
parameter_list|,
name|uintptr_t
name|source
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NETISR_LOCKING
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
endif|#
directive|endif
name|struct
name|netisr_workstream
modifier|*
name|nwsp
decl_stmt|;
name|struct
name|netisr_proto
modifier|*
name|npp
decl_stmt|;
name|struct
name|netisr_work
modifier|*
name|npwp
decl_stmt|;
name|int
name|dosignal
decl_stmt|,
name|error
decl_stmt|;
name|u_int
name|cpuid
decl_stmt|,
name|dispatch_policy
decl_stmt|;
name|KASSERT
argument_list|(
name|proto
operator|<
name|NETISR_MAXPROT
argument_list|,
operator|(
literal|"%s: invalid proto %u"
operator|,
name|__func__
operator|,
name|proto
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NETISR_LOCKING
name|NETISR_RLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|npp
operator|=
operator|&
name|netisr_proto
index|[
name|proto
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|npp
operator|->
name|np_handler
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: invalid proto %u"
operator|,
name|__func__
operator|,
name|proto
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VIMAGE
if|if
condition|(
name|V_netisr_enable
index|[
name|proto
index|]
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOPROTOOPT
operator|)
return|;
block|}
endif|#
directive|endif
name|dispatch_policy
operator|=
name|netisr_get_dispatch
argument_list|(
name|npp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dispatch_policy
operator|==
name|NETISR_DISPATCH_DEFERRED
condition|)
return|return
operator|(
name|netisr_queue_src
argument_list|(
name|proto
argument_list|,
name|source
argument_list|,
name|m
argument_list|)
operator|)
return|;
comment|/* 	 * If direct dispatch is forced, then unconditionally dispatch 	 * without a formal CPU selection.  Borrow the current CPU's stats, 	 * even if there's no worker on it.  In this case we don't update 	 * nws_flags because all netisr processing will be source ordered due 	 * to always being forced to directly dispatch. 	 */
if|if
condition|(
name|dispatch_policy
operator|==
name|NETISR_DISPATCH_DIRECT
condition|)
block|{
name|nwsp
operator|=
name|DPCPU_PTR
argument_list|(
name|nws
argument_list|)
expr_stmt|;
name|npwp
operator|=
operator|&
name|nwsp
operator|->
name|nws_work
index|[
name|proto
index|]
expr_stmt|;
name|npwp
operator|->
name|nw_dispatched
operator|++
expr_stmt|;
name|npwp
operator|->
name|nw_handled
operator|++
expr_stmt|;
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_handler
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out_unlock
goto|;
block|}
name|KASSERT
argument_list|(
name|dispatch_policy
operator|==
name|NETISR_DISPATCH_HYBRID
argument_list|,
operator|(
literal|"%s: unknown dispatch policy (%u)"
operator|,
name|__func__
operator|,
name|dispatch_policy
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Otherwise, we execute in a hybrid mode where we will try to direct 	 * dispatch if we're on the right CPU and the netisr worker isn't 	 * already running. 	 */
name|sched_pin
argument_list|()
expr_stmt|;
name|m
operator|=
name|netisr_select_cpuid
argument_list|(
operator|&
name|netisr_proto
index|[
name|proto
index|]
argument_list|,
name|NETISR_DISPATCH_HYBRID
argument_list|,
name|source
argument_list|,
name|m
argument_list|,
operator|&
name|cpuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out_unpin
goto|;
block|}
name|KASSERT
argument_list|(
operator|!
name|CPU_ABSENT
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|(
literal|"%s: CPU %u absent"
operator|,
name|__func__
operator|,
name|cpuid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpuid
operator|!=
name|curcpu
condition|)
goto|goto
name|queue_fallback
goto|;
name|nwsp
operator|=
name|DPCPU_PTR
argument_list|(
name|nws
argument_list|)
expr_stmt|;
name|npwp
operator|=
operator|&
name|nwsp
operator|->
name|nws_work
index|[
name|proto
index|]
expr_stmt|;
comment|/*- 	 * We are willing to direct dispatch only if three conditions hold: 	 * 	 * (1) The netisr worker isn't already running, 	 * (2) Another thread isn't already directly dispatching, and 	 * (3) The netisr hasn't already been woken up. 	 */
name|NWS_LOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwsp
operator|->
name|nws_flags
operator|&
operator|(
name|NWS_RUNNING
operator||
name|NWS_DISPATCHING
operator||
name|NWS_SCHEDULED
operator|)
condition|)
block|{
name|error
operator|=
name|netisr_queue_workstream
argument_list|(
name|nwsp
argument_list|,
name|proto
argument_list|,
name|npwp
argument_list|,
name|m
argument_list|,
operator|&
name|dosignal
argument_list|)
expr_stmt|;
name|NWS_UNLOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dosignal
condition|)
name|NWS_SIGNAL
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
goto|goto
name|out_unpin
goto|;
block|}
comment|/* 	 * The current thread is now effectively the netisr worker, so set 	 * the dispatching flag to prevent concurrent processing of the 	 * stream from another thread (even the netisr worker), which could 	 * otherwise lead to effective misordering of the stream. 	 */
name|nwsp
operator|->
name|nws_flags
operator||=
name|NWS_DISPATCHING
expr_stmt|;
name|NWS_UNLOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_handler
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|NWS_LOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
name|nwsp
operator|->
name|nws_flags
operator|&=
operator|~
name|NWS_DISPATCHING
expr_stmt|;
name|npwp
operator|->
name|nw_handled
operator|++
expr_stmt|;
name|npwp
operator|->
name|nw_hybrid_dispatched
operator|++
expr_stmt|;
comment|/* 	 * If other work was enqueued by another thread while we were direct 	 * dispatching, we need to signal the netisr worker to do that work. 	 * In the future, we might want to do some of that work in the 	 * current thread, rather than trigger further context switches.  If 	 * so, we'll want to establish a reasonable bound on the work done in 	 * the "borrowed" context. 	 */
if|if
condition|(
name|nwsp
operator|->
name|nws_pendingbits
operator|!=
literal|0
condition|)
block|{
name|nwsp
operator|->
name|nws_flags
operator||=
name|NWS_SCHEDULED
expr_stmt|;
name|dosignal
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|dosignal
operator|=
literal|0
expr_stmt|;
name|NWS_UNLOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dosignal
condition|)
name|NWS_SIGNAL
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out_unpin
goto|;
name|queue_fallback
label|:
name|error
operator|=
name|netisr_queue_internal
argument_list|(
name|proto
argument_list|,
name|m
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
name|out_unpin
label|:
name|sched_unpin
argument_list|()
expr_stmt|;
name|out_unlock
label|:
ifdef|#
directive|ifdef
name|NETISR_LOCKING
name|NETISR_RUNLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|netisr_dispatch
parameter_list|(
name|u_int
name|proto
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
operator|(
name|netisr_dispatch_src
argument_list|(
name|proto
argument_list|,
literal|0
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEVICE_POLLING
end_ifdef

begin_comment
comment|/*  * Kernel polling borrows a netisr thread to run interface polling in; this  * function allows kernel polling to request that the netisr thread be  * scheduled even if no packets are pending for protocols.  */
end_comment

begin_function
name|void
name|netisr_sched_poll
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|netisr_workstream
modifier|*
name|nwsp
decl_stmt|;
name|nwsp
operator|=
name|DPCPU_ID_PTR
argument_list|(
name|nws_array
index|[
literal|0
index|]
argument_list|,
name|nws
argument_list|)
expr_stmt|;
name|NWS_SIGNAL
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|netisr_start_swi
parameter_list|(
name|u_int
name|cpuid
parameter_list|,
name|struct
name|pcpu
modifier|*
name|pc
parameter_list|)
block|{
name|char
name|swiname
index|[
literal|12
index|]
decl_stmt|;
name|struct
name|netisr_workstream
modifier|*
name|nwsp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
name|CPU_ABSENT
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|(
literal|"%s: CPU %u absent"
operator|,
name|__func__
operator|,
name|cpuid
operator|)
argument_list|)
expr_stmt|;
name|nwsp
operator|=
name|DPCPU_ID_PTR
argument_list|(
name|cpuid
argument_list|,
name|nws
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|nwsp
operator|->
name|nws_mtx
argument_list|,
literal|"netisr_mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|nwsp
operator|->
name|nws_cpu
operator|=
name|cpuid
expr_stmt|;
name|snprintf
argument_list|(
name|swiname
argument_list|,
sizeof|sizeof
argument_list|(
name|swiname
argument_list|)
argument_list|,
literal|"netisr %u"
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
name|error
operator|=
name|swi_add
argument_list|(
operator|&
name|nwsp
operator|->
name|nws_intr_event
argument_list|,
name|swiname
argument_list|,
name|swi_net
argument_list|,
name|nwsp
argument_list|,
name|SWI_NET
argument_list|,
name|INTR_MPSAFE
argument_list|,
operator|&
name|nwsp
operator|->
name|nws_swi_cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"%s: swi_add %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_netisr
operator|=
name|nwsp
operator|->
name|nws_intr_event
expr_stmt|;
if|if
condition|(
name|netisr_bindthreads
condition|)
block|{
name|error
operator|=
name|intr_event_bind
argument_list|(
name|nwsp
operator|->
name|nws_intr_event
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: cpu %u: intr_event_bind: %d"
argument_list|,
name|__func__
argument_list|,
name|cpuid
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|NETISR_WLOCK
argument_list|()
expr_stmt|;
name|nws_array
index|[
name|nws_count
index|]
operator|=
name|nwsp
operator|->
name|nws_cpu
expr_stmt|;
name|nws_count
operator|++
expr_stmt|;
name|NETISR_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the netisr subsystem.  We rely on BSS and static initialization  * of most fields in global data structures.  *  * Start a worker thread for the boot CPU so that we can support network  * traffic immediately in case the network stack is used before additional  * CPUs are started (for example, diskless boot).  */
end_comment

begin_function
specifier|static
name|void
name|netisr_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pcpu
modifier|*
name|pc
decl_stmt|;
name|NETISR_LOCK_INIT
argument_list|()
expr_stmt|;
if|if
condition|(
name|netisr_maxthreads
operator|==
literal|0
operator|||
name|netisr_maxthreads
operator|<
operator|-
literal|1
condition|)
name|netisr_maxthreads
operator|=
literal|1
expr_stmt|;
comment|/* default behavior */
elseif|else
if|if
condition|(
name|netisr_maxthreads
operator|==
operator|-
literal|1
condition|)
name|netisr_maxthreads
operator|=
name|mp_ncpus
expr_stmt|;
comment|/* use max cpus */
if|if
condition|(
name|netisr_maxthreads
operator|>
name|mp_ncpus
condition|)
block|{
name|printf
argument_list|(
literal|"netisr_init: forcing maxthreads from %d to %d\n"
argument_list|,
name|netisr_maxthreads
argument_list|,
name|mp_ncpus
argument_list|)
expr_stmt|;
name|netisr_maxthreads
operator|=
name|mp_ncpus
expr_stmt|;
block|}
if|if
condition|(
name|netisr_defaultqlimit
operator|>
name|netisr_maxqlimit
condition|)
block|{
name|printf
argument_list|(
literal|"netisr_init: forcing defaultqlimit from %d to %d\n"
argument_list|,
name|netisr_defaultqlimit
argument_list|,
name|netisr_maxqlimit
argument_list|)
expr_stmt|;
name|netisr_defaultqlimit
operator|=
name|netisr_maxqlimit
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEVICE_POLLING
comment|/* 	 * The device polling code is not yet aware of how to deal with 	 * multiple netisr threads, so for the time being compiling in device 	 * polling disables parallel netisr workers. 	 */
if|if
condition|(
name|netisr_maxthreads
operator|!=
literal|1
operator|||
name|netisr_bindthreads
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"netisr_init: forcing maxthreads to 1 and "
literal|"bindthreads to 0 for device polling\n"
argument_list|)
expr_stmt|;
name|netisr_maxthreads
operator|=
literal|1
expr_stmt|;
name|netisr_bindthreads
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EARLY_AP_STARTUP
name|STAILQ_FOREACH
argument_list|(
argument|pc
argument_list|,
argument|&cpuhead
argument_list|,
argument|pc_allcpu
argument_list|)
block|{
if|if
condition|(
name|nws_count
operator|>=
name|netisr_maxthreads
condition|)
break|break;
name|netisr_start_swi
argument_list|(
name|pc
operator|->
name|pc_cpuid
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|pc
operator|=
name|get_pcpu
argument_list|()
expr_stmt|;
name|netisr_start_swi
argument_list|(
name|pc
operator|->
name|pc_cpuid
argument_list|,
name|pc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|netisr_init
argument_list|,
name|SI_SUB_SOFTINTR
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|netisr_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|EARLY_AP_STARTUP
end_ifndef

begin_comment
comment|/*  * Start worker threads for additional CPUs.  No attempt to gracefully handle  * work reassignment, we don't yet support dynamic reconfiguration.  */
end_comment

begin_function
specifier|static
name|void
name|netisr_start
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pcpu
modifier|*
name|pc
decl_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|pc
argument_list|,
argument|&cpuhead
argument_list|,
argument|pc_allcpu
argument_list|)
block|{
if|if
condition|(
name|nws_count
operator|>=
name|netisr_maxthreads
condition|)
break|break;
comment|/* Worker will already be present for boot CPU. */
if|if
condition|(
name|pc
operator|->
name|pc_netisr
operator|!=
name|NULL
condition|)
continue|continue;
name|netisr_start_swi
argument_list|(
name|pc
operator|->
name|pc_cpuid
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|netisr_start
argument_list|,
name|SI_SUB_SMP
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|,
name|netisr_start
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Sysctl monitoring for netisr: query a list of registered protocols.  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_netisr_proto
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
name|struct
name|sysctl_netisr_proto
modifier|*
name|snpp
decl_stmt|,
modifier|*
name|snp_array
decl_stmt|;
name|struct
name|netisr_proto
modifier|*
name|npp
decl_stmt|;
name|u_int
name|counter
decl_stmt|,
name|proto
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|snp_array
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|snp_array
argument_list|)
operator|*
name|NETISR_MAXPROT
argument_list|,
name|M_TEMP
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|counter
operator|=
literal|0
expr_stmt|;
name|NETISR_RLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
for|for
control|(
name|proto
operator|=
literal|0
init|;
name|proto
operator|<
name|NETISR_MAXPROT
condition|;
name|proto
operator|++
control|)
block|{
name|npp
operator|=
operator|&
name|netisr_proto
index|[
name|proto
index|]
expr_stmt|;
if|if
condition|(
name|npp
operator|->
name|np_name
operator|==
name|NULL
condition|)
continue|continue;
name|snpp
operator|=
operator|&
name|snp_array
index|[
name|counter
index|]
expr_stmt|;
name|snpp
operator|->
name|snp_version
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|snpp
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|snpp
operator|->
name|snp_name
argument_list|,
name|npp
operator|->
name|np_name
argument_list|,
name|NETISR_NAMEMAXLEN
argument_list|)
expr_stmt|;
name|snpp
operator|->
name|snp_proto
operator|=
name|proto
expr_stmt|;
name|snpp
operator|->
name|snp_qlimit
operator|=
name|npp
operator|->
name|np_qlimit
expr_stmt|;
name|snpp
operator|->
name|snp_policy
operator|=
name|npp
operator|->
name|np_policy
expr_stmt|;
name|snpp
operator|->
name|snp_dispatch
operator|=
name|npp
operator|->
name|np_dispatch
expr_stmt|;
if|if
condition|(
name|npp
operator|->
name|np_m2flow
operator|!=
name|NULL
condition|)
name|snpp
operator|->
name|snp_flags
operator||=
name|NETISR_SNP_FLAGS_M2FLOW
expr_stmt|;
if|if
condition|(
name|npp
operator|->
name|np_m2cpuid
operator|!=
name|NULL
condition|)
name|snpp
operator|->
name|snp_flags
operator||=
name|NETISR_SNP_FLAGS_M2CPUID
expr_stmt|;
if|if
condition|(
name|npp
operator|->
name|np_drainedcpu
operator|!=
name|NULL
condition|)
name|snpp
operator|->
name|snp_flags
operator||=
name|NETISR_SNP_FLAGS_DRAINEDCPU
expr_stmt|;
name|counter
operator|++
expr_stmt|;
block|}
name|NETISR_RUNLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|counter
operator|<=
name|NETISR_MAXPROT
argument_list|,
operator|(
literal|"sysctl_netisr_proto: counter too big (%d)"
operator|,
name|counter
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|snp_array
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|snp_array
argument_list|)
operator|*
name|counter
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|snp_array
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_isr
argument_list|,
name|OID_AUTO
argument_list|,
name|proto
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_STRUCT
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_netisr_proto
argument_list|,
literal|"S,sysctl_netisr_proto"
argument_list|,
literal|"Return list of protocols registered with netisr"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Sysctl monitoring for netisr: query a list of workstreams.  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_netisr_workstream
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
name|struct
name|sysctl_netisr_workstream
modifier|*
name|snwsp
decl_stmt|,
modifier|*
name|snws_array
decl_stmt|;
name|struct
name|netisr_workstream
modifier|*
name|nwsp
decl_stmt|;
name|u_int
name|counter
decl_stmt|,
name|cpuid
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|snws_array
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|snws_array
argument_list|)
operator|*
name|MAXCPU
argument_list|,
name|M_TEMP
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|counter
operator|=
literal|0
expr_stmt|;
name|NETISR_RLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|CPU_FOREACH
argument_list|(
argument|cpuid
argument_list|)
block|{
name|nwsp
operator|=
name|DPCPU_ID_PTR
argument_list|(
name|cpuid
argument_list|,
name|nws
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwsp
operator|->
name|nws_intr_event
operator|==
name|NULL
condition|)
continue|continue;
name|NWS_LOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
name|snwsp
operator|=
operator|&
name|snws_array
index|[
name|counter
index|]
expr_stmt|;
name|snwsp
operator|->
name|snws_version
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|snwsp
argument_list|)
expr_stmt|;
comment|/* 		 * For now, we equate workstream IDs and CPU IDs in the 		 * kernel, but expose them independently to userspace in case 		 * that assumption changes in the future. 		 */
name|snwsp
operator|->
name|snws_wsid
operator|=
name|cpuid
expr_stmt|;
name|snwsp
operator|->
name|snws_cpu
operator|=
name|cpuid
expr_stmt|;
if|if
condition|(
name|nwsp
operator|->
name|nws_intr_event
operator|!=
name|NULL
condition|)
name|snwsp
operator|->
name|snws_flags
operator||=
name|NETISR_SNWS_FLAGS_INTR
expr_stmt|;
name|NWS_UNLOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
name|counter
operator|++
expr_stmt|;
block|}
name|NETISR_RUNLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|counter
operator|<=
name|MAXCPU
argument_list|,
operator|(
literal|"sysctl_netisr_workstream: counter too big (%d)"
operator|,
name|counter
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|snws_array
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|snws_array
argument_list|)
operator|*
name|counter
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|snws_array
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_isr
argument_list|,
name|OID_AUTO
argument_list|,
name|workstream
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_STRUCT
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_netisr_workstream
argument_list|,
literal|"S,sysctl_netisr_workstream"
argument_list|,
literal|"Return list of workstreams implemented by netisr"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Sysctl monitoring for netisr: query per-protocol data across all  * workstreams.  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_netisr_work
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
name|struct
name|sysctl_netisr_work
modifier|*
name|snwp
decl_stmt|,
modifier|*
name|snw_array
decl_stmt|;
name|struct
name|netisr_workstream
modifier|*
name|nwsp
decl_stmt|;
name|struct
name|netisr_proto
modifier|*
name|npp
decl_stmt|;
name|struct
name|netisr_work
modifier|*
name|nwp
decl_stmt|;
name|u_int
name|counter
decl_stmt|,
name|cpuid
decl_stmt|,
name|proto
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|snw_array
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|snw_array
argument_list|)
operator|*
name|MAXCPU
operator|*
name|NETISR_MAXPROT
argument_list|,
name|M_TEMP
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|counter
operator|=
literal|0
expr_stmt|;
name|NETISR_RLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|CPU_FOREACH
argument_list|(
argument|cpuid
argument_list|)
block|{
name|nwsp
operator|=
name|DPCPU_ID_PTR
argument_list|(
name|cpuid
argument_list|,
name|nws
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwsp
operator|->
name|nws_intr_event
operator|==
name|NULL
condition|)
continue|continue;
name|NWS_LOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
for|for
control|(
name|proto
operator|=
literal|0
init|;
name|proto
operator|<
name|NETISR_MAXPROT
condition|;
name|proto
operator|++
control|)
block|{
name|npp
operator|=
operator|&
name|netisr_proto
index|[
name|proto
index|]
expr_stmt|;
if|if
condition|(
name|npp
operator|->
name|np_name
operator|==
name|NULL
condition|)
continue|continue;
name|nwp
operator|=
operator|&
name|nwsp
operator|->
name|nws_work
index|[
name|proto
index|]
expr_stmt|;
name|snwp
operator|=
operator|&
name|snw_array
index|[
name|counter
index|]
expr_stmt|;
name|snwp
operator|->
name|snw_version
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|snwp
argument_list|)
expr_stmt|;
name|snwp
operator|->
name|snw_wsid
operator|=
name|cpuid
expr_stmt|;
comment|/* See comment above. */
name|snwp
operator|->
name|snw_proto
operator|=
name|proto
expr_stmt|;
name|snwp
operator|->
name|snw_len
operator|=
name|nwp
operator|->
name|nw_len
expr_stmt|;
name|snwp
operator|->
name|snw_watermark
operator|=
name|nwp
operator|->
name|nw_watermark
expr_stmt|;
name|snwp
operator|->
name|snw_dispatched
operator|=
name|nwp
operator|->
name|nw_dispatched
expr_stmt|;
name|snwp
operator|->
name|snw_hybrid_dispatched
operator|=
name|nwp
operator|->
name|nw_hybrid_dispatched
expr_stmt|;
name|snwp
operator|->
name|snw_qdrops
operator|=
name|nwp
operator|->
name|nw_qdrops
expr_stmt|;
name|snwp
operator|->
name|snw_queued
operator|=
name|nwp
operator|->
name|nw_queued
expr_stmt|;
name|snwp
operator|->
name|snw_handled
operator|=
name|nwp
operator|->
name|nw_handled
expr_stmt|;
name|counter
operator|++
expr_stmt|;
block|}
name|NWS_UNLOCK
argument_list|(
name|nwsp
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|counter
operator|<=
name|MAXCPU
operator|*
name|NETISR_MAXPROT
argument_list|,
operator|(
literal|"sysctl_netisr_work: counter too big (%d)"
operator|,
name|counter
operator|)
argument_list|)
expr_stmt|;
name|NETISR_RUNLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|snw_array
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|snw_array
argument_list|)
operator|*
name|counter
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|snw_array
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_isr
argument_list|,
name|OID_AUTO
argument_list|,
name|work
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_STRUCT
operator||
name|CTLFLAG_MPSAFE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_netisr_work
argument_list|,
literal|"S,sysctl_netisr_work"
argument_list|,
literal|"Return list of per-workstream, per-protocol work in netisr"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|netisr
argument_list|,
argument|db_show_netisr
argument_list|)
end_macro

begin_block
block|{
name|struct
name|netisr_workstream
modifier|*
name|nwsp
decl_stmt|;
name|struct
name|netisr_work
modifier|*
name|nwp
decl_stmt|;
name|int
name|first
decl_stmt|,
name|proto
decl_stmt|;
name|u_int
name|cpuid
decl_stmt|;
name|db_printf
argument_list|(
literal|"%3s %6s %5s %5s %5s %8s %8s %8s %8s\n"
argument_list|,
literal|"CPU"
argument_list|,
literal|"Proto"
argument_list|,
literal|"Len"
argument_list|,
literal|"WMark"
argument_list|,
literal|"Max"
argument_list|,
literal|"Disp"
argument_list|,
literal|"HDisp"
argument_list|,
literal|"Drop"
argument_list|,
literal|"Queue"
argument_list|)
expr_stmt|;
name|CPU_FOREACH
argument_list|(
argument|cpuid
argument_list|)
block|{
name|nwsp
operator|=
name|DPCPU_ID_PTR
argument_list|(
name|cpuid
argument_list|,
name|nws
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwsp
operator|->
name|nws_intr_event
operator|==
name|NULL
condition|)
continue|continue;
name|first
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|proto
operator|=
literal|0
init|;
name|proto
operator|<
name|NETISR_MAXPROT
condition|;
name|proto
operator|++
control|)
block|{
if|if
condition|(
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_handler
operator|==
name|NULL
condition|)
continue|continue;
name|nwp
operator|=
operator|&
name|nwsp
operator|->
name|nws_work
index|[
name|proto
index|]
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|db_printf
argument_list|(
literal|"%3d "
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|db_printf
argument_list|(
literal|"%3s "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"%6s %5d %5d %5d %8ju %8ju %8ju %8ju\n"
argument_list|,
name|netisr_proto
index|[
name|proto
index|]
operator|.
name|np_name
argument_list|,
name|nwp
operator|->
name|nw_len
argument_list|,
name|nwp
operator|->
name|nw_watermark
argument_list|,
name|nwp
operator|->
name|nw_qlimit
argument_list|,
name|nwp
operator|->
name|nw_dispatched
argument_list|,
name|nwp
operator|->
name|nw_hybrid_dispatched
argument_list|,
name|nwp
operator|->
name|nw_qdrops
argument_list|,
name|nwp
operator|->
name|nw_queued
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

