begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2008-2010, BitGravity Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Neither the name of the BitGravity Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"opt_route.h"
end_include

begin_include
include|#
directive|include
file|"opt_mpath.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/bitstring.h>
end_include

begin_include
include|#
directive|include
file|<sys/condvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/hash.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llatbl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/flowtable.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_struct
struct|struct
name|ipv4_tuple
block|{
name|uint16_t
name|ip_sport
decl_stmt|;
comment|/* source port */
name|uint16_t
name|ip_dport
decl_stmt|;
comment|/* destination port */
name|in_addr_t
name|ip_saddr
decl_stmt|;
comment|/* source address */
name|in_addr_t
name|ip_daddr
decl_stmt|;
comment|/* destination address */
block|}
struct|;
end_struct

begin_union
union|union
name|ipv4_flow
block|{
name|struct
name|ipv4_tuple
name|ipf_ipt
decl_stmt|;
name|uint32_t
name|ipf_key
index|[
literal|3
index|]
decl_stmt|;
block|}
union|;
end_union

begin_struct
struct|struct
name|ipv6_tuple
block|{
name|uint16_t
name|ip_sport
decl_stmt|;
comment|/* source port */
name|uint16_t
name|ip_dport
decl_stmt|;
comment|/* destination port */
name|struct
name|in6_addr
name|ip_saddr
decl_stmt|;
comment|/* source address */
name|struct
name|in6_addr
name|ip_daddr
decl_stmt|;
comment|/* destination address */
block|}
struct|;
end_struct

begin_union
union|union
name|ipv6_flow
block|{
name|struct
name|ipv6_tuple
name|ipf_ipt
decl_stmt|;
name|uint32_t
name|ipf_key
index|[
literal|9
index|]
decl_stmt|;
block|}
union|;
end_union

begin_struct
struct|struct
name|flentry
block|{
specifier|volatile
name|uint32_t
name|f_fhash
decl_stmt|;
comment|/* hash flowing forward */
name|uint16_t
name|f_flags
decl_stmt|;
comment|/* flow flags */
name|uint8_t
name|f_pad
decl_stmt|;
name|uint8_t
name|f_proto
decl_stmt|;
comment|/* protocol */
name|uint32_t
name|f_fibnum
decl_stmt|;
comment|/* fib index */
name|uint32_t
name|f_uptime
decl_stmt|;
comment|/* uptime at last access */
name|struct
name|flentry
modifier|*
name|f_next
decl_stmt|;
comment|/* pointer to collision entry */
specifier|volatile
name|struct
name|rtentry
modifier|*
name|f_rt
decl_stmt|;
comment|/* rtentry for flow */
specifier|volatile
name|struct
name|llentry
modifier|*
name|f_lle
decl_stmt|;
comment|/* llentry for flow */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|flentry_v4
block|{
name|struct
name|flentry
name|fl_entry
decl_stmt|;
name|union
name|ipv4_flow
name|fl_flow
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|flentry_v6
block|{
name|struct
name|flentry
name|fl_entry
decl_stmt|;
name|union
name|ipv6_flow
name|fl_flow
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|fl_fhash
value|fl_entry.fl_fhash
end_define

begin_define
define|#
directive|define
name|fl_flags
value|fl_entry.fl_flags
end_define

begin_define
define|#
directive|define
name|fl_proto
value|fl_entry.fl_proto
end_define

begin_define
define|#
directive|define
name|fl_uptime
value|fl_entry.fl_uptime
end_define

begin_define
define|#
directive|define
name|fl_rt
value|fl_entry.fl_rt
end_define

begin_define
define|#
directive|define
name|fl_lle
value|fl_entry.fl_lle
end_define

begin_define
define|#
directive|define
name|SECS_PER_HOUR
value|3600
end_define

begin_define
define|#
directive|define
name|SECS_PER_DAY
value|(24*SECS_PER_HOUR)
end_define

begin_define
define|#
directive|define
name|SYN_IDLE
value|300
end_define

begin_define
define|#
directive|define
name|UDP_IDLE
value|300
end_define

begin_define
define|#
directive|define
name|FIN_WAIT_IDLE
value|600
end_define

begin_define
define|#
directive|define
name|TCP_IDLE
value|SECS_PER_DAY
end_define

begin_typedef
typedef|typedef
name|void
name|fl_lock_t
parameter_list|(
name|struct
name|flowtable
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|void
name|fl_rtalloc_t
parameter_list|(
name|struct
name|route
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_typedef

begin_union
union|union
name|flentryp
block|{
name|struct
name|flentry
modifier|*
modifier|*
name|global
decl_stmt|;
name|struct
name|flentry
modifier|*
modifier|*
name|pcpu
index|[
name|MAXCPU
index|]
decl_stmt|;
block|}
union|;
end_union

begin_struct
struct|struct
name|flowtable
block|{
name|counter_u64_t
modifier|*
name|ft_stat
decl_stmt|;
name|uma_zone_t
name|ft_zone
decl_stmt|;
name|int
name|ft_size
decl_stmt|;
name|int
name|ft_lock_count
decl_stmt|;
name|uint32_t
name|ft_flags
decl_stmt|;
name|uint32_t
name|ft_max_depth
decl_stmt|;
name|fl_lock_t
modifier|*
name|ft_lock
decl_stmt|;
name|fl_lock_t
modifier|*
name|ft_unlock
decl_stmt|;
name|fl_rtalloc_t
modifier|*
name|ft_rtalloc
decl_stmt|;
comment|/* 	 * XXX need to pad out 	 */
name|struct
name|mtx
modifier|*
name|ft_locks
decl_stmt|;
name|union
name|flentryp
name|ft_table
decl_stmt|;
name|bitstr_t
modifier|*
name|ft_masks
index|[
name|MAXCPU
index|]
decl_stmt|;
name|bitstr_t
modifier|*
name|ft_tmpmask
decl_stmt|;
name|uint32_t
name|ft_udp_idle
name|__aligned
parameter_list|(
name|CACHE_LINE_SIZE
parameter_list|)
function_decl|;
name|uint32_t
name|ft_fin_wait_idle
decl_stmt|;
name|uint32_t
name|ft_syn_idle
decl_stmt|;
name|uint32_t
name|ft_tcp_idle
decl_stmt|;
name|boolean_t
name|ft_full
decl_stmt|;
block|}
name|__aligned
argument_list|(
name|CACHE_LINE_SIZE
argument_list|)
struct|;
end_struct

begin_define
define|#
directive|define
name|FLOWSTAT_ADD
parameter_list|(
name|ft
parameter_list|,
name|name
parameter_list|,
name|v
parameter_list|)
define|\
value|counter_u64_add((ft)->ft_stat[offsetof(struct flowtable_stat, name) / sizeof(uint64_t)], (v))
end_define

begin_define
define|#
directive|define
name|FLOWSTAT_INC
parameter_list|(
name|ft
parameter_list|,
name|name
parameter_list|)
value|FLOWSTAT_ADD(ft, name, 1)
end_define

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|flowcleanerproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|flow_hashjitter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cv
name|flowclean_f_cv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cv
name|flowclean_c_cv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|flowclean_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|flowclean_cycles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|flowclean_freq
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * TODO:  * - add sysctls to resize&& flush flow tables  * - Add per flowtable sysctls for statistics and configuring timeouts  * - add saturation counter to rtentry to support per-packet load-balancing  *   add flag to indicate round-robin flow, add list lookup from head      for flows  * - add sysctl / device node / syscall to support exporting and importing  *   of flows with flag to indicate that a flow was imported so should  *   not be considered for auto-cleaning  * - support explicit connection state (currently only ad-hoc for DSR)  * - idetach() cleanup for options VIMAGE builds.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|flowtable
argument_list|,
name|ip4_ft
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_ip4_ft
value|VNET(ip4_ft)
end_define

begin_decl_stmt
specifier|static
name|uma_zone_t
name|flow_ipv4_zone
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|flowtable
argument_list|,
name|ip6_ft
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_ip6_ft
value|VNET(ip6_ft)
end_define

begin_decl_stmt
specifier|static
name|uma_zone_t
name|flow_ipv6_zone
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|flowtable_enable
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|flowtable_syn_expire
argument_list|)
operator|=
name|SYN_IDLE
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|flowtable_udp_expire
argument_list|)
operator|=
name|UDP_IDLE
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|flowtable_fin_wait_expire
argument_list|)
operator|=
name|FIN_WAIT_IDLE
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|flowtable_tcp_expire
argument_list|)
operator|=
name|TCP_IDLE
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_flowtable_enable
value|VNET(flowtable_enable)
end_define

begin_define
define|#
directive|define
name|V_flowtable_syn_expire
value|VNET(flowtable_syn_expire)
end_define

begin_define
define|#
directive|define
name|V_flowtable_udp_expire
value|VNET(flowtable_udp_expire)
end_define

begin_define
define|#
directive|define
name|V_flowtable_fin_wait_expire
value|VNET(flowtable_fin_wait_expire)
end_define

begin_define
define|#
directive|define
name|V_flowtable_tcp_expire
value|VNET(flowtable_tcp_expire)
end_define

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_net
argument_list|,
name|OID_AUTO
argument_list|,
name|flowtable
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"flowtable"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_flowtable
argument_list|,
name|OID_AUTO
argument_list|,
name|enable
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|flowtable_enable
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"enable flowtable caching."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * XXX This does not end up updating timeouts at runtime  * and only reflects the value for the last table added :-/  */
end_comment

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_flowtable
argument_list|,
name|OID_AUTO
argument_list|,
name|syn_expire
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|flowtable_syn_expire
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"seconds after which to remove syn allocated flow."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_flowtable
argument_list|,
name|OID_AUTO
argument_list|,
name|udp_expire
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|flowtable_udp_expire
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"seconds after which to remove flow allocated to UDP."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_flowtable
argument_list|,
name|OID_AUTO
argument_list|,
name|fin_wait_expire
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|flowtable_fin_wait_expire
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"seconds after which to remove a flow in FIN_WAIT."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_VNET_INT
argument_list|(
name|_net_flowtable
argument_list|,
name|OID_AUTO
argument_list|,
name|tcp_expire
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|flowtable_tcp_expire
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"seconds after which to remove flow allocated to a TCP connection."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|RADIX_MPATH
end_ifndef

begin_function
specifier|static
name|void
name|rtalloc_ign_wrapper
parameter_list|(
name|struct
name|route
modifier|*
name|ro
parameter_list|,
name|uint32_t
name|hash
parameter_list|,
name|u_int
name|fibnum
parameter_list|)
block|{
name|rtalloc_ign_fib
argument_list|(
name|ro
argument_list|,
literal|0
argument_list|,
name|fibnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|flowtable_global_lock
parameter_list|(
name|struct
name|flowtable
modifier|*
name|table
parameter_list|,
name|uint32_t
name|hash
parameter_list|)
block|{
name|int
name|lock_index
init|=
operator|(
name|hash
operator|)
operator|&
operator|(
name|table
operator|->
name|ft_lock_count
operator|-
literal|1
operator|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|table
operator|->
name|ft_locks
index|[
name|lock_index
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flowtable_global_unlock
parameter_list|(
name|struct
name|flowtable
modifier|*
name|table
parameter_list|,
name|uint32_t
name|hash
parameter_list|)
block|{
name|int
name|lock_index
init|=
operator|(
name|hash
operator|)
operator|&
operator|(
name|table
operator|->
name|ft_lock_count
operator|-
literal|1
operator|)
decl_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|table
operator|->
name|ft_locks
index|[
name|lock_index
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flowtable_pcpu_lock
parameter_list|(
name|struct
name|flowtable
modifier|*
name|table
parameter_list|,
name|uint32_t
name|hash
parameter_list|)
block|{
name|critical_enter
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flowtable_pcpu_unlock
parameter_list|(
name|struct
name|flowtable
modifier|*
name|table
parameter_list|,
name|uint32_t
name|hash
parameter_list|)
block|{
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|FL_ENTRY_INDEX
parameter_list|(
name|table
parameter_list|,
name|hash
parameter_list|)
value|((hash) % (table)->ft_size)
end_define

begin_define
define|#
directive|define
name|FL_ENTRY
parameter_list|(
name|table
parameter_list|,
name|hash
parameter_list|)
value|*flowtable_entry((table), (hash))
end_define

begin_define
define|#
directive|define
name|FL_ENTRY_LOCK
parameter_list|(
name|table
parameter_list|,
name|hash
parameter_list|)
value|(table)->ft_lock((table), (hash))
end_define

begin_define
define|#
directive|define
name|FL_ENTRY_UNLOCK
parameter_list|(
name|table
parameter_list|,
name|hash
parameter_list|)
value|(table)->ft_unlock((table), (hash))
end_define

begin_define
define|#
directive|define
name|FL_STALE
value|(1<<8)
end_define

begin_define
define|#
directive|define
name|FL_OVERWRITE
value|(1<<10)
end_define

begin_function_decl
specifier|static
name|struct
name|flentry
modifier|*
name|flowtable_lookup_common
parameter_list|(
name|struct
name|flowtable
modifier|*
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|int
name|proto_to_flags
parameter_list|(
name|uint8_t
name|proto
parameter_list|)
block|{
name|int
name|flag
decl_stmt|;
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|flag
operator|=
name|FL_TCP
expr_stmt|;
break|break;
case|case
name|IPPROTO_SCTP
case|:
name|flag
operator|=
name|FL_SCTP
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|flag
operator|=
name|FL_UDP
expr_stmt|;
break|break;
default|default:
name|flag
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|flag
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|flags_to_proto
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|int
name|proto
decl_stmt|,
name|protoflags
decl_stmt|;
name|protoflags
operator|=
name|flags
operator|&
operator|(
name|FL_TCP
operator||
name|FL_SCTP
operator||
name|FL_UDP
operator|)
expr_stmt|;
switch|switch
condition|(
name|protoflags
condition|)
block|{
case|case
name|FL_TCP
case|:
name|proto
operator|=
name|IPPROTO_TCP
expr_stmt|;
break|break;
case|case
name|FL_SCTP
case|:
name|proto
operator|=
name|IPPROTO_SCTP
expr_stmt|;
break|break;
case|case
name|FL_UDP
case|:
name|proto
operator|=
name|IPPROTO_UDP
expr_stmt|;
break|break;
default|default:
name|proto
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|proto
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|FLOWTABLE_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|ipv4_flow_print_tuple
parameter_list|(
name|int
name|flags
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|ssin
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|dsin
parameter_list|)
block|{
name|char
name|saddr
index|[
literal|4
operator|*
sizeof|sizeof
expr|"123"]
operator|,
name|daddr
index|[
literal|4
operator|*
sizeof|sizeof
expr|"123"]
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FL_HASH_ALL
condition|)
block|{
name|inet_ntoa_r
argument_list|(
name|ssin
operator|->
name|sin_addr
argument_list|,
name|saddr
argument_list|)
expr_stmt|;
name|inet_ntoa_r
argument_list|(
name|dsin
operator|->
name|sin_addr
argument_list|,
name|daddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"proto=%d %s:%d->%s:%d\n"
argument_list|,
name|proto
argument_list|,
name|saddr
argument_list|,
name|ntohs
argument_list|(
name|ssin
operator|->
name|sin_port
argument_list|)
argument_list|,
name|daddr
argument_list|,
name|ntohs
argument_list|(
name|dsin
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inet_ntoa_r
argument_list|(
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|dsin
operator|->
name|sin_addr
argument_list|,
name|daddr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"proto=%d %s\n"
argument_list|,
name|proto
argument_list|,
name|daddr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|ipv4_mbuf_demarshal
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|ssin
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|dsin
parameter_list|,
name|uint16_t
modifier|*
name|flags
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|uint8_t
name|proto
decl_stmt|;
name|int
name|iphlen
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|uh
decl_stmt|;
name|struct
name|sctphdr
modifier|*
name|sh
decl_stmt|;
name|uint16_t
name|sport
decl_stmt|,
name|dport
decl_stmt|;
name|proto
operator|=
name|sport
operator|=
name|dport
operator|=
literal|0
expr_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|dsin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|dsin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|dsin
argument_list|)
expr_stmt|;
name|dsin
operator|->
name|sin_addr
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
name|ssin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|ssin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ssin
argument_list|)
expr_stmt|;
name|ssin
operator|->
name|sin_addr
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
name|proto
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|flags
operator|&
name|FL_HASH_ALL
operator|)
operator|==
literal|0
condition|)
goto|goto
name|skipports
goto|;
name|iphlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
comment|/* XXX options? */
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|iphlen
operator|)
expr_stmt|;
name|sport
operator|=
name|th
operator|->
name|th_sport
expr_stmt|;
name|dport
operator|=
name|th
operator|->
name|th_dport
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|flags
operator|&
name|FL_HASH_ALL
operator|)
operator|&&
operator|(
name|th
operator|->
name|th_flags
operator|&
operator|(
name|TH_RST
operator||
name|TH_FIN
operator|)
operator|)
condition|)
operator|*
name|flags
operator||=
name|FL_STALE
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|uh
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|iphlen
operator|)
expr_stmt|;
name|sport
operator|=
name|uh
operator|->
name|uh_sport
expr_stmt|;
name|dport
operator|=
name|uh
operator|->
name|uh_dport
expr_stmt|;
break|break;
case|case
name|IPPROTO_SCTP
case|:
name|sh
operator|=
operator|(
expr|struct
name|sctphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|iphlen
operator|)
expr_stmt|;
name|sport
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|dport
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|ENOTSUP
operator|)
return|;
comment|/* no port - hence not a protocol we care about */
break|break;
block|}
name|skipports
label|:
operator|*
name|flags
operator||=
name|proto_to_flags
argument_list|(
name|proto
argument_list|)
expr_stmt|;
name|ssin
operator|->
name|sin_port
operator|=
name|sport
expr_stmt|;
name|dsin
operator|->
name|sin_port
operator|=
name|dport
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|ipv4_flow_lookup_hash
parameter_list|(
name|struct
name|sockaddr_in
modifier|*
name|ssin
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|dsin
parameter_list|,
name|uint32_t
modifier|*
name|key
parameter_list|,
name|uint16_t
name|flags
parameter_list|)
block|{
name|uint16_t
name|sport
decl_stmt|,
name|dport
decl_stmt|;
name|uint8_t
name|proto
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|proto
operator|=
name|flags_to_proto
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|sport
operator|=
name|dport
operator|=
name|key
index|[
literal|2
index|]
operator|=
name|key
index|[
literal|1
index|]
operator|=
name|key
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ssin
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|flags
operator|&
name|FL_HASH_ALL
operator|)
condition|)
block|{
name|key
index|[
literal|1
index|]
operator|=
name|ssin
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|sport
operator|=
name|ssin
operator|->
name|sin_port
expr_stmt|;
block|}
if|if
condition|(
name|dsin
operator|!=
name|NULL
condition|)
block|{
name|key
index|[
literal|2
index|]
operator|=
name|dsin
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|dport
operator|=
name|dsin
operator|->
name|sin_port
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|FL_HASH_ALL
condition|)
block|{
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|key
operator|)
index|[
literal|0
index|]
operator|=
name|sport
expr_stmt|;
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|key
operator|)
index|[
literal|1
index|]
operator|=
name|dport
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|flow_hashjitter
operator|+
name|proto
expr_stmt|;
return|return
operator|(
name|jenkins_hash32
argument_list|(
name|key
argument_list|,
literal|3
argument_list|,
name|offset
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|flentry
modifier|*
name|flowtable_lookup_ipv4
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|sockaddr_storage
name|ssa
decl_stmt|,
name|dsa
decl_stmt|;
name|uint16_t
name|flags
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|dsin
decl_stmt|,
modifier|*
name|ssin
decl_stmt|;
name|dsin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|dsa
expr_stmt|;
name|ssin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ssa
expr_stmt|;
name|bzero
argument_list|(
name|dsin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dsin
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ssin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ssin
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|=
name|V_ip4_ft
operator|.
name|ft_flags
expr_stmt|;
if|if
condition|(
name|ipv4_mbuf_demarshal
argument_list|(
name|m
argument_list|,
name|ssin
argument_list|,
name|dsin
argument_list|,
operator|&
name|flags
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|flowtable_lookup_common
argument_list|(
operator|&
name|V_ip4_ft
argument_list|,
operator|&
name|ssa
argument_list|,
operator|&
name|dsa
argument_list|,
name|m
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|flow_to_route
parameter_list|(
name|struct
name|flentry
modifier|*
name|fle
parameter_list|,
name|struct
name|route
modifier|*
name|ro
parameter_list|)
block|{
name|uint32_t
modifier|*
name|hashkey
init|=
name|NULL
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
name|hashkey
operator|=
operator|(
operator|(
expr|struct
name|flentry_v4
operator|*
operator|)
name|fle
operator|)
operator|->
name|fl_flow
operator|.
name|ipf_key
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|hashkey
index|[
literal|2
index|]
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|=
name|__DEVOLATILE
argument_list|(
expr|struct
name|rtentry
operator|*
argument_list|,
name|fle
operator|->
name|f_rt
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_lle
operator|=
name|__DEVOLATILE
argument_list|(
expr|struct
name|llentry
operator|*
argument_list|,
name|fle
operator|->
name|f_lle
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_flags
operator||=
name|RT_NORTREF
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_comment
comment|/*  * PULLUP_TO(len, p, T) makes sure that len + sizeof(T) is contiguous,  * then it sets p to point at the offset "len" in the mbuf. WARNING: the  * pointer might become stale after other pullups (but we never use it  * this way).  */
end_comment

begin_define
define|#
directive|define
name|PULLUP_TO
parameter_list|(
name|_len
parameter_list|,
name|p
parameter_list|,
name|T
parameter_list|)
define|\
value|do {									\ 	int x = (_len) + sizeof(T);					\ 	if ((m)->m_len< x) {						\ 		goto receive_failed;					\ 	}								\ 	p = (mtod(m, char *) + (_len));					\ } while (0)
end_define

begin_define
define|#
directive|define
name|TCP
parameter_list|(
name|p
parameter_list|)
value|((struct tcphdr *)(p))
end_define

begin_define
define|#
directive|define
name|SCTP
parameter_list|(
name|p
parameter_list|)
value|((struct sctphdr *)(p))
end_define

begin_define
define|#
directive|define
name|UDP
parameter_list|(
name|p
parameter_list|)
value|((struct udphdr *)(p))
end_define

begin_function
specifier|static
name|int
name|ipv6_mbuf_demarshal
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr_in6
modifier|*
name|ssin6
parameter_list|,
name|struct
name|sockaddr_in6
modifier|*
name|dsin6
parameter_list|,
name|uint16_t
modifier|*
name|flags
parameter_list|)
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|uint8_t
name|proto
decl_stmt|;
name|int
name|hlen
decl_stmt|;
name|uint16_t
name|src_port
decl_stmt|,
name|dst_port
decl_stmt|;
name|u_short
name|offset
decl_stmt|;
name|void
modifier|*
name|ulp
decl_stmt|;
name|offset
operator|=
name|hlen
operator|=
name|src_port
operator|=
name|dst_port
operator|=
literal|0
expr_stmt|;
name|ulp
operator|=
name|NULL
expr_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
name|proto
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|flags
operator|&
name|FL_HASH_ALL
operator|)
operator|==
literal|0
condition|)
goto|goto
name|skipports
goto|;
while|while
condition|(
name|ulp
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_ICMPV6
case|:
case|case
name|IPPROTO_OSPFIGP
case|:
case|case
name|IPPROTO_PIM
case|:
case|case
name|IPPROTO_CARP
case|:
case|case
name|IPPROTO_ESP
case|:
case|case
name|IPPROTO_NONE
case|:
name|ulp
operator|=
name|ip6
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
name|PULLUP_TO
argument_list|(
name|hlen
argument_list|,
name|ulp
argument_list|,
expr|struct
name|tcphdr
argument_list|)
expr_stmt|;
name|dst_port
operator|=
name|TCP
argument_list|(
name|ulp
argument_list|)
operator|->
name|th_dport
expr_stmt|;
name|src_port
operator|=
name|TCP
argument_list|(
name|ulp
argument_list|)
operator|->
name|th_sport
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|flags
operator|&
name|FL_HASH_ALL
operator|)
operator|&&
operator|(
name|TCP
argument_list|(
name|ulp
argument_list|)
operator|->
name|th_flags
operator|&
operator|(
name|TH_RST
operator||
name|TH_FIN
operator|)
operator|)
condition|)
operator|*
name|flags
operator||=
name|FL_STALE
expr_stmt|;
break|break;
case|case
name|IPPROTO_SCTP
case|:
name|PULLUP_TO
argument_list|(
name|hlen
argument_list|,
name|ulp
argument_list|,
expr|struct
name|sctphdr
argument_list|)
expr_stmt|;
name|src_port
operator|=
name|SCTP
argument_list|(
name|ulp
argument_list|)
operator|->
name|src_port
expr_stmt|;
name|dst_port
operator|=
name|SCTP
argument_list|(
name|ulp
argument_list|)
operator|->
name|dest_port
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|PULLUP_TO
argument_list|(
name|hlen
argument_list|,
name|ulp
argument_list|,
expr|struct
name|udphdr
argument_list|)
expr_stmt|;
name|dst_port
operator|=
name|UDP
argument_list|(
name|ulp
argument_list|)
operator|->
name|uh_dport
expr_stmt|;
name|src_port
operator|=
name|UDP
argument_list|(
name|ulp
argument_list|)
operator|->
name|uh_sport
expr_stmt|;
break|break;
case|case
name|IPPROTO_HOPOPTS
case|:
comment|/* RFC 2460 */
name|PULLUP_TO
argument_list|(
name|hlen
argument_list|,
name|ulp
argument_list|,
expr|struct
name|ip6_hbh
argument_list|)
expr_stmt|;
name|hlen
operator|+=
operator|(
operator|(
operator|(
expr|struct
name|ip6_hbh
operator|*
operator|)
name|ulp
operator|)
operator|->
name|ip6h_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
name|proto
operator|=
operator|(
operator|(
expr|struct
name|ip6_hbh
operator|*
operator|)
name|ulp
operator|)
operator|->
name|ip6h_nxt
expr_stmt|;
name|ulp
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|IPPROTO_ROUTING
case|:
comment|/* RFC 2460 */
name|PULLUP_TO
argument_list|(
name|hlen
argument_list|,
name|ulp
argument_list|,
expr|struct
name|ip6_rthdr
argument_list|)
expr_stmt|;
name|hlen
operator|+=
operator|(
operator|(
operator|(
expr|struct
name|ip6_rthdr
operator|*
operator|)
name|ulp
operator|)
operator|->
name|ip6r_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
name|proto
operator|=
operator|(
operator|(
expr|struct
name|ip6_rthdr
operator|*
operator|)
name|ulp
operator|)
operator|->
name|ip6r_nxt
expr_stmt|;
name|ulp
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|IPPROTO_FRAGMENT
case|:
comment|/* RFC 2460 */
name|PULLUP_TO
argument_list|(
name|hlen
argument_list|,
name|ulp
argument_list|,
expr|struct
name|ip6_frag
argument_list|)
expr_stmt|;
name|hlen
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_frag
argument_list|)
expr_stmt|;
name|proto
operator|=
operator|(
operator|(
expr|struct
name|ip6_frag
operator|*
operator|)
name|ulp
operator|)
operator|->
name|ip6f_nxt
expr_stmt|;
name|offset
operator|=
operator|(
operator|(
expr|struct
name|ip6_frag
operator|*
operator|)
name|ulp
operator|)
operator|->
name|ip6f_offlg
operator|&
name|IP6F_OFF_MASK
expr_stmt|;
name|ulp
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|IPPROTO_DSTOPTS
case|:
comment|/* RFC 2460 */
name|PULLUP_TO
argument_list|(
name|hlen
argument_list|,
name|ulp
argument_list|,
expr|struct
name|ip6_hbh
argument_list|)
expr_stmt|;
name|hlen
operator|+=
operator|(
operator|(
operator|(
expr|struct
name|ip6_hbh
operator|*
operator|)
name|ulp
operator|)
operator|->
name|ip6h_len
operator|+
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
name|proto
operator|=
operator|(
operator|(
expr|struct
name|ip6_hbh
operator|*
operator|)
name|ulp
operator|)
operator|->
name|ip6h_nxt
expr_stmt|;
name|ulp
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|IPPROTO_AH
case|:
comment|/* RFC 2402 */
name|PULLUP_TO
argument_list|(
name|hlen
argument_list|,
name|ulp
argument_list|,
expr|struct
name|ip6_ext
argument_list|)
expr_stmt|;
name|hlen
operator|+=
operator|(
operator|(
operator|(
expr|struct
name|ip6_ext
operator|*
operator|)
name|ulp
operator|)
operator|->
name|ip6e_len
operator|+
literal|2
operator|)
operator|<<
literal|2
expr_stmt|;
name|proto
operator|=
operator|(
operator|(
expr|struct
name|ip6_ext
operator|*
operator|)
name|ulp
operator|)
operator|->
name|ip6e_nxt
expr_stmt|;
name|ulp
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
name|PULLUP_TO
argument_list|(
name|hlen
argument_list|,
name|ulp
argument_list|,
expr|struct
name|ip6_ext
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|src_port
operator|==
literal|0
condition|)
block|{
name|receive_failed
label|:
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
name|skipports
label|:
name|dsin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|dsin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|dsin6
argument_list|)
expr_stmt|;
name|dsin6
operator|->
name|sin6_port
operator|=
name|dst_port
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|dsin6
operator|->
name|sin6_addr
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ssin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|ssin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ssin6
argument_list|)
expr_stmt|;
name|ssin6
operator|->
name|sin6_port
operator|=
name|src_port
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ssin6
operator|->
name|sin6_addr
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|flags
operator||=
name|proto_to_flags
argument_list|(
name|proto
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|zero_key
parameter_list|(
name|key
parameter_list|)
define|\
value|do {				\ 	key[0] = 0;		\ 	key[1] = 0;		\ 	key[2] = 0;		\ 	key[3] = 0;		\ 	key[4] = 0;		\ 	key[5] = 0;		\ 	key[6] = 0;		\ 	key[7] = 0;		\ 	key[8] = 0;		\ } while (0)
end_define

begin_function
specifier|static
name|uint32_t
name|ipv6_flow_lookup_hash
parameter_list|(
name|struct
name|sockaddr_in6
modifier|*
name|ssin6
parameter_list|,
name|struct
name|sockaddr_in6
modifier|*
name|dsin6
parameter_list|,
name|uint32_t
modifier|*
name|key
parameter_list|,
name|uint16_t
name|flags
parameter_list|)
block|{
name|uint16_t
name|sport
decl_stmt|,
name|dport
decl_stmt|;
name|uint8_t
name|proto
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
name|proto
operator|=
name|flags_to_proto
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|zero_key
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|sport
operator|=
name|dport
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dsin6
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|key
index|[
literal|1
index|]
argument_list|,
operator|&
name|dsin6
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|dport
operator|=
name|dsin6
operator|->
name|sin6_port
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ssin6
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|flags
operator|&
name|FL_HASH_ALL
operator|)
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|key
index|[
literal|5
index|]
argument_list|,
operator|&
name|ssin6
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|sport
operator|=
name|ssin6
operator|->
name|sin6_port
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|FL_HASH_ALL
condition|)
block|{
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|key
operator|)
index|[
literal|0
index|]
operator|=
name|sport
expr_stmt|;
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|key
operator|)
index|[
literal|1
index|]
operator|=
name|dport
expr_stmt|;
block|}
else|else
name|offset
operator|=
name|flow_hashjitter
operator|+
name|proto
expr_stmt|;
return|return
operator|(
name|jenkins_hash32
argument_list|(
name|key
argument_list|,
literal|9
argument_list|,
name|offset
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|flentry
modifier|*
name|flowtable_lookup_ipv6
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|sockaddr_storage
name|ssa
decl_stmt|,
name|dsa
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|dsin6
decl_stmt|,
modifier|*
name|ssin6
decl_stmt|;
name|uint16_t
name|flags
decl_stmt|;
name|dsin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|dsa
expr_stmt|;
name|ssin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ssa
expr_stmt|;
name|bzero
argument_list|(
name|dsin6
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dsin6
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ssin6
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ssin6
argument_list|)
argument_list|)
expr_stmt|;
name|flags
operator|=
name|V_ip6_ft
operator|.
name|ft_flags
expr_stmt|;
if|if
condition|(
name|ipv6_mbuf_demarshal
argument_list|(
name|m
argument_list|,
name|ssin6
argument_list|,
name|dsin6
argument_list|,
operator|&
name|flags
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|flowtable_lookup_common
argument_list|(
operator|&
name|V_ip6_ft
argument_list|,
operator|&
name|ssa
argument_list|,
operator|&
name|dsa
argument_list|,
name|m
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|flow_to_route_in6
parameter_list|(
name|struct
name|flentry
modifier|*
name|fle
parameter_list|,
name|struct
name|route_in6
modifier|*
name|ro
parameter_list|)
block|{
name|uint32_t
modifier|*
name|hashkey
init|=
name|NULL
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
expr_stmt|;
name|hashkey
operator|=
operator|(
operator|(
expr|struct
name|flentry_v6
operator|*
operator|)
name|fle
operator|)
operator|->
name|fl_flow
operator|.
name|ipf_key
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
operator|&
name|hashkey
index|[
literal|5
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|=
name|__DEVOLATILE
argument_list|(
expr|struct
name|rtentry
operator|*
argument_list|,
name|fle
operator|->
name|f_rt
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_lle
operator|=
name|__DEVOLATILE
argument_list|(
expr|struct
name|llentry
operator|*
argument_list|,
name|fle
operator|->
name|f_lle
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_flags
operator||=
name|RT_NORTREF
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_function
specifier|static
name|bitstr_t
modifier|*
name|flowtable_mask
parameter_list|(
name|struct
name|flowtable
modifier|*
name|ft
parameter_list|)
block|{
name|bitstr_t
modifier|*
name|mask
decl_stmt|;
if|if
condition|(
name|ft
operator|->
name|ft_flags
operator|&
name|FL_PCPU
condition|)
name|mask
operator|=
name|ft
operator|->
name|ft_masks
index|[
name|curcpu
index|]
expr_stmt|;
else|else
name|mask
operator|=
name|ft
operator|->
name|ft_masks
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
name|mask
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|flentry
modifier|*
modifier|*
name|flowtable_entry
parameter_list|(
name|struct
name|flowtable
modifier|*
name|ft
parameter_list|,
name|uint32_t
name|hash
parameter_list|)
block|{
name|struct
name|flentry
modifier|*
modifier|*
name|fle
decl_stmt|;
name|int
name|index
init|=
operator|(
name|hash
operator|%
name|ft
operator|->
name|ft_size
operator|)
decl_stmt|;
if|if
condition|(
name|ft
operator|->
name|ft_flags
operator|&
name|FL_PCPU
condition|)
block|{
name|KASSERT
argument_list|(
operator|&
name|ft
operator|->
name|ft_table
operator|.
name|pcpu
index|[
name|curcpu
index|]
index|[
literal|0
index|]
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pcpu not set"
operator|)
argument_list|)
expr_stmt|;
name|fle
operator|=
operator|&
name|ft
operator|->
name|ft_table
operator|.
name|pcpu
index|[
name|curcpu
index|]
index|[
name|index
index|]
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
operator|&
name|ft
operator|->
name|ft_table
operator|.
name|global
index|[
literal|0
index|]
operator|!=
name|NULL
argument_list|,
operator|(
literal|"global not set"
operator|)
argument_list|)
expr_stmt|;
name|fle
operator|=
operator|&
name|ft
operator|->
name|ft_table
operator|.
name|global
index|[
name|index
index|]
expr_stmt|;
block|}
return|return
operator|(
name|fle
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|flow_stale
parameter_list|(
name|struct
name|flowtable
modifier|*
name|ft
parameter_list|,
name|struct
name|flentry
modifier|*
name|fle
parameter_list|)
block|{
name|time_t
name|idle_time
decl_stmt|;
if|if
condition|(
operator|(
name|fle
operator|->
name|f_fhash
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|fle
operator|->
name|f_rt
operator|->
name|rt_flags
operator|&
name|RTF_HOST
operator|)
operator|&&
operator|(
operator|(
name|fle
operator|->
name|f_rt
operator|->
name|rt_flags
operator|&
operator|(
name|RTF_UP
operator|)
operator|)
operator|!=
operator|(
name|RTF_UP
operator|)
operator|)
operator|)
operator|||
operator|(
name|fle
operator|->
name|f_rt
operator|->
name|rt_ifp
operator|==
name|NULL
operator|)
operator|||
operator|!
name|RT_LINK_IS_UP
argument_list|(
name|fle
operator|->
name|f_rt
operator|->
name|rt_ifp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|idle_time
operator|=
name|time_uptime
operator|-
name|fle
operator|->
name|f_uptime
expr_stmt|;
if|if
condition|(
operator|(
name|fle
operator|->
name|f_flags
operator|&
name|FL_STALE
operator|)
operator|||
operator|(
operator|(
name|fle
operator|->
name|f_flags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_ACK
operator||
name|TH_FIN
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|idle_time
operator|>
name|ft
operator|->
name|ft_udp_idle
operator|)
operator|)
operator|||
operator|(
operator|(
name|fle
operator|->
name|f_flags
operator|&
name|TH_FIN
operator|)
operator|&&
operator|(
name|idle_time
operator|>
name|ft
operator|->
name|ft_fin_wait_idle
operator|)
operator|)
operator|||
operator|(
operator|(
name|fle
operator|->
name|f_flags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_ACK
operator|)
operator|)
operator|==
name|TH_SYN
operator|&&
operator|(
name|idle_time
operator|>
name|ft
operator|->
name|ft_syn_idle
operator|)
operator|)
operator|||
operator|(
operator|(
name|fle
operator|->
name|f_flags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_ACK
operator|)
operator|)
operator|==
operator|(
name|TH_SYN
operator||
name|TH_ACK
operator|)
operator|&&
operator|(
name|idle_time
operator|>
name|ft
operator|->
name|ft_tcp_idle
operator|)
operator|)
operator|||
operator|(
operator|(
name|fle
operator|->
name|f_rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|==
literal|0
operator|||
operator|(
name|fle
operator|->
name|f_rt
operator|->
name|rt_ifp
operator|==
name|NULL
operator|)
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|flowtable_set_hashkey
parameter_list|(
name|struct
name|flentry
modifier|*
name|fle
parameter_list|,
name|uint32_t
modifier|*
name|key
parameter_list|)
block|{
name|uint32_t
modifier|*
name|hashkey
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nwords
decl_stmt|;
if|if
condition|(
name|fle
operator|->
name|f_flags
operator|&
name|FL_IPV6
condition|)
block|{
name|nwords
operator|=
literal|9
expr_stmt|;
name|hashkey
operator|=
operator|(
operator|(
expr|struct
name|flentry_v4
operator|*
operator|)
name|fle
operator|)
operator|->
name|fl_flow
operator|.
name|ipf_key
expr_stmt|;
block|}
else|else
block|{
name|nwords
operator|=
literal|3
expr_stmt|;
name|hashkey
operator|=
operator|(
operator|(
expr|struct
name|flentry_v6
operator|*
operator|)
name|fle
operator|)
operator|->
name|fl_flow
operator|.
name|ipf_key
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
name|hashkey
index|[
name|i
index|]
operator|=
name|key
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|flow_full
parameter_list|(
name|struct
name|flowtable
modifier|*
name|ft
parameter_list|)
block|{
name|boolean_t
name|full
decl_stmt|;
name|int
name|count
decl_stmt|,
name|max
decl_stmt|;
name|full
operator|=
name|ft
operator|->
name|ft_full
expr_stmt|;
name|count
operator|=
name|uma_zone_get_cur
argument_list|(
name|ft
operator|->
name|ft_zone
argument_list|)
expr_stmt|;
name|max
operator|=
name|uma_zone_get_max
argument_list|(
name|ft
operator|->
name|ft_zone
argument_list|)
expr_stmt|;
if|if
condition|(
name|full
operator|&&
operator|(
name|count
operator|<
operator|(
name|max
operator|-
operator|(
name|max
operator|>>
literal|3
operator|)
operator|)
operator|)
condition|)
name|ft
operator|->
name|ft_full
operator|=
name|FALSE
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|full
operator|&&
operator|(
name|count
operator|>
operator|(
name|max
operator|-
operator|(
name|max
operator|>>
literal|5
operator|)
operator|)
operator|)
condition|)
name|ft
operator|->
name|ft_full
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|full
operator|&&
operator|!
name|ft
operator|->
name|ft_full
condition|)
block|{
name|flowclean_freq
operator|=
literal|4
operator|*
name|hz
expr_stmt|;
if|if
condition|(
operator|(
name|ft
operator|->
name|ft_flags
operator|&
name|FL_HASH_ALL
operator|)
operator|==
literal|0
condition|)
name|ft
operator|->
name|ft_udp_idle
operator|=
name|ft
operator|->
name|ft_fin_wait_idle
operator|=
name|ft
operator|->
name|ft_syn_idle
operator|=
name|ft
operator|->
name|ft_tcp_idle
operator|=
literal|5
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|flowclean_c_cv
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|full
operator|&&
name|ft
operator|->
name|ft_full
condition|)
block|{
name|flowclean_freq
operator|=
literal|20
operator|*
name|hz
expr_stmt|;
if|if
condition|(
operator|(
name|ft
operator|->
name|ft_flags
operator|&
name|FL_HASH_ALL
operator|)
operator|==
literal|0
condition|)
name|ft
operator|->
name|ft_udp_idle
operator|=
name|ft
operator|->
name|ft_fin_wait_idle
operator|=
name|ft
operator|->
name|ft_syn_idle
operator|=
name|ft
operator|->
name|ft_tcp_idle
operator|=
literal|30
expr_stmt|;
block|}
return|return
operator|(
name|ft
operator|->
name|ft_full
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|flowtable_insert
parameter_list|(
name|struct
name|flowtable
modifier|*
name|ft
parameter_list|,
name|uint32_t
name|hash
parameter_list|,
name|uint32_t
modifier|*
name|key
parameter_list|,
name|uint32_t
name|fibnum
parameter_list|,
name|struct
name|route
modifier|*
name|ro
parameter_list|,
name|uint16_t
name|flags
parameter_list|)
block|{
name|struct
name|flentry
modifier|*
name|fle
decl_stmt|,
modifier|*
name|fletail
decl_stmt|,
modifier|*
name|newfle
decl_stmt|,
modifier|*
modifier|*
name|flep
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|bitstr_t
modifier|*
name|mask
decl_stmt|;
name|uint8_t
name|proto
decl_stmt|;
name|newfle
operator|=
name|uma_zalloc
argument_list|(
name|ft
operator|->
name|ft_zone
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfle
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|newfle
operator|->
name|f_flags
operator||=
operator|(
name|flags
operator|&
name|FL_IPV6
operator|)
expr_stmt|;
name|proto
operator|=
name|flags_to_proto
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|FL_ENTRY_LOCK
argument_list|(
name|ft
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|mask
operator|=
name|flowtable_mask
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|flep
operator|=
name|flowtable_entry
argument_list|(
name|ft
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|fletail
operator|=
name|fle
operator|=
operator|*
name|flep
expr_stmt|;
if|if
condition|(
name|fle
operator|==
name|NULL
condition|)
block|{
name|bit_set
argument_list|(
name|mask
argument_list|,
name|FL_ENTRY_INDEX
argument_list|(
name|ft
argument_list|,
name|hash
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|flep
operator|=
name|fle
operator|=
name|newfle
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
name|depth
operator|=
literal|0
expr_stmt|;
name|FLOWSTAT_INC
argument_list|(
name|ft
argument_list|,
name|ft_collisions
argument_list|)
expr_stmt|;
comment|/* 	 * find end of list and make sure that we were not 	 * preempted by another thread handling this flow 	 */
while|while
condition|(
name|fle
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fle
operator|->
name|f_fhash
operator|==
name|hash
operator|&&
operator|!
name|flow_stale
argument_list|(
name|ft
argument_list|,
name|fle
argument_list|)
condition|)
block|{
comment|/* 			 * there was either a hash collision 			 * or we lost a race to insert 			 */
name|FL_ENTRY_UNLOCK
argument_list|(
name|ft
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|ft
operator|->
name|ft_zone
argument_list|,
name|newfle
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FL_OVERWRITE
condition|)
goto|goto
name|skip
goto|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
comment|/* 		 * re-visit this double condition XXX 		 */
if|if
condition|(
name|fletail
operator|->
name|f_next
operator|!=
name|NULL
condition|)
name|fletail
operator|=
name|fle
operator|->
name|f_next
expr_stmt|;
name|depth
operator|++
expr_stmt|;
name|fle
operator|=
name|fle
operator|->
name|f_next
expr_stmt|;
block|}
if|if
condition|(
name|depth
operator|>
name|ft
operator|->
name|ft_max_depth
condition|)
name|ft
operator|->
name|ft_max_depth
operator|=
name|depth
expr_stmt|;
name|fletail
operator|->
name|f_next
operator|=
name|newfle
expr_stmt|;
name|fle
operator|=
name|newfle
expr_stmt|;
name|skip
label|:
name|flowtable_set_hashkey
argument_list|(
name|fle
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|fle
operator|->
name|f_proto
operator|=
name|proto
expr_stmt|;
name|fle
operator|->
name|f_rt
operator|=
name|ro
operator|->
name|ro_rt
expr_stmt|;
name|fle
operator|->
name|f_lle
operator|=
name|ro
operator|->
name|ro_lle
expr_stmt|;
name|fle
operator|->
name|f_fhash
operator|=
name|hash
expr_stmt|;
name|fle
operator|->
name|f_fibnum
operator|=
name|fibnum
expr_stmt|;
name|fle
operator|->
name|f_uptime
operator|=
name|time_uptime
expr_stmt|;
name|FL_ENTRY_UNLOCK
argument_list|(
name|ft
argument_list|,
name|hash
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|flowtable_key_equal
parameter_list|(
name|struct
name|flentry
modifier|*
name|fle
parameter_list|,
name|uint32_t
modifier|*
name|key
parameter_list|)
block|{
name|uint32_t
modifier|*
name|hashkey
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nwords
decl_stmt|;
if|if
condition|(
name|fle
operator|->
name|f_flags
operator|&
name|FL_IPV6
condition|)
block|{
name|nwords
operator|=
literal|9
expr_stmt|;
name|hashkey
operator|=
operator|(
operator|(
expr|struct
name|flentry_v4
operator|*
operator|)
name|fle
operator|)
operator|->
name|fl_flow
operator|.
name|ipf_key
expr_stmt|;
block|}
else|else
block|{
name|nwords
operator|=
literal|3
expr_stmt|;
name|hashkey
operator|=
operator|(
operator|(
expr|struct
name|flentry_v6
operator|*
operator|)
name|fle
operator|)
operator|->
name|fl_flow
operator|.
name|ipf_key
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|hashkey
index|[
name|i
index|]
operator|!=
name|key
index|[
name|i
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|flentry
modifier|*
name|flowtable_lookup
parameter_list|(
name|sa_family_t
name|sa
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
switch|switch
condition|(
name|sa
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
return|return
operator|(
name|flowtable_lookup_ipv4
argument_list|(
name|m
argument_list|)
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
return|return
operator|(
name|flowtable_lookup_ipv6
argument_list|(
name|m
argument_list|)
operator|)
return|;
endif|#
directive|endif
default|default:
name|panic
argument_list|(
literal|"%s: sa %d"
argument_list|,
name|__func__
argument_list|,
name|sa
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|flentry
modifier|*
name|flowtable_lookup_common
parameter_list|(
name|struct
name|flowtable
modifier|*
name|ft
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|ssa
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|dsa
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|route_in6
name|sro6
decl_stmt|;
name|struct
name|route
name|sro
decl_stmt|,
modifier|*
name|ro
decl_stmt|;
name|struct
name|flentry
modifier|*
name|fle
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|llentry
modifier|*
name|lle
decl_stmt|;
name|struct
name|sockaddr_storage
modifier|*
name|l3addr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|uint32_t
name|key
index|[
literal|9
index|]
decl_stmt|,
name|hash
decl_stmt|,
name|fibnum
decl_stmt|;
name|uint8_t
name|proto
decl_stmt|;
if|if
condition|(
name|V_flowtable_enable
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|sro
operator|.
name|ro_rt
operator|=
name|sro6
operator|.
name|ro_rt
operator|=
name|NULL
expr_stmt|;
name|sro
operator|.
name|ro_lle
operator|=
name|sro6
operator|.
name|ro_lle
operator|=
name|NULL
expr_stmt|;
name|flags
operator||=
name|ft
operator|->
name|ft_flags
expr_stmt|;
name|proto
operator|=
name|flags_to_proto
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|fibnum
operator|=
name|M_GETFIB
argument_list|(
name|m
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ssa
operator|->
name|ss_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|sockaddr_in
modifier|*
name|ssin
decl_stmt|,
modifier|*
name|dsin
decl_stmt|;
name|KASSERT
argument_list|(
name|dsa
operator|->
name|ss_family
operator|==
name|AF_INET
argument_list|,
operator|(
literal|"%s: dsa family %d\n"
operator|,
name|__func__
operator|,
name|dsa
operator|->
name|ss_family
operator|)
argument_list|)
expr_stmt|;
name|ro
operator|=
operator|&
name|sro
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ro
operator|->
name|ro_dst
argument_list|,
name|dsa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * The harvested source and destination addresses 		 * may contain port information if the packet is 		 * from a transport protocol (e.g. TCP/UDP). The 		 * port field must be cleared before performing 		 * a route lookup. 		 */
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
operator|)
operator|->
name|sin_port
operator|=
literal|0
expr_stmt|;
name|dsin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|dsa
expr_stmt|;
name|ssin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ssa
expr_stmt|;
if|if
condition|(
operator|(
name|dsin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|ssin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|)
operator|||
operator|(
name|ntohl
argument_list|(
name|dsin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
operator|>>
name|IN_CLASSA_NSHIFT
operator|)
operator|==
name|IN_LOOPBACKNET
operator|||
operator|(
name|ntohl
argument_list|(
name|ssin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
operator|>>
name|IN_CLASSA_NSHIFT
operator|)
operator|==
name|IN_LOOPBACKNET
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|hash
operator|=
name|ipv4_flow_lookup_hash
argument_list|(
name|ssin
argument_list|,
name|dsin
argument_list|,
name|key
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
modifier|*
name|ssin6
decl_stmt|,
modifier|*
name|dsin6
decl_stmt|;
name|KASSERT
argument_list|(
name|dsa
operator|->
name|ss_family
operator|==
name|AF_INET6
argument_list|,
operator|(
literal|"%s: dsa family %d\n"
operator|,
name|__func__
operator|,
name|dsa
operator|->
name|ss_family
operator|)
argument_list|)
expr_stmt|;
name|ro
operator|=
operator|(
expr|struct
name|route
operator|*
operator|)
operator|&
name|sro6
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sro6
operator|.
name|ro_dst
argument_list|,
name|dsa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
operator|)
operator|->
name|sin6_port
operator|=
literal|0
expr_stmt|;
name|dsin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|dsa
expr_stmt|;
name|ssin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|ssa
expr_stmt|;
name|flags
operator||=
name|FL_IPV6
expr_stmt|;
name|hash
operator|=
name|ipv6_flow_lookup_hash
argument_list|(
name|ssin6
argument_list|,
name|dsin6
argument_list|,
name|key
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|panic
argument_list|(
literal|"%s: ssa family %d"
argument_list|,
name|__func__
argument_list|,
name|ssa
operator|->
name|ss_family
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Ports are zero and this isn't a transmit cache 	 * - thus not a protocol for which we need to keep 	 * state 	 * FL_HASH_ALL => key[0] != 0 for TCP || UDP || SCTP 	 */
if|if
condition|(
name|key
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
operator|(
name|ft
operator|->
name|ft_flags
operator|&
name|FL_HASH_ALL
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|FLOWSTAT_INC
argument_list|(
name|ft
argument_list|,
name|ft_lookups
argument_list|)
expr_stmt|;
name|FL_ENTRY_LOCK
argument_list|(
name|ft
argument_list|,
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fle
operator|=
name|FL_ENTRY
argument_list|(
name|ft
argument_list|,
name|hash
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|FL_ENTRY_UNLOCK
argument_list|(
name|ft
argument_list|,
name|hash
argument_list|)
expr_stmt|;
goto|goto
name|uncached
goto|;
block|}
name|keycheck
label|:
name|rt
operator|=
name|__DEVOLATILE
argument_list|(
expr|struct
name|rtentry
operator|*
argument_list|,
name|fle
operator|->
name|f_rt
argument_list|)
expr_stmt|;
name|lle
operator|=
name|__DEVOLATILE
argument_list|(
expr|struct
name|llentry
operator|*
argument_list|,
name|fle
operator|->
name|f_lle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rt
operator|!=
name|NULL
operator|)
operator|&&
name|lle
operator|!=
name|NULL
operator|&&
name|fle
operator|->
name|f_fhash
operator|==
name|hash
operator|&&
name|flowtable_key_equal
argument_list|(
name|fle
argument_list|,
name|key
argument_list|)
operator|&&
operator|(
name|proto
operator|==
name|fle
operator|->
name|f_proto
operator|)
operator|&&
operator|(
name|fibnum
operator|==
name|fle
operator|->
name|f_fibnum
operator|)
operator|&&
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|&&
operator|(
name|rt
operator|->
name|rt_ifp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|lle
operator|->
name|la_flags
operator|&
name|LLE_VALID
operator|)
condition|)
block|{
name|FLOWSTAT_INC
argument_list|(
name|ft
argument_list|,
name|ft_hits
argument_list|)
expr_stmt|;
name|fle
operator|->
name|f_uptime
operator|=
name|time_uptime
expr_stmt|;
name|fle
operator|->
name|f_flags
operator||=
name|flags
expr_stmt|;
name|FL_ENTRY_UNLOCK
argument_list|(
name|ft
argument_list|,
name|hash
argument_list|)
expr_stmt|;
goto|goto
name|success
goto|;
block|}
elseif|else
if|if
condition|(
name|fle
operator|->
name|f_next
operator|!=
name|NULL
condition|)
block|{
name|fle
operator|=
name|fle
operator|->
name|f_next
expr_stmt|;
goto|goto
name|keycheck
goto|;
block|}
name|FL_ENTRY_UNLOCK
argument_list|(
name|ft
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|uncached
label|:
if|if
condition|(
name|flags
operator|&
name|FL_NOAUTO
operator|||
name|flow_full
argument_list|(
name|ft
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|FLOWSTAT_INC
argument_list|(
name|ft
argument_list|,
name|ft_misses
argument_list|)
expr_stmt|;
comment|/* 	 * This bit of code ends up locking the 	 * same route 3 times (just like ip_output + ether_output) 	 * - at lookup 	 * - in rt_check when called by arpresolve 	 * - dropping the refcount for the rtentry 	 * 	 * This could be consolidated to one if we wrote a variant 	 * of arpresolve with an rt_check variant that expected to 	 * receive the route locked 	 */
name|ft
operator|->
name|ft_rtalloc
argument_list|(
name|ro
argument_list|,
name|hash
argument_list|,
name|fibnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|rt
operator|=
name|ro
operator|->
name|ro_rt
expr_stmt|;
name|ifp
operator|=
name|rt
operator|->
name|rt_ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_POINTOPOINT
operator||
name|IFF_LOOPBACK
operator|)
condition|)
block|{
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
switch|switch
condition|(
name|ssa
operator|->
name|ss_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
name|l3addr
operator|=
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
name|rt
operator|->
name|rt_gateway
expr_stmt|;
else|else
name|l3addr
operator|=
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
expr_stmt|;
name|lle
operator|=
name|llentry_alloc
argument_list|(
name|ifp
argument_list|,
name|LLTABLE
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|l3addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
modifier|*
name|dsin6
decl_stmt|;
name|dsin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|dsa
expr_stmt|;
if|if
condition|(
name|in6_localaddr
argument_list|(
operator|&
name|dsin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
name|l3addr
operator|=
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
name|rt
operator|->
name|rt_gateway
expr_stmt|;
else|else
name|l3addr
operator|=
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
expr_stmt|;
name|lle
operator|=
name|llentry_alloc
argument_list|(
name|ifp
argument_list|,
name|LLTABLE6
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|l3addr
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|lle
operator|==
name|NULL
condition|)
block|{
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ro
operator|->
name|ro_lle
operator|=
name|lle
expr_stmt|;
if|if
condition|(
name|flowtable_insert
argument_list|(
name|ft
argument_list|,
name|hash
argument_list|,
name|key
argument_list|,
name|fibnum
argument_list|,
name|ro
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|LLE_FREE
argument_list|(
name|lle
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|success
label|:
if|if
condition|(
name|fle
operator|!=
name|NULL
operator|&&
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_FLOWID
operator|)
operator|==
literal|0
condition|)
block|{
name|m
operator|->
name|m_flags
operator||=
name|M_FLOWID
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|fle
operator|->
name|f_fhash
expr_stmt|;
block|}
return|return
operator|(
name|fle
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * used by the bit_alloc macro  */
end_comment

begin_define
define|#
directive|define
name|calloc
parameter_list|(
name|count
parameter_list|,
name|size
parameter_list|)
value|malloc((count)*(size), M_DEVBUF, M_WAITOK|M_ZERO)
end_define

begin_function
specifier|static
name|void
name|flowtable_alloc
parameter_list|(
name|struct
name|flowtable
modifier|*
name|ft
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RADIX_MPATH
name|ft
operator|->
name|ft_rtalloc
operator|=
name|rtalloc_mpath_fib
expr_stmt|;
else|#
directive|else
name|ft
operator|->
name|ft_rtalloc
operator|=
name|rtalloc_ign_wrapper
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ft
operator|->
name|ft_flags
operator|&
name|FL_PCPU
condition|)
block|{
name|ft
operator|->
name|ft_lock
operator|=
name|flowtable_pcpu_lock
expr_stmt|;
name|ft
operator|->
name|ft_unlock
operator|=
name|flowtable_pcpu_unlock
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<=
name|mp_maxid
condition|;
name|i
operator|++
control|)
block|{
name|ft
operator|->
name|ft_table
operator|.
name|pcpu
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
name|ft
operator|->
name|ft_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|flentry
operator|*
argument_list|)
argument_list|,
name|M_RTABLE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ft
operator|->
name|ft_masks
index|[
name|i
index|]
operator|=
name|bit_alloc
argument_list|(
name|ft
operator|->
name|ft_size
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ft
operator|->
name|ft_lock_count
operator|=
literal|2
operator|*
operator|(
name|powerof2
argument_list|(
name|mp_maxid
operator|+
literal|1
argument_list|)
condition|?
operator|(
name|mp_maxid
operator|+
literal|1
operator|)
else|:
operator|(
name|fls
argument_list|(
name|mp_maxid
operator|+
literal|1
argument_list|)
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
name|ft
operator|->
name|ft_lock
operator|=
name|flowtable_global_lock
expr_stmt|;
name|ft
operator|->
name|ft_unlock
operator|=
name|flowtable_global_unlock
expr_stmt|;
name|ft
operator|->
name|ft_table
operator|.
name|global
operator|=
name|malloc
argument_list|(
name|ft
operator|->
name|ft_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|flentry
operator|*
argument_list|)
argument_list|,
name|M_RTABLE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ft
operator|->
name|ft_locks
operator|=
name|malloc
argument_list|(
name|ft
operator|->
name|ft_lock_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mtx
argument_list|)
argument_list|,
name|M_RTABLE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ft
operator|->
name|ft_lock_count
condition|;
name|i
operator|++
control|)
name|mtx_init
argument_list|(
operator|&
name|ft
operator|->
name|ft_locks
index|[
name|i
index|]
argument_list|,
literal|"flow"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_DUPOK
argument_list|)
expr_stmt|;
name|ft
operator|->
name|ft_masks
index|[
literal|0
index|]
operator|=
name|bit_alloc
argument_list|(
name|ft
operator|->
name|ft_size
argument_list|)
expr_stmt|;
block|}
name|ft
operator|->
name|ft_tmpmask
operator|=
name|bit_alloc
argument_list|(
name|ft
operator|->
name|ft_size
argument_list|)
expr_stmt|;
comment|/* 	 * In the local transmit case the table truly is 	 * just a cache - so everything is eligible for 	 * replacement after 5s of non-use 	 */
if|if
condition|(
name|ft
operator|->
name|ft_flags
operator|&
name|FL_HASH_ALL
condition|)
block|{
name|ft
operator|->
name|ft_udp_idle
operator|=
name|V_flowtable_udp_expire
expr_stmt|;
name|ft
operator|->
name|ft_syn_idle
operator|=
name|V_flowtable_syn_expire
expr_stmt|;
name|ft
operator|->
name|ft_fin_wait_idle
operator|=
name|V_flowtable_fin_wait_expire
expr_stmt|;
name|ft
operator|->
name|ft_tcp_idle
operator|=
name|V_flowtable_fin_wait_expire
expr_stmt|;
block|}
else|else
block|{
name|ft
operator|->
name|ft_udp_idle
operator|=
name|ft
operator|->
name|ft_fin_wait_idle
operator|=
name|ft
operator|->
name|ft_syn_idle
operator|=
name|ft
operator|->
name|ft_tcp_idle
operator|=
literal|30
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * The rest of the code is devoted to garbage collection of expired entries.  * It is a new additon made necessary by the switch to dynamically allocating  * flow tables.  *  */
end_comment

begin_function
specifier|static
name|void
name|fle_free
parameter_list|(
name|struct
name|flentry
modifier|*
name|fle
parameter_list|,
name|struct
name|flowtable
modifier|*
name|ft
parameter_list|)
block|{
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|llentry
modifier|*
name|lle
decl_stmt|;
name|rt
operator|=
name|__DEVOLATILE
argument_list|(
expr|struct
name|rtentry
operator|*
argument_list|,
name|fle
operator|->
name|f_rt
argument_list|)
expr_stmt|;
name|lle
operator|=
name|__DEVOLATILE
argument_list|(
expr|struct
name|llentry
operator|*
argument_list|,
name|fle
operator|->
name|f_lle
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
name|NULL
condition|)
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
if|if
condition|(
name|lle
operator|!=
name|NULL
condition|)
name|LLE_FREE
argument_list|(
name|lle
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|ft
operator|->
name|ft_zone
argument_list|,
name|fle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flowtable_free_stale
parameter_list|(
name|struct
name|flowtable
modifier|*
name|ft
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|)
block|{
name|int
name|curbit
init|=
literal|0
decl_stmt|,
name|tmpsize
decl_stmt|;
name|struct
name|flentry
modifier|*
name|fle
decl_stmt|,
modifier|*
modifier|*
name|flehead
decl_stmt|,
modifier|*
name|fleprev
decl_stmt|;
name|struct
name|flentry
modifier|*
name|flefreehead
decl_stmt|,
modifier|*
name|flefreetail
decl_stmt|,
modifier|*
name|fletmp
decl_stmt|;
name|bitstr_t
modifier|*
name|mask
decl_stmt|,
modifier|*
name|tmpmask
decl_stmt|;
name|flefreehead
operator|=
name|flefreetail
operator|=
name|NULL
expr_stmt|;
name|mask
operator|=
name|flowtable_mask
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|tmpmask
operator|=
name|ft
operator|->
name|ft_tmpmask
expr_stmt|;
name|tmpsize
operator|=
name|ft
operator|->
name|ft_size
expr_stmt|;
name|memcpy
argument_list|(
name|tmpmask
argument_list|,
name|mask
argument_list|,
name|ft
operator|->
name|ft_size
operator|/
literal|8
argument_list|)
expr_stmt|;
comment|/* 	 * XXX Note to self, bit_ffs operates at the byte level 	 * and thus adds gratuitous overhead 	 */
name|bit_ffs
argument_list|(
name|tmpmask
argument_list|,
name|ft
operator|->
name|ft_size
argument_list|,
operator|&
name|curbit
argument_list|)
expr_stmt|;
while|while
condition|(
name|curbit
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|curbit
operator|>=
name|ft
operator|->
name|ft_size
operator|||
name|curbit
operator|<
operator|-
literal|1
condition|)
block|{
name|log
argument_list|(
name|LOG_ALERT
argument_list|,
literal|"warning: bad curbit value %d \n"
argument_list|,
name|curbit
argument_list|)
expr_stmt|;
break|break;
block|}
name|FL_ENTRY_LOCK
argument_list|(
name|ft
argument_list|,
name|curbit
argument_list|)
expr_stmt|;
name|flehead
operator|=
name|flowtable_entry
argument_list|(
name|ft
argument_list|,
name|curbit
argument_list|)
expr_stmt|;
name|fle
operator|=
name|fleprev
operator|=
operator|*
name|flehead
expr_stmt|;
name|FLOWSTAT_INC
argument_list|(
name|ft
argument_list|,
name|ft_free_checks
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|fle
operator|==
name|NULL
operator|&&
name|curbit
operator|>
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ALERT
argument_list|,
literal|"warning bit=%d set, but no fle found\n"
argument_list|,
name|curbit
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
name|fle
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|__DEVOLATILE
argument_list|(
expr|struct
name|rtentry
operator|*
argument_list|,
name|fle
operator|->
name|f_rt
argument_list|)
operator|!=
name|rt
condition|)
block|{
name|fleprev
operator|=
name|fle
expr_stmt|;
name|fle
operator|=
name|fle
operator|->
name|f_next
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|flow_stale
argument_list|(
name|ft
argument_list|,
name|fle
argument_list|)
condition|)
block|{
name|fleprev
operator|=
name|fle
expr_stmt|;
name|fle
operator|=
name|fle
operator|->
name|f_next
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * delete head of the list 			 */
if|if
condition|(
name|fleprev
operator|==
operator|*
name|flehead
condition|)
block|{
name|fletmp
operator|=
name|fleprev
expr_stmt|;
if|if
condition|(
name|fle
operator|==
name|fleprev
condition|)
block|{
name|fleprev
operator|=
operator|*
name|flehead
operator|=
name|fle
operator|->
name|f_next
expr_stmt|;
block|}
else|else
name|fleprev
operator|=
operator|*
name|flehead
operator|=
name|fle
expr_stmt|;
name|fle
operator|=
name|fle
operator|->
name|f_next
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * don't advance fleprev 				 */
name|fletmp
operator|=
name|fle
expr_stmt|;
name|fleprev
operator|->
name|f_next
operator|=
name|fle
operator|->
name|f_next
expr_stmt|;
name|fle
operator|=
name|fleprev
operator|->
name|f_next
expr_stmt|;
block|}
if|if
condition|(
name|flefreehead
operator|==
name|NULL
condition|)
name|flefreehead
operator|=
name|flefreetail
operator|=
name|fletmp
expr_stmt|;
else|else
block|{
name|flefreetail
operator|->
name|f_next
operator|=
name|fletmp
expr_stmt|;
name|flefreetail
operator|=
name|fletmp
expr_stmt|;
block|}
name|fletmp
operator|->
name|f_next
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|flehead
operator|==
name|NULL
condition|)
name|bit_clear
argument_list|(
name|mask
argument_list|,
name|curbit
argument_list|)
expr_stmt|;
name|FL_ENTRY_UNLOCK
argument_list|(
name|ft
argument_list|,
name|curbit
argument_list|)
expr_stmt|;
name|bit_clear
argument_list|(
name|tmpmask
argument_list|,
name|curbit
argument_list|)
expr_stmt|;
name|tmpmask
operator|+=
operator|(
name|curbit
operator|/
literal|8
operator|)
expr_stmt|;
name|tmpsize
operator|-=
operator|(
name|curbit
operator|/
literal|8
operator|)
operator|*
literal|8
expr_stmt|;
name|bit_ffs
argument_list|(
name|tmpmask
argument_list|,
name|tmpsize
argument_list|,
operator|&
name|curbit
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|fle
operator|=
name|flefreehead
operator|)
operator|!=
name|NULL
condition|)
block|{
name|flefreehead
operator|=
name|fle
operator|->
name|f_next
expr_stmt|;
name|FLOWSTAT_INC
argument_list|(
name|ft
argument_list|,
name|ft_frees
argument_list|)
expr_stmt|;
name|fle_free
argument_list|(
name|fle
argument_list|,
name|ft
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|flowtable_route_flush
parameter_list|(
name|sa_family_t
name|sa
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|)
block|{
name|struct
name|flowtable
modifier|*
name|ft
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|sa
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|ft
operator|=
operator|&
name|V_ip4_ft
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|ft
operator|=
operator|&
name|V_ip6_ft
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|panic
argument_list|(
literal|"%s: sa %d"
argument_list|,
name|__func__
argument_list|,
name|sa
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ft
operator|->
name|ft_flags
operator|&
name|FL_PCPU
condition|)
block|{
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
if|if
condition|(
name|smp_started
operator|==
literal|1
condition|)
block|{
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_bind
argument_list|(
name|curthread
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
name|flowtable_free_stale
argument_list|(
name|ft
argument_list|,
name|rt
argument_list|)
expr_stmt|;
if|if
condition|(
name|smp_started
operator|==
literal|1
condition|)
block|{
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_unbind
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|flowtable_free_stale
argument_list|(
name|ft
argument_list|,
name|rt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|flowtable_clean_vnet
parameter_list|(
name|struct
name|flowtable
modifier|*
name|ft
parameter_list|)
block|{
if|if
condition|(
name|ft
operator|->
name|ft_flags
operator|&
name|FL_PCPU
condition|)
block|{
name|int
name|i
decl_stmt|;
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
if|if
condition|(
name|smp_started
operator|==
literal|1
condition|)
block|{
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_bind
argument_list|(
name|curthread
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
name|flowtable_free_stale
argument_list|(
name|ft
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|smp_started
operator|==
literal|1
condition|)
block|{
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_unbind
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|flowtable_free_stale
argument_list|(
name|ft
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flowtable_cleaner
parameter_list|(
name|void
parameter_list|)
block|{
name|VNET_ITERATOR_DECL
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"flowtable cleaner started\n"
argument_list|)
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|VNET_LIST_RLOCK
argument_list|()
expr_stmt|;
name|VNET_FOREACH
argument_list|(
argument|vnet_iter
argument_list|)
block|{
name|CURVNET_SET
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
name|flowtable_clean_vnet
argument_list|(
operator|&
name|V_ip4_ft
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|flowtable_clean_vnet
argument_list|(
operator|&
name|V_ip6_ft
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
name|VNET_LIST_RUNLOCK
argument_list|()
expr_stmt|;
comment|/* 		 * The 10 second interval between cleaning checks 		 * is arbitrary 		 */
name|mtx_lock
argument_list|(
operator|&
name|flowclean_lock
argument_list|)
expr_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|sched_prio
argument_list|(
name|td
argument_list|,
name|PPAUSE
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|flowclean_cycles
operator|++
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|flowclean_f_cv
argument_list|)
expr_stmt|;
name|cv_timedwait
argument_list|(
operator|&
name|flowclean_c_cv
argument_list|,
operator|&
name|flowclean_lock
argument_list|,
name|flowclean_freq
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|flowclean_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|flowtable_flush
parameter_list|(
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|uint64_t
name|start
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|flowclean_lock
argument_list|)
expr_stmt|;
name|start
operator|=
name|flowclean_cycles
expr_stmt|;
while|while
condition|(
name|start
operator|==
name|flowclean_cycles
condition|)
block|{
name|cv_broadcast
argument_list|(
operator|&
name|flowclean_c_cv
argument_list|)
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|flowclean_f_cv
argument_list|,
operator|&
name|flowclean_lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|flowclean_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|kproc_desc
name|flow_kp
init|=
block|{
literal|"flowcleaner"
block|,
name|flowtable_cleaner
block|,
operator|&
name|flowcleanerproc
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSINIT
argument_list|(
name|flowcleaner
argument_list|,
name|SI_SUB_KTHREAD_IDLE
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|kproc_start
argument_list|,
operator|&
name|flow_kp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|flowtable_get_size
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
if|if
condition|(
name|TUNABLE_INT_FETCH
argument_list|(
name|name
argument_list|,
operator|&
name|size
argument_list|)
condition|)
block|{
if|if
condition|(
name|size
operator|<
literal|256
condition|)
name|size
operator|=
literal|256
expr_stmt|;
if|if
condition|(
operator|!
name|powerof2
argument_list|(
name|size
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s must be power of 2\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|size
operator|=
literal|2048
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * round up to the next power of 2 		 */
name|size
operator|=
literal|1
operator|<<
name|fls
argument_list|(
operator|(
literal|1024
operator|+
name|maxusers
operator|*
literal|64
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|flowtable_init
parameter_list|(
specifier|const
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|flow_hashjitter
operator|=
name|arc4random
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
name|flow_ipv4_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"ip4flow"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|flentry_v4
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_CACHE
argument_list|,
name|UMA_ZONE_MAXBUCKET
argument_list|)
expr_stmt|;
name|uma_zone_set_max
argument_list|(
name|flow_ipv4_zone
argument_list|,
literal|1024
operator|+
name|maxusers
operator|*
literal|64
operator|*
name|mp_ncpus
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|flow_ipv6_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"ip6flow"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|flentry_v6
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_CACHE
argument_list|,
name|UMA_ZONE_MAXBUCKET
argument_list|)
expr_stmt|;
name|uma_zone_set_max
argument_list|(
name|flow_ipv6_zone
argument_list|,
literal|1024
operator|+
name|maxusers
operator|*
literal|64
operator|*
name|mp_ncpus
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cv_init
argument_list|(
operator|&
name|flowclean_c_cv
argument_list|,
literal|"c_flowcleanwait"
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|flowclean_f_cv
argument_list|,
literal|"f_flowcleanwait"
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|flowclean_lock
argument_list|,
literal|"flowclean lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|EVENTHANDLER_REGISTER
argument_list|(
name|ifnet_departure_event
argument_list|,
name|flowtable_flush
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|flowclean_freq
operator|=
literal|20
operator|*
name|hz
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|flowtable_init
argument_list|,
name|SI_SUB_PROTO_BEGIN
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|flowtable_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_net_flowtable
argument_list|,
name|OID_AUTO
argument_list|,
name|ip4
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Flowtable for IPv4"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UMA_MAX
argument_list|(
name|_net_flowtable_ip4
argument_list|,
name|OID_AUTO
argument_list|,
name|maxflows
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|flow_ipv4_zone
argument_list|,
literal|"Maximum number of IPv4 flows allowed"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_PCPUSTAT_DEFINE
argument_list|(
expr|struct
name|flowtable_stat
argument_list|,
name|ip4_ftstat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_PCPUSTAT_SYSINIT
argument_list|(
name|ip4_ftstat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_PCPUSTAT_SYSUNINIT
argument_list|(
name|ip4_ftstat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_VNET_PCPUSTAT
argument_list|(
name|_net_flowtable_ip4
argument_list|,
name|OID_AUTO
argument_list|,
name|stat
argument_list|,
expr|struct
name|flowtable_stat
argument_list|,
name|ip4_ftstat
argument_list|,
literal|"Flowtable statistics for IPv4 "
literal|"(struct flowtable_stat, net/flowtable.h)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|flowtable_init_vnet_v4
parameter_list|(
specifier|const
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|V_ip4_ft
operator|.
name|ft_zone
operator|=
name|flow_ipv4_zone
expr_stmt|;
name|V_ip4_ft
operator|.
name|ft_size
operator|=
name|flowtable_get_size
argument_list|(
literal|"net.flowtable.ip4.size"
argument_list|)
expr_stmt|;
name|V_ip4_ft
operator|.
name|ft_flags
operator|=
name|FL_PCPU
expr_stmt|;
name|V_ip4_ft
operator|.
name|ft_stat
operator|=
name|VNET
argument_list|(
name|ip4_ftstat
argument_list|)
expr_stmt|;
name|flowtable_alloc
argument_list|(
operator|&
name|V_ip4_ft
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|VNET_SYSINIT
argument_list|(
name|ft_vnet_v4
argument_list|,
name|SI_SUB_PROTO_IFATTACHDOMAIN
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|flowtable_init_vnet_v4
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_net_flowtable
argument_list|,
name|OID_AUTO
argument_list|,
name|ip6
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Flowtable for IPv6"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UMA_MAX
argument_list|(
name|_net_flowtable_ip6
argument_list|,
name|OID_AUTO
argument_list|,
name|maxflows
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|flow_ipv6_zone
argument_list|,
literal|"Maximum number of IPv6 flows allowed"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_PCPUSTAT_DEFINE
argument_list|(
expr|struct
name|flowtable_stat
argument_list|,
name|ip6_ftstat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_PCPUSTAT_SYSINIT
argument_list|(
name|ip6_ftstat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_PCPUSTAT_SYSUNINIT
argument_list|(
name|ip6_ftstat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_VNET_PCPUSTAT
argument_list|(
name|_net_flowtable_ip6
argument_list|,
name|OID_AUTO
argument_list|,
name|stat
argument_list|,
expr|struct
name|flowtable_stat
argument_list|,
name|ip6_ftstat
argument_list|,
literal|"Flowtable statistics for IPv6 "
literal|"(struct flowtable_stat, net/flowtable.h)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|flowtable_init_vnet_v6
parameter_list|(
specifier|const
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|V_ip6_ft
operator|.
name|ft_zone
operator|=
name|flow_ipv6_zone
expr_stmt|;
name|V_ip6_ft
operator|.
name|ft_size
operator|=
name|flowtable_get_size
argument_list|(
literal|"net.flowtable.ip6.size"
argument_list|)
expr_stmt|;
name|V_ip6_ft
operator|.
name|ft_flags
operator|=
name|FL_PCPU
expr_stmt|;
name|V_ip6_ft
operator|.
name|ft_stat
operator|=
name|VNET
argument_list|(
name|ip6_ftstat
argument_list|)
expr_stmt|;
name|flowtable_alloc
argument_list|(
operator|&
name|V_ip6_ft
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|VNET_SYSINIT
argument_list|(
name|flowtable_init_vnet_v6
argument_list|,
name|SI_SUB_PROTO_IFATTACHDOMAIN
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|flowtable_init_vnet_v6
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_function
specifier|static
name|uint32_t
modifier|*
name|flowtable_get_hashkey
parameter_list|(
name|struct
name|flentry
modifier|*
name|fle
parameter_list|)
block|{
name|uint32_t
modifier|*
name|hashkey
decl_stmt|;
if|if
condition|(
name|fle
operator|->
name|f_flags
operator|&
name|FL_IPV6
condition|)
name|hashkey
operator|=
operator|(
operator|(
expr|struct
name|flentry_v4
operator|*
operator|)
name|fle
operator|)
operator|->
name|fl_flow
operator|.
name|ipf_key
expr_stmt|;
else|else
name|hashkey
operator|=
operator|(
operator|(
expr|struct
name|flentry_v6
operator|*
operator|)
name|fle
operator|)
operator|->
name|fl_flow
operator|.
name|ipf_key
expr_stmt|;
return|return
operator|(
name|hashkey
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bitstr_t
modifier|*
name|flowtable_mask_pcpu
parameter_list|(
name|struct
name|flowtable
modifier|*
name|ft
parameter_list|,
name|int
name|cpuid
parameter_list|)
block|{
name|bitstr_t
modifier|*
name|mask
decl_stmt|;
if|if
condition|(
name|ft
operator|->
name|ft_flags
operator|&
name|FL_PCPU
condition|)
name|mask
operator|=
name|ft
operator|->
name|ft_masks
index|[
name|cpuid
index|]
expr_stmt|;
else|else
name|mask
operator|=
name|ft
operator|->
name|ft_masks
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
name|mask
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|flentry
modifier|*
modifier|*
name|flowtable_entry_pcpu
parameter_list|(
name|struct
name|flowtable
modifier|*
name|ft
parameter_list|,
name|uint32_t
name|hash
parameter_list|,
name|int
name|cpuid
parameter_list|)
block|{
name|struct
name|flentry
modifier|*
modifier|*
name|fle
decl_stmt|;
name|int
name|index
init|=
operator|(
name|hash
operator|%
name|ft
operator|->
name|ft_size
operator|)
decl_stmt|;
if|if
condition|(
name|ft
operator|->
name|ft_flags
operator|&
name|FL_PCPU
condition|)
block|{
name|fle
operator|=
operator|&
name|ft
operator|->
name|ft_table
operator|.
name|pcpu
index|[
name|cpuid
index|]
index|[
name|index
index|]
expr_stmt|;
block|}
else|else
block|{
name|fle
operator|=
operator|&
name|ft
operator|->
name|ft_table
operator|.
name|global
index|[
name|index
index|]
expr_stmt|;
block|}
return|return
operator|(
name|fle
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|flow_show
parameter_list|(
name|struct
name|flowtable
modifier|*
name|ft
parameter_list|,
name|struct
name|flentry
modifier|*
name|fle
parameter_list|)
block|{
name|int
name|idle_time
decl_stmt|;
name|int
name|rt_valid
decl_stmt|,
name|ifp_valid
decl_stmt|;
name|uint16_t
name|sport
decl_stmt|,
name|dport
decl_stmt|;
name|uint32_t
modifier|*
name|hashkey
decl_stmt|;
name|char
name|saddr
index|[
literal|4
operator|*
sizeof|sizeof
expr|"123"]
operator|,
name|daddr
index|[
literal|4
operator|*
sizeof|sizeof
expr|"123"]
expr_stmt|;
specifier|volatile
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|NULL
decl_stmt|;
name|idle_time
operator|=
call|(
name|int
call|)
argument_list|(
name|time_uptime
operator|-
name|fle
operator|->
name|f_uptime
argument_list|)
expr_stmt|;
name|rt
operator|=
name|fle
operator|->
name|f_rt
expr_stmt|;
name|rt_valid
operator|=
name|rt
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
name|rt_valid
condition|)
name|ifp
operator|=
name|rt
operator|->
name|rt_ifp
expr_stmt|;
name|ifp_valid
operator|=
name|ifp
operator|!=
name|NULL
expr_stmt|;
name|hashkey
operator|=
name|flowtable_get_hashkey
argument_list|(
name|fle
argument_list|)
expr_stmt|;
if|if
condition|(
name|fle
operator|->
name|f_flags
operator|&
name|FL_IPV6
condition|)
goto|goto
name|skipaddr
goto|;
name|inet_ntoa_r
argument_list|(
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|hashkey
index|[
literal|2
index|]
argument_list|,
name|daddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ft
operator|->
name|ft_flags
operator|&
name|FL_HASH_ALL
condition|)
block|{
name|inet_ntoa_r
argument_list|(
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|hashkey
index|[
literal|1
index|]
argument_list|,
name|saddr
argument_list|)
expr_stmt|;
name|sport
operator|=
name|ntohs
argument_list|(
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|hashkey
operator|)
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|dport
operator|=
name|ntohs
argument_list|(
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|hashkey
operator|)
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"%s:%d->%s:%d"
argument_list|,
name|saddr
argument_list|,
name|sport
argument_list|,
name|daddr
argument_list|,
name|dport
argument_list|)
expr_stmt|;
block|}
else|else
name|db_printf
argument_list|(
literal|"%s "
argument_list|,
name|daddr
argument_list|)
expr_stmt|;
name|skipaddr
label|:
if|if
condition|(
name|fle
operator|->
name|f_flags
operator|&
name|FL_STALE
condition|)
name|db_printf
argument_list|(
literal|" FL_STALE "
argument_list|)
expr_stmt|;
if|if
condition|(
name|fle
operator|->
name|f_flags
operator|&
name|FL_TCP
condition|)
name|db_printf
argument_list|(
literal|" FL_TCP "
argument_list|)
expr_stmt|;
if|if
condition|(
name|fle
operator|->
name|f_flags
operator|&
name|FL_UDP
condition|)
name|db_printf
argument_list|(
literal|" FL_UDP "
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt_valid
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
condition|)
name|db_printf
argument_list|(
literal|" RTF_UP "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifp_valid
condition|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
condition|)
name|db_printf
argument_list|(
literal|" IFF_LOOPBACK "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|db_printf
argument_list|(
literal|" IFF_UP "
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_POINTOPOINT
condition|)
name|db_printf
argument_list|(
literal|" IFF_POINTOPOINT "
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fle
operator|->
name|f_flags
operator|&
name|FL_IPV6
condition|)
name|db_printf
argument_list|(
literal|"\n\tkey=%08x:%08x:%08x%08x:%08x:%08x%08x:%08x:%08x"
argument_list|,
name|hashkey
index|[
literal|0
index|]
argument_list|,
name|hashkey
index|[
literal|1
index|]
argument_list|,
name|hashkey
index|[
literal|2
index|]
argument_list|,
name|hashkey
index|[
literal|3
index|]
argument_list|,
name|hashkey
index|[
literal|4
index|]
argument_list|,
name|hashkey
index|[
literal|5
index|]
argument_list|,
name|hashkey
index|[
literal|6
index|]
argument_list|,
name|hashkey
index|[
literal|7
index|]
argument_list|,
name|hashkey
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
else|else
name|db_printf
argument_list|(
literal|"\n\tkey=%08x:%08x:%08x "
argument_list|,
name|hashkey
index|[
literal|0
index|]
argument_list|,
name|hashkey
index|[
literal|1
index|]
argument_list|,
name|hashkey
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"hash=%08x idle_time=%03d"
literal|"\n\tfibnum=%02d rt=%p"
argument_list|,
name|fle
operator|->
name|f_fhash
argument_list|,
name|idle_time
argument_list|,
name|fle
operator|->
name|f_fibnum
argument_list|,
name|fle
operator|->
name|f_rt
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flowtable_show
parameter_list|(
name|struct
name|flowtable
modifier|*
name|ft
parameter_list|,
name|int
name|cpuid
parameter_list|)
block|{
name|int
name|curbit
init|=
literal|0
decl_stmt|;
name|struct
name|flentry
modifier|*
name|fle
decl_stmt|,
modifier|*
modifier|*
name|flehead
decl_stmt|;
name|bitstr_t
modifier|*
name|mask
decl_stmt|,
modifier|*
name|tmpmask
decl_stmt|;
if|if
condition|(
name|cpuid
operator|!=
operator|-
literal|1
condition|)
name|db_printf
argument_list|(
literal|"cpu: %d\n"
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
name|mask
operator|=
name|flowtable_mask_pcpu
argument_list|(
name|ft
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
name|tmpmask
operator|=
name|ft
operator|->
name|ft_tmpmask
expr_stmt|;
name|memcpy
argument_list|(
name|tmpmask
argument_list|,
name|mask
argument_list|,
name|ft
operator|->
name|ft_size
operator|/
literal|8
argument_list|)
expr_stmt|;
comment|/* 	 * XXX Note to self, bit_ffs operates at the byte level 	 * and thus adds gratuitous overhead 	 */
name|bit_ffs
argument_list|(
name|tmpmask
argument_list|,
name|ft
operator|->
name|ft_size
argument_list|,
operator|&
name|curbit
argument_list|)
expr_stmt|;
while|while
condition|(
name|curbit
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|curbit
operator|>=
name|ft
operator|->
name|ft_size
operator|||
name|curbit
operator|<
operator|-
literal|1
condition|)
block|{
name|db_printf
argument_list|(
literal|"warning: bad curbit value %d \n"
argument_list|,
name|curbit
argument_list|)
expr_stmt|;
break|break;
block|}
name|flehead
operator|=
name|flowtable_entry_pcpu
argument_list|(
name|ft
argument_list|,
name|curbit
argument_list|,
name|cpuid
argument_list|)
expr_stmt|;
name|fle
operator|=
operator|*
name|flehead
expr_stmt|;
while|while
condition|(
name|fle
operator|!=
name|NULL
condition|)
block|{
name|flow_show
argument_list|(
name|ft
argument_list|,
name|fle
argument_list|)
expr_stmt|;
name|fle
operator|=
name|fle
operator|->
name|f_next
expr_stmt|;
continue|continue;
block|}
name|bit_clear
argument_list|(
name|tmpmask
argument_list|,
name|curbit
argument_list|)
expr_stmt|;
name|bit_ffs
argument_list|(
name|tmpmask
argument_list|,
name|ft
operator|->
name|ft_size
argument_list|,
operator|&
name|curbit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|flowtable_show_vnet
parameter_list|(
name|struct
name|flowtable
modifier|*
name|ft
parameter_list|)
block|{
if|if
condition|(
name|ft
operator|->
name|ft_flags
operator|&
name|FL_PCPU
condition|)
block|{
name|int
name|i
decl_stmt|;
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
name|flowtable_show
argument_list|(
name|ft
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|flowtable_show
argument_list|(
name|ft
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|flowtables
argument_list|,
argument|db_show_flowtables
argument_list|)
end_macro

begin_block
block|{
name|VNET_ITERATOR_DECL
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|VNET_FOREACH
argument_list|(
argument|vnet_iter
argument_list|)
block|{
name|CURVNET_SET
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VIMAGE
name|db_printf
argument_list|(
literal|"vnet %p\n"
argument_list|,
name|vnet_iter
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
name|printf
argument_list|(
literal|"IPv4:\n"
argument_list|)
expr_stmt|;
name|flowtable_show_vnet
argument_list|(
operator|&
name|V_ip4_ft
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|printf
argument_list|(
literal|"IPv6:\n"
argument_list|)
expr_stmt|;
name|flowtable_show_vnet
argument_list|(
operator|&
name|V_ip6_ft
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

