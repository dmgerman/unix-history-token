begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**************************************************************************  Copyright (c) 2008-2009, BitGravity Inc. All rights reserved.  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:   1. Redistributions of source code must retain the above copyright notice,     this list of conditions and the following disclaimer.   2. Neither the name of the BitGravity Corporation nor the names of its     contributors may be used to endorse or promote products derived from     this software without specific prior written permission.  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"opt_route.h"
end_include

begin_include
include|#
directive|include
file|"opt_mpath.h"
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_FLOWTABLE
end_ifndef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/bitstring.h>
end_include

begin_include
include|#
directive|include
file|<sys/callout.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vimage.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llatbl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<net/flowtable.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp.h>
end_include

begin_include
include|#
directive|include
file|<libkern/jenkins.h>
end_include

begin_struct
struct|struct
name|ipv4_tuple
block|{
name|uint16_t
name|ip_sport
decl_stmt|;
comment|/* source port */
name|uint16_t
name|ip_dport
decl_stmt|;
comment|/* destination port */
name|in_addr_t
name|ip_saddr
decl_stmt|;
comment|/* source address */
name|in_addr_t
name|ip_daddr
decl_stmt|;
comment|/* destination address */
block|}
struct|;
end_struct

begin_union
union|union
name|ipv4_flow
block|{
name|struct
name|ipv4_tuple
name|ipf_ipt
decl_stmt|;
name|uint32_t
name|ipf_key
index|[
literal|3
index|]
decl_stmt|;
block|}
union|;
end_union

begin_struct
struct|struct
name|ipv6_tuple
block|{
name|uint16_t
name|ip_sport
decl_stmt|;
comment|/* source port */
name|uint16_t
name|ip_dport
decl_stmt|;
comment|/* destination port */
name|struct
name|in6_addr
name|ip_saddr
decl_stmt|;
comment|/* source address */
name|struct
name|in6_addr
name|ip_daddr
decl_stmt|;
comment|/* destination address */
block|}
struct|;
end_struct

begin_union
union|union
name|ipv6_flow
block|{
name|struct
name|ipv6_tuple
name|ipf_ipt
decl_stmt|;
name|uint32_t
name|ipf_key
index|[
literal|9
index|]
decl_stmt|;
block|}
union|;
end_union

begin_struct
struct|struct
name|flentry
block|{
specifier|volatile
name|uint32_t
name|f_fhash
decl_stmt|;
comment|/* hash flowing forward */
name|uint16_t
name|f_flags
decl_stmt|;
comment|/* flow flags */
name|uint8_t
name|f_pad
decl_stmt|;
comment|/* alignment */
name|uint8_t
name|f_proto
decl_stmt|;
comment|/* protocol */
name|uint32_t
name|f_uptime
decl_stmt|;
comment|/* uptime at last access */
name|struct
name|flentry
modifier|*
name|f_next
decl_stmt|;
comment|/* pointer to collision entry */
specifier|volatile
name|struct
name|rtentry
modifier|*
name|f_rt
decl_stmt|;
comment|/* rtentry for flow */
specifier|volatile
name|struct
name|llentry
modifier|*
name|f_lle
decl_stmt|;
comment|/* llentry for flow */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|flentry_v4
block|{
name|struct
name|flentry
name|fl_entry
decl_stmt|;
name|union
name|ipv4_flow
name|fl_flow
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|flentry_v6
block|{
name|struct
name|flentry
name|fl_entry
decl_stmt|;
name|union
name|ipv6_flow
name|fl_flow
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|fl_fhash
value|fl_entry.fl_fhash
end_define

begin_define
define|#
directive|define
name|fl_flags
value|fl_entry.fl_flags
end_define

begin_define
define|#
directive|define
name|fl_proto
value|fl_entry.fl_proto
end_define

begin_define
define|#
directive|define
name|fl_uptime
value|fl_entry.fl_uptime
end_define

begin_define
define|#
directive|define
name|fl_rt
value|fl_entry.fl_rt
end_define

begin_define
define|#
directive|define
name|fl_lle
value|fl_entry.fl_lle
end_define

begin_define
define|#
directive|define
name|SECS_PER_HOUR
value|3600
end_define

begin_define
define|#
directive|define
name|SECS_PER_DAY
value|(24*SECS_PER_HOUR)
end_define

begin_define
define|#
directive|define
name|SYN_IDLE
value|300
end_define

begin_define
define|#
directive|define
name|UDP_IDLE
value|300
end_define

begin_define
define|#
directive|define
name|FIN_WAIT_IDLE
value|600
end_define

begin_define
define|#
directive|define
name|TCP_IDLE
value|SECS_PER_DAY
end_define

begin_typedef
typedef|typedef
name|void
name|fl_lock_t
parameter_list|(
name|struct
name|flowtable
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_typedef

begin_typedef
typedef|typedef
name|void
name|fl_rtalloc_t
parameter_list|(
name|struct
name|route
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_typedef

begin_union
union|union
name|flentryp
block|{
name|struct
name|flentry
modifier|*
modifier|*
name|global
decl_stmt|;
name|struct
name|flentry
modifier|*
modifier|*
name|pcpu
index|[
name|MAXCPU
index|]
decl_stmt|;
block|}
union|;
end_union

begin_struct
struct|struct
name|flowtable
block|{
name|int
name|ft_size
decl_stmt|;
name|int
name|ft_lock_count
decl_stmt|;
name|uint32_t
name|ft_flags
decl_stmt|;
name|uint32_t
name|ft_collisions
decl_stmt|;
name|uint32_t
name|ft_allocated
decl_stmt|;
name|uint32_t
name|ft_misses
decl_stmt|;
name|uint64_t
name|ft_hits
decl_stmt|;
name|uint32_t
name|ft_udp_idle
decl_stmt|;
name|uint32_t
name|ft_fin_wait_idle
decl_stmt|;
name|uint32_t
name|ft_syn_idle
decl_stmt|;
name|uint32_t
name|ft_tcp_idle
decl_stmt|;
name|fl_lock_t
modifier|*
name|ft_lock
decl_stmt|;
name|fl_lock_t
modifier|*
name|ft_unlock
decl_stmt|;
name|fl_rtalloc_t
modifier|*
name|ft_rtalloc
decl_stmt|;
name|struct
name|mtx
modifier|*
name|ft_locks
decl_stmt|;
name|union
name|flentryp
name|ft_table
decl_stmt|;
name|bitstr_t
modifier|*
name|ft_masks
index|[
name|MAXCPU
index|]
decl_stmt|;
name|bitstr_t
modifier|*
name|ft_tmpmask
decl_stmt|;
name|struct
name|flowtable
modifier|*
name|ft_next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|proc
modifier|*
name|flowcleanerproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|flowtable
modifier|*
name|flow_list_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|hashjitter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|ipv4_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uma_zone_t
name|ipv6_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * TODO:  * - Make flowtable stats per-cpu, aggregated at sysctl call time,  *   to avoid extra cache evictions caused by incrementing a shared  *   counter  * - add IPv6 support to flow lookup  * - add sysctls to resize&& flush flow tables   * - Add per flowtable sysctls for statistics and configuring timeouts  * - add saturation counter to rtentry to support per-packet load-balancing  *   add flag to indicate round-robin flow, add list lookup from head      for flows  * - add sysctl / device node / syscall to support exporting and importing  *   of flows with flag to indicate that a flow was imported so should  *   not be considered for auto-cleaning  * - support explicit connection state (currently only ad-hoc for DSR)  */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_inet
argument_list|,
name|OID_AUTO
argument_list|,
name|flowtable
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"flowtable"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|flowtable_enable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_flowtable
argument_list|,
name|OID_AUTO
argument_list|,
name|enable
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|flowtable_enable
argument_list|,
literal|0
argument_list|,
literal|"enable flowtable caching."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|flowtable_hits
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_flowtable
argument_list|,
name|OID_AUTO
argument_list|,
name|hits
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|flowtable_hits
argument_list|,
literal|0
argument_list|,
literal|"# flowtable hits."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|flowtable_lookups
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_flowtable
argument_list|,
name|OID_AUTO
argument_list|,
name|lookups
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|flowtable_lookups
argument_list|,
literal|0
argument_list|,
literal|"# flowtable lookups."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|flowtable_misses
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_flowtable
argument_list|,
name|OID_AUTO
argument_list|,
name|misses
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|flowtable_misses
argument_list|,
literal|0
argument_list|,
literal|"#flowtable misses."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|flowtable_frees
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_flowtable
argument_list|,
name|OID_AUTO
argument_list|,
name|frees
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|flowtable_frees
argument_list|,
literal|0
argument_list|,
literal|"#flows freed."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|flowtable_free_checks
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_flowtable
argument_list|,
name|OID_AUTO
argument_list|,
name|free_checks
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|flowtable_free_checks
argument_list|,
literal|0
argument_list|,
literal|"#flows free checks."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|flowtable_max_depth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_flowtable
argument_list|,
name|OID_AUTO
argument_list|,
name|max_depth
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|flowtable_max_depth
argument_list|,
literal|0
argument_list|,
literal|"max collision list length."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|flowtable_collisions
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_flowtable
argument_list|,
name|OID_AUTO
argument_list|,
name|collisions
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|flowtable_collisions
argument_list|,
literal|0
argument_list|,
literal|"#flowtable collisions."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * XXX This does not end up updating timeouts at runtime  * and only reflects the value for the last table added :-/  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|flowtable_syn_expire
init|=
name|SYN_IDLE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_flowtable
argument_list|,
name|OID_AUTO
argument_list|,
name|syn_expire
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|flowtable_syn_expire
argument_list|,
literal|0
argument_list|,
literal|"seconds after which to remove syn allocated flow."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|flowtable_udp_expire
init|=
name|UDP_IDLE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_flowtable
argument_list|,
name|OID_AUTO
argument_list|,
name|udp_expire
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|flowtable_udp_expire
argument_list|,
literal|0
argument_list|,
literal|"seconds after which to remove flow allocated to UDP."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|flowtable_fin_wait_expire
init|=
name|FIN_WAIT_IDLE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_flowtable
argument_list|,
name|OID_AUTO
argument_list|,
name|fin_wait_expire
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|flowtable_fin_wait_expire
argument_list|,
literal|0
argument_list|,
literal|"seconds after which to remove a flow in FIN_WAIT."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|flowtable_tcp_expire
init|=
name|TCP_IDLE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_flowtable
argument_list|,
name|OID_AUTO
argument_list|,
name|tcp_expire
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|flowtable_tcp_expire
argument_list|,
literal|0
argument_list|,
literal|"seconds after which to remove flow allocated to a TCP connection."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Maximum number of flows that can be allocated of a given type.  *  * The table is allocated at boot time (for the pure caching case  * there is no reason why this could not be changed at runtime)  * and thus (currently) needs to be set with a tunable.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nmbflows
init|=
literal|4096
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|sysctl_nmbflows
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|newnmbflows
decl_stmt|;
name|newnmbflows
operator|=
name|nmbflows
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|newnmbflows
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
condition|)
block|{
if|if
condition|(
name|newnmbflows
operator|>
name|nmbflows
condition|)
block|{
name|nmbflows
operator|=
name|newnmbflows
expr_stmt|;
name|uma_zone_set_max
argument_list|(
name|ipv4_zone
argument_list|,
name|nmbflows
argument_list|)
expr_stmt|;
name|uma_zone_set_max
argument_list|(
name|ipv6_zone
argument_list|,
name|nmbflows
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_flowtable
argument_list|,
name|OID_AUTO
argument_list|,
name|nmbflows
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|nmbflows
argument_list|,
literal|0
argument_list|,
name|sysctl_nmbflows
argument_list|,
literal|"IU"
argument_list|,
literal|"Maximum number of flows allowed"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|RADIX_MPATH
end_ifndef

begin_function
specifier|static
name|void
name|in_rtalloc_ign_wrapper
parameter_list|(
name|struct
name|route
modifier|*
name|ro
parameter_list|,
name|uint32_t
name|hash
parameter_list|,
name|u_int
name|fib
parameter_list|)
block|{
name|rtalloc_ign_fib
argument_list|(
name|ro
argument_list|,
literal|0
argument_list|,
name|fib
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|flowtable_global_lock
parameter_list|(
name|struct
name|flowtable
modifier|*
name|table
parameter_list|,
name|uint32_t
name|hash
parameter_list|)
block|{
name|int
name|lock_index
init|=
operator|(
name|hash
operator|)
operator|&
operator|(
name|table
operator|->
name|ft_lock_count
operator|-
literal|1
operator|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|table
operator|->
name|ft_locks
index|[
name|lock_index
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flowtable_global_unlock
parameter_list|(
name|struct
name|flowtable
modifier|*
name|table
parameter_list|,
name|uint32_t
name|hash
parameter_list|)
block|{
name|int
name|lock_index
init|=
operator|(
name|hash
operator|)
operator|&
operator|(
name|table
operator|->
name|ft_lock_count
operator|-
literal|1
operator|)
decl_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|table
operator|->
name|ft_locks
index|[
name|lock_index
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flowtable_pcpu_lock
parameter_list|(
name|struct
name|flowtable
modifier|*
name|table
parameter_list|,
name|uint32_t
name|hash
parameter_list|)
block|{
name|critical_enter
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flowtable_pcpu_unlock
parameter_list|(
name|struct
name|flowtable
modifier|*
name|table
parameter_list|,
name|uint32_t
name|hash
parameter_list|)
block|{
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|FL_ENTRY_INDEX
parameter_list|(
name|table
parameter_list|,
name|hash
parameter_list|)
value|((hash) % (table)->ft_size)
end_define

begin_define
define|#
directive|define
name|FL_ENTRY
parameter_list|(
name|table
parameter_list|,
name|hash
parameter_list|)
value|*flowtable_entry((table), (hash))
end_define

begin_define
define|#
directive|define
name|FL_ENTRY_LOCK
parameter_list|(
name|table
parameter_list|,
name|hash
parameter_list|)
value|(table)->ft_lock((table), (hash))
end_define

begin_define
define|#
directive|define
name|FL_ENTRY_UNLOCK
parameter_list|(
name|table
parameter_list|,
name|hash
parameter_list|)
value|(table)->ft_unlock((table), (hash))
end_define

begin_define
define|#
directive|define
name|FL_STALE
value|(1<<8)
end_define

begin_define
define|#
directive|define
name|FL_IPV6
value|(1<<9)
end_define

begin_function
specifier|static
name|uint32_t
name|ipv4_flow_lookup_hash_internal
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|route
modifier|*
name|ro
parameter_list|,
name|uint32_t
modifier|*
name|key
parameter_list|,
name|uint16_t
modifier|*
name|flags
parameter_list|,
name|uint8_t
modifier|*
name|protop
parameter_list|)
block|{
name|uint16_t
name|sport
init|=
literal|0
decl_stmt|,
name|dport
init|=
literal|0
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|uint8_t
name|proto
init|=
literal|0
decl_stmt|;
name|int
name|iphlen
decl_stmt|;
name|uint32_t
name|hash
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|uh
decl_stmt|;
name|struct
name|sctphdr
modifier|*
name|sh
decl_stmt|;
if|if
condition|(
name|flowtable_enable
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|key
index|[
literal|1
index|]
operator|=
name|key
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
block|}
else|else
operator|*
name|flags
operator|&=
operator|~
name|FL_HASH_PORTS
expr_stmt|;
name|key
index|[
literal|2
index|]
operator|=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|flags
operator|&
name|FL_HASH_PORTS
operator|)
operator|==
literal|0
condition|)
goto|goto
name|skipports
goto|;
name|proto
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|iphlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
comment|/* XXX options? */
name|key
index|[
literal|1
index|]
operator|=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|iphlen
operator|)
expr_stmt|;
name|sport
operator|=
name|ntohs
argument_list|(
name|th
operator|->
name|th_sport
argument_list|)
expr_stmt|;
name|dport
operator|=
name|ntohs
argument_list|(
name|th
operator|->
name|th_dport
argument_list|)
expr_stmt|;
operator|*
name|flags
operator||=
name|th
operator|->
name|th_flags
expr_stmt|;
if|if
condition|(
operator|*
name|flags
operator|&
name|TH_RST
condition|)
operator|*
name|flags
operator||=
name|FL_STALE
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDP
case|:
name|uh
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|iphlen
operator|)
expr_stmt|;
name|sport
operator|=
name|uh
operator|->
name|uh_sport
expr_stmt|;
name|dport
operator|=
name|uh
operator|->
name|uh_dport
expr_stmt|;
break|break;
case|case
name|IPPROTO_SCTP
case|:
name|sh
operator|=
operator|(
expr|struct
name|sctphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|iphlen
operator|)
expr_stmt|;
name|sport
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|dport
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|*
name|flags
operator|&
name|FL_HASH_PORTS
condition|)
goto|goto
name|noop
goto|;
comment|/* no port - hence not a protocol we care about */
break|break;
empty_stmt|;
block|}
operator|*
name|protop
operator|=
name|proto
expr_stmt|;
comment|/* 	 * If this is a transmit route cache then  	 * hash all flows to a given destination to 	 * the same bucket 	 */
if|if
condition|(
operator|(
operator|*
name|flags
operator|&
name|FL_HASH_PORTS
operator|)
operator|==
literal|0
condition|)
name|proto
operator|=
name|sport
operator|=
name|dport
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|key
operator|)
index|[
literal|0
index|]
operator|=
name|sport
expr_stmt|;
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|key
operator|)
index|[
literal|1
index|]
operator|=
name|dport
expr_stmt|;
name|skipports
label|:
name|hash
operator|=
name|jenkins_hashword
argument_list|(
name|key
argument_list|,
literal|3
argument_list|,
name|hashjitter
operator|+
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
operator|&&
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_FLOWID
operator|)
operator|==
literal|0
condition|)
block|{
name|m
operator|->
name|m_flags
operator||=
name|M_FLOWID
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|hash
expr_stmt|;
block|}
return|return
operator|(
name|hash
operator|)
return|;
name|noop
label|:
operator|*
name|protop
operator|=
name|proto
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bitstr_t
modifier|*
name|flowtable_mask
parameter_list|(
name|struct
name|flowtable
modifier|*
name|ft
parameter_list|)
block|{
name|bitstr_t
modifier|*
name|mask
decl_stmt|;
if|if
condition|(
name|ft
operator|->
name|ft_flags
operator|&
name|FL_PCPU
condition|)
name|mask
operator|=
name|ft
operator|->
name|ft_masks
index|[
name|curcpu
index|]
expr_stmt|;
else|else
name|mask
operator|=
name|ft
operator|->
name|ft_masks
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
name|mask
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|flentry
modifier|*
modifier|*
name|flowtable_entry
parameter_list|(
name|struct
name|flowtable
modifier|*
name|ft
parameter_list|,
name|uint32_t
name|hash
parameter_list|)
block|{
name|struct
name|flentry
modifier|*
modifier|*
name|fle
decl_stmt|;
name|int
name|index
init|=
operator|(
name|hash
operator|%
name|ft
operator|->
name|ft_size
operator|)
decl_stmt|;
if|if
condition|(
name|ft
operator|->
name|ft_flags
operator|&
name|FL_PCPU
condition|)
block|{
name|KASSERT
argument_list|(
operator|&
name|ft
operator|->
name|ft_table
operator|.
name|pcpu
index|[
name|curcpu
index|]
index|[
literal|0
index|]
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pcpu not set"
operator|)
argument_list|)
expr_stmt|;
name|fle
operator|=
operator|&
name|ft
operator|->
name|ft_table
operator|.
name|pcpu
index|[
name|curcpu
index|]
index|[
name|index
index|]
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
operator|&
name|ft
operator|->
name|ft_table
operator|.
name|global
index|[
literal|0
index|]
operator|!=
name|NULL
argument_list|,
operator|(
literal|"global not set"
operator|)
argument_list|)
expr_stmt|;
name|fle
operator|=
operator|&
name|ft
operator|->
name|ft_table
operator|.
name|global
index|[
name|index
index|]
expr_stmt|;
block|}
return|return
operator|(
name|fle
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|flow_stale
parameter_list|(
name|struct
name|flowtable
modifier|*
name|ft
parameter_list|,
name|struct
name|flentry
modifier|*
name|fle
parameter_list|)
block|{
name|time_t
name|idle_time
decl_stmt|;
if|if
condition|(
operator|(
name|fle
operator|->
name|f_fhash
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|fle
operator|->
name|f_rt
operator|->
name|rt_flags
operator|&
name|RTF_HOST
operator|)
operator|&&
operator|(
operator|(
name|fle
operator|->
name|f_rt
operator|->
name|rt_flags
operator|&
operator|(
name|RTF_UP
operator|)
operator|)
operator|!=
operator|(
name|RTF_UP
operator|)
operator|)
operator|)
operator|||
operator|(
name|fle
operator|->
name|f_rt
operator|->
name|rt_ifp
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|idle_time
operator|=
name|time_uptime
operator|-
name|fle
operator|->
name|f_uptime
expr_stmt|;
if|if
condition|(
operator|(
name|fle
operator|->
name|f_flags
operator|&
name|FL_STALE
operator|)
operator|||
operator|(
operator|(
name|fle
operator|->
name|f_flags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_ACK
operator||
name|TH_FIN
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|idle_time
operator|>
name|ft
operator|->
name|ft_udp_idle
operator|)
operator|)
operator|||
operator|(
operator|(
name|fle
operator|->
name|f_flags
operator|&
name|TH_FIN
operator|)
operator|&&
operator|(
name|idle_time
operator|>
name|ft
operator|->
name|ft_fin_wait_idle
operator|)
operator|)
operator|||
operator|(
operator|(
name|fle
operator|->
name|f_flags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_ACK
operator|)
operator|)
operator|==
name|TH_SYN
operator|&&
operator|(
name|idle_time
operator|>
name|ft
operator|->
name|ft_syn_idle
operator|)
operator|)
operator|||
operator|(
operator|(
name|fle
operator|->
name|f_flags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_ACK
operator|)
operator|)
operator|==
operator|(
name|TH_SYN
operator||
name|TH_ACK
operator|)
operator|&&
operator|(
name|idle_time
operator|>
name|ft
operator|->
name|ft_tcp_idle
operator|)
operator|)
operator|||
operator|(
operator|(
name|fle
operator|->
name|f_rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|==
literal|0
operator|||
operator|(
name|fle
operator|->
name|f_rt
operator|->
name|rt_ifp
operator|==
name|NULL
operator|)
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|flowtable_set_hashkey
parameter_list|(
name|struct
name|flentry
modifier|*
name|fle
parameter_list|,
name|uint32_t
modifier|*
name|key
parameter_list|)
block|{
name|uint32_t
modifier|*
name|hashkey
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nwords
decl_stmt|;
if|if
condition|(
name|fle
operator|->
name|f_flags
operator|&
name|FL_IPV6
condition|)
block|{
name|nwords
operator|=
literal|9
expr_stmt|;
name|hashkey
operator|=
operator|(
operator|(
expr|struct
name|flentry_v4
operator|*
operator|)
name|fle
operator|)
operator|->
name|fl_flow
operator|.
name|ipf_key
expr_stmt|;
block|}
else|else
block|{
name|nwords
operator|=
literal|3
expr_stmt|;
name|hashkey
operator|=
operator|(
operator|(
expr|struct
name|flentry_v6
operator|*
operator|)
name|fle
operator|)
operator|->
name|fl_flow
operator|.
name|ipf_key
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
name|hashkey
index|[
name|i
index|]
operator|=
name|key
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|flowtable_insert
parameter_list|(
name|struct
name|flowtable
modifier|*
name|ft
parameter_list|,
name|uint32_t
name|hash
parameter_list|,
name|uint32_t
modifier|*
name|key
parameter_list|,
name|uint8_t
name|proto
parameter_list|,
name|struct
name|route
modifier|*
name|ro
parameter_list|,
name|uint16_t
name|flags
parameter_list|)
block|{
name|struct
name|flentry
modifier|*
name|fle
decl_stmt|,
modifier|*
name|fletail
decl_stmt|,
modifier|*
name|newfle
decl_stmt|,
modifier|*
modifier|*
name|flep
decl_stmt|;
name|int
name|depth
decl_stmt|;
name|uma_zone_t
name|flezone
decl_stmt|;
name|bitstr_t
modifier|*
name|mask
decl_stmt|;
name|flezone
operator|=
operator|(
name|flags
operator|&
name|FL_IPV6
operator|)
condition|?
name|ipv6_zone
else|:
name|ipv4_zone
expr_stmt|;
name|newfle
operator|=
name|uma_zalloc
argument_list|(
name|flezone
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|newfle
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|newfle
operator|->
name|f_flags
operator||=
operator|(
name|flags
operator|&
name|FL_IPV6
operator|)
expr_stmt|;
name|FL_ENTRY_LOCK
argument_list|(
name|ft
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|mask
operator|=
name|flowtable_mask
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|flep
operator|=
name|flowtable_entry
argument_list|(
name|ft
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|fletail
operator|=
name|fle
operator|=
operator|*
name|flep
expr_stmt|;
if|if
condition|(
name|fle
operator|==
name|NULL
condition|)
block|{
name|bit_set
argument_list|(
name|mask
argument_list|,
name|FL_ENTRY_INDEX
argument_list|(
name|ft
argument_list|,
name|hash
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|flep
operator|=
name|fle
operator|=
name|newfle
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
name|depth
operator|=
literal|0
expr_stmt|;
name|flowtable_collisions
operator|++
expr_stmt|;
comment|/* 	 * find end of list and make sure that we were not 	 * preempted by another thread handling this flow 	 */
while|while
condition|(
name|fle
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fle
operator|->
name|f_fhash
operator|==
name|hash
operator|&&
operator|!
name|flow_stale
argument_list|(
name|ft
argument_list|,
name|fle
argument_list|)
condition|)
block|{
comment|/* 			 * there was either a hash collision 			 * or we lost a race to insert 			 */
name|FL_ENTRY_UNLOCK
argument_list|(
name|ft
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
operator|(
name|newfle
operator|->
name|f_flags
operator|&
name|FL_IPV6
operator|)
condition|?
name|ipv6_zone
else|:
name|ipv4_zone
argument_list|,
name|newfle
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
comment|/* 		 * re-visit this double condition XXX 		 */
if|if
condition|(
name|fletail
operator|->
name|f_next
operator|!=
name|NULL
condition|)
name|fletail
operator|=
name|fle
operator|->
name|f_next
expr_stmt|;
name|depth
operator|++
expr_stmt|;
name|fle
operator|=
name|fle
operator|->
name|f_next
expr_stmt|;
block|}
if|if
condition|(
name|depth
operator|>
name|flowtable_max_depth
condition|)
name|flowtable_max_depth
operator|=
name|depth
expr_stmt|;
name|fletail
operator|->
name|f_next
operator|=
name|newfle
expr_stmt|;
name|fle
operator|=
name|newfle
expr_stmt|;
name|skip
label|:
name|flowtable_set_hashkey
argument_list|(
name|fle
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|fle
operator|->
name|f_proto
operator|=
name|proto
expr_stmt|;
name|fle
operator|->
name|f_rt
operator|=
name|ro
operator|->
name|ro_rt
expr_stmt|;
name|fle
operator|->
name|f_lle
operator|=
name|ro
operator|->
name|ro_lle
expr_stmt|;
name|fle
operator|->
name|f_fhash
operator|=
name|hash
expr_stmt|;
name|fle
operator|->
name|f_uptime
operator|=
name|time_uptime
expr_stmt|;
name|FL_ENTRY_UNLOCK
argument_list|(
name|ft
argument_list|,
name|hash
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|flowtable_key_equal
parameter_list|(
name|struct
name|flentry
modifier|*
name|fle
parameter_list|,
name|uint32_t
modifier|*
name|key
parameter_list|)
block|{
name|uint32_t
modifier|*
name|hashkey
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nwords
decl_stmt|;
if|if
condition|(
name|fle
operator|->
name|f_flags
operator|&
name|FL_IPV6
condition|)
block|{
name|nwords
operator|=
literal|9
expr_stmt|;
name|hashkey
operator|=
operator|(
operator|(
expr|struct
name|flentry_v4
operator|*
operator|)
name|fle
operator|)
operator|->
name|fl_flow
operator|.
name|ipf_key
expr_stmt|;
block|}
else|else
block|{
name|nwords
operator|=
literal|3
expr_stmt|;
name|hashkey
operator|=
operator|(
operator|(
expr|struct
name|flentry_v6
operator|*
operator|)
name|fle
operator|)
operator|->
name|fl_flow
operator|.
name|ipf_key
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nwords
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|hashkey
index|[
name|i
index|]
operator|!=
name|key
index|[
name|i
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|flowtable_lookup
parameter_list|(
name|struct
name|flowtable
modifier|*
name|ft
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|route
modifier|*
name|ro
parameter_list|)
block|{
name|uint32_t
name|key
index|[
literal|9
index|]
decl_stmt|,
name|hash
decl_stmt|;
name|struct
name|flentry
modifier|*
name|fle
decl_stmt|;
name|uint16_t
name|flags
decl_stmt|;
name|uint8_t
name|proto
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|fib
init|=
literal|0
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|llentry
modifier|*
name|lle
decl_stmt|;
name|flags
operator|=
name|ft
operator|->
name|ft_flags
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|=
name|NULL
expr_stmt|;
name|ro
operator|->
name|ro_lle
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * The internal hash lookup is the only IPv4 specific bit 	 * remaining 	 * 	 * XXX BZ: to add IPv6 support just add a check for the 	 * address type in m and ro and an equivalent ipv6 lookup 	 * function - the rest of the code should automatically 	 * handle an ipv6 flow (note that m can be NULL in which 	 * case ro will be set) 	 */
name|hash
operator|=
name|ipv4_flow_lookup_hash_internal
argument_list|(
name|m
argument_list|,
name|ro
argument_list|,
name|key
argument_list|,
operator|&
name|flags
argument_list|,
operator|&
name|proto
argument_list|)
expr_stmt|;
comment|/* 	 * Ports are zero and this isn't a transmit cache 	 * - thus not a protocol for which we need to keep  	 * state 	 * FL_HASH_PORTS => key[0] != 0 for TCP || UDP || SCTP 	 */
if|if
condition|(
name|hash
operator|==
literal|0
operator|||
operator|(
name|key
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
operator|(
name|ft
operator|->
name|ft_flags
operator|&
name|FL_HASH_PORTS
operator|)
operator|)
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|flowtable_lookups
operator|++
expr_stmt|;
name|FL_ENTRY_LOCK
argument_list|(
name|ft
argument_list|,
name|hash
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fle
operator|=
name|FL_ENTRY
argument_list|(
name|ft
argument_list|,
name|hash
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|FL_ENTRY_UNLOCK
argument_list|(
name|ft
argument_list|,
name|hash
argument_list|)
expr_stmt|;
goto|goto
name|uncached
goto|;
block|}
name|keycheck
label|:
name|rt
operator|=
name|__DEVOLATILE
argument_list|(
expr|struct
name|rtentry
operator|*
argument_list|,
name|fle
operator|->
name|f_rt
argument_list|)
expr_stmt|;
name|lle
operator|=
name|__DEVOLATILE
argument_list|(
expr|struct
name|llentry
operator|*
argument_list|,
name|fle
operator|->
name|f_lle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rt
operator|!=
name|NULL
operator|)
operator|&&
name|fle
operator|->
name|f_fhash
operator|==
name|hash
operator|&&
name|flowtable_key_equal
argument_list|(
name|fle
argument_list|,
name|key
argument_list|)
operator|&&
operator|(
name|proto
operator|==
name|fle
operator|->
name|f_proto
operator|)
operator|&&
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|&&
operator|(
name|rt
operator|->
name|rt_ifp
operator|!=
name|NULL
operator|)
condition|)
block|{
name|flowtable_hits
operator|++
expr_stmt|;
name|fle
operator|->
name|f_uptime
operator|=
name|time_uptime
expr_stmt|;
name|fle
operator|->
name|f_flags
operator||=
name|flags
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|=
name|rt
expr_stmt|;
name|ro
operator|->
name|ro_lle
operator|=
name|lle
expr_stmt|;
name|FL_ENTRY_UNLOCK
argument_list|(
name|ft
argument_list|,
name|hash
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|fle
operator|->
name|f_next
operator|!=
name|NULL
condition|)
block|{
name|fle
operator|=
name|fle
operator|->
name|f_next
expr_stmt|;
goto|goto
name|keycheck
goto|;
block|}
name|FL_ENTRY_UNLOCK
argument_list|(
name|ft
argument_list|,
name|hash
argument_list|)
expr_stmt|;
name|uncached
label|:
name|flowtable_misses
operator|++
expr_stmt|;
comment|/* 	 * This bit of code ends up locking the 	 * same route 3 times (just like ip_output + ether_output) 	 * - at lookup 	 * - in rt_check when called by arpresolve 	 * - dropping the refcount for the rtentry 	 * 	 * This could be consolidated to one if we wrote a variant 	 * of arpresolve with an rt_check variant that expected to 	 * receive the route locked 	 */
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|fib
operator|=
name|M_GETFIB
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ft
operator|->
name|ft_rtalloc
argument_list|(
name|ro
argument_list|,
name|hash
argument_list|,
name|fib
argument_list|)
expr_stmt|;
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENETUNREACH
expr_stmt|;
else|else
block|{
name|struct
name|llentry
modifier|*
name|lle
init|=
name|NULL
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|l3addr
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
init|=
name|ro
operator|->
name|ro_rt
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|rt
operator|->
name|rt_ifp
decl_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
name|l3addr
operator|=
name|rt
operator|->
name|rt_gateway
expr_stmt|;
else|else
name|l3addr
operator|=
operator|&
name|ro
operator|->
name|ro_dst
expr_stmt|;
name|llentry_update
argument_list|(
operator|&
name|lle
argument_list|,
name|LLTABLE
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|l3addr
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_lle
operator|=
name|lle
expr_stmt|;
if|if
condition|(
name|lle
operator|==
name|NULL
condition|)
block|{
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|error
operator|=
name|flowtable_insert
argument_list|(
name|ft
argument_list|,
name|hash
argument_list|,
name|key
argument_list|,
name|proto
argument_list|,
name|ro
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|LLE_FREE
argument_list|(
name|lle
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|=
name|NULL
expr_stmt|;
name|ro
operator|->
name|ro_lle
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * used by the bit_alloc macro  */
end_comment

begin_define
define|#
directive|define
name|calloc
parameter_list|(
name|count
parameter_list|,
name|size
parameter_list|)
value|malloc((count)*(size), M_DEVBUF, M_WAITOK|M_ZERO)
end_define

begin_function
name|struct
name|flowtable
modifier|*
name|flowtable_alloc
parameter_list|(
name|int
name|nentry
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|flowtable
modifier|*
name|ft
decl_stmt|,
modifier|*
name|fttail
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|hashjitter
operator|==
literal|0
condition|)
name|hashjitter
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|nentry
operator|>
literal|0
argument_list|,
operator|(
literal|"nentry must be> 0, is %d\n"
operator|,
name|nentry
operator|)
argument_list|)
expr_stmt|;
name|ft
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|flowtable
argument_list|)
argument_list|,
name|M_RTABLE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ft
operator|->
name|ft_flags
operator|=
name|flags
expr_stmt|;
name|ft
operator|->
name|ft_size
operator|=
name|nentry
expr_stmt|;
ifdef|#
directive|ifdef
name|RADIX_MPATH
name|ft
operator|->
name|ft_rtalloc
operator|=
name|rtalloc_mpath_fib
expr_stmt|;
else|#
directive|else
name|ft
operator|->
name|ft_rtalloc
operator|=
name|in_rtalloc_ign_wrapper
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
operator|&
name|FL_PCPU
condition|)
block|{
name|ft
operator|->
name|ft_lock
operator|=
name|flowtable_pcpu_lock
expr_stmt|;
name|ft
operator|->
name|ft_unlock
operator|=
name|flowtable_pcpu_unlock
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|mp_maxid
condition|;
name|i
operator|++
control|)
block|{
name|ft
operator|->
name|ft_table
operator|.
name|pcpu
index|[
name|i
index|]
operator|=
name|malloc
argument_list|(
name|nentry
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|flentry
operator|*
argument_list|)
argument_list|,
name|M_RTABLE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ft
operator|->
name|ft_masks
index|[
name|i
index|]
operator|=
name|bit_alloc
argument_list|(
name|nentry
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ft
operator|->
name|ft_lock_count
operator|=
literal|2
operator|*
operator|(
name|powerof2
argument_list|(
name|mp_maxid
operator|+
literal|1
argument_list|)
condition|?
operator|(
name|mp_maxid
operator|+
literal|1
operator|)
else|:
operator|(
name|fls
argument_list|(
name|mp_maxid
operator|+
literal|1
argument_list|)
operator|<<
literal|1
operator|)
operator|)
expr_stmt|;
name|ft
operator|->
name|ft_lock
operator|=
name|flowtable_global_lock
expr_stmt|;
name|ft
operator|->
name|ft_unlock
operator|=
name|flowtable_global_unlock
expr_stmt|;
name|ft
operator|->
name|ft_table
operator|.
name|global
operator|=
name|malloc
argument_list|(
name|nentry
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|flentry
operator|*
argument_list|)
argument_list|,
name|M_RTABLE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ft
operator|->
name|ft_locks
operator|=
name|malloc
argument_list|(
name|ft
operator|->
name|ft_lock_count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mtx
argument_list|)
argument_list|,
name|M_RTABLE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ft
operator|->
name|ft_lock_count
condition|;
name|i
operator|++
control|)
name|mtx_init
argument_list|(
operator|&
name|ft
operator|->
name|ft_locks
index|[
name|i
index|]
argument_list|,
literal|"flow"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
operator||
name|MTX_DUPOK
argument_list|)
expr_stmt|;
name|ft
operator|->
name|ft_masks
index|[
literal|0
index|]
operator|=
name|bit_alloc
argument_list|(
name|nentry
argument_list|)
expr_stmt|;
block|}
name|ft
operator|->
name|ft_tmpmask
operator|=
name|bit_alloc
argument_list|(
name|nentry
argument_list|)
expr_stmt|;
comment|/* 	 * In the local transmit case the table truly is  	 * just a cache - so everything is eligible for 	 * replacement after 5s of non-use 	 */
if|if
condition|(
name|flags
operator|&
name|FL_HASH_PORTS
condition|)
block|{
name|ft
operator|->
name|ft_udp_idle
operator|=
name|flowtable_udp_expire
expr_stmt|;
name|ft
operator|->
name|ft_syn_idle
operator|=
name|flowtable_syn_expire
expr_stmt|;
name|ft
operator|->
name|ft_fin_wait_idle
operator|=
name|flowtable_fin_wait_expire
expr_stmt|;
name|ft
operator|->
name|ft_tcp_idle
operator|=
name|flowtable_fin_wait_expire
expr_stmt|;
block|}
else|else
block|{
name|ft
operator|->
name|ft_udp_idle
operator|=
name|ft
operator|->
name|ft_fin_wait_idle
operator|=
name|ft
operator|->
name|ft_syn_idle
operator|=
name|ft
operator|->
name|ft_tcp_idle
operator|=
literal|30
expr_stmt|;
block|}
comment|/* 	 * hook in to the cleaner list 	 */
if|if
condition|(
name|flow_list_head
operator|==
name|NULL
condition|)
name|flow_list_head
operator|=
name|ft
expr_stmt|;
else|else
block|{
name|fttail
operator|=
name|flow_list_head
expr_stmt|;
while|while
condition|(
name|fttail
operator|->
name|ft_next
operator|!=
name|NULL
condition|)
name|fttail
operator|=
name|fttail
operator|->
name|ft_next
expr_stmt|;
name|fttail
operator|->
name|ft_next
operator|=
name|ft
expr_stmt|;
block|}
return|return
operator|(
name|ft
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|flowtable_setup
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|ipv4_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"ip4flow"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|flentry_v4
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|64
argument_list|,
name|UMA_ZONE_MAXBUCKET
argument_list|)
expr_stmt|;
name|ipv6_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"ip6flow"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|flentry_v6
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|64
argument_list|,
name|UMA_ZONE_MAXBUCKET
argument_list|)
expr_stmt|;
name|uma_zone_set_max
argument_list|(
name|ipv4_zone
argument_list|,
name|nmbflows
argument_list|)
expr_stmt|;
name|uma_zone_set_max
argument_list|(
name|ipv6_zone
argument_list|,
name|nmbflows
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|flowtable_setup
argument_list|,
name|SI_SUB_KTHREAD_INIT
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|flowtable_setup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The rest of the code is devoted to garbage collection of expired entries.  * It is a new additon made necessary by the switch to dynamically allocating  * flow tables.  *   */
end_comment

begin_function
specifier|static
name|void
name|fle_free
parameter_list|(
name|struct
name|flentry
modifier|*
name|fle
parameter_list|)
block|{
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|llentry
modifier|*
name|lle
decl_stmt|;
name|rt
operator|=
name|__DEVOLATILE
argument_list|(
expr|struct
name|rtentry
operator|*
argument_list|,
name|fle
operator|->
name|f_rt
argument_list|)
expr_stmt|;
name|lle
operator|=
name|__DEVOLATILE
argument_list|(
expr|struct
name|llentry
operator|*
argument_list|,
name|fle
operator|->
name|f_lle
argument_list|)
expr_stmt|;
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|LLE_FREE
argument_list|(
name|lle
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
operator|(
name|fle
operator|->
name|f_flags
operator|&
name|FL_IPV6
operator|)
condition|?
name|ipv6_zone
else|:
name|ipv4_zone
argument_list|,
name|fle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flowtable_free_stale
parameter_list|(
name|struct
name|flowtable
modifier|*
name|ft
parameter_list|)
block|{
name|int
name|curbit
init|=
literal|0
decl_stmt|,
name|count
decl_stmt|;
name|struct
name|flentry
modifier|*
name|fle
decl_stmt|,
modifier|*
modifier|*
name|flehead
decl_stmt|,
modifier|*
name|fleprev
decl_stmt|;
name|struct
name|flentry
modifier|*
name|flefreehead
decl_stmt|,
modifier|*
name|flefreetail
decl_stmt|,
modifier|*
name|fletmp
decl_stmt|;
name|bitstr_t
modifier|*
name|mask
decl_stmt|,
modifier|*
name|tmpmask
decl_stmt|;
name|flefreehead
operator|=
name|flefreetail
operator|=
name|NULL
expr_stmt|;
name|mask
operator|=
name|flowtable_mask
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|tmpmask
operator|=
name|ft
operator|->
name|ft_tmpmask
expr_stmt|;
name|memcpy
argument_list|(
name|tmpmask
argument_list|,
name|mask
argument_list|,
name|ft
operator|->
name|ft_size
operator|/
literal|8
argument_list|)
expr_stmt|;
comment|/* 	 * XXX Note to self, bit_ffs operates at the byte level 	 * and thus adds gratuitous overhead 	 */
name|bit_ffs
argument_list|(
name|tmpmask
argument_list|,
name|ft
operator|->
name|ft_size
argument_list|,
operator|&
name|curbit
argument_list|)
expr_stmt|;
while|while
condition|(
name|curbit
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|curbit
operator|>=
name|ft
operator|->
name|ft_size
operator|||
name|curbit
operator|<
operator|-
literal|1
condition|)
block|{
name|log
argument_list|(
name|LOG_ALERT
argument_list|,
literal|"warning: bad curbit value %d \n"
argument_list|,
name|curbit
argument_list|)
expr_stmt|;
break|break;
block|}
name|FL_ENTRY_LOCK
argument_list|(
name|ft
argument_list|,
name|curbit
argument_list|)
expr_stmt|;
name|flehead
operator|=
name|flowtable_entry
argument_list|(
name|ft
argument_list|,
name|curbit
argument_list|)
expr_stmt|;
name|fle
operator|=
name|fleprev
operator|=
operator|*
name|flehead
expr_stmt|;
name|flowtable_free_checks
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|fle
operator|==
name|NULL
operator|&&
name|curbit
operator|>
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ALERT
argument_list|,
literal|"warning bit=%d set, but no fle found\n"
argument_list|,
name|curbit
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
name|fle
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|flow_stale
argument_list|(
name|ft
argument_list|,
name|fle
argument_list|)
condition|)
block|{
name|fleprev
operator|=
name|fle
expr_stmt|;
name|fle
operator|=
name|fle
operator|->
name|f_next
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * delete head of the list 			 */
if|if
condition|(
name|fleprev
operator|==
operator|*
name|flehead
condition|)
block|{
name|fletmp
operator|=
name|fleprev
expr_stmt|;
if|if
condition|(
name|fle
operator|==
name|fleprev
condition|)
block|{
name|fleprev
operator|=
operator|*
name|flehead
operator|=
name|fle
operator|->
name|f_next
expr_stmt|;
block|}
else|else
name|fleprev
operator|=
operator|*
name|flehead
operator|=
name|fle
expr_stmt|;
name|fle
operator|=
name|fle
operator|->
name|f_next
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * don't advance fleprev 				 */
name|fletmp
operator|=
name|fle
expr_stmt|;
name|fleprev
operator|->
name|f_next
operator|=
name|fle
operator|->
name|f_next
expr_stmt|;
name|fle
operator|=
name|fleprev
operator|->
name|f_next
expr_stmt|;
block|}
if|if
condition|(
name|flefreehead
operator|==
name|NULL
condition|)
name|flefreehead
operator|=
name|flefreetail
operator|=
name|fletmp
expr_stmt|;
else|else
block|{
name|flefreetail
operator|->
name|f_next
operator|=
name|fletmp
expr_stmt|;
name|flefreetail
operator|=
name|fletmp
expr_stmt|;
block|}
name|fletmp
operator|->
name|f_next
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|flehead
operator|==
name|NULL
condition|)
name|bit_clear
argument_list|(
name|mask
argument_list|,
name|curbit
argument_list|)
expr_stmt|;
name|FL_ENTRY_UNLOCK
argument_list|(
name|ft
argument_list|,
name|curbit
argument_list|)
expr_stmt|;
name|bit_clear
argument_list|(
name|tmpmask
argument_list|,
name|curbit
argument_list|)
expr_stmt|;
name|bit_ffs
argument_list|(
name|tmpmask
argument_list|,
name|ft
operator|->
name|ft_size
argument_list|,
operator|&
name|curbit
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|fle
operator|=
name|flefreehead
operator|)
operator|!=
name|NULL
condition|)
block|{
name|flefreehead
operator|=
name|fle
operator|->
name|f_next
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|flowtable_frees
operator|++
expr_stmt|;
name|fle_free
argument_list|(
name|fle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bootverbose
operator|&&
name|count
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"freed %d flow entries\n"
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flowtable_cleaner
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|flowtable
modifier|*
name|ft
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"flowtable cleaner started\n"
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|ft
operator|=
name|flow_list_head
expr_stmt|;
while|while
condition|(
name|ft
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ft
operator|->
name|ft_flags
operator|&
name|FL_PCPU
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|mp_maxid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_bind
argument_list|(
name|curthread
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|flowtable_free_stale
argument_list|(
name|ft
argument_list|)
expr_stmt|;
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_unbind
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|flowtable_free_stale
argument_list|(
name|ft
argument_list|)
expr_stmt|;
block|}
name|ft
operator|=
name|ft
operator|->
name|ft_next
expr_stmt|;
block|}
comment|/* 		 * The 20 second interval between cleaning checks 		 * is arbitrary 		 */
name|pause
argument_list|(
literal|"flowcleanwait"
argument_list|,
literal|20
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|kproc_desc
name|flow_kp
init|=
block|{
literal|"flowcleaner"
block|,
name|flowtable_cleaner
block|,
operator|&
name|flowcleanerproc
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSINIT
argument_list|(
name|flowcleaner
argument_list|,
name|SI_SUB_KTHREAD_IDLE
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|kproc_start
argument_list|,
operator|&
name|flow_kp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NO_FLOWTABLE */
end_comment

end_unit

