begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: if_trunk.c,v 1.30 2007/01/31 06:20:19 reyk Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2006 Reyk Floeter<reyk@openbsd.org>  * Copyright (c) 2007 Andrew Thompson<thompsa@FreeBSD.org>  * Copyright (c) 2014 Marcelo Araujo<araujo@FreeBSD.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/rmlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_clone.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_ifattach.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_lagg.h>
end_include

begin_include
include|#
directive|include
file|<net/ieee8023ad_lacp.h>
end_include

begin_comment
comment|/* Special flags we should propagate to the lagg ports. */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|int
name|flag
decl_stmt|;
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
block|}
name|lagg_pflags
index|[]
init|=
block|{
block|{
name|IFF_PROMISC
block|,
name|ifpromisc
block|}
block|,
block|{
name|IFF_ALLMULTI
block|,
name|if_allmulti
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|SLIST_HEAD
argument_list|(
name|__trhead
argument_list|,
name|lagg_softc
argument_list|)
argument_list|,
name|lagg_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* list of laggs */
end_comment

begin_define
define|#
directive|define
name|V_lagg_list
value|VNET(lagg_list)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|mtx
argument_list|,
name|lagg_list_mtx
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_lagg_list_mtx
value|VNET(lagg_list_mtx)
end_define

begin_define
define|#
directive|define
name|LAGG_LIST_LOCK_INIT
parameter_list|(
name|x
parameter_list|)
value|mtx_init(&V_lagg_list_mtx, \ 					"if_lagg list", NULL, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|LAGG_LIST_LOCK_DESTROY
parameter_list|(
name|x
parameter_list|)
value|mtx_destroy(&V_lagg_list_mtx)
end_define

begin_define
define|#
directive|define
name|LAGG_LIST_LOCK
parameter_list|(
name|x
parameter_list|)
value|mtx_lock(&V_lagg_list_mtx)
end_define

begin_define
define|#
directive|define
name|LAGG_LIST_UNLOCK
parameter_list|(
name|x
parameter_list|)
value|mtx_unlock(&V_lagg_list_mtx)
end_define

begin_decl_stmt
name|eventhandler_tag
name|lagg_detach_cookie
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|lagg_clone_create
parameter_list|(
name|struct
name|if_clone
modifier|*
parameter_list|,
name|int
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_clone_destroy
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|if_clone
operator|*
argument_list|,
name|lagg_cloner
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_lagg_cloner
value|VNET(lagg_cloner)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
name|laggname
index|[]
init|=
literal|"lagg"
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|lagg_lladdr
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_capabilities
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_port_lladdr
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|,
name|lagg_llqtype
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_port_setlladdr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_port_create
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_port_destroy
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_input
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_linkstate
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_port_state
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_port_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_port_output
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|struct
name|route
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_port_ifdetach
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|LAGG_PORT_STACKING
end_ifdef

begin_function_decl
specifier|static
name|int
name|lagg_port_checkstacking
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|lagg_port2req
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|struct
name|lagg_reqport
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_stop
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_ether_setmulti
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_ether_cmdmulti
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_setflag
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_setflags
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|lagg_get_counter
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|ift_counter
name|cnt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|lagg_port
modifier|*
name|lagg_link_active
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|lagg_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Simple round robin */
end_comment

begin_function_decl
specifier|static
name|void
name|lagg_rr_attach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_rr_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_rr_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Active failover */
end_comment

begin_function_decl
specifier|static
name|int
name|lagg_fail_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_fail_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Loadbalancing */
end_comment

begin_function_decl
specifier|static
name|void
name|lagg_lb_attach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_lb_detach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_lb_port_create
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_lb_port_destroy
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_lb_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_lb_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_lb_porttable
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|lagg_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Broadcast */
end_comment

begin_function_decl
specifier|static
name|int
name|lagg_bcast_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_bcast_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* 802.3ad LACP */
end_comment

begin_function_decl
specifier|static
name|void
name|lagg_lacp_attach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_lacp_detach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_lacp_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_lacp_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_lacp_lladdr
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* lagg protocol table */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
name|lagg_proto
block|{
name|lagg_proto
name|pr_num
decl_stmt|;
name|void
function_decl|(
modifier|*
name|pr_attach
function_decl|)
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|pr_detach
function_decl|)
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|pr_start
function_decl|)
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
name|struct
name|mbuf
modifier|*
function_decl|(
modifier|*
name|pr_input
function_decl|)
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|pr_addport
function_decl|)
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|pr_delport
function_decl|)
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|pr_linkstate
function_decl|)
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|pr_init
function_decl|)
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|pr_stop
function_decl|)
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|pr_lladdr
function_decl|)
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|pr_request
function_decl|)
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|pr_portreq
function_decl|)
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
block|}
name|lagg_protos
index|[]
init|=
block|{
block|{
operator|.
name|pr_num
operator|=
name|LAGG_PROTO_NONE
block|}
block|,
block|{
operator|.
name|pr_num
operator|=
name|LAGG_PROTO_ROUNDROBIN
block|,
operator|.
name|pr_attach
operator|=
name|lagg_rr_attach
block|,
operator|.
name|pr_start
operator|=
name|lagg_rr_start
block|,
operator|.
name|pr_input
operator|=
name|lagg_rr_input
block|,     }
block|,
block|{
operator|.
name|pr_num
operator|=
name|LAGG_PROTO_FAILOVER
block|,
operator|.
name|pr_start
operator|=
name|lagg_fail_start
block|,
operator|.
name|pr_input
operator|=
name|lagg_fail_input
block|,     }
block|,
block|{
operator|.
name|pr_num
operator|=
name|LAGG_PROTO_LOADBALANCE
block|,
operator|.
name|pr_attach
operator|=
name|lagg_lb_attach
block|,
operator|.
name|pr_detach
operator|=
name|lagg_lb_detach
block|,
operator|.
name|pr_start
operator|=
name|lagg_lb_start
block|,
operator|.
name|pr_input
operator|=
name|lagg_lb_input
block|,
operator|.
name|pr_addport
operator|=
name|lagg_lb_port_create
block|,
operator|.
name|pr_delport
operator|=
name|lagg_lb_port_destroy
block|,     }
block|,
block|{
operator|.
name|pr_num
operator|=
name|LAGG_PROTO_LACP
block|,
operator|.
name|pr_attach
operator|=
name|lagg_lacp_attach
block|,
operator|.
name|pr_detach
operator|=
name|lagg_lacp_detach
block|,
operator|.
name|pr_start
operator|=
name|lagg_lacp_start
block|,
operator|.
name|pr_input
operator|=
name|lagg_lacp_input
block|,
operator|.
name|pr_addport
operator|=
name|lacp_port_create
block|,
operator|.
name|pr_delport
operator|=
name|lacp_port_destroy
block|,
operator|.
name|pr_linkstate
operator|=
name|lacp_linkstate
block|,
operator|.
name|pr_init
operator|=
name|lacp_init
block|,
operator|.
name|pr_stop
operator|=
name|lacp_stop
block|,
operator|.
name|pr_lladdr
operator|=
name|lagg_lacp_lladdr
block|,
operator|.
name|pr_request
operator|=
name|lacp_req
block|,
operator|.
name|pr_portreq
operator|=
name|lacp_portreq
block|,     }
block|,
block|{
operator|.
name|pr_num
operator|=
name|LAGG_PROTO_BROADCAST
block|,
operator|.
name|pr_start
operator|=
name|lagg_bcast_start
block|,
operator|.
name|pr_input
operator|=
name|lagg_bcast_input
block|,     }
block|, }
struct|;
end_struct

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_link
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_link
argument_list|,
name|OID_AUTO
argument_list|,
name|lagg
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Link Aggregation"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Allow input on any failover links */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|lagg_failover_rx_all
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_lagg_failover_rx_all
value|VNET(lagg_failover_rx_all)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_link_lagg
argument_list|,
name|OID_AUTO
argument_list|,
name|failover_rx_all
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLFLAG_VNET
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|lagg_failover_rx_all
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Accept input from any interface in a failover lagg"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Default value for using flowid */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|def_use_flowid
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_def_use_flowid
value|VNET(def_use_flowid)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_link_lagg
argument_list|,
name|OID_AUTO
argument_list|,
name|default_use_flowid
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|def_use_flowid
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Default setting for using flow id for load sharing"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Default value for flowid shift */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|def_flowid_shift
argument_list|)
operator|=
literal|16
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_def_flowid_shift
value|VNET(def_flowid_shift)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_link_lagg
argument_list|,
name|OID_AUTO
argument_list|,
name|default_flowid_shift
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|def_flowid_shift
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Default setting for flowid shift for load sharing"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|vnet_lagg_init
parameter_list|(
specifier|const
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|LAGG_LIST_LOCK_INIT
argument_list|()
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|V_lagg_list
argument_list|)
expr_stmt|;
name|V_lagg_cloner
operator|=
name|if_clone_simple
argument_list|(
name|laggname
argument_list|,
name|lagg_clone_create
argument_list|,
name|lagg_clone_destroy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|VNET_SYSINIT
argument_list|(
name|vnet_lagg_init
argument_list|,
name|SI_SUB_PROTO_IFATTACHDOMAIN
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|vnet_lagg_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|vnet_lagg_uninit
parameter_list|(
specifier|const
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|if_clone_detach
argument_list|(
name|V_lagg_cloner
argument_list|)
expr_stmt|;
name|LAGG_LIST_LOCK_DESTROY
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|VNET_SYSUNINIT
argument_list|(
name|vnet_lagg_uninit
argument_list|,
name|SI_SUB_PROTO_IFATTACHDOMAIN
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|vnet_lagg_uninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|lagg_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|lagg_input_p
operator|=
name|lagg_input
expr_stmt|;
name|lagg_linkstate_p
operator|=
name|lagg_port_state
expr_stmt|;
name|lagg_detach_cookie
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|ifnet_departure_event
argument_list|,
name|lagg_port_ifdetach
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|ifnet_departure_event
argument_list|,
name|lagg_detach_cookie
argument_list|)
expr_stmt|;
name|lagg_input_p
operator|=
name|NULL
expr_stmt|;
name|lagg_linkstate_p
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|lagg_mod
init|=
block|{
literal|"if_lagg"
block|,
name|lagg_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|if_lagg
argument_list|,
name|lagg_mod
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|if_lagg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|lagg_proto_attach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|lagg_proto
name|pr
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|sc
operator|->
name|sc_proto
operator|==
name|LAGG_PROTO_NONE
argument_list|,
operator|(
literal|"%s: sc %p has proto"
operator|,
name|__func__
operator|,
name|sc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ifflags
operator|&
name|IFF_DEBUG
condition|)
name|if_printf
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
literal|"using proto %u\n"
argument_list|,
name|pr
argument_list|)
expr_stmt|;
if|if
condition|(
name|lagg_protos
index|[
name|pr
index|]
operator|.
name|pr_attach
operator|!=
name|NULL
condition|)
name|lagg_protos
index|[
name|pr
index|]
operator|.
name|pr_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_proto
operator|=
name|pr
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_proto_detach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|lagg_proto
name|pr
decl_stmt|;
name|LAGG_WLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|pr
operator|=
name|sc
operator|->
name|sc_proto
expr_stmt|;
name|sc
operator|->
name|sc_proto
operator|=
name|LAGG_PROTO_NONE
expr_stmt|;
if|if
condition|(
name|lagg_protos
index|[
name|pr
index|]
operator|.
name|pr_detach
operator|!=
name|NULL
condition|)
name|lagg_protos
index|[
name|pr
index|]
operator|.
name|pr_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_proto_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
operator|(
name|lagg_protos
index|[
name|sc
operator|->
name|sc_proto
index|]
operator|.
name|pr_start
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_proto_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
operator|(
name|lagg_protos
index|[
name|sc
operator|->
name|sc_proto
index|]
operator|.
name|pr_input
argument_list|(
name|sc
argument_list|,
name|lp
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_proto_addport
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|)
block|{
if|if
condition|(
name|lagg_protos
index|[
name|sc
operator|->
name|sc_proto
index|]
operator|.
name|pr_addport
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|lagg_protos
index|[
name|sc
operator|->
name|sc_proto
index|]
operator|.
name|pr_addport
argument_list|(
name|lp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_proto_delport
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|)
block|{
if|if
condition|(
name|lagg_protos
index|[
name|sc
operator|->
name|sc_proto
index|]
operator|.
name|pr_delport
operator|!=
name|NULL
condition|)
name|lagg_protos
index|[
name|sc
operator|->
name|sc_proto
index|]
operator|.
name|pr_delport
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_proto_linkstate
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|)
block|{
if|if
condition|(
name|lagg_protos
index|[
name|sc
operator|->
name|sc_proto
index|]
operator|.
name|pr_linkstate
operator|!=
name|NULL
condition|)
name|lagg_protos
index|[
name|sc
operator|->
name|sc_proto
index|]
operator|.
name|pr_linkstate
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_proto_init
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|lagg_protos
index|[
name|sc
operator|->
name|sc_proto
index|]
operator|.
name|pr_init
operator|!=
name|NULL
condition|)
name|lagg_protos
index|[
name|sc
operator|->
name|sc_proto
index|]
operator|.
name|pr_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_proto_stop
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|lagg_protos
index|[
name|sc
operator|->
name|sc_proto
index|]
operator|.
name|pr_stop
operator|!=
name|NULL
condition|)
name|lagg_protos
index|[
name|sc
operator|->
name|sc_proto
index|]
operator|.
name|pr_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_proto_lladdr
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|lagg_protos
index|[
name|sc
operator|->
name|sc_proto
index|]
operator|.
name|pr_lladdr
operator|!=
name|NULL
condition|)
name|lagg_protos
index|[
name|sc
operator|->
name|sc_proto
index|]
operator|.
name|pr_lladdr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_proto_request
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|void
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|lagg_protos
index|[
name|sc
operator|->
name|sc_proto
index|]
operator|.
name|pr_request
operator|!=
name|NULL
condition|)
name|lagg_protos
index|[
name|sc
operator|->
name|sc_proto
index|]
operator|.
name|pr_request
argument_list|(
name|sc
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_proto_portreq
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|void
modifier|*
name|v
parameter_list|)
block|{
if|if
condition|(
name|lagg_protos
index|[
name|sc
operator|->
name|sc_proto
index|]
operator|.
name|pr_portreq
operator|!=
name|NULL
condition|)
name|lagg_protos
index|[
name|sc
operator|->
name|sc_proto
index|]
operator|.
name|pr_portreq
argument_list|(
name|lp
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine is run via an vlan  * config EVENT  */
end_comment

begin_function
specifier|static
name|void
name|lagg_register_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int16_t
name|vtag
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
comment|/* Not our event */
return|return;
name|LAGG_RLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|)
condition|)
block|{
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|EVENTHANDLER_INVOKE
argument_list|(
name|vlan_config
argument_list|,
name|lp
operator|->
name|lp_ifp
argument_list|,
name|vtag
argument_list|)
expr_stmt|;
block|}
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine is run via an vlan  * unconfig EVENT  */
end_comment

begin_function
specifier|static
name|void
name|lagg_unregister_vlan
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int16_t
name|vtag
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|!=
name|arg
condition|)
comment|/* Not our event */
return|return;
name|LAGG_RLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SLIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|)
condition|)
block|{
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|EVENTHANDLER_INVOKE
argument_list|(
name|vlan_unconfig
argument_list|,
name|lp
operator|->
name|lp_ifp
argument_list|,
name|vtag
argument_list|)
expr_stmt|;
block|}
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_clone_create
parameter_list|(
name|struct
name|if_clone
modifier|*
name|ifc
parameter_list|,
name|int
name|unit
parameter_list|,
name|caddr_t
name|params
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|static
specifier|const
name|u_char
name|eaddr
index|[
literal|6
index|]
decl_stmt|;
comment|/* 00:00:00:00:00:00 */
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
if|if
condition|(
name|V_def_use_flowid
condition|)
name|sc
operator|->
name|sc_opts
operator||=
name|LAGG_OPT_USE_FLOWID
expr_stmt|;
name|sc
operator|->
name|flowid_shift
operator|=
name|V_def_flowid_shift
expr_stmt|;
comment|/* Hash all layers by default */
name|sc
operator|->
name|sc_flags
operator|=
name|MBUF_HASHFLAG_L2
operator||
name|MBUF_HASHFLAG_L3
operator||
name|MBUF_HASHFLAG_L4
expr_stmt|;
name|lagg_proto_attach
argument_list|(
name|sc
argument_list|,
name|LAGG_PROTO_DEFAULT
argument_list|)
expr_stmt|;
name|LAGG_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_lladdr_task
argument_list|,
literal|0
argument_list|,
name|lagg_port_setlladdr
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* Initialise pseudo media types */
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
literal|0
argument_list|,
name|lagg_media_change
argument_list|,
name|lagg_media_status
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|laggname
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_transmit
operator|=
name|lagg_transmit
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|lagg_qflush
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|lagg_init
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|lagg_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_get_counter
operator|=
name|lagg_get_counter
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_SIMPLEX
operator||
name|IFF_BROADCAST
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_capenable
operator|=
name|ifp
operator|->
name|if_capabilities
operator|=
name|IFCAP_HWSTATS
expr_stmt|;
comment|/* 	 * Attach as an ordinary ethernet device, children will be attached 	 * as special device IFT_IEEE8023ADLAG. 	 */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vlan_attach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_config
argument_list|,
name|lagg_register_vlan
argument_list|,
name|sc
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
name|sc
operator|->
name|vlan_detach
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|lagg_unregister_vlan
argument_list|,
name|sc
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
comment|/* Insert into the global list of laggs */
name|LAGG_LIST_LOCK
argument_list|()
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|V_lagg_list
argument_list|,
name|sc
argument_list|,
name|sc_entries
argument_list|)
expr_stmt|;
name|LAGG_LIST_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_clone_destroy
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lagg_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_config
argument_list|,
name|sc
operator|->
name|vlan_attach
argument_list|)
expr_stmt|;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|sc
operator|->
name|vlan_detach
argument_list|)
expr_stmt|;
comment|/* Shutdown and remove lagg ports */
while|while
condition|(
operator|(
name|lp
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|lagg_port_destroy
argument_list|(
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Unhook the aggregation protocol */
name|lagg_proto_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LAGG_UNLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|LAGG_LIST_LOCK
argument_list|()
expr_stmt|;
name|SLIST_REMOVE
argument_list|(
operator|&
name|V_lagg_list
argument_list|,
name|sc
argument_list|,
name|lagg_softc
argument_list|,
name|sc_entries
argument_list|)
expr_stmt|;
name|LAGG_LIST_UNLOCK
argument_list|()
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|sc
operator|->
name|sc_lladdr_task
argument_list|)
expr_stmt|;
name|LAGG_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set link-layer address on the lagg interface itself.  *   * Set noinline to be dtrace-friendly  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|lagg_lladdr
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|lladdr
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|lagg_port
name|lp
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|lladdr
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|LAGG_WLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Set the link layer address on the lagg interface. 	 * lagg_proto_lladdr() notifies the MAC change to 	 * the aggregation protocol.  iflladdr_event handler which 	 * may trigger gratuitous ARPs for INET will be handled in 	 * a taskqueue. 	 */
name|bcopy
argument_list|(
name|lladdr
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|lagg_proto_lladdr
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Send notification request for lagg interface 	 * itself. Note that new lladdr is already set. 	 */
name|bzero
argument_list|(
operator|&
name|lp
argument_list|,
sizeof|sizeof
argument_list|(
name|lp
argument_list|)
argument_list|)
expr_stmt|;
name|lp
operator|.
name|lp_ifp
operator|=
name|sc
operator|->
name|sc_ifp
expr_stmt|;
name|lp
operator|.
name|lp_softc
operator|=
name|sc
expr_stmt|;
comment|/* Do not request lladdr change */
name|lagg_port_lladdr
argument_list|(
operator|&
name|lp
argument_list|,
name|lladdr
argument_list|,
name|LAGG_LLQTYPE_VIRT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_capabilities
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|int
name|cap
init|=
operator|~
literal|0
decl_stmt|,
name|ena
init|=
operator|~
literal|0
decl_stmt|;
name|u_long
name|hwa
init|=
operator|~
literal|0UL
decl_stmt|;
name|struct
name|ifnet_hw_tsomax
name|hw_tsomax
decl_stmt|;
name|LAGG_WLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|hw_tsomax
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hw_tsomax
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get capabilities from the lagg ports */
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
name|cap
operator|&=
name|lp
operator|->
name|lp_ifp
operator|->
name|if_capabilities
expr_stmt|;
name|ena
operator|&=
name|lp
operator|->
name|lp_ifp
operator|->
name|if_capenable
expr_stmt|;
name|hwa
operator|&=
name|lp
operator|->
name|lp_ifp
operator|->
name|if_hwassist
expr_stmt|;
name|if_hw_tsomax_common
argument_list|(
name|lp
operator|->
name|lp_ifp
argument_list|,
operator|&
name|hw_tsomax
argument_list|)
expr_stmt|;
block|}
name|cap
operator|=
operator|(
name|cap
operator|==
operator|~
literal|0
condition|?
literal|0
else|:
name|cap
operator|)
expr_stmt|;
name|ena
operator|=
operator|(
name|ena
operator|==
operator|~
literal|0
condition|?
literal|0
else|:
name|ena
operator|)
expr_stmt|;
name|hwa
operator|=
operator|(
name|hwa
operator|==
operator|~
literal|0
condition|?
literal|0
else|:
name|hwa
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_capabilities
operator|!=
name|cap
operator|||
name|sc
operator|->
name|sc_ifp
operator|->
name|if_capenable
operator|!=
name|ena
operator|||
name|sc
operator|->
name|sc_ifp
operator|->
name|if_hwassist
operator|!=
name|hwa
operator|||
name|if_hw_tsomax_update
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
operator|&
name|hw_tsomax
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_ifp
operator|->
name|if_capabilities
operator|=
name|cap
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_capenable
operator|=
name|ena
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_hwassist
operator|=
name|hwa
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|sc
operator|->
name|sc_ifp
operator|->
name|if_lastchange
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ifflags
operator|&
name|IFF_DEBUG
condition|)
name|if_printf
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
literal|"capabilities 0x%08x enabled 0x%08x\n"
argument_list|,
name|cap
argument_list|,
name|ena
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Enqueue interface lladdr notification.  * If request is already queued, it is updated.  * If setting lladdr is also desired, @do_change has to be set to 1.  *  * Set noinline to be dtrace-friendly  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|lagg_port_lladdr
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|uint8_t
modifier|*
name|lladdr
parameter_list|,
name|lagg_llqtype
name|llq_type
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|lp
operator|->
name|lp_softc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|lp
operator|->
name|lp_ifp
decl_stmt|;
name|struct
name|lagg_llq
modifier|*
name|llq
decl_stmt|;
name|LAGG_WLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Do not enqueue requests where lladdr is the same for 	 * "physical" interfaces (e.g. ports in lagg) 	 */
if|if
condition|(
name|llq_type
operator|==
name|LAGG_LLQTYPE_PHYS
operator|&&
name|memcmp
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|lladdr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Check to make sure its not already queued to be changed */
name|SLIST_FOREACH
argument_list|(
argument|llq
argument_list|,
argument|&sc->sc_llq_head
argument_list|,
argument|llq_entries
argument_list|)
block|{
if|if
condition|(
name|llq
operator|->
name|llq_ifp
operator|==
name|ifp
condition|)
block|{
comment|/* Update lladdr, it may have changed */
name|bcopy
argument_list|(
name|lladdr
argument_list|,
name|llq
operator|->
name|llq_lladdr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|llq
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lagg_llq
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|llq
operator|==
name|NULL
condition|)
comment|/* XXX what to do */
return|return;
name|llq
operator|->
name|llq_ifp
operator|=
name|ifp
expr_stmt|;
name|llq
operator|->
name|llq_type
operator|=
name|llq_type
expr_stmt|;
name|bcopy
argument_list|(
name|lladdr
argument_list|,
name|llq
operator|->
name|llq_lladdr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* XXX: We should insert to tail */
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_llq_head
argument_list|,
name|llq
argument_list|,
name|llq_entries
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|sc
operator|->
name|sc_lladdr_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the interface MAC address from a taskqueue to avoid a LOR.  *  * Set noinline to be dtrace-friendly  */
end_comment

begin_function
specifier|static
name|__noinline
name|void
name|lagg_port_setlladdr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|lagg_llq
modifier|*
name|llq
decl_stmt|,
modifier|*
name|head
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Grab a local reference of the queue and remove it from the softc */
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|head
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_llq_head
argument_list|)
expr_stmt|;
name|SLIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_llq_head
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Traverse the queue and set the lladdr on each ifp. It is safe to do 	 * unlocked as we have the only reference to it. 	 */
for|for
control|(
name|llq
operator|=
name|head
init|;
name|llq
operator|!=
name|NULL
condition|;
name|llq
operator|=
name|head
control|)
block|{
name|ifp
operator|=
name|llq
operator|->
name|llq_ifp
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|ifp
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Set the link layer address on the laggport interface. 		 * Note that if_setlladdr() or iflladdr_event handler 		 * may result in arp transmission / lltable updates. 		 */
if|if
condition|(
name|llq
operator|->
name|llq_type
operator|==
name|LAGG_LLQTYPE_PHYS
condition|)
name|error
operator|=
name|if_setlladdr
argument_list|(
name|ifp
argument_list|,
name|llq
operator|->
name|llq_lladdr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"%s: setlladdr failed on %s\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
else|else
name|EVENTHANDLER_INVOKE
argument_list|(
name|iflladdr_event
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
name|head
operator|=
name|SLIST_NEXT
argument_list|(
name|llq
argument_list|,
name|llq_entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|llq
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_port_create
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc_ptr
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|,
modifier|*
name|tlp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|uint64_t
modifier|*
name|pval
decl_stmt|;
name|LAGG_WLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Limit the maximal number of lagg ports */
if|if
condition|(
name|sc
operator|->
name|sc_count
operator|>=
name|LAGG_MAX_PORTS
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* Check if port has already been associated to a lagg */
if|if
condition|(
name|ifp
operator|->
name|if_lagg
operator|!=
name|NULL
condition|)
block|{
comment|/* Port is already in the current lagg? */
name|lp
operator|=
operator|(
expr|struct
name|lagg_port
operator|*
operator|)
name|ifp
operator|->
name|if_lagg
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|lp_softc
operator|==
name|sc
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* XXX Disallow non-ethernet interfaces (this should be any of 802) */
if|if
condition|(
name|ifp
operator|->
name|if_type
operator|!=
name|IFT_ETHER
operator|&&
name|ifp
operator|->
name|if_type
operator|!=
name|IFT_L2VLAN
condition|)
return|return
operator|(
name|EPROTONOSUPPORT
operator|)
return|;
comment|/* Allow the first Ethernet member to define the MTU */
if|if
condition|(
name|SLIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|)
condition|)
name|sc
operator|->
name|sc_ifp
operator|->
name|if_mtu
operator|=
name|ifp
operator|->
name|if_mtu
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_ifp
operator|->
name|if_mtu
operator|!=
name|ifp
operator|->
name|if_mtu
condition|)
block|{
name|if_printf
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
literal|"invalid MTU for %s\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|lp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lagg_port
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Check if port is a stacked lagg */
name|LAGG_LIST_LOCK
argument_list|()
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|sc_ptr
argument_list|,
argument|&V_lagg_list
argument_list|,
argument|sc_entries
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|==
name|sc_ptr
operator|->
name|sc_ifp
condition|)
block|{
name|LAGG_LIST_UNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|lp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* XXX disable stacking for the moment, its untested */
ifdef|#
directive|ifdef
name|LAGG_PORT_STACKING
name|lp
operator|->
name|lp_flags
operator||=
name|LAGG_PORT_STACK
expr_stmt|;
if|if
condition|(
name|lagg_port_checkstacking
argument_list|(
name|sc_ptr
argument_list|)
operator|>=
name|LAGG_MAX_STACKING
condition|)
block|{
name|LAGG_LIST_UNLOCK
argument_list|()
expr_stmt|;
name|free
argument_list|(
name|lp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|E2BIG
operator|)
return|;
block|}
endif|#
directive|endif
block|}
block|}
name|LAGG_LIST_UNLOCK
argument_list|()
expr_stmt|;
comment|/* Change the interface type */
name|lp
operator|->
name|lp_iftype
operator|=
name|ifp
operator|->
name|if_type
expr_stmt|;
name|ifp
operator|->
name|if_type
operator|=
name|IFT_IEEE8023ADLAG
expr_stmt|;
name|ifp
operator|->
name|if_lagg
operator|=
name|lp
expr_stmt|;
name|lp
operator|->
name|lp_ioctl
operator|=
name|ifp
operator|->
name|if_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|lagg_port_ioctl
expr_stmt|;
name|lp
operator|->
name|lp_output
operator|=
name|ifp
operator|->
name|if_output
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|lagg_port_output
expr_stmt|;
name|lp
operator|->
name|lp_ifp
operator|=
name|ifp
expr_stmt|;
name|lp
operator|->
name|lp_softc
operator|=
name|sc
expr_stmt|;
comment|/* Save port link layer address */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|lp
operator|->
name|lp_lladdr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_primary
operator|=
name|lp
expr_stmt|;
comment|/* First port in lagg. Update/notify lagg lladdress */
name|lagg_lladdr
argument_list|(
name|sc
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Update link layer address for this port and 		 * send notifications to other subsystems. 		 */
name|lagg_port_lladdr
argument_list|(
name|lp
argument_list|,
name|IF_LLADDR
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|)
argument_list|,
name|LAGG_LLQTYPE_PHYS
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Insert into the list of ports. 	 * Keep ports sorted by if_index. It is handy, when configuration 	 * is predictable and `ifconfig laggN create ...` command 	 * will lead to the same result each time. 	 */
name|SLIST_FOREACH
argument_list|(
argument|tlp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
if|if
condition|(
name|tlp
operator|->
name|lp_ifp
operator|->
name|if_index
operator|<
name|ifp
operator|->
name|if_index
operator|&&
operator|(
name|SLIST_NEXT
argument_list|(
name|tlp
argument_list|,
name|lp_entries
argument_list|)
operator|==
name|NULL
operator|||
name|SLIST_NEXT
argument_list|(
name|tlp
argument_list|,
name|lp_entries
argument_list|)
operator|->
name|lp_ifp
operator|->
name|if_index
operator|>
name|ifp
operator|->
name|if_index
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|tlp
operator|!=
name|NULL
condition|)
name|SLIST_INSERT_AFTER
argument_list|(
name|tlp
argument_list|,
name|lp
argument_list|,
name|lp_entries
argument_list|)
expr_stmt|;
else|else
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|,
name|lp
argument_list|,
name|lp_entries
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_count
operator|++
expr_stmt|;
comment|/* Update lagg capabilities */
name|lagg_capabilities
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lagg_linkstate
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Read port counters */
name|pval
operator|=
name|lp
operator|->
name|port_counters
operator|.
name|val
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IFCOUNTERS
condition|;
name|i
operator|++
operator|,
name|pval
operator|++
control|)
operator|*
name|pval
operator|=
name|ifp
operator|->
name|if_get_counter
argument_list|(
name|ifp
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Add multicast addresses and interface flags to this port */
name|lagg_ether_cmdmulti
argument_list|(
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lagg_setflags
argument_list|(
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|lagg_proto_addport
argument_list|(
name|sc
argument_list|,
name|lp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Remove the port, without calling pr_delport. */
name|lagg_port_destroy
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|LAGG_PORT_STACKING
end_ifdef

begin_function
specifier|static
name|int
name|lagg_port_checkstacking
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc_ptr
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|int
name|m
init|=
literal|0
decl_stmt|;
name|LAGG_WLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
if|if
condition|(
name|lp
operator|->
name|lp_flags
operator|&
name|LAGG_PORT_STACK
condition|)
block|{
name|sc_ptr
operator|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|lp
operator|->
name|lp_ifp
operator|->
name|if_softc
expr_stmt|;
name|m
operator|=
name|MAX
argument_list|(
name|m
argument_list|,
name|lagg_port_checkstacking
argument_list|(
name|sc_ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|m
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|lagg_port_destroy
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|int
name|rundelport
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|lp
operator|->
name|lp_softc
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp_ptr
decl_stmt|,
modifier|*
name|lp0
decl_stmt|;
name|struct
name|lagg_llq
modifier|*
name|llq
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|lp
operator|->
name|lp_ifp
decl_stmt|;
name|uint64_t
modifier|*
name|pval
decl_stmt|,
name|vdiff
decl_stmt|;
name|int
name|i
decl_stmt|;
name|LAGG_WLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rundelport
condition|)
name|lagg_proto_delport
argument_list|(
name|sc
argument_list|,
name|lp
argument_list|)
expr_stmt|;
comment|/* 	 * Remove multicast addresses and interface flags from this port and 	 * reset the MAC address, skip if the interface is being detached. 	 */
if|if
condition|(
operator|!
name|lp
operator|->
name|lp_detaching
condition|)
block|{
name|lagg_ether_cmdmulti
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lagg_setflags
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lagg_port_lladdr
argument_list|(
name|lp
argument_list|,
name|lp
operator|->
name|lp_lladdr
argument_list|,
name|LAGG_LLQTYPE_PHYS
argument_list|)
expr_stmt|;
block|}
comment|/* Restore interface */
name|ifp
operator|->
name|if_type
operator|=
name|lp
operator|->
name|lp_iftype
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|lp
operator|->
name|lp_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|lp
operator|->
name|lp_output
expr_stmt|;
name|ifp
operator|->
name|if_lagg
operator|=
name|NULL
expr_stmt|;
comment|/* Update detached port counters */
name|pval
operator|=
name|lp
operator|->
name|port_counters
operator|.
name|val
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IFCOUNTERS
condition|;
name|i
operator|++
operator|,
name|pval
operator|++
control|)
block|{
name|vdiff
operator|=
name|ifp
operator|->
name|if_get_counter
argument_list|(
name|ifp
argument_list|,
name|i
argument_list|)
operator|-
operator|*
name|pval
expr_stmt|;
name|sc
operator|->
name|detached_counters
operator|.
name|val
index|[
name|i
index|]
operator|+=
name|vdiff
expr_stmt|;
block|}
comment|/* Finally, remove the port from the lagg */
name|SLIST_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|,
name|lp
argument_list|,
name|lagg_port
argument_list|,
name|lp_entries
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_count
operator|--
expr_stmt|;
comment|/* Update the primary interface */
if|if
condition|(
name|lp
operator|==
name|sc
operator|->
name|sc_primary
condition|)
block|{
name|uint8_t
name|lladdr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|lp0
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|lladdr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|lp0
operator|->
name|lp_lladdr
argument_list|,
name|lladdr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
name|lagg_lladdr
argument_list|(
name|sc
argument_list|,
name|lladdr
argument_list|)
expr_stmt|;
comment|/* Mark lp0 as new primary */
name|sc
operator|->
name|sc_primary
operator|=
name|lp0
expr_stmt|;
comment|/* 		 * Enqueue lladdr update/notification for each port 		 * (new primary needs update as well, to switch from 		 * old lladdr to its 'real' one). 		 */
name|SLIST_FOREACH
argument_list|(
argument|lp_ptr
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|lagg_port_lladdr
argument_list|(
name|lp_ptr
argument_list|,
name|lladdr
argument_list|,
name|LAGG_LLQTYPE_PHYS
argument_list|)
expr_stmt|;
block|}
comment|/* Remove any pending lladdr changes from the queue */
if|if
condition|(
name|lp
operator|->
name|lp_detaching
condition|)
block|{
name|SLIST_FOREACH
argument_list|(
argument|llq
argument_list|,
argument|&sc->sc_llq_head
argument_list|,
argument|llq_entries
argument_list|)
block|{
if|if
condition|(
name|llq
operator|->
name|llq_ifp
operator|==
name|ifp
condition|)
block|{
name|SLIST_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_llq_head
argument_list|,
name|llq
argument_list|,
name|lagg_llq
argument_list|,
name|llq_entries
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|llq
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
comment|/* Only appears once */
block|}
block|}
block|}
if|if
condition|(
name|lp
operator|->
name|lp_ifflags
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: lp_ifflags unclean\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* Update lagg capabilities */
name|lagg_capabilities
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lagg_linkstate
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_port_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|lagg_reqport
modifier|*
name|rp
init|=
operator|(
expr|struct
name|lagg_reqport
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|lagg_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
comment|/* Should be checked by the caller */
if|if
condition|(
name|ifp
operator|->
name|if_type
operator|!=
name|IFT_IEEE8023ADLAG
operator|||
operator|(
name|lp
operator|=
name|ifp
operator|->
name|if_lagg
operator|)
operator|==
name|NULL
operator|||
operator|(
name|sc
operator|=
name|lp
operator|->
name|lp_softc
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|fallback
goto|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCGLAGGPORT
case|:
if|if
condition|(
name|rp
operator|->
name|rp_portname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|ifunit
argument_list|(
name|rp
operator|->
name|rp_portname
argument_list|)
operator|!=
name|ifp
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|LAGG_RLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lp
operator|=
name|ifp
operator|->
name|if_lagg
operator|)
operator|==
name|NULL
operator|||
name|lp
operator|->
name|lp_softc
operator|!=
name|sc
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
break|break;
block|}
name|lagg_port2req
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
if|if
condition|(
name|lp
operator|->
name|lp_ioctl
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
call|(
modifier|*
name|lp
operator|->
name|lp_ioctl
call|)
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
comment|/* Update lagg interface capabilities */
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lagg_capabilities
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
comment|/* Do not allow the MTU to be changed once joined */
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
default|default:
goto|goto
name|fallback
goto|;
block|}
return|return
operator|(
name|error
operator|)
return|;
name|fallback
label|:
if|if
condition|(
name|lp
operator|->
name|lp_ioctl
operator|!=
name|NULL
condition|)
return|return
operator|(
call|(
modifier|*
name|lp
operator|->
name|lp_ioctl
call|)
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
operator|)
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Requests counter @cnt data.   *  * Counter value is calculated the following way:  * 1) for each port, sum  difference between current and "initial" measurements.  * 2) add lagg logical interface counters.  * 3) add data from detached_counters array.  *  * We also do the following things on ports attach/detach:  * 1) On port attach we store all counters it has into port_counter array.   * 2) On port detach we add the different between "initial" and  *   current counters data to detached_counters array.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|lagg_get_counter
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|ift_counter
name|cnt
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|lpifp
decl_stmt|;
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
name|uint64_t
name|newval
decl_stmt|,
name|oldval
decl_stmt|,
name|vsum
decl_stmt|;
comment|/* Revise this when we've got non-generic counters. */
name|KASSERT
argument_list|(
name|cnt
operator|<
name|IFCOUNTERS
argument_list|,
operator|(
literal|"%s: invalid cnt %d"
operator|,
name|__func__
operator|,
name|cnt
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|LAGG_RLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|vsum
operator|=
literal|0
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
comment|/* Saved attached value */
name|oldval
operator|=
name|lp
operator|->
name|port_counters
operator|.
name|val
index|[
name|cnt
index|]
expr_stmt|;
comment|/* current value */
name|lpifp
operator|=
name|lp
operator|->
name|lp_ifp
expr_stmt|;
name|newval
operator|=
name|lpifp
operator|->
name|if_get_counter
argument_list|(
name|lpifp
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
comment|/* Calculate diff and save new */
name|vsum
operator|+=
name|newval
operator|-
name|oldval
expr_stmt|;
block|}
comment|/* 	 * Add counter data which might be added by upper 	 * layer protocols operating on logical interface. 	 */
name|vsum
operator|+=
name|if_get_counter_default
argument_list|(
name|ifp
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
comment|/* 	 * Add counter data from detached ports counters 	 */
name|vsum
operator|+=
name|sc
operator|->
name|detached_counters
operator|.
name|val
index|[
name|cnt
index|]
expr_stmt|;
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
return|return
operator|(
name|vsum
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For direct output to child ports.  */
end_comment

begin_function
specifier|static
name|int
name|lagg_port_output
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|route
modifier|*
name|ro
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
init|=
name|ifp
operator|->
name|if_lagg
decl_stmt|;
switch|switch
condition|(
name|dst
operator|->
name|sa_family
condition|)
block|{
case|case
name|pseudo_AF_HDRCMPLT
case|:
case|case
name|AF_UNSPEC
case|:
return|return
operator|(
call|(
modifier|*
name|lp
operator|->
name|lp_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
name|ro
argument_list|)
operator|)
return|;
block|}
comment|/* drop any other frames */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_port_ifdetach
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|struct
name|lagg_softc
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
operator|(
name|lp
operator|=
name|ifp
operator|->
name|if_lagg
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* If the ifnet is just being renamed, don't do anything. */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RENAMING
condition|)
return|return;
name|sc
operator|=
name|lp
operator|->
name|lp_softc
expr_stmt|;
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lp
operator|->
name|lp_detaching
operator|=
literal|1
expr_stmt|;
name|lagg_port_destroy
argument_list|(
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_port2req
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|struct
name|lagg_reqport
modifier|*
name|rp
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|lp
operator|->
name|lp_softc
decl_stmt|;
name|strlcpy
argument_list|(
name|rp
operator|->
name|rp_ifname
argument_list|,
name|sc
operator|->
name|sc_ifname
argument_list|,
sizeof|sizeof
argument_list|(
name|rp
operator|->
name|rp_ifname
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|rp
operator|->
name|rp_portname
argument_list|,
name|lp
operator|->
name|lp_ifp
operator|->
name|if_xname
argument_list|,
sizeof|sizeof
argument_list|(
name|rp
operator|->
name|rp_portname
argument_list|)
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rp_prio
operator|=
name|lp
operator|->
name|lp_prio
expr_stmt|;
name|rp
operator|->
name|rp_flags
operator|=
name|lp
operator|->
name|lp_flags
expr_stmt|;
name|lagg_proto_portreq
argument_list|(
name|sc
argument_list|,
name|lp
argument_list|,
operator|&
name|rp
operator|->
name|rp_psc
argument_list|)
expr_stmt|;
comment|/* Add protocol specific flags */
switch|switch
condition|(
name|sc
operator|->
name|sc_proto
condition|)
block|{
case|case
name|LAGG_PROTO_FAILOVER
case|:
if|if
condition|(
name|lp
operator|==
name|sc
operator|->
name|sc_primary
condition|)
name|rp
operator|->
name|rp_flags
operator||=
name|LAGG_PORT_MASTER
expr_stmt|;
if|if
condition|(
name|lp
operator|==
name|lagg_link_active
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_primary
argument_list|)
condition|)
name|rp
operator|->
name|rp_flags
operator||=
name|LAGG_PORT_ACTIVE
expr_stmt|;
break|break;
case|case
name|LAGG_PROTO_ROUNDROBIN
case|:
case|case
name|LAGG_PROTO_LOADBALANCE
case|:
case|case
name|LAGG_PROTO_BROADCAST
case|:
if|if
condition|(
name|LAGG_PORTACTIVE
argument_list|(
name|lp
argument_list|)
condition|)
name|rp
operator|->
name|rp_flags
operator||=
name|LAGG_PORT_ACTIVE
expr_stmt|;
break|break;
case|case
name|LAGG_PROTO_LACP
case|:
comment|/* LACP has a different definition of active */
if|if
condition|(
name|lacp_isactive
argument_list|(
name|lp
argument_list|)
condition|)
name|rp
operator|->
name|rp_flags
operator||=
name|LAGG_PORT_ACTIVE
expr_stmt|;
if|if
condition|(
name|lacp_iscollecting
argument_list|(
name|lp
argument_list|)
condition|)
name|rp
operator|->
name|rp_flags
operator||=
name|LAGG_PORT_COLLECTING
expr_stmt|;
if|if
condition|(
name|lacp_isdistributing
argument_list|(
name|lp
argument_list|)
condition|)
name|rp
operator|->
name|rp_flags
operator||=
name|LAGG_PORT_DISTRIBUTING
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
return|return;
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
comment|/* 	 * Update the port lladdrs if needed. 	 * This might be if_setlladdr() notification 	 * that lladdr has been changed. 	 */
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|lagg_port_lladdr
argument_list|(
name|lp
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|LAGG_LLQTYPE_PHYS
argument_list|)
expr_stmt|;
name|lagg_proto_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_stop
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|LAGG_WLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|lagg_proto_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|lagg_reqall
modifier|*
name|ra
init|=
operator|(
expr|struct
name|lagg_reqall
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|lagg_reqopts
modifier|*
name|ro
init|=
operator|(
expr|struct
name|lagg_reqopts
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|lagg_reqport
modifier|*
name|rp
init|=
operator|(
expr|struct
name|lagg_reqport
operator|*
operator|)
name|data
decl_stmt|,
name|rpbuf
decl_stmt|;
name|struct
name|lagg_reqflags
modifier|*
name|rf
init|=
operator|(
expr|struct
name|lagg_reqflags
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|tpif
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|outbuf
decl_stmt|;
name|int
name|count
decl_stmt|,
name|buflen
decl_stmt|,
name|len
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|rpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|rpbuf
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCGLAGG
case|:
name|LAGG_RLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|count
operator|++
expr_stmt|;
name|buflen
operator|=
name|count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|lagg_reqport
argument_list|)
expr_stmt|;
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|outbuf
operator|=
name|malloc
argument_list|(
name|buflen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|LAGG_RLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|ra
operator|->
name|ra_proto
operator|=
name|sc
operator|->
name|sc_proto
expr_stmt|;
name|lagg_proto_request
argument_list|(
name|sc
argument_list|,
operator|&
name|ra
operator|->
name|ra_psc
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|outbuf
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|ra
operator|->
name|ra_size
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|rpbuf
argument_list|)
condition|)
break|break;
name|lagg_port2req
argument_list|(
name|lp
argument_list|,
operator|&
name|rpbuf
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|rpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|rpbuf
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|rpbuf
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
name|rpbuf
argument_list|)
expr_stmt|;
block|}
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|ra
operator|->
name|ra_ports
operator|=
name|count
expr_stmt|;
name|ra
operator|->
name|ra_size
operator|=
name|count
operator|*
sizeof|sizeof
argument_list|(
name|rpbuf
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|outbuf
argument_list|,
name|ra
operator|->
name|ra_port
argument_list|,
name|ra
operator|->
name|ra_size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|outbuf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSLAGG
case|:
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NET_LAGG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|ra
operator|->
name|ra_proto
operator|<
literal|1
operator|||
name|ra
operator|->
name|ra_proto
operator|>=
name|LAGG_PROTO_MAX
condition|)
block|{
name|error
operator|=
name|EPROTONOSUPPORT
expr_stmt|;
break|break;
block|}
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lagg_proto_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LAGG_UNLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lagg_proto_attach
argument_list|(
name|sc
argument_list|,
name|ra
operator|->
name|ra_proto
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGLAGGOPTS
case|:
name|ro
operator|->
name|ro_opts
operator|=
name|sc
operator|->
name|sc_opts
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_proto
operator|==
name|LAGG_PROTO_LACP
condition|)
block|{
name|struct
name|lacp_softc
modifier|*
name|lsc
decl_stmt|;
name|lsc
operator|=
operator|(
expr|struct
name|lacp_softc
operator|*
operator|)
name|sc
operator|->
name|sc_psc
expr_stmt|;
if|if
condition|(
name|lsc
operator|->
name|lsc_debug
operator|.
name|lsc_tx_test
operator|!=
literal|0
condition|)
name|ro
operator|->
name|ro_opts
operator||=
name|LAGG_OPT_LACP_TXTEST
expr_stmt|;
if|if
condition|(
name|lsc
operator|->
name|lsc_debug
operator|.
name|lsc_rx_test
operator|!=
literal|0
condition|)
name|ro
operator|->
name|ro_opts
operator||=
name|LAGG_OPT_LACP_RXTEST
expr_stmt|;
if|if
condition|(
name|lsc
operator|->
name|lsc_strict_mode
operator|!=
literal|0
condition|)
name|ro
operator|->
name|ro_opts
operator||=
name|LAGG_OPT_LACP_STRICT
expr_stmt|;
if|if
condition|(
name|lsc
operator|->
name|lsc_fast_timeout
operator|!=
literal|0
condition|)
name|ro
operator|->
name|ro_opts
operator||=
name|LAGG_OPT_LACP_TIMEOUT
expr_stmt|;
name|ro
operator|->
name|ro_active
operator|=
name|sc
operator|->
name|sc_active
expr_stmt|;
block|}
else|else
block|{
name|ro
operator|->
name|ro_active
operator|=
literal|0
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|ro
operator|->
name|ro_active
operator|+=
name|LAGG_PORTACTIVE
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
name|ro
operator|->
name|ro_flapping
operator|=
name|sc
operator|->
name|sc_flapping
expr_stmt|;
name|ro
operator|->
name|ro_flowid_shift
operator|=
name|sc
operator|->
name|flowid_shift
expr_stmt|;
break|break;
case|case
name|SIOCSLAGGOPTS
case|:
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NET_LAGG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|ro
operator|->
name|ro_opts
operator|==
literal|0
condition|)
break|break;
comment|/* 		 * Set options.  LACP options are stored in sc->sc_psc, 		 * not in sc_opts. 		 */
name|int
name|valid
decl_stmt|,
name|lacp
decl_stmt|;
switch|switch
condition|(
name|ro
operator|->
name|ro_opts
condition|)
block|{
case|case
name|LAGG_OPT_USE_FLOWID
case|:
case|case
operator|-
name|LAGG_OPT_USE_FLOWID
case|:
case|case
name|LAGG_OPT_FLOWIDSHIFT
case|:
name|valid
operator|=
literal|1
expr_stmt|;
name|lacp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LAGG_OPT_LACP_TXTEST
case|:
case|case
operator|-
name|LAGG_OPT_LACP_TXTEST
case|:
case|case
name|LAGG_OPT_LACP_RXTEST
case|:
case|case
operator|-
name|LAGG_OPT_LACP_RXTEST
case|:
case|case
name|LAGG_OPT_LACP_STRICT
case|:
case|case
operator|-
name|LAGG_OPT_LACP_STRICT
case|:
case|case
name|LAGG_OPT_LACP_TIMEOUT
case|:
case|case
operator|-
name|LAGG_OPT_LACP_TIMEOUT
case|:
name|valid
operator|=
name|lacp
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|valid
operator|=
name|lacp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|valid
operator|==
literal|0
operator|||
operator|(
name|lacp
operator|==
literal|1
operator|&&
name|sc
operator|->
name|sc_proto
operator|!=
name|LAGG_PROTO_LACP
operator|)
condition|)
block|{
comment|/* Invalid combination of options specified. */
name|error
operator|=
name|EINVAL
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
comment|/* Return from SIOCSLAGGOPTS. */
block|}
comment|/* 		 * Store new options into sc->sc_opts except for 		 * FLOWIDSHIFT and LACP options. 		 */
if|if
condition|(
name|lacp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ro
operator|->
name|ro_opts
operator|==
name|LAGG_OPT_FLOWIDSHIFT
condition|)
name|sc
operator|->
name|flowid_shift
operator|=
name|ro
operator|->
name|ro_flowid_shift
expr_stmt|;
elseif|else
if|if
condition|(
name|ro
operator|->
name|ro_opts
operator|>
literal|0
condition|)
name|sc
operator|->
name|sc_opts
operator||=
name|ro
operator|->
name|ro_opts
expr_stmt|;
else|else
name|sc
operator|->
name|sc_opts
operator|&=
operator|~
name|ro
operator|->
name|ro_opts
expr_stmt|;
block|}
else|else
block|{
name|struct
name|lacp_softc
modifier|*
name|lsc
decl_stmt|;
name|struct
name|lacp_port
modifier|*
name|lp
decl_stmt|;
name|lsc
operator|=
operator|(
expr|struct
name|lacp_softc
operator|*
operator|)
name|sc
operator|->
name|sc_psc
expr_stmt|;
switch|switch
condition|(
name|ro
operator|->
name|ro_opts
condition|)
block|{
case|case
name|LAGG_OPT_LACP_TXTEST
case|:
name|lsc
operator|->
name|lsc_debug
operator|.
name|lsc_tx_test
operator|=
literal|1
expr_stmt|;
break|break;
case|case
operator|-
name|LAGG_OPT_LACP_TXTEST
case|:
name|lsc
operator|->
name|lsc_debug
operator|.
name|lsc_tx_test
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LAGG_OPT_LACP_RXTEST
case|:
name|lsc
operator|->
name|lsc_debug
operator|.
name|lsc_rx_test
operator|=
literal|1
expr_stmt|;
break|break;
case|case
operator|-
name|LAGG_OPT_LACP_RXTEST
case|:
name|lsc
operator|->
name|lsc_debug
operator|.
name|lsc_rx_test
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LAGG_OPT_LACP_STRICT
case|:
name|lsc
operator|->
name|lsc_strict_mode
operator|=
literal|1
expr_stmt|;
break|break;
case|case
operator|-
name|LAGG_OPT_LACP_STRICT
case|:
name|lsc
operator|->
name|lsc_strict_mode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|LAGG_OPT_LACP_TIMEOUT
case|:
name|LACP_LOCK
argument_list|(
name|lsc
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&lsc->lsc_ports
argument_list|,
argument|lp_next
argument_list|)
name|lp
operator|->
name|lp_state
operator||=
name|LACP_STATE_TIMEOUT
expr_stmt|;
name|LACP_UNLOCK
argument_list|(
name|lsc
argument_list|)
expr_stmt|;
name|lsc
operator|->
name|lsc_fast_timeout
operator|=
literal|1
expr_stmt|;
break|break;
case|case
operator|-
name|LAGG_OPT_LACP_TIMEOUT
case|:
name|LACP_LOCK
argument_list|(
name|lsc
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&lsc->lsc_ports
argument_list|,
argument|lp_next
argument_list|)
name|lp
operator|->
name|lp_state
operator|&=
operator|~
name|LACP_STATE_TIMEOUT
expr_stmt|;
name|LACP_UNLOCK
argument_list|(
name|lsc
argument_list|)
expr_stmt|;
name|lsc
operator|->
name|lsc_fast_timeout
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGLAGGFLAGS
case|:
name|rf
operator|->
name|rf_flags
operator|=
literal|0
expr_stmt|;
name|LAGG_RLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|MBUF_HASHFLAG_L2
condition|)
name|rf
operator|->
name|rf_flags
operator||=
name|LAGG_F_HASHL2
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|MBUF_HASHFLAG_L3
condition|)
name|rf
operator|->
name|rf_flags
operator||=
name|LAGG_F_HASHL3
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|MBUF_HASHFLAG_L4
condition|)
name|rf
operator|->
name|rf_flags
operator||=
name|LAGG_F_HASHL4
expr_stmt|;
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSLAGGHASH
case|:
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NET_LAGG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
operator|(
name|rf
operator|->
name|rf_flags
operator|&
name|LAGG_F_HASHMASK
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rf
operator|->
name|rf_flags
operator|&
name|LAGG_F_HASHL2
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|MBUF_HASHFLAG_L2
expr_stmt|;
if|if
condition|(
name|rf
operator|->
name|rf_flags
operator|&
name|LAGG_F_HASHL3
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|MBUF_HASHFLAG_L3
expr_stmt|;
if|if
condition|(
name|rf
operator|->
name|rf_flags
operator|&
name|LAGG_F_HASHL4
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|MBUF_HASHFLAG_L4
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGLAGGPORT
case|:
if|if
condition|(
name|rp
operator|->
name|rp_portname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|tpif
operator|=
name|ifunit
argument_list|(
name|rp
operator|->
name|rp_portname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|LAGG_RLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lp
operator|=
operator|(
expr|struct
name|lagg_port
operator|*
operator|)
name|tpif
operator|->
name|if_lagg
operator|)
operator|==
name|NULL
operator|||
name|lp
operator|->
name|lp_softc
operator|!=
name|sc
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
break|break;
block|}
name|lagg_port2req
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSLAGGPORT
case|:
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NET_LAGG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|rp
operator|->
name|rp_portname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|tpif
operator|=
name|ifunit
argument_list|(
name|rp
operator|->
name|rp_portname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|INET6
comment|/* 		 * A laggport interface should not have inet6 address 		 * because two interfaces with a valid link-local 		 * scope zone must not be merged in any form.  This 		 * restriction is needed to prevent violation of 		 * link-local scope zone.  Attempts to add a laggport 		 * interface which has inet6 addresses triggers 		 * removal of all inet6 addresses on the member 		 * interface. 		 */
if|if
condition|(
name|in6ifa_llaonifp
argument_list|(
name|tpif
argument_list|)
condition|)
block|{
name|in6_ifdetach
argument_list|(
name|tpif
argument_list|)
expr_stmt|;
name|if_printf
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
literal|"IPv6 addresses on %s have been removed "
literal|"before adding it as a member to prevent "
literal|"IPv6 address scope violation.\n"
argument_list|,
name|tpif
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|lagg_port_create
argument_list|(
name|sc
argument_list|,
name|tpif
argument_list|)
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSLAGGDELPORT
case|:
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NET_LAGG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|rp
operator|->
name|rp_portname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|tpif
operator|=
name|ifunit
argument_list|(
name|rp
operator|->
name|rp_portname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lp
operator|=
operator|(
expr|struct
name|lagg_port
operator|*
operator|)
name|tpif
operator|->
name|if_lagg
operator|)
operator|==
name|NULL
operator|||
name|lp
operator|->
name|lp_softc
operator|!=
name|sc
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|lagg_port_destroy
argument_list|(
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/* Set flags on ports too */
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
name|lagg_setflags
argument_list|(
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
comment|/* 			 * If interface is marked down and it is running, 			 * then stop and disable it. 			 */
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lagg_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
comment|/* 			 * If interface is marked up and it is stopped, then 			 * start it. 			 */
call|(
modifier|*
name|ifp
operator|->
name|if_init
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|lagg_ether_setmulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFCAP
case|:
case|case
name|SIOCSIFMTU
case|:
comment|/* Do not allow the MTU or caps to be directly changed */
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_ether_setmulti
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|LAGG_WLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
comment|/* First, remove any existing filter entries. */
name|lagg_ether_cmdmulti
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* copy all addresses from the lagg interface to the port */
name|lagg_ether_cmdmulti
argument_list|(
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_ether_cmdmulti
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|int
name|set
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|lp
operator|->
name|lp_softc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|lp
operator|->
name|lp_ifp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|scifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|lagg_mc
modifier|*
name|mc
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|int
name|error
decl_stmt|;
name|LAGG_WLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
name|IF_ADDR_WLOCK
argument_list|(
name|scifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&scifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|mc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lagg_mc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|==
name|NULL
condition|)
block|{
name|IF_ADDR_WUNLOCK
argument_list|(
name|scifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|ifma
operator|->
name|ifma_addr
argument_list|,
operator|&
name|mc
operator|->
name|mc_addr
argument_list|,
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|mc
operator|->
name|mc_addr
operator|.
name|sdl_index
operator|=
name|ifp
operator|->
name|if_index
expr_stmt|;
name|mc
operator|->
name|mc_ifma
operator|=
name|NULL
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|lp
operator|->
name|lp_mc_head
argument_list|,
name|mc
argument_list|,
name|mc_entries
argument_list|)
expr_stmt|;
block|}
name|IF_ADDR_WUNLOCK
argument_list|(
name|scifp
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|mc
argument_list|,
argument|&lp->lp_mc_head
argument_list|,
argument|mc_entries
argument_list|)
block|{
name|error
operator|=
name|if_addmulti
argument_list|(
name|ifp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|mc
operator|->
name|mc_addr
argument_list|,
operator|&
name|mc
operator|->
name|mc_ifma
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|(
name|mc
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|lp
operator|->
name|lp_mc_head
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE
argument_list|(
operator|&
name|lp
operator|->
name|lp_mc_head
argument_list|,
name|mc
argument_list|,
name|lagg_mc
argument_list|,
name|mc_entries
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|mc_ifma
operator|&&
operator|!
name|lp
operator|->
name|lp_detaching
condition|)
name|if_delmulti_ifma
argument_list|(
name|mc
operator|->
name|mc_ifma
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Handle a ref counted flag that should be set on the lagg port as well */
end_comment

begin_function
specifier|static
name|int
name|lagg_setflag
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|status
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|lp
operator|->
name|lp_softc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|scifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|lp
operator|->
name|lp_ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|LAGG_WLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|status
operator|=
name|status
condition|?
operator|(
name|scifp
operator|->
name|if_flags
operator|&
name|flag
operator|)
else|:
literal|0
expr_stmt|;
comment|/* Now "status" contains the flag value or 0 */
comment|/* 	 * See if recorded ports status is different from what 	 * we want it to be.  If it is, flip it.  We record ports 	 * status in lp_ifflags so that we won't clear ports flag 	 * we haven't set.  In fact, we don't clear or set ports 	 * flags directly, but get or release references to them. 	 * That's why we can be sure that recorded flags still are 	 * in accord with actual ports flags. 	 */
if|if
condition|(
name|status
operator|!=
operator|(
name|lp
operator|->
name|lp_ifflags
operator|&
name|flag
operator|)
condition|)
block|{
name|error
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|ifp
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|lp
operator|->
name|lp_ifflags
operator|&=
operator|~
name|flag
expr_stmt|;
name|lp
operator|->
name|lp_ifflags
operator||=
name|status
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle IFF_* flags that require certain changes on the lagg port  * if "status" is true, update ports flags respective to the lagg  * if "status" is false, forcedly clear the flags set on port.  */
end_comment

begin_function
specifier|static
name|int
name|lagg_setflags
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|lagg_pflags
index|[
name|i
index|]
operator|.
name|flag
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|lagg_setflag
argument_list|(
name|lp
argument_list|,
name|lagg_pflags
index|[
name|i
index|]
operator|.
name|flag
argument_list|,
name|status
argument_list|,
name|lagg_pflags
index|[
name|i
index|]
operator|.
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|,
name|mcast
decl_stmt|;
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|mcast
operator|=
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_MCAST
operator||
name|M_BCAST
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|LAGG_RLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
comment|/* We need a Tx algorithm and at least one port */
if|if
condition|(
name|sc
operator|->
name|sc_proto
operator|==
name|LAGG_PROTO_NONE
operator|||
name|sc
operator|->
name|sc_count
operator|==
literal|0
condition|)
block|{
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|lagg_proto_start
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The ifp->if_qflush entry point for lagg(4) is no-op.  */
end_comment

begin_function
specifier|static
name|void
name|lagg_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
name|__unused
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_input
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
init|=
name|ifp
operator|->
name|if_lagg
decl_stmt|;
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|lp
operator|->
name|lp_softc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|scifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
name|LAGG_RLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
operator|(
name|lp
operator|->
name|lp_flags
operator|&
name|LAGG_PORT_DISABLED
operator|)
operator|||
name|sc
operator|->
name|sc_proto
operator|==
name|LAGG_PROTO_NONE
condition|)
block|{
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ETHER_BPF_MTAP
argument_list|(
name|scifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|lp_detaching
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|m
operator|=
name|lagg_proto_input
argument_list|(
name|sc
argument_list|,
name|lp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|scifp
operator|->
name|if_flags
operator|&
name|IFF_MONITOR
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ifflags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Ignore */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|imr
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
name|imr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|imr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
expr_stmt|;
name|LAGG_RLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
if|if
condition|(
name|LAGG_PORTACTIVE
argument_list|(
name|lp
argument_list|)
condition|)
name|imr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
block|}
name|LAGG_RUNLOCK
argument_list|(
name|sc
argument_list|,
operator|&
name|tracker
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_linkstate
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|int
name|new_link
init|=
name|LINK_STATE_DOWN
decl_stmt|;
name|uint64_t
name|speed
decl_stmt|;
comment|/* Our link is considered up if at least one of our ports is active */
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
if|if
condition|(
name|lp
operator|->
name|lp_ifp
operator|->
name|if_link_state
operator|==
name|LINK_STATE_UP
condition|)
block|{
name|new_link
operator|=
name|LINK_STATE_UP
expr_stmt|;
break|break;
block|}
block|}
name|if_link_state_change
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|,
name|new_link
argument_list|)
expr_stmt|;
comment|/* Update if_baudrate to reflect the max possible speed */
switch|switch
condition|(
name|sc
operator|->
name|sc_proto
condition|)
block|{
case|case
name|LAGG_PROTO_FAILOVER
case|:
name|sc
operator|->
name|sc_ifp
operator|->
name|if_baudrate
operator|=
name|sc
operator|->
name|sc_primary
operator|!=
name|NULL
condition|?
name|sc
operator|->
name|sc_primary
operator|->
name|lp_ifp
operator|->
name|if_baudrate
else|:
literal|0
expr_stmt|;
break|break;
case|case
name|LAGG_PROTO_ROUNDROBIN
case|:
case|case
name|LAGG_PROTO_LOADBALANCE
case|:
case|case
name|LAGG_PROTO_BROADCAST
case|:
name|speed
operator|=
literal|0
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|speed
operator|+=
name|lp
operator|->
name|lp_ifp
operator|->
name|if_baudrate
expr_stmt|;
name|sc
operator|->
name|sc_ifp
operator|->
name|if_baudrate
operator|=
name|speed
expr_stmt|;
break|break;
case|case
name|LAGG_PROTO_LACP
case|:
comment|/* LACP updates if_baudrate itself */
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_port_state
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
init|=
operator|(
expr|struct
name|lagg_port
operator|*
operator|)
name|ifp
operator|->
name|if_lagg
decl_stmt|;
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|lp
operator|!=
name|NULL
condition|)
name|sc
operator|=
name|lp
operator|->
name|lp_softc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|LAGG_WLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lagg_linkstate
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lagg_proto_linkstate
argument_list|(
name|sc
argument_list|,
name|lp
argument_list|)
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|lagg_port
modifier|*
name|lagg_link_active
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp_next
decl_stmt|,
modifier|*
name|rval
init|=
name|NULL
decl_stmt|;
comment|// int new_link = LINK_STATE_DOWN;
name|LAGG_RLOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Search a port which reports an active link state. 	 */
if|if
condition|(
name|lp
operator|==
name|NULL
condition|)
goto|goto
name|search
goto|;
if|if
condition|(
name|LAGG_PORTACTIVE
argument_list|(
name|lp
argument_list|)
condition|)
block|{
name|rval
operator|=
name|lp
expr_stmt|;
goto|goto
name|found
goto|;
block|}
if|if
condition|(
operator|(
name|lp_next
operator|=
name|SLIST_NEXT
argument_list|(
name|lp
argument_list|,
name|lp_entries
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|LAGG_PORTACTIVE
argument_list|(
name|lp_next
argument_list|)
condition|)
block|{
name|rval
operator|=
name|lp_next
expr_stmt|;
goto|goto
name|found
goto|;
block|}
name|search
label|:
name|SLIST_FOREACH
argument_list|(
argument|lp_next
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
if|if
condition|(
name|LAGG_PORTACTIVE
argument_list|(
name|lp_next
argument_list|)
condition|)
block|{
name|rval
operator|=
name|lp_next
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
name|found
label|:
if|if
condition|(
name|rval
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * The IEEE 802.1D standard assumes that a lagg with 		 * multiple ports is always full duplex. This is valid 		 * for load sharing laggs and if at least two links 		 * are active. Unfortunately, checking the latter would 		 * be too expensive at this point. 		 XXX 		if ((sc->sc_capabilities& IFCAP_LAGG_FULLDUPLEX)&& 		    (sc->sc_count> 1)) 			new_link = LINK_STATE_FULL_DUPLEX; 		else 			new_link = rval->lp_link_state; 		 */
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lagg_enqueue
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
call|(
name|ifp
operator|->
name|if_transmit
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Simple round robin aggregation  */
end_comment

begin_function
specifier|static
name|void
name|lagg_rr_attach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|sc_capabilities
operator|=
name|IFCAP_LAGG_FULLDUPLEX
expr_stmt|;
name|sc
operator|->
name|sc_seq
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_rr_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|uint32_t
name|p
decl_stmt|;
name|p
operator|=
name|atomic_fetchadd_32
argument_list|(
operator|&
name|sc
operator|->
name|sc_seq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|%=
name|sc
operator|->
name|sc_count
expr_stmt|;
name|lp
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|--
condition|)
name|lp
operator|=
name|SLIST_NEXT
argument_list|(
name|lp
argument_list|,
name|lp_entries
argument_list|)
expr_stmt|;
comment|/* 	 * Check the port's link state. This will return the next active 	 * port if the link is down or the port is NULL. 	 */
if|if
condition|(
operator|(
name|lp
operator|=
name|lagg_link_active
argument_list|(
name|sc
argument_list|,
name|lp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
comment|/* Send mbuf */
return|return
operator|(
name|lagg_enqueue
argument_list|(
name|lp
operator|->
name|lp_ifp
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_rr_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
comment|/* Just pass in the packet to our lagg device */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Broadcast mode  */
end_comment

begin_function
specifier|static
name|int
name|lagg_bcast_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|active_ports
init|=
literal|0
decl_stmt|;
name|int
name|errors
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|,
modifier|*
name|last
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
if|if
condition|(
operator|!
name|LAGG_PORTACTIVE
argument_list|(
name|lp
argument_list|)
condition|)
continue|continue;
name|active_ports
operator|++
expr_stmt|;
if|if
condition|(
name|last
operator|!=
name|NULL
condition|)
block|{
name|m0
operator|=
name|m_copym
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOBUFS
expr_stmt|;
name|errors
operator|++
expr_stmt|;
break|break;
block|}
name|ret
operator|=
name|lagg_enqueue
argument_list|(
name|last
operator|->
name|lp_ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|errors
operator|++
expr_stmt|;
block|}
name|last
operator|=
name|lp
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|last
operator|=
name|lagg_link_active
argument_list|(
name|sc
argument_list|,
name|last
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
name|ret
operator|=
name|lagg_enqueue
argument_list|(
name|last
operator|->
name|lp_ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|errors
operator|++
expr_stmt|;
if|if
condition|(
name|errors
operator|==
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_bcast_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
comment|/* Just pass in the packet to our lagg device */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Active failover  */
end_comment

begin_function
specifier|static
name|int
name|lagg_fail_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
comment|/* Use the master port if active or the next available port */
if|if
condition|(
operator|(
name|lp
operator|=
name|lagg_link_active
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_primary
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
comment|/* Send mbuf */
return|return
operator|(
name|lagg_enqueue
argument_list|(
name|lp
operator|->
name|lp_ifp
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_fail_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|tmp_tp
decl_stmt|;
if|if
condition|(
name|lp
operator|==
name|sc
operator|->
name|sc_primary
operator|||
name|V_lagg_failover_rx_all
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|LAGG_PORTACTIVE
argument_list|(
name|sc
operator|->
name|sc_primary
argument_list|)
condition|)
block|{
name|tmp_tp
operator|=
name|lagg_link_active
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_primary
argument_list|)
expr_stmt|;
comment|/* 		 * If tmp_tp is null, we've recieved a packet when all 		 * our links are down. Weird, but process it anyways. 		 */
if|if
condition|(
operator|(
name|tmp_tp
operator|==
name|NULL
operator|||
name|tmp_tp
operator|==
name|lp
operator|)
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Loadbalancing  */
end_comment

begin_function
specifier|static
name|void
name|lagg_lb_attach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|struct
name|lagg_lb
modifier|*
name|lb
decl_stmt|;
name|lb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lagg_lb
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_capabilities
operator|=
name|IFCAP_LAGG_FULLDUPLEX
expr_stmt|;
name|lb
operator|->
name|lb_key
operator|=
name|m_ether_tcpip_hash_init
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_psc
operator|=
name|lb
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|lagg_lb_port_create
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_lb_detach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_lb
modifier|*
name|lb
decl_stmt|;
name|lb
operator|=
operator|(
expr|struct
name|lagg_lb
operator|*
operator|)
name|sc
operator|->
name|sc_psc
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|lb
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|lb
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_lb_porttable
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|)
block|{
name|struct
name|lagg_lb
modifier|*
name|lb
init|=
operator|(
expr|struct
name|lagg_lb
operator|*
operator|)
name|sc
operator|->
name|sc_psc
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp_next
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|lb
operator|->
name|lb_ports
argument_list|,
sizeof|sizeof
argument_list|(
name|lb
operator|->
name|lb_ports
argument_list|)
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp_next
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
if|if
condition|(
name|lp_next
operator|==
name|lp
condition|)
continue|continue;
if|if
condition|(
name|i
operator|>=
name|LAGG_MAX_PORTS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_ifflags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: port %s at index %d\n"
argument_list|,
name|sc
operator|->
name|sc_ifname
argument_list|,
name|lp_next
operator|->
name|lp_ifp
operator|->
name|if_xname
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lb
operator|->
name|lb_ports
index|[
name|i
operator|++
index|]
operator|=
name|lp_next
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_lb_port_create
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|lp
operator|->
name|lp_softc
decl_stmt|;
return|return
operator|(
name|lagg_lb_porttable
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_lb_port_destroy
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|lp
operator|->
name|lp_softc
decl_stmt|;
name|lagg_lb_porttable
argument_list|(
name|sc
argument_list|,
name|lp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_lb_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|lagg_lb
modifier|*
name|lb
init|=
operator|(
expr|struct
name|lagg_lb
operator|*
operator|)
name|sc
operator|->
name|sc_psc
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|p
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_opts
operator|&
name|LAGG_OPT_USE_FLOWID
operator|)
operator|&&
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
operator|!=
name|M_HASHTYPE_NONE
condition|)
name|p
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|>>
name|sc
operator|->
name|flowid_shift
expr_stmt|;
else|else
name|p
operator|=
name|m_ether_tcpip_hash
argument_list|(
name|sc
operator|->
name|sc_flags
argument_list|,
name|m
argument_list|,
name|lb
operator|->
name|lb_key
argument_list|)
expr_stmt|;
name|p
operator|%=
name|sc
operator|->
name|sc_count
expr_stmt|;
name|lp
operator|=
name|lb
operator|->
name|lb_ports
index|[
name|p
index|]
expr_stmt|;
comment|/* 	 * Check the port's link state. This will return the next active 	 * port if the link is down or the port is NULL. 	 */
if|if
condition|(
operator|(
name|lp
operator|=
name|lagg_link_active
argument_list|(
name|sc
argument_list|,
name|lp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
comment|/* Send mbuf */
return|return
operator|(
name|lagg_enqueue
argument_list|(
name|lp
operator|->
name|lp_ifp
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_lb_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
comment|/* Just pass in the packet to our lagg device */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 802.3ad LACP  */
end_comment

begin_function
specifier|static
name|void
name|lagg_lacp_attach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|lacp_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|lacp_port_create
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_lacp_detach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|void
modifier|*
name|psc
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|lacp_port_destroy
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|psc
operator|=
name|sc
operator|->
name|sc_psc
expr_stmt|;
name|sc
operator|->
name|sc_psc
operator|=
name|NULL
expr_stmt|;
name|LAGG_WUNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lacp_detach
argument_list|(
name|psc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_lacp_lladdr
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
comment|/* purge all the lacp ports */
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|lacp_port_destroy
argument_list|(
name|lp
argument_list|)
expr_stmt|;
comment|/* add them back in */
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|lacp_port_create
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_lacp_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|lp
operator|=
name|lacp_select_tx_port
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
comment|/* Send mbuf */
return|return
operator|(
name|lagg_enqueue
argument_list|(
name|lp
operator|->
name|lp_ifp
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_lacp_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|u_short
name|etype
decl_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
comment|/* Tap off LACP control messages */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_VLANTAG
operator|)
operator|==
literal|0
operator|&&
name|etype
operator|==
name|ETHERTYPE_SLOW
condition|)
block|{
name|m
operator|=
name|lacp_input
argument_list|(
name|lp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * If the port is not collecting or not in the active aggregator then 	 * free and return. 	 */
if|if
condition|(
name|lacp_iscollecting
argument_list|(
name|lp
argument_list|)
operator|==
literal|0
operator|||
name|lacp_isactive
argument_list|(
name|lp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

end_unit

