begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: if_trunk.c,v 1.30 2007/01/31 06:20:19 reyk Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2006 Reyk Floeter<reyk@openbsd.org>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/hash.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_clone.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_lagg.h>
end_include

begin_include
include|#
directive|include
file|<net/ieee8023ad_lacp.h>
end_include

begin_comment
comment|/* Special flags we should propagate to the lagg ports. */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|int
name|flag
decl_stmt|;
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
block|}
name|lagg_pflags
index|[]
init|=
block|{
block|{
name|IFF_PROMISC
block|,
name|ifpromisc
block|}
block|,
block|{
name|IFF_ALLMULTI
block|,
name|if_allmulti
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_macro
name|SLIST_HEAD
argument_list|(
argument|__trhead
argument_list|,
argument|lagg_softc
argument_list|)
end_macro

begin_expr_stmt
name|lagg_list
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* list of laggs */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|lagg_list_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|eventhandler_tag
name|lagg_detach_cookie
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|lagg_clone_create
parameter_list|(
name|struct
name|if_clone
modifier|*
parameter_list|,
name|int
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_clone_destroy
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_lladdr
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_capabilities
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_port_lladdr
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_port_create
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_port_destroy
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_input
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_port_state
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_port_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_port_output
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|struct
name|rtentry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_port_ifdetach
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_port_checkstacking
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_port2req
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|struct
name|lagg_reqport
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_init
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_stop
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_ether_setmulti
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_ether_cmdmulti
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_ether_purgemulti
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_setflag
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_setflags
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_start
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|ifmediareq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|lagg_port
modifier|*
name|lagg_link_active
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|lagg_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|void
modifier|*
name|lagg_gethdr
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|u_int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|IFC_SIMPLE_DECLARE
argument_list|(
name|lagg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Simple round robin */
end_comment

begin_function_decl
specifier|static
name|int
name|lagg_rr_attach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_rr_detach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_rr_port_destroy
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_rr_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_rr_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Active failover */
end_comment

begin_function_decl
specifier|static
name|int
name|lagg_fail_attach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_fail_detach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_fail_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_fail_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Loadbalancing */
end_comment

begin_function_decl
specifier|static
name|int
name|lagg_lb_attach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_lb_detach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_lb_port_create
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_lb_port_destroy
parameter_list|(
name|struct
name|lagg_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_lb_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_lb_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_lb_porttable
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|lagg_port
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* 802.3ad LACP */
end_comment

begin_function_decl
specifier|static
name|int
name|lagg_lacp_attach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_lacp_detach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lagg_lacp_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_lacp_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|,
name|struct
name|lagg_port
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lagg_lacp_lladdr
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* lagg protocol table */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
block|{
name|int
name|ti_proto
decl_stmt|;
name|int
function_decl|(
modifier|*
name|ti_attach
function_decl|)
parameter_list|(
name|struct
name|lagg_softc
modifier|*
parameter_list|)
function_decl|;
block|}
name|lagg_protos
index|[]
init|=
block|{
block|{
name|LAGG_PROTO_ROUNDROBIN
block|,
name|lagg_rr_attach
block|}
block|,
block|{
name|LAGG_PROTO_FAILOVER
block|,
name|lagg_fail_attach
block|}
block|,
block|{
name|LAGG_PROTO_LOADBALANCE
block|,
name|lagg_lb_attach
block|}
block|,
block|{
name|LAGG_PROTO_ETHERCHANNEL
block|,
name|lagg_lb_attach
block|}
block|,
block|{
name|LAGG_PROTO_LACP
block|,
name|lagg_lacp_attach
block|}
block|,
block|{
name|LAGG_PROTO_NONE
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|lagg_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|mtx_init
argument_list|(
operator|&
name|lagg_list_mtx
argument_list|,
literal|"if_lagg list"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|lagg_list
argument_list|)
expr_stmt|;
name|if_clone_attach
argument_list|(
operator|&
name|lagg_cloner
argument_list|)
expr_stmt|;
name|lagg_input_p
operator|=
name|lagg_input
expr_stmt|;
name|lagg_linkstate_p
operator|=
name|lagg_port_state
expr_stmt|;
name|lagg_detach_cookie
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|ifnet_departure_event
argument_list|,
name|lagg_port_ifdetach
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|ifnet_departure_event
argument_list|,
name|lagg_detach_cookie
argument_list|)
expr_stmt|;
name|if_clone_detach
argument_list|(
operator|&
name|lagg_cloner
argument_list|)
expr_stmt|;
name|lagg_input_p
operator|=
name|NULL
expr_stmt|;
name|lagg_linkstate_p
operator|=
name|NULL
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|lagg_list_mtx
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|lagg_mod
init|=
block|{
literal|"if_lagg"
block|,
name|lagg_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|if_lagg
argument_list|,
name|lagg_mod
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|lagg_clone_create
parameter_list|(
name|struct
name|if_clone
modifier|*
name|ifc
parameter_list|,
name|int
name|unit
parameter_list|,
name|caddr_t
name|params
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|u_char
name|eaddr
index|[
literal|6
index|]
decl_stmt|;
comment|/* 00:00:00:00:00:00 */
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|sc
operator|->
name|sc_ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|sc
operator|->
name|sc_proto
operator|=
name|LAGG_PROTO_NONE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|lagg_protos
index|[
name|i
index|]
operator|.
name|ti_proto
operator|!=
name|LAGG_PROTO_NONE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lagg_protos
index|[
name|i
index|]
operator|.
name|ti_proto
operator|==
name|LAGG_PROTO_DEFAULT
condition|)
block|{
name|sc
operator|->
name|sc_proto
operator|=
name|lagg_protos
index|[
name|i
index|]
operator|.
name|ti_proto
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|lagg_protos
index|[
name|i
index|]
operator|.
name|ti_attach
argument_list|(
name|sc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|if_free_type
argument_list|(
name|ifp
argument_list|,
name|IFT_ETHER
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
break|break;
block|}
block|}
name|LAGG_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|)
expr_stmt|;
comment|/* Initialise pseudo media types */
name|ifmedia_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
literal|0
argument_list|,
name|lagg_media_change
argument_list|,
name|lagg_media_status
argument_list|)
expr_stmt|;
name|ifmedia_add
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ifmedia_set
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|IFM_ETHER
operator||
name|IFM_AUTO
argument_list|)
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|ifc
operator|->
name|ifc_name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_type
operator|=
name|IFT_ETHER
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sc
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|lagg_start
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|lagg_init
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|lagg_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_SIMPLEX
operator||
name|IFF_BROADCAST
operator||
name|IFF_MULTICAST
expr_stmt|;
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ifqmaxlen
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drv_maxlen
operator|=
name|ifqmaxlen
expr_stmt|;
name|IFQ_SET_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
comment|/* 	 * Attach as an ordinary ethernet device, childs will be attached 	 * as special device IFT_IEEE8023ADLAG. 	 */
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
comment|/* Insert into the global list of laggs */
name|mtx_lock
argument_list|(
operator|&
name|lagg_list_mtx
argument_list|)
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|lagg_list
argument_list|,
name|sc
argument_list|,
name|sc_entries
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lagg_list_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_clone_destroy
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|LAGG_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lagg_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
comment|/* Shutdown and remove lagg ports */
while|while
condition|(
operator|(
name|lp
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|lagg_port_destroy
argument_list|(
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Unhook the aggregation protocol */
if|if
condition|(
name|sc
operator|->
name|sc_detach
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_detach
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Remove any multicast groups that we may have joined. */
name|lagg_ether_purgemulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LAGG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
operator|&
name|sc
operator|->
name|sc_media
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_free_type
argument_list|(
name|ifp
argument_list|,
name|IFT_ETHER
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|lagg_list_mtx
argument_list|)
expr_stmt|;
name|SLIST_REMOVE
argument_list|(
operator|&
name|lagg_list
argument_list|,
name|sc
argument_list|,
name|lagg_softc
argument_list|,
name|sc_entries
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|lagg_list_mtx
argument_list|)
expr_stmt|;
name|LAGG_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_lladdr
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|uint8_t
modifier|*
name|lladdr
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|lladdr
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|bcopy
argument_list|(
name|lladdr
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* Let the protocol know the MAC has changed */
if|if
condition|(
name|sc
operator|->
name|sc_lladdr
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_lladdr
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_capabilities
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|int
name|cap
init|=
operator|~
literal|0
decl_stmt|,
name|priv
decl_stmt|;
name|LAGG_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Preserve private capabilities */
name|priv
operator|=
name|sc
operator|->
name|sc_capabilities
operator|&
name|IFCAP_LAGG_MASK
expr_stmt|;
comment|/* Get capabilities from the lagg ports */
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|cap
operator|&=
name|lp
operator|->
name|lp_capabilities
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ifflags
operator|&
name|IFF_DEBUG
condition|)
block|{
name|printf
argument_list|(
literal|"%s: capabilities 0x%08x\n"
argument_list|,
name|sc
operator|->
name|sc_ifname
argument_list|,
name|cap
operator|==
operator|~
literal|0
condition|?
name|priv
else|:
operator|(
name|cap
operator||
name|priv
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|cap
operator|==
operator|~
literal|0
condition|?
name|priv
else|:
operator|(
name|cap
operator||
name|priv
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_port_lladdr
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|uint8_t
modifier|*
name|lladdr
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|lp
operator|->
name|lp_ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|lladdr
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* Set the link layer address */
name|error
operator|=
name|if_setlladdr
argument_list|(
name|ifp
argument_list|,
name|lladdr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|printf
argument_list|(
literal|"%s: setlladdr failed on %s\n"
argument_list|,
name|__func__
argument_list|,
name|lp
operator|->
name|lp_ifname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_port_create
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc_ptr
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|LAGG_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Limit the maximal number of lagg ports */
if|if
condition|(
name|sc
operator|->
name|sc_count
operator|>=
name|LAGG_MAX_PORTS
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* New lagg port has to be in an idle state */
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Check if port has already been associated to a lagg */
if|if
condition|(
name|ifp
operator|->
name|if_lagg
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* XXX Disallow non-ethernet interfaces (this should be any of 802) */
if|if
condition|(
name|ifp
operator|->
name|if_type
operator|!=
name|IFT_ETHER
condition|)
return|return
operator|(
name|EPROTONOSUPPORT
operator|)
return|;
if|if
condition|(
operator|(
name|lp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lagg_port
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Check if port is a stacked lagg */
name|mtx_lock
argument_list|(
operator|&
name|lagg_list_mtx
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|sc_ptr
argument_list|,
argument|&lagg_list
argument_list|,
argument|sc_entries
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|==
name|sc_ptr
operator|->
name|sc_ifp
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|lagg_list_mtx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* XXX disable stacking for the moment, its untested 			lp->lp_flags |= LAGG_PORT_STACK; 			if (lagg_port_checkstacking(sc_ptr)>= 			    LAGG_MAX_STACKING) { 				mtx_unlock(&lagg_list_mtx); 				free(lp, M_DEVBUF); 				return (E2BIG); 			} 			*/
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|lagg_list_mtx
argument_list|)
expr_stmt|;
comment|/* Change the interface type */
name|lp
operator|->
name|lp_iftype
operator|=
name|ifp
operator|->
name|if_type
expr_stmt|;
name|ifp
operator|->
name|if_type
operator|=
name|IFT_IEEE8023ADLAG
expr_stmt|;
name|ifp
operator|->
name|if_lagg
operator|=
name|lp
expr_stmt|;
name|lp
operator|->
name|lp_ioctl
operator|=
name|ifp
operator|->
name|if_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|lagg_port_ioctl
expr_stmt|;
name|lp
operator|->
name|lp_output
operator|=
name|ifp
operator|->
name|if_output
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|lagg_port_output
expr_stmt|;
name|lp
operator|->
name|lp_ifp
operator|=
name|ifp
expr_stmt|;
name|lp
operator|->
name|lp_lagg
operator|=
name|sc
expr_stmt|;
comment|/* Save port link layer address */
name|bcopy
argument_list|(
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|lp
operator|->
name|lp_lladdr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|SLIST_EMPTY
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_primary
operator|=
name|lp
expr_stmt|;
name|lagg_lladdr
argument_list|(
name|sc
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Update link layer address for this port */
name|lagg_port_lladdr
argument_list|(
name|lp
argument_list|,
name|IF_LLADDR
argument_list|(
name|sc
operator|->
name|sc_ifp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Insert into the list of ports */
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|,
name|lp
argument_list|,
name|lp_entries
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_count
operator|++
expr_stmt|;
comment|/* Update lagg capabilities */
name|sc
operator|->
name|sc_capabilities
operator|=
name|lagg_capabilities
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Add multicast addresses and interface flags to this port */
name|lagg_ether_cmdmulti
argument_list|(
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lagg_setflags
argument_list|(
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_port_create
operator|!=
name|NULL
condition|)
name|error
operator|=
call|(
modifier|*
name|sc
operator|->
name|sc_port_create
call|)
argument_list|(
name|lp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* remove the port again, without calling sc_port_destroy */
name|lagg_port_destroy
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_port_checkstacking
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc_ptr
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|int
name|m
init|=
literal|0
decl_stmt|;
name|LAGG_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
if|if
condition|(
name|lp
operator|->
name|lp_flags
operator|&
name|LAGG_PORT_STACK
condition|)
block|{
name|sc_ptr
operator|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|lp
operator|->
name|lp_ifp
operator|->
name|if_softc
expr_stmt|;
name|m
operator|=
name|MAX
argument_list|(
name|m
argument_list|,
name|lagg_port_checkstacking
argument_list|(
name|sc_ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|m
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_port_destroy
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|int
name|runpd
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|lp
operator|->
name|lp_lagg
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp_ptr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|lp
operator|->
name|lp_ifp
decl_stmt|;
name|LAGG_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|runpd
operator|&&
name|sc
operator|->
name|sc_port_destroy
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_port_destroy
call|)
argument_list|(
name|lp
argument_list|)
expr_stmt|;
comment|/* Remove multicast addresses and interface flags from this port */
name|lagg_ether_cmdmulti
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lagg_setflags
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Restore interface */
name|ifp
operator|->
name|if_type
operator|=
name|lp
operator|->
name|lp_iftype
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|lp
operator|->
name|lp_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|lp
operator|->
name|lp_output
expr_stmt|;
name|ifp
operator|->
name|if_lagg
operator|=
name|NULL
expr_stmt|;
comment|/* Finally, remove the port from the lagg */
name|SLIST_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|,
name|lp
argument_list|,
name|lagg_port
argument_list|,
name|lp_entries
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_count
operator|--
expr_stmt|;
comment|/* Update the primary interface */
if|if
condition|(
name|lp
operator|==
name|sc
operator|->
name|sc_primary
condition|)
block|{
name|uint8_t
name|lladdr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|lp_ptr
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|lladdr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|lp_ptr
operator|->
name|lp_lladdr
argument_list|,
name|lladdr
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
name|lagg_lladdr
argument_list|(
name|sc
argument_list|,
name|lladdr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_primary
operator|=
name|lp_ptr
expr_stmt|;
comment|/* Update link layer address for each port */
name|SLIST_FOREACH
argument_list|(
argument|lp_ptr
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|lagg_port_lladdr
argument_list|(
name|lp_ptr
argument_list|,
name|lladdr
argument_list|)
expr_stmt|;
block|}
comment|/* Reset the port lladdr */
name|lagg_port_lladdr
argument_list|(
name|lp
argument_list|,
name|lp
operator|->
name|lp_lladdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|lp_ifflags
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: lp_ifflags unclean\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
comment|/* Update lagg capabilities */
name|sc
operator|->
name|sc_capabilities
operator|=
name|lagg_capabilities
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_port_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|lagg_reqport
modifier|*
name|rp
init|=
operator|(
expr|struct
name|lagg_reqport
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|lagg_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Should be checked by the caller */
if|if
condition|(
name|ifp
operator|->
name|if_type
operator|!=
name|IFT_IEEE8023ADLAG
operator|||
operator|(
name|lp
operator|=
name|ifp
operator|->
name|if_lagg
operator|)
operator|==
name|NULL
operator|||
operator|(
name|sc
operator|=
name|lp
operator|->
name|lp_lagg
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|fallback
goto|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCGLAGGPORT
case|:
name|LAGG_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rp_portname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|ifunit
argument_list|(
name|rp
operator|->
name|rp_portname
argument_list|)
operator|!=
name|ifp
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|lp
operator|->
name|lp_lagg
operator|!=
name|sc
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
name|lagg_port2req
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|LAGG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|fallback
goto|;
block|}
return|return
operator|(
name|error
operator|)
return|;
name|fallback
label|:
if|if
condition|(
name|lp
operator|!=
name|NULL
condition|)
return|return
operator|(
call|(
modifier|*
name|lp
operator|->
name|lp_ioctl
call|)
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
operator|)
return|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_port_output
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt0
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
init|=
name|ifp
operator|->
name|if_lagg
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|short
name|type
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|dst
operator|->
name|sa_family
condition|)
block|{
case|case
name|pseudo_AF_HDRCMPLT
case|:
case|case
name|AF_UNSPEC
case|:
name|eh
operator|=
operator|(
expr|struct
name|ether_header
operator|*
operator|)
name|dst
operator|->
name|sa_data
expr_stmt|;
name|type
operator|=
name|eh
operator|->
name|ether_type
expr_stmt|;
break|break;
block|}
comment|/* 	 * Only allow ethernet types required to initiate or maintain the link, 	 * aggregated frames take a different path. 	 */
switch|switch
condition|(
name|ntohs
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|ETHERTYPE_PAE
case|:
comment|/* EAPOL PAE/802.1x */
return|return
operator|(
call|(
modifier|*
name|lp
operator|->
name|lp_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
name|rt0
argument_list|)
operator|)
return|;
block|}
comment|/* drop any other frames */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_port_ifdetach
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|struct
name|lagg_softc
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
operator|(
name|lp
operator|=
name|ifp
operator|->
name|if_lagg
operator|)
operator|==
name|NULL
condition|)
return|return;
name|sc
operator|=
name|lp
operator|->
name|lp_lagg
expr_stmt|;
name|LAGG_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lagg_port_destroy
argument_list|(
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|LAGG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_port2req
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|struct
name|lagg_reqport
modifier|*
name|rp
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|lp
operator|->
name|lp_lagg
decl_stmt|;
name|strlcpy
argument_list|(
name|rp
operator|->
name|rp_ifname
argument_list|,
name|sc
operator|->
name|sc_ifname
argument_list|,
sizeof|sizeof
argument_list|(
name|rp
operator|->
name|rp_ifname
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|rp
operator|->
name|rp_portname
argument_list|,
name|lp
operator|->
name|lp_ifp
operator|->
name|if_xname
argument_list|,
sizeof|sizeof
argument_list|(
name|rp
operator|->
name|rp_portname
argument_list|)
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rp_prio
operator|=
name|lp
operator|->
name|lp_prio
expr_stmt|;
name|rp
operator|->
name|rp_flags
operator|=
name|lp
operator|->
name|lp_flags
expr_stmt|;
comment|/* Add protocol specific flags */
switch|switch
condition|(
name|sc
operator|->
name|sc_proto
condition|)
block|{
case|case
name|LAGG_PROTO_FAILOVER
case|:
if|if
condition|(
name|lp
operator|==
name|sc
operator|->
name|sc_primary
condition|)
name|rp
operator|->
name|rp_flags
operator||=
name|LAGG_PORT_MASTER
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|LAGG_PROTO_ROUNDROBIN
case|:
case|case
name|LAGG_PROTO_LOADBALANCE
case|:
case|case
name|LAGG_PROTO_ETHERCHANNEL
case|:
if|if
condition|(
name|LAGG_PORTACTIVE
argument_list|(
name|lp
argument_list|)
condition|)
name|rp
operator|->
name|rp_flags
operator||=
name|LAGG_PORT_ACTIVE
expr_stmt|;
break|break;
case|case
name|LAGG_PROTO_LACP
case|:
comment|/* LACP has a different definition of active */
if|if
condition|(
name|lacp_port_isactive
argument_list|(
name|lp
argument_list|)
condition|)
name|rp
operator|->
name|rp_flags
operator||=
name|LAGG_PORT_ACTIVE
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_init
parameter_list|(
name|void
modifier|*
name|xsc
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|xsc
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
return|return;
name|LAGG_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
comment|/* Update the port lladdrs */
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|lagg_port_lladdr
argument_list|(
name|lp
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_init
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_init
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LAGG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_stop
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|LAGG_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_stop
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_stop
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|lagg_reqall
modifier|*
name|ra
init|=
operator|(
expr|struct
name|lagg_reqall
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|lagg_reqport
modifier|*
name|rp
init|=
operator|(
expr|struct
name|lagg_reqport
operator|*
operator|)
name|data
decl_stmt|,
name|rpbuf
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|tpif
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|unlock
init|=
literal|1
decl_stmt|;
name|LAGG_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|rpbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|rpbuf
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCGLAGG
case|:
name|ra
operator|->
name|ra_proto
operator|=
name|sc
operator|->
name|sc_proto
expr_stmt|;
name|ra
operator|->
name|ra_ports
operator|=
name|i
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|)
expr_stmt|;
while|while
condition|(
name|lp
operator|&&
name|ra
operator|->
name|ra_size
operator|>=
name|i
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|lagg_reqport
argument_list|)
condition|)
block|{
name|lagg_port2req
argument_list|(
name|lp
argument_list|,
operator|&
name|rpbuf
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|rpbuf
argument_list|,
operator|(
name|caddr_t
operator|)
name|ra
operator|->
name|ra_port
operator|+
name|i
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lagg_reqport
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|i
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|lagg_reqport
argument_list|)
expr_stmt|;
name|ra
operator|->
name|ra_ports
operator|++
expr_stmt|;
name|lp
operator|=
name|SLIST_NEXT
argument_list|(
name|lp
argument_list|,
name|lp_entries
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSLAGG
case|:
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NET_LAGG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|ra
operator|->
name|ra_proto
operator|>=
name|LAGG_PROTO_MAX
condition|)
block|{
name|error
operator|=
name|EPROTONOSUPPORT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_proto
operator|!=
name|LAGG_PROTO_NONE
condition|)
block|{
name|error
operator|=
name|sc
operator|->
name|sc_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Reset protocol and pointers */
name|sc
operator|->
name|sc_proto
operator|=
name|LAGG_PROTO_NONE
expr_stmt|;
name|sc
operator|->
name|sc_detach
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_start
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_input
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_port_create
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_port_destroy
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_linkstate
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_init
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_stop
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_lladdr
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|lagg_protos
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|lagg_protos
index|[
literal|0
index|]
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|lagg_protos
index|[
name|i
index|]
operator|.
name|ti_proto
operator|==
name|ra
operator|->
name|ra_proto
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_ifflags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: using proto %u\n"
argument_list|,
name|sc
operator|->
name|sc_ifname
argument_list|,
name|lagg_protos
index|[
name|i
index|]
operator|.
name|ti_proto
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_proto
operator|=
name|lagg_protos
index|[
name|i
index|]
operator|.
name|ti_proto
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_proto
operator|!=
name|LAGG_PROTO_NONE
condition|)
name|error
operator|=
name|lagg_protos
index|[
name|i
index|]
operator|.
name|ti_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|error
operator|=
name|EPROTONOSUPPORT
expr_stmt|;
break|break;
case|case
name|SIOCGLAGGPORT
case|:
if|if
condition|(
name|rp
operator|->
name|rp_portname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|tpif
operator|=
name|ifunit
argument_list|(
name|rp
operator|->
name|rp_portname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|lp
operator|=
operator|(
expr|struct
name|lagg_port
operator|*
operator|)
name|tpif
operator|->
name|if_lagg
operator|)
operator|==
name|NULL
operator|||
name|lp
operator|->
name|lp_lagg
operator|!=
name|sc
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
name|lagg_port2req
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSLAGGPORT
case|:
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NET_LAGG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|rp
operator|->
name|rp_portname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|tpif
operator|=
name|ifunit
argument_list|(
name|rp
operator|->
name|rp_portname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|lagg_port_create
argument_list|(
name|sc
argument_list|,
name|tpif
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSLAGGDELPORT
case|:
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NET_LAGG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|rp
operator|->
name|rp_portname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|tpif
operator|=
name|ifunit
argument_list|(
name|rp
operator|->
name|rp_portname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|lp
operator|=
operator|(
expr|struct
name|lagg_port
operator|*
operator|)
name|tpif
operator|->
name|if_lagg
operator|)
operator|==
name|NULL
operator|||
name|lp
operator|->
name|lp_lagg
operator|!=
name|sc
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|lagg_port_destroy
argument_list|(
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
comment|/* Set flags on ports too */
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
name|lagg_setflags
argument_list|(
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
comment|/* 			 * If interface is marked down and it is running, 			 * then stop and disable it. 			 */
name|lagg_stop
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
comment|/* 			 * If interface is marked up and it is stopped, then 			 * start it. 			 */
name|LAGG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|unlock
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_init
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|error
operator|=
name|lagg_ether_setmulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMEDIA
case|:
case|case
name|SIOCGIFMEDIA
case|:
name|LAGG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|unlock
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|sc
operator|->
name|sc_media
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
break|break;
default|default:
name|LAGG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|unlock
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
label|:
if|if
condition|(
name|unlock
condition|)
name|LAGG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_ether_setmulti
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|LAGG_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* First, remove any existing filter entries. */
name|lagg_ether_purgemulti
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
name|lagg_ether_cmdmulti
argument_list|(
name|lp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_ether_cmdmulti
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|int
name|set
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|lp
operator|->
name|lp_lagg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|lp
operator|->
name|lp_ifp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|trifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|lagg_mc
modifier|*
name|mc
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|,
modifier|*
name|rifma
init|=
name|NULL
decl_stmt|;
name|struct
name|sockaddr_dl
name|sdl
decl_stmt|;
name|int
name|error
decl_stmt|;
name|LAGG_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sdl
argument_list|,
sizeof|sizeof
argument_list|(
name|sdl
argument_list|)
argument_list|)
expr_stmt|;
name|sdl
operator|.
name|sdl_len
operator|=
sizeof|sizeof
argument_list|(
name|sdl
argument_list|)
expr_stmt|;
name|sdl
operator|.
name|sdl_family
operator|=
name|AF_LINK
expr_stmt|;
name|sdl
operator|.
name|sdl_type
operator|=
name|IFT_ETHER
expr_stmt|;
name|sdl
operator|.
name|sdl_alen
operator|=
name|ETHER_ADDR_LEN
expr_stmt|;
name|sdl
operator|.
name|sdl_index
operator|=
name|ifp
operator|->
name|if_index
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&trifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
continue|continue;
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifma
operator|->
name|ifma_addr
argument_list|)
argument_list|,
name|LLADDR
argument_list|(
operator|&
name|sdl
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
name|error
operator|=
name|if_addmulti
argument_list|(
name|ifp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sdl
argument_list|,
operator|&
name|rifma
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lagg_mc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|mc
operator|->
name|mc_ifma
operator|=
name|rifma
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|lp
operator|->
name|lp_mc_head
argument_list|,
name|mc
argument_list|,
name|mc_entries
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|(
name|mc
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|lp
operator|->
name|lp_mc_head
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE
argument_list|(
operator|&
name|lp
operator|->
name|lp_mc_head
argument_list|,
name|mc
argument_list|,
name|lagg_mc
argument_list|,
name|mc_entries
argument_list|)
expr_stmt|;
name|if_delmulti_ifma
argument_list|(
name|mc
operator|->
name|mc_ifma
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_ether_purgemulti
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|LAGG_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|lagg_ether_cmdmulti
argument_list|(
name|lp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Handle a ref counted flag that should be set on the lagg port as well */
end_comment

begin_function
specifier|static
name|int
name|lagg_setflag
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|status
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|lp
operator|->
name|lp_lagg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|trifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|lp
operator|->
name|lp_ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|LAGG_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|status
operator|=
name|status
condition|?
operator|(
name|trifp
operator|->
name|if_flags
operator|&
name|flag
operator|)
else|:
literal|0
expr_stmt|;
comment|/* Now "status" contains the flag value or 0 */
comment|/* 	 * See if recorded ports status is different from what 	 * we want it to be.  If it is, flip it.  We record ports 	 * status in lp_ifflags so that we won't clear ports flag 	 * we haven't set.  In fact, we don't clear or set ports 	 * flags directly, but get or release references to them. 	 * That's why we can be sure that recorded flags still are 	 * in accord with actual ports flags. 	 */
if|if
condition|(
name|status
operator|!=
operator|(
name|lp
operator|->
name|lp_ifflags
operator|&
name|flag
operator|)
condition|)
block|{
name|error
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|ifp
argument_list|,
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|lp
operator|->
name|lp_ifflags
operator|&=
operator|~
name|flag
expr_stmt|;
name|lp
operator|->
name|lp_ifflags
operator||=
name|status
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle IFF_* flags that require certain changes on the lagg port  * if "status" is true, update ports flags respective to the lagg  * if "status" is false, forcedly clear the flags set on port.  */
end_comment

begin_function
specifier|static
name|int
name|lagg_setflags
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|lagg_pflags
index|[
name|i
index|]
operator|.
name|flag
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|lagg_setflag
argument_list|(
name|lp
argument_list|,
name|lagg_pflags
index|[
name|i
index|]
operator|.
name|flag
argument_list|,
name|status
argument_list|,
name|lagg_pflags
index|[
name|i
index|]
operator|.
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
condition|;
name|error
operator|=
literal|0
control|)
block|{
name|IFQ_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_proto
operator|!=
name|LAGG_PROTO_NONE
condition|)
block|{
name|LAGG_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|sc
operator|->
name|sc_start
call|)
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|LAGG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
else|else
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_input
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
init|=
name|ifp
operator|->
name|if_lagg
decl_stmt|;
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|lp
operator|->
name|lp_lagg
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|trifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
if|if
condition|(
operator|(
name|trifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
operator|(
name|lp
operator|->
name|lp_flags
operator|&
name|LAGG_PORT_DISABLED
operator|)
operator|||
name|sc
operator|->
name|sc_proto
operator|==
name|LAGG_PROTO_NONE
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|LAGG_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|BPF_MTAP
argument_list|(
name|trifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
call|(
modifier|*
name|sc
operator|->
name|sc_input
call|)
argument_list|(
name|sc
argument_list|,
name|lp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_ibytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|trifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|trifp
operator|->
name|if_ibytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
block|}
name|LAGG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ifflags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Ignore */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|imr
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|lagg_softc
operator|*
operator|)
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|imr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
name|imr
operator|->
name|ifm_active
operator|=
name|IFM_ETHER
operator||
name|IFM_AUTO
expr_stmt|;
name|LAGG_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|lp
operator|=
name|sc
operator|->
name|sc_primary
expr_stmt|;
if|if
condition|(
name|lp
operator|!=
name|NULL
operator|&&
name|lp
operator|->
name|lp_ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
condition|)
name|imr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
name|LAGG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_port_state
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
init|=
operator|(
expr|struct
name|lagg_port
operator|*
operator|)
name|ifp
operator|->
name|if_lagg
decl_stmt|;
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|lp
operator|!=
name|NULL
condition|)
name|sc
operator|=
name|lp
operator|->
name|lp_lagg
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
name|LAGG_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_linkstate
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_linkstate
call|)
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|LAGG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|lagg_port
modifier|*
name|lagg_link_active
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp_next
decl_stmt|,
modifier|*
name|rval
init|=
name|NULL
decl_stmt|;
comment|// int new_link = LINK_STATE_DOWN;
name|LAGG_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 	 * Search a port which reports an active link state. 	 */
if|if
condition|(
name|lp
operator|==
name|NULL
condition|)
goto|goto
name|search
goto|;
if|if
condition|(
name|LAGG_PORTACTIVE
argument_list|(
name|lp
argument_list|)
condition|)
block|{
name|rval
operator|=
name|lp
expr_stmt|;
goto|goto
name|found
goto|;
block|}
if|if
condition|(
operator|(
name|lp_next
operator|=
name|SLIST_NEXT
argument_list|(
name|lp
argument_list|,
name|lp_entries
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|LAGG_PORTACTIVE
argument_list|(
name|lp_next
argument_list|)
condition|)
block|{
name|rval
operator|=
name|lp_next
expr_stmt|;
goto|goto
name|found
goto|;
block|}
name|search
label|:
name|SLIST_FOREACH
argument_list|(
argument|lp_next
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
if|if
condition|(
name|LAGG_PORTACTIVE
argument_list|(
name|lp_next
argument_list|)
condition|)
block|{
name|rval
operator|=
name|lp_next
expr_stmt|;
goto|goto
name|found
goto|;
block|}
block|}
name|found
label|:
if|if
condition|(
name|rval
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * The IEEE 802.1D standard assumes that a lagg with 		 * multiple ports is always full duplex. This is valid 		 * for load sharing laggs and if at least two links 		 * are active. Unfortunately, checking the latter would 		 * be too expensive at this point. 		 XXX 		if ((sc->sc_capabilities& IFCAP_LAGG_FULLDUPLEX)&& 		    (sc->sc_count> 1)) 			new_link = LINK_STATE_FULL_DUPLEX; 		else 			new_link = rval->lp_link_state; 		 */
block|}
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|void
modifier|*
name|lagg_gethdr
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u_int
name|off
parameter_list|,
name|u_int
name|len
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
operator|(
name|off
operator|+
name|len
operator|)
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
operator|(
name|off
operator|+
name|len
operator|)
condition|)
block|{
name|m_copydata
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
return|return
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|off
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|lagg_hashmbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
name|key
parameter_list|)
block|{
name|uint16_t
name|etype
decl_stmt|;
name|uint32_t
name|p
init|=
literal|0
decl_stmt|;
name|int
name|off
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|ether_vlan_header
name|vlanbuf
decl_stmt|;
specifier|const
name|struct
name|ether_vlan_header
modifier|*
name|vlan
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
specifier|const
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|ip
name|ipbuf
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
specifier|const
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|ip6_hdr
name|ip6buf
decl_stmt|;
endif|#
directive|endif
name|off
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|off
condition|)
goto|goto
name|out
goto|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|eh
operator|->
name|ether_shost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|eh
operator|->
name|ether_dhost
argument_list|,
name|ETHER_ADDR_LEN
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Special handling for encapsulating VLAN frames */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_VLANTAG
condition|)
block|{
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|,
sizeof|sizeof
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|etype
operator|==
name|ETHERTYPE_VLAN
condition|)
block|{
name|vlan
operator|=
name|lagg_gethdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vlan
argument_list|)
argument_list|,
operator|&
name|vlanbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlan
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|vlan
operator|->
name|evl_tag
argument_list|,
sizeof|sizeof
argument_list|(
name|vlan
operator|->
name|evl_tag
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|etype
operator|=
name|ntohs
argument_list|(
name|vlan
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
name|off
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|vlan
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|etype
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|ETHERTYPE_IP
case|:
name|ip
operator|=
name|lagg_gethdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|,
operator|&
name|ipbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|ip
operator|->
name|ip_src
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|ip
operator|->
name|ip_dst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|ETHERTYPE_IPV6
case|:
name|ip6
operator|=
name|lagg_gethdr
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
argument_list|,
operator|&
name|ip6buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip6
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|hash32_buf
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|out
label|:
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lagg_enqueue
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* Send mbuf */
name|IFQ_ENQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
operator|==
literal|0
condition|)
call|(
modifier|*
name|ifp
operator|->
name|if_start
call|)
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_obytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_MCAST
condition|)
name|ifp
operator|->
name|if_omcasts
operator|++
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Simple round robin aggregation  */
end_comment

begin_function
specifier|static
name|int
name|lagg_rr_attach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|sc
operator|->
name|sc_detach
operator|=
name|lagg_rr_detach
expr_stmt|;
name|sc
operator|->
name|sc_start
operator|=
name|lagg_rr_start
expr_stmt|;
name|sc
operator|->
name|sc_input
operator|=
name|lagg_rr_input
expr_stmt|;
name|sc
operator|->
name|sc_port_create
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_port_destroy
operator|=
name|lagg_rr_port_destroy
expr_stmt|;
name|sc
operator|->
name|sc_capabilities
operator|=
name|IFCAP_LAGG_FULLDUPLEX
expr_stmt|;
name|lp
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|sc
operator|->
name|sc_ports
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_psc
operator|=
operator|(
name|caddr_t
operator|)
name|lp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_rr_detach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|sc_psc
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_rr_port_destroy
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|lp
operator|->
name|lp_lagg
decl_stmt|;
if|if
condition|(
name|lp
operator|==
operator|(
expr|struct
name|lagg_port
operator|*
operator|)
name|sc
operator|->
name|sc_psc
condition|)
name|sc
operator|->
name|sc_psc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_rr_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
init|=
operator|(
expr|struct
name|lagg_port
operator|*
operator|)
name|sc
operator|->
name|sc_psc
decl_stmt|,
modifier|*
name|lp_next
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|lp
operator|==
name|NULL
operator|&&
operator|(
name|lp
operator|=
name|lagg_link_active
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Send mbuf */
name|error
operator|=
name|lagg_enqueue
argument_list|(
name|lp
operator|->
name|lp_ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Get next active port */
name|lp_next
operator|=
name|lagg_link_active
argument_list|(
name|sc
argument_list|,
name|SLIST_NEXT
argument_list|(
name|lp
argument_list|,
name|lp_entries
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_psc
operator|=
operator|(
name|caddr_t
operator|)
name|lp_next
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_rr_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
comment|/* Just pass in the packet to our lagg device */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Active failover  */
end_comment

begin_function
specifier|static
name|int
name|lagg_fail_attach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|sc_detach
operator|=
name|lagg_fail_detach
expr_stmt|;
name|sc
operator|->
name|sc_start
operator|=
name|lagg_fail_start
expr_stmt|;
name|sc
operator|->
name|sc_input
operator|=
name|lagg_fail_input
expr_stmt|;
name|sc
operator|->
name|sc_port_create
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_port_destroy
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_fail_detach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_fail_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
comment|/* Use the master port if active or the next available port */
if|if
condition|(
operator|(
name|lp
operator|=
name|lagg_link_active
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_primary
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Send mbuf */
return|return
operator|(
name|lagg_enqueue
argument_list|(
name|lp
operator|->
name|lp_ifp
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_fail_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|tmp_tp
decl_stmt|;
if|if
condition|(
name|lp
operator|==
name|sc
operator|->
name|sc_primary
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_primary
operator|->
name|lp_link_state
operator|==
name|LINK_STATE_DOWN
condition|)
block|{
name|tmp_tp
operator|=
name|lagg_link_active
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * If tmp_tp is null, we've recieved a packet when all 		 * our links are down. Weird, but process it anyways. 		 */
if|if
condition|(
operator|(
name|tmp_tp
operator|==
name|NULL
operator|||
name|tmp_tp
operator|==
name|lp
operator|)
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Loadbalancing  */
end_comment

begin_function
specifier|static
name|int
name|lagg_lb_attach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|struct
name|lagg_lb
modifier|*
name|lb
decl_stmt|;
if|if
condition|(
operator|(
name|lb
operator|=
operator|(
expr|struct
name|lagg_lb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|lagg_lb
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sc
operator|->
name|sc_detach
operator|=
name|lagg_lb_detach
expr_stmt|;
name|sc
operator|->
name|sc_start
operator|=
name|lagg_lb_start
expr_stmt|;
name|sc
operator|->
name|sc_input
operator|=
name|lagg_lb_input
expr_stmt|;
name|sc
operator|->
name|sc_port_create
operator|=
name|lagg_lb_port_create
expr_stmt|;
name|sc
operator|->
name|sc_port_destroy
operator|=
name|lagg_lb_port_destroy
expr_stmt|;
name|sc
operator|->
name|sc_capabilities
operator|=
name|IFCAP_LAGG_FULLDUPLEX
expr_stmt|;
name|lb
operator|->
name|lb_key
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_psc
operator|=
operator|(
name|caddr_t
operator|)
name|lb
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|lagg_lb_port_create
argument_list|(
name|lp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_lb_detach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_lb
modifier|*
name|lb
init|=
operator|(
expr|struct
name|lagg_lb
operator|*
operator|)
name|sc
operator|->
name|sc_psc
decl_stmt|;
if|if
condition|(
name|lb
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|lb
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_lb_porttable
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|)
block|{
name|struct
name|lagg_lb
modifier|*
name|lb
init|=
operator|(
expr|struct
name|lagg_lb
operator|*
operator|)
name|sc
operator|->
name|sc_psc
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp_next
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|lb
operator|->
name|lb_ports
argument_list|,
sizeof|sizeof
argument_list|(
name|lb
operator|->
name|lb_ports
argument_list|)
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp_next
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
block|{
if|if
condition|(
name|lp_next
operator|==
name|lp
condition|)
continue|continue;
if|if
condition|(
name|i
operator|>=
name|LAGG_MAX_PORTS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sc
operator|->
name|sc_ifflags
operator|&
name|IFF_DEBUG
condition|)
name|printf
argument_list|(
literal|"%s: port %s at index %d\n"
argument_list|,
name|sc
operator|->
name|sc_ifname
argument_list|,
name|lp_next
operator|->
name|lp_ifname
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|lb
operator|->
name|lb_ports
index|[
name|i
operator|++
index|]
operator|=
name|lp_next
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_lb_port_create
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|lp
operator|->
name|lp_lagg
decl_stmt|;
return|return
operator|(
name|lagg_lb_porttable
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_lb_port_destroy
parameter_list|(
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|)
block|{
name|struct
name|lagg_softc
modifier|*
name|sc
init|=
name|lp
operator|->
name|lp_lagg
decl_stmt|;
name|lagg_lb_porttable
argument_list|(
name|sc
argument_list|,
name|lp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_lb_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|lagg_lb
modifier|*
name|lb
init|=
operator|(
expr|struct
name|lagg_lb
operator|*
operator|)
name|sc
operator|->
name|sc_psc
decl_stmt|;
name|struct
name|lagg_port
modifier|*
name|lp
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|p
init|=
literal|0
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|p
operator|=
name|lagg_hashmbuf
argument_list|(
name|m
argument_list|,
name|lb
operator|->
name|lb_key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|idx
operator|=
name|p
operator|%
name|sc
operator|->
name|sc_count
operator|)
operator|>=
name|LAGG_MAX_PORTS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|lp
operator|=
name|lb
operator|->
name|lb_ports
index|[
name|idx
index|]
expr_stmt|;
comment|/* 	 * Check the port's link state. This will return the next active 	 * port if the link is down or the port is NULL. 	 */
if|if
condition|(
operator|(
name|lp
operator|=
name|lagg_link_active
argument_list|(
name|sc
argument_list|,
name|lp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Send mbuf */
return|return
operator|(
name|lagg_enqueue
argument_list|(
name|lp
operator|->
name|lp_ifp
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_lb_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
comment|/* Just pass in the packet to our lagg device */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 802.3ad LACP  */
end_comment

begin_function
specifier|static
name|int
name|lagg_lacp_attach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sc
operator|->
name|sc_detach
operator|=
name|lagg_lacp_detach
expr_stmt|;
name|sc
operator|->
name|sc_port_create
operator|=
name|lacp_port_create
expr_stmt|;
name|sc
operator|->
name|sc_port_destroy
operator|=
name|lacp_port_destroy
expr_stmt|;
name|sc
operator|->
name|sc_linkstate
operator|=
name|lacp_linkstate
expr_stmt|;
name|sc
operator|->
name|sc_start
operator|=
name|lagg_lacp_start
expr_stmt|;
name|sc
operator|->
name|sc_input
operator|=
name|lagg_lacp_input
expr_stmt|;
name|sc
operator|->
name|sc_init
operator|=
name|lacp_init
expr_stmt|;
name|sc
operator|->
name|sc_stop
operator|=
name|lacp_stop
expr_stmt|;
name|sc
operator|->
name|sc_lladdr
operator|=
name|lagg_lacp_lladdr
expr_stmt|;
name|error
operator|=
name|lacp_attach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|lacp_port_create
argument_list|(
name|lp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_lacp_detach
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|lacp_port_destroy
argument_list|(
name|lp
argument_list|)
expr_stmt|;
comment|/* unlocking is safe here */
name|LAGG_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|error
operator|=
name|lacp_detach
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|LAGG_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lagg_lacp_lladdr
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
comment|/* purge all the lacp ports */
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|lacp_port_destroy
argument_list|(
name|lp
argument_list|)
expr_stmt|;
comment|/* add them back in */
name|SLIST_FOREACH
argument_list|(
argument|lp
argument_list|,
argument|&sc->sc_ports
argument_list|,
argument|lp_entries
argument_list|)
name|lacp_port_create
argument_list|(
name|lp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lagg_lacp_start
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|lagg_port
modifier|*
name|lp
decl_stmt|;
name|lp
operator|=
name|lacp_select_tx_port
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* Send mbuf */
return|return
operator|(
name|lagg_enqueue
argument_list|(
name|lp
operator|->
name|lp_ifp
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|lagg_lacp_input
parameter_list|(
name|struct
name|lagg_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lagg_port
modifier|*
name|lp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_ifp
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|u_short
name|etype
decl_stmt|;
name|uint8_t
name|subtype
decl_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
expr_stmt|;
comment|/* Tap off LACP control messages */
if|if
condition|(
name|etype
operator|==
name|ETHERTYPE_SLOW
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|subtype
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|m_copydata
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|subtype
argument_list|)
argument_list|,
operator|&
name|subtype
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|subtype
condition|)
block|{
case|case
name|SLOWPROTOCOLS_SUBTYPE_LACP
case|:
name|lacp_input
argument_list|(
name|lp
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLOWPROTOCOLS_SUBTYPE_MARKER
case|:
name|lacp_marker_input
argument_list|(
name|lp
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* Unknown LACP packet type */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * If the port is not collecting or not in the active aggregator then 	 * free and return. 	 */
if|if
condition|(
operator|(
name|lp
operator|->
name|lp_flags
operator|&
name|LAGG_PORT_COLLECTING
operator|)
operator|==
literal|0
operator|||
name|lacp_port_isactive
argument_list|(
name|lp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

end_unit

