begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004-2009 University of Zagreb  * Copyright (c) 2006-2009 FreeBSD Foundation  * All rights reserved.  *  * This software was developed by the University of Zagreb and the  * FreeBSD Foundation under sponsorship by the Stichting NLnet and the  * FreeBSD Foundation.  *  * Copyright (c) 2009 Jeffrey Roberson<jeff@freebsd.org>  * Copyright (c) 2009 Robert N. M. Watson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|"opt_kdb.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/sdt.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_sym.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_comment
comment|/*-  * This file implements core functions for virtual network stacks:  *  * - Virtual network stack management functions.  *  * - Virtual network stack memory allocator, which virtualizes global  *   variables in the network stack  *  * - Virtualized SYSINIT's/SYSUNINIT's, which allow network stack subsystems  *   to register startup/shutdown events to be run for each virtual network  *   stack instance.  */
end_comment

begin_expr_stmt
name|FEATURE
argument_list|(
name|vimage
argument_list|,
literal|"VIMAGE kernel virtualization"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_VNET
argument_list|,
literal|"vnet"
argument_list|,
literal|"network stack control block"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The virtual network stack list has two read-write locks, one sleepable and  * the other not, so that the list can be stablized and walked in a variety  * of network stack contexts.  Both must be acquired exclusively to modify  * the list, but a read lock of either lock is sufficient to walk the list.  */
end_comment

begin_decl_stmt
name|struct
name|rwlock
name|vnet_rwlock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sx
name|vnet_sxlock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VNET_LIST_WLOCK
parameter_list|()
value|do {						\ 	sx_xlock(&vnet_sxlock);						\ 	rw_wlock(&vnet_rwlock);						\ } while (0)
end_define

begin_define
define|#
directive|define
name|VNET_LIST_WUNLOCK
parameter_list|()
value|do {					\ 	rw_wunlock(&vnet_rwlock);					\ 	sx_xunlock(&vnet_sxlock);					\ } while (0)
end_define

begin_decl_stmt
name|struct
name|vnet_list_head
name|vnet_head
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vnet
modifier|*
name|vnet0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The virtual network stack allocator provides storage for virtualized  * global variables.  These variables are defined/declared using the  * VNET_DEFINE()/VNET_DECLARE() macros, which place them in the 'set_vnet'  * linker set.  The details of the implementation are somewhat subtle, but  * allow the majority of most network subsystems to maintain  * virtualization-agnostic.  *  * The virtual network stack allocator handles variables in the base kernel  * vs. modules in similar but different ways.  In both cases, virtualized  * global variables are marked as such by being declared to be part of the  * vnet linker set.  These "master" copies of global variables serve two  * functions:  *  * (1) They contain static initialization or "default" values for global  *     variables which will be propagated to each virtual network stack  *     instance when created.  As with normal global variables, they default  *     to zero-filled.  *  * (2) They act as unique global names by which the variable can be referred  *     to, regardless of network stack instance.  The single global symbol  *     will be used to calculate the location of a per-virtual instance  *     variable at run-time.  *  * Each virtual network stack instance has a complete copy of each  * virtualized global variable, stored in a malloc'd block of memory  * referred to by vnet->vnet_data_mem.  Critical to the design is that each  * per-instance memory block is laid out identically to the master block so  * that the offset of each global variable is the same across all blocks.  To  * optimize run-time access, a precalculated 'base' address,  * vnet->vnet_data_base, is stored in each vnet, and is the amount that can  * be added to the address of a 'master' instance of a variable to get to the  * per-vnet instance.  *  * Virtualized global variables are handled in a similar manner, but as each  * module has its own 'set_vnet' linker set, and we want to keep all  * virtualized globals togther, we reserve space in the kernel's linker set  * for potential module variables using a per-vnet character array,  * 'modspace'.  The virtual network stack allocator maintains a free list to  * track what space in the array is free (all, initially) and as modules are  * linked, allocates portions of the space to specific globals.  The kernel  * module linker queries the virtual network stack allocator and will  * bind references of the global to the location during linking.  It also  * calls into the virtual network stack allocator, once the memory is  * initialized, in order to propagate the new static initializations to all  * existing virtual network stack instances so that the soon-to-be executing  * module will find every network stack instance with proper default values.  */
end_comment

begin_comment
comment|/*  * Number of bytes of data in the 'set_vnet' linker set, and hence the total  * size of all kernel virtualized global variables, and the malloc(9) type  * that will be used to allocate it.  */
end_comment

begin_define
define|#
directive|define
name|VNET_BYTES
value|(VNET_STOP - VNET_START)
end_define

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_VNET_DATA
argument_list|,
literal|"vnet_data"
argument_list|,
literal|"VNET data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * VNET_MODMIN is the minimum number of bytes we will reserve for the sum of  * global variables across all loaded modules.  As this actually sizes an  * array declared as a virtualized global variable in the kernel itself, and  * we want the virtualized global variable space to be page-sized, we may  * have more space than that in practice.  */
end_comment

begin_define
define|#
directive|define
name|VNET_MODMIN
value|8192
end_define

begin_define
define|#
directive|define
name|VNET_SIZE
value|roundup2(VNET_BYTES, PAGE_SIZE)
end_define

begin_define
define|#
directive|define
name|VNET_MODSIZE
value|(VNET_SIZE - (VNET_BYTES - VNET_MODMIN))
end_define

begin_comment
comment|/*  * Space to store virtualized global variables from loadable kernel modules,  * and the free list to manage it.  */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|char
argument_list|,
name|modspace
index|[
name|VNET_MODMIN
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Global lists of subsystem constructor and destructors for vnets.  They are  * registered via VNET_SYSINIT() and VNET_SYSUNINIT().  Both lists are  * protected by the vnet_sysinit_sxlock global lock.  */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument|vnet_sysinit_head
argument_list|,
argument|vnet_sysinit
argument_list|)
name|vnet_constructors
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|vnet_constructors
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument|vnet_sysuninit_head
argument_list|,
argument|vnet_sysinit
argument_list|)
name|vnet_destructors
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|vnet_destructors
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|sx
name|vnet_sysinit_sxlock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VNET_SYSINIT_WLOCK
parameter_list|()
value|sx_xlock(&vnet_sysinit_sxlock);
end_define

begin_define
define|#
directive|define
name|VNET_SYSINIT_WUNLOCK
parameter_list|()
value|sx_xunlock(&vnet_sysinit_sxlock);
end_define

begin_define
define|#
directive|define
name|VNET_SYSINIT_RLOCK
parameter_list|()
value|sx_slock(&vnet_sysinit_sxlock);
end_define

begin_define
define|#
directive|define
name|VNET_SYSINIT_RUNLOCK
parameter_list|()
value|sx_sunlock(&vnet_sysinit_sxlock);
end_define

begin_struct
struct|struct
name|vnet_data_free
block|{
name|uintptr_t
name|vnd_start
decl_stmt|;
name|int
name|vnd_len
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|vnet_data_free
argument_list|)
name|vnd_link
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_VNET_DATA_FREE
argument_list|,
literal|"vnet_data_free"
argument_list|,
literal|"VNET resource accounting"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|vnet_data_free
argument_list|)
name|vnet_data_free_head
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|vnet_data_free_head
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|sx
name|vnet_data_free_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SDT_PROVIDER_DEFINE
argument_list|(
name|vnet
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SDT_PROBE_DEFINE1
argument_list|(
name|vnet
argument_list|,
name|functions
argument_list|,
name|vnet_alloc
argument_list|,
name|entry
argument_list|,
name|entry
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SDT_PROBE_DEFINE2
argument_list|(
name|vnet
argument_list|,
name|functions
argument_list|,
name|vnet_alloc
argument_list|,
name|alloc
argument_list|,
name|alloc
argument_list|,
literal|"int"
argument_list|,
literal|"struct vnet *"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|SDT_PROBE_DEFINE2
argument_list|(
argument|vnet
argument_list|,
argument|functions
argument_list|,
argument|vnet_alloc
argument_list|,
argument|return
argument_list|,
argument|return
argument_list|,
literal|"int"
argument_list|,
literal|"struct vnet *"
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|SDT_PROBE_DEFINE2
argument_list|(
name|vnet
argument_list|,
name|functions
argument_list|,
name|vnet_destroy
argument_list|,
name|entry
argument_list|,
name|entry
argument_list|,
literal|"int"
argument_list|,
literal|"struct vnet *"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|SDT_PROBE_DEFINE1
argument_list|(
argument|vnet
argument_list|,
argument|functions
argument_list|,
argument|vnet_destroy
argument_list|,
argument|return
argument_list|,
argument|entry
argument_list|,
literal|"int"
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_function_decl
specifier|static
name|void
name|db_show_vnet_print_vs
parameter_list|(
name|struct
name|vnet_sysinit
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Allocate a virtual network stack.  */
end_comment

begin_function
name|struct
name|vnet
modifier|*
name|vnet_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|vnet
modifier|*
name|vnet
decl_stmt|;
name|SDT_PROBE1
argument_list|(
name|vnet
argument_list|,
name|functions
argument_list|,
name|vnet_alloc
argument_list|,
name|entry
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|vnet
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vnet
argument_list|)
argument_list|,
name|M_VNET
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|vnet
operator|->
name|vnet_magic_n
operator|=
name|VNET_MAGIC_N
expr_stmt|;
name|SDT_PROBE2
argument_list|(
name|vnet
argument_list|,
name|functions
argument_list|,
name|vnet_alloc
argument_list|,
name|alloc
argument_list|,
name|__LINE__
argument_list|,
name|vnet
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate storage for virtualized global variables and copy in 	 * initial values form our 'master' copy. 	 */
name|vnet
operator|->
name|vnet_data_mem
operator|=
name|malloc
argument_list|(
name|VNET_SIZE
argument_list|,
name|M_VNET_DATA
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|vnet
operator|->
name|vnet_data_mem
argument_list|,
operator|(
name|void
operator|*
operator|)
name|VNET_START
argument_list|,
name|VNET_BYTES
argument_list|)
expr_stmt|;
comment|/* 	 * All use of vnet-specific data will immediately subtract VNET_START 	 * from the base memory pointer, so pre-calculate that now to avoid 	 * it on each use. 	 */
name|vnet
operator|->
name|vnet_data_base
operator|=
operator|(
name|uintptr_t
operator|)
name|vnet
operator|->
name|vnet_data_mem
operator|-
name|VNET_START
expr_stmt|;
comment|/* Initialize / attach vnet module instances. */
name|CURVNET_SET_QUIET
argument_list|(
name|vnet
argument_list|)
expr_stmt|;
name|vnet_sysinit
argument_list|()
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
name|VNET_LIST_WLOCK
argument_list|()
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|vnet_head
argument_list|,
name|vnet
argument_list|,
name|vnet_le
argument_list|)
expr_stmt|;
name|VNET_LIST_WUNLOCK
argument_list|()
expr_stmt|;
name|SDT_PROBE2
argument_list|(
argument|vnet
argument_list|,
argument|functions
argument_list|,
argument|vnet_alloc
argument_list|,
argument|return
argument_list|,
argument|__LINE__
argument_list|,
argument|vnet
argument_list|)
empty_stmt|;
return|return
operator|(
name|vnet
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy a virtual network stack.  */
end_comment

begin_function
name|void
name|vnet_destroy
parameter_list|(
name|struct
name|vnet
modifier|*
name|vnet
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|,
modifier|*
name|nifp
decl_stmt|;
name|SDT_PROBE2
argument_list|(
name|vnet
argument_list|,
name|functions
argument_list|,
name|vnet_destroy
argument_list|,
name|entry
argument_list|,
name|__LINE__
argument_list|,
name|vnet
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vnet
operator|->
name|vnet_sockcnt
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: vnet still has sockets"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|VNET_LIST_WLOCK
argument_list|()
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|vnet
argument_list|,
name|vnet_le
argument_list|)
expr_stmt|;
name|VNET_LIST_WUNLOCK
argument_list|()
expr_stmt|;
name|CURVNET_SET_QUIET
argument_list|(
name|vnet
argument_list|)
expr_stmt|;
comment|/* Return all inherited interfaces to their parent vnets. */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ifp
argument_list|,
argument|&V_ifnet
argument_list|,
argument|if_link
argument_list|,
argument|nifp
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|->
name|if_home_vnet
operator|!=
name|ifp
operator|->
name|if_vnet
condition|)
name|if_vmove
argument_list|(
name|ifp
argument_list|,
name|ifp
operator|->
name|if_home_vnet
argument_list|)
expr_stmt|;
block|}
name|vnet_sysuninit
argument_list|()
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
comment|/* 	 * Release storage for the virtual network stack instance. 	 */
name|free
argument_list|(
name|vnet
operator|->
name|vnet_data_mem
argument_list|,
name|M_VNET_DATA
argument_list|)
expr_stmt|;
name|vnet
operator|->
name|vnet_data_mem
operator|=
name|NULL
expr_stmt|;
name|vnet
operator|->
name|vnet_data_base
operator|=
literal|0
expr_stmt|;
name|vnet
operator|->
name|vnet_magic_n
operator|=
literal|0xdeadbeef
expr_stmt|;
name|free
argument_list|(
name|vnet
argument_list|,
name|M_VNET
argument_list|)
expr_stmt|;
name|SDT_PROBE1
argument_list|(
argument|vnet
argument_list|,
argument|functions
argument_list|,
argument|vnet_destroy
argument_list|,
argument|return
argument_list|,
argument|__LINE__
argument_list|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/*  * Boot time initialization and allocation of virtual network stacks.  */
end_comment

begin_function
specifier|static
name|void
name|vnet_init_prelink
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|rw_init
argument_list|(
operator|&
name|vnet_rwlock
argument_list|,
literal|"vnet_rwlock"
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|vnet_sxlock
argument_list|,
literal|"vnet_sxlock"
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|vnet_sysinit_sxlock
argument_list|,
literal|"vnet_sysinit_sxlock"
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|vnet_head
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|vnet_init_prelink
argument_list|,
name|SI_SUB_VNET_PRELINK
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|vnet_init_prelink
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|vnet0_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* Warn people before take off - in case we crash early. */
name|printf
argument_list|(
literal|"WARNING: VIMAGE (virtualized network stack) is a highly "
literal|"experimental feature.\n"
argument_list|)
expr_stmt|;
comment|/* 	 * We MUST clear curvnet in vi_init_done() before going SMP, 	 * otherwise CURVNET_SET() macros would scream about unnecessary 	 * curvnet recursions. 	 */
name|curvnet
operator|=
name|prison0
operator|.
name|pr_vnet
operator|=
name|vnet0
operator|=
name|vnet_alloc
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|vnet0_init
argument_list|,
name|SI_SUB_VNET
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|vnet0_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|vnet_init_done
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|curvnet
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|vnet_init_done
argument_list|,
name|SI_SUB_VNET_DONE
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|vnet_init_done
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Once on boot, initialize the modspace freelist to entirely cover modspace.  */
end_comment

begin_function
specifier|static
name|void
name|vnet_data_startup
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{
name|struct
name|vnet_data_free
modifier|*
name|df
decl_stmt|;
name|df
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|df
argument_list|)
argument_list|,
name|M_VNET_DATA_FREE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|df
operator|->
name|vnd_start
operator|=
operator|(
name|uintptr_t
operator|)
operator|&
name|VNET_NAME
argument_list|(
name|modspace
argument_list|)
expr_stmt|;
name|df
operator|->
name|vnd_len
operator|=
name|VNET_MODMIN
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|vnet_data_free_head
argument_list|,
name|df
argument_list|,
name|vnd_link
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|vnet_data_free_lock
argument_list|,
literal|"vnet_data alloc lock"
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|vnet_data
argument_list|,
name|SI_SUB_KLD
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|vnet_data_startup
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * When a module is loaded and requires storage for a virtualized global  * variable, allocate space from the modspace free list.  This interface  * should be used only by the kernel linker.  */
end_comment

begin_function
name|void
modifier|*
name|vnet_data_alloc
parameter_list|(
name|int
name|size
parameter_list|)
block|{
name|struct
name|vnet_data_free
modifier|*
name|df
decl_stmt|;
name|void
modifier|*
name|s
decl_stmt|;
name|s
operator|=
name|NULL
expr_stmt|;
name|size
operator|=
name|roundup2
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|vnet_data_free_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|df
argument_list|,
argument|&vnet_data_free_head
argument_list|,
argument|vnd_link
argument_list|)
block|{
if|if
condition|(
name|df
operator|->
name|vnd_len
operator|<
name|size
condition|)
continue|continue;
if|if
condition|(
name|df
operator|->
name|vnd_len
operator|==
name|size
condition|)
block|{
name|s
operator|=
operator|(
name|void
operator|*
operator|)
name|df
operator|->
name|vnd_start
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|vnet_data_free_head
argument_list|,
name|df
argument_list|,
name|vnd_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|df
argument_list|,
name|M_VNET_DATA_FREE
argument_list|)
expr_stmt|;
break|break;
block|}
name|s
operator|=
operator|(
name|void
operator|*
operator|)
name|df
operator|->
name|vnd_start
expr_stmt|;
name|df
operator|->
name|vnd_len
operator|-=
name|size
expr_stmt|;
name|df
operator|->
name|vnd_start
operator|=
name|df
operator|->
name|vnd_start
operator|+
name|size
expr_stmt|;
break|break;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|vnet_data_free_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free space for a virtualized global variable on module unload.  */
end_comment

begin_function
name|void
name|vnet_data_free
parameter_list|(
name|void
modifier|*
name|start_arg
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|vnet_data_free
modifier|*
name|df
decl_stmt|;
name|struct
name|vnet_data_free
modifier|*
name|dn
decl_stmt|;
name|uintptr_t
name|start
decl_stmt|;
name|uintptr_t
name|end
decl_stmt|;
name|size
operator|=
name|roundup2
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|start
operator|=
operator|(
name|uintptr_t
operator|)
name|start_arg
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|size
expr_stmt|;
comment|/* 	 * Free a region of space and merge it with as many neighbors as 	 * possible.  Keeping the list sorted simplifies this operation. 	 */
name|sx_xlock
argument_list|(
operator|&
name|vnet_data_free_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|df
argument_list|,
argument|&vnet_data_free_head
argument_list|,
argument|vnd_link
argument_list|)
block|{
if|if
condition|(
name|df
operator|->
name|vnd_start
operator|>
name|end
condition|)
break|break;
comment|/* 		 * If we expand at the end of an entry we may have to merge 		 * it with the one following it as well. 		 */
if|if
condition|(
name|df
operator|->
name|vnd_start
operator|+
name|df
operator|->
name|vnd_len
operator|==
name|start
condition|)
block|{
name|df
operator|->
name|vnd_len
operator|+=
name|size
expr_stmt|;
name|dn
operator|=
name|TAILQ_NEXT
argument_list|(
name|df
argument_list|,
name|vnd_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|df
operator|->
name|vnd_start
operator|+
name|df
operator|->
name|vnd_len
operator|==
name|dn
operator|->
name|vnd_start
condition|)
block|{
name|df
operator|->
name|vnd_len
operator|+=
name|dn
operator|->
name|vnd_len
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|vnet_data_free_head
argument_list|,
name|dn
argument_list|,
name|vnd_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dn
argument_list|,
name|M_VNET_DATA_FREE
argument_list|)
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|vnet_data_free_lock
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|df
operator|->
name|vnd_start
operator|==
name|end
condition|)
block|{
name|df
operator|->
name|vnd_start
operator|=
name|start
expr_stmt|;
name|df
operator|->
name|vnd_len
operator|+=
name|size
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|vnet_data_free_lock
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|dn
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|df
argument_list|)
argument_list|,
name|M_VNET_DATA_FREE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|dn
operator|->
name|vnd_start
operator|=
name|start
expr_stmt|;
name|dn
operator|->
name|vnd_len
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|df
condition|)
name|TAILQ_INSERT_BEFORE
argument_list|(
name|df
argument_list|,
name|dn
argument_list|,
name|vnd_link
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|vnet_data_free_head
argument_list|,
name|dn
argument_list|,
name|vnd_link
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|vnet_data_free_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * When a new virtualized global variable has been allocated, propagate its  * initial value to each already-allocated virtual network stack instance.  */
end_comment

begin_function
name|void
name|vnet_data_copy
parameter_list|(
name|void
modifier|*
name|start
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|vnet
modifier|*
name|vnet
decl_stmt|;
name|VNET_LIST_RLOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|vnet
argument_list|,
argument|&vnet_head
argument_list|,
argument|vnet_le
argument_list|)
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|vnet
operator|->
name|vnet_data_base
operator|+
operator|(
name|uintptr_t
operator|)
name|start
operator|)
argument_list|,
name|start
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|VNET_LIST_RUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Variants on sysctl_handle_foo that know how to handle virtualized global  * variables: if 'arg1' is a pointer, then we transform it to the local vnet  * offset.  */
end_comment

begin_function
name|int
name|vnet_sysctl_handle_int
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
if|if
condition|(
name|arg1
operator|!=
name|NULL
condition|)
name|arg1
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|curvnet
operator|->
name|vnet_data_base
operator|+
operator|(
name|uintptr_t
operator|)
name|arg1
operator|)
expr_stmt|;
return|return
operator|(
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vnet_sysctl_handle_opaque
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
if|if
condition|(
name|arg1
operator|!=
name|NULL
condition|)
name|arg1
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|curvnet
operator|->
name|vnet_data_base
operator|+
operator|(
name|uintptr_t
operator|)
name|arg1
operator|)
expr_stmt|;
return|return
operator|(
name|sysctl_handle_opaque
argument_list|(
name|oidp
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vnet_sysctl_handle_string
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
if|if
condition|(
name|arg1
operator|!=
name|NULL
condition|)
name|arg1
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|curvnet
operator|->
name|vnet_data_base
operator|+
operator|(
name|uintptr_t
operator|)
name|arg1
operator|)
expr_stmt|;
return|return
operator|(
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vnet_sysctl_handle_uint
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
if|if
condition|(
name|arg1
operator|!=
name|NULL
condition|)
name|arg1
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|curvnet
operator|->
name|vnet_data_base
operator|+
operator|(
name|uintptr_t
operator|)
name|arg1
operator|)
expr_stmt|;
return|return
operator|(
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|req
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Support for special SYSINIT handlers registered via VNET_SYSINIT()  * and VNET_SYSUNINIT().  */
end_comment

begin_function
name|void
name|vnet_register_sysinit
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|vnet_sysinit
modifier|*
name|vs
decl_stmt|,
modifier|*
name|vs2
decl_stmt|;
name|struct
name|vnet
modifier|*
name|vnet
decl_stmt|;
name|vs
operator|=
name|arg
expr_stmt|;
name|KASSERT
argument_list|(
name|vs
operator|->
name|subsystem
operator|>
name|SI_SUB_VNET
argument_list|,
operator|(
literal|"vnet sysinit too early"
operator|)
argument_list|)
expr_stmt|;
comment|/* Add the constructor to the global list of vnet constructors. */
name|VNET_SYSINIT_WLOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vs2
argument_list|,
argument|&vnet_constructors
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|vs2
operator|->
name|subsystem
operator|>
name|vs
operator|->
name|subsystem
condition|)
break|break;
if|if
condition|(
name|vs2
operator|->
name|subsystem
operator|==
name|vs
operator|->
name|subsystem
operator|&&
name|vs2
operator|->
name|order
operator|>
name|vs
operator|->
name|order
condition|)
break|break;
block|}
if|if
condition|(
name|vs2
operator|!=
name|NULL
condition|)
name|TAILQ_INSERT_BEFORE
argument_list|(
name|vs2
argument_list|,
name|vs
argument_list|,
name|link
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|vnet_constructors
argument_list|,
name|vs
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 	 * Invoke the constructor on all the existing vnets when it is 	 * registered. 	 */
name|VNET_FOREACH
argument_list|(
argument|vnet
argument_list|)
block|{
name|CURVNET_SET_QUIET
argument_list|(
name|vnet
argument_list|)
expr_stmt|;
name|vs
operator|->
name|func
argument_list|(
name|vs
operator|->
name|arg
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
name|VNET_SYSINIT_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vnet_deregister_sysinit
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|vnet_sysinit
modifier|*
name|vs
decl_stmt|;
name|vs
operator|=
name|arg
expr_stmt|;
comment|/* Remove the constructor from the global list of vnet constructors. */
name|VNET_SYSINIT_WLOCK
argument_list|()
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|vnet_constructors
argument_list|,
name|vs
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|VNET_SYSINIT_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vnet_register_sysuninit
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|vnet_sysinit
modifier|*
name|vs
decl_stmt|,
modifier|*
name|vs2
decl_stmt|;
name|vs
operator|=
name|arg
expr_stmt|;
comment|/* Add the destructor to the global list of vnet destructors. */
name|VNET_SYSINIT_WLOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vs2
argument_list|,
argument|&vnet_destructors
argument_list|,
argument|link
argument_list|)
block|{
if|if
condition|(
name|vs2
operator|->
name|subsystem
operator|>
name|vs
operator|->
name|subsystem
condition|)
break|break;
if|if
condition|(
name|vs2
operator|->
name|subsystem
operator|==
name|vs
operator|->
name|subsystem
operator|&&
name|vs2
operator|->
name|order
operator|>
name|vs
operator|->
name|order
condition|)
break|break;
block|}
if|if
condition|(
name|vs2
operator|!=
name|NULL
condition|)
name|TAILQ_INSERT_BEFORE
argument_list|(
name|vs2
argument_list|,
name|vs
argument_list|,
name|link
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|vnet_destructors
argument_list|,
name|vs
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|VNET_SYSINIT_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vnet_deregister_sysuninit
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|vnet_sysinit
modifier|*
name|vs
decl_stmt|;
name|struct
name|vnet
modifier|*
name|vnet
decl_stmt|;
name|vs
operator|=
name|arg
expr_stmt|;
comment|/* 	 * Invoke the destructor on all the existing vnets when it is 	 * deregistered. 	 */
name|VNET_SYSINIT_WLOCK
argument_list|()
expr_stmt|;
name|VNET_FOREACH
argument_list|(
argument|vnet
argument_list|)
block|{
name|CURVNET_SET_QUIET
argument_list|(
name|vnet
argument_list|)
expr_stmt|;
name|vs
operator|->
name|func
argument_list|(
name|vs
operator|->
name|arg
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
comment|/* Remove the destructor from the global list of vnet destructors. */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|vnet_destructors
argument_list|,
name|vs
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|VNET_SYSINIT_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Invoke all registered vnet constructors on the current vnet.  Used during  * vnet construction.  The caller is responsible for ensuring the new vnet is  * the current vnet and that the vnet_sysinit_sxlock lock is locked.  */
end_comment

begin_function
name|void
name|vnet_sysinit
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|vnet_sysinit
modifier|*
name|vs
decl_stmt|;
name|VNET_SYSINIT_RLOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vs
argument_list|,
argument|&vnet_constructors
argument_list|,
argument|link
argument_list|)
block|{
name|vs
operator|->
name|func
argument_list|(
name|vs
operator|->
name|arg
argument_list|)
expr_stmt|;
block|}
name|VNET_SYSINIT_RUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Invoke all registered vnet destructors on the current vnet.  Used during  * vnet destruction.  The caller is responsible for ensuring the dying vnet  * the current vnet and that the vnet_sysinit_sxlock lock is locked.  */
end_comment

begin_function
name|void
name|vnet_sysuninit
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|vnet_sysinit
modifier|*
name|vs
decl_stmt|;
name|VNET_SYSINIT_RLOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH_REVERSE
argument_list|(
argument|vs
argument_list|,
argument|&vnet_destructors
argument_list|,
argument|vnet_sysuninit_head
argument_list|,
argument|link
argument_list|)
block|{
name|vs
operator|->
name|func
argument_list|(
name|vs
operator|->
name|arg
argument_list|)
expr_stmt|;
block|}
name|VNET_SYSINIT_RUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * EVENTHANDLER(9) extensions.  */
end_comment

begin_comment
comment|/*  * Invoke the eventhandler function originally registered with the possibly  * registered argument for all virtual network stack instances.  *  * This iterator can only be used for eventhandlers that do not take any  * additional arguments, as we do ignore the variadic arguments from the  * EVENTHANDLER_INVOKE() call.  */
end_comment

begin_function
name|void
name|vnet_global_eventhandler_iterator_func
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|VNET_ITERATOR_DECL
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|struct
name|eventhandler_entry_vimage
modifier|*
name|v_ee
decl_stmt|;
comment|/* 	 * There is a bug here in that we should actually cast things to 	 * (struct eventhandler_entry_ ## name *)  but that's not easily 	 * possible in here so just re-using the variadic version we 	 * defined for the generic vimage case. 	 */
name|v_ee
operator|=
name|arg
expr_stmt|;
name|VNET_LIST_RLOCK
argument_list|()
expr_stmt|;
name|VNET_FOREACH
argument_list|(
argument|vnet_iter
argument_list|)
block|{
name|CURVNET_SET
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
operator|(
operator|(
name|vimage_iterator_func_t
operator|)
name|v_ee
operator|->
name|func
operator|)
operator|(
name|v_ee
operator|->
name|ee_arg
operator|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
name|VNET_LIST_RUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VNET_DEBUG
end_ifdef

begin_struct
struct|struct
name|vnet_recursion
block|{
name|SLIST_ENTRY
argument_list|(
argument|vnet_recursion
argument_list|)
name|vnr_le
expr_stmt|;
specifier|const
name|char
modifier|*
name|prev_fn
decl_stmt|;
specifier|const
name|char
modifier|*
name|where_fn
decl_stmt|;
name|int
name|where_line
decl_stmt|;
name|struct
name|vnet
modifier|*
name|old_vnet
decl_stmt|;
name|struct
name|vnet
modifier|*
name|new_vnet
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|SLIST_HEAD
argument_list|(
argument_list|,
argument|vnet_recursion
argument_list|)
name|vnet_recursions
operator|=
name|SLIST_HEAD_INITIALIZER
argument_list|(
name|vnet_recursions
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|vnet_print_recursion
parameter_list|(
name|struct
name|vnet_recursion
modifier|*
name|vnr
parameter_list|,
name|int
name|brief
parameter_list|)
block|{
if|if
condition|(
operator|!
name|brief
condition|)
name|printf
argument_list|(
literal|"CURVNET_SET() recursion in "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s() line %d, prev in %s()"
argument_list|,
name|vnr
operator|->
name|where_fn
argument_list|,
name|vnr
operator|->
name|where_line
argument_list|,
name|vnr
operator|->
name|prev_fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|brief
condition|)
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\n    "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%p -> %p\n"
argument_list|,
name|vnr
operator|->
name|old_vnet
argument_list|,
name|vnr
operator|->
name|new_vnet
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vnet_log_recursion
parameter_list|(
name|struct
name|vnet
modifier|*
name|old_vnet
parameter_list|,
specifier|const
name|char
modifier|*
name|old_fn
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|struct
name|vnet_recursion
modifier|*
name|vnr
decl_stmt|;
comment|/* Skip already logged recursion events. */
name|SLIST_FOREACH
argument_list|(
argument|vnr
argument_list|,
argument|&vnet_recursions
argument_list|,
argument|vnr_le
argument_list|)
if|if
condition|(
name|vnr
operator|->
name|prev_fn
operator|==
name|old_fn
operator|&&
name|vnr
operator|->
name|where_fn
operator|==
name|curthread
operator|->
name|td_vnet_lpush
operator|&&
name|vnr
operator|->
name|where_line
operator|==
name|line
operator|&&
operator|(
name|vnr
operator|->
name|old_vnet
operator|==
name|vnr
operator|->
name|new_vnet
operator|)
operator|==
operator|(
name|curvnet
operator|==
name|old_vnet
operator|)
condition|)
return|return;
name|vnr
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vnr
argument_list|)
argument_list|,
name|M_VNET
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|vnr
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: malloc failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|vnr
operator|->
name|prev_fn
operator|=
name|old_fn
expr_stmt|;
name|vnr
operator|->
name|where_fn
operator|=
name|curthread
operator|->
name|td_vnet_lpush
expr_stmt|;
name|vnr
operator|->
name|where_line
operator|=
name|line
expr_stmt|;
name|vnr
operator|->
name|old_vnet
operator|=
name|old_vnet
expr_stmt|;
name|vnr
operator|->
name|new_vnet
operator|=
name|curvnet
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|vnet_recursions
argument_list|,
name|vnr
argument_list|,
name|vnr_le
argument_list|)
expr_stmt|;
name|vnet_print_recursion
argument_list|(
name|vnr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|KDB
name|kdb_backtrace
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VNET_DEBUG */
end_comment

begin_comment
comment|/*  * DDB(4).  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DDB
end_ifdef

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|vnets
argument_list|,
argument|db_show_vnets
argument_list|)
end_macro

begin_block
block|{
name|VNET_ITERATOR_DECL
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|VNET_FOREACH
argument_list|(
argument|vnet_iter
argument_list|)
block|{
name|db_printf
argument_list|(
literal|"vnet            = %p\n"
argument_list|,
name|vnet_iter
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|" vnet_magic_n   = 0x%x (%s, orig 0x%x)\n"
argument_list|,
name|vnet_iter
operator|->
name|vnet_magic_n
argument_list|,
operator|(
name|vnet_iter
operator|->
name|vnet_magic_n
operator|==
name|VNET_MAGIC_N
operator|)
condition|?
literal|"ok"
else|:
literal|"mismatch"
argument_list|,
name|VNET_MAGIC_N
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|" vnet_ifcnt     = %u\n"
argument_list|,
name|vnet_iter
operator|->
name|vnet_ifcnt
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|" vnet_sockcnt   = %u\n"
argument_list|,
name|vnet_iter
operator|->
name|vnet_sockcnt
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|" vnet_data_mem  = %p\n"
argument_list|,
name|vnet_iter
operator|->
name|vnet_data_mem
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|" vnet_data_base = 0x%jx\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|vnet_iter
operator|->
name|vnet_data_base
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_pager_quit
condition|)
break|break;
block|}
block|}
end_block

begin_function
specifier|static
name|void
name|db_show_vnet_print_vs
parameter_list|(
name|struct
name|vnet_sysinit
modifier|*
name|vs
parameter_list|,
name|int
name|ddb
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|vsname
decl_stmt|,
modifier|*
name|funcname
decl_stmt|;
name|c_db_sym_t
name|sym
decl_stmt|;
name|db_expr_t
name|offset
decl_stmt|;
define|#
directive|define
name|xprint
parameter_list|(
modifier|...
parameter_list|)
define|\
value|if (ddb)							\ 		db_printf(__VA_ARGS__);					\ 	else								\ 		printf(__VA_ARGS__)
if|if
condition|(
name|vs
operator|==
name|NULL
condition|)
block|{
name|xprint
argument_list|(
literal|"%s: no vnet_sysinit * given\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|sym
operator|=
name|db_search_symbol
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vs
argument_list|,
name|DB_STGY_ANY
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|db_symbol_values
argument_list|(
name|sym
argument_list|,
operator|&
name|vsname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sym
operator|=
name|db_search_symbol
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|vs
operator|->
name|func
argument_list|,
name|DB_STGY_PROC
argument_list|,
operator|&
name|offset
argument_list|)
expr_stmt|;
name|db_symbol_values
argument_list|(
name|sym
argument_list|,
operator|&
name|funcname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|xprint
argument_list|(
literal|"%s(%p)\n"
argument_list|,
operator|(
name|vsname
operator|!=
name|NULL
operator|)
condition|?
name|vsname
else|:
literal|""
argument_list|,
name|vs
argument_list|)
expr_stmt|;
name|xprint
argument_list|(
literal|"  0x%08x 0x%08x\n"
argument_list|,
name|vs
operator|->
name|subsystem
argument_list|,
name|vs
operator|->
name|order
argument_list|)
expr_stmt|;
name|xprint
argument_list|(
literal|"  %p(%s)(%p)\n"
argument_list|,
name|vs
operator|->
name|func
argument_list|,
operator|(
name|funcname
operator|!=
name|NULL
operator|)
condition|?
name|funcname
else|:
literal|""
argument_list|,
name|vs
operator|->
name|arg
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|xprint
block|}
end_function

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|vnet_sysinit
argument_list|,
argument|db_show_vnet_sysinit
argument_list|)
end_macro

begin_block
block|{
name|struct
name|vnet_sysinit
modifier|*
name|vs
decl_stmt|;
name|db_printf
argument_list|(
literal|"VNET_SYSINIT vs Name(Ptr)\n"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"  Subsystem  Order\n"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"  Function(Name)(Arg)\n"
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vs
argument_list|,
argument|&vnet_constructors
argument_list|,
argument|link
argument_list|)
block|{
name|db_show_vnet_print_vs
argument_list|(
name|vs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_pager_quit
condition|)
break|break;
block|}
block|}
end_block

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|vnet_sysuninit
argument_list|,
argument|db_show_vnet_sysuninit
argument_list|)
end_macro

begin_block
block|{
name|struct
name|vnet_sysinit
modifier|*
name|vs
decl_stmt|;
name|db_printf
argument_list|(
literal|"VNET_SYSUNINIT vs Name(Ptr)\n"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"  Subsystem  Order\n"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"  Function(Name)(Arg)\n"
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_REVERSE
argument_list|(
argument|vs
argument_list|,
argument|&vnet_destructors
argument_list|,
argument|vnet_sysuninit_head
argument_list|,
argument|link
argument_list|)
block|{
name|db_show_vnet_print_vs
argument_list|(
name|vs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_pager_quit
condition|)
break|break;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|VNET_DEBUG
end_ifdef

begin_macro
name|DB_SHOW_COMMAND
argument_list|(
argument|vnetrcrs
argument_list|,
argument|db_show_vnetrcrs
argument_list|)
end_macro

begin_block
block|{
name|struct
name|vnet_recursion
modifier|*
name|vnr
decl_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|vnr
argument_list|,
argument|&vnet_recursions
argument_list|,
argument|vnr_le
argument_list|)
name|vnet_print_recursion
argument_list|(
name|vnr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DDB */
end_comment

end_unit

