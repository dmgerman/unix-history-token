begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: if_media.c,v 1.1 1997/03/17 02:55:15 thorpej Exp $	*/
end_comment

begin_comment
comment|/*	$Id: if_media.c,v 1.4 1998/02/04 22:33:03 eivind Exp $ */
end_comment

begin_comment
comment|/*  * Copyright (c) 1997  *	Jonathan Stone and Jason R. Thorpe.  All rights reserved.  *  * This software is derived from information provided by Matt Thomas.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Jonathan Stone  *	and Jason R. Thorpe for the NetBSD Project.  * 4. The names of the authors may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * BSD/OS-compatible network interface media selection.  *  * Where it is safe to do so, this code strays slightly from the BSD/OS  * design.  Software which uses the API (device drivers, basically)  * shouldn't notice any difference.  *  * Many thanks to Matt Thomas for providing the information necessary  * to implement this interface.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_comment
comment|/*  * Compile-time options:  * IFMEDIA_DEBUG:  *	turn on implementation-level debug printfs.  * 	Useful for debugging newly-ported  drivers.  */
end_comment

begin_decl_stmt
name|struct
name|ifmedia_entry
modifier|*
name|ifmedia_match
name|__P
argument_list|(
operator|(
expr|struct
name|ifmedia
operator|*
name|ifm
operator|,
name|int
name|flags
operator|,
name|int
name|mask
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IFMEDIA_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|ifmedia_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ifmedia_printword
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Initialize if_media struct for a specific interface instance.  */
end_comment

begin_function
name|void
name|ifmedia_init
parameter_list|(
name|ifm
parameter_list|,
name|dontcare_mask
parameter_list|,
name|change_callback
parameter_list|,
name|status_callback
parameter_list|)
name|struct
name|ifmedia
modifier|*
name|ifm
decl_stmt|;
name|int
name|dontcare_mask
decl_stmt|;
name|ifm_change_cb_t
name|change_callback
decl_stmt|;
name|ifm_stat_cb_t
name|status_callback
decl_stmt|;
block|{
name|LIST_INIT
argument_list|(
operator|&
name|ifm
operator|->
name|ifm_list
argument_list|)
expr_stmt|;
name|ifm
operator|->
name|ifm_cur
operator|=
name|NULL
expr_stmt|;
name|ifm
operator|->
name|ifm_media
operator|=
literal|0
expr_stmt|;
name|ifm
operator|->
name|ifm_mask
operator|=
name|dontcare_mask
expr_stmt|;
comment|/* IF don't-care bits */
name|ifm
operator|->
name|ifm_change
operator|=
name|change_callback
expr_stmt|;
name|ifm
operator|->
name|ifm_status
operator|=
name|status_callback
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a media configuration to the list of supported media  * for a specific interface instance.  */
end_comment

begin_function
name|void
name|ifmedia_add
parameter_list|(
name|ifm
parameter_list|,
name|mword
parameter_list|,
name|data
parameter_list|,
name|aux
parameter_list|)
name|struct
name|ifmedia
modifier|*
name|ifm
decl_stmt|;
name|int
name|mword
decl_stmt|;
name|int
name|data
decl_stmt|;
name|void
modifier|*
name|aux
decl_stmt|;
block|{
specifier|register
name|struct
name|ifmedia_entry
modifier|*
name|entry
decl_stmt|;
ifdef|#
directive|ifdef
name|IFMEDIA_DEBUG
if|if
condition|(
name|ifmedia_debug
condition|)
block|{
if|if
condition|(
name|ifm
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ifmedia_add: null ifm\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"Adding entry for "
argument_list|)
expr_stmt|;
name|ifmedia_printword
argument_list|(
name|mword
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|entry
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|,
name|M_IFADDR
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"ifmedia_add: can't malloc entry"
argument_list|)
expr_stmt|;
name|entry
operator|->
name|ifm_media
operator|=
name|mword
expr_stmt|;
name|entry
operator|->
name|ifm_data
operator|=
name|data
expr_stmt|;
name|entry
operator|->
name|ifm_aux
operator|=
name|aux
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ifm
operator|->
name|ifm_list
argument_list|,
name|entry
argument_list|,
name|ifm_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add an array of media configurations to the list of  * supported media for a specific interface instance.  */
end_comment

begin_function
name|void
name|ifmedia_list_add
parameter_list|(
name|ifm
parameter_list|,
name|lp
parameter_list|,
name|count
parameter_list|)
name|struct
name|ifmedia
modifier|*
name|ifm
decl_stmt|;
name|struct
name|ifmedia_entry
modifier|*
name|lp
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|ifmedia_add
argument_list|(
name|ifm
argument_list|,
name|lp
index|[
name|i
index|]
operator|.
name|ifm_media
argument_list|,
name|lp
index|[
name|i
index|]
operator|.
name|ifm_data
argument_list|,
name|lp
index|[
name|i
index|]
operator|.
name|ifm_aux
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the default active media.   *  * Called by device-specific code which is assumed to have already  * selected the default media in hardware.  We do _not_ call the  * media-change callback.  */
end_comment

begin_function
name|void
name|ifmedia_set
parameter_list|(
name|ifm
parameter_list|,
name|target
parameter_list|)
name|struct
name|ifmedia
modifier|*
name|ifm
decl_stmt|;
name|int
name|target
decl_stmt|;
block|{
name|struct
name|ifmedia_entry
modifier|*
name|match
decl_stmt|;
name|match
operator|=
name|ifmedia_match
argument_list|(
name|ifm
argument_list|,
name|target
argument_list|,
name|ifm
operator|->
name|ifm_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ifmedia_set: no match for 0x%x/0x%x\n"
argument_list|,
name|target
argument_list|,
operator|~
name|ifm
operator|->
name|ifm_mask
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"ifmedia_set"
argument_list|)
expr_stmt|;
block|}
name|ifm
operator|->
name|ifm_cur
operator|=
name|match
expr_stmt|;
ifdef|#
directive|ifdef
name|IFMEDIA_DEBUG
if|if
condition|(
name|ifmedia_debug
condition|)
block|{
name|printf
argument_list|(
literal|"ifmedia_set: target "
argument_list|)
expr_stmt|;
name|ifmedia_printword
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ifmedia_set: setting to "
argument_list|)
expr_stmt|;
name|ifmedia_printword
argument_list|(
name|ifm
operator|->
name|ifm_cur
operator|->
name|ifm_media
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Device-independent media ioctl support function.  */
end_comment

begin_function
name|int
name|ifmedia_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|ifr
parameter_list|,
name|ifm
parameter_list|,
name|cmd
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|struct
name|ifmedia
modifier|*
name|ifm
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
block|{
name|struct
name|ifmedia_entry
modifier|*
name|match
decl_stmt|;
name|struct
name|ifmediareq
modifier|*
name|ifmr
init|=
operator|(
expr|struct
name|ifmediareq
operator|*
operator|)
name|ifr
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|sticky
decl_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
operator|||
name|ifr
operator|==
name|NULL
operator|||
name|ifm
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* 	 * Set the current media. 	 */
case|case
name|SIOCSIFMEDIA
case|:
block|{
name|struct
name|ifmedia_entry
modifier|*
name|oldentry
decl_stmt|;
name|int
name|oldmedia
decl_stmt|;
name|int
name|newmedia
init|=
name|ifr
operator|->
name|ifr_media
decl_stmt|;
name|match
operator|=
name|ifmedia_match
argument_list|(
name|ifm
argument_list|,
name|newmedia
argument_list|,
name|ifm
operator|->
name|ifm_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|IFMEDIA_DEBUG
if|if
condition|(
name|ifmedia_debug
condition|)
block|{
name|printf
argument_list|(
literal|"ifmedia_ioctl: no media found for 0x%x\n"
argument_list|,
name|newmedia
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 		 * If no change, we're done. 		 * XXX Automedia may invole software intervention. 		 *     Keep going in case the the connected media changed. 		 *     Similarly, if best match changed (kernel debugger?). 		 */
if|if
condition|(
operator|(
name|IFM_SUBTYPE
argument_list|(
name|newmedia
argument_list|)
operator|!=
name|IFM_AUTO
operator|)
operator|&&
operator|(
name|newmedia
operator|==
name|ifm
operator|->
name|ifm_media
operator|)
operator|&&
operator|(
name|match
operator|==
name|ifm
operator|->
name|ifm_cur
operator|)
condition|)
return|return
literal|0
return|;
comment|/* 		 * We found a match, now make the driver switch to it. 		 * Make sure to preserve our old media type in case the 		 * driver can't switch. 		 */
ifdef|#
directive|ifdef
name|IFMEDIA_DEBUG
if|if
condition|(
name|ifmedia_debug
condition|)
block|{
name|printf
argument_list|(
literal|"ifmedia_ioctl: switching %s to "
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|ifmedia_printword
argument_list|(
name|match
operator|->
name|ifm_media
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|oldentry
operator|=
name|ifm
operator|->
name|ifm_cur
expr_stmt|;
name|oldmedia
operator|=
name|ifm
operator|->
name|ifm_media
expr_stmt|;
name|ifm
operator|->
name|ifm_cur
operator|=
name|match
expr_stmt|;
name|ifm
operator|->
name|ifm_media
operator|=
name|newmedia
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|ifm
operator|->
name|ifm_change
call|)
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ifm
operator|->
name|ifm_cur
operator|=
name|oldentry
expr_stmt|;
name|ifm
operator|->
name|ifm_media
operator|=
name|oldmedia
expr_stmt|;
block|}
break|break;
block|}
comment|/* 	 * Get list of available media and current media on interface. 	 */
case|case
name|SIOCGIFMEDIA
case|:
block|{
name|struct
name|ifmedia_entry
modifier|*
name|ep
decl_stmt|;
name|int
modifier|*
name|kptr
decl_stmt|,
name|count
decl_stmt|;
name|kptr
operator|=
name|NULL
expr_stmt|;
comment|/* XXX gcc */
name|ifmr
operator|->
name|ifm_active
operator|=
name|ifmr
operator|->
name|ifm_current
operator|=
name|ifm
operator|->
name|ifm_cur
condition|?
name|ifm
operator|->
name|ifm_cur
operator|->
name|ifm_media
else|:
name|IFM_NONE
expr_stmt|;
name|ifmr
operator|->
name|ifm_mask
operator|=
name|ifm
operator|->
name|ifm_mask
expr_stmt|;
name|ifmr
operator|->
name|ifm_status
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|ifm
operator|->
name|ifm_status
call|)
argument_list|(
name|ifp
argument_list|,
name|ifmr
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|ep
operator|=
name|ifm
operator|->
name|ifm_list
operator|.
name|lh_first
expr_stmt|;
if|if
condition|(
name|ifmr
operator|->
name|ifm_count
operator|!=
literal|0
condition|)
block|{
name|kptr
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|ifmr
operator|->
name|ifm_count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 			 * Get the media words from the interface's list. 			 */
for|for
control|(
init|;
name|ep
operator|!=
name|NULL
operator|&&
name|count
operator|<
name|ifmr
operator|->
name|ifm_count
condition|;
name|ep
operator|=
name|ep
operator|->
name|ifm_list
operator|.
name|le_next
operator|,
name|count
operator|++
control|)
name|kptr
index|[
name|count
index|]
operator|=
name|ep
operator|->
name|ifm_media
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
name|error
operator|=
name|E2BIG
expr_stmt|;
comment|/* oops! */
block|}
comment|/* 		 * If there are more interfaces on the list, count 		 * them.  This allows the caller to set ifmr->ifm_count 		 * to 0 on the first call to know how much space to 		 * callocate. 		 */
for|for
control|(
init|;
name|ep
operator|!=
name|NULL
condition|;
name|ep
operator|=
name|ep
operator|->
name|ifm_list
operator|.
name|le_next
control|)
name|count
operator|++
expr_stmt|;
comment|/* 		 * We do the copyout on E2BIG, because that's 		 * just our way of telling userland that there 		 * are more.  This is the behavior I've observed 		 * under BSD/OS 3.0 		 */
name|sticky
operator|=
name|error
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|E2BIG
operator|)
operator|&&
name|ifmr
operator|->
name|ifm_count
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
name|kptr
argument_list|,
operator|(
name|caddr_t
operator|)
name|ifmr
operator|->
name|ifm_ulist
argument_list|,
name|ifmr
operator|->
name|ifm_count
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|sticky
expr_stmt|;
if|if
condition|(
name|ifmr
operator|->
name|ifm_count
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|kptr
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|ifmr
operator|->
name|ifm_count
operator|=
name|count
expr_stmt|;
break|break;
block|}
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find media entry matching a given ifm word.  *  */
end_comment

begin_function
name|struct
name|ifmedia_entry
modifier|*
name|ifmedia_match
parameter_list|(
name|ifm
parameter_list|,
name|target
parameter_list|,
name|mask
parameter_list|)
name|struct
name|ifmedia
modifier|*
name|ifm
decl_stmt|;
name|int
name|target
decl_stmt|;
name|int
name|mask
decl_stmt|;
block|{
name|struct
name|ifmedia_entry
modifier|*
name|match
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|match
operator|=
name|NULL
expr_stmt|;
name|mask
operator|=
operator|~
name|mask
expr_stmt|;
for|for
control|(
name|next
operator|=
name|ifm
operator|->
name|ifm_list
operator|.
name|lh_first
init|;
name|next
operator|!=
name|NULL
condition|;
name|next
operator|=
name|next
operator|->
name|ifm_list
operator|.
name|le_next
control|)
block|{
if|if
condition|(
operator|(
name|next
operator|->
name|ifm_media
operator|&
name|mask
operator|)
operator|==
operator|(
name|target
operator|&
name|mask
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|IFMEDIA_DEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
if|if
condition|(
name|match
condition|)
block|{
name|printf
argument_list|(
literal|"ifmedia_match: multiple match for "
literal|"0x%x/0x%x\n"
argument_list|,
name|target
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|match
operator|=
name|next
expr_stmt|;
block|}
block|}
return|return
name|match
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IFMEDIA_DEBUG
end_ifdef

begin_decl_stmt
name|struct
name|ifmedia_description
name|ifm_type_descriptions
index|[]
init|=
name|IFM_TYPE_DESCRIPTIONS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ifmedia_description
name|ifm_subtype_ethernet_descriptions
index|[]
init|=
name|IFM_SUBTYPE_ETHERNET_DESCRIPTIONS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ifmedia_description
name|ifm_subtype_ethernet_option_descriptions
index|[]
init|=
name|IFM_SUBTYPE_ETHERNET_OPTION_DESCRIPTIONS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ifmedia_description
name|ifm_subtype_tokenring_descriptions
index|[]
init|=
name|IFM_SUBTYPE_TOKENRING_DESCRIPTIONS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ifmedia_description
name|ifm_subtype_tokenring_option_descriptions
index|[]
init|=
name|IFM_SUBTYPE_TOKENRING_OPTION_DESCRIPTIONS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ifmedia_description
name|ifm_subtype_fddi_descriptions
index|[]
init|=
name|IFM_SUBTYPE_FDDI_DESCRIPTIONS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ifmedia_description
name|ifm_subtype_fddi_option_descriptions
index|[]
init|=
name|IFM_SUBTYPE_FDDI_OPTION_DESCRIPTIONS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ifmedia_description
name|ifm_subtype_shared_descriptions
index|[]
init|=
name|IFM_SUBTYPE_SHARED_DESCRIPTIONS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ifmedia_description
name|ifm_shared_option_descriptions
index|[]
init|=
name|IFM_SHARED_OPTION_DESCRIPTIONS
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ifmedia_type_to_subtype
block|{
name|struct
name|ifmedia_description
modifier|*
name|subtypes
decl_stmt|;
name|struct
name|ifmedia_description
modifier|*
name|options
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* must be in the same order as IFM_TYPE_DESCRIPTIONS */
end_comment

begin_decl_stmt
name|struct
name|ifmedia_type_to_subtype
name|ifmedia_types_to_subtypes
index|[]
init|=
block|{
block|{
operator|&
name|ifm_subtype_ethernet_descriptions
index|[
literal|0
index|]
block|,
operator|&
name|ifm_subtype_ethernet_option_descriptions
index|[
literal|0
index|]
block|}
block|,
block|{
operator|&
name|ifm_subtype_tokenring_descriptions
index|[
literal|0
index|]
block|,
operator|&
name|ifm_subtype_tokenring_option_descriptions
index|[
literal|0
index|]
block|}
block|,
block|{
operator|&
name|ifm_subtype_fddi_descriptions
index|[
literal|0
index|]
block|,
operator|&
name|ifm_subtype_fddi_option_descriptions
index|[
literal|0
index|]
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * print a media word.  */
end_comment

begin_function
specifier|static
name|void
name|ifmedia_printword
parameter_list|(
name|ifmw
parameter_list|)
name|int
name|ifmw
decl_stmt|;
block|{
name|struct
name|ifmedia_description
modifier|*
name|desc
decl_stmt|;
name|struct
name|ifmedia_type_to_subtype
modifier|*
name|ttos
decl_stmt|;
name|int
name|seen_option
init|=
literal|0
decl_stmt|;
comment|/* Find the top-level interface type. */
for|for
control|(
name|desc
operator|=
name|ifm_type_descriptions
operator|,
name|ttos
operator|=
name|ifmedia_types_to_subtypes
init|;
name|desc
operator|->
name|ifmt_string
operator|!=
name|NULL
condition|;
name|desc
operator|++
operator|,
name|ttos
operator|++
control|)
if|if
condition|(
name|IFM_TYPE
argument_list|(
name|ifmw
argument_list|)
operator|==
name|desc
operator|->
name|ifmt_word
condition|)
break|break;
if|if
condition|(
name|desc
operator|->
name|ifmt_string
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"<unknown type>\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
name|desc
operator|->
name|ifmt_string
argument_list|)
expr_stmt|;
comment|/* 	 * Check for the shared subtype descriptions first, then the 	 * type-specific ones. 	 */
for|for
control|(
name|desc
operator|=
name|ifm_subtype_shared_descriptions
init|;
name|desc
operator|->
name|ifmt_string
operator|!=
name|NULL
condition|;
name|desc
operator|++
control|)
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|ifmw
argument_list|)
operator|==
name|desc
operator|->
name|ifmt_word
condition|)
goto|goto
name|got_subtype
goto|;
for|for
control|(
name|desc
operator|=
name|ttos
operator|->
name|subtypes
init|;
name|desc
operator|->
name|ifmt_string
operator|!=
name|NULL
condition|;
name|desc
operator|++
control|)
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|ifmw
argument_list|)
operator|==
name|desc
operator|->
name|ifmt_word
condition|)
break|break;
if|if
condition|(
name|desc
operator|->
name|ifmt_string
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"<unknown subtype>\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|got_subtype
label|:
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|desc
operator|->
name|ifmt_string
argument_list|)
expr_stmt|;
comment|/* 	 * Look for shared options. 	 */
for|for
control|(
name|desc
operator|=
name|ifm_shared_option_descriptions
init|;
name|desc
operator|->
name|ifmt_string
operator|!=
name|NULL
condition|;
name|desc
operator|++
control|)
block|{
if|if
condition|(
name|ifmw
operator|&
name|desc
operator|->
name|ifmt_word
condition|)
block|{
if|if
condition|(
name|seen_option
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"<"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|seen_option
operator|++
condition|?
literal|","
else|:
literal|""
argument_list|,
name|desc
operator|->
name|ifmt_string
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Look for subtype-specific options. 	 */
for|for
control|(
name|desc
operator|=
name|ttos
operator|->
name|options
init|;
name|desc
operator|->
name|ifmt_string
operator|!=
name|NULL
condition|;
name|desc
operator|++
control|)
block|{
if|if
condition|(
name|ifmw
operator|&
name|desc
operator|->
name|ifmt_word
condition|)
block|{
if|if
condition|(
name|seen_option
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"<"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%s"
argument_list|,
name|seen_option
operator|++
condition|?
literal|","
else|:
literal|""
argument_list|,
name|desc
operator|->
name|ifmt_string
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|seen_option
condition|?
literal|">"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IFMEDIA_DEBUG */
end_comment

end_unit

