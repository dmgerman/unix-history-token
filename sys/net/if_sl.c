begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1987, 1989, 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)if_sl.c	8.6 (Berkeley) 2/1/94  * $Id: if_sl.c,v 1.64 1997/12/19 19:39:01 ache Exp $  */
end_comment

begin_comment
comment|/*  * Serial Line interface  *  * Rick Adams  * Center for Seismic Studies  * 1300 N 17th Street, Suite 1450  * Arlington, Virginia 22209  * (703)276-7900  * rick@seismo.ARPA  * seismo!rick  *  * Pounded on heavily by Chris Torek (chris@mimsy.umd.edu, umcp-cs!chris).  * N.B.: this belongs in netinet, not net, the way it stands now.  * Should have a link-layer type designation, but wouldn't be  * backwards-compatible.  *  * Converted to 4.3BSD Beta by Chris Torek.  * Other changes made at Berkeley, based in part on code by Kirk Smith.  * W. Jolitz added slip abort.  *  * Hacked almost beyond recognition by Van Jacobson (van@helios.ee.lbl.gov).  * Added priority queuing for "interactive" traffic; hooks for TCP  * header compression; ICMP filtering (at 2400 baud, some cretin  * pinging you can use up all your bandwidth).  Made low clist behavior  * more robust and slightly less likely to hang serial line.  * Sped up a bunch of things.  *  * Note that splimp() is used throughout to block both (tty) input  * interrupts and network activity; thus, splimp must be>= spltty.  */
end_comment

begin_include
include|#
directive|include
file|"sl.h"
end_include

begin_if
if|#
directive|if
name|NSL
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/clist.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_if
if|#
directive|if
name|INET
end_if

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
literal|"Huh? Slip without inet?"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/slcompress.h>
end_include

begin_include
include|#
directive|include
file|<net/if_slvar.h>
end_include

begin_include
include|#
directive|include
file|<net/slip.h>
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|slattach
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|PSEUDO_SET
argument_list|(
name|slattach
argument_list|,
name|if_sl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * SLRMAX is a hard limit on input packet size.  To simplify the code  * and improve performance, we require that packets fit in an mbuf  * cluster, and if we get a compressed packet, there's enough extra  * room to expand the header into a max length tcp/ip header (128  * bytes).  So, SLRMAX can be at most  *	MCLBYTES - 128  *  * SLMTU is the default transmit MTU. The transmit MTU should be kept  * small enough so that interactive use doesn't suffer, but large  * enough to provide good performance. 552 is a good choice for SLMTU  * because it is high enough to not fragment TCP packets being routed  * through this host. Packet fragmentation is bad with SLIP because  * fragment headers aren't compressed. The previous assumptions about  * the best MTU value don't really hold when using modern modems with  * BTLZ data compression because the modem buffers play a much larger  * role in interactive performance than the MTU. The MTU can be changed  * at any time to suit the specific environment with ifconfig(8), and  * its maximum value is defined as SLTMAX. SLTMAX must not be so large  * that it would overflow the stack if BPF is configured (XXX; if_ppp.c  * handles this better).  *  * SLIP_HIWAT is the amount of data that will be queued 'downstream'  * of us (i.e., in clists waiting to be picked up by the tty output  * interrupt).  If we queue a lot of data downstream, it's immune to  * our t.o.s. queuing.  * E.g., if SLIP_HIWAT is 1024, the interactive traffic in mixed  * telnet/ftp will see a 1 sec wait, independent of the mtu (the  * wait is dependent on the ftp window size but that's typically  * 1k - 4k).  So, we want SLIP_HIWAT just big enough to amortize  * the cost (in idle time on the wire) of the tty driver running  * off the end of its clists& having to call back slstart for a  * new packet.  For a tty interface with any buffering at all, this  * cost will be zero.  Even with a totally brain dead interface (like  * the one on a typical workstation), the cost will be<= 1 character  * time.  So, setting SLIP_HIWAT to ~100 guarantees that we'll lose  * at most 1% while maintaining good interactive response.  */
end_comment

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_define
define|#
directive|define
name|BUFOFFSET
value|(128+sizeof(struct ifnet **)+SLIP_HDRLEN)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BUFOFFSET
value|(128+sizeof(struct ifnet **))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SLRMAX
value|(MCLBYTES - BUFOFFSET)
end_define

begin_define
define|#
directive|define
name|SLBUFSIZE
value|(SLRMAX + BUFOFFSET)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|SLMTU
end_ifndef

begin_define
define|#
directive|define
name|SLMTU
value|552
end_define

begin_comment
comment|/* default MTU */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SLTMAX
value|1500
end_define

begin_comment
comment|/* maximum MTU */
end_comment

begin_define
define|#
directive|define
name|SLIP_HIWAT
value|roundup(50,CBSIZE)
end_define

begin_define
define|#
directive|define
name|CLISTRESERVE
value|1024
end_define

begin_comment
comment|/* Can't let clists get too low */
end_comment

begin_comment
comment|/*  * SLIP ABORT ESCAPE MECHANISM:  *	(inspired by HAYES modem escape arrangement)  *	1sec escape 1sec escape 1sec escape { 1sec escape 1sec escape }  *	within window time signals a "soft" exit from slip mode by remote end  *	if the IFF_DEBUG flag is on.  */
end_comment

begin_define
define|#
directive|define
name|ABT_ESC
value|'\033'
end_define

begin_comment
comment|/* can't be t_intr - distant host must know it*/
end_comment

begin_define
define|#
directive|define
name|ABT_IDLE
value|1
end_define

begin_comment
comment|/* in seconds - idle before an escape */
end_comment

begin_define
define|#
directive|define
name|ABT_COUNT
value|3
end_define

begin_comment
comment|/* count of escapes for abort */
end_comment

begin_define
define|#
directive|define
name|ABT_WINDOW
value|(ABT_COUNT*2+2)
end_define

begin_comment
comment|/* in seconds - time to count */
end_comment

begin_decl_stmt
name|struct
name|sl_softc
name|sl_softc
index|[
name|NSL
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FRAME_END
value|0xc0
end_define

begin_comment
comment|/* Frame End */
end_comment

begin_define
define|#
directive|define
name|FRAME_ESCAPE
value|0xdb
end_define

begin_comment
comment|/* Frame Esc */
end_comment

begin_define
define|#
directive|define
name|TRANS_FRAME_END
value|0xdc
end_define

begin_comment
comment|/* transposed frame end */
end_comment

begin_define
define|#
directive|define
name|TRANS_FRAME_ESCAPE
value|0xdd
end_define

begin_comment
comment|/* transposed frame esc */
end_comment

begin_decl_stmt
specifier|static
name|int
name|slinit
name|__P
argument_list|(
operator|(
expr|struct
name|sl_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|sl_btom
name|__P
argument_list|(
operator|(
expr|struct
name|sl_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timeout_t
name|sl_keepalive
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timeout_t
name|sl_outfill
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|slclose
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|slinput
name|__P
argument_list|(
operator|(
name|int
operator|,
expr|struct
name|tty
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|slioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
name|int
operator|,
name|caddr_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sltioctl
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
operator|,
name|int
operator|,
name|caddr_t
operator|,
name|int
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|slopen
name|__P
argument_list|(
operator|(
name|dev_t
operator|,
expr|struct
name|tty
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sloutput
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|sockaddr
operator|*
operator|,
expr|struct
name|rtentry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|slstart
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|linesw
name|slipdisc
init|=
block|{
name|slopen
block|,
name|slclose
block|,
name|l_noread
block|,
name|l_nowrite
block|,
name|sltioctl
block|,
name|slinput
block|,
name|slstart
block|,
name|ttymodem
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Called from boot code to establish sl interfaces.  */
end_comment

begin_function
specifier|static
name|void
name|slattach
parameter_list|(
name|dummy
parameter_list|)
name|void
modifier|*
name|dummy
decl_stmt|;
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
name|linesw
index|[
name|SLIPDISC
index|]
operator|=
name|slipdisc
expr_stmt|;
for|for
control|(
name|sc
operator|=
name|sl_softc
init|;
name|i
operator|<
name|NSL
condition|;
name|sc
operator|++
control|)
block|{
name|sc
operator|->
name|sc_if
operator|.
name|if_name
operator|=
literal|"sl"
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
operator|=
name|i
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
operator|=
name|SLMTU
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|=
name|IFF_POINTOPOINT
operator||
name|SC_AUTOCOMP
operator||
name|IFF_MULTICAST
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_type
operator|=
name|IFT_SLIP
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ioctl
operator|=
name|slioctl
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_output
operator|=
name|sloutput
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
operator|.
name|ifq_maxlen
operator|=
literal|50
expr_stmt|;
name|sc
operator|->
name|sc_fastq
operator|.
name|ifq_maxlen
operator|=
literal|32
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_linkmib
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_linkmiblen
operator|=
sizeof|sizeof
expr|*
name|sc
expr_stmt|;
name|if_attach
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|,
name|DLT_SLIP
argument_list|,
name|SLIP_HDRLEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|slinit
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
name|caddr_t
name|p
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ep
operator|==
operator|(
name|u_char
operator|*
operator|)
literal|0
condition|)
block|{
name|MCLALLOC
argument_list|(
name|p
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|sc
operator|->
name|sc_ep
operator|=
operator|(
name|u_char
operator|*
operator|)
name|p
operator|+
name|SLBUFSIZE
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"sl%d: can't allocate buffer\n"
argument_list|,
name|sc
operator|-
name|sl_softc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|sc
operator|->
name|sc_buf
operator|=
name|sc
operator|->
name|sc_ep
operator|-
name|SLRMAX
expr_stmt|;
name|sc
operator|->
name|sc_mp
operator|=
name|sc
operator|->
name|sc_buf
expr_stmt|;
name|sl_compress_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_comp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Line specific open routine.  * Attach the given tty to the first available sl unit.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|slopen
parameter_list|(
name|dev
parameter_list|,
name|tp
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|nsl
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|tp
operator|->
name|t_line
operator|==
name|SLIPDISC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|nsl
operator|=
name|NSL
operator|,
name|sc
operator|=
name|sl_softc
init|;
operator|--
name|nsl
operator|>=
literal|0
condition|;
name|sc
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_ttyp
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_STATIC
operator|)
condition|)
block|{
if|if
condition|(
name|slinit
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|tp
operator|->
name|t_sc
operator|=
operator|(
name|caddr_t
operator|)
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_ttyp
operator|=
name|tp
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_baudrate
operator|=
name|tp
operator|->
name|t_ospeed
expr_stmt|;
name|ttyflush
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_line
operator|=
name|SLIPDISC
expr_stmt|;
comment|/* 			 * We don't use t_canq or t_rawq, so reduce their 			 * cblock resources to 0.  Reserve enough cblocks 			 * for t_outq to guarantee that we can fit a full 			 * packet if the SLIP_HIWAT check allows slstart() 			 * to loop.  Use the same value for the cblock 			 * limit since the reserved blocks should always 			 * be enough.  Reserving cblocks probably makes 			 * the CLISTRESERVE check unnecessary and wasteful. 			 */
name|clist_alloc_cblocks
argument_list|(
operator|&
name|tp
operator|->
name|t_canq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clist_alloc_cblocks
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|SLIP_HIWAT
operator|+
literal|2
operator|*
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
operator|+
literal|1
argument_list|,
name|SLIP_HIWAT
operator|+
literal|2
operator|*
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
operator|+
literal|1
argument_list|)
expr_stmt|;
name|clist_alloc_cblocks
argument_list|(
operator|&
name|tp
operator|->
name|t_rawq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|if_up
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Line specific close routine.  * Detach the tty from the sl unit.  */
end_comment

begin_function
specifier|static
name|int
name|slclose
parameter_list|(
name|tp
parameter_list|,
name|flag
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ttyflush
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * XXX the placement of the following spl is misleading.  tty 	 * interrupts must be blocked across line discipline switches 	 * and throughout closes to avoid races. 	 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* actually, max(spltty, splnet) */
name|clist_free_cblocks
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_line
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|sl_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_outfill
condition|)
block|{
name|sc
operator|->
name|sc_outfill
operator|=
literal|0
expr_stmt|;
name|untimeout
argument_list|(
name|sl_outfill
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sc_ofhandle
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_keepalive
condition|)
block|{
name|sc
operator|->
name|sc_keepalive
operator|=
literal|0
expr_stmt|;
name|untimeout
argument_list|(
name|sl_keepalive
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sc_kahandle
argument_list|)
expr_stmt|;
block|}
name|if_down
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
name|SC_STATIC
expr_stmt|;
name|sc
operator|->
name|sc_ttyp
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|t_sc
operator|=
name|NULL
expr_stmt|;
name|MCLFREE
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|sc
operator|->
name|sc_ep
operator|-
name|SLBUFSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ep
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_mp
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_buf
operator|=
literal|0
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Line specific (tty) ioctl routine.  * Provide a way to get the sl unit number.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|sltioctl
parameter_list|(
name|tp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|,
name|p
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
name|struct
name|sl_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sl_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
decl_stmt|,
modifier|*
name|nc
decl_stmt|,
modifier|*
name|tmpnc
decl_stmt|;
name|int
name|s
decl_stmt|,
name|nsl
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SLIOCGUNIT
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
expr_stmt|;
break|break;
case|case
name|SLIOCSUNIT
case|:
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
operator|!=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
condition|)
block|{
for|for
control|(
name|nsl
operator|=
name|NSL
operator|,
name|nc
operator|=
name|sl_softc
init|;
operator|--
name|nsl
operator|>=
literal|0
condition|;
name|nc
operator|++
control|)
block|{
if|if
condition|(
name|nc
operator|->
name|sc_if
operator|.
name|if_unit
operator|==
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|&&
name|nc
operator|->
name|sc_ttyp
operator|==
name|NULL
condition|)
block|{
name|tmpnc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|tmpnc
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpnc
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
operator|*
name|tmpnc
operator|=
operator|*
name|nc
expr_stmt|;
operator|*
name|nc
operator|=
operator|*
name|sc
expr_stmt|;
name|nc
operator|->
name|sc_if
operator|=
name|tmpnc
operator|->
name|sc_if
expr_stmt|;
name|tmpnc
operator|->
name|sc_if
operator|=
name|sc
operator|->
name|sc_if
expr_stmt|;
operator|*
name|sc
operator|=
operator|*
name|tmpnc
expr_stmt|;
name|free
argument_list|(
name|tmpnc
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_UP
condition|)
block|{
name|if_down
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
name|if_up
argument_list|(
operator|&
name|nc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_UP
condition|)
name|if_down
argument_list|(
operator|&
name|nc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_STATIC
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
operator|(
name|nc
operator|->
name|sc_flags
operator|&
name|SC_STATIC
operator|)
expr_stmt|;
name|tp
operator|->
name|t_sc
operator|=
name|sc
operator|=
name|nc
expr_stmt|;
goto|goto
name|slfound
goto|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|slfound
label|:
name|sc
operator|->
name|sc_flags
operator||=
name|SC_STATIC
expr_stmt|;
break|break;
case|case
name|SLIOCSKEEPAL
case|:
name|sc
operator|->
name|sc_keepalive
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|*
name|hz
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_keepalive
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|SC_KEEPALIVE
expr_stmt|;
name|sc
operator|->
name|sc_kahandle
operator|=
name|timeout
argument_list|(
name|sl_keepalive
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sc_keepalive
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_KEEPALIVE
operator|)
operator|!=
literal|0
condition|)
block|{
name|untimeout
argument_list|(
name|sl_keepalive
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sc_kahandle
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_KEEPALIVE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SLIOCGKEEPAL
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_keepalive
operator|/
name|hz
expr_stmt|;
break|break;
case|case
name|SLIOCSOUTFILL
case|:
name|sc
operator|->
name|sc_outfill
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|*
name|hz
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_outfill
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|SC_OUTWAIT
expr_stmt|;
name|sc
operator|->
name|sc_ofhandle
operator|=
name|timeout
argument_list|(
name|sl_outfill
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sc_outfill
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_OUTWAIT
operator|)
operator|!=
literal|0
condition|)
block|{
name|untimeout
argument_list|(
name|sl_outfill
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sc_ofhandle
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_OUTWAIT
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SLIOCGOUTFILL
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_outfill
operator|/
name|hz
expr_stmt|;
break|break;
default|default:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOIOCTL
operator|)
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Queue a packet.  Start transmission if not active.  * Compression happens in slstart; if we do it here, IP TOS  * will cause us to not compress "background" packets, because  * ordering gets trashed.  It can be done for all packets in slstart.  */
end_comment

begin_function
specifier|static
name|int
name|sloutput
parameter_list|(
name|ifp
parameter_list|,
name|m
parameter_list|,
name|dst
parameter_list|,
name|rtp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rtp
decl_stmt|;
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
init|=
operator|&
name|sl_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
specifier|register
name|struct
name|ifqueue
modifier|*
name|ifq
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * `Cannot happen' (see slioctl).  Someday we will extend 	 * the line protocol to support other address families. 	 */
if|if
condition|(
name|dst
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
name|printf
argument_list|(
literal|"sl%d: af%d not supported\n"
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_noproto
operator|++
expr_stmt|;
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_ttyp
operator|==
name|NULL
operator|||
operator|!
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_ttyp
operator|->
name|t_state
operator|&
name|TS_CONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EHOSTUNREACH
operator|)
return|;
block|}
name|ifq
operator|=
operator|&
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
expr_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|SC_NOICMP
operator|&&
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_ICMP
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETRESET
operator|)
return|;
comment|/* XXX ? */
block|}
if|if
condition|(
name|ip
operator|->
name|ip_tos
operator|&
name|IPTOS_LOWDELAY
condition|)
name|ifq
operator|=
operator|&
name|sc
operator|->
name|sc_fastq
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
name|ifq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|IF_ENQUEUE
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ttyp
operator|->
name|t_outq
operator|.
name|c_cc
operator|==
literal|0
condition|)
name|slstart
argument_list|(
name|sc
operator|->
name|sc_ttyp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start output on interface.  Get another datagram  * to send from the interface queue and map it to  * the interface before starting output.  */
end_comment

begin_function
specifier|static
name|int
name|slstart
parameter_list|(
name|tp
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sl_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m2
decl_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|u_char
name|bpfbuf
index|[
name|SLTMAX
operator|+
name|SLIP_HDRLEN
index|]
decl_stmt|;
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Call output process whether or not there is more in the 		 * output queue.  We are being called in lieu of ttstart 		 * and must do what it would. 		 */
call|(
modifier|*
name|tp
operator|->
name|t_oproc
call|)
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_OUTWAIT
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|>
name|SLIP_HIWAT
condition|)
return|return
literal|0
return|;
block|}
comment|/* 		 * This happens briefly when the line shuts down. 		 */
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* 		 * Get a packet and send it to the interface. 		 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_fastq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|sc
operator|->
name|sc_if
operator|.
name|if_omcasts
operator|++
expr_stmt|;
comment|/* XXX */
else|else
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* 		 * We do the header compression here rather than in sloutput 		 * because the packets will be out of order if we are using TOS 		 * queueing, and the connection id compression will get 		 * munged when this happens. 		 */
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_bpf
condition|)
block|{
comment|/* 			 * We need to save the TCP/IP header before it's 			 * compressed.  To avoid complicated code, we just 			 * copy the entire packet into a stack buffer (since 			 * this is a serial line, packets should be short 			 * and/or the copy should be negligible cost compared 			 * to the packet transmission time). 			 */
specifier|register
name|struct
name|mbuf
modifier|*
name|m1
init|=
name|m
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
init|=
name|bpfbuf
operator|+
name|SLIP_HDRLEN
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
do|do
block|{
specifier|register
name|int
name|mlen
init|=
name|m1
operator|->
name|m_len
decl_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m1
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|cp
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|mlen
expr_stmt|;
name|len
operator|+=
name|mlen
expr_stmt|;
block|}
do|while
condition|(
name|m1
operator|=
name|m1
operator|->
name|m_next
condition|)
do|;
block|}
endif|#
directive|endif
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_v
operator|==
name|IPVERSION
operator|&&
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|SC_COMPRESS
condition|)
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator||=
name|sl_compress_tcp
argument_list|(
name|m
argument_list|,
name|ip
argument_list|,
operator|&
name|sc
operator|->
name|sc_comp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_bpf
condition|)
block|{
comment|/* 			 * Put the SLIP pseudo-"link header" in place.  The 			 * compressed header is now at the beginning of the 			 * mbuf. 			 */
name|bpfbuf
index|[
name|SLX_DIR
index|]
operator|=
name|SLIPDIR_OUT
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|&
name|bpfbuf
index|[
name|SLX_CHDR
index|]
argument_list|,
name|CHDR_LEN
argument_list|)
expr_stmt|;
name|bpf_tap
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|,
name|bpfbuf
argument_list|,
name|len
operator|+
name|SLIP_HDRLEN
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * If system is getting low on clists, just flush our 		 * output queue (if the stuff was important, it'll get 		 * retransmitted). Note that SLTMAX is used instead of 		 * the current if_mtu setting because connections that 		 * have already been established still use the original 		 * (possibly larger) mss. 		 */
if|if
condition|(
name|cfreecount
operator|<
name|CLISTRESERVE
operator|+
name|SLTMAX
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
continue|continue;
block|}
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_OUTWAIT
expr_stmt|;
comment|/* 		 * The extra FRAME_END will start up a new packet, and thus 		 * will flush any accumulated garbage.  We do this whenever 		 * the line may have been idle for some time. 		 */
if|if
condition|(
name|tp
operator|->
name|t_outq
operator|.
name|c_cc
operator|==
literal|0
condition|)
block|{
operator|++
name|sc
operator|->
name|sc_if
operator|.
name|if_obytes
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
name|FRAME_END
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|m
condition|)
block|{
specifier|register
name|u_char
modifier|*
name|ep
decl_stmt|;
name|cp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|ep
operator|=
name|cp
operator|+
name|m
operator|->
name|m_len
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|ep
condition|)
block|{
comment|/* 				 * Find out how many bytes in the string we can 				 * handle without doing something special. 				 */
specifier|register
name|u_char
modifier|*
name|bp
init|=
name|cp
decl_stmt|;
while|while
condition|(
name|cp
operator|<
name|ep
condition|)
block|{
switch|switch
condition|(
operator|*
name|cp
operator|++
condition|)
block|{
case|case
name|FRAME_ESCAPE
case|:
case|case
name|FRAME_END
case|:
operator|--
name|cp
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
if|if
condition|(
name|cp
operator|>
name|bp
condition|)
block|{
comment|/* 					 * Put n characters at once 					 * into the tty output queue. 					 */
if|if
condition|(
name|b_to_q
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|,
name|cp
operator|-
name|bp
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
break|break;
name|sc
operator|->
name|sc_if
operator|.
name|if_obytes
operator|+=
name|cp
operator|-
name|bp
expr_stmt|;
block|}
comment|/* 				 * If there are characters left in the mbuf, 				 * the first one must be special.. 				 * Put it out in a different form. 				 */
if|if
condition|(
name|cp
operator|<
name|ep
condition|)
block|{
if|if
condition|(
name|putc
argument_list|(
name|FRAME_ESCAPE
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
break|break;
if|if
condition|(
name|putc
argument_list|(
operator|*
name|cp
operator|++
operator|==
name|FRAME_ESCAPE
condition|?
name|TRANS_FRAME_ESCAPE
else|:
name|TRANS_FRAME_END
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|unputc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|sc_if
operator|.
name|if_obytes
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|MFREE
argument_list|(
name|m
argument_list|,
name|m2
argument_list|)
expr_stmt|;
name|m
operator|=
name|m2
expr_stmt|;
block|}
if|if
condition|(
name|putc
argument_list|(
name|FRAME_END
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
block|{
comment|/* 			 * Not enough room.  Remove a char to make room 			 * and end the packet normally. 			 * If you get many collisions (more than one or two 			 * a day) you probably do not have enough clists 			 * and you should increase "nclist" in param.c. 			 */
operator|(
name|void
operator|)
name|unputc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
name|FRAME_END
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|++
name|sc
operator|->
name|sc_if
operator|.
name|if_obytes
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Copy data buffer to mbuf chain; add ifnet pointer.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sl_btom
parameter_list|(
name|sc
parameter_list|,
name|len
parameter_list|)
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * If we have more than MHLEN bytes, it's cheaper to 	 * queue the cluster we just filled& allocate a new one 	 * for the input buffer.  Otherwise, fill the mbuf we 	 * allocated above.  Note that code in the input routine 	 * guarantees that packet will fit in a cluster. 	 */
if|if
condition|(
name|len
operator|>=
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * we couldn't get a cluster - if memory's this 			 * low, it's time to start dropping packets. 			 */
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sc
operator|->
name|sc_ep
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
name|SLBUFSIZE
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_buf
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|int
operator|)
name|sc
operator|->
name|sc_buf
operator|&
operator|~
name|MCLOFSET
argument_list|)
expr_stmt|;
block|}
else|else
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_buf
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|sc
operator|->
name|sc_if
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * tty interface receiver interrupt.  */
end_comment

begin_function
specifier|static
name|int
name|slinput
parameter_list|(
name|c
parameter_list|,
name|tp
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|int
name|s
decl_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|u_char
name|chdr
index|[
name|CHDR_LEN
index|]
decl_stmt|;
endif|#
directive|endif
name|tk_nin
operator|++
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|sl_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|c
operator|&
name|TTY_ERRORMASK
operator|||
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|SC_ERROR
expr_stmt|;
return|return
literal|0
return|;
block|}
name|c
operator|&=
name|TTY_CHARMASK
expr_stmt|;
operator|++
name|sc
operator|->
name|sc_if
operator|.
name|if_ibytes
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|ABT_ESC
condition|)
block|{
comment|/* 			 * If we have a previous abort, see whether 			 * this one is within the time limit. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_abortcount
operator|&&
name|time
operator|.
name|tv_sec
operator|>=
name|sc
operator|->
name|sc_starttime
operator|+
name|ABT_WINDOW
condition|)
name|sc
operator|->
name|sc_abortcount
operator|=
literal|0
expr_stmt|;
comment|/* 			 * If we see an abort after "idle" time, count it; 			 * record when the first abort escape arrived. 			 */
if|if
condition|(
name|time
operator|.
name|tv_sec
operator|>=
name|sc
operator|->
name|sc_lasttime
operator|+
name|ABT_IDLE
condition|)
block|{
if|if
condition|(
operator|++
name|sc
operator|->
name|sc_abortcount
operator|==
literal|1
condition|)
name|sc
operator|->
name|sc_starttime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_abortcount
operator|>=
name|ABT_COUNT
condition|)
block|{
name|slclose
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
else|else
name|sc
operator|->
name|sc_abortcount
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_lasttime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|TRANS_FRAME_ESCAPE
case|:
if|if
condition|(
name|sc
operator|->
name|sc_escape
condition|)
name|c
operator|=
name|FRAME_ESCAPE
expr_stmt|;
break|break;
case|case
name|TRANS_FRAME_END
case|:
if|if
condition|(
name|sc
operator|->
name|sc_escape
condition|)
name|c
operator|=
name|FRAME_END
expr_stmt|;
break|break;
case|case
name|FRAME_ESCAPE
case|:
name|sc
operator|->
name|sc_escape
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
case|case
name|FRAME_END
case|:
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_KEEPALIVE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_ERROR
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_ERROR
expr_stmt|;
goto|goto
name|newpack
goto|;
block|}
name|len
operator|=
name|sc
operator|->
name|sc_mp
operator|-
name|sc
operator|->
name|sc_buf
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|3
condition|)
comment|/* less than min length packet - ignore */
goto|goto
name|newpack
goto|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_bpf
condition|)
block|{
comment|/* 			 * Save the compressed header, so we 			 * can tack it on later.  Note that we 			 * will end up copying garbage in some 			 * cases but this is okay.  We remember 			 * where the buffer started so we can 			 * compute the new header length. 			 */
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_buf
argument_list|,
name|chdr
argument_list|,
name|CHDR_LEN
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
name|sc
operator|->
name|sc_buf
operator|&
literal|0xf0
operator|)
operator|)
operator|!=
operator|(
name|IPVERSION
operator|<<
literal|4
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|&
literal|0x80
condition|)
name|c
operator|=
name|TYPE_COMPRESSED_TCP
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|TYPE_UNCOMPRESSED_TCP
condition|)
operator|*
name|sc
operator|->
name|sc_buf
operator|&=
literal|0x4f
expr_stmt|;
comment|/* XXX */
comment|/* 			 * We've got something that's not an IP packet. 			 * If compression is enabled, try to decompress it. 			 * Otherwise, if `auto-enable' compression is on and 			 * it's a reasonable packet, decompress it and then 			 * enable compression.  Otherwise, drop it. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|SC_COMPRESS
condition|)
block|{
name|len
operator|=
name|sl_uncompress_tcp
argument_list|(
operator|&
name|sc
operator|->
name|sc_buf
argument_list|,
name|len
argument_list|,
operator|(
name|u_int
operator|)
name|c
argument_list|,
operator|&
name|sc
operator|->
name|sc_comp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|SC_AUTOCOMP
operator|)
operator|&&
name|c
operator|==
name|TYPE_UNCOMPRESSED_TCP
operator|&&
name|len
operator|>=
literal|40
condition|)
block|{
name|len
operator|=
name|sl_uncompress_tcp
argument_list|(
operator|&
name|sc
operator|->
name|sc_buf
argument_list|,
name|len
argument_list|,
operator|(
name|u_int
operator|)
name|c
argument_list|,
operator|&
name|sc
operator|->
name|sc_comp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
goto|goto
name|error
goto|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator||=
name|SC_COMPRESS
expr_stmt|;
block|}
else|else
goto|goto
name|error
goto|;
block|}
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_bpf
condition|)
block|{
comment|/* 			 * Put the SLIP pseudo-"link header" in place. 			 * We couldn't do this any earlier since 			 * decompression probably moved the buffer 			 * pointer.  Then, invoke BPF. 			 */
specifier|register
name|u_char
modifier|*
name|hp
init|=
name|sc
operator|->
name|sc_buf
operator|-
name|SLIP_HDRLEN
decl_stmt|;
name|hp
index|[
name|SLX_DIR
index|]
operator|=
name|SLIPDIR_IN
expr_stmt|;
name|bcopy
argument_list|(
name|chdr
argument_list|,
operator|&
name|hp
index|[
name|SLX_CHDR
index|]
argument_list|,
name|CHDR_LEN
argument_list|)
expr_stmt|;
name|bpf_tap
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|,
name|hp
argument_list|,
name|len
operator|+
name|SLIP_HDRLEN
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m
operator|=
name|sl_btom
argument_list|(
name|sc
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
goto|goto
name|newpack
goto|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|ipintrq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
operator|&
name|ipintrq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_iqdrops
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IF_ENQUEUE
argument_list|(
operator|&
name|ipintrq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|schednetisr
argument_list|(
name|NETISR_IP
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|newpack
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_mp
operator|<
name|sc
operator|->
name|sc_ep
condition|)
block|{
operator|*
name|sc
operator|->
name|sc_mp
operator|++
operator|=
name|c
expr_stmt|;
name|sc
operator|->
name|sc_escape
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* can't put lower; would miss an extra frame */
name|sc
operator|->
name|sc_flags
operator||=
name|SC_ERROR
expr_stmt|;
name|error
label|:
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|newpack
label|:
name|sc
operator|->
name|sc_mp
operator|=
name|sc
operator|->
name|sc_buf
operator|=
name|sc
operator|->
name|sc_ep
operator|-
name|SLRMAX
expr_stmt|;
name|sc
operator|->
name|sc_escape
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_function
specifier|static
name|int
name|slioctl
parameter_list|(
name|ifp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
specifier|register
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
comment|/* 		 * if.c will set the interface up even if we 		 * don't want it to. 		 */
if|if
condition|(
name|sl_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
operator|.
name|sc_ttyp
operator|==
name|NULL
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFADDR
case|:
comment|/* 		 * This is "historical" - set the interface up when 		 * setting the address. 		 */
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
name|sl_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
operator|.
name|sc_ttyp
operator|!=
name|NULL
condition|)
name|if_up
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFDSTADDR
case|:
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
break|break;
case|case
name|SIOCSIFMTU
case|:
comment|/* 		 * Set the interface MTU. 		 */
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|SLTMAX
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|tp
operator|=
name|sl_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
operator|.
name|sc_ttyp
expr_stmt|;
if|if
condition|(
name|tp
operator|!=
name|NULL
condition|)
name|clist_alloc_cblocks
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|SLIP_HIWAT
operator|+
literal|2
operator|*
name|ifp
operator|->
name|if_mtu
operator|+
literal|1
argument_list|,
name|SLIP_HIWAT
operator|+
literal|2
operator|*
name|ifp
operator|->
name|if_mtu
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sl_keepalive
parameter_list|(
name|chan
parameter_list|)
name|void
modifier|*
name|chan
decl_stmt|;
block|{
name|struct
name|sl_softc
modifier|*
name|sc
init|=
name|chan
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_keepalive
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_KEEPALIVE
condition|)
name|pgsignal
argument_list|(
name|sc
operator|->
name|sc_ttyp
operator|->
name|t_pgrp
argument_list|,
name|SIGURG
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|sc_flags
operator||=
name|SC_KEEPALIVE
expr_stmt|;
name|sc
operator|->
name|sc_kahandle
operator|=
name|timeout
argument_list|(
name|sl_keepalive
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sc_keepalive
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_KEEPALIVE
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sl_outfill
parameter_list|(
name|chan
parameter_list|)
name|void
modifier|*
name|chan
decl_stmt|;
block|{
name|struct
name|sl_softc
modifier|*
name|sc
init|=
name|chan
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
init|=
name|sc
operator|->
name|sc_ttyp
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_outfill
operator|&&
name|tp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_OUTWAIT
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
operator|++
name|sc
operator|->
name|sc_if
operator|.
name|if_obytes
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
name|FRAME_END
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
call|(
modifier|*
name|tp
operator|->
name|t_oproc
call|)
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_flags
operator||=
name|SC_OUTWAIT
expr_stmt|;
name|sc
operator|->
name|sc_ofhandle
operator|=
name|timeout
argument_list|(
name|sl_outfill
argument_list|,
name|sc
argument_list|,
name|sc
operator|->
name|sc_outfill
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_OUTWAIT
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

