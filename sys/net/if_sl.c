begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1987, 1989 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: @(#)if_sl.c	7.22 (Berkeley) 4/20/91  *	$Id: if_sl.c,v 1.7 1993/12/20 19:31:32 wollman Exp $  */
end_comment

begin_comment
comment|/*  * Serial Line interface  *  * Rick Adams  * Center for Seismic Studies  * 1300 N 17th Street, Suite 1450  * Arlington, Virginia 22209  * (703)276-7900  * rick@seismo.ARPA  * seismo!rick  *  * Pounded on heavily by Chris Torek (chris@mimsy.umd.edu, umcp-cs!chris).  * N.B.: this belongs in netinet, not net, the way it stands now.  * Should have a link-layer type designation, but wouldn't be  * backwards-compatible.  *  * Converted to 4.3BSD Beta by Chris Torek.  * Other changes made at Berkeley, based in part on code by Kirk Smith.  * W. Jolitz added slip abort.  *  * Hacked almost beyond recognition by Van Jacobson (van@helios.ee.lbl.gov).  * Added priority queuing for "interactive" traffic; hooks for TCP  * header compression; ICMP filtering (at 2400 baud, some cretin  * pinging you can use up all your bandwidth).  Made low clist behavior  * more robust and slightly less likely to hang serial line.  * Sped up a bunch of things.  *   * Note that splimp() is used throughout to block both (tty) input  * interrupts and network activity; thus, splimp must be>= spltty.  */
end_comment

begin_comment
comment|/* $Id: if_sl.c,v 1.7 1993/12/20 19:31:32 wollman Exp $ */
end_comment

begin_comment
comment|/* from if_sl.c,v 1.11 84/10/04 12:54:47 rick Exp */
end_comment

begin_include
include|#
directive|include
file|"sl.h"
end_include

begin_if
if|#
directive|if
name|NSL
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_comment
comment|/* sigh */
end_comment

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"dkstat.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"tty.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"if.h"
end_include

begin_include
include|#
directive|include
file|"if_types.h"
end_include

begin_include
include|#
directive|include
file|"netisr.h"
end_include

begin_include
include|#
directive|include
file|"route.h"
end_include

begin_if
if|#
directive|if
name|INET
end_if

begin_include
include|#
directive|include
file|"netinet/in.h"
end_include

begin_include
include|#
directive|include
file|"netinet/in_systm.h"
end_include

begin_include
include|#
directive|include
file|"netinet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"netinet/ip.h"
end_include

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
literal|"Huh? Slip without inet?"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"machine/mtpr.h"
end_include

begin_include
include|#
directive|include
file|"slcompress.h"
end_include

begin_include
include|#
directive|include
file|"if_slvar.h"
end_include

begin_include
include|#
directive|include
file|"slip.h"
end_include

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"sys/time.h"
end_include

begin_include
include|#
directive|include
file|"net/bpf.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * SLMAX is a hard limit on input packet size.  To simplify the code  * and improve performance, we require that packets fit in an mbuf  * cluster, and if we get a compressed packet, there's enough extra  * room to expand the header into a max length tcp/ip header (128  * bytes).  So, SLMAX can be at most  *	MCLBYTES - 128  *  * SLMTU is a hard limit on output packet size.  To insure good  * interactive response, SLMTU wants to be the smallest size that  * amortizes the header cost.  (Remember that even with  * type-of-service queuing, we have to wait for any in-progress  * packet to finish.  I.e., we wait, on the average, 1/2 * mtu /  * cps, where cps is the line speed in characters per second.  * E.g., 533ms wait for a 1024 byte MTU on a 9600 baud line.  The  * average compressed header size is 6-8 bytes so any MTU> 90  * bytes will give us 90% of the line bandwidth.  A 100ms wait is  * tolerable (500ms is not), so want an MTU around 296.  (Since TCP  * will send 256 byte segments (to allow for 40 byte headers), the  * typical packet size on the wire will be around 260 bytes).  In  * 4.3tahoe+ systems, we can set an MTU in a route so we do that&  * leave the interface MTU relatively high (so we don't IP fragment  * when acting as a gateway to someone using a stupid MTU).  *  * Similar considerations apply to SLIP_HIWAT:  It's the amount of  * data that will be queued 'downstream' of us (i.e., in clists  * waiting to be picked up by the tty output interrupt).  If we  * queue a lot of data downstream, it's immune to our t.o.s. queuing.  * E.g., if SLIP_HIWAT is 1024, the interactive traffic in mixed  * telnet/ftp will see a 1 sec wait, independent of the mtu (the  * wait is dependent on the ftp window size but that's typically  * 1k - 4k).  So, we want SLIP_HIWAT just big enough to amortize  * the cost (in idle time on the wire) of the tty driver running  * off the end of its clists& having to call back slstart for a  * new packet.  For a tty interface with any buffering at all, this  * cost will be zero.  Even with a totally brain dead interface (like  * the one on a typical workstation), the cost will be<= 1 character  * time.  So, setting SLIP_HIWAT to ~100 guarantees that we'll lose  * at most 1% while maintaining good interactive response.  */
end_comment

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_define
define|#
directive|define
name|BUFOFFSET
value|(128+sizeof(struct ifnet **)+SLIP_HDRLEN)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BUFOFFSET
value|(128+sizeof(struct ifnet **))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SLMAX
value|(MCLBYTES - BUFOFFSET)
end_define

begin_define
define|#
directive|define
name|SLBUFSIZE
value|(SLMAX + BUFOFFSET)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|experimental
end_ifdef

begin_comment
comment|/*  * In this code, the SLMTU is the actual interface MTU as advertised  * in our ifnet structures.  SLRMTU is the MTU we stick into routes  * via slrtrequest() to tell TCP to produce small packets.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SLMTU
end_ifndef

begin_define
define|#
directive|define
name|SLMTU
value|1500
end_define

begin_comment
comment|/* same as Ethernet */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SLRMTU
end_ifndef

begin_define
define|#
directive|define
name|SLRMTU
value|296
end_define

begin_comment
comment|/* for good latency */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SLMTU
value|296
end_define

begin_define
define|#
directive|define
name|SLRMTU
value|SLMTU
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SLIP_HIWAT
value|roundup(50,CBSIZE)
end_define

begin_comment
comment|/*  * SLIP ABORT ESCAPE MECHANISM:  *	(inspired by HAYES modem escape arrangement)  *	1sec escape 1sec escape 1sec escape { 1sec escape 1sec escape }  *	signals a "soft" exit from slip mode by usermode process  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ABT_ESC
end_ifdef

begin_undef
undef|#
directive|undef
name|ABT_ESC
end_undef

begin_define
define|#
directive|define
name|ABT_ESC
value|'\033'
end_define

begin_comment
comment|/* can't be t_intr - distant host must know it*/
end_comment

begin_define
define|#
directive|define
name|ABT_WAIT
value|1
end_define

begin_comment
comment|/* in seconds - idle before an escape& after */
end_comment

begin_define
define|#
directive|define
name|ABT_RECYCLE
value|(5*2+2)
end_define

begin_comment
comment|/* in seconds - time window processing abort */
end_comment

begin_define
define|#
directive|define
name|ABT_SOFT
value|3
end_define

begin_comment
comment|/* count of escapes */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ABT_ESC */
end_comment

begin_comment
comment|/*  * The following disgusting hack gets around the problem that IP TOS  * can't be set yet.  We want to put "interactive" traffic on a high  * priority queue.  To decide if traffic is interactive, we check that  * a) it is TCP and b) one of its ports is telnet, rlogin or ftp control.  */
end_comment

begin_decl_stmt
specifier|static
name|u_short
name|interactive_ports
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|513
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|21
block|,
literal|0
block|,
literal|23
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INTERACTIVE
parameter_list|(
name|p
parameter_list|)
value|(interactive_ports[(p)& 7] == (p))
end_define

begin_decl_stmt
name|struct
name|sl_softc
name|sl_softc
index|[
name|NSL
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FRAME_END
value|0xc0
end_define

begin_comment
comment|/* Frame End */
end_comment

begin_define
define|#
directive|define
name|FRAME_ESCAPE
value|0xdb
end_define

begin_comment
comment|/* Frame Esc */
end_comment

begin_define
define|#
directive|define
name|TRANS_FRAME_END
value|0xdc
end_define

begin_comment
comment|/* transposed frame end */
end_comment

begin_define
define|#
directive|define
name|TRANS_FRAME_ESCAPE
value|0xdd
end_define

begin_comment
comment|/* transposed frame esc */
end_comment

begin_define
define|#
directive|define
name|t_sc
value|T_LINEP
end_define

begin_comment
comment|/*  * Prototypes.  */
end_comment

begin_function_decl
name|void
name|slattach
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|slinit
parameter_list|(
name|struct
name|sl_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|slopen
parameter_list|(
name|int
comment|/*dev_t*/
parameter_list|,
name|struct
name|tty
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|slclose
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sltioctl
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|,
name|int
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sloutput
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|struct
name|rtentry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|slstart
parameter_list|(
name|struct
name|tty
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|sl_btom
parameter_list|(
name|struct
name|sl_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|slinput
parameter_list|(
name|int
parameter_list|,
name|struct
name|tty
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|slrtrequest
parameter_list|(
name|int
parameter_list|,
name|struct
name|rtentry
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|slioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|int
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Called from boot code to establish sl interfaces.  */
end_comment

begin_function
name|void
name|slattach
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sc
operator|=
name|sl_softc
init|;
name|i
operator|<
name|NSL
condition|;
name|sc
operator|++
control|)
block|{
name|sc
operator|->
name|sc_if
operator|.
name|if_name
operator|=
literal|"sl"
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
operator|=
name|i
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
operator|=
name|SLMTU
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|=
name|IFF_POINTOPOINT
expr_stmt|;
comment|/* 		 * Multicast support is trivial for point-to-point 		 * netifs. 		 */
ifdef|#
directive|ifdef
name|MULTICAST
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator||=
name|IFF_MULTICAST
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_if
operator|.
name|if_type
operator|=
name|IFT_SLIP
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ioctl
operator|=
name|slioctl
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_output
operator|=
name|sloutput
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
operator|.
name|ifq_maxlen
operator|=
literal|50
expr_stmt|;
name|sc
operator|->
name|sc_fastq
operator|.
name|ifq_maxlen
operator|=
literal|32
expr_stmt|;
name|if_attach
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
operator|&
name|sc
operator|->
name|sc_bpf
argument_list|,
operator|&
name|sc
operator|->
name|sc_if
argument_list|,
name|DLT_SLIP
argument_list|,
name|SLIP_HDRLEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_expr_stmt
name|TEXT_SET
argument_list|(
name|pseudo_set
argument_list|,
name|slattach
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|slinit
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
name|caddr_t
name|p
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ep
operator|==
operator|(
name|u_char
operator|*
operator|)
literal|0
condition|)
block|{
name|MCLALLOC
argument_list|(
name|p
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|sc
operator|->
name|sc_ep
operator|=
operator|(
name|u_char
operator|*
operator|)
name|p
operator|+
name|SLBUFSIZE
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"sl%d: can't allocate buffer\n"
argument_list|,
name|sc
operator|-
name|sl_softc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|sc
operator|->
name|sc_buf
operator|=
name|sc
operator|->
name|sc_ep
operator|-
name|SLMAX
expr_stmt|;
name|sc
operator|->
name|sc_mp
operator|=
name|sc
operator|->
name|sc_buf
expr_stmt|;
name|sl_compress_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_comp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Line specific open routine.  * Attach the given tty to the first available sl unit.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|slopen
parameter_list|(
name|dev
parameter_list|,
name|tp
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|nsl
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|tp
operator|->
name|t_line
operator|==
name|SLIPDISC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|nsl
operator|=
name|NSL
operator|,
name|sc
operator|=
name|sl_softc
init|;
operator|--
name|nsl
operator|>=
literal|0
condition|;
name|sc
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_ttyp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|slinit
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|tp
operator|->
name|t_sc
operator|=
operator|(
name|caddr_t
operator|)
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_ttyp
operator|=
name|tp
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_baudrate
operator|=
name|tp
operator|->
name|t_ospeed
expr_stmt|;
name|ttyflush
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Line specific close routine.  * Detach the tty from the sl unit.  * Mimics part of ttyclose().  */
end_comment

begin_function
name|int
name|slclose
parameter_list|(
name|tp
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ttywflush
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* actually, max(spltty, splnet) */
name|tp
operator|->
name|t_line
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|sl_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
name|if_down
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ttyp
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|t_sc
operator|=
name|NULL
expr_stmt|;
name|MCLFREE
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|sc
operator|->
name|sc_ep
operator|-
name|SLBUFSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ep
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_mp
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_buf
operator|=
literal|0
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Line specific (tty) ioctl routine.  * Provide a way to get the sl unit number.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|sltioctl
parameter_list|(
name|tp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
name|struct
name|sl_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sl_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
decl_stmt|;
name|int
name|s
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SLIOCGUNIT
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
expr_stmt|;
break|break;
case|case
name|SLIOCGFLAGS
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_flags
expr_stmt|;
break|break;
case|case
name|SLIOCSFLAGS
case|:
define|#
directive|define
name|SC_MASK
value|0xffff
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
operator|(
name|sc
operator|->
name|sc_flags
operator|&
operator|~
name|SC_MASK
operator|)
operator||
operator|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|&
name|SC_MASK
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Queue a packet.  Start transmission if not active.  */
end_comment

begin_function
name|int
name|sloutput
parameter_list|(
name|ifp
parameter_list|,
name|m
parameter_list|,
name|dst
parameter_list|,
name|rt
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
init|=
operator|&
name|sl_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
specifier|register
name|struct
name|ifqueue
modifier|*
name|ifq
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* 	 * `Cannot happen' (see slioctl).  Someday we will extend 	 * the line protocol to support other address families. 	 */
if|if
condition|(
name|dst
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
name|printf
argument_list|(
literal|"sl%d: af%d not supported\n"
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_ttyp
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
comment|/* sort of */
block|}
if|if
condition|(
operator|(
operator|(
name|sc
operator|->
name|sc_ttyp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|sc
operator|->
name|sc_ttyp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
name|ifq
operator|=
operator|&
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
operator|)
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
condition|)
block|{
name|u_short
name|srcport
init|=
name|ntohs
argument_list|(
operator|(
operator|(
name|short
operator|*
operator|)
name|ip
operator|)
index|[
name|ip
operator|->
name|ip_hl
operator|<<
literal|1
index|]
argument_list|)
decl_stmt|;
name|u_short
name|dstport
init|=
name|ntohs
argument_list|(
operator|(
operator|(
name|short
operator|*
operator|)
name|ip
operator|)
index|[
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|1
operator|)
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|INTERACTIVE
argument_list|(
name|srcport
argument_list|)
operator|||
name|INTERACTIVE
argument_list|(
name|dstport
argument_list|)
condition|)
block|{
name|ifq
operator|=
operator|&
name|sc
operator|->
name|sc_fastq
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_NOICMP
operator|&&
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_ICMP
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
name|ifq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|IF_ENQUEUE
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_lastchange
operator|=
name|time
expr_stmt|;
if|if
condition|(
name|RB_LEN
argument_list|(
name|sc
operator|->
name|sc_ttyp
operator|->
name|t_out
argument_list|)
operator|==
literal|0
condition|)
name|slstart
argument_list|(
name|sc
operator|->
name|sc_ttyp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start output on interface.  Get another datagram  * to send from the interface queue and map it to  * the interface before starting output.  */
end_comment

begin_function
name|void
name|slstart
parameter_list|(
name|tp
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|sl_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m2
decl_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|u_char
name|bpfbuf
index|[
name|SLMTU
operator|+
name|SLIP_HDRLEN
index|]
decl_stmt|;
specifier|register
name|int
name|len
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Call output process whether or not there is any output. 		 * We are being called in lieu of ttstart and must do what 		 * it would. 		 */
call|(
modifier|*
name|tp
operator|->
name|t_oproc
call|)
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|RB_LEN
argument_list|(
name|tp
operator|->
name|t_out
argument_list|)
operator|>
name|SLIP_HIWAT
condition|)
return|return;
comment|/* 		 * This happens briefly when the line shuts down. 		 */
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
comment|/* 		 * Do not remove the packet from the IP queue if it 		 * doesn't look like the packet will fit into the 		 * current COM output queue, with a packet full of 		 * escapes this could be as bad as SLMTU*2.  The value 		 * of RBSZ in tty.h also has to be upped to be at least 		 * SLMTU*2. 		 */
if|if
condition|(
name|min
argument_list|(
name|RBSZ
argument_list|,
literal|4
operator|*
name|SLMTU
operator|+
literal|4
argument_list|)
operator|-
name|RB_LEN
argument_list|(
name|tp
operator|->
name|t_out
argument_list|)
operator|<
literal|2
operator|*
name|SLMTU
operator|+
literal|2
condition|)
return|return;
comment|/* 		 * Get a packet and send it to the interface. 		 */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_fastq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
comment|/* 		 * We do the header compression here rather than in sl_output 		 * because the packets will be out of order if we are using TOS 		 * queueing, and the connection id compression will get messed 		 * up when this happens. 		 */
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|sc_bpf
condition|)
block|{
comment|/* 		 * We need to save the TCP/IP header before it's compressed. 		 * To avoid complicated code, we just copy the entire packet 		 * into a stack buffer (since this is a serial line, packets 		 * should be short and/or the copy should be negligible cost 		 * compared to the packet transmission time). 		*/
specifier|register
name|struct
name|mbuf
modifier|*
name|m1
init|=
name|m
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
init|=
name|bpfbuf
operator|+
name|SLIP_HDRLEN
decl_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
do|do
block|{
specifier|register
name|int
name|mlen
init|=
name|m1
operator|->
name|m_len
decl_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m1
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|cp
argument_list|,
name|mlen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|mlen
expr_stmt|;
name|len
operator|+=
name|mlen
expr_stmt|;
block|}
do|while
condition|(
name|m1
operator|=
name|m1
operator|->
name|m_next
condition|)
do|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
operator|)
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_COMPRESS
condition|)
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator||=
name|sl_compress_tcp
argument_list|(
name|m
argument_list|,
name|ip
argument_list|,
operator|&
name|sc
operator|->
name|sc_comp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|sc_bpf
condition|)
block|{
comment|/*                  * Put the SLIP pseudo-"link header" in place.  The compressed                  * header is now at the beginning of the mbuf.                  */
name|bpfbuf
index|[
name|SLX_DIR
index|]
operator|=
name|SLIPDIR_OUT
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
operator|&
name|bpfbuf
index|[
name|SLX_CHDR
index|]
argument_list|,
name|CHDR_LEN
argument_list|)
expr_stmt|;
name|bpf_tap
argument_list|(
name|sc
operator|->
name|sc_bpf
argument_list|,
name|bpfbuf
argument_list|,
name|len
operator|+
name|SLIP_HDRLEN
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sc
operator|->
name|sc_if
operator|.
name|if_lastchange
operator|=
name|time
expr_stmt|;
comment|/* 		 * The extra FRAME_END will start up a new packet, and thus 		 * will flush any accumulated garbage.  We do this whenever 		 * the line may have been idle for some time. 		 */
if|if
condition|(
name|RB_LEN
argument_list|(
name|tp
operator|->
name|t_out
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|sc
operator|->
name|sc_bytessent
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
name|FRAME_END
argument_list|,
name|tp
operator|->
name|t_out
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|m
condition|)
block|{
specifier|register
name|u_char
modifier|*
name|ep
decl_stmt|;
name|cp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|ep
operator|=
name|cp
operator|+
name|m
operator|->
name|m_len
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|ep
condition|)
block|{
comment|/* 				 * Find out how many bytes in the string we can 				 * handle without doing something special. 				 */
specifier|register
name|u_char
modifier|*
name|bp
init|=
name|cp
decl_stmt|;
while|while
condition|(
name|cp
operator|<
name|ep
condition|)
block|{
switch|switch
condition|(
operator|*
name|cp
operator|++
condition|)
block|{
case|case
name|FRAME_ESCAPE
case|:
case|case
name|FRAME_END
case|:
operator|--
name|cp
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
if|if
condition|(
name|cp
operator|>
name|bp
condition|)
block|{
comment|/* 					 * Put the non-special bytes 					 * into the tty output queue. 					 */
name|sc
operator|->
name|sc_bytessent
operator|+=
name|rb_write
argument_list|(
name|tp
operator|->
name|t_out
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|,
name|cp
operator|-
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * If there are characters left in the mbuf, 				 * the first one must be special.. 				 * Put it out in a different form. 				 */
if|if
condition|(
name|cp
operator|<
name|ep
condition|)
block|{
if|if
condition|(
name|putc
argument_list|(
name|FRAME_ESCAPE
argument_list|,
name|tp
operator|->
name|t_out
argument_list|)
condition|)
break|break;
if|if
condition|(
name|putc
argument_list|(
operator|*
name|cp
operator|++
operator|==
name|FRAME_ESCAPE
condition|?
name|TRANS_FRAME_ESCAPE
else|:
name|TRANS_FRAME_END
argument_list|,
name|tp
operator|->
name|t_out
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|unputc
argument_list|(
name|tp
operator|->
name|t_out
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|sc_bytessent
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|MFREE
argument_list|(
name|m
argument_list|,
name|m2
argument_list|)
expr_stmt|;
name|m
operator|=
name|m2
expr_stmt|;
block|}
if|if
condition|(
name|putc
argument_list|(
name|FRAME_END
argument_list|,
name|tp
operator|->
name|t_out
argument_list|)
condition|)
block|{
comment|/* 			 * Not enough room.  Remove a char to make room 			 * and end the packet normally. 			 * If you get many collisions (more than one or two 			 * a day) you probably do not have enough clists 			 * and you should increase "nclist" in param.c. 			 */
operator|(
name|void
operator|)
name|unputc
argument_list|(
name|tp
operator|->
name|t_out
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
name|FRAME_END
argument_list|,
name|tp
operator|->
name|t_out
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_collisions
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|++
name|sc
operator|->
name|sc_bytessent
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
block|}
name|sc
operator|->
name|sc_if
operator|.
name|if_obytes
operator|=
name|sc
operator|->
name|sc_bytessent
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Copy data buffer to mbuf chain; add ifnet pointer.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sl_btom
parameter_list|(
name|sc
parameter_list|,
name|len
parameter_list|)
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * If we have more than MHLEN bytes, it's cheaper to 	 * queue the cluster we just filled& allocate a new one 	 * for the input buffer.  Otherwise, fill the mbuf we 	 * allocated above.  Note that code in the input routine 	 * guarantees that packet will fit in a cluster. 	 */
if|if
condition|(
name|len
operator|>=
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * we couldn't get a cluster - if memory's this 			 * low, it's time to start dropping packets. 			 */
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sc
operator|->
name|sc_ep
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
name|SLBUFSIZE
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_buf
expr_stmt|;
name|m
operator|->
name|m_ext
operator|.
name|ext_buf
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|int
operator|)
name|sc
operator|->
name|sc_buf
operator|&
operator|~
name|MCLOFSET
argument_list|)
expr_stmt|;
block|}
else|else
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_buf
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|sc
operator|->
name|sc_if
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * tty interface receiver interrupt.  */
end_comment

begin_function
name|void
name|slinput
parameter_list|(
name|c
parameter_list|,
name|tp
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
specifier|register
name|struct
name|sl_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|int
name|s
decl_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|u_char
name|chdr
index|[
name|CHDR_LEN
index|]
decl_stmt|;
endif|#
directive|endif
name|tk_nin
operator|++
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|sl_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
operator|(
name|c
operator|&
name|TTY_ERRORMASK
operator|)
operator|||
operator|(
operator|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* XXX */
name|sc
operator|->
name|sc_flags
operator||=
name|SC_ERROR
expr_stmt|;
return|return;
block|}
operator|++
name|sc
operator|->
name|sc_bytesrcvd
expr_stmt|;
operator|++
name|sc
operator|->
name|sc_if
operator|.
name|if_ibytes
expr_stmt|;
ifdef|#
directive|ifdef
name|ABT_ESC
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_ABORT
condition|)
block|{
comment|/* if we see an abort after "idle" time, count it */
if|if
condition|(
name|c
operator|==
name|ABT_ESC
operator|&&
name|time
operator|.
name|tv_sec
operator|>=
name|sc
operator|->
name|sc_lasttime
operator|+
name|ABT_WAIT
condition|)
block|{
name|sc
operator|->
name|sc_abortcount
operator|++
expr_stmt|;
comment|/* record when the first abort escape arrived */
if|if
condition|(
name|sc
operator|->
name|sc_abortcount
operator|==
literal|1
condition|)
name|sc
operator|->
name|sc_starttime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
block|}
comment|/* 		 * if we have an abort, see that we have not run out of time, 		 * or that we have an "idle" time after the complete escape 		 * sequence 		 */
if|if
condition|(
name|sc
operator|->
name|sc_abortcount
condition|)
block|{
if|if
condition|(
name|time
operator|.
name|tv_sec
operator|>=
name|sc
operator|->
name|sc_starttime
operator|+
name|ABT_RECYCLE
condition|)
name|sc
operator|->
name|sc_abortcount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_abortcount
operator|>=
name|ABT_SOFT
operator|&&
name|time
operator|.
name|tv_sec
operator|>=
name|sc
operator|->
name|sc_lasttime
operator|+
name|ABT_WAIT
condition|)
block|{
name|slclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|sc
operator|->
name|sc_lasttime
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|TRANS_FRAME_ESCAPE
case|:
if|if
condition|(
name|sc
operator|->
name|sc_escape
condition|)
name|c
operator|=
name|FRAME_ESCAPE
expr_stmt|;
break|break;
case|case
name|TRANS_FRAME_END
case|:
if|if
condition|(
name|sc
operator|->
name|sc_escape
condition|)
name|c
operator|=
name|FRAME_END
expr_stmt|;
break|break;
case|case
name|FRAME_ESCAPE
case|:
name|sc
operator|->
name|sc_escape
operator|=
literal|1
expr_stmt|;
return|return;
case|case
name|FRAME_END
case|:
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_ERROR
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_ERROR
expr_stmt|;
goto|goto
name|newpack
goto|;
block|}
name|len
operator|=
name|sc
operator|->
name|sc_mp
operator|-
name|sc
operator|->
name|sc_buf
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|3
condition|)
comment|/* less than min length packet - ignore */
goto|goto
name|newpack
goto|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|sc_bpf
condition|)
comment|/* 			 * Save the compressed header, so we can 			 * tack it on later.  Note that we just 			 * we will end up copying garbage in some 			 * cases but this is okay.  We remember 			 * where the buffer started so we can 			 * compute the new header length. 			 */
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_buf
argument_list|,
name|chdr
argument_list|,
name|CHDR_LEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|c
operator|=
operator|(
operator|*
name|sc
operator|->
name|sc_buf
operator|&
literal|0xf0
operator|)
operator|)
operator|!=
operator|(
name|IPVERSION
operator|<<
literal|4
operator|)
condition|)
block|{
if|if
condition|(
name|c
operator|&
literal|0x80
condition|)
name|c
operator|=
name|TYPE_COMPRESSED_TCP
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
name|TYPE_UNCOMPRESSED_TCP
condition|)
operator|*
name|sc
operator|->
name|sc_buf
operator|&=
literal|0x4f
expr_stmt|;
comment|/* XXX */
comment|/* 			 * We've got something that's not an IP packet. 			 * If compression is enabled, try to decompress it. 			 * Otherwise, if `auto-enable' compression is on and 			 * it's a reasonable packet, decompress it and then 			 * enable compression.  Otherwise, drop it. 			 */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_COMPRESS
condition|)
block|{
name|len
operator|=
name|sl_uncompress_tcp
argument_list|(
operator|&
name|sc
operator|->
name|sc_buf
argument_list|,
name|len
argument_list|,
operator|(
name|u_int
operator|)
name|c
argument_list|,
operator|&
name|sc
operator|->
name|sc_comp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
goto|goto
name|error
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_AUTOCOMP
operator|)
operator|&&
name|c
operator|==
name|TYPE_UNCOMPRESSED_TCP
operator|&&
name|len
operator|>=
literal|40
condition|)
block|{
name|len
operator|=
name|sl_uncompress_tcp
argument_list|(
operator|&
name|sc
operator|->
name|sc_buf
argument_list|,
name|len
argument_list|,
operator|(
name|u_int
operator|)
name|c
argument_list|,
operator|&
name|sc
operator|->
name|sc_comp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
goto|goto
name|error
goto|;
name|sc
operator|->
name|sc_flags
operator||=
name|SC_COMPRESS
expr_stmt|;
block|}
else|else
goto|goto
name|error
goto|;
block|}
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
if|if
condition|(
name|sc
operator|->
name|sc_bpf
condition|)
block|{
comment|/* 			 * Put the SLIP pseudo-"link header" in place. 			 * We couldn't do this any earlier since 			 * decompression probably moved the buffer 			 * pointer.  Then, invoke BPF. 			 */
specifier|register
name|u_char
modifier|*
name|hp
init|=
name|sc
operator|->
name|sc_buf
operator|-
name|SLIP_HDRLEN
decl_stmt|;
name|hp
index|[
name|SLX_DIR
index|]
operator|=
name|SLIPDIR_IN
expr_stmt|;
name|bcopy
argument_list|(
name|chdr
argument_list|,
operator|&
name|hp
index|[
name|SLX_CHDR
index|]
argument_list|,
name|CHDR_LEN
argument_list|)
expr_stmt|;
name|bpf_tap
argument_list|(
name|sc
operator|->
name|sc_bpf
argument_list|,
name|hp
argument_list|,
name|len
operator|+
name|SLIP_HDRLEN
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m
operator|=
name|sl_btom
argument_list|(
name|sc
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_lastchange
operator|=
name|time
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|ipintrq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
operator|&
name|ipintrq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_iqdrops
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IF_ENQUEUE
argument_list|(
operator|&
name|ipintrq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|schednetisr
argument_list|(
name|NETISR_IP
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|newpack
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_mp
operator|<
name|sc
operator|->
name|sc_ep
condition|)
block|{
operator|*
name|sc
operator|->
name|sc_mp
operator|++
operator|=
name|c
expr_stmt|;
name|sc
operator|->
name|sc_escape
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|sc
operator|->
name|sc_flags
operator||=
name|SC_ERROR
expr_stmt|;
name|error
label|:
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|newpack
label|:
name|sc
operator|->
name|sc_mp
operator|=
name|sc
operator|->
name|sc_buf
operator|=
name|sc
operator|->
name|sc_ep
operator|-
name|SLMAX
expr_stmt|;
name|sc
operator|->
name|sc_escape
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|experimental
end_ifdef

begin_comment
comment|/*  * Get a route change request.  * We fill in the MTU and lock it so that MTU discovery won't try  * to change it back to the interface MTU.  */
end_comment

begin_function
specifier|static
name|int
name|slrtrequest
parameter_list|(
name|int
name|cmd
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|gate
parameter_list|)
block|{
if|if
condition|(
name|rt
condition|)
block|{
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_mtu
operator|=
name|SLRMTU
expr_stmt|;
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_locks
operator||=
name|RTV_MTU
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Process an ioctl request.  */
end_comment

begin_function
name|int
name|slioctl
parameter_list|(
name|ifp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCAIFADDR
case|:
case|case
name|SIOCSIFADDR
case|:
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
ifdef|#
directive|ifdef
name|experimental
name|ifa
operator|->
name|ifa_rtrequest
operator|=
name|slrtrequest
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFDSTADDR
case|:
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

