begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 The FreeBSD Foundation  * Copyright (c) 2009-2010 Bjoern A. Zeeb<bz@FreeBSD.org>  * All rights reserved.  *  * This software was developed by CK Software GmbH under sponsorship  * from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  * notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  * notice, this list of conditions and the following disclaimer in the  * documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * A pair of virtual back-to-back connected ethernet like interfaces  * (``two interfaces with a virtual cross-over cable'').  *  * This is mostly intended to be used to provide connectivity between  * different virtual network stack instances.  */
end_comment

begin_comment
comment|/*  * Things to re-think once we have more experience:  * - ifp->if_reassign function once we can test with vimage. Depending on  *   how if_vmove() is going to be improved.  * - Real random etheraddrs that are checked to be uniquish; we would need  *   to re-do them in case we move the interface between network stacks  *   in a private if_reassign function.  *   In case we bridge to a real interface/network or between indepedent  *   epairs on multiple stacks/machines, we may need this.  *   For now let the user handle that case.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_clone.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_define
define|#
directive|define
name|EPAIRNAME
value|"epair"
end_define

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_link
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_link
argument_list|,
name|OID_AUTO
argument_list|,
name|epair
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"epair sysctl"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|EPAIR_DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|epair_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_XINT
argument_list|(
name|_net_link_epair
argument_list|,
name|OID_AUTO
argument_list|,
name|epair_debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|epair_debug
argument_list|,
literal|0
argument_list|,
literal|"if_epair(4) debugging."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|arg
modifier|...
parameter_list|)
define|\
value|if (epair_debug)						\ 		printf("[%s:%d] " fmt, __func__, __LINE__, ##arg)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|fmt
parameter_list|,
name|arg
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|epair_nh_sintr
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|epair_nh_m2cpuid
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|uintptr_t
parameter_list|,
name|u_int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|epair_nh_drainedcpu
parameter_list|(
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|epair_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|epair_clone_match
parameter_list|(
name|struct
name|if_clone
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|epair_clone_create
parameter_list|(
name|struct
name|if_clone
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|epair_clone_destroy
parameter_list|(
name|struct
name|if_clone
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Netisr realted definitions and sysctl. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|netisr_handler
name|epair_nh
init|=
block|{
operator|.
name|nh_name
operator|=
name|EPAIRNAME
block|,
operator|.
name|nh_proto
operator|=
name|NETISR_EPAIR
block|,
operator|.
name|nh_policy
operator|=
name|NETISR_POLICY_CPU
block|,
operator|.
name|nh_handler
operator|=
name|epair_nh_sintr
block|,
operator|.
name|nh_m2cpuid
operator|=
name|epair_nh_m2cpuid
block|,
operator|.
name|nh_drainedcpu
operator|=
name|epair_nh_drainedcpu
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|sysctl_epair_netisr_maxqlen
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|qlimit
decl_stmt|;
name|netisr_getqlimit
argument_list|(
operator|&
name|epair_nh
argument_list|,
operator|&
name|qlimit
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|qlimit
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|qlimit
operator|<
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|netisr_setqlimit
argument_list|(
operator|&
name|epair_nh
argument_list|,
name|qlimit
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_link_epair
argument_list|,
name|OID_AUTO
argument_list|,
name|netisr_maxqlen
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_epair_netisr_maxqlen
argument_list|,
literal|"I"
argument_list|,
literal|"Maximum if_epair(4) netisr \"hw\" queue length"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|epair_softc
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
comment|/* This ifp. */
name|struct
name|ifnet
modifier|*
name|oifp
decl_stmt|;
comment|/* other ifp of pair. */
name|u_int
name|refcount
decl_stmt|;
comment|/* # of mbufs in flight. */
name|u_int
name|cpuid
decl_stmt|;
comment|/* CPU ID assigned upon creation. */
name|void
function_decl|(
modifier|*
name|if_qflush
function_decl|)
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
comment|/* Original if_qflush routine. */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Per-CPU list of ifps with data in the ifq that needs to be flushed  * to the netisr ``hw'' queue before we allow any further direct queuing  * to the ``hw'' queue.  */
end_comment

begin_struct
struct|struct
name|epair_ifp_drain
block|{
name|STAILQ_ENTRY
argument_list|(
argument|epair_ifp_drain
argument_list|)
name|ifp_next
expr_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|STAILQ_HEAD
argument_list|(
name|eid_list
argument_list|,
name|epair_ifp_drain
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|EPAIR_LOCK_INIT
parameter_list|(
name|dpcpu
parameter_list|)
value|mtx_init(&(dpcpu)->if_epair_mtx, \ 					    "if_epair", NULL, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|EPAIR_LOCK_DESTROY
parameter_list|(
name|dpcpu
parameter_list|)
value|mtx_destroy(&(dpcpu)->if_epair_mtx)
end_define

begin_define
define|#
directive|define
name|EPAIR_LOCK_ASSERT
parameter_list|(
name|dpcpu
parameter_list|)
value|mtx_assert(&(dpcpu)->if_epair_mtx, \ 					    MA_OWNED)
end_define

begin_define
define|#
directive|define
name|EPAIR_LOCK
parameter_list|(
name|dpcpu
parameter_list|)
value|mtx_lock(&(dpcpu)->if_epair_mtx)
end_define

begin_define
define|#
directive|define
name|EPAIR_UNLOCK
parameter_list|(
name|dpcpu
parameter_list|)
value|mtx_unlock(&(dpcpu)->if_epair_mtx)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANTS
end_ifdef

begin_define
define|#
directive|define
name|EPAIR_REFCOUNT_INIT
parameter_list|(
name|r
parameter_list|,
name|v
parameter_list|)
value|refcount_init((r), (v))
end_define

begin_define
define|#
directive|define
name|EPAIR_REFCOUNT_AQUIRE
parameter_list|(
name|r
parameter_list|)
value|refcount_acquire((r))
end_define

begin_define
define|#
directive|define
name|EPAIR_REFCOUNT_RELEASE
parameter_list|(
name|r
parameter_list|)
value|refcount_release((r))
end_define

begin_define
define|#
directive|define
name|EPAIR_REFCOUNT_ASSERT
parameter_list|(
name|a
parameter_list|,
name|p
parameter_list|)
value|KASSERT(a, p)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|EPAIR_REFCOUNT_INIT
parameter_list|(
name|r
parameter_list|,
name|v
parameter_list|)
end_define

begin_define
define|#
directive|define
name|EPAIR_REFCOUNT_AQUIRE
parameter_list|(
name|r
parameter_list|)
end_define

begin_define
define|#
directive|define
name|EPAIR_REFCOUNT_RELEASE
parameter_list|(
name|r
parameter_list|)
end_define

begin_define
define|#
directive|define
name|EPAIR_REFCOUNT_ASSERT
parameter_list|(
name|a
parameter_list|,
name|p
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_EPAIR
argument_list|,
name|EPAIRNAME
argument_list|,
literal|"Pair of virtual cross-over connected Ethernet-like interfaces"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|if_clone
name|epair_cloner
init|=
name|IFC_CLONE_INITIALIZER
argument_list|(
name|EPAIRNAME
argument_list|,
name|NULL
argument_list|,
name|IF_MAXUNIT
argument_list|,
name|NULL
argument_list|,
name|epair_clone_match
argument_list|,
name|epair_clone_create
argument_list|,
name|epair_clone_destroy
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * DPCPU area and functions.  */
end_comment

begin_struct
struct|struct
name|epair_dpcpu
block|{
name|struct
name|mtx
name|if_epair_mtx
decl_stmt|;
comment|/* Per-CPU locking. */
name|int
name|epair_drv_flags
decl_stmt|;
comment|/* Per-CPU ``hw'' drv flags. */
name|struct
name|eid_list
name|epair_ifp_drain_list
decl_stmt|;
comment|/* Per-CPU list of ifps with 						 * data in the ifq. */
block|}
struct|;
end_struct

begin_expr_stmt
name|DPCPU_DEFINE
argument_list|(
expr|struct
name|epair_dpcpu
argument_list|,
name|epair_dpcpu
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|epair_dpcpu_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|epair_dpcpu
modifier|*
name|epair_dpcpu
decl_stmt|;
name|struct
name|eid_list
modifier|*
name|s
decl_stmt|;
name|u_int
name|cpuid
decl_stmt|;
for|for
control|(
name|cpuid
operator|=
literal|0
init|;
name|cpuid
operator|<=
name|mp_maxid
condition|;
name|cpuid
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|cpuid
argument_list|)
condition|)
continue|continue;
name|epair_dpcpu
operator|=
name|DPCPU_ID_PTR
argument_list|(
name|cpuid
argument_list|,
name|epair_dpcpu
argument_list|)
expr_stmt|;
comment|/* Initialize per-cpu lock. */
name|EPAIR_LOCK_INIT
argument_list|(
name|epair_dpcpu
argument_list|)
expr_stmt|;
comment|/* Driver flags are per-cpu as are our netisr "hw" queues. */
name|epair_dpcpu
operator|->
name|epair_drv_flags
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Initialize per-cpu drain list. 		 * Manually do what STAILQ_HEAD_INITIALIZER would do. 		 */
name|s
operator|=
operator|&
name|epair_dpcpu
operator|->
name|epair_ifp_drain_list
expr_stmt|;
name|s
operator|->
name|stqh_first
operator|=
name|NULL
expr_stmt|;
name|s
operator|->
name|stqh_last
operator|=
operator|&
name|s
operator|->
name|stqh_first
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|epair_dpcpu_detach
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|epair_dpcpu
modifier|*
name|epair_dpcpu
decl_stmt|;
name|u_int
name|cpuid
decl_stmt|;
for|for
control|(
name|cpuid
operator|=
literal|0
init|;
name|cpuid
operator|<=
name|mp_maxid
condition|;
name|cpuid
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|cpuid
argument_list|)
condition|)
continue|continue;
name|epair_dpcpu
operator|=
name|DPCPU_ID_PTR
argument_list|(
name|cpuid
argument_list|,
name|epair_dpcpu
argument_list|)
expr_stmt|;
comment|/* Destroy per-cpu lock. */
name|EPAIR_LOCK_DESTROY
argument_list|(
name|epair_dpcpu
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Helper functions.  */
end_comment

begin_function
specifier|static
name|u_int
name|cpuid_from_ifp
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|epair_softc
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
return|return
operator|(
name|sc
operator|->
name|cpuid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Netisr handler functions.  */
end_comment

begin_function
specifier|static
name|void
name|epair_nh_sintr
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|epair_softc
modifier|*
name|sc
decl_stmt|;
name|ifp
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_input
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|EPAIR_REFCOUNT_RELEASE
argument_list|(
operator|&
name|sc
operator|->
name|refcount
argument_list|)
expr_stmt|;
name|EPAIR_REFCOUNT_ASSERT
argument_list|(
operator|(
name|int
operator|)
name|sc
operator|->
name|refcount
operator|>=
literal|1
argument_list|,
operator|(
literal|"%s: ifp=%p sc->refcount not>= 1: %d"
operator|,
name|__func__
operator|,
name|ifp
operator|,
name|sc
operator|->
name|refcount
operator|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"ifp=%p refcount=%u\n"
argument_list|,
name|ifp
argument_list|,
name|sc
operator|->
name|refcount
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|epair_nh_m2cpuid
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uintptr_t
name|source
parameter_list|,
name|u_int
modifier|*
name|cpuid
parameter_list|)
block|{
operator|*
name|cpuid
operator|=
name|cpuid_from_ifp
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|epair_nh_drainedcpu
parameter_list|(
name|u_int
name|cpuid
parameter_list|)
block|{
name|struct
name|epair_dpcpu
modifier|*
name|epair_dpcpu
decl_stmt|;
name|struct
name|epair_ifp_drain
modifier|*
name|elm
decl_stmt|,
modifier|*
name|tvar
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|epair_dpcpu
operator|=
name|DPCPU_ID_PTR
argument_list|(
name|cpuid
argument_list|,
name|epair_dpcpu
argument_list|)
expr_stmt|;
name|EPAIR_LOCK
argument_list|(
name|epair_dpcpu
argument_list|)
expr_stmt|;
comment|/* 	 * Assume our "hw" queue and possibly ifq will be emptied 	 * again. In case we will overflow the "hw" queue while 	 * draining, epair_start_locked will set IFF_DRV_OACTIVE 	 * again and we will stop and return. 	 */
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|elm
argument_list|,
argument|&epair_dpcpu->epair_ifp_drain_list
argument_list|,
argument|ifp_next
argument_list|,
argument|tvar
argument_list|)
block|{
name|ifp
operator|=
name|elm
operator|->
name|ifp
expr_stmt|;
name|epair_dpcpu
operator|->
name|epair_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|epair_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|IFQ_LOCK
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFQ_IS_EMPTY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|struct
name|epair_softc
modifier|*
name|sc
decl_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|epair_dpcpu
operator|->
name|epair_ifp_drain_list
argument_list|,
name|elm
argument_list|,
name|epair_ifp_drain
argument_list|,
name|ifp_next
argument_list|)
expr_stmt|;
comment|/* The cached ifp goes off the list. */
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|EPAIR_REFCOUNT_RELEASE
argument_list|(
operator|&
name|sc
operator|->
name|refcount
argument_list|)
expr_stmt|;
name|EPAIR_REFCOUNT_ASSERT
argument_list|(
operator|(
name|int
operator|)
name|sc
operator|->
name|refcount
operator|>=
literal|1
argument_list|,
operator|(
literal|"%s: ifp=%p sc->refcount not>= 1: %d"
operator|,
name|__func__
operator|,
name|ifp
operator|,
name|sc
operator|->
name|refcount
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|elm
argument_list|,
name|M_EPAIR
argument_list|)
expr_stmt|;
block|}
name|IFQ_UNLOCK
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Our "hw"q overflew again. */
name|epair_dpcpu
operator|->
name|epair_drv_flags
operator||=
name|IFF_DRV_OACTIVE
name|DPRINTF
argument_list|(
literal|"hw queue length overflow at %u\n"
argument_list|,
name|epair_nh
operator|.
name|nh_qlimit
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|EPAIR_UNLOCK
argument_list|(
name|epair_dpcpu
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Network interface (`if') related functions.  */
end_comment

begin_function
specifier|static
name|void
name|epair_remove_ifp_from_draining
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|epair_dpcpu
modifier|*
name|epair_dpcpu
decl_stmt|;
name|struct
name|epair_ifp_drain
modifier|*
name|elm
decl_stmt|,
modifier|*
name|tvar
decl_stmt|;
name|u_int
name|cpuid
decl_stmt|;
for|for
control|(
name|cpuid
operator|=
literal|0
init|;
name|cpuid
operator|<=
name|mp_maxid
condition|;
name|cpuid
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|cpuid
argument_list|)
condition|)
continue|continue;
name|epair_dpcpu
operator|=
name|DPCPU_ID_PTR
argument_list|(
name|cpuid
argument_list|,
name|epair_dpcpu
argument_list|)
expr_stmt|;
name|EPAIR_LOCK
argument_list|(
name|epair_dpcpu
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH_SAFE
argument_list|(
argument|elm
argument_list|,
argument|&epair_dpcpu->epair_ifp_drain_list
argument_list|,
argument|ifp_next
argument_list|,
argument|tvar
argument_list|)
block|{
if|if
condition|(
name|ifp
operator|==
name|elm
operator|->
name|ifp
condition|)
block|{
name|struct
name|epair_softc
modifier|*
name|sc
decl_stmt|;
name|STAILQ_REMOVE
argument_list|(
operator|&
name|epair_dpcpu
operator|->
name|epair_ifp_drain_list
argument_list|,
name|elm
argument_list|,
name|epair_ifp_drain
argument_list|,
name|ifp_next
argument_list|)
expr_stmt|;
comment|/* The cached ifp goes off the list. */
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|EPAIR_REFCOUNT_RELEASE
argument_list|(
operator|&
name|sc
operator|->
name|refcount
argument_list|)
expr_stmt|;
name|EPAIR_REFCOUNT_ASSERT
argument_list|(
operator|(
name|int
operator|)
name|sc
operator|->
name|refcount
operator|>=
literal|1
argument_list|,
operator|(
literal|"%s: ifp=%p sc->refcount not>= 1: %d"
operator|,
name|__func__
operator|,
name|ifp
operator|,
name|sc
operator|->
name|refcount
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|elm
argument_list|,
name|M_EPAIR
argument_list|)
expr_stmt|;
block|}
block|}
name|EPAIR_UNLOCK
argument_list|(
name|epair_dpcpu
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|epair_add_ifp_for_draining
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|epair_dpcpu
modifier|*
name|epair_dpcpu
decl_stmt|;
name|struct
name|epair_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|epair_ifp_drain
modifier|*
name|elm
init|=
name|NULL
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|epair_dpcpu
operator|=
name|DPCPU_ID_PTR
argument_list|(
name|sc
operator|->
name|cpuid
argument_list|,
name|epair_dpcpu
argument_list|)
expr_stmt|;
name|EPAIR_LOCK_ASSERT
argument_list|(
name|epair_dpcpu
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|elm
argument_list|,
argument|&epair_dpcpu->epair_ifp_drain_list
argument_list|,
argument|ifp_next
argument_list|)
if|if
condition|(
name|elm
operator|->
name|ifp
operator|==
name|ifp
condition|)
break|break;
comment|/* If the ifp is there already, return success. */
if|if
condition|(
name|elm
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|elm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|epair_ifp_drain
argument_list|)
argument_list|,
name|M_EPAIR
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|elm
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|elm
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
comment|/* Add a reference for the ifp pointer on the list. */
name|EPAIR_REFCOUNT_AQUIRE
argument_list|(
operator|&
name|sc
operator|->
name|refcount
argument_list|)
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|epair_dpcpu
operator|->
name|epair_ifp_drain_list
argument_list|,
name|elm
argument_list|,
name|ifp_next
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|epair_start_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|epair_dpcpu
modifier|*
name|epair_dpcpu
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|epair_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|oifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"ifp=%p\n"
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|epair_dpcpu
operator|=
name|DPCPU_ID_PTR
argument_list|(
name|sc
operator|->
name|cpuid
argument_list|,
name|epair_dpcpu
argument_list|)
expr_stmt|;
name|EPAIR_LOCK_ASSERT
argument_list|(
name|epair_dpcpu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * We get patckets here from ether_output via if_handoff() 	 * and ned to put them into the input queue of the oifp 	 * and call oifp->if_input() via netisr/epair_sintr(). 	 */
name|oifp
operator|=
name|sc
operator|->
name|oifp
expr_stmt|;
name|sc
operator|=
name|oifp
operator|->
name|if_softc
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|IFQ_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 		 * In case the outgoing interface is not usable, 		 * drop the packet. 		 */
if|if
condition|(
operator|(
name|oifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
operator|(
name|oifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|DPRINTF
argument_list|(
literal|"packet %s -> %s\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|oifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
comment|/* 		 * Add a reference so the interface cannot go while the 		 * packet is in transit as we rely on rcvif to stay valid. 		 */
name|EPAIR_REFCOUNT_AQUIRE
argument_list|(
operator|&
name|sc
operator|->
name|refcount
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|oifp
expr_stmt|;
name|CURVNET_SET_QUIET
argument_list|(
name|oifp
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|error
operator|=
name|netisr_queue
argument_list|(
name|NETISR_EPAIR
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
comment|/* Someone else received the packet. */
name|oifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* The packet was freed already. */
name|epair_dpcpu
operator|->
name|epair_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
operator|(
name|void
operator|)
name|epair_add_ifp_for_draining
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|EPAIR_REFCOUNT_RELEASE
argument_list|(
operator|&
name|sc
operator|->
name|refcount
argument_list|)
expr_stmt|;
name|EPAIR_REFCOUNT_ASSERT
argument_list|(
operator|(
name|int
operator|)
name|sc
operator|->
name|refcount
operator|>=
literal|1
argument_list|,
operator|(
literal|"%s: ifp=%p sc->refcount not>= 1: %d"
operator|,
name|__func__
operator|,
name|oifp
operator|,
name|sc
operator|->
name|refcount
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|epair_start
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|epair_dpcpu
modifier|*
name|epair_dpcpu
decl_stmt|;
name|epair_dpcpu
operator|=
name|DPCPU_ID_PTR
argument_list|(
name|cpuid_from_ifp
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|epair_dpcpu
argument_list|)
expr_stmt|;
name|EPAIR_LOCK
argument_list|(
name|epair_dpcpu
argument_list|)
expr_stmt|;
name|epair_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|EPAIR_UNLOCK
argument_list|(
name|epair_dpcpu
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|epair_transmit_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|epair_dpcpu
modifier|*
name|epair_dpcpu
decl_stmt|;
name|struct
name|epair_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|oifp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|;
name|short
name|mflags
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"ifp=%p m=%p\n"
argument_list|,
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|epair_dpcpu
operator|=
name|DPCPU_ID_PTR
argument_list|(
name|sc
operator|->
name|cpuid
argument_list|,
name|epair_dpcpu
argument_list|)
expr_stmt|;
name|EPAIR_LOCK_ASSERT
argument_list|(
name|epair_dpcpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * We are not going to use the interface en/dequeue mechanism 	 * on the TX side. We are called from ether_output_frame() 	 * and will put the packet into the incoming queue of the 	 * other interface of our pair via the netsir. 	 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * In case the outgoing interface is not usable, 	 * drop the packet. 	 */
name|oifp
operator|=
name|sc
operator|->
name|oifp
expr_stmt|;
if|if
condition|(
operator|(
name|oifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
operator|(
name|oifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|mflags
operator|=
name|m
operator|->
name|m_flags
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"packet %s -> %s\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|oifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTQ
comment|/* Support ALTQ via the clasic if_start() path. */
name|IF_LOCK
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ALTQ_IS_ENABLED
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|ALTQ_ENQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_drops
operator|++
expr_stmt|;
name|IF_UNLOCK
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|ifp
operator|->
name|if_obytes
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|mflags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
condition|)
name|ifp
operator|->
name|if_omcasts
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
operator|==
literal|0
condition|)
name|epair_start_locked
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|epair_add_ifp_for_draining
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
name|IF_UNLOCK
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|epair_dpcpu
operator|->
name|epair_drv_flags
operator|&
name|IFF_DRV_OACTIVE
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Our hardware queue is full, try to fall back 		 * queuing to the ifq but do not call ifp->if_start. 		 * Either we are lucky or the packet is gone. 		 */
name|IFQ_ENQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
operator|(
name|void
operator|)
name|epair_add_ifp_for_draining
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sc
operator|=
name|oifp
operator|->
name|if_softc
expr_stmt|;
comment|/* 	 * Add a reference so the interface cannot go while the 	 * packet is in transit as we rely on rcvif to stay valid. 	 */
name|EPAIR_REFCOUNT_AQUIRE
argument_list|(
operator|&
name|sc
operator|->
name|refcount
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|oifp
expr_stmt|;
name|CURVNET_SET_QUIET
argument_list|(
name|oifp
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|error
operator|=
name|netisr_queue
argument_list|(
name|NETISR_EPAIR
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
comment|/* 		 * IFQ_HANDOFF_ADJ/ip_handoff() update statistics, 		 * but as we bypass all this we have to duplicate 		 * the logic another time. 		 */
name|ifp
operator|->
name|if_obytes
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|mflags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
condition|)
name|ifp
operator|->
name|if_omcasts
operator|++
expr_stmt|;
comment|/* Someone else received the packet. */
name|oifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* The packet was freed already. */
name|epair_dpcpu
operator|->
name|epair_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|ifp
operator|->
name|if_oerrors
operator|++
expr_stmt|;
name|EPAIR_REFCOUNT_RELEASE
argument_list|(
operator|&
name|sc
operator|->
name|refcount
argument_list|)
expr_stmt|;
name|EPAIR_REFCOUNT_ASSERT
argument_list|(
operator|(
name|int
operator|)
name|sc
operator|->
name|refcount
operator|>=
literal|1
argument_list|,
operator|(
literal|"%s: ifp=%p sc->refcount not>= 1: %d"
operator|,
name|__func__
operator|,
name|oifp
operator|,
name|sc
operator|->
name|refcount
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|epair_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|epair_dpcpu
modifier|*
name|epair_dpcpu
decl_stmt|;
name|int
name|error
decl_stmt|;
name|epair_dpcpu
operator|=
name|DPCPU_ID_PTR
argument_list|(
name|cpuid_from_ifp
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|epair_dpcpu
argument_list|)
expr_stmt|;
name|EPAIR_LOCK
argument_list|(
name|epair_dpcpu
argument_list|)
expr_stmt|;
name|error
operator|=
name|epair_transmit_locked
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|EPAIR_UNLOCK
argument_list|(
name|epair_dpcpu
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|epair_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|epair_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: ifp=%p, epair_softc gone? sc=%p\n"
operator|,
name|__func__
operator|,
name|ifp
operator|,
name|sc
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Remove this ifp from all backpointer lists. The interface will not 	 * usable for flushing anyway nor should it have anything to flush 	 * after if_qflush(). 	 */
name|epair_remove_ifp_from_draining
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|if_qflush
condition|)
name|sc
operator|->
name|if_qflush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|epair_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ifr
operator|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
comment|/* We basically allow all kinds of MTUs. */
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* Let the common ethernet handler process this. */
name|error
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|epair_init
parameter_list|(
name|void
modifier|*
name|dummy
name|__unused
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  * Interface cloning functions.  * We use our private ones so that we can create/destroy our secondary  * device along with the primary one.  */
end_comment

begin_function
specifier|static
name|int
name|epair_clone_match
parameter_list|(
name|struct
name|if_clone
modifier|*
name|ifc
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"name='%s'\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Our base name is epair. 	 * Our interfaces will be named epair<n>[ab]. 	 * So accept anything of the following list: 	 * - epair 	 * - epair<n> 	 * but not the epair<n>[ab] versions. 	 */
if|if
condition|(
name|strncmp
argument_list|(
name|EPAIRNAME
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|EPAIRNAME
argument_list|)
operator|-
literal|1
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|cp
operator|=
name|name
operator|+
sizeof|sizeof
argument_list|(
name|EPAIRNAME
argument_list|)
operator|-
literal|1
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|<
literal|'0'
operator|||
operator|*
name|cp
operator|>
literal|'9'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|epair_clone_create
parameter_list|(
name|struct
name|if_clone
modifier|*
name|ifc
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|len
parameter_list|,
name|caddr_t
name|params
parameter_list|)
block|{
name|struct
name|epair_softc
modifier|*
name|sca
decl_stmt|,
modifier|*
name|scb
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|char
modifier|*
name|dp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|unit
decl_stmt|,
name|wildcard
decl_stmt|;
name|uint8_t
name|eaddr
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
comment|/* 00:00:00:00:00:00 */
comment|/* 	 * We are abusing params to create our second interface. 	 * Actually we already created it and called if_clone_createif() 	 * for it to do the official insertion procedure the moment we knew 	 * it cannot fail anymore. So just do attach it here. 	 */
if|if
condition|(
name|params
condition|)
block|{
name|scb
operator|=
operator|(
expr|struct
name|epair_softc
operator|*
operator|)
name|params
expr_stmt|;
name|ifp
operator|=
name|scb
operator|->
name|ifp
expr_stmt|;
comment|/* Assign a hopefully unique, locally administered etheraddr. */
name|eaddr
index|[
literal|0
index|]
operator|=
literal|0x02
expr_stmt|;
name|eaddr
index|[
literal|3
index|]
operator|=
operator|(
name|ifp
operator|->
name|if_index
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|eaddr
index|[
literal|4
index|]
operator|=
name|ifp
operator|->
name|if_index
operator|&
literal|0xff
expr_stmt|;
name|eaddr
index|[
literal|5
index|]
operator|=
literal|0x0b
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
comment|/* Correctly set the name for the cloner list. */
name|strlcpy
argument_list|(
name|name
argument_list|,
name|scb
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Try to see if a special unit was requested. */
name|error
operator|=
name|ifc_name2unit
argument_list|(
name|name
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|wildcard
operator|=
operator|(
name|unit
operator|<
literal|0
operator|)
expr_stmt|;
name|error
operator|=
name|ifc_alloc_unit
argument_list|(
name|ifc
argument_list|,
operator|&
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * If no unit had been given, we need to adjust the ifName. 	 * Also make sure there is space for our extra [ab] suffix. 	 */
for|for
control|(
name|dp
operator|=
name|name
init|;
operator|*
name|dp
operator|!=
literal|'\0'
condition|;
name|dp
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|wildcard
condition|)
block|{
name|error
operator|=
name|snprintf
argument_list|(
name|dp
argument_list|,
name|len
operator|-
operator|(
name|dp
operator|-
name|name
operator|)
argument_list|,
literal|"%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>
name|len
operator|-
operator|(
name|dp
operator|-
name|name
operator|)
operator|-
literal|1
condition|)
block|{
comment|/* ifName too long. */
name|ifc_free_unit
argument_list|(
name|ifc
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|dp
operator|+=
name|error
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|-
operator|(
name|dp
operator|-
name|name
operator|)
operator|-
literal|1
operator|<
literal|1
condition|)
block|{
comment|/* No space left for our [ab] suffix. */
name|ifc_free_unit
argument_list|(
name|ifc
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
operator|*
name|dp
operator|=
literal|'a'
expr_stmt|;
comment|/* Must not change dp so we can replace 'a' by 'b' later. */
operator|*
operator|(
name|dp
operator|+
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
comment|/* Allocate memory for both [ab] interfaces */
name|sca
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|epair_softc
argument_list|)
argument_list|,
name|M_EPAIR
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|EPAIR_REFCOUNT_INIT
argument_list|(
operator|&
name|sca
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sca
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|sca
operator|->
name|ifp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|sca
argument_list|,
name|M_EPAIR
argument_list|)
expr_stmt|;
name|ifc_free_unit
argument_list|(
name|ifc
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|scb
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|epair_softc
argument_list|)
argument_list|,
name|M_EPAIR
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|EPAIR_REFCOUNT_INIT
argument_list|(
operator|&
name|scb
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|scb
operator|->
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|scb
operator|->
name|ifp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|scb
argument_list|,
name|M_EPAIR
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|sca
operator|->
name|ifp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sca
argument_list|,
name|M_EPAIR
argument_list|)
expr_stmt|;
name|ifc_free_unit
argument_list|(
name|ifc
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
comment|/* 	 * Cross-reference the interfaces so we will be able to free both. 	 */
name|sca
operator|->
name|oifp
operator|=
name|scb
operator|->
name|ifp
expr_stmt|;
name|scb
operator|->
name|oifp
operator|=
name|sca
operator|->
name|ifp
expr_stmt|;
comment|/* 	 * Calculate the cpuid for netisr queueing based on the 	 * ifIndex of the interfaces. As long as we cannot configure 	 * this or use cpuset information easily we cannot guarantee 	 * cache locality but we can at least allow parallelism. 	 */
name|sca
operator|->
name|cpuid
operator|=
name|netisr_get_cpuid
argument_list|(
name|sca
operator|->
name|ifp
operator|->
name|if_index
operator|%
name|netisr_get_cpucount
argument_list|()
argument_list|)
expr_stmt|;
name|scb
operator|->
name|cpuid
operator|=
name|netisr_get_cpuid
argument_list|(
name|scb
operator|->
name|ifp
operator|->
name|if_index
operator|%
name|netisr_get_cpucount
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Finish initialization of interface<n>a. */
name|ifp
operator|=
name|sca
operator|->
name|ifp
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|sca
expr_stmt|;
name|strlcpy
argument_list|(
name|ifp
operator|->
name|if_xname
argument_list|,
name|name
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_dname
operator|=
name|ifc
operator|->
name|ifc_name
expr_stmt|;
name|ifp
operator|->
name|if_dunit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|epair_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|epair_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|epair_init
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|ifqmaxlen
expr_stmt|;
comment|/* Assign a hopefully unique, locally administered etheraddr. */
name|eaddr
index|[
literal|0
index|]
operator|=
literal|0x02
expr_stmt|;
name|eaddr
index|[
literal|3
index|]
operator|=
operator|(
name|ifp
operator|->
name|if_index
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|eaddr
index|[
literal|4
index|]
operator|=
name|ifp
operator|->
name|if_index
operator|&
literal|0xff
expr_stmt|;
name|eaddr
index|[
literal|5
index|]
operator|=
literal|0x0a
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|eaddr
argument_list|)
expr_stmt|;
name|sca
operator|->
name|if_qflush
operator|=
name|ifp
operator|->
name|if_qflush
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|epair_qflush
expr_stmt|;
name|ifp
operator|->
name|if_transmit
operator|=
name|epair_transmit
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
name|IF_Gbps
argument_list|(
literal|10UL
argument_list|)
expr_stmt|;
comment|/* arbitrary maximum */
comment|/* Swap the name and finish initialization of interface<n>b. */
operator|*
name|dp
operator|=
literal|'b'
expr_stmt|;
name|ifp
operator|=
name|scb
operator|->
name|ifp
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|scb
expr_stmt|;
name|strlcpy
argument_list|(
name|ifp
operator|->
name|if_xname
argument_list|,
name|name
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_dname
operator|=
name|ifc
operator|->
name|ifc_name
expr_stmt|;
name|ifp
operator|->
name|if_dunit
operator|=
name|unit
expr_stmt|;
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_start
operator|=
name|epair_start
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|epair_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|epair_init
expr_stmt|;
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|ifqmaxlen
expr_stmt|;
comment|/* We need to play some tricks here for the second interface. */
name|strlcpy
argument_list|(
name|name
argument_list|,
name|EPAIRNAME
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|error
operator|=
name|if_clone_create
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
operator|(
name|caddr_t
operator|)
name|scb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"%s: if_clone_createif() for our 2nd iface failed: %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|scb
operator|->
name|if_qflush
operator|=
name|ifp
operator|->
name|if_qflush
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|epair_qflush
expr_stmt|;
name|ifp
operator|->
name|if_transmit
operator|=
name|epair_transmit
expr_stmt|;
name|ifp
operator|->
name|if_baudrate
operator|=
name|IF_Gbps
argument_list|(
literal|10UL
argument_list|)
expr_stmt|;
comment|/* arbitrary maximum */
comment|/* 	 * Restore name to<n>a as the ifp for this will go into the 	 * cloner list for the initial call. 	 */
name|strlcpy
argument_list|(
name|name
argument_list|,
name|sca
operator|->
name|ifp
operator|->
name|if_xname
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"name='%s/%db' created sca=%p scb=%p\n"
argument_list|,
name|name
argument_list|,
name|unit
argument_list|,
name|sca
argument_list|,
name|scb
argument_list|)
expr_stmt|;
comment|/* Tell the world, that we are ready to rock. */
name|sca
operator|->
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|scb
operator|->
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|epair_clone_destroy
parameter_list|(
name|struct
name|if_clone
modifier|*
name|ifc
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|oifp
decl_stmt|;
name|struct
name|epair_softc
modifier|*
name|sca
decl_stmt|,
modifier|*
name|scb
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|error
decl_stmt|;
name|DPRINTF
argument_list|(
literal|"ifp=%p\n"
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * In case we called into if_clone_destroyif() ourselves 	 * again to remove the second interface, the softc will be 	 * NULL. In that case so not do anything but return success. 	 */
if|if
condition|(
name|ifp
operator|->
name|if_softc
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|unit
operator|=
name|ifp
operator|->
name|if_dunit
expr_stmt|;
name|sca
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|oifp
operator|=
name|sca
operator|->
name|oifp
expr_stmt|;
name|scb
operator|=
name|oifp
operator|->
name|if_softc
expr_stmt|;
name|DPRINTF
argument_list|(
literal|"ifp=%p oifp=%p\n"
argument_list|,
name|ifp
argument_list|,
name|oifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|oifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|oifp
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for all packets to be dispatched to if_input. 	 * The numbers can only go down as the interfaces are 	 * detached so there is no need to use atomics. 	 */
name|DPRINTF
argument_list|(
literal|"sca refcnt=%u scb refcnt=%u\n"
argument_list|,
name|sca
operator|->
name|refcount
argument_list|,
name|scb
operator|->
name|refcount
argument_list|)
expr_stmt|;
name|EPAIR_REFCOUNT_ASSERT
argument_list|(
name|sca
operator|->
name|refcount
operator|==
literal|1
operator|&&
name|scb
operator|->
name|refcount
operator|==
literal|1
argument_list|,
operator|(
literal|"%s: ifp=%p sca->refcount!=1: %d || ifp=%p scb->refcount!=1: %d"
operator|,
name|__func__
operator|,
name|ifp
operator|,
name|sca
operator|->
name|refcount
operator|,
name|oifp
operator|,
name|scb
operator|->
name|refcount
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Get rid of our second half. 	 */
name|oifp
operator|->
name|if_softc
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|if_clone_destroyif
argument_list|(
name|ifc
argument_list|,
name|oifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|panic
argument_list|(
literal|"%s: if_clone_destroyif() for our 2nd iface failed: %d"
argument_list|,
name|__func__
argument_list|,
name|error
argument_list|)
expr_stmt|;
comment|/* 	 * Finish cleaning up. Free them and release the unit. 	 * As the other of the two interfaces my reside in a different vnet, 	 * we need to switch before freeing them. 	 */
name|CURVNET_SET_QUIET
argument_list|(
name|oifp
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|if_free_type
argument_list|(
name|oifp
argument_list|,
name|IFT_ETHER
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
name|if_free_type
argument_list|(
name|ifp
argument_list|,
name|IFT_ETHER
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scb
argument_list|,
name|M_EPAIR
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sca
argument_list|,
name|M_EPAIR
argument_list|)
expr_stmt|;
name|ifc_free_unit
argument_list|(
name|ifc
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|epair_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|qlimit
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
comment|/* For now limit us to one global mutex and one inq. */
name|epair_dpcpu_init
argument_list|()
expr_stmt|;
name|epair_nh
operator|.
name|nh_qlimit
operator|=
literal|42
operator|*
name|ifqmaxlen
expr_stmt|;
comment|/* 42 shall be the number. */
if|if
condition|(
name|TUNABLE_INT_FETCH
argument_list|(
literal|"net.link.epair.netisr_maxqlen"
argument_list|,
operator|&
name|qlimit
argument_list|)
condition|)
name|epair_nh
operator|.
name|nh_qlimit
operator|=
name|qlimit
expr_stmt|;
name|netisr_register
argument_list|(
operator|&
name|epair_nh
argument_list|)
expr_stmt|;
name|if_clone_attach
argument_list|(
operator|&
name|epair_cloner
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s initialized.\n"
argument_list|,
name|EPAIRNAME
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|if_clone_detach
argument_list|(
operator|&
name|epair_cloner
argument_list|)
expr_stmt|;
name|netisr_unregister
argument_list|(
operator|&
name|epair_nh
argument_list|)
expr_stmt|;
name|epair_dpcpu_detach
argument_list|()
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s unloaded.\n"
argument_list|,
name|EPAIRNAME
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|epair_mod
init|=
block|{
literal|"if_epair"
block|,
name|epair_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|if_epair
argument_list|,
name|epair_mod
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|if_epair
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

