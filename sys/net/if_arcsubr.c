begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: if_arcsubr.c,v 1.36 2001/06/14 05:44:23 itojun Exp $	*/
end_comment

begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1994, 1995 Ignatios Souvatzis  * Copyright (c) 1982, 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * from: NetBSD: if_ethersubr.c,v 1.9 1994/06/29 06:36:11 cgd Exp  *       @(#)if_ethersubr.c	8.1 (Berkeley) 6/10/93  *  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arc.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llatbl.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/nd6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ARCNET_ALLOW_BROKEN_ARP
end_define

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|arc_defrag
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|arc_resolvemulti
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|u_int8_t
name|arcbroadcastaddr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ARC_LLADDR
parameter_list|(
name|ifp
parameter_list|)
value|(*(u_int8_t *)IF_LLADDR(ifp))
end_define

begin_define
define|#
directive|define
name|senderr
parameter_list|(
name|e
parameter_list|)
value|{ error = (e); goto bad;}
end_define

begin_define
define|#
directive|define
name|SIN
parameter_list|(
name|s
parameter_list|)
value|((const struct sockaddr_in *)(s))
end_define

begin_comment
comment|/*  * ARCnet output routine.  * Encapsulate a packet of type family for the local net.  * Assumes that ifp is actually pointer to arccom structure.  */
end_comment

begin_function
name|int
name|arc_output
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|route
modifier|*
name|ro
parameter_list|)
block|{
name|struct
name|arc_header
modifier|*
name|ah
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int8_t
name|atype
decl_stmt|,
name|adst
decl_stmt|;
name|int
name|loop_copy
init|=
literal|0
decl_stmt|;
name|int
name|isphds
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|llentry
modifier|*
name|lle
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|)
condition|)
return|return
operator|(
name|ENETDOWN
operator|)
return|;
comment|/* m, m1 aren't initialized yet */
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|dst
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
comment|/* 		 * For now, use the simple IP addr -> ARCnet addr mapping 		 */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
condition|)
name|adst
operator|=
name|arcbroadcastaddr
expr_stmt|;
comment|/* ARCnet broadcast address */
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_NOARP
condition|)
name|adst
operator|=
name|ntohl
argument_list|(
name|SIN
argument_list|(
name|dst
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
operator|&
literal|0xFF
expr_stmt|;
else|else
block|{
name|error
operator|=
name|arpresolve
argument_list|(
name|ifp
argument_list|,
name|ro
condition|?
name|ro
operator|->
name|ro_rt
else|:
name|NULL
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
operator|&
name|adst
argument_list|,
operator|&
name|lle
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|==
name|EWOULDBLOCK
condition|?
literal|0
else|:
name|error
operator|)
return|;
block|}
name|atype
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK0
operator|)
condition|?
name|ARCTYPE_IP_OLD
else|:
name|ARCTYPE_IP
expr_stmt|;
break|break;
case|case
name|AF_ARP
case|:
block|{
name|struct
name|arphdr
modifier|*
name|ah
decl_stmt|;
name|ah
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arphdr
operator|*
argument_list|)
expr_stmt|;
name|ah
operator|->
name|ar_hrd
operator|=
name|htons
argument_list|(
name|ARPHRD_ARCNET
argument_list|)
expr_stmt|;
name|loop_copy
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* if this is for us, don't do it */
switch|switch
condition|(
name|ntohs
argument_list|(
name|ah
operator|->
name|ar_op
argument_list|)
condition|)
block|{
case|case
name|ARPOP_REVREQUEST
case|:
case|case
name|ARPOP_REVREPLY
case|:
name|atype
operator|=
name|ARCTYPE_REVARP
expr_stmt|;
break|break;
case|case
name|ARPOP_REQUEST
case|:
case|case
name|ARPOP_REPLY
case|:
default|default:
name|atype
operator|=
name|ARCTYPE_ARP
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_BCAST
condition|)
name|bcopy
argument_list|(
name|ifp
operator|->
name|if_broadcastaddr
argument_list|,
operator|&
name|adst
argument_list|,
name|ARC_ADDR_LEN
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
name|ar_tha
argument_list|(
name|ah
argument_list|)
argument_list|,
operator|&
name|adst
argument_list|,
name|ARC_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|error
operator|=
name|nd6_storelladdr
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|adst
argument_list|,
operator|&
name|lle
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|atype
operator|=
name|ARCTYPE_INET6
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|AF_UNSPEC
case|:
block|{
specifier|const
name|struct
name|arc_header
modifier|*
name|ah
decl_stmt|;
name|loop_copy
operator|=
operator|-
literal|1
expr_stmt|;
name|ah
operator|=
operator|(
specifier|const
expr|struct
name|arc_header
operator|*
operator|)
name|dst
operator|->
name|sa_data
expr_stmt|;
name|adst
operator|=
name|ah
operator|->
name|arc_dhost
expr_stmt|;
name|atype
operator|=
name|ah
operator|->
name|arc_type
expr_stmt|;
if|if
condition|(
name|atype
operator|==
name|ARCTYPE_ARP
condition|)
block|{
name|atype
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK0
operator|)
condition|?
name|ARCTYPE_ARP_OLD
else|:
name|ARCTYPE_ARP
expr_stmt|;
ifdef|#
directive|ifdef
name|ARCNET_ALLOW_BROKEN_ARP
comment|/* 			 * XXX It's not clear per RFC826 if this is needed, but 			 * "assigned numbers" say this is wrong. 			 * However, e.g., AmiTCP 3.0Beta used it... we make this 			 * switchable for emergency cases. Not perfect, but... 			 */
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK2
condition|)
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arphdr
operator|*
argument_list|)
operator|->
name|ar_pro
operator|=
name|atype
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
block|}
default|default:
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"can't handle af%d\n"
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|EAFNOSUPPORT
argument_list|)
expr_stmt|;
block|}
name|isphds
operator|=
name|arc_isphds
argument_list|(
name|atype
argument_list|)
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|isphds
condition|?
name|ARC_HDRNEWLEN
else|:
name|ARC_HDRLEN
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
name|senderr
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
name|ah
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arc_header
operator|*
argument_list|)
expr_stmt|;
name|ah
operator|->
name|arc_type
operator|=
name|atype
expr_stmt|;
name|ah
operator|->
name|arc_dhost
operator|=
name|adst
expr_stmt|;
name|ah
operator|->
name|arc_shost
operator|=
name|ARC_LLADDR
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|isphds
condition|)
block|{
name|ah
operator|->
name|arc_flag
operator|=
literal|0
expr_stmt|;
name|ah
operator|->
name|arc_seqid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_SIMPLEX
operator|)
operator|&&
operator|(
name|loop_copy
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_BCAST
operator|)
operator|||
operator|(
name|loop_copy
operator|>
literal|0
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|n
init|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|M_COPYALL
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|if_simloop
argument_list|(
name|ifp
argument_list|,
name|n
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|,
name|ARC_HDRLEN
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ah
operator|->
name|arc_dhost
operator|==
name|ah
operator|->
name|arc_shost
condition|)
block|{
operator|(
name|void
operator|)
name|if_simloop
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|,
name|ARC_HDRLEN
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX */
block|}
block|}
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|ifp
operator|->
name|if_transmit
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|bad
label|:
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|arc_frag_init
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|arccom
modifier|*
name|ac
decl_stmt|;
name|ac
operator|=
operator|(
expr|struct
name|arccom
operator|*
operator|)
name|ifp
operator|->
name|if_l2com
expr_stmt|;
name|ac
operator|->
name|curr_frag
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|arc_frag_next
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|arccom
modifier|*
name|ac
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|arc_header
modifier|*
name|ah
decl_stmt|;
name|ac
operator|=
operator|(
expr|struct
name|arccom
operator|*
operator|)
name|ifp
operator|->
name|if_l2com
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|ac
operator|->
name|curr_frag
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|tfrags
decl_stmt|;
comment|/* dequeue new packet */
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|ah
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arc_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arc_isphds
argument_list|(
name|ah
operator|->
name|arc_type
argument_list|)
condition|)
return|return
name|m
return|;
operator|++
name|ac
operator|->
name|ac_seqid
expr_stmt|;
comment|/* make the seqid unique */
name|tfrags
operator|=
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|ARC_MAX_DATA
operator|-
literal|1
operator|)
operator|/
name|ARC_MAX_DATA
expr_stmt|;
name|ac
operator|->
name|fsflag
operator|=
literal|2
operator|*
name|tfrags
operator|-
literal|3
expr_stmt|;
name|ac
operator|->
name|sflag
operator|=
literal|0
expr_stmt|;
name|ac
operator|->
name|rsflag
operator|=
name|ac
operator|->
name|fsflag
expr_stmt|;
name|ac
operator|->
name|arc_dhost
operator|=
name|ah
operator|->
name|arc_dhost
expr_stmt|;
name|ac
operator|->
name|arc_shost
operator|=
name|ah
operator|->
name|arc_shost
expr_stmt|;
name|ac
operator|->
name|arc_type
operator|=
name|ah
operator|->
name|arc_type
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|ARC_HDRNEWLEN
argument_list|)
expr_stmt|;
name|ac
operator|->
name|curr_frag
operator|=
name|m
expr_stmt|;
block|}
comment|/* split out next fragment and return it */
if|if
condition|(
name|ac
operator|->
name|sflag
operator|<
name|ac
operator|->
name|fsflag
condition|)
block|{
comment|/* we CAN'T have short packets here */
name|ac
operator|->
name|curr_frag
operator|=
name|m_split
argument_list|(
name|m
argument_list|,
name|ARC_MAX_DATA
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|->
name|curr_frag
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|ARC_HDRNEWLEN
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|ac
operator|->
name|curr_frag
argument_list|)
expr_stmt|;
name|ac
operator|->
name|curr_frag
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ah
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arc_header
operator|*
argument_list|)
expr_stmt|;
name|ah
operator|->
name|arc_flag
operator|=
name|ac
operator|->
name|rsflag
expr_stmt|;
name|ah
operator|->
name|arc_seqid
operator|=
name|ac
operator|->
name|ac_seqid
expr_stmt|;
name|ac
operator|->
name|sflag
operator|+=
literal|2
expr_stmt|;
name|ac
operator|->
name|rsflag
operator|=
name|ac
operator|->
name|sflag
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>=
name|ARC_MIN_FORBID_LEN
operator|-
name|ARC_HDRNEWLEN
operator|+
literal|2
operator|)
operator|&&
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<=
name|ARC_MAX_FORBID_LEN
operator|-
name|ARC_HDRNEWLEN
operator|+
literal|2
operator|)
condition|)
block|{
name|ac
operator|->
name|curr_frag
operator|=
literal|0
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|ARC_HDRNEWLEN_EXC
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|ah
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arc_header
operator|*
argument_list|)
expr_stmt|;
name|ah
operator|->
name|arc_flag
operator|=
literal|0xFF
expr_stmt|;
name|ah
operator|->
name|arc_seqid
operator|=
literal|0xFFFF
expr_stmt|;
name|ah
operator|->
name|arc_type2
operator|=
name|ac
operator|->
name|arc_type
expr_stmt|;
name|ah
operator|->
name|arc_flag2
operator|=
name|ac
operator|->
name|sflag
expr_stmt|;
name|ah
operator|->
name|arc_seqid2
operator|=
name|ac
operator|->
name|ac_seqid
expr_stmt|;
block|}
else|else
block|{
name|ac
operator|->
name|curr_frag
operator|=
literal|0
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|ARC_HDRNEWLEN
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|ah
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arc_header
operator|*
argument_list|)
expr_stmt|;
name|ah
operator|->
name|arc_flag
operator|=
name|ac
operator|->
name|sflag
expr_stmt|;
name|ah
operator|->
name|arc_seqid
operator|=
name|ac
operator|->
name|ac_seqid
expr_stmt|;
block|}
name|ah
operator|->
name|arc_dhost
operator|=
name|ac
operator|->
name|arc_dhost
expr_stmt|;
name|ah
operator|->
name|arc_shost
operator|=
name|ac
operator|->
name|arc_shost
expr_stmt|;
name|ah
operator|->
name|arc_type
operator|=
name|ac
operator|->
name|arc_type
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * Defragmenter. Returns mbuf if last packet found, else  * NULL. frees imcoming mbuf as necessary.  */
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|mbuf
operator|*
name|arc_defrag
argument_list|(
argument|struct ifnet *ifp
argument_list|,
argument|struct mbuf *m
argument_list|)
block|{ 	struct
name|arc_header
operator|*
name|ah
block|,
operator|*
name|ah1
block|; 	struct
name|arccom
operator|*
name|ac
block|; 	struct
name|ac_frag
operator|*
name|af
block|; 	struct
name|mbuf
operator|*
name|m1
block|;
name|char
operator|*
name|s
block|;
name|int
name|newflen
block|;
name|u_char
name|src
block|,
name|dst
block|,
name|typ
block|;
name|ac
operator|=
operator|(
expr|struct
name|arccom
operator|*
operator|)
name|ifp
operator|->
name|if_l2com
block|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|ARC_HDRNEWLEN
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|ARC_HDRNEWLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  	ah
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arc_header
operator|*
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|typ
operator|=
name|ah
operator|->
name|arc_type
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|arc_isphds
argument_list|(
name|typ
argument_list|)
condition|)
return|return
name|m
return|;
end_if

begin_expr_stmt
name|src
operator|=
name|ah
operator|->
name|arc_shost
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|dst
operator|=
name|ah
operator|->
name|arc_dhost
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ah
operator|->
name|arc_flag
operator|==
literal|0xff
condition|)
block|{
name|m_adj
argument_list|(
name|m
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|ARC_HDRNEWLEN
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|ARC_HDRNEWLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|ah
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arc_header
operator|*
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|af
operator|=
operator|&
name|ac
operator|->
name|ac_fragtab
index|[
name|src
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|m1
operator|=
name|af
operator|->
name|af_packet
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|s
operator|=
literal|"debug code error"
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ah
operator|->
name|arc_flag
operator|&
literal|1
condition|)
block|{
comment|/* 		 * first fragment. We always initialize, which is 		 * about the right thing to do, as we only want to 		 * accept one fragmented packet per src at a time. 		 */
if|if
condition|(
name|m1
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m1
argument_list|)
expr_stmt|;
name|af
operator|->
name|af_packet
operator|=
name|m
expr_stmt|;
name|m1
operator|=
name|m
expr_stmt|;
name|af
operator|->
name|af_maxflag
operator|=
name|ah
operator|->
name|arc_flag
expr_stmt|;
name|af
operator|->
name|af_lastseen
operator|=
literal|0
expr_stmt|;
name|af
operator|->
name|af_seqid
operator|=
name|ah
operator|->
name|arc_seqid
expr_stmt|;
return|return
name|NULL
return|;
comment|/* notreached */
block|}
else|else
block|{
comment|/* check for unfragmented packet */
if|if
condition|(
name|ah
operator|->
name|arc_flag
operator|==
literal|0
condition|)
return|return
name|m
return|;
comment|/* do we have a first packet from that src? */
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
literal|"no first frag"
expr_stmt|;
goto|goto
name|outofseq
goto|;
block|}
name|ah1
operator|=
name|mtod
argument_list|(
name|m1
argument_list|,
expr|struct
name|arc_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ah
operator|->
name|arc_seqid
operator|!=
name|ah1
operator|->
name|arc_seqid
condition|)
block|{
name|s
operator|=
literal|"seqid differs"
expr_stmt|;
goto|goto
name|outofseq
goto|;
block|}
if|if
condition|(
name|typ
operator|!=
name|ah1
operator|->
name|arc_type
condition|)
block|{
name|s
operator|=
literal|"type differs"
expr_stmt|;
goto|goto
name|outofseq
goto|;
block|}
if|if
condition|(
name|dst
operator|!=
name|ah1
operator|->
name|arc_dhost
condition|)
block|{
name|s
operator|=
literal|"dest host differs"
expr_stmt|;
goto|goto
name|outofseq
goto|;
block|}
comment|/* typ, seqid and dst are ok here. */
if|if
condition|(
name|ah
operator|->
name|arc_flag
operator|==
name|af
operator|->
name|af_lastseen
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|ah
operator|->
name|arc_flag
operator|==
name|af
operator|->
name|af_lastseen
operator|+
literal|2
condition|)
block|{
comment|/* ok, this is next fragment */
name|af
operator|->
name|af_lastseen
operator|=
name|ah
operator|->
name|arc_flag
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|ARC_HDRNEWLEN
argument_list|)
expr_stmt|;
comment|/* 			 * m_cat might free the first mbuf (with pkthdr) 			 * in 2nd chain; therefore: 			 */
name|newflen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_cat
argument_list|(
name|m1
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m1
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|newflen
expr_stmt|;
comment|/* is it the last one? */
if|if
condition|(
name|af
operator|->
name|af_lastseen
operator|>
name|af
operator|->
name|af_maxflag
condition|)
block|{
name|af
operator|->
name|af_packet
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|m1
operator|)
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
name|s
operator|=
literal|"other reason"
expr_stmt|;
comment|/* if all else fails, it is out of sequence, too */
block|}
end_if

begin_label
name|outofseq
label|:
end_label

begin_if
if|if
condition|(
name|m1
condition|)
block|{
name|m_freem
argument_list|(
name|m1
argument_list|)
expr_stmt|;
name|af
operator|->
name|af_packet
operator|=
name|NULL
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: got out of seq. packet: %s\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|NULL
return|;
end_return

begin_comment
unit|}
comment|/*  * return 1 if Packet Header Definition Standard, else 0.  * For now: old IP, old ARP aren't obviously. Lacking correct information,  * we guess that besides new IP and new ARP also IPX and APPLETALK are PHDS.  * (Apple and Novell corporations were involved, among others, in PHDS work).  * Easiest is to assume that everybody else uses that, too.  */
end_comment

begin_macro
unit|int
name|arc_isphds
argument_list|(
argument|u_int8_t type
argument_list|)
end_macro

begin_block
block|{
return|return
operator|(
name|type
operator|!=
name|ARCTYPE_IP_OLD
operator|&&
name|type
operator|!=
name|ARCTYPE_ARP_OLD
operator|&&
name|type
operator|!=
name|ARCTYPE_DIAGNOSE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Process a received Arcnet packet;  * the packet is in the mbuf chain m with  * the ARCnet header.  */
end_comment

begin_function
name|void
name|arc_input
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|arc_header
modifier|*
name|ah
decl_stmt|;
name|int
name|isr
decl_stmt|;
name|u_int8_t
name|atype
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* possibly defragment: */
name|m
operator|=
name|arc_defrag
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ah
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arc_header
operator|*
argument_list|)
expr_stmt|;
comment|/* does this belong to us? */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_PROMISC
operator|)
operator|==
literal|0
operator|&&
name|ah
operator|->
name|arc_dhost
operator|!=
name|arcbroadcastaddr
operator|&&
name|ah
operator|->
name|arc_dhost
operator|!=
name|ARC_LLADDR
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IBYTES
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ah
operator|->
name|arc_dhost
operator|==
name|arcbroadcastaddr
condition|)
block|{
name|m
operator|->
name|m_flags
operator||=
name|M_BCAST
operator||
name|M_MCAST
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IMCASTS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|atype
operator|=
name|ah
operator|->
name|arc_type
expr_stmt|;
switch|switch
condition|(
name|atype
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|ARCTYPE_IP
case|:
name|m_adj
argument_list|(
name|m
argument_list|,
name|ARC_HDRNEWLEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|ip_fastforward
argument_list|(
name|m
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|isr
operator|=
name|NETISR_IP
expr_stmt|;
break|break;
case|case
name|ARCTYPE_IP_OLD
case|:
name|m_adj
argument_list|(
name|m
argument_list|,
name|ARC_HDRLEN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|ip_fastforward
argument_list|(
name|m
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|isr
operator|=
name|NETISR_IP
expr_stmt|;
break|break;
case|case
name|ARCTYPE_ARP
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_NOARP
condition|)
block|{
comment|/* Discard packet if ARP is disabled on interface */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|m_adj
argument_list|(
name|m
argument_list|,
name|ARC_HDRNEWLEN
argument_list|)
expr_stmt|;
name|isr
operator|=
name|NETISR_ARP
expr_stmt|;
ifdef|#
directive|ifdef
name|ARCNET_ALLOW_BROKEN_ARP
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arphdr
operator|*
argument_list|)
operator|->
name|ar_pro
operator|=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ARCTYPE_ARP_OLD
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_NOARP
condition|)
block|{
comment|/* Discard packet if ARP is disabled on interface */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|m_adj
argument_list|(
name|m
argument_list|,
name|ARC_HDRLEN
argument_list|)
expr_stmt|;
name|isr
operator|=
name|NETISR_ARP
expr_stmt|;
ifdef|#
directive|ifdef
name|ARCNET_ALLOW_BROKEN_ARP
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arphdr
operator|*
argument_list|)
operator|->
name|ar_pro
operator|=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|ARCTYPE_INET6
case|:
name|m_adj
argument_list|(
name|m
argument_list|,
name|ARC_HDRNEWLEN
argument_list|)
expr_stmt|;
name|isr
operator|=
name|NETISR_IPV6
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|M_SETFIB
argument_list|(
name|m
argument_list|,
name|ifp
operator|->
name|if_fib
argument_list|)
expr_stmt|;
name|netisr_dispatch
argument_list|(
name|isr
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Register (new) link level address.  */
end_comment

begin_function
name|void
name|arc_storelladdr
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int8_t
name|lla
parameter_list|)
block|{
name|ARC_LLADDR
argument_list|(
name|ifp
argument_list|)
operator|=
name|lla
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform common duties while attaching to interface list  */
end_comment

begin_function
name|void
name|arc_ifattach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_int8_t
name|lla
parameter_list|)
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|struct
name|arccom
modifier|*
name|ac
decl_stmt|;
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_addrlen
operator|=
literal|1
expr_stmt|;
name|ifp
operator|->
name|if_hdrlen
operator|=
name|ARC_HDRLEN
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
literal|1500
expr_stmt|;
name|ifp
operator|->
name|if_resolvemulti
operator|=
name|arc_resolvemulti
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_baudrate
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_baudrate
operator|=
literal|2500000
expr_stmt|;
name|ifa
operator|=
name|ifp
operator|->
name|if_addr
expr_stmt|;
name|KASSERT
argument_list|(
name|ifa
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no lladdr!\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|sdl
operator|->
name|sdl_type
operator|=
name|IFT_ARCNET
expr_stmt|;
name|sdl
operator|->
name|sdl_alen
operator|=
name|ifp
operator|->
name|if_addrlen
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_BROADCAST
condition|)
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_MULTICAST
operator||
name|IFF_ALLMULTI
expr_stmt|;
name|ac
operator|=
operator|(
expr|struct
name|arccom
operator|*
operator|)
name|ifp
operator|->
name|if_l2com
expr_stmt|;
name|ac
operator|->
name|ac_seqid
operator|=
operator|(
name|time_second
operator|)
operator|&
literal|0xFFFF
expr_stmt|;
comment|/* try to make seqid unique */
if|if
condition|(
name|lla
operator|==
literal|0
condition|)
block|{
comment|/* XXX this message isn't entirely clear, to me -- cgd */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: link address 0 reserved for broadcasts.  Please change it and ifconfig %s down up\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
name|arc_storelladdr
argument_list|(
name|ifp
argument_list|,
name|lla
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_broadcastaddr
operator|=
operator|&
name|arcbroadcastaddr
expr_stmt|;
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_ARCNET
argument_list|,
name|ARC_HDRLEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arc_ifdetach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|bpfdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_detach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|arc_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|ifp
operator|->
name|if_init
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|)
expr_stmt|;
comment|/* before arpwhohas */
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|ifp
operator|->
name|if_init
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIOCGIFADDR
case|:
block|{
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ifr
operator|->
name|ifr_data
expr_stmt|;
operator|*
operator|(
name|u_int8_t
operator|*
operator|)
name|sa
operator|->
name|sa_data
operator|=
name|ARC_LLADDR
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
if|if
condition|(
name|ifr
operator|==
name|NULL
condition|)
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|ifr
operator|->
name|ifr_addr
operator|.
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
case|case
name|AF_INET6
case|:
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|SIOCSIFMTU
case|:
comment|/* 		 * Set the interface MTU. 		 * mtu can't be larger than ARCMTU for RFC1051 		 * and can't be larger than ARC_PHDS_MTU 		 */
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK0
operator|)
operator|&&
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ARCMTU
operator|)
operator|||
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ARC_PHDS_MAXMTU
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* based on ether_resolvemulti() */
end_comment

begin_function
name|int
name|arc_resolvemulti
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|llsa
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_LINK
case|:
comment|/* 		* No mapping needed. Just check that it's a valid MC address. 		*/
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
operator|*
name|LLADDR
argument_list|(
name|sdl
argument_list|)
operator|!=
name|arcbroadcastaddr
condition|)
return|return
name|EADDRNOTAVAIL
return|;
operator|*
name|llsa
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
operator|!
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
return|return
name|EADDRNOTAVAIL
return|;
name|sdl
operator|=
name|link_init_sdl
argument_list|(
name|ifp
argument_list|,
operator|*
name|llsa
argument_list|,
name|IFT_ETHER
argument_list|)
expr_stmt|;
name|sdl
operator|->
name|sdl_alen
operator|=
name|ARC_ADDR_LEN
expr_stmt|;
operator|*
name|LLADDR
argument_list|(
name|sdl
argument_list|)
operator|=
literal|0
expr_stmt|;
operator|*
name|llsa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sdl
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* 			 * An IP6 address of 0 means listen to all 			 * of the Ethernet multicast address used for IP6. 			 * (This is used for multicast routers.) 			 */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_ALLMULTI
expr_stmt|;
operator|*
name|llsa
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
return|return
name|EADDRNOTAVAIL
return|;
name|sdl
operator|=
name|link_init_sdl
argument_list|(
name|ifp
argument_list|,
operator|*
name|llsa
argument_list|,
name|IFT_ETHER
argument_list|)
expr_stmt|;
name|sdl
operator|->
name|sdl_alen
operator|=
name|ARC_ADDR_LEN
expr_stmt|;
operator|*
name|LLADDR
argument_list|(
name|sdl
argument_list|)
operator|=
literal|0
expr_stmt|;
operator|*
name|llsa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sdl
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
default|default:
comment|/* 		 * Well, the text isn't quite right, but it's the name 		 * that counts... 		 */
return|return
name|EAFNOSUPPORT
return|;
block|}
block|}
end_function

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_ARCCOM
argument_list|,
literal|"arccom"
argument_list|,
literal|"ARCNET interface internals"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
modifier|*
name|arc_alloc
parameter_list|(
name|u_char
name|type
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|arccom
modifier|*
name|ac
decl_stmt|;
name|ac
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|arccom
argument_list|)
argument_list|,
name|M_ARCCOM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ac
operator|->
name|ac_ifp
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|ac
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arc_free
parameter_list|(
name|void
modifier|*
name|com
parameter_list|,
name|u_char
name|type
parameter_list|)
block|{
name|free
argument_list|(
name|com
argument_list|,
name|M_ARCCOM
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|arc_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|if_register_com_alloc
argument_list|(
name|IFT_ARCNET
argument_list|,
name|arc_alloc
argument_list|,
name|arc_free
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|if_deregister_com_alloc
argument_list|(
name|IFT_ARCNET
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|EOPNOTSUPP
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|arc_mod
init|=
block|{
literal|"arcnet"
block|,
name|arc_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|arcnet
argument_list|,
name|arc_mod
argument_list|,
name|SI_SUB_INIT_IF
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|arcnet
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

