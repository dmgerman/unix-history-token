begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: if_arcsubr.c,v 1.36 2001/06/14 05:44:23 itojun Exp $	*/
end_comment

begin_comment
comment|/*	$FreeBSD$ */
end_comment

begin_comment
comment|/*  * Copyright (c) 1994, 1995 Ignatios Souvatzis  * Copyright (c) 1982, 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * from: NetBSD: if_ethersubr.c,v 1.9 1994/06/29 06:36:11 cgd Exp  *       @(#)if_ethersubr.c	8.1 (Berkeley) 6/10/93  *  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arc.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/nd6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|arcnet
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|ARCNET_ALLOW_BROKEN_ARP
end_define

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|arc_defrag
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|senderr
parameter_list|(
name|e
parameter_list|)
value|{ error = (e); goto bad;}
end_define

begin_define
define|#
directive|define
name|SIN
parameter_list|(
name|s
parameter_list|)
value|((struct sockaddr_in *)s)
end_define

begin_comment
comment|/*  * ARCnet output routine.  * Encapsulate a packet of type family for the local net.  * Assumes that ifp is actually pointer to arccom structure.  */
end_comment

begin_function
name|int
name|arc_output
parameter_list|(
name|ifp
parameter_list|,
name|m
parameter_list|,
name|dst
parameter_list|,
name|rt0
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt0
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|mcopy
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|arccom
modifier|*
name|ac
decl_stmt|;
name|struct
name|arc_header
modifier|*
name|ah
decl_stmt|;
name|struct
name|arphdr
modifier|*
name|arph
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int8_t
name|atype
decl_stmt|,
name|adst
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|int
name|s
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
operator|)
operator|!=
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
condition|)
return|return
operator|(
name|ENETDOWN
operator|)
return|;
comment|/* m, m1 aren't initialized yet */
name|error
operator|=
literal|0
expr_stmt|;
name|ac
operator|=
operator|(
expr|struct
name|arccom
operator|*
operator|)
name|ifp
expr_stmt|;
name|mcopy
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|rt
operator|=
name|rt0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rt0
operator|=
name|rt
operator|=
name|rtalloc1
argument_list|(
name|dst
argument_list|,
literal|1
argument_list|,
literal|0UL
argument_list|)
operator|)
condition|)
name|rt
operator|->
name|rt_refcnt
operator|--
expr_stmt|;
else|else
name|senderr
argument_list|(
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_gwroute
operator|==
literal|0
condition|)
goto|goto
name|lookup
goto|;
if|if
condition|(
operator|(
operator|(
name|rt
operator|=
name|rt
operator|->
name|rt_gwroute
operator|)
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|rtfree
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|rt
operator|=
name|rt0
expr_stmt|;
name|lookup
label|:
name|rt
operator|->
name|rt_gwroute
operator|=
name|rtalloc1
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|,
literal|1
argument_list|,
literal|0UL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rt
operator|=
name|rt
operator|->
name|rt_gwroute
operator|)
operator|==
literal|0
condition|)
name|senderr
argument_list|(
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_REJECT
condition|)
if|if
condition|(
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_expire
operator|==
literal|0
operator|||
name|time_second
operator|<
name|rt
operator|->
name|rt_rmx
operator|.
name|rmx_expire
condition|)
name|senderr
argument_list|(
name|rt
operator|==
name|rt0
condition|?
name|EHOSTDOWN
else|:
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|dst
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
comment|/* 		 * For now, use the simple IP addr -> ARCnet addr mapping 		 */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
condition|)
name|adst
operator|=
name|arcbroadcastaddr
expr_stmt|;
comment|/* ARCnet broadcast address */
elseif|else
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_NOARP
condition|)
name|adst
operator|=
name|ntohl
argument_list|(
name|SIN
argument_list|(
name|dst
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
operator|&
literal|0xFF
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|arpresolve
argument_list|(
name|ifp
argument_list|,
name|rt
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
operator|&
name|adst
argument_list|,
name|rt0
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* not resolved yet */
comment|/* If broadcasting on a simplex interface, loopback a copy */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_SIMPLEX
operator|)
condition|)
name|mcopy
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|M_COPYALL
argument_list|)
expr_stmt|;
name|atype
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK0
operator|)
condition|?
name|ARCTYPE_IP_OLD
else|:
name|ARCTYPE_IP
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
ifdef|#
directive|ifdef
name|OLDIP6OUTPUT
if|if
condition|(
operator|!
name|nd6_resolve
argument_list|(
name|ifp
argument_list|,
name|rt
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|adst
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* if not yet resolves */
else|#
directive|else
if|if
condition|(
operator|!
name|nd6_storelladdr
argument_list|(
name|ifp
argument_list|,
name|rt
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|adst
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* it must be impossible, but... */
endif|#
directive|endif
comment|/* OLDIP6OUTPUT */
name|atype
operator|=
name|ARCTYPE_INET6
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|AF_UNSPEC
case|:
name|ah
operator|=
operator|(
expr|struct
name|arc_header
operator|*
operator|)
name|dst
operator|->
name|sa_data
expr_stmt|;
name|adst
operator|=
name|ah
operator|->
name|arc_dhost
expr_stmt|;
name|atype
operator|=
name|ah
operator|->
name|arc_type
expr_stmt|;
if|if
condition|(
name|atype
operator|==
name|ARCTYPE_ARP
condition|)
block|{
name|atype
operator|=
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK0
operator|)
condition|?
name|ARCTYPE_ARP_OLD
else|:
name|ARCTYPE_ARP
expr_stmt|;
ifdef|#
directive|ifdef
name|ARCNET_ALLOW_BROKEN_ARP
comment|/* 			 * XXX It's not clear per RFC826 if this is needed, but 			 * "assigned numbers" say this is wrong. 			 * However, e.g., AmiTCP 3.0Beta used it... we make this 			 * switchable for emergency cases. Not perfect, but... 			 */
name|arph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arphdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK2
condition|)
name|arph
operator|->
name|ar_pro
operator|=
name|atype
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"%s%d: can't handle af%d\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|EAFNOSUPPORT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mcopy
condition|)
operator|(
name|void
operator|)
name|if_simloop
argument_list|(
name|ifp
argument_list|,
name|mcopy
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|ARC_HDRLEN
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
name|senderr
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
name|ah
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arc_header
operator|*
argument_list|)
expr_stmt|;
name|ah
operator|->
name|arc_type
operator|=
name|atype
expr_stmt|;
name|ah
operator|->
name|arc_dhost
operator|=
name|adst
expr_stmt|;
name|ah
operator|->
name|arc_shost
operator|=
operator|*
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* 	 * Queue message on interface, and start output if interface 	 * not yet active. 	 */
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
name|ifp
operator|->
name|if_obytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|IF_ENQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_OACTIVE
operator|)
operator|==
literal|0
condition|)
call|(
modifier|*
name|ifp
operator|->
name|if_start
call|)
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|!
name|IF_HANDOFF
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|,
name|ifp
argument_list|)
condition|)
block|{
name|m
operator|=
literal|0
expr_stmt|;
name|senderr
argument_list|(
name|ENOBUFS
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
name|bad
label|:
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|arc_frag_init
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|arccom
modifier|*
name|ac
decl_stmt|;
name|ac
operator|=
operator|(
expr|struct
name|arccom
operator|*
operator|)
name|ifp
expr_stmt|;
name|ac
operator|->
name|curr_frag
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|arc_frag_next
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|arccom
modifier|*
name|ac
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|arc_header
modifier|*
name|ah
decl_stmt|;
name|ac
operator|=
operator|(
expr|struct
name|arccom
operator|*
operator|)
name|ifp
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|ac
operator|->
name|curr_frag
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|tfrags
decl_stmt|;
comment|/* dequeue new packet */
name|IF_DEQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|ah
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arc_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arc_isphds
argument_list|(
name|ah
operator|->
name|arc_type
argument_list|)
condition|)
return|return
name|m
return|;
operator|++
name|ac
operator|->
name|ac_seqid
expr_stmt|;
comment|/* make the seqid unique */
name|tfrags
operator|=
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
literal|503
operator|)
operator|/
literal|504
expr_stmt|;
name|ac
operator|->
name|fsflag
operator|=
literal|2
operator|*
name|tfrags
operator|-
literal|3
expr_stmt|;
name|ac
operator|->
name|sflag
operator|=
literal|0
expr_stmt|;
name|ac
operator|->
name|rsflag
operator|=
name|ac
operator|->
name|fsflag
expr_stmt|;
name|ac
operator|->
name|arc_dhost
operator|=
name|ah
operator|->
name|arc_dhost
expr_stmt|;
name|ac
operator|->
name|arc_shost
operator|=
name|ah
operator|->
name|arc_shost
expr_stmt|;
name|ac
operator|->
name|arc_type
operator|=
name|ah
operator|->
name|arc_type
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|ARC_HDRLEN
argument_list|)
expr_stmt|;
name|ac
operator|->
name|curr_frag
operator|=
name|m
expr_stmt|;
block|}
comment|/* split out next fragment and return it */
if|if
condition|(
name|ac
operator|->
name|sflag
operator|<
name|ac
operator|->
name|fsflag
condition|)
block|{
comment|/* we CAN'T have short packets here */
name|ac
operator|->
name|curr_frag
operator|=
name|m_split
argument_list|(
name|m
argument_list|,
literal|504
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ac
operator|->
name|curr_frag
operator|==
literal|0
condition|)
block|{
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|ARC_HDRNEWLEN
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m_free
argument_list|(
name|ac
operator|->
name|curr_frag
argument_list|)
expr_stmt|;
name|ac
operator|->
name|curr_frag
operator|=
literal|0
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ah
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arc_header
operator|*
argument_list|)
expr_stmt|;
name|ah
operator|->
name|arc_flag
operator|=
name|ac
operator|->
name|rsflag
expr_stmt|;
name|ah
operator|->
name|arc_seqid
operator|=
name|ac
operator|->
name|ac_seqid
expr_stmt|;
name|ac
operator|->
name|sflag
operator|+=
literal|2
expr_stmt|;
name|ac
operator|->
name|rsflag
operator|=
name|ac
operator|->
name|sflag
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>=
name|ARC_MIN_FORBID_LEN
operator|-
name|ARC_HDRNEWLEN
operator|+
literal|2
operator|)
operator|&&
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<=
name|ARC_MAX_FORBID_LEN
operator|-
name|ARC_HDRNEWLEN
operator|+
literal|2
operator|)
condition|)
block|{
name|ac
operator|->
name|curr_frag
operator|=
literal|0
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|ARC_HDRNEWLEN_EXC
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|ah
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arc_header
operator|*
argument_list|)
expr_stmt|;
name|ah
operator|->
name|arc_flag
operator|=
literal|0xFF
expr_stmt|;
name|ah
operator|->
name|arc_seqid
operator|=
literal|0xFFFF
expr_stmt|;
name|ah
operator|->
name|arc_type2
operator|=
name|ac
operator|->
name|arc_type
expr_stmt|;
name|ah
operator|->
name|arc_flag2
operator|=
name|ac
operator|->
name|sflag
expr_stmt|;
name|ah
operator|->
name|arc_seqid2
operator|=
name|ac
operator|->
name|ac_seqid
expr_stmt|;
block|}
else|else
block|{
name|ac
operator|->
name|curr_frag
operator|=
literal|0
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|ARC_HDRNEWLEN
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|ah
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arc_header
operator|*
argument_list|)
expr_stmt|;
name|ah
operator|->
name|arc_flag
operator|=
name|ac
operator|->
name|sflag
expr_stmt|;
name|ah
operator|->
name|arc_seqid
operator|=
name|ac
operator|->
name|ac_seqid
expr_stmt|;
block|}
name|ah
operator|->
name|arc_dhost
operator|=
name|ac
operator|->
name|arc_dhost
expr_stmt|;
name|ah
operator|->
name|arc_shost
operator|=
name|ac
operator|->
name|arc_shost
expr_stmt|;
name|ah
operator|->
name|arc_type
operator|=
name|ac
operator|->
name|arc_type
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * Defragmenter. Returns mbuf if last packet found, else  * NULL. frees imcoming mbuf as necessary.  */
end_comment

begin_function
name|__inline
name|struct
name|mbuf
modifier|*
name|arc_defrag
parameter_list|(
name|ifp
parameter_list|,
name|m
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|arc_header
modifier|*
name|ah
decl_stmt|,
modifier|*
name|ah1
decl_stmt|;
name|struct
name|arccom
modifier|*
name|ac
decl_stmt|;
name|struct
name|ac_frag
modifier|*
name|af
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m1
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|newflen
decl_stmt|;
name|u_char
name|src
decl_stmt|,
name|dst
decl_stmt|,
name|typ
decl_stmt|;
name|ac
operator|=
operator|(
expr|struct
name|arccom
operator|*
operator|)
name|ifp
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|ARC_HDRNEWLEN
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|ARC_HDRNEWLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|++
name|ifp
operator|->
name|if_ierrors
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|ah
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arc_header
operator|*
argument_list|)
expr_stmt|;
name|typ
operator|=
name|ah
operator|->
name|arc_type
expr_stmt|;
if|if
condition|(
operator|!
name|arc_isphds
argument_list|(
name|typ
argument_list|)
condition|)
return|return
name|m
return|;
name|src
operator|=
name|ah
operator|->
name|arc_shost
expr_stmt|;
name|dst
operator|=
name|ah
operator|->
name|arc_dhost
expr_stmt|;
if|if
condition|(
name|ah
operator|->
name|arc_flag
operator|==
literal|0xff
condition|)
block|{
name|m_adj
argument_list|(
name|m
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|ARC_HDRNEWLEN
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|ARC_HDRNEWLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
operator|++
name|ifp
operator|->
name|if_ierrors
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
name|ah
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arc_header
operator|*
argument_list|)
expr_stmt|;
block|}
name|af
operator|=
operator|&
name|ac
operator|->
name|ac_fragtab
index|[
name|src
index|]
expr_stmt|;
name|m1
operator|=
name|af
operator|->
name|af_packet
expr_stmt|;
name|s
operator|=
literal|"debug code error"
expr_stmt|;
if|if
condition|(
name|ah
operator|->
name|arc_flag
operator|&
literal|1
condition|)
block|{
comment|/* 		 * first fragment. We always initialize, which is 		 * about the right thing to do, as we only want to 		 * accept one fragmented packet per src at a time. 		 */
if|if
condition|(
name|m1
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m1
argument_list|)
expr_stmt|;
name|af
operator|->
name|af_packet
operator|=
name|m
expr_stmt|;
name|m1
operator|=
name|m
expr_stmt|;
name|af
operator|->
name|af_maxflag
operator|=
name|ah
operator|->
name|arc_flag
expr_stmt|;
name|af
operator|->
name|af_lastseen
operator|=
literal|0
expr_stmt|;
name|af
operator|->
name|af_seqid
operator|=
name|ah
operator|->
name|arc_seqid
expr_stmt|;
return|return
name|NULL
return|;
comment|/* notreached */
block|}
else|else
block|{
comment|/* check for unfragmented packet */
if|if
condition|(
name|ah
operator|->
name|arc_flag
operator|==
literal|0
condition|)
return|return
name|m
return|;
comment|/* do we have a first packet from that src? */
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
literal|"no first frag"
expr_stmt|;
goto|goto
name|outofseq
goto|;
block|}
name|ah1
operator|=
name|mtod
argument_list|(
name|m1
argument_list|,
expr|struct
name|arc_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ah
operator|->
name|arc_seqid
operator|!=
name|ah1
operator|->
name|arc_seqid
condition|)
block|{
name|s
operator|=
literal|"seqid differs"
expr_stmt|;
goto|goto
name|outofseq
goto|;
block|}
if|if
condition|(
name|typ
operator|!=
name|ah1
operator|->
name|arc_type
condition|)
block|{
name|s
operator|=
literal|"type differs"
expr_stmt|;
goto|goto
name|outofseq
goto|;
block|}
if|if
condition|(
name|dst
operator|!=
name|ah1
operator|->
name|arc_dhost
condition|)
block|{
name|s
operator|=
literal|"dest host differs"
expr_stmt|;
goto|goto
name|outofseq
goto|;
block|}
comment|/* typ, seqid and dst are ok here. */
if|if
condition|(
name|ah
operator|->
name|arc_flag
operator|==
name|af
operator|->
name|af_lastseen
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|ah
operator|->
name|arc_flag
operator|==
name|af
operator|->
name|af_lastseen
operator|+
literal|2
condition|)
block|{
comment|/* ok, this is next fragment */
name|af
operator|->
name|af_lastseen
operator|=
name|ah
operator|->
name|arc_flag
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|ARC_HDRNEWLEN
argument_list|)
expr_stmt|;
comment|/* 			 * m_cat might free the first mbuf (with pkthdr) 			 * in 2nd chain; therefore: 			 */
name|newflen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_cat
argument_list|(
name|m1
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m1
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|newflen
expr_stmt|;
comment|/* is it the last one? */
if|if
condition|(
name|af
operator|->
name|af_lastseen
operator|>
name|af
operator|->
name|af_maxflag
condition|)
block|{
name|af
operator|->
name|af_packet
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|m1
operator|)
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
name|s
operator|=
literal|"other reason"
expr_stmt|;
comment|/* if all else fails, it is out of sequence, too */
block|}
name|outofseq
label|:
if|if
condition|(
name|m1
condition|)
block|{
name|m_freem
argument_list|(
name|m1
argument_list|)
expr_stmt|;
name|af
operator|->
name|af_packet
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s%d: got out of seq. packet: %s\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * return 1 if Packet Header Definition Standard, else 0.  * For now: old IP, old ARP aren't obviously. Lacking correct information,  * we guess that besides new IP and new ARP also IPX and APPLETALK are PHDS.  * (Apple and Novell corporations were involved, among others, in PHDS work).  * Easiest is to assume that everybody else uses that, too.  */
end_comment

begin_function
name|int
name|arc_isphds
parameter_list|(
name|type
parameter_list|)
name|u_int8_t
name|type
decl_stmt|;
block|{
return|return
operator|(
name|type
operator|!=
name|ARCTYPE_IP_OLD
operator|&&
name|type
operator|!=
name|ARCTYPE_ARP_OLD
operator|&&
name|type
operator|!=
name|ARCTYPE_DIAGNOSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a received Arcnet packet;  * the packet is in the mbuf chain m with  * the ARCnet header.  */
end_comment

begin_function
name|void
name|arc_input
parameter_list|(
name|ifp
parameter_list|,
name|m
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|arc_header
modifier|*
name|ah
decl_stmt|;
name|struct
name|ifqueue
modifier|*
name|inq
decl_stmt|;
name|u_int8_t
name|atype
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|arphdr
modifier|*
name|arph
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|int
name|s
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* possibly defragment: */
name|m
operator|=
name|arc_defrag
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ah
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arc_header
operator|*
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ibytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|arcbroadcastaddr
operator|==
name|ah
operator|->
name|arc_dhost
condition|)
block|{
name|m
operator|->
name|m_flags
operator||=
name|M_BCAST
operator||
name|M_MCAST
expr_stmt|;
name|ifp
operator|->
name|if_imcasts
operator|++
expr_stmt|;
block|}
name|atype
operator|=
name|ah
operator|->
name|arc_type
expr_stmt|;
switch|switch
condition|(
name|atype
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|ARCTYPE_IP
case|:
name|m_adj
argument_list|(
name|m
argument_list|,
name|ARC_HDRNEWLEN
argument_list|)
expr_stmt|;
name|schednetisr
argument_list|(
name|NETISR_IP
argument_list|)
expr_stmt|;
name|inq
operator|=
operator|&
name|ipintrq
expr_stmt|;
break|break;
case|case
name|ARCTYPE_IP_OLD
case|:
name|m_adj
argument_list|(
name|m
argument_list|,
name|ARC_HDRLEN
argument_list|)
expr_stmt|;
name|schednetisr
argument_list|(
name|NETISR_IP
argument_list|)
expr_stmt|;
name|inq
operator|=
operator|&
name|ipintrq
expr_stmt|;
break|break;
case|case
name|ARCTYPE_ARP
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_NOARP
condition|)
block|{
comment|/* Discard packet if ARP is disabled on interface */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|m_adj
argument_list|(
name|m
argument_list|,
name|ARC_HDRNEWLEN
argument_list|)
expr_stmt|;
name|schednetisr
argument_list|(
name|NETISR_ARP
argument_list|)
expr_stmt|;
name|inq
operator|=
operator|&
name|arpintrq
expr_stmt|;
ifdef|#
directive|ifdef
name|ARCNET_ALLOW_BROKEN_ARP
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arphdr
operator|*
argument_list|)
operator|->
name|ar_pro
operator|=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|ARCTYPE_ARP_OLD
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_NOARP
condition|)
block|{
comment|/* Discard packet if ARP is disabled on interface */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|m_adj
argument_list|(
name|m
argument_list|,
name|ARC_HDRLEN
argument_list|)
expr_stmt|;
name|schednetisr
argument_list|(
name|NETISR_ARP
argument_list|)
expr_stmt|;
name|inq
operator|=
operator|&
name|arpintrq
expr_stmt|;
name|arph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arphdr
operator|*
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ARCNET_ALLOW_BROKEN_ARP
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arphdr
operator|*
argument_list|)
operator|->
name|ar_pro
operator|=
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|ARCTYPE_INET6
case|:
name|m_adj
argument_list|(
name|m
argument_list|,
name|ARC_HDRNEWLEN
argument_list|)
expr_stmt|;
name|schednetisr
argument_list|(
name|NETISR_IPV6
argument_list|)
expr_stmt|;
name|inq
operator|=
operator|&
name|ip6intrq
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
name|inq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
name|inq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
name|IF_ENQUEUE
argument_list|(
name|inq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|IF_HANDOFF
argument_list|(
name|inq
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Convert Arcnet address to printable (loggable) representation.  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|digits
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|arc_sprintf
parameter_list|(
name|ap
parameter_list|)
name|u_int8_t
modifier|*
name|ap
decl_stmt|;
block|{
specifier|static
name|char
name|arcbuf
index|[
literal|3
index|]
decl_stmt|;
name|char
modifier|*
name|cp
init|=
name|arcbuf
decl_stmt|;
operator|*
name|cp
operator|++
operator|=
name|digits
index|[
operator|*
name|ap
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|digits
index|[
operator|*
name|ap
operator|++
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|arcbuf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Register (new) link level address.  */
end_comment

begin_function
name|void
name|arc_storelladdr
parameter_list|(
name|ifp
parameter_list|,
name|lla
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int8_t
name|lla
decl_stmt|;
block|{
operator|*
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
operator|=
name|lla
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform common duties while attaching to interface list  */
end_comment

begin_function
name|void
name|arc_ifattach
parameter_list|(
name|ifp
parameter_list|,
name|lla
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_int8_t
name|lla
decl_stmt|;
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
name|struct
name|arccom
modifier|*
name|ac
decl_stmt|;
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_type
operator|=
name|IFT_ARCNET
expr_stmt|;
name|ifp
operator|->
name|if_addrlen
operator|=
literal|1
expr_stmt|;
name|ifp
operator|->
name|if_hdrlen
operator|=
name|ARC_HDRLEN
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
literal|1500
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_baudrate
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_baudrate
operator|=
literal|2500000
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|500000
name|ifa
operator|=
name|ifnet_addrs
index|[
name|ifp
operator|->
name|if_index
operator|-
literal|1
index|]
expr_stmt|;
else|#
directive|else
name|ifa
operator|=
name|ifaddr_byindex
argument_list|(
name|ifp
operator|->
name|if_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|ifa
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no lladdr!\n"
operator|,
name|__FUNCTION__
operator|)
argument_list|)
expr_stmt|;
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|sdl
operator|->
name|sdl_type
operator|=
name|IFT_ARCNET
expr_stmt|;
name|sdl
operator|->
name|sdl_alen
operator|=
name|ifp
operator|->
name|if_addrlen
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_BROADCAST
condition|)
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_MULTICAST
operator||
name|IFF_ALLMULTI
expr_stmt|;
name|ac
operator|=
operator|(
expr|struct
name|arccom
operator|*
operator|)
name|ifp
expr_stmt|;
name|ac
operator|->
name|ac_seqid
operator|=
operator|(
name|time_second
operator|)
operator|&
literal|0xFFFF
expr_stmt|;
comment|/* try to make seqid unique */
if|if
condition|(
name|lla
operator|==
literal|0
condition|)
block|{
comment|/* XXX this message isn't entirely clear, to me -- cgd */
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s%d: link address 0 reserved for broadcasts.  Please change it and ifconfig %s%d down up\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
name|arc_storelladdr
argument_list|(
name|ifp
argument_list|,
name|lla
argument_list|)
expr_stmt|;
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_ARCNET
argument_list|,
name|ARC_HDRLEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|arc_ifdetach
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|bpfdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_detach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|arc_ioctl
parameter_list|(
name|ifp
parameter_list|,
name|command
parameter_list|,
name|data
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|command
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|ifp
operator|->
name|if_init
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|)
expr_stmt|;
comment|/* before arpwhohas */
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|ifp
operator|->
name|if_init
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
if|if
condition|(
name|ifr
operator|==
name|NULL
condition|)
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|ifr
operator|->
name|ifr_addr
operator|.
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
case|case
name|AF_INET6
case|:
name|error
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|SIOCSIFMTU
case|:
comment|/* 		 * Set the interface MTU. 		 * mtu can't be larger than ARCMTU for RFC1051 		 * and can't be larger than ARC_PHDS_MTU 		 */
if|if
condition|(
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LINK0
operator|)
operator|&&
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ARCMTU
operator|)
operator|||
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ARC_PHDS_MAXMTU
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
break|break;
if|#
directive|if
literal|0
block|case SIOCGIFADDR: 		{ 			struct sockaddr *sa;  			sa = (struct sockaddr *)& ifr->ifr_data; 			bcopy(IFP2AC(ifp)->ac_enaddr, 			      (caddr_t) sa->sa_data, ETHER_ADDR_LEN); 		} 		break;
endif|#
directive|endif
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

