begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004 Doug Rabson  * Copyright (c) 1982, 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_mac.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mac.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/firewire.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/nd6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_FWCOM
argument_list|,
literal|"fw_com"
argument_list|,
literal|"firewire interface internals"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|fw_hwaddr
name|firewire_broadcastaddr
init|=
block|{
literal|0xffffffff
block|,
literal|0xffffffff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xffff
block|,
literal|0xffffffff
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|firewire_output
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt0
parameter_list|)
block|{
name|struct
name|fw_com
modifier|*
name|fc
init|=
name|IFP2FWC
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|,
name|type
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
init|=
name|NULL
decl_stmt|;
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|union
name|fw_encap
modifier|*
name|enc
decl_stmt|;
name|struct
name|fw_hwaddr
modifier|*
name|destfw
decl_stmt|;
name|uint8_t
name|speed
decl_stmt|;
name|uint16_t
name|psize
decl_stmt|,
name|fsize
decl_stmt|,
name|dsize
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mtail
decl_stmt|;
name|int
name|unicast
decl_stmt|,
name|dgl
decl_stmt|,
name|foff
decl_stmt|;
specifier|static
name|int
name|next_dgl
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_ifnet_transmit
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|ENETDOWN
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|rt0
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|rt_check
argument_list|(
operator|&
name|rt
argument_list|,
operator|&
name|rt0
argument_list|,
name|dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|RT_UNLOCK
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * For unicast, we make a tag to store the lladdr of the 	 * destination. This might not be the first time we have seen 	 * the packet (for instance, the arp code might be trying to 	 * re-send it after receiving an arp reply) so we only 	 * allocate a tag if there isn't one there already. For 	 * multicast, we will eventually use a different tag to store 	 * the channel number. 	 */
name|unicast
operator|=
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|unicast
condition|)
block|{
name|mtag
operator|=
name|m_tag_locate
argument_list|(
name|m
argument_list|,
name|MTAG_FIREWIRE
argument_list|,
name|MTAG_FIREWIRE_HWADDR
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mtag
condition|)
block|{
name|mtag
operator|=
name|m_tag_alloc
argument_list|(
name|MTAG_FIREWIRE
argument_list|,
name|MTAG_FIREWIRE_HWADDR
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fw_hwaddr
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mtag
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|m_tag_prepend
argument_list|(
name|m
argument_list|,
name|mtag
argument_list|)
expr_stmt|;
block|}
name|destfw
operator|=
operator|(
expr|struct
name|fw_hwaddr
operator|*
operator|)
operator|(
name|mtag
operator|+
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|destfw
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|dst
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|AF_INET
case|case
name|AF_INET
case|:
comment|/* 		 * Only bother with arp for unicast. Allocation of 		 * channels etc. for firewire is quite different and 		 * doesn't fit into the arp model. 		 */
if|if
condition|(
name|unicast
condition|)
block|{
name|error
operator|=
name|arpresolve
argument_list|(
name|ifp
argument_list|,
name|rt
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|destfw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|==
name|EWOULDBLOCK
condition|?
literal|0
else|:
name|error
operator|)
return|;
block|}
name|type
operator|=
name|ETHERTYPE_IP
expr_stmt|;
break|break;
case|case
name|AF_ARP
case|:
block|{
name|struct
name|arphdr
modifier|*
name|ah
decl_stmt|;
name|ah
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arphdr
operator|*
argument_list|)
expr_stmt|;
name|ah
operator|->
name|ar_hrd
operator|=
name|htons
argument_list|(
name|ARPHRD_IEEE1394
argument_list|)
expr_stmt|;
name|type
operator|=
name|ETHERTYPE_ARP
expr_stmt|;
if|if
condition|(
name|unicast
condition|)
operator|*
name|destfw
operator|=
operator|*
operator|(
expr|struct
name|fw_hwaddr
operator|*
operator|)
name|ar_tha
argument_list|(
name|ah
argument_list|)
expr_stmt|;
comment|/* 		 * The standard arp code leaves a hole for the target 		 * hardware address which we need to close up. 		 */
name|bcopy
argument_list|(
name|ar_tpa
argument_list|(
name|ah
argument_list|)
argument_list|,
name|ar_tha
argument_list|(
name|ah
argument_list|)
argument_list|,
name|ah
operator|->
name|ar_pln
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
name|ah
operator|->
name|ar_hln
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|unicast
condition|)
block|{
name|error
operator|=
name|nd6_storelladdr
argument_list|(
name|fc
operator|->
name|fc_ifp
argument_list|,
name|rt
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|destfw
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|type
operator|=
name|ETHERTYPE_IPV6
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"can't handle af%d\n"
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Let BPF tap off a copy before we encapsulate. 	 */
if|if
condition|(
name|bpf_peers_present
argument_list|(
name|ifp
operator|->
name|if_bpf
argument_list|)
condition|)
block|{
name|struct
name|fw_bpfhdr
name|h
decl_stmt|;
if|if
condition|(
name|unicast
condition|)
name|bcopy
argument_list|(
name|destfw
argument_list|,
name|h
operator|.
name|firewire_dhost
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
operator|&
name|firewire_broadcastaddr
argument_list|,
name|h
operator|.
name|firewire_dhost
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|fc
operator|->
name|fc_hwaddr
argument_list|,
name|h
operator|.
name|firewire_shost
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|h
operator|.
name|firewire_type
operator|=
name|htons
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|bpf_mtap2
argument_list|(
name|ifp
operator|->
name|if_bpf
argument_list|,
operator|&
name|h
argument_list|,
sizeof|sizeof
argument_list|(
name|h
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Punt on MCAP for now and send all multicast packets on the 	 * broadcast channel. 	 */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_MCAST
condition|)
name|m
operator|->
name|m_flags
operator||=
name|M_BCAST
expr_stmt|;
comment|/* 	 * Figure out what speed to use and what the largest supported 	 * packet size is. For unicast, this is the minimum of what we 	 * can speak and what they can hear. For broadcast, lets be 	 * conservative and use S100. We could possibly improve that 	 * by examining the bus manager's speed map or similar. We 	 * also reduce the packet size for broadcast to account for 	 * the GASP header. 	 */
if|if
condition|(
name|unicast
condition|)
block|{
name|speed
operator|=
name|min
argument_list|(
name|fc
operator|->
name|fc_speed
argument_list|,
name|destfw
operator|->
name|sspd
argument_list|)
expr_stmt|;
name|psize
operator|=
name|min
argument_list|(
literal|512
operator|<<
name|speed
argument_list|,
literal|2
operator|<<
name|destfw
operator|->
name|sender_max_rec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|speed
operator|=
literal|0
expr_stmt|;
name|psize
operator|=
literal|512
operator|-
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Next, we encapsulate, possibly fragmenting the original 	 * datagram if it won't fit into a single packet. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<=
name|psize
operator|-
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
comment|/* 		 * No fragmentation is necessary. 		 */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|enc
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|union
name|fw_encap
operator|*
argument_list|)
expr_stmt|;
name|enc
operator|->
name|unfrag
operator|.
name|ether_type
operator|=
name|type
expr_stmt|;
name|enc
operator|->
name|unfrag
operator|.
name|lf
operator|=
name|FW_ENCAP_UNFRAG
expr_stmt|;
name|enc
operator|->
name|unfrag
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Byte swap the encapsulation header manually. 		 */
name|enc
operator|->
name|ul
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
name|enc
operator|->
name|ul
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|IFQ_HANDOFF
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * Fragment the datagram, making sure to leave enough 		 * space for the encapsulation header in each packet. 		 */
name|fsize
operator|=
name|psize
operator|-
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|dgl
operator|=
name|next_dgl
operator|++
expr_stmt|;
name|dsize
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|foff
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|fsize
condition|)
block|{
comment|/* 				 * Split off the tail segment from the 				 * datagram, copying our tags over. 				 */
name|mtail
operator|=
name|m_split
argument_list|(
name|m
argument_list|,
name|fsize
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|m_tag_copy_chain
argument_list|(
name|mtail
argument_list|,
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mtail
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 			 * Add our encapsulation header to this 			 * fragment and hand it off to the link. 			 */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|enc
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|union
name|fw_encap
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|foff
operator|==
literal|0
condition|)
block|{
name|enc
operator|->
name|firstfrag
operator|.
name|lf
operator|=
name|FW_ENCAP_FIRST
expr_stmt|;
name|enc
operator|->
name|firstfrag
operator|.
name|reserved1
operator|=
literal|0
expr_stmt|;
name|enc
operator|->
name|firstfrag
operator|.
name|reserved2
operator|=
literal|0
expr_stmt|;
name|enc
operator|->
name|firstfrag
operator|.
name|datagram_size
operator|=
name|dsize
operator|-
literal|1
expr_stmt|;
name|enc
operator|->
name|firstfrag
operator|.
name|ether_type
operator|=
name|type
expr_stmt|;
name|enc
operator|->
name|firstfrag
operator|.
name|dgl
operator|=
name|dgl
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mtail
condition|)
name|enc
operator|->
name|nextfrag
operator|.
name|lf
operator|=
name|FW_ENCAP_NEXT
expr_stmt|;
else|else
name|enc
operator|->
name|nextfrag
operator|.
name|lf
operator|=
name|FW_ENCAP_LAST
expr_stmt|;
name|enc
operator|->
name|nextfrag
operator|.
name|reserved1
operator|=
literal|0
expr_stmt|;
name|enc
operator|->
name|nextfrag
operator|.
name|reserved2
operator|=
literal|0
expr_stmt|;
name|enc
operator|->
name|nextfrag
operator|.
name|reserved3
operator|=
literal|0
expr_stmt|;
name|enc
operator|->
name|nextfrag
operator|.
name|datagram_size
operator|=
name|dsize
operator|-
literal|1
expr_stmt|;
name|enc
operator|->
name|nextfrag
operator|.
name|fragment_offset
operator|=
name|foff
expr_stmt|;
name|enc
operator|->
name|nextfrag
operator|.
name|dgl
operator|=
name|dgl
expr_stmt|;
block|}
name|foff
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
comment|/* 			 * Byte swap the encapsulation header manually. 			 */
name|enc
operator|->
name|ul
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
name|enc
operator|->
name|ul
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|enc
operator|->
name|ul
index|[
literal|1
index|]
operator|=
name|htonl
argument_list|(
name|enc
operator|->
name|ul
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|IFQ_HANDOFF
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|mtail
condition|)
name|m_freem
argument_list|(
name|mtail
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m
operator|=
name|mtail
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bad
label|:
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|firewire_input_fragment
parameter_list|(
name|struct
name|fw_com
modifier|*
name|fc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|src
parameter_list|)
block|{
name|union
name|fw_encap
modifier|*
name|enc
decl_stmt|;
name|struct
name|fw_reass
modifier|*
name|r
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mf
decl_stmt|,
modifier|*
name|mprev
decl_stmt|;
name|int
name|dsize
decl_stmt|;
name|int
name|fstart
decl_stmt|,
name|fend
decl_stmt|,
name|start
decl_stmt|,
name|end
decl_stmt|,
name|islast
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
comment|/* 	 * Find an existing reassembly buffer or create a new one. 	 */
name|enc
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|union
name|fw_encap
operator|*
argument_list|)
expr_stmt|;
name|id
operator|=
name|enc
operator|->
name|firstfrag
operator|.
name|dgl
operator||
operator|(
name|src
operator|<<
literal|16
operator|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|r
argument_list|,
argument|&fc->fc_frags
argument_list|,
argument|fr_link
argument_list|)
if|if
condition|(
name|r
operator|->
name|fr_id
operator|==
name|id
condition|)
break|break;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|r
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fw_reass
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|r
operator|->
name|fr_id
operator|=
name|id
expr_stmt|;
name|r
operator|->
name|fr_frags
operator|=
literal|0
expr_stmt|;
name|STAILQ_INSERT_HEAD
argument_list|(
operator|&
name|fc
operator|->
name|fc_frags
argument_list|,
name|r
argument_list|,
name|fr_link
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If this fragment overlaps any other fragment, we must discard 	 * the partial reassembly and start again. 	 */
if|if
condition|(
name|enc
operator|->
name|firstfrag
operator|.
name|lf
operator|==
name|FW_ENCAP_FIRST
condition|)
name|fstart
operator|=
literal|0
expr_stmt|;
else|else
name|fstart
operator|=
name|enc
operator|->
name|nextfrag
operator|.
name|fragment_offset
expr_stmt|;
name|fend
operator|=
name|fstart
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|dsize
operator|=
name|enc
operator|->
name|nextfrag
operator|.
name|datagram_size
expr_stmt|;
name|islast
operator|=
operator|(
name|enc
operator|->
name|nextfrag
operator|.
name|lf
operator|==
name|FW_ENCAP_LAST
operator|)
expr_stmt|;
for|for
control|(
name|mf
operator|=
name|r
operator|->
name|fr_frags
init|;
name|mf
condition|;
name|mf
operator|=
name|mf
operator|->
name|m_nextpkt
control|)
block|{
name|enc
operator|=
name|mtod
argument_list|(
name|mf
argument_list|,
expr|union
name|fw_encap
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc
operator|->
name|nextfrag
operator|.
name|datagram_size
operator|!=
name|dsize
condition|)
block|{
comment|/* 			 * This fragment must be from a different 			 * packet. 			 */
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|enc
operator|->
name|firstfrag
operator|.
name|lf
operator|==
name|FW_ENCAP_FIRST
condition|)
name|start
operator|=
literal|0
expr_stmt|;
else|else
name|start
operator|=
name|enc
operator|->
name|nextfrag
operator|.
name|fragment_offset
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|mf
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fstart
operator|<
name|end
operator|&&
name|fend
operator|>
name|start
operator|)
operator|||
operator|(
name|islast
operator|&&
name|enc
operator|->
name|nextfrag
operator|.
name|lf
operator|==
name|FW_ENCAP_LAST
operator|)
condition|)
block|{
comment|/* 			 * Overlap - discard reassembly buffer and start 			 * again with this fragment. 			 */
goto|goto
name|bad
goto|;
block|}
block|}
comment|/* 	 * Find where to put this fragment in the list. 	 */
for|for
control|(
name|mf
operator|=
name|r
operator|->
name|fr_frags
operator|,
name|mprev
operator|=
name|NULL
init|;
name|mf
condition|;
name|mprev
operator|=
name|mf
operator|,
name|mf
operator|=
name|mf
operator|->
name|m_nextpkt
control|)
block|{
name|enc
operator|=
name|mtod
argument_list|(
name|mf
argument_list|,
expr|union
name|fw_encap
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc
operator|->
name|firstfrag
operator|.
name|lf
operator|==
name|FW_ENCAP_FIRST
condition|)
name|start
operator|=
literal|0
expr_stmt|;
else|else
name|start
operator|=
name|enc
operator|->
name|nextfrag
operator|.
name|fragment_offset
expr_stmt|;
if|if
condition|(
name|start
operator|>=
name|fend
condition|)
break|break;
block|}
comment|/* 	 * If this is a last fragment and we are not adding at the end 	 * of the list, discard the buffer. 	 */
if|if
condition|(
name|islast
operator|&&
name|mprev
operator|&&
name|mprev
operator|->
name|m_nextpkt
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|mprev
condition|)
block|{
name|m
operator|->
name|m_nextpkt
operator|=
name|mprev
operator|->
name|m_nextpkt
expr_stmt|;
name|mprev
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
comment|/* 		 * Coalesce forwards and see if we can make a whole 		 * datagram. 		 */
name|enc
operator|=
name|mtod
argument_list|(
name|mprev
argument_list|,
expr|union
name|fw_encap
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc
operator|->
name|firstfrag
operator|.
name|lf
operator|==
name|FW_ENCAP_FIRST
condition|)
name|start
operator|=
literal|0
expr_stmt|;
else|else
name|start
operator|=
name|enc
operator|->
name|nextfrag
operator|.
name|fragment_offset
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|mprev
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
while|while
condition|(
name|end
operator|==
name|fstart
condition|)
block|{
comment|/* 			 * Strip off the encap header from m and 			 * append it to mprev, freeing m. 			 */
name|m_adj
argument_list|(
name|m
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|mprev
operator|->
name|m_nextpkt
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|mprev
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_cat
argument_list|(
name|mprev
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|mprev
operator|->
name|m_pkthdr
operator|.
name|len
operator|==
name|dsize
operator|+
literal|1
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
comment|/* 				 * We have assembled a complete packet 				 * we must be finished. Make sure we have 				 * merged the whole chain. 				 */
name|STAILQ_REMOVE
argument_list|(
operator|&
name|fc
operator|->
name|fc_frags
argument_list|,
name|r
argument_list|,
name|fw_reass
argument_list|,
name|fr_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|r
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|m
operator|=
name|mprev
operator|->
name|m_nextpkt
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|mf
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|mf
expr_stmt|;
block|}
name|mprev
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|mprev
operator|)
return|;
block|}
comment|/* 			 * See if we can continue merging forwards. 			 */
name|end
operator|=
name|fend
expr_stmt|;
name|m
operator|=
name|mprev
operator|->
name|m_nextpkt
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|enc
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|union
name|fw_encap
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc
operator|->
name|firstfrag
operator|.
name|lf
operator|==
name|FW_ENCAP_FIRST
condition|)
name|fstart
operator|=
literal|0
expr_stmt|;
else|else
name|fstart
operator|=
name|enc
operator|->
name|nextfrag
operator|.
name|fragment_offset
expr_stmt|;
name|fend
operator|=
name|fstart
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
else|else
block|{
name|m
operator|->
name|m_nextpkt
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|fr_frags
operator|=
name|m
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
while|while
condition|(
name|r
operator|->
name|fr_frags
condition|)
block|{
name|mf
operator|=
name|r
operator|->
name|fr_frags
expr_stmt|;
name|r
operator|->
name|fr_frags
operator|=
name|mf
operator|->
name|m_nextpkt
expr_stmt|;
name|m_freem
argument_list|(
name|mf
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|m_nextpkt
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|fr_frags
operator|=
name|m
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|firewire_input
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint16_t
name|src
parameter_list|)
block|{
name|struct
name|fw_com
modifier|*
name|fc
init|=
name|IFP2FWC
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|union
name|fw_encap
modifier|*
name|enc
decl_stmt|;
name|int
name|type
decl_stmt|,
name|isr
decl_stmt|;
name|GIANT_REQUIRED
expr_stmt|;
comment|/* 	 * The caller has already stripped off the packet header 	 * (stream or wreqb) and marked the mbuf's M_BCAST flag 	 * appropriately. We de-encapsulate the IP packet and pass it 	 * up the line after handling link-level fragmentation. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"discarding frame without "
literal|"encapsulation header (len %u pkt len %u)\n"
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|enc
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|union
name|fw_encap
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Byte swap the encapsulation header manually. 	 */
name|enc
operator|->
name|ul
index|[
literal|0
index|]
operator|=
name|ntohl
argument_list|(
name|enc
operator|->
name|ul
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|enc
operator|->
name|unfrag
operator|.
name|lf
operator|!=
literal|0
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return;
name|enc
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|union
name|fw_encap
operator|*
argument_list|)
expr_stmt|;
name|enc
operator|->
name|ul
index|[
literal|1
index|]
operator|=
name|ntohl
argument_list|(
name|enc
operator|->
name|ul
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|m
operator|=
name|firewire_input_fragment
argument_list|(
name|fc
argument_list|,
name|m
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|m
condition|)
return|return;
name|enc
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|union
name|fw_encap
operator|*
argument_list|)
expr_stmt|;
name|type
operator|=
name|enc
operator|->
name|firstfrag
operator|.
name|ether_type
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|enc
operator|->
name|unfrag
operator|.
name|ether_type
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"discard frame w/o interface pointer\n"
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|!=
name|ifp
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Warning, frame marked as received on %s\n"
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_xname
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MAC
comment|/* 	 * Tag the mbuf with an appropriate MAC label before any other 	 * consumers can get to it. 	 */
name|mac_create_mbuf_from_ifnet
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Give bpf a chance at the packet. The link-level driver 	 * should have left us a tag with the EUID of the sender. 	 */
if|if
condition|(
name|bpf_peers_present
argument_list|(
name|ifp
operator|->
name|if_bpf
argument_list|)
condition|)
block|{
name|struct
name|fw_bpfhdr
name|h
decl_stmt|;
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|mtag
operator|=
name|m_tag_locate
argument_list|(
name|m
argument_list|,
name|MTAG_FIREWIRE
argument_list|,
name|MTAG_FIREWIRE_SENDER_EUID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
condition|)
name|bcopy
argument_list|(
name|mtag
operator|+
literal|1
argument_list|,
name|h
operator|.
name|firewire_shost
argument_list|,
literal|8
argument_list|)
expr_stmt|;
else|else
name|bcopy
argument_list|(
operator|&
name|firewire_broadcastaddr
argument_list|,
name|h
operator|.
name|firewire_dhost
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|fc
operator|->
name|fc_hwaddr
argument_list|,
name|h
operator|.
name|firewire_dhost
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|h
operator|.
name|firewire_type
operator|=
name|htons
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|bpf_mtap2
argument_list|(
name|ifp
operator|->
name|if_bpf
argument_list|,
operator|&
name|h
argument_list|,
sizeof|sizeof
argument_list|(
name|h
argument_list|)
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MONITOR
condition|)
block|{
comment|/* 		 * Interface marked for monitoring; discard packet. 		 */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|->
name|if_ibytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* Discard packet if interface is not up */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
condition|)
name|ifp
operator|->
name|if_imcasts
operator|++
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|ETHERTYPE_IP
case|:
if|if
condition|(
name|ip_fastforward
argument_list|(
name|m
argument_list|)
condition|)
return|return;
name|isr
operator|=
name|NETISR_IP
expr_stmt|;
break|break;
case|case
name|ETHERTYPE_ARP
case|:
block|{
name|struct
name|arphdr
modifier|*
name|ah
decl_stmt|;
name|ah
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|arphdr
operator|*
argument_list|)
expr_stmt|;
comment|/* 		 * Adjust the arp packet to insert an empty tha slot. 		 */
name|m
operator|->
name|m_len
operator|+=
name|ah
operator|->
name|ar_hln
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|ah
operator|->
name|ar_hln
expr_stmt|;
name|bcopy
argument_list|(
name|ar_tha
argument_list|(
name|ah
argument_list|)
argument_list|,
name|ar_tpa
argument_list|(
name|ah
argument_list|)
argument_list|,
name|ah
operator|->
name|ar_pln
argument_list|)
expr_stmt|;
name|isr
operator|=
name|NETISR_ARP
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|ETHERTYPE_IPV6
case|:
name|isr
operator|=
name|NETISR_IPV6
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|netisr_dispatch
argument_list|(
name|isr
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|firewire_ioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|ifp
operator|->
name|if_init
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|)
expr_stmt|;
comment|/* before arpwhohas */
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|ifp
operator|->
name|if_init
argument_list|(
name|ifp
operator|->
name|if_softc
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIOCGIFADDR
case|:
block|{
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ifr
operator|->
name|ifr_data
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|IFP2FWC
argument_list|(
name|ifp
argument_list|)
operator|->
name|fc_hwaddr
argument_list|,
operator|(
name|caddr_t
operator|)
name|sa
operator|->
name|sa_data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fw_hwaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMTU
case|:
comment|/* 		 * Set the interface MTU. 		 */
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
literal|1500
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|->
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
block|}
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* XXX netbsd has ENOTTY??? */
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|firewire_resolvemulti
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|llsa
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_LINK
case|:
comment|/* 		 * No mapping needed. 		 */
operator|*
name|llsa
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
operator|!
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
return|return
name|EADDRNOTAVAIL
return|;
operator|*
name|llsa
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* 			 * An IP6 address of 0 means listen to all 			 * of the Ethernet multicast address used for IP6. 			 * (This is used for multicast routers.) 			 */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_ALLMULTI
expr_stmt|;
operator|*
name|llsa
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
return|return
name|EADDRNOTAVAIL
return|;
operator|*
name|llsa
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
endif|#
directive|endif
default|default:
comment|/* 		 * Well, the text isn't quite right, but it's the name 		 * that counts... 		 */
return|return
name|EAFNOSUPPORT
return|;
block|}
block|}
end_function

begin_function
name|void
name|firewire_ifattach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|fw_hwaddr
modifier|*
name|llc
parameter_list|)
block|{
name|struct
name|fw_com
modifier|*
name|fc
init|=
name|IFP2FWC
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|speeds
index|[]
init|=
block|{
literal|"S100"
block|,
literal|"S200"
block|,
literal|"S400"
block|,
literal|"S800"
block|,
literal|"S1600"
block|,
literal|"S3200"
block|}
decl_stmt|;
name|fc
operator|->
name|fc_speed
operator|=
name|llc
operator|->
name|sspd
expr_stmt|;
name|STAILQ_INIT
argument_list|(
operator|&
name|fc
operator|->
name|fc_frags
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_addrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|fw_hwaddr
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_hdrlen
operator|=
literal|0
expr_stmt|;
name|if_attach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_mtu
operator|=
literal|1500
expr_stmt|;
comment|/* XXX */
name|ifp
operator|->
name|if_output
operator|=
name|firewire_output
expr_stmt|;
name|ifp
operator|->
name|if_resolvemulti
operator|=
name|firewire_resolvemulti
expr_stmt|;
name|ifp
operator|->
name|if_broadcastaddr
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|firewire_broadcastaddr
expr_stmt|;
name|ifa
operator|=
name|ifaddr_byindex
argument_list|(
name|ifp
operator|->
name|if_index
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ifa
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no lladdr!\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|sdl
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|sdl
operator|->
name|sdl_type
operator|=
name|IFT_IEEE1394
expr_stmt|;
name|sdl
operator|->
name|sdl_alen
operator|=
name|ifp
operator|->
name|if_addrlen
expr_stmt|;
name|bcopy
argument_list|(
name|llc
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|ifp
operator|->
name|if_addrlen
argument_list|)
expr_stmt|;
name|bpfattach
argument_list|(
name|ifp
argument_list|,
name|DLT_APPLE_IP_OVER_IEEE1394
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fw_hwaddr
argument_list|)
argument_list|)
expr_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"Firewire address: %8D @ 0x%04x%08x, %s, maxrec %d\n"
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|llc
operator|->
name|sender_unique_ID_hi
argument_list|,
literal|":"
argument_list|,
name|ntohs
argument_list|(
name|llc
operator|->
name|sender_unicast_FIFO_hi
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|llc
operator|->
name|sender_unicast_FIFO_lo
argument_list|)
argument_list|,
name|speeds
index|[
name|llc
operator|->
name|sspd
index|]
argument_list|,
operator|(
literal|2
operator|<<
name|llc
operator|->
name|sender_max_rec
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|firewire_ifdetach
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|bpfdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_detach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|firewire_busreset
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|fw_com
modifier|*
name|fc
init|=
name|IFP2FWC
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|fw_reass
modifier|*
name|r
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* 	 * Discard any partial datagrams since the host ids may have changed. 	 */
while|while
condition|(
operator|(
name|r
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|fc
operator|->
name|fc_frags
argument_list|)
operator|)
condition|)
block|{
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|fc
operator|->
name|fc_frags
argument_list|,
name|fr_link
argument_list|)
expr_stmt|;
while|while
condition|(
name|r
operator|->
name|fr_frags
condition|)
block|{
name|m
operator|=
name|r
operator|->
name|fr_frags
expr_stmt|;
name|r
operator|->
name|fr_frags
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|r
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|firewire_alloc
parameter_list|(
name|u_char
name|type
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|fw_com
modifier|*
name|fc
decl_stmt|;
name|fc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fw_com
argument_list|)
argument_list|,
name|M_FWCOM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|fc
operator|->
name|fc_ifp
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|fc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|firewire_free
parameter_list|(
name|void
modifier|*
name|com
parameter_list|,
name|u_char
name|type
parameter_list|)
block|{
name|free
argument_list|(
name|com
argument_list|,
name|M_FWCOM
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|firewire_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|if_register_com_alloc
argument_list|(
name|IFT_IEEE1394
argument_list|,
name|firewire_alloc
argument_list|,
name|firewire_free
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|if_deregister_com_alloc
argument_list|(
name|IFT_IEEE1394
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|firewire_mod
init|=
block|{
literal|"if_firewire"
block|,
name|firewire_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|if_firewire
argument_list|,
name|firewire_mod
argument_list|,
name|SI_SUB_INIT_IF
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|if_firewire
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

