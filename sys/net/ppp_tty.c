begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ppp_tty.c - Point-to-Point Protocol (PPP) driver for asynchronous  * 	       tty devices.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1989 Carnegie Mellon University.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by Carnegie Mellon University.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * Drew D. Perkins  * Carnegie Mellon University  * 4910 Forbes Ave.  * Pittsburgh, PA 15213  * (412) 268-8576  * ddp@andrew.cmu.edu  *  * Based on:  *	@(#)if_sl.c	7.6.1.2 (Berkeley) 2/15/89  *  * Copyright (c) 1987 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * Serial Line interface  *  * Rick Adams  * Center for Seismic Studies  * 1300 N 17th Street, Suite 1450  * Arlington, Virginia 22209  * (703)276-7900  * rick@seismo.ARPA  * seismo!rick  *  * Pounded on heavily by Chris Torek (chris@mimsy.umd.edu, umcp-cs!chris).  * Converted to 4.3BSD Beta by Chris Torek.  * Other changes made at Berkeley, based in part on code by Kirk Smith.  *  * Converted to 4.3BSD+ 386BSD by Brad Parker (brad@cayman.com)  * Added VJ tcp header compression; more unified ioctls  *  * Extensively modified by Paul Mackerras (paulus@cs.anu.edu.au).  * Cleaned up a lot of the mbuf-related code to fix bugs that  * caused system crashes and packet corruption.  Changed pppstart  * so that it doesn't just give up with a "collision" if the whole  * packet doesn't fit in the output ring buffer.  *  * Added priority queueing for interactive IP packets, following  * the model of if_sl.c, plus hooks for bpf.  * Paul Mackerras (paulus@cs.anu.edu.au).  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"opt_ppp.h"
end_include

begin_comment
comment|/* XXX for ppp_defs.h */
end_comment

begin_define
define|#
directive|define
name|VJC
end_define

begin_comment
comment|/* XXX for ppp_defs.h */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PPP_FILTER
end_ifdef

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if_ppp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_pppvar.h>
end_include

begin_function_decl
specifier|static
name|int
name|pppopen
parameter_list|(
name|struct
name|cdev
modifier|*
name|dev
parameter_list|,
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pppclose
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|int
name|flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pppread
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pppwrite
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ppptioctl
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pppinput
parameter_list|(
name|int
name|c
parameter_list|,
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pppstart
parameter_list|(
name|struct
name|tty
modifier|*
name|tp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_short
name|pppfcs
parameter_list|(
name|u_short
name|fcs
parameter_list|,
name|u_char
modifier|*
name|cp
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pppasyncstart
parameter_list|(
name|struct
name|ppp_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pppasyncctlp
parameter_list|(
name|struct
name|ppp_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pppasyncrelinq
parameter_list|(
name|struct
name|ppp_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pppasyncsetmtu
parameter_list|(
name|struct
name|ppp_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ppp_timeout
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pppgetm
parameter_list|(
name|struct
name|ppp_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ppplogchar
parameter_list|(
name|struct
name|ppp_softc
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* XXX called from if_ppp.c - layering violation */
end_comment

begin_function_decl
name|void
name|pppasyncattach
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pppasyncdetach
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Some useful mbuf macros not in mbuf.h.  */
end_comment

begin_define
define|#
directive|define
name|M_IS_CLUSTER
parameter_list|(
name|m
parameter_list|)
value|((m)->m_flags& M_EXT)
end_define

begin_define
define|#
directive|define
name|M_DATASTART
parameter_list|(
name|m
parameter_list|)
define|\
value|(M_IS_CLUSTER(m) ? (m)->m_ext.ext_buf : \ 	    (m)->m_flags& M_PKTHDR ? (m)->m_pktdat : (m)->m_dat)
end_define

begin_define
define|#
directive|define
name|M_DATASIZE
parameter_list|(
name|m
parameter_list|)
define|\
value|(M_IS_CLUSTER(m) ? (m)->m_ext.ext_size : \ 	    (m)->m_flags& M_PKTHDR ? MHLEN: MLEN)
end_define

begin_comment
comment|/*  * Does c need to be escaped?  */
end_comment

begin_define
define|#
directive|define
name|ESCAPE_P
parameter_list|(
name|c
parameter_list|)
value|(sc->sc_asyncmap[(c)>> 5]& (1<< ((c)& 0x1F)))
end_define

begin_comment
comment|/*  * Procedures for using an async tty interface for PPP.  */
end_comment

begin_comment
comment|/* This is a FreeBSD-2.X kernel. */
end_comment

begin_define
define|#
directive|define
name|CCOUNT
parameter_list|(
name|q
parameter_list|)
value|((q)->c_cc)
end_define

begin_define
define|#
directive|define
name|PPP_LOWAT
value|100
end_define

begin_comment
comment|/* Process more output when< LOWAT on queue */
end_comment

begin_define
define|#
directive|define
name|PPP_HIWAT
value|400
end_define

begin_comment
comment|/* Don't start a new packet if HIWAT on que */
end_comment

begin_comment
comment|/*  * Define the PPP line discipline.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|linesw
name|pppdisc
init|=
block|{
name|pppopen
block|,
name|pppclose
block|,
name|pppread
block|,
name|pppwrite
block|,
name|ppptioctl
block|,
name|pppinput
block|,
name|pppstart
block|,
name|ttymodem
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|pppasyncattach
parameter_list|(
name|dummy
parameter_list|)
name|void
modifier|*
name|dummy
decl_stmt|;
block|{
name|ldisc_register
argument_list|(
name|PPPDISC
argument_list|,
operator|&
name|pppdisc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pppasyncdetach
parameter_list|()
block|{
name|ldisc_deregister
argument_list|(
name|PPPDISC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Line specific open routine for async tty devices.  * Attach the given tty to the first available ppp unit.  * Called from device open routine or ttioctl() at>= splsofttty()  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|pppopen
parameter_list|(
name|dev
parameter_list|,
name|tp
parameter_list|)
name|struct
name|cdev
modifier|*
name|dev
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
comment|/* XXX */
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|tp
operator|->
name|t_hotchar
operator|=
name|PPP_FLAG
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|=
name|pppalloc
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_relinq
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_relinq
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* get previous owner to relinquish the unit */
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_m
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_asyncmap
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_asyncmap
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_asyncmap
index|[
literal|0
index|]
operator|=
literal|0xffffffff
expr_stmt|;
name|sc
operator|->
name|sc_asyncmap
index|[
literal|3
index|]
operator|=
literal|0x60000000
expr_stmt|;
name|sc
operator|->
name|sc_rasyncmap
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_devp
operator|=
operator|(
name|void
operator|*
operator|)
name|tp
expr_stmt|;
name|sc
operator|->
name|sc_start
operator|=
name|pppasyncstart
expr_stmt|;
name|sc
operator|->
name|sc_ctlp
operator|=
name|pppasyncctlp
expr_stmt|;
name|sc
operator|->
name|sc_relinq
operator|=
name|pppasyncrelinq
expr_stmt|;
name|sc
operator|->
name|sc_setmtu
operator|=
name|pppasyncsetmtu
expr_stmt|;
name|sc
operator|->
name|sc_outm
operator|=
name|NULL
expr_stmt|;
name|pppgetm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|PPP2IFP
argument_list|(
name|sc
argument_list|)
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|PPP2IFP
argument_list|(
name|sc
argument_list|)
operator|->
name|if_lastchange
argument_list|)
expr_stmt|;
name|PPP2IFP
argument_list|(
name|sc
argument_list|)
operator|->
name|if_baudrate
operator|=
name|tp
operator|->
name|t_ospeed
expr_stmt|;
name|tp
operator|->
name|t_hotchar
operator|=
name|PPP_FLAG
expr_stmt|;
name|tp
operator|->
name|t_lsc
operator|=
name|sc
expr_stmt|;
name|ttyflush
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
comment|/*      * Pre-allocate cblocks to the "just right" amount.  The 1 byte t_canq      * allocation helps avoid the need for select and/or FIONREAD.      * We also pass 1 byte tokens through t_canq...      */
name|clist_alloc_cblocks
argument_list|(
operator|&
name|tp
operator|->
name|t_canq
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|clist_alloc_cblocks
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|PPP2IFP
argument_list|(
name|sc
argument_list|)
operator|->
name|if_mtu
operator|+
name|PPP_HIWAT
argument_list|,
name|PPP2IFP
argument_list|(
name|sc
argument_list|)
operator|->
name|if_mtu
operator|+
name|PPP_HIWAT
argument_list|)
expr_stmt|;
name|clist_alloc_cblocks
argument_list|(
operator|&
name|tp
operator|->
name|t_rawq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Line specific close routine, called from device close routine  * and from ttioctl at>= splsofttty().  * Detach the tty from the ppp unit.  * Mimics part of tty_close().  */
end_comment

begin_function
specifier|static
name|int
name|pppclose
parameter_list|(
name|tp
parameter_list|,
name|flag
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ppp_softc
operator|*
operator|)
name|tp
operator|->
name|t_lsc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|ttyflush
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
name|clist_free_cblocks
argument_list|(
operator|&
name|tp
operator|->
name|t_canq
argument_list|)
expr_stmt|;
name|clist_free_cblocks
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
name|pppasyncrelinq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|pppdealloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Relinquish the interface unit to another device.  */
end_comment

begin_function
specifier|static
name|void
name|pppasyncrelinq
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_outm
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_outm
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_outm
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_m
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_TIMEOUT
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_timo_ch
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_TIMEOUT
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This gets called from the upper layer to notify a mtu change  */
end_comment

begin_function
specifier|static
name|void
name|pppasyncsetmtu
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
init|=
operator|(
expr|struct
name|tty
operator|*
operator|)
name|sc
operator|->
name|sc_devp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|!=
name|NULL
condition|)
name|clist_alloc_cblocks
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|PPP2IFP
argument_list|(
name|sc
argument_list|)
operator|->
name|if_mtu
operator|+
name|PPP_HIWAT
argument_list|,
name|PPP2IFP
argument_list|(
name|sc
argument_list|)
operator|->
name|if_mtu
operator|+
name|PPP_HIWAT
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Line specific (tty) read routine.  * called at zero spl from the device driver in the response to user-level  * reads on the tty file descriptor (ie: pppd).  */
end_comment

begin_function
specifier|static
name|int
name|pppread
parameter_list|(
name|tp
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ppp_softc
operator|*
operator|)
name|tp
operator|->
name|t_lsc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/*      * Loop waiting for input, checking that nothing disasterous      * happens in the meantime.      */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|tp
operator|!=
operator|(
expr|struct
name|tty
operator|*
operator|)
name|sc
operator|->
name|sc_devp
operator|||
name|tp
operator|->
name|t_line
operator|!=
name|PPPDISC
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_inq
operator|.
name|ifq_head
operator|!=
name|NULL
condition|)
break|break;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* end of file */
block|}
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASYNC
operator|||
name|flag
operator|&
name|O_NONBLOCK
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
block|}
name|error
operator|=
name|ttysleep
argument_list|(
name|tp
argument_list|,
name|TSA_HUP_OR_INPUT
argument_list|(
name|tp
argument_list|)
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
literal|"pppin"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
comment|/* Pull place-holder byte out of canonical queue */
name|getc
argument_list|(
operator|&
name|tp
operator|->
name|t_canq
argument_list|)
expr_stmt|;
comment|/* Get the packet from the input queue */
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_inq
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|&&
name|uio
operator|->
name|uio_resid
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
if|if
condition|(
operator|(
name|error
operator|=
name|uiomove
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|uio
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Line specific (tty) write routine.  * called at zero spl from the device driver in the response to user-level  * writes on the tty file descriptor (ie: pppd).  */
end_comment

begin_function
specifier|static
name|int
name|pppwrite
parameter_list|(
name|tp
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ppp_softc
operator|*
operator|)
name|tp
operator|->
name|t_lsc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sockaddr
name|dst
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CONNECTED
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* wrote 0 bytes */
if|if
condition|(
name|tp
operator|->
name|t_line
operator|!=
name|PPPDISC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
name|EIO
return|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|>
name|PPP2IFP
argument_list|(
name|sc
argument_list|)
operator|->
name|if_mtu
operator|+
name|PPP_HDRLEN
operator|||
name|uio
operator|->
name|uio_resid
operator|<
name|PPP_HDRLEN
condition|)
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|m_uiotombuf
argument_list|(
name|uio
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|dst
operator|.
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|dst
operator|.
name|sa_data
argument_list|,
name|PPP_HDRLEN
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|PPP_HDRLEN
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|PPP_HDRLEN
expr_stmt|;
comment|/* call the upper layer to "transmit" it... */
name|error
operator|=
name|pppoutput
argument_list|(
name|PPP2IFP
argument_list|(
name|sc
argument_list|)
argument_list|,
name|m
argument_list|,
operator|&
name|dst
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Line specific (tty) ioctl routine.  * This discipline requires that tty device drivers call  * the line specific l_ioctl routine from their ioctl routines.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|ppptioctl
parameter_list|(
name|tp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|,
name|td
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|ppp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ppp_softc
operator|*
operator|)
name|tp
operator|->
name|t_lsc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|tp
operator|!=
operator|(
expr|struct
name|tty
operator|*
operator|)
name|sc
operator|->
name|sc_devp
condition|)
return|return
operator|(
name|ENOIOCTL
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PPPIOCSASYNCMAP
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|sc
operator|->
name|sc_asyncmap
index|[
literal|0
index|]
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
expr_stmt|;
break|break;
case|case
name|PPPIOCGASYNCMAP
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_asyncmap
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|PPPIOCSRASYNCMAP
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|sc
operator|->
name|sc_rasyncmap
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
expr_stmt|;
break|break;
case|case
name|PPPIOCGRASYNCMAP
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_rasyncmap
expr_stmt|;
break|break;
case|case
name|PPPIOCSXASYNCMAP
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|sc
operator|->
name|sc_asyncmap
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_asyncmap
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_asyncmap
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* mustn't escape 0x20 - 0x3f */
name|sc
operator|->
name|sc_asyncmap
index|[
literal|2
index|]
operator|&=
operator|~
literal|0x40000000
expr_stmt|;
comment|/* mustn't escape 0x5e */
name|sc
operator|->
name|sc_asyncmap
index|[
literal|3
index|]
operator||=
literal|0x60000000
expr_stmt|;
comment|/* must escape 0x7d, 0x7e */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPPIOCGXASYNCMAP
case|:
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_asyncmap
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_asyncmap
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|pppioctl
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|cmd
operator|==
name|PPPIOCSMRU
condition|)
name|pppgetm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * FCS lookup table as calculated by genfcstab.  */
end_comment

begin_decl_stmt
specifier|static
name|u_short
name|fcstab
index|[
literal|256
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x1189
block|,
literal|0x2312
block|,
literal|0x329b
block|,
literal|0x4624
block|,
literal|0x57ad
block|,
literal|0x6536
block|,
literal|0x74bf
block|,
literal|0x8c48
block|,
literal|0x9dc1
block|,
literal|0xaf5a
block|,
literal|0xbed3
block|,
literal|0xca6c
block|,
literal|0xdbe5
block|,
literal|0xe97e
block|,
literal|0xf8f7
block|,
literal|0x1081
block|,
literal|0x0108
block|,
literal|0x3393
block|,
literal|0x221a
block|,
literal|0x56a5
block|,
literal|0x472c
block|,
literal|0x75b7
block|,
literal|0x643e
block|,
literal|0x9cc9
block|,
literal|0x8d40
block|,
literal|0xbfdb
block|,
literal|0xae52
block|,
literal|0xdaed
block|,
literal|0xcb64
block|,
literal|0xf9ff
block|,
literal|0xe876
block|,
literal|0x2102
block|,
literal|0x308b
block|,
literal|0x0210
block|,
literal|0x1399
block|,
literal|0x6726
block|,
literal|0x76af
block|,
literal|0x4434
block|,
literal|0x55bd
block|,
literal|0xad4a
block|,
literal|0xbcc3
block|,
literal|0x8e58
block|,
literal|0x9fd1
block|,
literal|0xeb6e
block|,
literal|0xfae7
block|,
literal|0xc87c
block|,
literal|0xd9f5
block|,
literal|0x3183
block|,
literal|0x200a
block|,
literal|0x1291
block|,
literal|0x0318
block|,
literal|0x77a7
block|,
literal|0x662e
block|,
literal|0x54b5
block|,
literal|0x453c
block|,
literal|0xbdcb
block|,
literal|0xac42
block|,
literal|0x9ed9
block|,
literal|0x8f50
block|,
literal|0xfbef
block|,
literal|0xea66
block|,
literal|0xd8fd
block|,
literal|0xc974
block|,
literal|0x4204
block|,
literal|0x538d
block|,
literal|0x6116
block|,
literal|0x709f
block|,
literal|0x0420
block|,
literal|0x15a9
block|,
literal|0x2732
block|,
literal|0x36bb
block|,
literal|0xce4c
block|,
literal|0xdfc5
block|,
literal|0xed5e
block|,
literal|0xfcd7
block|,
literal|0x8868
block|,
literal|0x99e1
block|,
literal|0xab7a
block|,
literal|0xbaf3
block|,
literal|0x5285
block|,
literal|0x430c
block|,
literal|0x7197
block|,
literal|0x601e
block|,
literal|0x14a1
block|,
literal|0x0528
block|,
literal|0x37b3
block|,
literal|0x263a
block|,
literal|0xdecd
block|,
literal|0xcf44
block|,
literal|0xfddf
block|,
literal|0xec56
block|,
literal|0x98e9
block|,
literal|0x8960
block|,
literal|0xbbfb
block|,
literal|0xaa72
block|,
literal|0x6306
block|,
literal|0x728f
block|,
literal|0x4014
block|,
literal|0x519d
block|,
literal|0x2522
block|,
literal|0x34ab
block|,
literal|0x0630
block|,
literal|0x17b9
block|,
literal|0xef4e
block|,
literal|0xfec7
block|,
literal|0xcc5c
block|,
literal|0xddd5
block|,
literal|0xa96a
block|,
literal|0xb8e3
block|,
literal|0x8a78
block|,
literal|0x9bf1
block|,
literal|0x7387
block|,
literal|0x620e
block|,
literal|0x5095
block|,
literal|0x411c
block|,
literal|0x35a3
block|,
literal|0x242a
block|,
literal|0x16b1
block|,
literal|0x0738
block|,
literal|0xffcf
block|,
literal|0xee46
block|,
literal|0xdcdd
block|,
literal|0xcd54
block|,
literal|0xb9eb
block|,
literal|0xa862
block|,
literal|0x9af9
block|,
literal|0x8b70
block|,
literal|0x8408
block|,
literal|0x9581
block|,
literal|0xa71a
block|,
literal|0xb693
block|,
literal|0xc22c
block|,
literal|0xd3a5
block|,
literal|0xe13e
block|,
literal|0xf0b7
block|,
literal|0x0840
block|,
literal|0x19c9
block|,
literal|0x2b52
block|,
literal|0x3adb
block|,
literal|0x4e64
block|,
literal|0x5fed
block|,
literal|0x6d76
block|,
literal|0x7cff
block|,
literal|0x9489
block|,
literal|0x8500
block|,
literal|0xb79b
block|,
literal|0xa612
block|,
literal|0xd2ad
block|,
literal|0xc324
block|,
literal|0xf1bf
block|,
literal|0xe036
block|,
literal|0x18c1
block|,
literal|0x0948
block|,
literal|0x3bd3
block|,
literal|0x2a5a
block|,
literal|0x5ee5
block|,
literal|0x4f6c
block|,
literal|0x7df7
block|,
literal|0x6c7e
block|,
literal|0xa50a
block|,
literal|0xb483
block|,
literal|0x8618
block|,
literal|0x9791
block|,
literal|0xe32e
block|,
literal|0xf2a7
block|,
literal|0xc03c
block|,
literal|0xd1b5
block|,
literal|0x2942
block|,
literal|0x38cb
block|,
literal|0x0a50
block|,
literal|0x1bd9
block|,
literal|0x6f66
block|,
literal|0x7eef
block|,
literal|0x4c74
block|,
literal|0x5dfd
block|,
literal|0xb58b
block|,
literal|0xa402
block|,
literal|0x9699
block|,
literal|0x8710
block|,
literal|0xf3af
block|,
literal|0xe226
block|,
literal|0xd0bd
block|,
literal|0xc134
block|,
literal|0x39c3
block|,
literal|0x284a
block|,
literal|0x1ad1
block|,
literal|0x0b58
block|,
literal|0x7fe7
block|,
literal|0x6e6e
block|,
literal|0x5cf5
block|,
literal|0x4d7c
block|,
literal|0xc60c
block|,
literal|0xd785
block|,
literal|0xe51e
block|,
literal|0xf497
block|,
literal|0x8028
block|,
literal|0x91a1
block|,
literal|0xa33a
block|,
literal|0xb2b3
block|,
literal|0x4a44
block|,
literal|0x5bcd
block|,
literal|0x6956
block|,
literal|0x78df
block|,
literal|0x0c60
block|,
literal|0x1de9
block|,
literal|0x2f72
block|,
literal|0x3efb
block|,
literal|0xd68d
block|,
literal|0xc704
block|,
literal|0xf59f
block|,
literal|0xe416
block|,
literal|0x90a9
block|,
literal|0x8120
block|,
literal|0xb3bb
block|,
literal|0xa232
block|,
literal|0x5ac5
block|,
literal|0x4b4c
block|,
literal|0x79d7
block|,
literal|0x685e
block|,
literal|0x1ce1
block|,
literal|0x0d68
block|,
literal|0x3ff3
block|,
literal|0x2e7a
block|,
literal|0xe70e
block|,
literal|0xf687
block|,
literal|0xc41c
block|,
literal|0xd595
block|,
literal|0xa12a
block|,
literal|0xb0a3
block|,
literal|0x8238
block|,
literal|0x93b1
block|,
literal|0x6b46
block|,
literal|0x7acf
block|,
literal|0x4854
block|,
literal|0x59dd
block|,
literal|0x2d62
block|,
literal|0x3ceb
block|,
literal|0x0e70
block|,
literal|0x1ff9
block|,
literal|0xf78f
block|,
literal|0xe606
block|,
literal|0xd49d
block|,
literal|0xc514
block|,
literal|0xb1ab
block|,
literal|0xa022
block|,
literal|0x92b9
block|,
literal|0x8330
block|,
literal|0x7bc7
block|,
literal|0x6a4e
block|,
literal|0x58d5
block|,
literal|0x495c
block|,
literal|0x3de3
block|,
literal|0x2c6a
block|,
literal|0x1ef1
block|,
literal|0x0f78
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Calculate a new FCS given the current FCS and the new data.  */
end_comment

begin_function
specifier|static
name|u_short
name|pppfcs
parameter_list|(
name|u_short
name|fcs
parameter_list|,
name|u_char
modifier|*
name|cp
parameter_list|,
name|int
name|len
parameter_list|)
block|{
while|while
condition|(
name|len
operator|--
condition|)
name|fcs
operator|=
name|PPP_FCS
argument_list|(
name|fcs
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
name|fcs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This gets called at splsoftnet from if_ppp.c at various times  * when there is data ready to be sent.  */
end_comment

begin_function
specifier|static
name|void
name|pppasyncstart
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
init|=
operator|(
expr|struct
name|tty
operator|*
operator|)
name|sc
operator|->
name|sc_devp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|start
decl_stmt|,
modifier|*
name|stop
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|n
decl_stmt|,
name|ndone
decl_stmt|,
name|done
decl_stmt|,
name|idle
decl_stmt|;
name|int
name|s
decl_stmt|;
name|idle
operator|=
literal|0
expr_stmt|;
comment|/* XXX assumes atomic access to *tp although we're not at spltty(). */
while|while
condition|(
name|CCOUNT
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
operator|<
name|PPP_HIWAT
condition|)
block|{
comment|/* 	 * See if we have an existing packet partly sent. 	 * If not, get a new packet and start sending it. 	 */
name|m
operator|=
name|sc
operator|->
name|sc_outm
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* 	     * Get another packet to be sent. 	     */
name|m
operator|=
name|ppp_dequeue
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|idle
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 	     * The extra PPP_FLAG will start up a new packet, and thus 	     * will flush any accumulated garbage.  We do this whenever 	     * the line may have been idle for some time. 	     */
comment|/* XXX as above. */
if|if
condition|(
name|CCOUNT
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|sc
operator|->
name|sc_stats
operator|.
name|ppp_obytes
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
name|PPP_FLAG
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
comment|/* Calculate the FCS for the first mbuf's worth. */
name|sc
operator|->
name|sc_outfcs
operator|=
name|pppfcs
argument_list|(
name|PPP_INITFCS
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|PPP2IFP
argument_list|(
name|sc
argument_list|)
operator|->
name|if_lastchange
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|start
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|stop
operator|=
name|start
operator|+
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Find out how many bytes in the string we can 		 * handle without doing something special. 		 */
for|for
control|(
name|cp
operator|=
name|start
init|;
name|cp
operator|<
name|stop
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|ESCAPE_P
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
break|break;
name|n
operator|=
name|cp
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
comment|/* NetBSD (0.9 or later), 4.3-Reno or similar. */
name|ndone
operator|=
name|n
operator|-
name|b_to_q
argument_list|(
name|start
argument_list|,
name|n
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
name|len
operator|-=
name|ndone
expr_stmt|;
name|start
operator|+=
name|ndone
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ppp_obytes
operator|+=
name|ndone
expr_stmt|;
if|if
condition|(
name|ndone
operator|<
name|n
condition|)
break|break;
comment|/* packet doesn't fit */
block|}
comment|/* 		 * If there are characters left in the mbuf, 		 * the first one must be special. 		 * Put it out in a different form. 		 */
if|if
condition|(
name|len
condition|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|putc
argument_list|(
name|PPP_ESCAPE
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|putc
argument_list|(
operator|*
name|start
operator|^
name|PPP_TRANS
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|unputc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ppp_obytes
operator|+=
literal|2
expr_stmt|;
name|start
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
block|}
comment|/* 	     * If we didn't empty this mbuf, remember where we're up to. 	     * If we emptied the last mbuf, try to add the FCS and closing 	     * flag, and if we can't, leave sc_outm pointing to m, but with 	     * m->m_len == 0, to remind us to output the FCS and flag later. 	     */
name|done
operator|=
name|len
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|done
operator|&&
name|m
operator|->
name|m_next
operator|==
name|NULL
condition|)
block|{
name|u_char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|c
decl_stmt|;
name|u_char
name|endseq
index|[
literal|8
index|]
decl_stmt|;
comment|/* 		 * We may have to escape the bytes in the FCS. 		 */
name|p
operator|=
name|endseq
expr_stmt|;
name|c
operator|=
operator|~
name|sc
operator|->
name|sc_outfcs
operator|&
literal|0xFF
expr_stmt|;
if|if
condition|(
name|ESCAPE_P
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|PPP_ESCAPE
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
operator|^
name|PPP_TRANS
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
operator|(
operator|~
name|sc
operator|->
name|sc_outfcs
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
if|if
condition|(
name|ESCAPE_P
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|PPP_ESCAPE
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
operator|^
name|PPP_TRANS
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|PPP_FLAG
expr_stmt|;
comment|/* 		 * Try to output the FCS and flag.  If the bytes 		 * don't all fit, back out. 		 */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
for|for
control|(
name|q
operator|=
name|endseq
init|;
name|q
operator|<
name|p
condition|;
operator|++
name|q
control|)
if|if
condition|(
name|putc
argument_list|(
operator|*
name|q
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
block|{
name|done
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|q
operator|>
name|endseq
condition|;
operator|--
name|q
control|)
name|unputc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
condition|)
name|sc
operator|->
name|sc_stats
operator|.
name|ppp_obytes
operator|+=
name|q
operator|-
name|endseq
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|done
condition|)
block|{
comment|/* remember where we got to */
name|m
operator|->
name|m_data
operator|=
name|start
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
break|break;
block|}
comment|/* Finished with this mbuf; free it and move on. */
name|m
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* Finished a packet */
break|break;
block|}
name|sc
operator|->
name|sc_outfcs
operator|=
name|pppfcs
argument_list|(
name|sc
operator|->
name|sc_outfcs
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If m == NULL, we have finished a packet. 	 * If m != NULL, we've either done as much work this time 	 * as we need to, or else we've filled up the output queue. 	 */
name|sc
operator|->
name|sc_outm
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|m
condition|)
break|break;
block|}
comment|/* Call pppstart to start output again if necessary. */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|pppstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/*      * This timeout is needed for operation on a pseudo-tty,      * because the pty code doesn't call pppstart after it has      * drained the t_outq.      */
if|if
condition|(
operator|!
name|idle
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_TIMEOUT
operator|)
operator|==
literal|0
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_timo_ch
argument_list|,
literal|1
argument_list|,
name|ppp_timeout
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|SC_TIMEOUT
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This gets called when a received packet is placed on  * the inq, at splsoftnet. The pppd daemon is to be woken up to do a read().  */
end_comment

begin_function
specifier|static
name|void
name|pppasyncctlp
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* Put a placeholder byte in canq for ttselect()/ttnread(). */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|tp
operator|=
operator|(
expr|struct
name|tty
operator|*
operator|)
name|sc
operator|->
name|sc_devp
expr_stmt|;
name|putc
argument_list|(
literal|0
argument_list|,
operator|&
name|tp
operator|->
name|t_canq
argument_list|)
expr_stmt|;
name|ttwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start output on async tty interface.  If the transmit queue  * has drained sufficiently, arrange for pppasyncstart to be  * called later at splsoftnet.  * Called at spltty or higher.  */
end_comment

begin_function
specifier|static
name|int
name|pppstart
parameter_list|(
name|tp
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ppp_softc
operator|*
operator|)
name|tp
operator|->
name|t_lsc
decl_stmt|;
comment|/*      * Call output process whether or not there is any output.      * We are being called in lieu of ttstart and must do what it would.      */
if|if
condition|(
name|tp
operator|->
name|t_oproc
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|tp
operator|->
name|t_oproc
call|)
argument_list|(
name|tp
argument_list|)
expr_stmt|;
comment|/*      * If the transmit queue has drained and the tty has not hung up      * or been disconnected from the ppp unit, then tell if_ppp.c that      * we need more output.      */
if|if
condition|(
name|CCOUNT
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
operator|<
name|PPP_LOWAT
operator|&&
operator|!
operator|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CONNECTED
operator|)
operator|==
literal|0
operator|)
operator|&&
name|sc
operator|!=
name|NULL
condition|)
block|{
name|ppp_restart
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Timeout routine - try to start some more output.  */
end_comment

begin_function
specifier|static
name|void
name|ppp_timeout
parameter_list|(
name|x
parameter_list|)
name|void
modifier|*
name|x
decl_stmt|;
block|{
name|struct
name|ppp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ppp_softc
operator|*
operator|)
name|x
decl_stmt|;
name|struct
name|tty
modifier|*
name|tp
init|=
operator|(
expr|struct
name|tty
operator|*
operator|)
name|sc
operator|->
name|sc_devp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_TIMEOUT
expr_stmt|;
name|pppstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate enough mbuf to handle current MRU.  */
end_comment

begin_function
specifier|static
name|void
name|pppgetm
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|mp
operator|=
operator|&
name|sc
operator|->
name|sc_m
expr_stmt|;
for|for
control|(
name|len
operator|=
name|sc
operator|->
name|sc_mru
operator|+
name|PPP_HDRLEN
operator|+
name|PPP_FCSLEN
init|;
name|len
operator|>
literal|0
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
operator|*
name|mp
operator|)
operator|==
name|NULL
condition|)
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
block|}
name|len
operator|-=
name|M_DATASIZE
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * tty interface receiver interrupt.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|paritytab
index|[
literal|8
index|]
init|=
block|{
literal|0x96696996
block|,
literal|0x69969669
block|,
literal|0x69969669
block|,
literal|0x96696996
block|,
literal|0x69969669
block|,
literal|0x96696996
block|,
literal|0x96696996
block|,
literal|0x69969669
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Called when character is available from device driver.  * Only guaranteed to be at splsofttty() or spltty()  * This is safe to be called while the upper half's netisr is preempted.  */
end_comment

begin_function
specifier|static
name|int
name|pppinput
parameter_list|(
name|c
parameter_list|,
name|tp
parameter_list|)
name|int
name|c
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|ilen
decl_stmt|,
name|s
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|ppp_softc
operator|*
operator|)
name|tp
operator|->
name|t_lsc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
operator|++
name|tk_nin
expr_stmt|;
operator|++
name|sc
operator|->
name|sc_stats
operator|.
name|ppp_ibytes
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|if_printf
argument_list|(
name|PPP2IFP
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|"no carrier\n"
argument_list|)
expr_stmt|;
goto|goto
name|flush
goto|;
block|}
if|if
condition|(
name|c
operator|&
name|TTY_ERRORMASK
condition|)
block|{
comment|/* framing error or overrun on this char - abort packet */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|if_printf
argument_list|(
name|PPP2IFP
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|"line error %x\n"
argument_list|,
name|c
operator|&
name|TTY_ERRORMASK
argument_list|)
expr_stmt|;
goto|goto
name|flush
goto|;
block|}
name|c
operator|&=
name|TTY_CHARMASK
expr_stmt|;
comment|/*      * Handle software flow control of output.      */
if|if
condition|(
name|tp
operator|->
name|t_iflag
operator|&
name|IXON
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|tp
operator|->
name|t_cc
index|[
name|VSTOP
index|]
operator|&&
name|tp
operator|->
name|t_cc
index|[
name|VSTOP
index|]
operator|!=
name|_POSIX_VDISABLE
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_TTSTOP
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_TTSTOP
expr_stmt|;
name|tp
operator|->
name|t_stop
argument_list|(
name|tp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|c
operator|==
name|tp
operator|->
name|t_cc
index|[
name|VSTART
index|]
operator|&&
name|tp
operator|->
name|t_cc
index|[
name|VSTART
index|]
operator|!=
name|_POSIX_VDISABLE
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_TTSTOP
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_oproc
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|tp
operator|->
name|t_oproc
call|)
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|0x80
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|SC_RCV_B7_1
expr_stmt|;
else|else
name|sc
operator|->
name|sc_flags
operator||=
name|SC_RCV_B7_0
expr_stmt|;
if|if
condition|(
name|paritytab
index|[
name|c
operator|>>
literal|5
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|0x1F
operator|)
operator|)
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|SC_RCV_ODDP
expr_stmt|;
else|else
name|sc
operator|->
name|sc_flags
operator||=
name|SC_RCV_EVNP
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_LOG_RAWIN
condition|)
name|ppplogchar
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|PPP_FLAG
condition|)
block|{
name|ilen
operator|=
name|sc
operator|->
name|sc_ilen
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rawin_count
operator|>
literal|0
condition|)
name|ppplogchar
argument_list|(
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * If SC_ESCAPED is set, then we've seen the packet 	 * abort sequence "}~". 	 */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
operator|(
name|SC_FLUSH
operator||
name|SC_ESCAPED
operator|)
operator|||
operator|(
name|ilen
operator|>
literal|0
operator|&&
name|sc
operator|->
name|sc_fcs
operator|!=
name|PPP_GOODFCS
operator|)
condition|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|SC_PKTLOST
expr_stmt|;
comment|/* note the dropped packet */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
operator|(
name|SC_FLUSH
operator||
name|SC_ESCAPED
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|if_printf
argument_list|(
name|PPP2IFP
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|"bad fcs %x, pkt len %d\n"
argument_list|,
name|sc
operator|->
name|sc_fcs
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
name|PPP2IFP
argument_list|(
name|sc
argument_list|)
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ppp_ierrors
operator|++
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
operator|(
name|SC_FLUSH
operator||
name|SC_ESCAPED
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ilen
operator|<
name|PPP_HDRLEN
operator|+
name|PPP_FCSLEN
condition|)
block|{
if|if
condition|(
name|ilen
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|if_printf
argument_list|(
name|PPP2IFP
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|"too short (%d)\n"
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|PPP2IFP
argument_list|(
name|sc
argument_list|)
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ppp_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|SC_PKTLOST
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* 	 * Remove FCS trailer.  Somewhat painful... 	 */
name|ilen
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_mc
operator|->
name|m_len
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|m
operator|=
name|sc
operator|->
name|sc_m
init|;
name|m
operator|->
name|m_next
operator|!=
name|sc
operator|->
name|sc_mc
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
empty_stmt|;
name|sc
operator|->
name|sc_mc
operator|=
name|m
expr_stmt|;
block|}
name|sc
operator|->
name|sc_mc
operator|->
name|m_len
operator|--
expr_stmt|;
comment|/* excise this mbuf chain */
name|m
operator|=
name|sc
operator|->
name|sc_m
expr_stmt|;
name|sc
operator|->
name|sc_m
operator|=
name|sc
operator|->
name|sc_mc
operator|->
name|m_next
expr_stmt|;
name|sc
operator|->
name|sc_mc
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|ppppktin
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|sc
operator|->
name|sc_flags
operator|&
name|SC_PKTLOST
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_PKTLOST
condition|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_PKTLOST
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|pppgetm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_FLUSH
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_LOG_FLUSH
condition|)
name|ppplogchar
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|c
operator|<
literal|0x20
operator|&&
operator|(
name|sc
operator|->
name|sc_rasyncmap
operator|&
operator|(
literal|1
operator|<<
name|c
operator|)
operator|)
condition|)
return|return
literal|0
return|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_ESCAPED
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_ESCAPED
expr_stmt|;
name|c
operator|^=
name|PPP_TRANS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|PPP_ESCAPE
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|SC_ESCAPED
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/*      * Initialize buffer on first octet received.      * First octet could be address or protocol (when compressing      * address/control).      * Second octet is control.      * Third octet is first or second (when compressing protocol)      * octet of protocol.      * Fourth octet is second octet of protocol.      */
if|if
condition|(
name|sc
operator|->
name|sc_ilen
operator|==
literal|0
condition|)
block|{
comment|/* reset the first input mbuf */
if|if
condition|(
name|sc
operator|->
name|sc_m
operator|==
name|NULL
condition|)
block|{
name|pppgetm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_m
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|if_printf
argument_list|(
name|PPP2IFP
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|"no input mbufs!\n"
argument_list|)
expr_stmt|;
goto|goto
name|flush
goto|;
block|}
block|}
name|m
operator|=
name|sc
operator|->
name|sc_m
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|M_DATASTART
argument_list|(
name|sc
operator|->
name|sc_m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mc
operator|=
name|m
expr_stmt|;
name|sc
operator|->
name|sc_mp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_fcs
operator|=
name|PPP_INITFCS
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|PPP_ALLSTATIONS
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_REJ_COMP_AC
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|if_printf
argument_list|(
name|PPP2IFP
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|"garbage received: 0x%x (need 0xFF)\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
goto|goto
name|flush
goto|;
block|}
operator|*
name|sc
operator|->
name|sc_mp
operator|++
operator|=
name|PPP_ALLSTATIONS
expr_stmt|;
operator|*
name|sc
operator|->
name|sc_mp
operator|++
operator|=
name|PPP_UI
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|+=
literal|2
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|sc_ilen
operator|==
literal|1
operator|&&
name|c
operator|!=
name|PPP_UI
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|if_printf
argument_list|(
name|PPP2IFP
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|"missing UI (0x3), got 0x%x\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
goto|goto
name|flush
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_ilen
operator|==
literal|2
operator|&&
operator|(
name|c
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
block|{
comment|/* a compressed protocol */
operator|*
name|sc
operator|->
name|sc_mp
operator|++
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_mc
operator|->
name|m_len
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_ilen
operator|==
literal|3
operator|&&
operator|(
name|c
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|if_printf
argument_list|(
name|PPP2IFP
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|"bad protocol %x\n"
argument_list|,
operator|(
name|sc
operator|->
name|sc_mp
index|[
operator|-
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
name|c
argument_list|)
expr_stmt|;
goto|goto
name|flush
goto|;
block|}
comment|/* packet beyond configured mru? */
if|if
condition|(
operator|++
name|sc
operator|->
name|sc_ilen
operator|>
name|sc
operator|->
name|sc_mru
operator|+
name|PPP_HDRLEN
operator|+
name|PPP_FCSLEN
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|if_printf
argument_list|(
name|PPP2IFP
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|"packet too big\n"
argument_list|)
expr_stmt|;
goto|goto
name|flush
goto|;
block|}
comment|/* is this mbuf full? */
name|m
operator|=
name|sc
operator|->
name|sc_mc
expr_stmt|;
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_next
operator|==
name|NULL
condition|)
block|{
name|pppgetm
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_next
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|if_printf
argument_list|(
name|PPP2IFP
argument_list|(
name|sc
argument_list|)
argument_list|,
literal|"too few input mbufs!\n"
argument_list|)
expr_stmt|;
goto|goto
name|flush
goto|;
block|}
block|}
name|sc
operator|->
name|sc_mc
operator|=
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|M_DATASTART
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
operator|++
name|m
operator|->
name|m_len
expr_stmt|;
operator|*
name|sc
operator|->
name|sc_mp
operator|++
operator|=
name|c
expr_stmt|;
name|sc
operator|->
name|sc_fcs
operator|=
name|PPP_FCS
argument_list|(
name|sc
operator|->
name|sc_fcs
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|flush
label|:
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_FLUSH
operator|)
condition|)
block|{
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
name|PPP2IFP
argument_list|(
name|sc
argument_list|)
operator|->
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ppp_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|SC_FLUSH
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_LOG_FLUSH
condition|)
name|ppplogchar
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_DUMP_BYTES
value|128
end_define

begin_function
specifier|static
name|void
name|ppplogchar
parameter_list|(
name|sc
parameter_list|,
name|c
parameter_list|)
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
name|sc
operator|->
name|sc_rawin
index|[
name|sc
operator|->
name|sc_rawin_count
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rawin_count
operator|>=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rawin
argument_list|)
operator|||
operator|(
name|c
operator|<
literal|0
operator|&&
name|sc
operator|->
name|sc_rawin_count
operator|>
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s input: %*D"
argument_list|,
name|PPP2IFP
argument_list|(
name|sc
argument_list|)
operator|->
name|if_xname
argument_list|,
name|sc
operator|->
name|sc_rawin_count
argument_list|,
name|sc
operator|->
name|sc_rawin
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rawin_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

end_unit

