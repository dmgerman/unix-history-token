begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2014-2017, Matthew Macy<mmacy@nextbsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  *  1. Redistributions of source code must retain the above copyright notice,  *     this list of conditions and the following disclaimer.  *  *  2. Neither the name of Matthew Macy nor the names of its  *     contributors may be used to endorse or promote products derived from  *     this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_acpi.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/mp_ring.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_lro.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/led/led.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pci_private.h>
end_include

begin_include
include|#
directive|include
file|<net/iflib.h>
end_include

begin_include
include|#
directive|include
file|"ifdi_if.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/memdesc.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_include
include|#
directive|include
file|<x86/include/busdma_impl.h>
end_include

begin_include
include|#
directive|include
file|<x86/iommu/busdma_dmar.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/bitstring.h>
end_include

begin_comment
comment|/*  * enable accounting of every mbuf as it comes in to and goes out of  * iflib's software descriptor references  */
end_comment

begin_define
define|#
directive|define
name|MEMORY_LOGGING
value|0
end_define

begin_comment
comment|/*  * Enable mbuf vectors for compressing long mbuf chains  */
end_comment

begin_comment
comment|/*  * NB:  * - Prefetching in tx cleaning should perhaps be a tunable. The distance ahead  *   we prefetch needs to be determined by the time spent in m_free vis a vis  *   the cost of a prefetch. This will of course vary based on the workload:  *      - NFLX's m_free path is dominated by vm-based M_EXT manipulation which  *        is quite expensive, thus suggesting very little prefetch.  *      - small packet forwarding which is just returning a single mbuf to  *        UMA will typically be very fast vis a vis the cost of a memory  *        access.  */
end_comment

begin_comment
comment|/*  * File organization:  *  - private structures  *  - iflib private utility functions  *  - ifnet functions  *  - vlan registry and other exported functions  *  - iflib public core functions  *  *  */
end_comment

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_IFLIB
argument_list|,
literal|"iflib"
argument_list|,
literal|"ifnet library"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct_decl
struct_decl|struct
name|iflib_txq
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|struct
name|iflib_txq
modifier|*
name|iflib_txq_t
typedef|;
end_typedef

begin_struct_decl
struct_decl|struct
name|iflib_rxq
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|struct
name|iflib_rxq
modifier|*
name|iflib_rxq_t
typedef|;
end_typedef

begin_struct_decl
struct_decl|struct
name|iflib_fl
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|struct
name|iflib_fl
modifier|*
name|iflib_fl_t
typedef|;
end_typedef

begin_struct_decl
struct_decl|struct
name|iflib_ctx
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
struct|struct
name|iflib_filter_info
block|{
name|driver_filter_t
modifier|*
name|ifi_filter
decl_stmt|;
name|void
modifier|*
name|ifi_filter_arg
decl_stmt|;
name|struct
name|grouptask
modifier|*
name|ifi_task
decl_stmt|;
name|void
modifier|*
name|ifi_ctx
decl_stmt|;
block|}
typedef|*
name|iflib_filter_info_t
typedef|;
end_typedef

begin_struct
struct|struct
name|iflib_ctx
block|{
name|KOBJ_FIELDS
expr_stmt|;
comment|/*    * Pointer to hardware driver's softc    */
name|void
modifier|*
name|ifc_softc
decl_stmt|;
name|device_t
name|ifc_dev
decl_stmt|;
name|if_t
name|ifc_ifp
decl_stmt|;
name|cpuset_t
name|ifc_cpus
decl_stmt|;
name|if_shared_ctx_t
name|ifc_sctx
decl_stmt|;
name|struct
name|if_softc_ctx
name|ifc_softc_ctx
decl_stmt|;
name|struct
name|mtx
name|ifc_mtx
decl_stmt|;
name|uint16_t
name|ifc_nhwtxqs
decl_stmt|;
name|uint16_t
name|ifc_nhwrxqs
decl_stmt|;
name|iflib_txq_t
name|ifc_txqs
decl_stmt|;
name|iflib_rxq_t
name|ifc_rxqs
decl_stmt|;
name|uint32_t
name|ifc_if_flags
decl_stmt|;
name|uint32_t
name|ifc_flags
decl_stmt|;
name|uint32_t
name|ifc_max_fl_buf_size
decl_stmt|;
name|int
name|ifc_in_detach
decl_stmt|;
name|int
name|ifc_link_state
decl_stmt|;
name|int
name|ifc_link_irq
decl_stmt|;
name|int
name|ifc_watchdog_events
decl_stmt|;
name|struct
name|cdev
modifier|*
name|ifc_led_dev
decl_stmt|;
name|struct
name|resource
modifier|*
name|ifc_msix_mem
decl_stmt|;
name|struct
name|if_irq
name|ifc_legacy_irq
decl_stmt|;
name|struct
name|grouptask
name|ifc_admin_task
decl_stmt|;
name|struct
name|grouptask
name|ifc_vflr_task
decl_stmt|;
name|struct
name|iflib_filter_info
name|ifc_filter_info
decl_stmt|;
name|struct
name|ifmedia
name|ifc_media
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|ifc_sysctl_node
decl_stmt|;
name|uint16_t
name|ifc_sysctl_ntxqs
decl_stmt|;
name|uint16_t
name|ifc_sysctl_nrxqs
decl_stmt|;
name|uint16_t
name|ifc_sysctl_qs_eq_override
decl_stmt|;
name|qidx_t
name|ifc_sysctl_ntxds
index|[
literal|8
index|]
decl_stmt|;
name|qidx_t
name|ifc_sysctl_nrxds
index|[
literal|8
index|]
decl_stmt|;
name|struct
name|if_txrx
name|ifc_txrx
decl_stmt|;
define|#
directive|define
name|isc_txd_encap
value|ifc_txrx.ift_txd_encap
define|#
directive|define
name|isc_txd_flush
value|ifc_txrx.ift_txd_flush
define|#
directive|define
name|isc_txd_credits_update
value|ifc_txrx.ift_txd_credits_update
define|#
directive|define
name|isc_rxd_available
value|ifc_txrx.ift_rxd_available
define|#
directive|define
name|isc_rxd_pkt_get
value|ifc_txrx.ift_rxd_pkt_get
define|#
directive|define
name|isc_rxd_refill
value|ifc_txrx.ift_rxd_refill
define|#
directive|define
name|isc_rxd_flush
value|ifc_txrx.ift_rxd_flush
define|#
directive|define
name|isc_rxd_refill
value|ifc_txrx.ift_rxd_refill
define|#
directive|define
name|isc_rxd_refill
value|ifc_txrx.ift_rxd_refill
define|#
directive|define
name|isc_legacy_intr
value|ifc_txrx.ift_legacy_intr
name|eventhandler_tag
name|ifc_vlan_attach_event
decl_stmt|;
name|eventhandler_tag
name|ifc_vlan_detach_event
decl_stmt|;
name|uint8_t
name|ifc_mac
index|[
name|ETHER_ADDR_LEN
index|]
decl_stmt|;
name|char
name|ifc_mtx_name
index|[
literal|16
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|void
modifier|*
name|iflib_get_softc
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
return|return
operator|(
name|ctx
operator|->
name|ifc_softc
operator|)
return|;
block|}
end_function

begin_function
name|device_t
name|iflib_get_dev
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
return|return
operator|(
name|ctx
operator|->
name|ifc_dev
operator|)
return|;
block|}
end_function

begin_function
name|if_t
name|iflib_get_ifp
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
return|return
operator|(
name|ctx
operator|->
name|ifc_ifp
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|ifmedia
modifier|*
name|iflib_get_media
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
return|return
operator|(
operator|&
name|ctx
operator|->
name|ifc_media
operator|)
return|;
block|}
end_function

begin_function
name|void
name|iflib_set_mac
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|uint8_t
name|mac
index|[
name|ETHER_ADDR_LEN
index|]
parameter_list|)
block|{
name|bcopy
argument_list|(
name|mac
argument_list|,
name|ctx
operator|->
name|ifc_mac
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|if_softc_ctx_t
name|iflib_get_softc_ctx
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
return|return
operator|(
operator|&
name|ctx
operator|->
name|ifc_softc_ctx
operator|)
return|;
block|}
end_function

begin_function
name|if_shared_ctx_t
name|iflib_get_sctx
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
return|return
operator|(
name|ctx
operator|->
name|ifc_sctx
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|IP_ALIGNED
parameter_list|(
name|m
parameter_list|)
value|((((uintptr_t)(m)->m_data)& 0x3) == 0x2)
end_define

begin_define
define|#
directive|define
name|CACHE_PTR_INCREMENT
value|(CACHE_LINE_SIZE/sizeof(void*))
end_define

begin_define
define|#
directive|define
name|CACHE_PTR_NEXT
parameter_list|(
name|ptr
parameter_list|)
value|((void *)(((uintptr_t)(ptr)+CACHE_LINE_SIZE-1)& (CACHE_LINE_SIZE-1)))
end_define

begin_define
define|#
directive|define
name|LINK_ACTIVE
parameter_list|(
name|ctx
parameter_list|)
value|((ctx)->ifc_link_state == LINK_STATE_UP)
end_define

begin_define
define|#
directive|define
name|CTX_IS_VF
parameter_list|(
name|ctx
parameter_list|)
value|((ctx)->ifc_sctx->isc_flags& IFLIB_IS_VF)
end_define

begin_define
define|#
directive|define
name|RX_SW_DESC_MAP_CREATED
value|(1<< 0)
end_define

begin_define
define|#
directive|define
name|TX_SW_DESC_MAP_CREATED
value|(1<< 1)
end_define

begin_define
define|#
directive|define
name|RX_SW_DESC_INUSE
value|(1<< 3)
end_define

begin_define
define|#
directive|define
name|TX_SW_DESC_MAPPED
value|(1<< 4)
end_define

begin_typedef
typedef|typedef
struct|struct
name|iflib_sw_rx_desc_array
block|{
name|bus_dmamap_t
modifier|*
name|ifsd_map
decl_stmt|;
comment|/* bus_dma maps for packet */
name|struct
name|mbuf
modifier|*
modifier|*
name|ifsd_m
decl_stmt|;
comment|/* pkthdr mbufs */
name|caddr_t
modifier|*
name|ifsd_cl
decl_stmt|;
comment|/* direct cluster pointer for rx */
name|uint8_t
modifier|*
name|ifsd_flags
decl_stmt|;
block|}
name|iflib_rxsd_array_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|iflib_sw_tx_desc_array
block|{
name|bus_dmamap_t
modifier|*
name|ifsd_map
decl_stmt|;
comment|/* bus_dma maps for packet */
name|struct
name|mbuf
modifier|*
modifier|*
name|ifsd_m
decl_stmt|;
comment|/* pkthdr mbufs */
name|uint8_t
modifier|*
name|ifsd_flags
decl_stmt|;
block|}
name|if_txsd_vec_t
typedef|;
end_typedef

begin_comment
comment|/* magic number that should be high enough for any hardware */
end_comment

begin_define
define|#
directive|define
name|IFLIB_MAX_TX_SEGS
value|128
end_define

begin_define
define|#
directive|define
name|IFLIB_MAX_RX_SEGS
value|32
end_define

begin_define
define|#
directive|define
name|IFLIB_RX_COPY_THRESH
value|128
end_define

begin_define
define|#
directive|define
name|IFLIB_MAX_RX_REFRESH
value|32
end_define

begin_comment
comment|/* The minimum descriptors per second before we start coalescing */
end_comment

begin_define
define|#
directive|define
name|IFLIB_MIN_DESC_SEC
value|16384
end_define

begin_define
define|#
directive|define
name|IFLIB_DEFAULT_TX_UPDATE_FREQ
value|16
end_define

begin_define
define|#
directive|define
name|IFLIB_QUEUE_IDLE
value|0
end_define

begin_define
define|#
directive|define
name|IFLIB_QUEUE_HUNG
value|1
end_define

begin_define
define|#
directive|define
name|IFLIB_QUEUE_WORKING
value|2
end_define

begin_comment
comment|/* maximum number of txqs that can share an rx interrupt */
end_comment

begin_define
define|#
directive|define
name|IFLIB_MAX_TX_SHARED_INTR
value|4
end_define

begin_comment
comment|/* this should really scale with ring size - this is a fairly arbitrary value */
end_comment

begin_define
define|#
directive|define
name|TX_BATCH_SIZE
value|32
end_define

begin_define
define|#
directive|define
name|IFLIB_RESTART_BUDGET
value|8
end_define

begin_define
define|#
directive|define
name|IFC_LEGACY
value|0x001
end_define

begin_define
define|#
directive|define
name|IFC_QFLUSH
value|0x002
end_define

begin_define
define|#
directive|define
name|IFC_MULTISEG
value|0x004
end_define

begin_define
define|#
directive|define
name|IFC_DMAR
value|0x008
end_define

begin_define
define|#
directive|define
name|IFC_SC_ALLOCATED
value|0x010
end_define

begin_define
define|#
directive|define
name|IFC_INIT_DONE
value|0x020
end_define

begin_define
define|#
directive|define
name|IFC_PREFETCH
value|0x040
end_define

begin_define
define|#
directive|define
name|IFC_DO_RESET
value|0x080
end_define

begin_define
define|#
directive|define
name|IFC_CHECK_HUNG
value|0x100
end_define

begin_define
define|#
directive|define
name|CSUM_OFFLOAD
value|(CSUM_IP_TSO|CSUM_IP6_TSO|CSUM_IP| \ 				 CSUM_IP_UDP|CSUM_IP_TCP|CSUM_IP_SCTP| \ 				 CSUM_IP6_UDP|CSUM_IP6_TCP|CSUM_IP6_SCTP)
end_define

begin_struct
struct|struct
name|iflib_txq
block|{
name|qidx_t
name|ift_in_use
decl_stmt|;
name|qidx_t
name|ift_cidx
decl_stmt|;
name|qidx_t
name|ift_cidx_processed
decl_stmt|;
name|qidx_t
name|ift_pidx
decl_stmt|;
name|uint8_t
name|ift_gen
decl_stmt|;
name|uint8_t
name|ift_br_offset
decl_stmt|;
name|uint16_t
name|ift_npending
decl_stmt|;
name|uint16_t
name|ift_db_pending
decl_stmt|;
name|uint16_t
name|ift_rs_pending
decl_stmt|;
comment|/* implicit pad */
name|uint8_t
name|ift_txd_size
index|[
literal|8
index|]
decl_stmt|;
name|uint64_t
name|ift_processed
decl_stmt|;
name|uint64_t
name|ift_cleaned
decl_stmt|;
name|uint64_t
name|ift_cleaned_prev
decl_stmt|;
if|#
directive|if
name|MEMORY_LOGGING
name|uint64_t
name|ift_enqueued
decl_stmt|;
name|uint64_t
name|ift_dequeued
decl_stmt|;
endif|#
directive|endif
name|uint64_t
name|ift_no_tx_dma_setup
decl_stmt|;
name|uint64_t
name|ift_no_desc_avail
decl_stmt|;
name|uint64_t
name|ift_mbuf_defrag_failed
decl_stmt|;
name|uint64_t
name|ift_mbuf_defrag
decl_stmt|;
name|uint64_t
name|ift_map_failed
decl_stmt|;
name|uint64_t
name|ift_txd_encap_efbig
decl_stmt|;
name|uint64_t
name|ift_pullups
decl_stmt|;
name|struct
name|mtx
name|ift_mtx
decl_stmt|;
name|struct
name|mtx
name|ift_db_mtx
decl_stmt|;
comment|/* constant values */
name|if_ctx_t
name|ift_ctx
decl_stmt|;
name|struct
name|ifmp_ring
modifier|*
name|ift_br
decl_stmt|;
name|struct
name|grouptask
name|ift_task
decl_stmt|;
name|qidx_t
name|ift_size
decl_stmt|;
name|uint16_t
name|ift_id
decl_stmt|;
name|struct
name|callout
name|ift_timer
decl_stmt|;
name|if_txsd_vec_t
name|ift_sds
decl_stmt|;
name|uint8_t
name|ift_qstatus
decl_stmt|;
name|uint8_t
name|ift_closed
decl_stmt|;
name|uint8_t
name|ift_update_freq
decl_stmt|;
name|struct
name|iflib_filter_info
name|ift_filter_info
decl_stmt|;
name|bus_dma_tag_t
name|ift_desc_tag
decl_stmt|;
name|bus_dma_tag_t
name|ift_tso_desc_tag
decl_stmt|;
name|iflib_dma_info_t
name|ift_ifdi
decl_stmt|;
define|#
directive|define
name|MTX_NAME_LEN
value|16
name|char
name|ift_mtx_name
index|[
name|MTX_NAME_LEN
index|]
decl_stmt|;
name|char
name|ift_db_mtx_name
index|[
name|MTX_NAME_LEN
index|]
decl_stmt|;
name|bus_dma_segment_t
name|ift_segs
index|[
name|IFLIB_MAX_TX_SEGS
index|]
name|__aligned
parameter_list|(
name|CACHE_LINE_SIZE
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|IFLIB_DIAGNOSTICS
name|uint64_t
name|ift_cpu_exec_count
index|[
literal|256
index|]
decl_stmt|;
endif|#
directive|endif
block|}
name|__aligned
argument_list|(
name|CACHE_LINE_SIZE
argument_list|)
struct|;
end_struct

begin_struct
struct|struct
name|iflib_fl
block|{
name|qidx_t
name|ifl_cidx
decl_stmt|;
name|qidx_t
name|ifl_pidx
decl_stmt|;
name|qidx_t
name|ifl_credits
decl_stmt|;
name|uint8_t
name|ifl_gen
decl_stmt|;
name|uint8_t
name|ifl_rxd_size
decl_stmt|;
if|#
directive|if
name|MEMORY_LOGGING
name|uint64_t
name|ifl_m_enqueued
decl_stmt|;
name|uint64_t
name|ifl_m_dequeued
decl_stmt|;
name|uint64_t
name|ifl_cl_enqueued
decl_stmt|;
name|uint64_t
name|ifl_cl_dequeued
decl_stmt|;
endif|#
directive|endif
comment|/* implicit pad */
name|bitstr_t
modifier|*
name|ifl_rx_bitmap
decl_stmt|;
name|qidx_t
name|ifl_fragidx
decl_stmt|;
comment|/* constant */
name|qidx_t
name|ifl_size
decl_stmt|;
name|uint16_t
name|ifl_buf_size
decl_stmt|;
name|uint16_t
name|ifl_cltype
decl_stmt|;
name|uma_zone_t
name|ifl_zone
decl_stmt|;
name|iflib_rxsd_array_t
name|ifl_sds
decl_stmt|;
name|iflib_rxq_t
name|ifl_rxq
decl_stmt|;
name|uint8_t
name|ifl_id
decl_stmt|;
name|bus_dma_tag_t
name|ifl_desc_tag
decl_stmt|;
name|iflib_dma_info_t
name|ifl_ifdi
decl_stmt|;
name|uint64_t
name|ifl_bus_addrs
index|[
name|IFLIB_MAX_RX_REFRESH
index|]
name|__aligned
parameter_list|(
name|CACHE_LINE_SIZE
parameter_list|)
function_decl|;
name|caddr_t
name|ifl_vm_addrs
index|[
name|IFLIB_MAX_RX_REFRESH
index|]
decl_stmt|;
name|qidx_t
name|ifl_rxd_idxs
index|[
name|IFLIB_MAX_RX_REFRESH
index|]
decl_stmt|;
block|}
name|__aligned
argument_list|(
name|CACHE_LINE_SIZE
argument_list|)
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|qidx_t
name|get_inuse
parameter_list|(
name|int
name|size
parameter_list|,
name|qidx_t
name|cidx
parameter_list|,
name|qidx_t
name|pidx
parameter_list|,
name|uint8_t
name|gen
parameter_list|)
block|{
name|qidx_t
name|used
decl_stmt|;
if|if
condition|(
name|pidx
operator|>
name|cidx
condition|)
name|used
operator|=
name|pidx
operator|-
name|cidx
expr_stmt|;
elseif|else
if|if
condition|(
name|pidx
operator|<
name|cidx
condition|)
name|used
operator|=
name|size
operator|-
name|cidx
operator|+
name|pidx
expr_stmt|;
elseif|else
if|if
condition|(
name|gen
operator|==
literal|0
operator|&&
name|pidx
operator|==
name|cidx
condition|)
name|used
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|gen
operator|==
literal|1
operator|&&
name|pidx
operator|==
name|cidx
condition|)
name|used
operator|=
name|size
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"bad state"
argument_list|)
expr_stmt|;
return|return
operator|(
name|used
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TXQ_AVAIL
parameter_list|(
name|txq
parameter_list|)
value|(txq->ift_size - get_inuse(txq->ift_size, txq->ift_cidx, txq->ift_pidx, txq->ift_gen))
end_define

begin_define
define|#
directive|define
name|IDXDIFF
parameter_list|(
name|head
parameter_list|,
name|tail
parameter_list|,
name|wrap
parameter_list|)
define|\
value|((head)>= (tail) ? (head) - (tail) : (wrap) - (tail) + (head))
end_define

begin_struct
struct|struct
name|iflib_rxq
block|{
comment|/* If there is a separate completion queue - 	 * these are the cq cidx and pidx. Otherwise 	 * these are unused. 	 */
name|qidx_t
name|ifr_size
decl_stmt|;
name|qidx_t
name|ifr_cq_cidx
decl_stmt|;
name|qidx_t
name|ifr_cq_pidx
decl_stmt|;
name|uint8_t
name|ifr_cq_gen
decl_stmt|;
name|uint8_t
name|ifr_fl_offset
decl_stmt|;
name|if_ctx_t
name|ifr_ctx
decl_stmt|;
name|iflib_fl_t
name|ifr_fl
decl_stmt|;
name|uint64_t
name|ifr_rx_irq
decl_stmt|;
name|uint16_t
name|ifr_id
decl_stmt|;
name|uint8_t
name|ifr_lro_enabled
decl_stmt|;
name|uint8_t
name|ifr_nfl
decl_stmt|;
name|uint8_t
name|ifr_ntxqirq
decl_stmt|;
name|uint8_t
name|ifr_txqid
index|[
name|IFLIB_MAX_TX_SHARED_INTR
index|]
decl_stmt|;
name|struct
name|lro_ctrl
name|ifr_lc
decl_stmt|;
name|struct
name|grouptask
name|ifr_task
decl_stmt|;
name|struct
name|iflib_filter_info
name|ifr_filter_info
decl_stmt|;
name|iflib_dma_info_t
name|ifr_ifdi
decl_stmt|;
comment|/* dynamically allocate if any drivers need a value substantially larger than this */
name|struct
name|if_rxd_frag
name|ifr_frags
index|[
name|IFLIB_MAX_RX_SEGS
index|]
name|__aligned
parameter_list|(
name|CACHE_LINE_SIZE
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|IFLIB_DIAGNOSTICS
name|uint64_t
name|ifr_cpu_exec_count
index|[
literal|256
index|]
decl_stmt|;
endif|#
directive|endif
block|}
name|__aligned
argument_list|(
name|CACHE_LINE_SIZE
argument_list|)
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|if_rxsd
block|{
name|caddr_t
modifier|*
name|ifsd_cl
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|ifsd_m
decl_stmt|;
name|iflib_fl_t
name|ifsd_fl
decl_stmt|;
name|qidx_t
name|ifsd_cidx
decl_stmt|;
block|}
typedef|*
name|if_rxsd_t
typedef|;
end_typedef

begin_comment
comment|/* multiple of word size */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__LP64__
end_ifdef

begin_define
define|#
directive|define
name|PKT_INFO_SIZE
value|6
end_define

begin_define
define|#
directive|define
name|RXD_INFO_SIZE
value|5
end_define

begin_define
define|#
directive|define
name|PKT_TYPE
value|uint64_t
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PKT_INFO_SIZE
value|11
end_define

begin_define
define|#
directive|define
name|RXD_INFO_SIZE
value|8
end_define

begin_define
define|#
directive|define
name|PKT_TYPE
value|uint32_t
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PKT_LOOP_BOUND
value|((PKT_INFO_SIZE/3)*3)
end_define

begin_define
define|#
directive|define
name|RXD_LOOP_BOUND
value|((RXD_INFO_SIZE/4)*4)
end_define

begin_typedef
typedef|typedef
struct|struct
name|if_pkt_info_pad
block|{
name|PKT_TYPE
name|pkt_val
index|[
name|PKT_INFO_SIZE
index|]
decl_stmt|;
block|}
typedef|*
name|if_pkt_info_pad_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|if_rxd_info_pad
block|{
name|PKT_TYPE
name|rxd_val
index|[
name|RXD_INFO_SIZE
index|]
decl_stmt|;
block|}
typedef|*
name|if_rxd_info_pad_t
typedef|;
end_typedef

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|if_pkt_info_pad
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|if_pkt_info
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|if_rxd_info_pad
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|if_rxd_info
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
specifier|inline
name|void
name|pkt_info_zero
parameter_list|(
name|if_pkt_info_t
name|pi
parameter_list|)
block|{
name|if_pkt_info_pad_t
name|pi_pad
decl_stmt|;
name|pi_pad
operator|=
operator|(
name|if_pkt_info_pad_t
operator|)
name|pi
expr_stmt|;
name|pi_pad
operator|->
name|pkt_val
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|pi_pad
operator|->
name|pkt_val
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|pi_pad
operator|->
name|pkt_val
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|pi_pad
operator|->
name|pkt_val
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|pi_pad
operator|->
name|pkt_val
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|pi_pad
operator|->
name|pkt_val
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|__LP64__
name|pi_pad
operator|->
name|pkt_val
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|pi_pad
operator|->
name|pkt_val
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
name|pi_pad
operator|->
name|pkt_val
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|pi_pad
operator|->
name|pkt_val
index|[
literal|9
index|]
operator|=
literal|0
expr_stmt|;
name|pi_pad
operator|->
name|pkt_val
index|[
literal|10
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|rxd_info_zero
parameter_list|(
name|if_rxd_info_t
name|ri
parameter_list|)
block|{
name|if_rxd_info_pad_t
name|ri_pad
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ri_pad
operator|=
operator|(
name|if_rxd_info_pad_t
operator|)
name|ri
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RXD_LOOP_BOUND
condition|;
name|i
operator|+=
literal|4
control|)
block|{
name|ri_pad
operator|->
name|rxd_val
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|ri_pad
operator|->
name|rxd_val
index|[
name|i
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|ri_pad
operator|->
name|rxd_val
index|[
name|i
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ri_pad
operator|->
name|rxd_val
index|[
name|i
operator|+
literal|3
index|]
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__LP64__
name|ri_pad
operator|->
name|rxd_val
index|[
name|RXD_INFO_SIZE
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Only allow a single packet to take up most 1/nth of the tx ring  */
end_comment

begin_define
define|#
directive|define
name|MAX_SINGLE_PACKET_FRACTION
value|12
end_define

begin_define
define|#
directive|define
name|IF_BAD_DMA
value|(bus_addr_t)-1
end_define

begin_define
define|#
directive|define
name|CTX_ACTIVE
parameter_list|(
name|ctx
parameter_list|)
value|((if_getdrvflags((ctx)->ifc_ifp)& IFF_DRV_RUNNING))
end_define

begin_define
define|#
directive|define
name|CTX_LOCK_INIT
parameter_list|(
name|_sc
parameter_list|,
name|_name
parameter_list|)
value|mtx_init(&(_sc)->ifc_mtx, _name, "iflib ctx lock", MTX_DEF)
end_define

begin_define
define|#
directive|define
name|CTX_LOCK
parameter_list|(
name|ctx
parameter_list|)
value|mtx_lock(&(ctx)->ifc_mtx)
end_define

begin_define
define|#
directive|define
name|CTX_UNLOCK
parameter_list|(
name|ctx
parameter_list|)
value|mtx_unlock(&(ctx)->ifc_mtx)
end_define

begin_define
define|#
directive|define
name|CTX_LOCK_DESTROY
parameter_list|(
name|ctx
parameter_list|)
value|mtx_destroy(&(ctx)->ifc_mtx)
end_define

begin_define
define|#
directive|define
name|CALLOUT_LOCK
parameter_list|(
name|txq
parameter_list|)
value|mtx_lock(&txq->ift_mtx)
end_define

begin_define
define|#
directive|define
name|CALLOUT_UNLOCK
parameter_list|(
name|txq
parameter_list|)
value|mtx_unlock(&txq->ift_mtx)
end_define

begin_comment
comment|/* Our boot-time initialization hook */
end_comment

begin_function_decl
specifier|static
name|int
name|iflib_module_event_handler
parameter_list|(
name|module_t
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|moduledata_t
name|iflib_moduledata
init|=
block|{
literal|"iflib"
block|,
name|iflib_module_event_handler
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|iflib
argument_list|,
name|iflib_moduledata
argument_list|,
name|SI_SUB_INIT_IF
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|iflib
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|iflib
argument_list|,
name|pci
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|iflib
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TASKQGROUP_DEFINE
argument_list|(
name|if_io_tqg
argument_list|,
name|mp_ncpus
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TASKQGROUP_DEFINE
argument_list|(
name|if_config_tqg
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|IFLIB_DEBUG_COUNTERS
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|INVARIANTS
end_ifdef

begin_define
define|#
directive|define
name|IFLIB_DEBUG_COUNTERS
value|1
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IFLIB_DEBUG_COUNTERS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !INVARIANTS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_net
argument_list|,
name|OID_AUTO
argument_list|,
name|iflib
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"iflib driver parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * XXX need to ensure that this can't accidentally cause the head to be moved backwards   */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iflib_min_tx_latency
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|min_tx_latency
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|iflib_min_tx_latency
argument_list|,
literal|0
argument_list|,
literal|"minimize transmit latency at the possible expense of throughput"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_no_tx_batch
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|no_tx_batch
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|iflib_no_tx_batch
argument_list|,
literal|0
argument_list|,
literal|"minimize transmit latency at the possible expense of throughput"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|IFLIB_DEBUG_COUNTERS
end_if

begin_decl_stmt
specifier|static
name|int
name|iflib_tx_seen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_tx_sent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_tx_encap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_rx_allocs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_fl_refills
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_fl_refills_large
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_tx_frees
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_seen
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_tx_seen
argument_list|,
literal|0
argument_list|,
literal|"# tx mbufs seen"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_sent
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_tx_sent
argument_list|,
literal|0
argument_list|,
literal|"# tx mbufs sent"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_encap
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_tx_encap
argument_list|,
literal|0
argument_list|,
literal|"# tx mbufs encapped"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|tx_frees
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_tx_frees
argument_list|,
literal|0
argument_list|,
literal|"# tx frees"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_allocs
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_rx_allocs
argument_list|,
literal|0
argument_list|,
literal|"# rx allocations"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|fl_refills
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_fl_refills
argument_list|,
literal|0
argument_list|,
literal|"# refills"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|fl_refills_large
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_fl_refills_large
argument_list|,
literal|0
argument_list|,
literal|"# large refills"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_txq_drain_flushing
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_txq_drain_oactive
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_txq_drain_notready
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_txq_drain_encapfail
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|txq_drain_flushing
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_txq_drain_flushing
argument_list|,
literal|0
argument_list|,
literal|"# drain flushes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|txq_drain_oactive
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_txq_drain_oactive
argument_list|,
literal|0
argument_list|,
literal|"# drain oactives"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|txq_drain_notready
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_txq_drain_notready
argument_list|,
literal|0
argument_list|,
literal|"# drain notready"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|txq_drain_encapfail
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_txq_drain_encapfail
argument_list|,
literal|0
argument_list|,
literal|"# drain encap fails"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_encap_load_mbuf_fail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_encap_txq_avail_fail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_encap_txd_encap_fail
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|encap_load_mbuf_fail
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_encap_load_mbuf_fail
argument_list|,
literal|0
argument_list|,
literal|"# busdma load failures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|encap_txq_avail_fail
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_encap_txq_avail_fail
argument_list|,
literal|0
argument_list|,
literal|"# txq avail failures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|encap_txd_encap_fail
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_encap_txd_encap_fail
argument_list|,
literal|0
argument_list|,
literal|"# driver encap failures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_task_fn_rxs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_rx_intr_enables
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_fast_intrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_intr_link
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_intr_msix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_rx_unavail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_rx_ctx_inactive
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_rx_zero_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_rx_if_input
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_rx_mbuf_null
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_rxd_flush
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|iflib_verbose_debug
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|intr_link
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_intr_link
argument_list|,
literal|0
argument_list|,
literal|"# intr link calls"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|intr_msix
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_intr_msix
argument_list|,
literal|0
argument_list|,
literal|"# intr msix calls"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|task_fn_rx
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_task_fn_rxs
argument_list|,
literal|0
argument_list|,
literal|"# task_fn_rx calls"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_intr_enables
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_rx_intr_enables
argument_list|,
literal|0
argument_list|,
literal|"# rx intr enables"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|fast_intrs
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_fast_intrs
argument_list|,
literal|0
argument_list|,
literal|"# fast_intr calls"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_unavail
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_rx_unavail
argument_list|,
literal|0
argument_list|,
literal|"# times rxeof called with no available data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_ctx_inactive
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_rx_ctx_inactive
argument_list|,
literal|0
argument_list|,
literal|"# times rxeof called with inactive context"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_zero_len
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_rx_zero_len
argument_list|,
literal|0
argument_list|,
literal|"# times rxeof saw zero len mbuf"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_if_input
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_rx_if_input
argument_list|,
literal|0
argument_list|,
literal|"# times rxeof called if_input"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|rx_mbuf_null
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_rx_mbuf_null
argument_list|,
literal|0
argument_list|,
literal|"# times rxeof got null mbuf"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|rxd_flush
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|iflib_rxd_flush
argument_list|,
literal|0
argument_list|,
literal|"# times rxd_flush called"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_iflib
argument_list|,
name|OID_AUTO
argument_list|,
name|verbose_debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|iflib_verbose_debug
argument_list|,
literal|0
argument_list|,
literal|"enable verbose debugging"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|DBG_COUNTER_INC
parameter_list|(
name|name
parameter_list|)
value|atomic_add_int(&(iflib_ ## name), 1)
end_define

begin_function
specifier|static
name|void
name|iflib_debug_reset
parameter_list|(
name|void
parameter_list|)
block|{
name|iflib_tx_seen
operator|=
name|iflib_tx_sent
operator|=
name|iflib_tx_encap
operator|=
name|iflib_rx_allocs
operator|=
name|iflib_fl_refills
operator|=
name|iflib_fl_refills_large
operator|=
name|iflib_tx_frees
operator|=
name|iflib_txq_drain_flushing
operator|=
name|iflib_txq_drain_oactive
operator|=
name|iflib_txq_drain_notready
operator|=
name|iflib_txq_drain_encapfail
operator|=
name|iflib_encap_load_mbuf_fail
operator|=
name|iflib_encap_txq_avail_fail
operator|=
name|iflib_encap_txd_encap_fail
operator|=
name|iflib_task_fn_rxs
operator|=
name|iflib_rx_intr_enables
operator|=
name|iflib_fast_intrs
operator|=
name|iflib_intr_link
operator|=
name|iflib_intr_msix
operator|=
name|iflib_rx_unavail
operator|=
name|iflib_rx_ctx_inactive
operator|=
name|iflib_rx_zero_len
operator|=
name|iflib_rx_if_input
operator|=
name|iflib_rx_mbuf_null
operator|=
name|iflib_rxd_flush
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DBG_COUNTER_INC
parameter_list|(
name|name
parameter_list|)
end_define

begin_function
specifier|static
name|void
name|iflib_debug_reset
parameter_list|(
name|void
parameter_list|)
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IFLIB_DEBUG
value|0
end_define

begin_function_decl
specifier|static
name|void
name|iflib_tx_structures_free
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iflib_rx_structures_free
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iflib_queues_alloc
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iflib_tx_credits_update
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|iflib_txq_t
name|txq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iflib_rxd_avail
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|iflib_rxq_t
name|rxq
parameter_list|,
name|qidx_t
name|cidx
parameter_list|,
name|qidx_t
name|budget
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iflib_qset_structures_setup
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iflib_msix_init
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iflib_legacy_setup
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|driver_filter_t
name|filter
parameter_list|,
name|void
modifier|*
name|filterarg
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iflib_txq_check_drain
parameter_list|(
name|iflib_txq_t
name|txq
parameter_list|,
name|int
name|budget
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|iflib_txq_can_drain
parameter_list|(
name|struct
name|ifmp_ring
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|iflib_register
parameter_list|(
name|if_ctx_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iflib_init_locked
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iflib_add_device_sysctl_pre
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iflib_add_device_sysctl_post
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iflib_ifmp_purge
parameter_list|(
name|iflib_txq_t
name|txq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_iflib_pre_assert
parameter_list|(
name|if_softc_ctx_t
name|scctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iflib_stop
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|iflib_if_init_locked
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
end_ifndef

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|iflib_fixup_rx
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEV_NETMAP
end_ifdef

begin_include
include|#
directive|include
file|<sys/selinfo.h>
end_include

begin_include
include|#
directive|include
file|<net/netmap.h>
end_include

begin_include
include|#
directive|include
file|<dev/netmap/netmap_kern.h>
end_include

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|iflib
argument_list|,
name|netmap
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * device-specific sysctl variables:  *  * iflib_crcstrip: 0: keep CRC in rx frames (default), 1: strip it.  *	During regular operations the CRC is stripped, but on some  *	hardware reception of frames not multiple of 64 is slower,  *	so using crcstrip=0 helps in benchmarks.  *  * iflib_rx_miss, iflib_rx_miss_bufs:  *	count packets that might be missed due to lost interrupts.  */
end_comment

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_dev_netmap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The xl driver by default strips CRCs and we do not override it.  */
end_comment

begin_decl_stmt
name|int
name|iflib_crcstrip
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|iflib_crcstrip
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|iflib_crcstrip
argument_list|,
literal|1
argument_list|,
literal|"strip CRC on rx frames"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|iflib_rx_miss
decl_stmt|,
name|iflib_rx_miss_bufs
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|iflib_rx_miss
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|iflib_rx_miss
argument_list|,
literal|0
argument_list|,
literal|"potentially missed rx intr"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_dev_netmap
argument_list|,
name|OID_AUTO
argument_list|,
name|iflib_rx_miss_bufs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|iflib_rx_miss_bufs
argument_list|,
literal|0
argument_list|,
literal|"potentially missed rx intr bufs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Register/unregister. We are already under netmap lock.  * Only called on the first register or the last unregister.  */
end_comment

begin_function
specifier|static
name|int
name|iflib_netmap_register
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|if_ctx_t
name|ctx
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|status
decl_stmt|;
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|IFDI_INTR_DISABLE
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* Tell the stack that the interface is no longer active */
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
operator|(
name|IFF_DRV_RUNNING
operator||
name|IFF_DRV_OACTIVE
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|CTX_IS_VF
argument_list|(
name|ctx
argument_list|)
condition|)
name|IFDI_CRCSTRIP_SET
argument_list|(
name|ctx
argument_list|,
name|onoff
argument_list|,
name|iflib_crcstrip
argument_list|)
expr_stmt|;
comment|/* enable or disable flags and callbacks in na and ifp */
if|if
condition|(
name|onoff
condition|)
block|{
name|nm_set_native_flags
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nm_clear_native_flags
argument_list|(
name|na
argument_list|)
expr_stmt|;
block|}
name|iflib_stop
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|iflib_init_locked
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|IFDI_CRCSTRIP_SET
argument_list|(
name|ctx
argument_list|,
name|onoff
argument_list|,
name|iflib_crcstrip
argument_list|)
expr_stmt|;
comment|// XXX why twice ?
name|status
operator|=
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|nm_clear_native_flags
argument_list|(
name|na
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reconcile kernel and user view of the transmit ring.  *  * All information is in the kring.  * Userspace wants to send packets up to the one before kring->rhead,  * kernel knows kring->nr_hwcur is the first unsent packet.  *  * Here we push packets out (as many as possible), and possibly  * reclaim buffers from previously completed transmission.  *  * The caller (netmap) guarantees that there is only one instance  * running at any time. Any interference with other driver  * methods should be handled by the individual drivers.  */
end_comment

begin_function
specifier|static
name|int
name|iflib_netmap_txsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|kring
operator|->
name|na
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|u_int
name|nm_i
decl_stmt|;
comment|/* index into the netmap ring */
name|u_int
name|nic_i
decl_stmt|;
comment|/* index into the NIC ring */
name|u_int
name|n
decl_stmt|;
name|u_int
specifier|const
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
specifier|const
name|head
init|=
name|kring
operator|->
name|rhead
decl_stmt|;
name|struct
name|if_pkt_info
name|pi
decl_stmt|;
comment|/* 	 * interrupts on every tx packet are expensive so request 	 * them every half ring, or where NS_REPORT is set 	 */
name|u_int
name|report_frequency
init|=
name|kring
operator|->
name|nkr_num_slots
operator|>>
literal|1
decl_stmt|;
comment|/* device-specific */
name|if_ctx_t
name|ctx
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|iflib_txq_t
name|txq
init|=
operator|&
name|ctx
operator|->
name|ifc_txqs
index|[
name|kring
operator|->
name|ring_id
index|]
decl_stmt|;
if|if
condition|(
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
condition|)
name|bus_dmamap_sync
argument_list|(
name|txq
operator|->
name|ift_desc_tag
argument_list|,
name|txq
operator|->
name|ift_ifdi
operator|->
name|idi_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * First part: process new packets to send. 	 * nm_i is the current index in the netmap ring, 	 * nic_i is the corresponding index in the NIC ring. 	 * 	 * If we have packets to send (nm_i != head) 	 * iterate over the netmap ring, fetch length and update 	 * the corresponding slot in the NIC ring. Some drivers also 	 * need to update the buffer's physical address in the NIC slot 	 * even NS_BUF_CHANGED is not set (PNMB computes the addresses). 	 * 	 * The netmap_reload_map() calls is especially expensive, 	 * even when (as in this case) the tag is 0, so do only 	 * when the buffer has actually changed. 	 * 	 * If possible do not set the report/intr bit on all slots, 	 * but only a few times per ring or when NS_REPORT is set. 	 * 	 * Finally, on 10G and faster drivers, it might be useful 	 * to prefetch the next slot and txr entry. 	 */
name|nm_i
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
name|pkt_info_zero
argument_list|(
operator|&
name|pi
argument_list|)
expr_stmt|;
name|pi
operator|.
name|ipi_segs
operator|=
name|txq
operator|->
name|ift_segs
expr_stmt|;
name|pi
operator|.
name|ipi_qsidx
operator|=
name|kring
operator|->
name|ring_id
expr_stmt|;
if|if
condition|(
name|nm_i
operator|!=
name|head
condition|)
block|{
comment|/* we have new packets to send */
name|nic_i
operator|=
name|netmap_idx_k2n
argument_list|(
name|kring
argument_list|,
name|nm_i
argument_list|)
expr_stmt|;
name|__builtin_prefetch
argument_list|(
operator|&
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
argument_list|)
expr_stmt|;
name|__builtin_prefetch
argument_list|(
operator|&
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_m
index|[
name|nic_i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
condition|)
name|__builtin_prefetch
argument_list|(
operator|&
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
index|[
name|nic_i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|nm_i
operator|!=
name|head
condition|;
name|n
operator|++
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
decl_stmt|;
name|u_int
name|len
init|=
name|slot
operator|->
name|len
decl_stmt|;
name|uint64_t
name|paddr
decl_stmt|;
name|void
modifier|*
name|addr
init|=
name|PNMB
argument_list|(
name|na
argument_list|,
name|slot
argument_list|,
operator|&
name|paddr
argument_list|)
decl_stmt|;
name|int
name|flags
init|=
operator|(
name|slot
operator|->
name|flags
operator|&
name|NS_REPORT
operator|||
name|nic_i
operator|==
literal|0
operator|||
name|nic_i
operator|==
name|report_frequency
operator|)
condition|?
name|IPI_TX_INTR
else|:
literal|0
decl_stmt|;
comment|/* device-specific */
name|pi
operator|.
name|ipi_len
operator|=
name|len
expr_stmt|;
name|pi
operator|.
name|ipi_segs
index|[
literal|0
index|]
operator|.
name|ds_addr
operator|=
name|paddr
expr_stmt|;
name|pi
operator|.
name|ipi_segs
index|[
literal|0
index|]
operator|.
name|ds_len
operator|=
name|len
expr_stmt|;
name|pi
operator|.
name|ipi_nsegs
operator|=
literal|1
expr_stmt|;
name|pi
operator|.
name|ipi_ndescs
operator|=
literal|0
expr_stmt|;
name|pi
operator|.
name|ipi_pidx
operator|=
name|nic_i
expr_stmt|;
name|pi
operator|.
name|ipi_flags
operator|=
name|flags
expr_stmt|;
comment|/* Fill the slot in the NIC ring. */
name|ctx
operator|->
name|isc_txd_encap
argument_list|(
name|ctx
operator|->
name|ifc_softc
argument_list|,
operator|&
name|pi
argument_list|)
expr_stmt|;
comment|/* prefetch for next round */
name|__builtin_prefetch
argument_list|(
operator|&
name|ring
operator|->
name|slot
index|[
name|nm_i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|__builtin_prefetch
argument_list|(
operator|&
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_m
index|[
name|nic_i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
condition|)
block|{
name|__builtin_prefetch
argument_list|(
operator|&
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
index|[
name|nic_i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|NM_CHECK_ADDR_LEN
argument_list|(
name|na
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|->
name|flags
operator|&
name|NS_BUF_CHANGED
condition|)
block|{
comment|/* buffer has changed, reload map */
name|netmap_reload_map
argument_list|(
name|na
argument_list|,
name|txq
operator|->
name|ift_desc_tag
argument_list|,
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
index|[
name|nic_i
index|]
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/* make sure changes to the buffer are synced */
name|bus_dmamap_sync
argument_list|(
name|txq
operator|->
name|ift_ifdi
operator|->
name|idi_tag
argument_list|,
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
index|[
name|nic_i
index|]
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
block|}
name|slot
operator|->
name|flags
operator|&=
operator|~
operator|(
name|NS_REPORT
operator||
name|NS_BUF_CHANGED
operator|)
expr_stmt|;
name|nm_i
operator|=
name|nm_next
argument_list|(
name|nm_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|nic_i
operator|=
name|nm_next
argument_list|(
name|nic_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
name|kring
operator|->
name|nr_hwcur
operator|=
name|head
expr_stmt|;
comment|/* synchronize the NIC ring */
if|if
condition|(
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
condition|)
name|bus_dmamap_sync
argument_list|(
name|txq
operator|->
name|ift_desc_tag
argument_list|,
name|txq
operator|->
name|ift_ifdi
operator|->
name|idi_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* (re)start the tx unit up to slot nic_i (excluded) */
name|ctx
operator|->
name|isc_txd_flush
argument_list|(
name|ctx
operator|->
name|ifc_softc
argument_list|,
name|txq
operator|->
name|ift_id
argument_list|,
name|nic_i
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Second part: reclaim buffers for completed transmissions. 	 */
if|if
condition|(
name|iflib_tx_credits_update
argument_list|(
name|ctx
argument_list|,
name|txq
argument_list|)
condition|)
block|{
comment|/* some tx completed, increment avail */
name|nic_i
operator|=
name|txq
operator|->
name|ift_cidx_processed
expr_stmt|;
name|kring
operator|->
name|nr_hwtail
operator|=
name|nm_prev
argument_list|(
name|netmap_idx_n2k
argument_list|(
name|kring
argument_list|,
name|nic_i
argument_list|)
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reconcile kernel and user view of the receive ring.  * Same as for the txsync, this routine must be efficient.  * The caller guarantees a single invocations, but races against  * the rest of the driver should be handled here.  *  * On call, kring->rhead is the first packet that userspace wants  * to keep, and kring->rcur is the wakeup point.  * The kernel has previously reported packets up to kring->rtail.  *  * If (flags& NAF_FORCE_READ) also check for incoming packets irrespective  * of whether or not we received an interrupt.  */
end_comment

begin_function
specifier|static
name|int
name|iflib_netmap_rxsync
parameter_list|(
name|struct
name|netmap_kring
modifier|*
name|kring
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|kring
operator|->
name|na
decl_stmt|;
name|struct
name|netmap_ring
modifier|*
name|ring
init|=
name|kring
operator|->
name|ring
decl_stmt|;
name|uint32_t
name|nm_i
decl_stmt|;
comment|/* index into the netmap ring */
name|uint32_t
name|nic_i
decl_stmt|,
name|nic_i_start
decl_stmt|;
comment|/* index into the NIC ring */
name|u_int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|u_int
specifier|const
name|lim
init|=
name|kring
operator|->
name|nkr_num_slots
operator|-
literal|1
decl_stmt|;
name|u_int
specifier|const
name|head
init|=
name|kring
operator|->
name|rhead
decl_stmt|;
name|int
name|force_update
init|=
operator|(
name|flags
operator|&
name|NAF_FORCE_READ
operator|)
operator|||
name|kring
operator|->
name|nr_kflags
operator|&
name|NKR_PENDINTR
decl_stmt|;
name|struct
name|if_rxd_info
name|ri
decl_stmt|;
name|struct
name|if_rxd_update
name|iru
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|if_ctx_t
name|ctx
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|iflib_rxq_t
name|rxq
init|=
operator|&
name|ctx
operator|->
name|ifc_rxqs
index|[
name|kring
operator|->
name|ring_id
index|]
decl_stmt|;
name|iflib_fl_t
name|fl
init|=
name|rxq
operator|->
name|ifr_fl
decl_stmt|;
if|if
condition|(
name|head
operator|>
name|lim
condition|)
return|return
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
return|;
comment|/* XXX check sync modes */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|fl
operator|=
name|rxq
operator|->
name|ifr_fl
init|;
name|i
operator|<
name|rxq
operator|->
name|ifr_nfl
condition|;
name|i
operator|++
operator|,
name|fl
operator|++
control|)
block|{
if|if
condition|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_map
operator|==
name|NULL
condition|)
continue|continue;
name|bus_dmamap_sync
argument_list|(
name|rxq
operator|->
name|ifr_fl
index|[
name|i
index|]
operator|.
name|ifl_desc_tag
argument_list|,
name|fl
operator|->
name|ifl_ifdi
operator|->
name|idi_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * First part: import newly received packets. 	 * 	 * nm_i is the index of the next free slot in the netmap ring, 	 * nic_i is the index of the next received packet in the NIC ring, 	 * and they may differ in case if_init() has been called while 	 * in netmap mode. For the receive ring we have 	 * 	 *	nic_i = rxr->next_check; 	 *	nm_i = kring->nr_hwtail (previous) 	 * and 	 *	nm_i == (nic_i + kring->nkr_hwofs) % ring_size 	 * 	 * rxr->next_check is set to 0 on a ring reinit 	 */
if|if
condition|(
name|netmap_no_pendintr
operator|||
name|force_update
condition|)
block|{
name|int
name|crclen
init|=
name|iflib_crcstrip
condition|?
literal|0
else|:
literal|4
decl_stmt|;
name|int
name|error
decl_stmt|,
name|avail
decl_stmt|;
name|uint16_t
name|slot_flags
init|=
name|kring
operator|->
name|nkr_slot_flags
decl_stmt|;
for|for
control|(
name|fl
operator|=
name|rxq
operator|->
name|ifr_fl
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rxq
operator|->
name|ifr_nfl
condition|;
name|i
operator|++
operator|,
name|fl
operator|++
control|)
block|{
name|nic_i
operator|=
name|fl
operator|->
name|ifl_cidx
expr_stmt|;
name|nm_i
operator|=
name|netmap_idx_n2k
argument_list|(
name|kring
argument_list|,
name|nic_i
argument_list|)
expr_stmt|;
name|avail
operator|=
name|iflib_rxd_avail
argument_list|(
name|ctx
argument_list|,
name|rxq
argument_list|,
name|nic_i
argument_list|,
name|USHRT_MAX
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|avail
operator|>
literal|0
condition|;
name|n
operator|++
operator|,
name|avail
operator|--
control|)
block|{
name|rxd_info_zero
argument_list|(
operator|&
name|ri
argument_list|)
expr_stmt|;
name|ri
operator|.
name|iri_frags
operator|=
name|rxq
operator|->
name|ifr_frags
expr_stmt|;
name|ri
operator|.
name|iri_qsidx
operator|=
name|kring
operator|->
name|ring_id
expr_stmt|;
name|ri
operator|.
name|iri_ifp
operator|=
name|ctx
operator|->
name|ifc_ifp
expr_stmt|;
name|ri
operator|.
name|iri_cidx
operator|=
name|nic_i
expr_stmt|;
name|error
operator|=
name|ctx
operator|->
name|isc_rxd_pkt_get
argument_list|(
name|ctx
operator|->
name|ifc_softc
argument_list|,
operator|&
name|ri
argument_list|)
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
operator|.
name|len
operator|=
name|error
condition|?
literal|0
else|:
name|ri
operator|.
name|iri_len
operator|-
name|crclen
expr_stmt|;
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
operator|.
name|flags
operator|=
name|slot_flags
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_map
condition|)
name|bus_dmamap_sync
argument_list|(
name|fl
operator|->
name|ifl_ifdi
operator|->
name|idi_tag
argument_list|,
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_map
index|[
name|nic_i
index|]
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|nm_i
operator|=
name|nm_next
argument_list|(
name|nm_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|nic_i
operator|=
name|nm_next
argument_list|(
name|nic_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
condition|)
block|{
comment|/* update the state variables */
if|if
condition|(
name|netmap_no_pendintr
operator|&&
operator|!
name|force_update
condition|)
block|{
comment|/* diagnostics */
name|iflib_rx_miss
operator|++
expr_stmt|;
name|iflib_rx_miss_bufs
operator|+=
name|n
expr_stmt|;
block|}
name|fl
operator|->
name|ifl_cidx
operator|=
name|nic_i
expr_stmt|;
name|kring
operator|->
name|nr_hwtail
operator|=
name|nm_i
expr_stmt|;
block|}
name|kring
operator|->
name|nr_kflags
operator|&=
operator|~
name|NKR_PENDINTR
expr_stmt|;
block|}
block|}
comment|/* 	 * Second part: skip past packets that userspace has released. 	 * (kring->nr_hwcur to head excluded), 	 * and make the buffers available for reception. 	 * As usual nm_i is the index in the netmap ring, 	 * nic_i is the index in the NIC ring, and 	 * nm_i == (nic_i + kring->nkr_hwofs) % ring_size 	 */
comment|/* XXX not sure how this will work with multiple free lists */
name|nm_i
operator|=
name|kring
operator|->
name|nr_hwcur
expr_stmt|;
if|if
condition|(
name|nm_i
operator|==
name|head
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|iru
operator|.
name|iru_paddrs
operator|=
name|fl
operator|->
name|ifl_bus_addrs
expr_stmt|;
name|iru
operator|.
name|iru_vaddrs
operator|=
operator|&
name|fl
operator|->
name|ifl_vm_addrs
index|[
literal|0
index|]
expr_stmt|;
name|iru
operator|.
name|iru_idxs
operator|=
name|fl
operator|->
name|ifl_rxd_idxs
expr_stmt|;
name|iru
operator|.
name|iru_qsidx
operator|=
name|rxq
operator|->
name|ifr_id
expr_stmt|;
name|iru
operator|.
name|iru_buf_size
operator|=
name|fl
operator|->
name|ifl_buf_size
expr_stmt|;
name|iru
operator|.
name|iru_flidx
operator|=
name|fl
operator|->
name|ifl_id
expr_stmt|;
name|nic_i_start
operator|=
name|nic_i
operator|=
name|netmap_idx_k2n
argument_list|(
name|kring
argument_list|,
name|nm_i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|nm_i
operator|!=
name|head
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|netmap_slot
modifier|*
name|slot
init|=
operator|&
name|ring
operator|->
name|slot
index|[
name|nm_i
index|]
decl_stmt|;
name|void
modifier|*
name|addr
init|=
name|PNMB
argument_list|(
name|na
argument_list|,
name|slot
argument_list|,
operator|&
name|fl
operator|->
name|ifl_bus_addrs
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr
operator|==
name|NETMAP_BUF_BASE
argument_list|(
name|na
argument_list|)
condition|)
comment|/* bad buf */
goto|goto
name|ring_reset
goto|;
name|fl
operator|->
name|ifl_vm_addrs
index|[
name|i
index|]
operator|=
name|addr
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_map
operator|&&
operator|(
name|slot
operator|->
name|flags
operator|&
name|NS_BUF_CHANGED
operator|)
condition|)
block|{
comment|/* buffer has changed, reload map */
name|netmap_reload_map
argument_list|(
name|na
argument_list|,
name|fl
operator|->
name|ifl_ifdi
operator|->
name|idi_tag
argument_list|,
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_map
index|[
name|nic_i
index|]
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
name|slot
operator|->
name|flags
operator|&=
operator|~
name|NS_BUF_CHANGED
expr_stmt|;
name|nm_i
operator|=
name|nm_next
argument_list|(
name|nm_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|fl
operator|->
name|ifl_rxd_idxs
index|[
name|i
index|]
operator|=
name|nic_i
operator|=
name|nm_next
argument_list|(
name|nic_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
if|if
condition|(
name|nm_i
operator|!=
name|head
operator|&&
name|i
operator|<
name|IFLIB_MAX_RX_REFRESH
condition|)
continue|continue;
name|iru
operator|.
name|iru_pidx
operator|=
name|nic_i_start
expr_stmt|;
name|iru
operator|.
name|iru_count
operator|=
name|i
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|ctx
operator|->
name|isc_rxd_refill
argument_list|(
name|ctx
operator|->
name|ifc_softc
argument_list|,
operator|&
name|iru
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_map
operator|==
name|NULL
condition|)
block|{
name|nic_i_start
operator|=
name|nic_i
expr_stmt|;
continue|continue;
block|}
name|nic_i
operator|=
name|nic_i_start
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|iru
operator|.
name|iru_count
condition|;
name|n
operator|++
control|)
block|{
name|bus_dmamap_sync
argument_list|(
name|fl
operator|->
name|ifl_ifdi
operator|->
name|idi_tag
argument_list|,
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_map
index|[
name|nic_i
index|]
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
name|nic_i
operator|=
name|nm_next
argument_list|(
name|nic_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
block|}
name|nic_i_start
operator|=
name|nic_i
expr_stmt|;
block|}
name|kring
operator|->
name|nr_hwcur
operator|=
name|head
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_map
condition|)
name|bus_dmamap_sync
argument_list|(
name|fl
operator|->
name|ifl_ifdi
operator|->
name|idi_tag
argument_list|,
name|fl
operator|->
name|ifl_ifdi
operator|->
name|idi_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
comment|/* 	 * IMPORTANT: we must leave one free slot in the ring, 	 * so move nic_i back by one unit 	 */
name|nic_i
operator|=
name|nm_prev
argument_list|(
name|nic_i
argument_list|,
name|lim
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|isc_rxd_flush
argument_list|(
name|ctx
operator|->
name|ifc_softc
argument_list|,
name|rxq
operator|->
name|ifr_id
argument_list|,
name|fl
operator|->
name|ifl_id
argument_list|,
name|nic_i
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|ring_reset
label|:
return|return
name|netmap_ring_reinit
argument_list|(
name|kring
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iflib_netmap_intr
parameter_list|(
name|struct
name|netmap_adapter
modifier|*
name|na
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|na
operator|->
name|ifp
decl_stmt|;
name|if_ctx_t
name|ctx
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|onoff
condition|)
block|{
name|IFDI_INTR_ENABLE
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IFDI_INTR_DISABLE
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iflib_netmap_attach
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|struct
name|netmap_adapter
name|na
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
operator|&
name|ctx
operator|->
name|ifc_softc_ctx
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|na
argument_list|,
sizeof|sizeof
argument_list|(
name|na
argument_list|)
argument_list|)
expr_stmt|;
name|na
operator|.
name|ifp
operator|=
name|ctx
operator|->
name|ifc_ifp
expr_stmt|;
name|na
operator|.
name|na_flags
operator|=
name|NAF_BDG_MAYSLEEP
expr_stmt|;
name|MPASS
argument_list|(
name|ctx
operator|->
name|ifc_softc_ctx
operator|.
name|isc_ntxqsets
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ctx
operator|->
name|ifc_softc_ctx
operator|.
name|isc_nrxqsets
argument_list|)
expr_stmt|;
name|na
operator|.
name|num_tx_desc
operator|=
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
expr_stmt|;
name|na
operator|.
name|num_rx_desc
operator|=
name|scctx
operator|->
name|isc_nrxd
index|[
literal|0
index|]
expr_stmt|;
name|na
operator|.
name|nm_txsync
operator|=
name|iflib_netmap_txsync
expr_stmt|;
name|na
operator|.
name|nm_rxsync
operator|=
name|iflib_netmap_rxsync
expr_stmt|;
name|na
operator|.
name|nm_register
operator|=
name|iflib_netmap_register
expr_stmt|;
name|na
operator|.
name|nm_intr
operator|=
name|iflib_netmap_intr
expr_stmt|;
name|na
operator|.
name|num_tx_rings
operator|=
name|ctx
operator|->
name|ifc_softc_ctx
operator|.
name|isc_ntxqsets
expr_stmt|;
name|na
operator|.
name|num_rx_rings
operator|=
name|ctx
operator|->
name|ifc_softc_ctx
operator|.
name|isc_nrxqsets
expr_stmt|;
return|return
operator|(
name|netmap_attach
argument_list|(
operator|&
name|na
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iflib_netmap_txq_init
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|iflib_txq_t
name|txq
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ctx
operator|->
name|ifc_ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
name|slot
operator|=
name|netmap_reset
argument_list|(
name|na
argument_list|,
name|NR_TX
argument_list|,
name|txq
operator|->
name|ift_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ctx
operator|->
name|ifc_softc_ctx
operator|.
name|isc_ntxd
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * In netmap mode, set the map for the packet buffer. 		 * NOTE: Some drivers (not this one) also need to set 		 * the physical buffer address in the NIC ring. 		 * netmap_idx_n2k() maps a nic index, i, into the corresponding 		 * netmap slot index, si 		 */
name|int
name|si
init|=
name|netmap_idx_n2k
argument_list|(
operator|&
name|na
operator|->
name|tx_rings
index|[
name|txq
operator|->
name|ift_id
index|]
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|netmap_load_map
argument_list|(
name|na
argument_list|,
name|txq
operator|->
name|ift_desc_tag
argument_list|,
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
index|[
name|i
index|]
argument_list|,
name|NMB
argument_list|(
name|na
argument_list|,
name|slot
operator|+
name|si
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iflib_netmap_rxq_init
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|iflib_rxq_t
name|rxq
parameter_list|)
block|{
name|struct
name|netmap_adapter
modifier|*
name|na
init|=
name|NA
argument_list|(
name|ctx
operator|->
name|ifc_ifp
argument_list|)
decl_stmt|;
name|struct
name|netmap_slot
modifier|*
name|slot
decl_stmt|;
name|struct
name|if_rxd_update
name|iru
decl_stmt|;
name|iflib_fl_t
name|fl
decl_stmt|;
name|bus_dmamap_t
modifier|*
name|map
decl_stmt|;
name|int
name|nrxd
decl_stmt|;
name|uint32_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|pidx_start
decl_stmt|;
name|slot
operator|=
name|netmap_reset
argument_list|(
name|na
argument_list|,
name|NR_RX
argument_list|,
name|rxq
operator|->
name|ifr_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|slot
operator|==
name|NULL
condition|)
return|return;
name|fl
operator|=
operator|&
name|rxq
operator|->
name|ifr_fl
index|[
literal|0
index|]
expr_stmt|;
name|map
operator|=
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_map
expr_stmt|;
name|nrxd
operator|=
name|ctx
operator|->
name|ifc_softc_ctx
operator|.
name|isc_nrxd
index|[
literal|0
index|]
expr_stmt|;
name|iru
operator|.
name|iru_paddrs
operator|=
name|fl
operator|->
name|ifl_bus_addrs
expr_stmt|;
name|iru
operator|.
name|iru_vaddrs
operator|=
operator|&
name|fl
operator|->
name|ifl_vm_addrs
index|[
literal|0
index|]
expr_stmt|;
name|iru
operator|.
name|iru_idxs
operator|=
name|fl
operator|->
name|ifl_rxd_idxs
expr_stmt|;
name|iru
operator|.
name|iru_qsidx
operator|=
name|rxq
operator|->
name|ifr_id
expr_stmt|;
name|iru
operator|.
name|iru_buf_size
operator|=
name|rxq
operator|->
name|ifr_fl
index|[
literal|0
index|]
operator|.
name|ifl_buf_size
expr_stmt|;
name|iru
operator|.
name|iru_flidx
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pidx_start
operator|=
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|nrxd
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|int
name|sj
init|=
name|netmap_idx_n2k
argument_list|(
operator|&
name|na
operator|->
name|rx_rings
index|[
name|rxq
operator|->
name|ifr_id
index|]
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|;
name|fl
operator|->
name|ifl_rxd_idxs
index|[
name|j
index|]
operator|=
name|i
expr_stmt|;
name|addr
operator|=
name|fl
operator|->
name|ifl_vm_addrs
index|[
name|j
index|]
operator|=
name|PNMB
argument_list|(
name|na
argument_list|,
name|slot
operator|+
name|sj
argument_list|,
operator|&
name|fl
operator|->
name|ifl_bus_addrs
index|[
name|j
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|map
condition|)
block|{
name|netmap_load_map
argument_list|(
name|na
argument_list|,
name|rxq
operator|->
name|ifr_fl
index|[
literal|0
index|]
operator|.
name|ifl_ifdi
operator|->
name|idi_tag
argument_list|,
operator|*
name|map
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|map
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|<
name|IFLIB_MAX_RX_REFRESH
operator|&&
name|i
operator|<
name|nrxd
operator|-
literal|1
condition|)
continue|continue;
name|iru
operator|.
name|iru_pidx
operator|=
name|pidx_start
expr_stmt|;
name|pidx_start
operator|=
name|i
expr_stmt|;
name|iru
operator|.
name|iru_count
operator|=
name|j
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|MPASS
argument_list|(
name|pidx_start
operator|+
name|j
operator|<=
name|nrxd
argument_list|)
expr_stmt|;
comment|/* Update descriptors and the cached value */
name|ctx
operator|->
name|isc_rxd_refill
argument_list|(
name|ctx
operator|->
name|ifc_softc
argument_list|,
operator|&
name|iru
argument_list|)
expr_stmt|;
block|}
comment|/* preserve queue */
if|if
condition|(
name|ctx
operator|->
name|ifc_ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
condition|)
block|{
name|struct
name|netmap_kring
modifier|*
name|kring
init|=
operator|&
name|na
operator|->
name|rx_rings
index|[
name|rxq
operator|->
name|ifr_id
index|]
decl_stmt|;
name|int
name|t
init|=
name|na
operator|->
name|num_rx_desc
operator|-
literal|1
operator|-
name|nm_kr_rxspace
argument_list|(
name|kring
argument_list|)
decl_stmt|;
name|ctx
operator|->
name|isc_rxd_flush
argument_list|(
name|ctx
operator|->
name|ifc_softc
argument_list|,
name|rxq
operator|->
name|ifr_id
argument_list|,
literal|0
comment|/* fl_id */
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
else|else
name|ctx
operator|->
name|isc_rxd_flush
argument_list|(
name|ctx
operator|->
name|ifc_softc
argument_list|,
name|rxq
operator|->
name|ifr_id
argument_list|,
literal|0
comment|/* fl_id */
argument_list|,
name|nrxd
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|iflib_netmap_detach
parameter_list|(
name|ifp
parameter_list|)
value|netmap_detach(ifp)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|iflib_netmap_txq_init
parameter_list|(
name|ctx
parameter_list|,
name|txq
parameter_list|)
end_define

begin_define
define|#
directive|define
name|iflib_netmap_rxq_init
parameter_list|(
name|ctx
parameter_list|,
name|rxq
parameter_list|)
end_define

begin_define
define|#
directive|define
name|iflib_netmap_detach
parameter_list|(
name|ifp
parameter_list|)
end_define

begin_define
define|#
directive|define
name|iflib_netmap_attach
parameter_list|(
name|ctx
parameter_list|)
value|(0)
end_define

begin_define
define|#
directive|define
name|netmap_rx_irq
parameter_list|(
name|ifp
parameter_list|,
name|qid
parameter_list|,
name|budget
parameter_list|)
value|(0)
end_define

begin_define
define|#
directive|define
name|netmap_tx_irq
parameter_list|(
name|ifp
parameter_list|,
name|qid
parameter_list|)
value|do {} while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
end_if

begin_function
specifier|static
name|__inline
name|void
name|prefetch
parameter_list|(
name|void
modifier|*
name|x
parameter_list|)
block|{
asm|__asm volatile("prefetcht0 %0" :: "m" (*(unsigned long *)x));
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|prefetch
parameter_list|(
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|_iflib_dmamap_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|err
parameter_list|)
block|{
if|if
condition|(
name|err
condition|)
return|return;
operator|*
operator|(
name|bus_addr_t
operator|*
operator|)
name|arg
operator|=
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iflib_dma_alloc
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|int
name|size
parameter_list|,
name|iflib_dma_info_t
name|dma
parameter_list|,
name|int
name|mapflags
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|if_shared_ctx_t
name|sctx
init|=
name|ctx
operator|->
name|ifc_sctx
decl_stmt|;
name|device_t
name|dev
init|=
name|ctx
operator|->
name|ifc_dev
decl_stmt|;
name|KASSERT
argument_list|(
name|sctx
operator|->
name|isc_q_align
operator|!=
literal|0
argument_list|,
operator|(
literal|"alignment value not initialized"
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
comment|/* parent */
name|sctx
operator|->
name|isc_q_align
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|size
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|size
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockarg */
operator|&
name|dma
operator|->
name|idi_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: bus_dma_tag_create failed: %d\n"
argument_list|,
name|__func__
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|fail_0
goto|;
block|}
name|err
operator|=
name|bus_dmamem_alloc
argument_list|(
name|dma
operator|->
name|idi_tag
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dma
operator|->
name|idi_vaddr
argument_list|,
name|BUS_DMA_NOWAIT
operator||
name|BUS_DMA_COHERENT
operator||
name|BUS_DMA_ZERO
argument_list|,
operator|&
name|dma
operator|->
name|idi_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: bus_dmamem_alloc(%ju) failed: %d\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|uintmax_t
operator|)
name|size
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|fail_1
goto|;
block|}
name|dma
operator|->
name|idi_paddr
operator|=
name|IF_BAD_DMA
expr_stmt|;
name|err
operator|=
name|bus_dmamap_load
argument_list|(
name|dma
operator|->
name|idi_tag
argument_list|,
name|dma
operator|->
name|idi_map
argument_list|,
name|dma
operator|->
name|idi_vaddr
argument_list|,
name|size
argument_list|,
name|_iflib_dmamap_cb
argument_list|,
operator|&
name|dma
operator|->
name|idi_paddr
argument_list|,
name|mapflags
operator||
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|dma
operator|->
name|idi_paddr
operator|==
name|IF_BAD_DMA
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: bus_dmamap_load failed: %d\n"
argument_list|,
name|__func__
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|fail_2
goto|;
block|}
name|dma
operator|->
name|idi_size
operator|=
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail_2
label|:
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|idi_tag
argument_list|,
name|dma
operator|->
name|idi_vaddr
argument_list|,
name|dma
operator|->
name|idi_map
argument_list|)
expr_stmt|;
name|fail_1
label|:
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|idi_tag
argument_list|)
expr_stmt|;
name|fail_0
label|:
name|dma
operator|->
name|idi_tag
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|iflib_dma_alloc_multi
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|int
modifier|*
name|sizes
parameter_list|,
name|iflib_dma_info_t
modifier|*
name|dmalist
parameter_list|,
name|int
name|mapflags
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
name|iflib_dma_info_t
modifier|*
name|dmaiter
decl_stmt|;
name|dmaiter
operator|=
name|dmalist
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|dmaiter
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|iflib_dma_alloc
argument_list|(
name|ctx
argument_list|,
name|sizes
index|[
name|i
index|]
argument_list|,
operator|*
name|dmaiter
argument_list|,
name|mapflags
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|err
condition|)
name|iflib_dma_free_multi
argument_list|(
name|dmalist
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|iflib_dma_free
parameter_list|(
name|iflib_dma_info_t
name|dma
parameter_list|)
block|{
if|if
condition|(
name|dma
operator|->
name|idi_tag
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|dma
operator|->
name|idi_paddr
operator|!=
name|IF_BAD_DMA
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|dma
operator|->
name|idi_tag
argument_list|,
name|dma
operator|->
name|idi_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|dma
operator|->
name|idi_tag
argument_list|,
name|dma
operator|->
name|idi_map
argument_list|)
expr_stmt|;
name|dma
operator|->
name|idi_paddr
operator|=
name|IF_BAD_DMA
expr_stmt|;
block|}
if|if
condition|(
name|dma
operator|->
name|idi_vaddr
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamem_free
argument_list|(
name|dma
operator|->
name|idi_tag
argument_list|,
name|dma
operator|->
name|idi_vaddr
argument_list|,
name|dma
operator|->
name|idi_map
argument_list|)
expr_stmt|;
name|dma
operator|->
name|idi_vaddr
operator|=
name|NULL
expr_stmt|;
block|}
name|bus_dma_tag_destroy
argument_list|(
name|dma
operator|->
name|idi_tag
argument_list|)
expr_stmt|;
name|dma
operator|->
name|idi_tag
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iflib_dma_free_multi
parameter_list|(
name|iflib_dma_info_t
modifier|*
name|dmalist
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|iflib_dma_info_t
modifier|*
name|dmaiter
init|=
name|dmalist
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|dmaiter
operator|++
control|)
name|iflib_dma_free
argument_list|(
operator|*
name|dmaiter
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|EARLY_AP_STARTUP
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|int
name|iflib_started
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * We used to abuse the smp_started flag to decide if the queues have been  * fully initialized (by late taskqgroup_adjust() calls in a SYSINIT()).  * That gave bad races, since the SYSINIT() runs strictly after smp_started  * is set.  Run a SYSINIT() strictly after that to just set a usable  * completion flag.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iflib_started
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|iflib_record_started
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|iflib_started
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|iflib_record_started
argument_list|,
name|SI_SUB_SMP
operator|+
literal|1
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|iflib_record_started
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|iflib_fast_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|iflib_filter_info_t
name|info
init|=
name|arg
decl_stmt|;
name|struct
name|grouptask
modifier|*
name|gtask
init|=
name|info
operator|->
name|ifi_task
decl_stmt|;
if|if
condition|(
operator|!
name|iflib_started
condition|)
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
name|DBG_COUNTER_INC
argument_list|(
name|fast_intrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|ifi_filter
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|ifi_filter
argument_list|(
name|info
operator|->
name|ifi_filter_arg
argument_list|)
operator|==
name|FILTER_HANDLED
condition|)
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
name|GROUPTASK_ENQUEUE
argument_list|(
name|gtask
argument_list|)
expr_stmt|;
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iflib_fast_intr_rxtx
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|iflib_filter_info_t
name|info
init|=
name|arg
decl_stmt|;
name|struct
name|grouptask
modifier|*
name|gtask
init|=
name|info
operator|->
name|ifi_task
decl_stmt|;
name|iflib_rxq_t
name|rxq
init|=
operator|(
name|iflib_rxq_t
operator|)
name|info
operator|->
name|ifi_ctx
decl_stmt|;
name|if_ctx_t
name|ctx
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cidx
decl_stmt|;
if|if
condition|(
operator|!
name|iflib_started
condition|)
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
name|DBG_COUNTER_INC
argument_list|(
name|fast_intrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|ifi_filter
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|ifi_filter
argument_list|(
name|info
operator|->
name|ifi_filter_arg
argument_list|)
operator|==
name|FILTER_HANDLED
condition|)
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rxq
operator|->
name|ifr_ntxqirq
condition|;
name|i
operator|++
control|)
block|{
name|qidx_t
name|txqid
init|=
name|rxq
operator|->
name|ifr_txqid
index|[
name|i
index|]
decl_stmt|;
name|ctx
operator|=
name|rxq
operator|->
name|ifr_ctx
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|isc_txd_credits_update
argument_list|(
name|ctx
operator|->
name|ifc_softc
argument_list|,
name|txqid
argument_list|,
name|false
argument_list|)
condition|)
block|{
name|IFDI_TX_QUEUE_INTR_ENABLE
argument_list|(
name|ctx
argument_list|,
name|txqid
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|GROUPTASK_ENQUEUE
argument_list|(
operator|&
name|ctx
operator|->
name|ifc_txqs
index|[
name|txqid
index|]
operator|.
name|ift_task
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|ifc_sctx
operator|->
name|isc_flags
operator|&
name|IFLIB_HAS_RXCQ
condition|)
name|cidx
operator|=
name|rxq
operator|->
name|ifr_cq_cidx
expr_stmt|;
else|else
name|cidx
operator|=
name|rxq
operator|->
name|ifr_fl
index|[
literal|0
index|]
operator|.
name|ifl_cidx
expr_stmt|;
if|if
condition|(
name|iflib_rxd_avail
argument_list|(
name|ctx
argument_list|,
name|rxq
argument_list|,
name|cidx
argument_list|,
literal|1
argument_list|)
condition|)
name|GROUPTASK_ENQUEUE
argument_list|(
name|gtask
argument_list|)
expr_stmt|;
else|else
name|IFDI_RX_QUEUE_INTR_ENABLE
argument_list|(
name|ctx
argument_list|,
name|rxq
operator|->
name|ifr_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iflib_fast_intr_ctx
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|iflib_filter_info_t
name|info
init|=
name|arg
decl_stmt|;
name|struct
name|grouptask
modifier|*
name|gtask
init|=
name|info
operator|->
name|ifi_task
decl_stmt|;
if|if
condition|(
operator|!
name|iflib_started
condition|)
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
name|DBG_COUNTER_INC
argument_list|(
name|fast_intrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|ifi_filter
operator|!=
name|NULL
operator|&&
name|info
operator|->
name|ifi_filter
argument_list|(
name|info
operator|->
name|ifi_filter_arg
argument_list|)
operator|==
name|FILTER_HANDLED
condition|)
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
name|GROUPTASK_ENQUEUE
argument_list|(
name|gtask
argument_list|)
expr_stmt|;
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_iflib_irq_alloc
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|if_irq_t
name|irq
parameter_list|,
name|int
name|rid
parameter_list|,
name|driver_filter_t
name|filter
parameter_list|,
name|driver_intr_t
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|rc
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|resource
modifier|*
name|res
decl_stmt|;
name|void
modifier|*
name|tag
init|=
name|NULL
decl_stmt|;
name|device_t
name|dev
init|=
name|ctx
operator|->
name|ifc_dev
decl_stmt|;
name|flags
operator|=
name|RF_ACTIVE
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ifc_flags
operator|&
name|IFC_LEGACY
condition|)
name|flags
operator||=
name|RF_SHAREABLE
expr_stmt|;
name|MPASS
argument_list|(
name|rid
operator|<
literal|512
argument_list|)
expr_stmt|;
name|irq
operator|->
name|ii_rid
operator|=
name|rid
expr_stmt|;
name|res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|irq
operator|->
name|ii_rid
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate IRQ for rid %d, name %s.\n"
argument_list|,
name|rid
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|irq
operator|->
name|ii_res
operator|=
name|res
expr_stmt|;
name|KASSERT
argument_list|(
name|filter
operator|==
name|NULL
operator|||
name|handler
operator|==
name|NULL
argument_list|,
operator|(
literal|"filter and handler can't both be non-NULL"
operator|)
argument_list|)
expr_stmt|;
name|rc
operator|=
name|bus_setup_intr
argument_list|(
name|dev
argument_list|,
name|res
argument_list|,
name|INTR_MPSAFE
operator||
name|INTR_TYPE_NET
argument_list|,
name|filter
argument_list|,
name|handler
argument_list|,
name|arg
argument_list|,
operator|&
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to setup interrupt for rid %d, name %s: %d\n"
argument_list|,
name|rid
argument_list|,
name|name
condition|?
name|name
else|:
literal|"unknown"
argument_list|,
name|rc
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|name
condition|)
name|bus_describe_intr
argument_list|(
name|dev
argument_list|,
name|res
argument_list|,
name|tag
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|irq
operator|->
name|ii_tag
operator|=
name|tag
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Allocate memory for tx_buffer structures. The tx_buffer stores all  *  the information needed to transmit a packet on the wire. This is  *  called only once at attach, setup is done every reset.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|iflib_txsd_alloc
parameter_list|(
name|iflib_txq_t
name|txq
parameter_list|)
block|{
name|if_ctx_t
name|ctx
init|=
name|txq
operator|->
name|ift_ctx
decl_stmt|;
name|if_shared_ctx_t
name|sctx
init|=
name|ctx
operator|->
name|ifc_sctx
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
operator|&
name|ctx
operator|->
name|ifc_softc_ctx
decl_stmt|;
name|device_t
name|dev
init|=
name|ctx
operator|->
name|ifc_dev
decl_stmt|;
name|int
name|err
decl_stmt|,
name|nsegments
decl_stmt|,
name|ntsosegments
decl_stmt|;
name|nsegments
operator|=
name|scctx
operator|->
name|isc_tx_nsegments
expr_stmt|;
name|ntsosegments
operator|=
name|scctx
operator|->
name|isc_tx_tso_segments_max
expr_stmt|;
name|MPASS
argument_list|(
name|scctx
operator|->
name|isc_ntxd
index|[
literal|0
index|]
operator|>
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|scctx
operator|->
name|isc_ntxd
index|[
name|txq
operator|->
name|ift_br_offset
index|]
operator|>
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|nsegments
operator|>
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ntsosegments
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Setup DMA descriptor areas. 	 */
if|if
condition|(
operator|(
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|sctx
operator|->
name|isc_tx_maxsize
argument_list|,
comment|/* maxsize */
name|nsegments
argument_list|,
comment|/* nsegments */
name|sctx
operator|->
name|isc_tx_maxsegsize
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|txq
operator|->
name|ift_desc_tag
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX DMA tag: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"maxsize: %zd nsegments: %d maxsegsize: %zd\n"
argument_list|,
name|sctx
operator|->
name|isc_tx_maxsize
argument_list|,
name|nsegments
argument_list|,
name|sctx
operator|->
name|isc_tx_maxsegsize
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|scctx
operator|->
name|isc_tx_tso_size_max
argument_list|,
comment|/* maxsize */
name|ntsosegments
argument_list|,
comment|/* nsegments */
name|scctx
operator|->
name|isc_tx_tso_segsize_max
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockfuncarg */
operator|&
name|txq
operator|->
name|ift_tso_desc_tag
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX TSO DMA tag: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_flags
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|*
name|scctx
operator|->
name|isc_ntxd
index|[
name|txq
operator|->
name|ift_br_offset
index|]
argument_list|,
name|M_IFLIB
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate tx_buffer memory\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mbuf
operator|*
argument_list|)
operator|*
name|scctx
operator|->
name|isc_ntxd
index|[
name|txq
operator|->
name|ift_br_offset
index|]
argument_list|,
name|M_IFLIB
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate tx_buffer memory\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create the descriptor buffer dma maps */
if|#
directive|if
name|defined
argument_list|(
name|ACPI_DMAR
argument_list|)
operator|||
operator|(
operator|!
operator|(
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|)
operator|)
if|if
condition|(
operator|(
name|ctx
operator|->
name|ifc_flags
operator|&
name|IFC_DMAR
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
operator|=
operator|(
name|bus_dmamap_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bus_dmamap_t
argument_list|)
operator|*
name|scctx
operator|->
name|isc_ntxd
index|[
name|txq
operator|->
name|ift_br_offset
index|]
argument_list|,
name|M_IFLIB
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate tx_buffer map memory\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|scctx
operator|->
name|isc_ntxd
index|[
name|txq
operator|->
name|ift_br_offset
index|]
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|txq
operator|->
name|ift_desc_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create TX DMA map\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
comment|/* We free all, it handles case where we are in the middle */
name|iflib_tx_structures_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iflib_txsd_destroy
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|iflib_txq_t
name|txq
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|bus_dmamap_t
name|map
decl_stmt|;
name|map
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
operator|!=
name|NULL
condition|)
name|map
operator|=
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_unload
argument_list|(
name|txq
operator|->
name|ift_desc_tag
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|txq
operator|->
name|ift_desc_tag
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iflib_txq_destroy
parameter_list|(
name|iflib_txq_t
name|txq
parameter_list|)
block|{
name|if_ctx_t
name|ctx
init|=
name|txq
operator|->
name|ift_ctx
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|txq
operator|->
name|ift_size
condition|;
name|i
operator|++
control|)
name|iflib_txsd_destroy
argument_list|(
name|ctx
argument_list|,
name|txq
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
argument_list|,
name|M_IFLIB
argument_list|)
expr_stmt|;
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_m
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_m
argument_list|,
name|M_IFLIB
argument_list|)
expr_stmt|;
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_flags
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_flags
argument_list|,
name|M_IFLIB
argument_list|)
expr_stmt|;
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_flags
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|txq
operator|->
name|ift_desc_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|txq
operator|->
name|ift_desc_tag
argument_list|)
expr_stmt|;
name|txq
operator|->
name|ift_desc_tag
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|txq
operator|->
name|ift_tso_desc_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|txq
operator|->
name|ift_tso_desc_tag
argument_list|)
expr_stmt|;
name|txq
operator|->
name|ift_tso_desc_tag
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|iflib_txsd_free
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|iflib_txq_t
name|txq
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
name|mp
operator|=
operator|&
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_m
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|txq
operator|->
name|ift_desc_tag
argument_list|,
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
index|[
name|i
index|]
argument_list|,
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|txq
operator|->
name|ift_desc_tag
argument_list|,
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|m_free
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
name|DBG_COUNTER_INC
argument_list|(
name|tx_frees
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iflib_txq_setup
parameter_list|(
name|iflib_txq_t
name|txq
parameter_list|)
block|{
name|if_ctx_t
name|ctx
init|=
name|txq
operator|->
name|ift_ctx
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
operator|&
name|ctx
operator|->
name|ifc_softc_ctx
decl_stmt|;
name|iflib_dma_info_t
name|di
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Set number of descriptors available */
name|txq
operator|->
name|ift_qstatus
operator|=
name|IFLIB_QUEUE_IDLE
expr_stmt|;
comment|/* XXX make configurable */
name|txq
operator|->
name|ift_update_freq
operator|=
name|IFLIB_DEFAULT_TX_UPDATE_FREQ
expr_stmt|;
comment|/* Reset indices */
name|txq
operator|->
name|ift_cidx_processed
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|ift_pidx
operator|=
name|txq
operator|->
name|ift_cidx
operator|=
name|txq
operator|->
name|ift_npending
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|ift_size
operator|=
name|scctx
operator|->
name|isc_ntxd
index|[
name|txq
operator|->
name|ift_br_offset
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|di
operator|=
name|txq
operator|->
name|ift_ifdi
init|;
name|i
operator|<
name|ctx
operator|->
name|ifc_nhwtxqs
condition|;
name|i
operator|++
operator|,
name|di
operator|++
control|)
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|di
operator|->
name|idi_vaddr
argument_list|,
name|di
operator|->
name|idi_size
argument_list|)
expr_stmt|;
name|IFDI_TXQ_SETUP
argument_list|(
name|ctx
argument_list|,
name|txq
operator|->
name|ift_id
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|di
operator|=
name|txq
operator|->
name|ift_ifdi
init|;
name|i
operator|<
name|ctx
operator|->
name|ifc_nhwtxqs
condition|;
name|i
operator|++
operator|,
name|di
operator|++
control|)
name|bus_dmamap_sync
argument_list|(
name|di
operator|->
name|idi_tag
argument_list|,
name|di
operator|->
name|idi_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Allocate memory for rx_buffer structures. Since we use one  *  rx_buffer per received packet, the maximum number of rx_buffer's  *  that we'll need is equal to the number of receive descriptors  *  that we've allocated.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|iflib_rxsd_alloc
parameter_list|(
name|iflib_rxq_t
name|rxq
parameter_list|)
block|{
name|if_ctx_t
name|ctx
init|=
name|rxq
operator|->
name|ifr_ctx
decl_stmt|;
name|if_shared_ctx_t
name|sctx
init|=
name|ctx
operator|->
name|ifc_sctx
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
operator|&
name|ctx
operator|->
name|ifc_softc_ctx
decl_stmt|;
name|device_t
name|dev
init|=
name|ctx
operator|->
name|ifc_dev
decl_stmt|;
name|iflib_fl_t
name|fl
decl_stmt|;
name|int
name|err
decl_stmt|;
name|MPASS
argument_list|(
name|scctx
operator|->
name|isc_nrxd
index|[
literal|0
index|]
operator|>
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|scctx
operator|->
name|isc_nrxd
index|[
name|rxq
operator|->
name|ifr_fl_offset
index|]
operator|>
literal|0
argument_list|)
expr_stmt|;
name|fl
operator|=
name|rxq
operator|->
name|ifr_fl
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|rxq
operator|->
name|ifr_nfl
condition|;
name|i
operator|++
operator|,
name|fl
operator|++
control|)
block|{
name|fl
operator|->
name|ifl_size
operator|=
name|scctx
operator|->
name|isc_nrxd
index|[
name|rxq
operator|->
name|ifr_fl_offset
index|]
expr_stmt|;
comment|/* this isn't necessarily the same */
name|err
operator|=
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, bounds */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|sctx
operator|->
name|isc_rx_maxsize
argument_list|,
comment|/* maxsize */
name|sctx
operator|->
name|isc_rx_nsegments
argument_list|,
comment|/* nsegments */
name|sctx
operator|->
name|isc_rx_maxsegsize
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
comment|/* lockfunc */
name|NULL
argument_list|,
comment|/* lockarg */
operator|&
name|fl
operator|->
name|ifl_desc_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s: bus_dma_tag_create failed %d\n"
argument_list|,
name|__func__
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_flags
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|*
name|scctx
operator|->
name|isc_nrxd
index|[
name|rxq
operator|->
name|ifr_fl_offset
index|]
argument_list|,
name|M_IFLIB
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate tx_buffer memory\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mbuf
operator|*
argument_list|)
operator|*
name|scctx
operator|->
name|isc_nrxd
index|[
name|rxq
operator|->
name|ifr_fl_offset
index|]
argument_list|,
name|M_IFLIB
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate tx_buffer memory\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_cl
operator|=
operator|(
name|caddr_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|caddr_t
argument_list|)
operator|*
name|scctx
operator|->
name|isc_nrxd
index|[
name|rxq
operator|->
name|ifr_fl_offset
index|]
argument_list|,
name|M_IFLIB
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate tx_buffer memory\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Create the descriptor buffer dma maps */
if|#
directive|if
name|defined
argument_list|(
name|ACPI_DMAR
argument_list|)
operator|||
operator|(
operator|!
operator|(
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|)
operator|)
if|if
condition|(
operator|(
name|ctx
operator|->
name|ifc_flags
operator|&
name|IFC_DMAR
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_map
operator|=
operator|(
name|bus_dmamap_t
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bus_dmamap_t
argument_list|)
operator|*
name|scctx
operator|->
name|isc_nrxd
index|[
name|rxq
operator|->
name|ifr_fl_offset
index|]
argument_list|,
name|M_IFLIB
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate tx_buffer map memory\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|scctx
operator|->
name|isc_nrxd
index|[
name|rxq
operator|->
name|ifr_fl_offset
index|]
condition|;
name|i
operator|++
control|)
block|{
name|err
operator|=
name|bus_dmamap_create
argument_list|(
name|fl
operator|->
name|ifl_desc_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to create RX buffer DMA map\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|fail
label|:
name|iflib_rx_structures_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Internal service routines  */
end_comment

begin_struct
struct|struct
name|rxq_refill_cb_arg
block|{
name|int
name|error
decl_stmt|;
name|bus_dma_segment_t
name|seg
decl_stmt|;
name|int
name|nseg
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|_rxq_refill_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|rxq_refill_cb_arg
modifier|*
name|cb_arg
init|=
name|arg
decl_stmt|;
name|cb_arg
operator|->
name|error
operator|=
name|error
expr_stmt|;
name|cb_arg
operator|->
name|seg
operator|=
name|segs
index|[
literal|0
index|]
expr_stmt|;
name|cb_arg
operator|->
name|nseg
operator|=
name|nseg
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ACPI_DMAR
end_ifdef

begin_define
define|#
directive|define
name|IS_DMAR
parameter_list|(
name|ctx
parameter_list|)
value|(ctx->ifc_flags& IFC_DMAR)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IS_DMAR
parameter_list|(
name|ctx
parameter_list|)
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  *	rxq_refill - refill an rxq  free-buffer list  *	@ctx: the iflib context  *	@rxq: the free-list to refill  *	@n: the number of new buffers to allocate  *  *	(Re)populate an rxq free-buffer list with up to @n new packet buffers.  *	The caller must assure that @n does not exceed the queue's capacity.  */
end_comment

begin_function
specifier|static
name|void
name|_iflib_fl_refill
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|iflib_fl_t
name|fl
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|frag_idx
init|=
name|fl
operator|->
name|ifl_fragidx
decl_stmt|;
name|int
name|pidx
init|=
name|fl
operator|->
name|ifl_pidx
decl_stmt|;
name|caddr_t
name|cl
decl_stmt|,
modifier|*
name|sd_cl
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|sd_m
decl_stmt|;
name|uint8_t
modifier|*
name|sd_flags
decl_stmt|;
name|struct
name|if_rxd_update
name|iru
decl_stmt|;
name|bus_dmamap_t
modifier|*
name|sd_map
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
init|=
literal|0
decl_stmt|;
name|uint64_t
name|bus_addr
decl_stmt|;
name|int
name|err
decl_stmt|;
name|sd_m
operator|=
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_m
expr_stmt|;
name|sd_map
operator|=
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_map
expr_stmt|;
name|sd_cl
operator|=
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_cl
expr_stmt|;
name|sd_flags
operator|=
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_flags
expr_stmt|;
name|idx
operator|=
name|pidx
expr_stmt|;
name|n
operator|=
name|count
expr_stmt|;
name|MPASS
argument_list|(
name|n
operator|>
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|fl
operator|->
name|ifl_credits
operator|+
name|n
operator|<=
name|fl
operator|->
name|ifl_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|pidx
operator|<
name|fl
operator|->
name|ifl_cidx
condition|)
name|MPASS
argument_list|(
name|pidx
operator|+
name|n
operator|<=
name|fl
operator|->
name|ifl_cidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pidx
operator|==
name|fl
operator|->
name|ifl_cidx
operator|&&
operator|(
name|fl
operator|->
name|ifl_credits
operator|<
name|fl
operator|->
name|ifl_size
operator|)
condition|)
name|MPASS
argument_list|(
name|fl
operator|->
name|ifl_gen
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|pidx
operator|>
name|fl
operator|->
name|ifl_cidx
condition|)
name|MPASS
argument_list|(
name|n
operator|<=
name|fl
operator|->
name|ifl_size
operator|-
name|pidx
operator|+
name|fl
operator|->
name|ifl_cidx
argument_list|)
expr_stmt|;
name|DBG_COUNTER_INC
argument_list|(
name|fl_refills
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|8
condition|)
name|DBG_COUNTER_INC
argument_list|(
name|fl_refills_large
argument_list|)
expr_stmt|;
name|iru
operator|.
name|iru_paddrs
operator|=
name|fl
operator|->
name|ifl_bus_addrs
expr_stmt|;
name|iru
operator|.
name|iru_vaddrs
operator|=
operator|&
name|fl
operator|->
name|ifl_vm_addrs
index|[
literal|0
index|]
expr_stmt|;
name|iru
operator|.
name|iru_idxs
operator|=
name|fl
operator|->
name|ifl_rxd_idxs
expr_stmt|;
name|iru
operator|.
name|iru_qsidx
operator|=
name|fl
operator|->
name|ifl_rxq
operator|->
name|ifr_id
expr_stmt|;
name|iru
operator|.
name|iru_buf_size
operator|=
name|fl
operator|->
name|ifl_buf_size
expr_stmt|;
name|iru
operator|.
name|iru_flidx
operator|=
name|fl
operator|->
name|ifl_id
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
comment|/* 		 * We allocate an uninitialized mbuf + cluster, mbuf is 		 * initialized after rx. 		 * 		 * If the cluster is still set then we know a minimum sized packet was received 		 */
name|bit_ffc_at
argument_list|(
name|fl
operator|->
name|ifl_rx_bitmap
argument_list|,
name|frag_idx
argument_list|,
name|fl
operator|->
name|ifl_size
argument_list|,
operator|&
name|frag_idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|frag_idx
operator|<
literal|0
operator|)
operator|||
operator|(
name|frag_idx
operator|>=
name|fl
operator|->
name|ifl_size
operator|)
condition|)
name|bit_ffc
argument_list|(
name|fl
operator|->
name|ifl_rx_bitmap
argument_list|,
name|fl
operator|->
name|ifl_size
argument_list|,
operator|&
name|frag_idx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cl
operator|=
name|sd_cl
index|[
name|frag_idx
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|cl
operator|=
name|sd_cl
index|[
name|frag_idx
index|]
operator|=
name|m_cljget
argument_list|(
name|NULL
argument_list|,
name|M_NOWAIT
argument_list|,
name|fl
operator|->
name|ifl_buf_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
if|#
directive|if
name|MEMORY_LOGGING
name|fl
operator|->
name|ifl_cl_enqueued
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_NOINIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
if|#
directive|if
name|MEMORY_LOGGING
name|fl
operator|->
name|ifl_m_enqueued
operator|++
expr_stmt|;
endif|#
directive|endif
name|DBG_COUNTER_INC
argument_list|(
name|rx_allocs
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
if|if
condition|(
operator|!
name|IS_DMAR
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
name|bus_addr
operator|=
name|pmap_kextract
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|cl
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|struct
name|rxq_refill_cb_arg
name|cb_arg
decl_stmt|;
name|iflib_rxq_t
name|q
decl_stmt|;
name|cb_arg
operator|.
name|error
operator|=
literal|0
expr_stmt|;
name|q
operator|=
name|fl
operator|->
name|ifl_rxq
expr_stmt|;
name|MPASS
argument_list|(
name|sd_map
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|sd_map
index|[
name|frag_idx
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|err
operator|=
name|bus_dmamap_load
argument_list|(
name|fl
operator|->
name|ifl_desc_tag
argument_list|,
name|sd_map
index|[
name|frag_idx
index|]
argument_list|,
name|cl
argument_list|,
name|fl
operator|->
name|ifl_buf_size
argument_list|,
name|_rxq_refill_cb
argument_list|,
operator|&
name|cb_arg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|fl
operator|->
name|ifl_desc_tag
argument_list|,
name|sd_map
index|[
name|frag_idx
index|]
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
name|cb_arg
operator|.
name|error
condition|)
block|{
comment|/* 				 * !zone_pack ? 				 */
if|if
condition|(
name|fl
operator|->
name|ifl_zone
operator|==
name|zone_pack
condition|)
name|uma_zfree
argument_list|(
name|fl
operator|->
name|ifl_zone
argument_list|,
name|cl
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|bus_addr
operator|=
name|cb_arg
operator|.
name|seg
operator|.
name|ds_addr
expr_stmt|;
block|}
name|bit_set
argument_list|(
name|fl
operator|->
name|ifl_rx_bitmap
argument_list|,
name|frag_idx
argument_list|)
expr_stmt|;
name|sd_flags
index|[
name|frag_idx
index|]
operator||=
name|RX_SW_DESC_INUSE
expr_stmt|;
name|MPASS
argument_list|(
name|sd_m
index|[
name|frag_idx
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|sd_cl
index|[
name|frag_idx
index|]
operator|=
name|cl
expr_stmt|;
name|sd_m
index|[
name|frag_idx
index|]
operator|=
name|m
expr_stmt|;
name|fl
operator|->
name|ifl_rxd_idxs
index|[
name|i
index|]
operator|=
name|frag_idx
expr_stmt|;
name|fl
operator|->
name|ifl_bus_addrs
index|[
name|i
index|]
operator|=
name|bus_addr
expr_stmt|;
name|fl
operator|->
name|ifl_vm_addrs
index|[
name|i
index|]
operator|=
name|cl
expr_stmt|;
name|fl
operator|->
name|ifl_credits
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|MPASS
argument_list|(
name|fl
operator|->
name|ifl_credits
operator|<=
name|fl
operator|->
name|ifl_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|idx
operator|==
name|fl
operator|->
name|ifl_size
condition|)
block|{
name|fl
operator|->
name|ifl_gen
operator|=
literal|1
expr_stmt|;
name|idx
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
operator|||
name|i
operator|==
name|IFLIB_MAX_RX_REFRESH
condition|)
block|{
name|iru
operator|.
name|iru_pidx
operator|=
name|pidx
expr_stmt|;
name|iru
operator|.
name|iru_count
operator|=
name|i
expr_stmt|;
name|ctx
operator|->
name|isc_rxd_refill
argument_list|(
name|ctx
operator|->
name|ifc_softc
argument_list|,
operator|&
name|iru
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|pidx
operator|=
name|idx
expr_stmt|;
name|fl
operator|->
name|ifl_pidx
operator|=
name|idx
expr_stmt|;
block|}
block|}
name|done
label|:
name|DBG_COUNTER_INC
argument_list|(
name|rxd_flush
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|ifl_pidx
operator|==
literal|0
condition|)
name|pidx
operator|=
name|fl
operator|->
name|ifl_size
operator|-
literal|1
expr_stmt|;
else|else
name|pidx
operator|=
name|fl
operator|->
name|ifl_pidx
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|sd_map
condition|)
name|bus_dmamap_sync
argument_list|(
name|fl
operator|->
name|ifl_ifdi
operator|->
name|idi_tag
argument_list|,
name|fl
operator|->
name|ifl_ifdi
operator|->
name|idi_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|isc_rxd_flush
argument_list|(
name|ctx
operator|->
name|ifc_softc
argument_list|,
name|fl
operator|->
name|ifl_rxq
operator|->
name|ifr_id
argument_list|,
name|fl
operator|->
name|ifl_id
argument_list|,
name|pidx
argument_list|)
expr_stmt|;
name|fl
operator|->
name|ifl_fragidx
operator|=
name|frag_idx
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|__iflib_fl_refill_lt
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|iflib_fl_t
name|fl
parameter_list|,
name|int
name|max
parameter_list|)
block|{
comment|/* we avoid allowing pidx to catch up with cidx as it confuses ixl */
name|int32_t
name|reclaimable
init|=
name|fl
operator|->
name|ifl_size
operator|-
name|fl
operator|->
name|ifl_credits
operator|-
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|int32_t
name|delta
init|=
name|fl
operator|->
name|ifl_size
operator|-
name|get_inuse
argument_list|(
name|fl
operator|->
name|ifl_size
argument_list|,
name|fl
operator|->
name|ifl_cidx
argument_list|,
name|fl
operator|->
name|ifl_pidx
argument_list|,
name|fl
operator|->
name|ifl_gen
argument_list|)
operator|-
literal|1
decl_stmt|;
endif|#
directive|endif
name|MPASS
argument_list|(
name|fl
operator|->
name|ifl_credits
operator|<=
name|fl
operator|->
name|ifl_size
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|reclaimable
operator|==
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclaimable
operator|>
literal|0
condition|)
name|_iflib_fl_refill
argument_list|(
name|ctx
argument_list|,
name|fl
argument_list|,
name|min
argument_list|(
name|max
argument_list|,
name|reclaimable
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iflib_fl_bufs_free
parameter_list|(
name|iflib_fl_t
name|fl
parameter_list|)
block|{
name|iflib_dma_info_t
name|idi
init|=
name|fl
operator|->
name|ifl_ifdi
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fl
operator|->
name|ifl_size
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|mbuf
modifier|*
modifier|*
name|sd_m
init|=
operator|&
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_m
index|[
name|i
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|sd_flags
init|=
operator|&
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_flags
index|[
name|i
index|]
decl_stmt|;
name|caddr_t
modifier|*
name|sd_cl
init|=
operator|&
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_cl
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|sd_flags
operator|&
name|RX_SW_DESC_INUSE
condition|)
block|{
if|if
condition|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_map
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_t
name|sd_map
init|=
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_map
index|[
name|i
index|]
decl_stmt|;
name|bus_dmamap_unload
argument_list|(
name|fl
operator|->
name|ifl_desc_tag
argument_list|,
name|sd_map
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|fl
operator|->
name|ifl_desc_tag
argument_list|,
name|sd_map
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|sd_m
operator|!=
name|NULL
condition|)
block|{
name|m_init
argument_list|(
operator|*
name|sd_m
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|zone_mbuf
argument_list|,
operator|*
name|sd_m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|sd_cl
operator|!=
name|NULL
condition|)
name|uma_zfree
argument_list|(
name|fl
operator|->
name|ifl_zone
argument_list|,
operator|*
name|sd_cl
argument_list|)
expr_stmt|;
operator|*
name|sd_flags
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|MPASS
argument_list|(
operator|*
name|sd_cl
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|*
name|sd_m
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|MEMORY_LOGGING
name|fl
operator|->
name|ifl_m_dequeued
operator|++
expr_stmt|;
name|fl
operator|->
name|ifl_cl_dequeued
operator|++
expr_stmt|;
endif|#
directive|endif
operator|*
name|sd_cl
operator|=
name|NULL
expr_stmt|;
operator|*
name|sd_m
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fl
operator|->
name|ifl_size
condition|;
name|i
operator|++
control|)
block|{
name|MPASS
argument_list|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_flags
index|[
name|i
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_cl
index|[
name|i
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_m
index|[
name|i
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Reset free list values 	 */
name|fl
operator|->
name|ifl_credits
operator|=
name|fl
operator|->
name|ifl_cidx
operator|=
name|fl
operator|->
name|ifl_pidx
operator|=
name|fl
operator|->
name|ifl_gen
operator|=
name|fl
operator|->
name|ifl_fragidx
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|idi
operator|->
name|idi_vaddr
argument_list|,
name|idi
operator|->
name|idi_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Initialize a receive ring and its buffers.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|iflib_fl_setup
parameter_list|(
name|iflib_fl_t
name|fl
parameter_list|)
block|{
name|iflib_rxq_t
name|rxq
init|=
name|fl
operator|->
name|ifl_rxq
decl_stmt|;
name|if_ctx_t
name|ctx
init|=
name|rxq
operator|->
name|ifr_ctx
decl_stmt|;
name|if_softc_ctx_t
name|sctx
init|=
operator|&
name|ctx
operator|->
name|ifc_softc_ctx
decl_stmt|;
name|bit_nclear
argument_list|(
name|fl
operator|->
name|ifl_rx_bitmap
argument_list|,
literal|0
argument_list|,
name|fl
operator|->
name|ifl_size
argument_list|)
expr_stmt|;
comment|/* 	** Free current RX buffer structs and their mbufs 	*/
name|iflib_fl_bufs_free
argument_list|(
name|fl
argument_list|)
expr_stmt|;
comment|/* Now replenish the mbufs */
name|MPASS
argument_list|(
name|fl
operator|->
name|ifl_credits
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * XXX don't set the max_frame_size to larger 	 * than the hardware can handle 	 */
if|if
condition|(
name|sctx
operator|->
name|isc_max_frame_size
operator|<=
literal|2048
condition|)
name|fl
operator|->
name|ifl_buf_size
operator|=
name|MCLBYTES
expr_stmt|;
ifndef|#
directive|ifndef
name|CONTIGMALLOC_WORKS
else|else
name|fl
operator|->
name|ifl_buf_size
operator|=
name|MJUMPAGESIZE
expr_stmt|;
else|#
directive|else
elseif|else
if|if
condition|(
name|sctx
operator|->
name|isc_max_frame_size
operator|<=
literal|4096
condition|)
name|fl
operator|->
name|ifl_buf_size
operator|=
name|MJUMPAGESIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|sctx
operator|->
name|isc_max_frame_size
operator|<=
literal|9216
condition|)
name|fl
operator|->
name|ifl_buf_size
operator|=
name|MJUM9BYTES
expr_stmt|;
else|else
name|fl
operator|->
name|ifl_buf_size
operator|=
name|MJUM16BYTES
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fl
operator|->
name|ifl_buf_size
operator|>
name|ctx
operator|->
name|ifc_max_fl_buf_size
condition|)
name|ctx
operator|->
name|ifc_max_fl_buf_size
operator|=
name|fl
operator|->
name|ifl_buf_size
expr_stmt|;
name|fl
operator|->
name|ifl_cltype
operator|=
name|m_gettype
argument_list|(
name|fl
operator|->
name|ifl_buf_size
argument_list|)
expr_stmt|;
name|fl
operator|->
name|ifl_zone
operator|=
name|m_getzone
argument_list|(
name|fl
operator|->
name|ifl_buf_size
argument_list|)
expr_stmt|;
comment|/* avoid pre-allocating zillions of clusters to an idle card 	 * potentially speeding up attach 	 */
name|_iflib_fl_refill
argument_list|(
name|ctx
argument_list|,
name|fl
argument_list|,
name|min
argument_list|(
literal|128
argument_list|,
name|fl
operator|->
name|ifl_size
argument_list|)
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|min
argument_list|(
literal|128
argument_list|,
name|fl
operator|->
name|ifl_size
argument_list|)
operator|==
name|fl
operator|->
name|ifl_credits
argument_list|)
expr_stmt|;
if|if
condition|(
name|min
argument_list|(
literal|128
argument_list|,
name|fl
operator|->
name|ifl_size
argument_list|)
operator|!=
name|fl
operator|->
name|ifl_credits
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
comment|/* 	 * handle failure 	 */
name|MPASS
argument_list|(
name|rxq
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|fl
operator|->
name|ifl_ifdi
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|fl
operator|->
name|ifl_ifdi
operator|->
name|idi_tag
argument_list|,
name|fl
operator|->
name|ifl_ifdi
operator|->
name|idi_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Free receive ring data structures  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|iflib_rx_sds_free
parameter_list|(
name|iflib_rxq_t
name|rxq
parameter_list|)
block|{
name|iflib_fl_t
name|fl
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|rxq
operator|->
name|ifr_fl
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rxq
operator|->
name|ifr_nfl
condition|;
name|i
operator|++
control|)
block|{
name|fl
operator|=
operator|&
name|rxq
operator|->
name|ifr_fl
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|ifl_desc_tag
operator|!=
name|NULL
condition|)
block|{
name|bus_dma_tag_destroy
argument_list|(
name|fl
operator|->
name|ifl_desc_tag
argument_list|)
expr_stmt|;
name|fl
operator|->
name|ifl_desc_tag
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_m
argument_list|,
name|M_IFLIB
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_cl
argument_list|,
name|M_IFLIB
argument_list|)
expr_stmt|;
comment|/* XXX destroy maps first */
name|free
argument_list|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_map
argument_list|,
name|M_IFLIB
argument_list|)
expr_stmt|;
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_m
operator|=
name|NULL
expr_stmt|;
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_cl
operator|=
name|NULL
expr_stmt|;
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_map
operator|=
name|NULL
expr_stmt|;
block|}
name|free
argument_list|(
name|rxq
operator|->
name|ifr_fl
argument_list|,
name|M_IFLIB
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|ifr_fl
operator|=
name|NULL
expr_stmt|;
name|rxq
operator|->
name|ifr_cq_gen
operator|=
name|rxq
operator|->
name|ifr_cq_cidx
operator|=
name|rxq
operator|->
name|ifr_cq_pidx
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * MI independent logic  *  */
end_comment

begin_function
specifier|static
name|void
name|iflib_timer
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|iflib_txq_t
name|txq
init|=
name|arg
decl_stmt|;
name|if_ctx_t
name|ctx
init|=
name|txq
operator|->
name|ift_ctx
decl_stmt|;
name|if_softc_ctx_t
name|sctx
init|=
operator|&
name|ctx
operator|->
name|ifc_softc_ctx
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|if_getdrvflags
argument_list|(
name|ctx
operator|->
name|ifc_ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
return|return;
comment|/* 	** Check on the state of the TX queue(s), this 	** can be done without the lock because its RO 	** and the HUNG state will be static if set. 	*/
name|IFDI_TIMER
argument_list|(
name|ctx
argument_list|,
name|txq
operator|->
name|ift_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|txq
operator|->
name|ift_qstatus
operator|==
name|IFLIB_QUEUE_HUNG
operator|)
operator|&&
operator|(
operator|(
name|txq
operator|->
name|ift_cleaned_prev
operator|==
name|txq
operator|->
name|ift_cleaned
operator|)
operator|||
operator|(
name|sctx
operator|->
name|isc_pause_frames
operator|==
literal|0
operator|)
operator|)
condition|)
goto|goto
name|hung
goto|;
if|if
condition|(
name|ifmp_ring_is_stalled
argument_list|(
name|txq
operator|->
name|ift_br
argument_list|)
condition|)
name|txq
operator|->
name|ift_qstatus
operator|=
name|IFLIB_QUEUE_HUNG
expr_stmt|;
name|txq
operator|->
name|ift_cleaned_prev
operator|=
name|txq
operator|->
name|ift_cleaned
expr_stmt|;
comment|/* handle any laggards */
if|if
condition|(
name|txq
operator|->
name|ift_db_pending
condition|)
name|GROUPTASK_ENQUEUE
argument_list|(
operator|&
name|txq
operator|->
name|ift_task
argument_list|)
expr_stmt|;
name|sctx
operator|->
name|isc_pause_frames
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ctx
operator|->
name|ifc_ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
name|callout_reset_on
argument_list|(
operator|&
name|txq
operator|->
name|ift_timer
argument_list|,
name|hz
operator|/
literal|2
argument_list|,
name|iflib_timer
argument_list|,
name|txq
argument_list|,
name|txq
operator|->
name|ift_timer
operator|.
name|c_cpu
argument_list|)
expr_stmt|;
return|return;
name|hung
label|:
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|if_setdrvflagbits
argument_list|(
name|ctx
operator|->
name|ifc_ifp
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|,
name|IFF_DRV_RUNNING
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|ctx
operator|->
name|ifc_dev
argument_list|,
literal|"TX(%d) desc avail = %d, pidx = %d\n"
argument_list|,
name|txq
operator|->
name|ift_id
argument_list|,
name|TXQ_AVAIL
argument_list|(
name|txq
argument_list|)
argument_list|,
name|txq
operator|->
name|ift_pidx
argument_list|)
expr_stmt|;
name|IFDI_WATCHDOG_RESET
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ifc_watchdog_events
operator|++
expr_stmt|;
name|ctx
operator|->
name|ifc_flags
operator||=
name|IFC_DO_RESET
expr_stmt|;
name|iflib_admin_intr_deferred
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iflib_init_locked
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|if_softc_ctx_t
name|sctx
init|=
operator|&
name|ctx
operator|->
name|ifc_softc_ctx
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
operator|&
name|ctx
operator|->
name|ifc_softc_ctx
decl_stmt|;
name|if_t
name|ifp
init|=
name|ctx
operator|->
name|ifc_ifp
decl_stmt|;
name|iflib_fl_t
name|fl
decl_stmt|;
name|iflib_txq_t
name|txq
decl_stmt|;
name|iflib_rxq_t
name|rxq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|tx_ip_csum_flags
decl_stmt|,
name|tx_ip6_csum_flags
decl_stmt|;
name|if_setdrvflagbits
argument_list|(
name|ifp
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|,
name|IFF_DRV_RUNNING
argument_list|)
expr_stmt|;
name|IFDI_INTR_DISABLE
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|tx_ip_csum_flags
operator|=
name|scctx
operator|->
name|isc_tx_csum_flags
operator|&
operator|(
name|CSUM_IP
operator||
name|CSUM_TCP
operator||
name|CSUM_UDP
operator||
name|CSUM_SCTP
operator|)
expr_stmt|;
name|tx_ip6_csum_flags
operator|=
name|scctx
operator|->
name|isc_tx_csum_flags
operator|&
operator|(
name|CSUM_IP6_TCP
operator||
name|CSUM_IP6_UDP
operator||
name|CSUM_IP6_SCTP
operator|)
expr_stmt|;
comment|/* Set hardware offload abilities */
name|if_clearhwassist
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_TXCSUM
condition|)
name|if_sethwassistbits
argument_list|(
name|ifp
argument_list|,
name|tx_ip_csum_flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_TXCSUM_IPV6
condition|)
name|if_sethwassistbits
argument_list|(
name|ifp
argument_list|,
name|tx_ip6_csum_flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_TSO4
condition|)
name|if_sethwassistbits
argument_list|(
name|ifp
argument_list|,
name|CSUM_IP_TSO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_TSO6
condition|)
name|if_sethwassistbits
argument_list|(
name|ifp
argument_list|,
name|CSUM_IP6_TSO
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|txq
operator|=
name|ctx
operator|->
name|ifc_txqs
init|;
name|i
operator|<
name|sctx
operator|->
name|isc_ntxqsets
condition|;
name|i
operator|++
operator|,
name|txq
operator|++
control|)
block|{
name|CALLOUT_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|txq
operator|->
name|ift_timer
argument_list|)
expr_stmt|;
name|CALLOUT_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|iflib_netmap_txq_init
argument_list|(
name|ctx
argument_list|,
name|txq
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rxq
operator|=
name|ctx
operator|->
name|ifc_rxqs
init|;
name|i
operator|<
name|sctx
operator|->
name|isc_nrxqsets
condition|;
name|i
operator|++
operator|,
name|rxq
operator|++
control|)
block|{
name|MPASS
argument_list|(
name|rxq
operator|->
name|ifr_id
operator|==
name|i
argument_list|)
expr_stmt|;
name|iflib_netmap_rxq_init
argument_list|(
name|ctx
argument_list|,
name|rxq
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
name|i
operator|=
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IFDI_INIT
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|==
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rxq
operator|=
name|ctx
operator|->
name|ifc_rxqs
init|;
name|i
operator|<
name|sctx
operator|->
name|isc_nrxqsets
condition|;
name|i
operator|++
operator|,
name|rxq
operator|++
control|)
block|{
comment|/* XXX this should really be done on a per-queue basis */
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_NETMAP
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|fl
operator|=
name|rxq
operator|->
name|ifr_fl
init|;
name|j
operator|<
name|rxq
operator|->
name|ifr_nfl
condition|;
name|j
operator|++
operator|,
name|fl
operator|++
control|)
block|{
if|if
condition|(
name|iflib_fl_setup
argument_list|(
name|fl
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|ctx
operator|->
name|ifc_dev
argument_list|,
literal|"freelist setup failed - check cluster settings\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
name|done
label|:
name|if_setdrvflagbits
argument_list|(
name|ctx
operator|->
name|ifc_ifp
argument_list|,
name|IFF_DRV_RUNNING
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|)
expr_stmt|;
name|IFDI_INTR_ENABLE
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|txq
operator|=
name|ctx
operator|->
name|ifc_txqs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sctx
operator|->
name|isc_ntxqsets
condition|;
name|i
operator|++
operator|,
name|txq
operator|++
control|)
name|callout_reset_on
argument_list|(
operator|&
name|txq
operator|->
name|ift_timer
argument_list|,
name|hz
operator|/
literal|2
argument_list|,
name|iflib_timer
argument_list|,
name|txq
argument_list|,
name|txq
operator|->
name|ift_timer
operator|.
name|c_cpu
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iflib_media_change
parameter_list|(
name|if_t
name|ifp
parameter_list|)
block|{
name|if_ctx_t
name|ctx
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|IFDI_MEDIA_CHANGE
argument_list|(
name|ctx
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|iflib_init_locked
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iflib_media_status
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|ifmr
parameter_list|)
block|{
name|if_ctx_t
name|ctx
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|IFDI_UPDATE_ADMIN_STATUS
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|IFDI_MEDIA_STATUS
argument_list|(
name|ctx
argument_list|,
name|ifmr
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iflib_stop
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|iflib_txq_t
name|txq
init|=
name|ctx
operator|->
name|ifc_txqs
decl_stmt|;
name|iflib_rxq_t
name|rxq
init|=
name|ctx
operator|->
name|ifc_rxqs
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
operator|&
name|ctx
operator|->
name|ifc_softc_ctx
decl_stmt|;
name|iflib_dma_info_t
name|di
decl_stmt|;
name|iflib_fl_t
name|fl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Tell the stack that the interface is no longer active */
name|if_setdrvflagbits
argument_list|(
name|ctx
operator|->
name|ifc_ifp
argument_list|,
name|IFF_DRV_OACTIVE
argument_list|,
name|IFF_DRV_RUNNING
argument_list|)
expr_stmt|;
name|IFDI_INTR_DISABLE
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|IFDI_STOP
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|iflib_debug_reset
argument_list|()
expr_stmt|;
comment|/* Wait for current tx queue users to exit to disarm watchdog timer. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scctx
operator|->
name|isc_ntxqsets
condition|;
name|i
operator|++
operator|,
name|txq
operator|++
control|)
block|{
comment|/* make sure all transmitters have completed before proceeding XXX */
comment|/* clean any enqueued buffers */
name|iflib_ifmp_purge
argument_list|(
name|txq
argument_list|)
expr_stmt|;
comment|/* Free any existing tx buffers. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|txq
operator|->
name|ift_size
condition|;
name|j
operator|++
control|)
block|{
name|iflib_txsd_free
argument_list|(
name|ctx
argument_list|,
name|txq
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
name|txq
operator|->
name|ift_processed
operator|=
name|txq
operator|->
name|ift_cleaned
operator|=
name|txq
operator|->
name|ift_cidx_processed
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|ift_in_use
operator|=
name|txq
operator|->
name|ift_gen
operator|=
name|txq
operator|->
name|ift_cidx
operator|=
name|txq
operator|->
name|ift_pidx
operator|=
name|txq
operator|->
name|ift_no_desc_avail
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|ift_closed
operator|=
name|txq
operator|->
name|ift_mbuf_defrag
operator|=
name|txq
operator|->
name|ift_mbuf_defrag_failed
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|ift_no_tx_dma_setup
operator|=
name|txq
operator|->
name|ift_txd_encap_efbig
operator|=
name|txq
operator|->
name|ift_map_failed
operator|=
literal|0
expr_stmt|;
name|txq
operator|->
name|ift_pullups
operator|=
literal|0
expr_stmt|;
name|ifmp_ring_reset_stats
argument_list|(
name|txq
operator|->
name|ift_br
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|di
operator|=
name|txq
operator|->
name|ift_ifdi
init|;
name|j
operator|<
name|ctx
operator|->
name|ifc_nhwtxqs
condition|;
name|j
operator|++
operator|,
name|di
operator|++
control|)
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|di
operator|->
name|idi_vaddr
argument_list|,
name|di
operator|->
name|idi_size
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scctx
operator|->
name|isc_nrxqsets
condition|;
name|i
operator|++
operator|,
name|rxq
operator|++
control|)
block|{
comment|/* make sure all transmitters have completed before proceeding XXX */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|di
operator|=
name|txq
operator|->
name|ift_ifdi
init|;
name|j
operator|<
name|ctx
operator|->
name|ifc_nhwrxqs
condition|;
name|j
operator|++
operator|,
name|di
operator|++
control|)
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|di
operator|->
name|idi_vaddr
argument_list|,
name|di
operator|->
name|idi_size
argument_list|)
expr_stmt|;
comment|/* also resets the free lists pidx/cidx */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|fl
operator|=
name|rxq
operator|->
name|ifr_fl
init|;
name|j
operator|<
name|rxq
operator|->
name|ifr_nfl
condition|;
name|j
operator|++
operator|,
name|fl
operator|++
control|)
name|iflib_fl_bufs_free
argument_list|(
name|fl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|caddr_t
name|calc_next_rxd
parameter_list|(
name|iflib_fl_t
name|fl
parameter_list|,
name|int
name|cidx
parameter_list|)
block|{
name|qidx_t
name|size
decl_stmt|;
name|int
name|nrxd
decl_stmt|;
name|caddr_t
name|start
decl_stmt|,
name|end
decl_stmt|,
name|cur
decl_stmt|,
name|next
decl_stmt|;
name|nrxd
operator|=
name|fl
operator|->
name|ifl_size
expr_stmt|;
name|size
operator|=
name|fl
operator|->
name|ifl_rxd_size
expr_stmt|;
name|start
operator|=
name|fl
operator|->
name|ifl_ifdi
operator|->
name|idi_vaddr
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|size
operator|==
literal|0
argument_list|)
condition|)
return|return
operator|(
name|start
operator|)
return|;
name|cur
operator|=
name|start
operator|+
name|size
operator|*
name|cidx
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|size
operator|*
name|nrxd
expr_stmt|;
name|next
operator|=
name|CACHE_PTR_NEXT
argument_list|(
name|cur
argument_list|)
expr_stmt|;
return|return
operator|(
name|next
operator|<
name|end
condition|?
name|next
else|:
name|start
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|prefetch_pkts
parameter_list|(
name|iflib_fl_t
name|fl
parameter_list|,
name|int
name|cidx
parameter_list|)
block|{
name|int
name|nextptr
decl_stmt|;
name|int
name|nrxd
init|=
name|fl
operator|->
name|ifl_size
decl_stmt|;
name|caddr_t
name|next_rxd
decl_stmt|;
name|nextptr
operator|=
operator|(
name|cidx
operator|+
name|CACHE_PTR_INCREMENT
operator|)
operator|&
operator|(
name|nrxd
operator|-
literal|1
operator|)
expr_stmt|;
name|prefetch
argument_list|(
operator|&
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_m
index|[
name|nextptr
index|]
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
operator|&
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_cl
index|[
name|nextptr
index|]
argument_list|)
expr_stmt|;
name|next_rxd
operator|=
name|calc_next_rxd
argument_list|(
name|fl
argument_list|,
name|cidx
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|next_rxd
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_m
index|[
operator|(
name|cidx
operator|+
literal|1
operator|)
operator|&
operator|(
name|nrxd
operator|-
literal|1
operator|)
index|]
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_m
index|[
operator|(
name|cidx
operator|+
literal|2
operator|)
operator|&
operator|(
name|nrxd
operator|-
literal|1
operator|)
index|]
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_m
index|[
operator|(
name|cidx
operator|+
literal|3
operator|)
operator|&
operator|(
name|nrxd
operator|-
literal|1
operator|)
index|]
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_m
index|[
operator|(
name|cidx
operator|+
literal|4
operator|)
operator|&
operator|(
name|nrxd
operator|-
literal|1
operator|)
index|]
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_cl
index|[
operator|(
name|cidx
operator|+
literal|1
operator|)
operator|&
operator|(
name|nrxd
operator|-
literal|1
operator|)
index|]
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_cl
index|[
operator|(
name|cidx
operator|+
literal|2
operator|)
operator|&
operator|(
name|nrxd
operator|-
literal|1
operator|)
index|]
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_cl
index|[
operator|(
name|cidx
operator|+
literal|3
operator|)
operator|&
operator|(
name|nrxd
operator|-
literal|1
operator|)
index|]
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_cl
index|[
operator|(
name|cidx
operator|+
literal|4
operator|)
operator|&
operator|(
name|nrxd
operator|-
literal|1
operator|)
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rxd_frag_to_sd
parameter_list|(
name|iflib_rxq_t
name|rxq
parameter_list|,
name|if_rxd_frag_t
name|irf
parameter_list|,
name|int
name|unload
parameter_list|,
name|if_rxsd_t
name|sd
parameter_list|)
block|{
name|int
name|flid
decl_stmt|,
name|cidx
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|iflib_fl_t
name|fl
decl_stmt|;
name|iflib_dma_info_t
name|di
decl_stmt|;
name|int
name|next
decl_stmt|;
name|map
operator|=
name|NULL
expr_stmt|;
name|flid
operator|=
name|irf
operator|->
name|irf_flid
expr_stmt|;
name|cidx
operator|=
name|irf
operator|->
name|irf_idx
expr_stmt|;
name|fl
operator|=
operator|&
name|rxq
operator|->
name|ifr_fl
index|[
name|flid
index|]
expr_stmt|;
name|sd
operator|->
name|ifsd_fl
operator|=
name|fl
expr_stmt|;
name|sd
operator|->
name|ifsd_cidx
operator|=
name|cidx
expr_stmt|;
name|sd
operator|->
name|ifsd_m
operator|=
operator|&
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_m
index|[
name|cidx
index|]
expr_stmt|;
name|sd
operator|->
name|ifsd_cl
operator|=
operator|&
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_cl
index|[
name|cidx
index|]
expr_stmt|;
name|fl
operator|->
name|ifl_credits
operator|--
expr_stmt|;
if|#
directive|if
name|MEMORY_LOGGING
name|fl
operator|->
name|ifl_m_dequeued
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rxq
operator|->
name|ifr_ctx
operator|->
name|ifc_flags
operator|&
name|IFC_PREFETCH
condition|)
name|prefetch_pkts
argument_list|(
name|fl
argument_list|,
name|cidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_map
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
operator|(
name|cidx
operator|+
name|CACHE_PTR_INCREMENT
operator|)
operator|&
operator|(
name|fl
operator|->
name|ifl_size
operator|-
literal|1
operator|)
expr_stmt|;
name|prefetch
argument_list|(
operator|&
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_map
index|[
name|next
index|]
argument_list|)
expr_stmt|;
name|map
operator|=
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_map
index|[
name|cidx
index|]
expr_stmt|;
name|di
operator|=
name|fl
operator|->
name|ifl_ifdi
expr_stmt|;
name|next
operator|=
operator|(
name|cidx
operator|+
name|CACHE_LINE_SIZE
operator|)
operator|&
operator|(
name|fl
operator|->
name|ifl_size
operator|-
literal|1
operator|)
expr_stmt|;
name|prefetch
argument_list|(
operator|&
name|fl
operator|->
name|ifl_sds
operator|.
name|ifsd_flags
index|[
name|next
index|]
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|di
operator|->
name|idi_tag
argument_list|,
name|di
operator|->
name|idi_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
operator||
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
comment|/* not valid assert if bxe really does SGE from non-contiguous elements */
name|MPASS
argument_list|(
name|fl
operator|->
name|ifl_cidx
operator|==
name|cidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|unload
condition|)
name|bus_dmamap_unload
argument_list|(
name|fl
operator|->
name|ifl_desc_tag
argument_list|,
name|map
argument_list|)
expr_stmt|;
block|}
name|fl
operator|->
name|ifl_cidx
operator|=
operator|(
name|fl
operator|->
name|ifl_cidx
operator|+
literal|1
operator|)
operator|&
operator|(
name|fl
operator|->
name|ifl_size
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|fl
operator|->
name|ifl_cidx
operator|==
literal|0
argument_list|)
condition|)
name|fl
operator|->
name|ifl_gen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|map
operator|!=
name|NULL
condition|)
name|bus_dmamap_sync
argument_list|(
name|fl
operator|->
name|ifl_ifdi
operator|->
name|idi_tag
argument_list|,
name|fl
operator|->
name|ifl_ifdi
operator|->
name|idi_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bit_clear
argument_list|(
name|fl
operator|->
name|ifl_rx_bitmap
argument_list|,
name|cidx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|assemble_segments
parameter_list|(
name|iflib_rxq_t
name|rxq
parameter_list|,
name|if_rxd_info_t
name|ri
parameter_list|,
name|if_rxsd_t
name|sd
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|padlen
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mh
decl_stmt|,
modifier|*
name|mt
decl_stmt|;
name|caddr_t
name|cl
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|mh
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|rxd_frag_to_sd
argument_list|(
name|rxq
argument_list|,
operator|&
name|ri
operator|->
name|iri_frags
index|[
name|i
index|]
argument_list|,
name|TRUE
argument_list|,
name|sd
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|*
name|sd
operator|->
name|ifsd_cl
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
operator|*
name|sd
operator|->
name|ifsd_m
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Don't include zero-length frags */
if|if
condition|(
name|ri
operator|->
name|iri_frags
index|[
name|i
index|]
operator|.
name|irf_len
operator|==
literal|0
condition|)
block|{
comment|/* XXX we can save the cluster here, but not the mbuf */
name|m_init
argument_list|(
operator|*
name|sd
operator|->
name|ifsd_m
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
operator|*
name|sd
operator|->
name|ifsd_m
argument_list|)
expr_stmt|;
operator|*
name|sd
operator|->
name|ifsd_m
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
name|m
operator|=
operator|*
name|sd
operator|->
name|ifsd_m
expr_stmt|;
operator|*
name|sd
operator|->
name|ifsd_m
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mh
operator|==
name|NULL
condition|)
block|{
name|flags
operator|=
name|M_PKTHDR
operator||
name|M_EXT
expr_stmt|;
name|mh
operator|=
name|mt
operator|=
name|m
expr_stmt|;
name|padlen
operator|=
name|ri
operator|->
name|iri_pad
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|=
name|M_EXT
expr_stmt|;
name|mt
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|mt
operator|=
name|m
expr_stmt|;
comment|/* assuming padding is only on the first fragment */
name|padlen
operator|=
literal|0
expr_stmt|;
block|}
name|cl
operator|=
operator|*
name|sd
operator|->
name|ifsd_cl
expr_stmt|;
operator|*
name|sd
operator|->
name|ifsd_cl
operator|=
name|NULL
expr_stmt|;
comment|/* Can these two be made one ? */
name|m_init
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|m_cljset
argument_list|(
name|m
argument_list|,
name|cl
argument_list|,
name|sd
operator|->
name|ifsd_fl
operator|->
name|ifl_cltype
argument_list|)
expr_stmt|;
comment|/* 		 * These must follow m_init and m_cljset 		 */
name|m
operator|->
name|m_data
operator|+=
name|padlen
expr_stmt|;
name|ri
operator|->
name|iri_len
operator|-=
name|padlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|ri
operator|->
name|iri_frags
index|[
name|i
index|]
operator|.
name|irf_len
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|<
name|ri
operator|->
name|iri_nfrags
condition|)
do|;
return|return
operator|(
name|mh
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process one software descriptor  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|iflib_rxd_pkt_get
parameter_list|(
name|iflib_rxq_t
name|rxq
parameter_list|,
name|if_rxd_info_t
name|ri
parameter_list|)
block|{
name|struct
name|if_rxsd
name|sd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* should I merge this back in now that the two paths are basically duplicated? */
if|if
condition|(
name|ri
operator|->
name|iri_nfrags
operator|==
literal|1
operator|&&
name|ri
operator|->
name|iri_frags
index|[
literal|0
index|]
operator|.
name|irf_len
operator|<=
name|IFLIB_RX_COPY_THRESH
condition|)
block|{
name|rxd_frag_to_sd
argument_list|(
name|rxq
argument_list|,
operator|&
name|ri
operator|->
name|iri_frags
index|[
literal|0
index|]
argument_list|,
name|FALSE
argument_list|,
operator|&
name|sd
argument_list|)
expr_stmt|;
name|m
operator|=
operator|*
name|sd
operator|.
name|ifsd_m
expr_stmt|;
operator|*
name|sd
operator|.
name|ifsd_m
operator|=
name|NULL
expr_stmt|;
name|m_init
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
if|if
condition|(
operator|!
name|IP_ALIGNED
argument_list|(
name|m
argument_list|)
condition|)
name|m
operator|->
name|m_data
operator|+=
literal|2
expr_stmt|;
endif|#
directive|endif
name|memcpy
argument_list|(
name|m
operator|->
name|m_data
argument_list|,
operator|*
name|sd
operator|.
name|ifsd_cl
argument_list|,
name|ri
operator|->
name|iri_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|ri
operator|->
name|iri_frags
index|[
literal|0
index|]
operator|.
name|irf_len
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|assemble_segments
argument_list|(
name|rxq
argument_list|,
name|ri
argument_list|,
operator|&
name|sd
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|ri
operator|->
name|iri_len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ri
operator|->
name|iri_ifp
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|ri
operator|->
name|iri_flags
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|ri
operator|->
name|iri_vtag
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|ri
operator|->
name|iri_flowid
expr_stmt|;
name|M_HASHTYPE_SET
argument_list|(
name|m
argument_list|,
name|ri
operator|->
name|iri_rsstype
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|ri
operator|->
name|iri_csum_flags
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|ri
operator|->
name|iri_csum_data
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|iflib_rxeof
parameter_list|(
name|iflib_rxq_t
name|rxq
parameter_list|,
name|qidx_t
name|budget
parameter_list|)
block|{
name|if_ctx_t
name|ctx
init|=
name|rxq
operator|->
name|ifr_ctx
decl_stmt|;
name|if_shared_ctx_t
name|sctx
init|=
name|ctx
operator|->
name|ifc_sctx
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
operator|&
name|ctx
operator|->
name|ifc_softc_ctx
decl_stmt|;
name|int
name|avail
decl_stmt|,
name|i
decl_stmt|;
name|qidx_t
modifier|*
name|cidxp
decl_stmt|;
name|struct
name|if_rxd_info
name|ri
decl_stmt|;
name|int
name|err
decl_stmt|,
name|budget_left
decl_stmt|,
name|rx_bytes
decl_stmt|,
name|rx_pkts
decl_stmt|;
name|iflib_fl_t
name|fl
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|lro_enabled
decl_stmt|;
comment|/* 	 * XXX early demux data packets so that if_input processing only handles 	 * acks in interrupt context 	 */
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mh
decl_stmt|,
modifier|*
name|mt
decl_stmt|;
name|ifp
operator|=
name|ctx
operator|->
name|ifc_ifp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEV_NETMAP
if|if
condition|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
condition|)
block|{
name|u_int
name|work
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|netmap_rx_irq
argument_list|(
name|ifp
argument_list|,
name|rxq
operator|->
name|ifr_id
argument_list|,
operator|&
name|work
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
endif|#
directive|endif
name|mh
operator|=
name|mt
operator|=
name|NULL
expr_stmt|;
name|MPASS
argument_list|(
name|budget
operator|>
literal|0
argument_list|)
expr_stmt|;
name|rx_pkts
operator|=
name|rx_bytes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sctx
operator|->
name|isc_flags
operator|&
name|IFLIB_HAS_RXCQ
condition|)
name|cidxp
operator|=
operator|&
name|rxq
operator|->
name|ifr_cq_cidx
expr_stmt|;
else|else
name|cidxp
operator|=
operator|&
name|rxq
operator|->
name|ifr_fl
index|[
literal|0
index|]
operator|.
name|ifl_cidx
expr_stmt|;
if|if
condition|(
operator|(
name|avail
operator|=
name|iflib_rxd_avail
argument_list|(
name|ctx
argument_list|,
name|rxq
argument_list|,
operator|*
name|cidxp
argument_list|,
name|budget
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|fl
operator|=
operator|&
name|rxq
operator|->
name|ifr_fl
index|[
literal|0
index|]
init|;
name|i
operator|<
name|sctx
operator|->
name|isc_nfl
condition|;
name|i
operator|++
operator|,
name|fl
operator|++
control|)
name|__iflib_fl_refill_lt
argument_list|(
name|ctx
argument_list|,
name|fl
argument_list|,
name|budget
operator|+
literal|8
argument_list|)
expr_stmt|;
name|DBG_COUNTER_INC
argument_list|(
name|rx_unavail
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
for|for
control|(
name|budget_left
operator|=
name|budget
init|;
operator|(
name|budget_left
operator|>
literal|0
operator|)
operator|&&
operator|(
name|avail
operator|>
literal|0
operator|)
condition|;
name|budget_left
operator|--
operator|,
name|avail
operator|--
control|)
block|{
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|CTX_ACTIVE
argument_list|(
name|ctx
argument_list|)
argument_list|)
condition|)
block|{
name|DBG_COUNTER_INC
argument_list|(
name|rx_ctx_inactive
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Reset client set fields to their default values 		 */
name|rxd_info_zero
argument_list|(
operator|&
name|ri
argument_list|)
expr_stmt|;
name|ri
operator|.
name|iri_qsidx
operator|=
name|rxq
operator|->
name|ifr_id
expr_stmt|;
name|ri
operator|.
name|iri_cidx
operator|=
operator|*
name|cidxp
expr_stmt|;
name|ri
operator|.
name|iri_ifp
operator|=
name|ifp
expr_stmt|;
name|ri
operator|.
name|iri_frags
operator|=
name|rxq
operator|->
name|ifr_frags
expr_stmt|;
name|err
operator|=
name|ctx
operator|->
name|isc_rxd_pkt_get
argument_list|(
name|ctx
operator|->
name|ifc_softc
argument_list|,
operator|&
name|ri
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|sctx
operator|->
name|isc_flags
operator|&
name|IFLIB_HAS_RXCQ
condition|)
block|{
operator|*
name|cidxp
operator|=
name|ri
operator|.
name|iri_cidx
expr_stmt|;
comment|/* Update our consumer index */
comment|/* XXX NB: shurd - check if this is still safe */
while|while
condition|(
name|rxq
operator|->
name|ifr_cq_cidx
operator|>=
name|scctx
operator|->
name|isc_nrxd
index|[
literal|0
index|]
condition|)
block|{
name|rxq
operator|->
name|ifr_cq_cidx
operator|-=
name|scctx
operator|->
name|isc_nrxd
index|[
literal|0
index|]
expr_stmt|;
name|rxq
operator|->
name|ifr_cq_gen
operator|=
literal|0
expr_stmt|;
block|}
comment|/* was this only a completion queue message? */
if|if
condition|(
name|__predict_false
argument_list|(
name|ri
operator|.
name|iri_nfrags
operator|==
literal|0
argument_list|)
condition|)
continue|continue;
block|}
name|MPASS
argument_list|(
name|ri
operator|.
name|iri_nfrags
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ri
operator|.
name|iri_len
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* will advance the cidx on the corresponding free lists */
name|m
operator|=
name|iflib_rxd_pkt_get
argument_list|(
name|rxq
argument_list|,
operator|&
name|ri
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail
operator|==
literal|0
operator|&&
name|budget_left
condition|)
name|avail
operator|=
name|iflib_rxd_avail
argument_list|(
name|ctx
argument_list|,
name|rxq
argument_list|,
operator|*
name|cidxp
argument_list|,
name|budget_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|DBG_COUNTER_INC
argument_list|(
name|rx_mbuf_null
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* imm_pkt: -- cxgb */
if|if
condition|(
name|mh
operator|==
name|NULL
condition|)
name|mh
operator|=
name|mt
operator|=
name|m
expr_stmt|;
else|else
block|{
name|mt
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
name|mt
operator|=
name|m
expr_stmt|;
block|}
block|}
comment|/* make sure that we can refill faster than drain */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|fl
operator|=
operator|&
name|rxq
operator|->
name|ifr_fl
index|[
literal|0
index|]
init|;
name|i
operator|<
name|sctx
operator|->
name|isc_nfl
condition|;
name|i
operator|++
operator|,
name|fl
operator|++
control|)
name|__iflib_fl_refill_lt
argument_list|(
name|ctx
argument_list|,
name|fl
argument_list|,
name|budget
operator|+
literal|8
argument_list|)
expr_stmt|;
name|lro_enabled
operator|=
operator|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_LRO
operator|)
expr_stmt|;
while|while
condition|(
name|mh
operator|!=
name|NULL
condition|)
block|{
name|m
operator|=
name|mh
expr_stmt|;
name|mh
operator|=
name|mh
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
if|if
condition|(
operator|!
name|IP_ALIGNED
argument_list|(
name|m
argument_list|)
operator|&&
operator|(
name|m
operator|=
name|iflib_fixup_rx
argument_list|(
name|m
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
endif|#
directive|endif
name|rx_bytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|rx_pkts
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|||
name|defined
argument_list|(
name|INET
argument_list|)
if|if
condition|(
name|lro_enabled
operator|&&
name|tcp_lro_rx
argument_list|(
operator|&
name|rxq
operator|->
name|ifr_lc
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
endif|#
directive|endif
name|DBG_COUNTER_INC
argument_list|(
name|rx_if_input
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_input
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IBYTES
argument_list|,
name|rx_bytes
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IPACKETS
argument_list|,
name|rx_pkts
argument_list|)
expr_stmt|;
comment|/* 	 * Flush any outstanding LRO work 	 */
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|||
name|defined
argument_list|(
name|INET
argument_list|)
name|tcp_lro_flush_all
argument_list|(
operator|&
name|rxq
operator|->
name|ifr_lc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|avail
condition|)
return|return
name|true
return|;
return|return
operator|(
name|iflib_rxd_avail
argument_list|(
name|ctx
argument_list|,
name|rxq
argument_list|,
operator|*
name|cidxp
argument_list|,
literal|1
argument_list|)
operator|)
return|;
name|err
label|:
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ifc_flags
operator||=
name|IFC_DO_RESET
expr_stmt|;
name|iflib_admin_intr_deferred
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|TXD_NOTIFY_COUNT
parameter_list|(
name|txq
parameter_list|)
value|(((txq)->ift_size / (txq)->ift_update_freq)-1)
end_define

begin_function
specifier|static
specifier|inline
name|qidx_t
name|txq_max_db_deferred
parameter_list|(
name|iflib_txq_t
name|txq
parameter_list|,
name|qidx_t
name|in_use
parameter_list|)
block|{
name|qidx_t
name|notify_count
init|=
name|TXD_NOTIFY_COUNT
argument_list|(
name|txq
argument_list|)
decl_stmt|;
name|qidx_t
name|minthresh
init|=
name|txq
operator|->
name|ift_size
operator|/
literal|8
decl_stmt|;
if|if
condition|(
name|in_use
operator|>
literal|4
operator|*
name|minthresh
condition|)
return|return
operator|(
name|notify_count
operator|)
return|;
if|if
condition|(
name|in_use
operator|>
literal|2
operator|*
name|minthresh
condition|)
return|return
operator|(
name|notify_count
operator|>>
literal|1
operator|)
return|;
if|if
condition|(
name|in_use
operator|>
name|minthresh
condition|)
return|return
operator|(
name|notify_count
operator|>>
literal|3
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|qidx_t
name|txq_max_rs_deferred
parameter_list|(
name|iflib_txq_t
name|txq
parameter_list|)
block|{
name|qidx_t
name|notify_count
init|=
name|TXD_NOTIFY_COUNT
argument_list|(
name|txq
argument_list|)
decl_stmt|;
name|qidx_t
name|minthresh
init|=
name|txq
operator|->
name|ift_size
operator|/
literal|8
decl_stmt|;
if|if
condition|(
name|txq
operator|->
name|ift_in_use
operator|>
literal|4
operator|*
name|minthresh
condition|)
return|return
operator|(
name|notify_count
operator|)
return|;
if|if
condition|(
name|txq
operator|->
name|ift_in_use
operator|>
literal|2
operator|*
name|minthresh
condition|)
return|return
operator|(
name|notify_count
operator|>>
literal|1
operator|)
return|;
if|if
condition|(
name|txq
operator|->
name|ift_in_use
operator|>
name|minthresh
condition|)
return|return
operator|(
name|notify_count
operator|>>
literal|2
operator|)
return|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|M_CSUM_FLAGS
parameter_list|(
name|m
parameter_list|)
value|((m)->m_pkthdr.csum_flags)
end_define

begin_define
define|#
directive|define
name|M_HAS_VLANTAG
parameter_list|(
name|m
parameter_list|)
value|(m->m_flags& M_VLANTAG)
end_define

begin_define
define|#
directive|define
name|TXQ_MAX_DB_DEFERRED
parameter_list|(
name|txq
parameter_list|,
name|in_use
parameter_list|)
value|txq_max_db_deferred((txq), (in_use))
end_define

begin_define
define|#
directive|define
name|TXQ_MAX_RS_DEFERRED
parameter_list|(
name|txq
parameter_list|)
value|txq_max_rs_deferred(txq)
end_define

begin_define
define|#
directive|define
name|TXQ_MAX_DB_CONSUMED
parameter_list|(
name|size
parameter_list|)
value|(size>> 4)
end_define

begin_comment
comment|/* forward compatibility for cxgb */
end_comment

begin_define
define|#
directive|define
name|FIRST_QSET
parameter_list|(
name|ctx
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|NTXQSETS
parameter_list|(
name|ctx
parameter_list|)
value|((ctx)->ifc_softc_ctx.isc_ntxqsets)
end_define

begin_define
define|#
directive|define
name|NRXQSETS
parameter_list|(
name|ctx
parameter_list|)
value|((ctx)->ifc_softc_ctx.isc_nrxqsets)
end_define

begin_define
define|#
directive|define
name|QIDX
parameter_list|(
name|ctx
parameter_list|,
name|m
parameter_list|)
value|((((m)->m_pkthdr.flowid& ctx->ifc_softc_ctx.isc_rss_table_mask) % NTXQSETS(ctx)) + FIRST_QSET(ctx))
end_define

begin_define
define|#
directive|define
name|DESC_RECLAIMABLE
parameter_list|(
name|q
parameter_list|)
value|((int)((q)->ift_processed - (q)->ift_cleaned - (q)->ift_ctx->ifc_softc_ctx.isc_tx_nsegments))
end_define

begin_comment
comment|/* XXX we should be setting this to something other than zero */
end_comment

begin_define
define|#
directive|define
name|RECLAIM_THRESH
parameter_list|(
name|ctx
parameter_list|)
value|((ctx)->ifc_sctx->isc_tx_reclaim_thresh)
end_define

begin_define
define|#
directive|define
name|MAX_TX_DESC
parameter_list|(
name|ctx
parameter_list|)
value|((ctx)->ifc_softc_ctx.isc_tx_tso_segments_max)
end_define

begin_function
specifier|static
specifier|inline
name|bool
name|iflib_txd_db_check
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|iflib_txq_t
name|txq
parameter_list|,
name|int
name|ring
parameter_list|,
name|qidx_t
name|in_use
parameter_list|)
block|{
name|qidx_t
name|dbval
decl_stmt|,
name|max
decl_stmt|;
name|bool
name|rang
decl_stmt|;
name|rang
operator|=
name|false
expr_stmt|;
name|max
operator|=
name|TXQ_MAX_DB_DEFERRED
argument_list|(
name|txq
argument_list|,
name|in_use
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|||
name|txq
operator|->
name|ift_db_pending
operator|>=
name|max
condition|)
block|{
name|dbval
operator|=
name|txq
operator|->
name|ift_npending
condition|?
name|txq
operator|->
name|ift_npending
else|:
name|txq
operator|->
name|ift_pidx
expr_stmt|;
name|ctx
operator|->
name|isc_txd_flush
argument_list|(
name|ctx
operator|->
name|ifc_softc
argument_list|,
name|txq
operator|->
name|ift_id
argument_list|,
name|dbval
argument_list|)
expr_stmt|;
name|txq
operator|->
name|ift_db_pending
operator|=
name|txq
operator|->
name|ift_npending
operator|=
literal|0
expr_stmt|;
name|rang
operator|=
name|true
expr_stmt|;
block|}
return|return
operator|(
name|rang
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PKT_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|print_pkt
parameter_list|(
name|if_pkt_info_t
name|pi
parameter_list|)
block|{
name|printf
argument_list|(
literal|"pi len:  %d qsidx: %d nsegs: %d ndescs: %d flags: %x pidx: %d\n"
argument_list|,
name|pi
operator|->
name|ipi_len
argument_list|,
name|pi
operator|->
name|ipi_qsidx
argument_list|,
name|pi
operator|->
name|ipi_nsegs
argument_list|,
name|pi
operator|->
name|ipi_ndescs
argument_list|,
name|pi
operator|->
name|ipi_flags
argument_list|,
name|pi
operator|->
name|ipi_pidx
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pi new_pidx: %d csum_flags: %lx tso_segsz: %d mflags: %x vtag: %d\n"
argument_list|,
name|pi
operator|->
name|ipi_new_pidx
argument_list|,
name|pi
operator|->
name|ipi_csum_flags
argument_list|,
name|pi
operator|->
name|ipi_tso_segsz
argument_list|,
name|pi
operator|->
name|ipi_mflags
argument_list|,
name|pi
operator|->
name|ipi_vtag
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"pi etype: %d ehdrlen: %d ip_hlen: %d ipproto: %d\n"
argument_list|,
name|pi
operator|->
name|ipi_etype
argument_list|,
name|pi
operator|->
name|ipi_ehdrlen
argument_list|,
name|pi
operator|->
name|ipi_ip_hlen
argument_list|,
name|pi
operator|->
name|ipi_ipproto
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|IS_TSO4
parameter_list|(
name|pi
parameter_list|)
value|((pi)->ipi_csum_flags& CSUM_IP_TSO)
end_define

begin_define
define|#
directive|define
name|IS_TSO6
parameter_list|(
name|pi
parameter_list|)
value|((pi)->ipi_csum_flags& CSUM_IP6_TSO)
end_define

begin_function
specifier|static
name|int
name|iflib_parse_header
parameter_list|(
name|iflib_txq_t
name|txq
parameter_list|,
name|if_pkt_info_t
name|pi
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
block|{
name|if_shared_ctx_t
name|sctx
init|=
name|txq
operator|->
name|ift_ctx
operator|->
name|ifc_sctx
decl_stmt|;
name|struct
name|ether_vlan_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|m
operator|=
operator|*
name|mp
expr_stmt|;
if|if
condition|(
operator|(
name|sctx
operator|->
name|isc_flags
operator|&
name|IFLIB_NEED_SCRATCH
operator|)
operator|&&
name|M_WRITABLE
argument_list|(
name|m
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_dup
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
else|else
block|{
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
name|n
operator|=
operator|*
name|mp
operator|=
name|m
expr_stmt|;
block|}
block|}
comment|/* 	 * Determine where frame payload starts. 	 * Jump over vlan headers if already present, 	 * helpful for QinQ too. 	 */
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
argument_list|)
condition|)
block|{
name|txq
operator|->
name|ift_pullups
operator|++
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_vlan_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|evl_encap_proto
operator|==
name|htons
argument_list|(
name|ETHERTYPE_VLAN
argument_list|)
condition|)
block|{
name|pi
operator|->
name|ipi_etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_proto
argument_list|)
expr_stmt|;
name|pi
operator|->
name|ipi_ehdrlen
operator|=
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
expr_stmt|;
block|}
else|else
block|{
name|pi
operator|->
name|ipi_etype
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|evl_encap_proto
argument_list|)
expr_stmt|;
name|pi
operator|->
name|ipi_ehdrlen
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
block|}
switch|switch
condition|(
name|pi
operator|->
name|ipi_etype
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|ETHERTYPE_IP
case|:
block|{
name|struct
name|ip
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
init|=
name|NULL
decl_stmt|;
name|int
name|minthlen
decl_stmt|;
name|minthlen
operator|=
name|min
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|pi
operator|->
name|ipi_ehdrlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
name|minthlen
argument_list|)
condition|)
block|{
comment|/* 			 * if this code bloat is causing too much of a hit 			 * move it to a separate function and mark it noinline 			 */
if|if
condition|(
name|m
operator|->
name|m_len
operator|==
name|pi
operator|->
name|ipi_ehdrlen
condition|)
block|{
name|n
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|MPASS
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|m_len
operator|>=
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
condition|)
block|{
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|n
operator|->
name|m_data
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|m_len
operator|>=
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
condition|)
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|txq
operator|->
name|ift_pullups
operator|++
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|minthlen
argument_list|)
operator|)
operator|==
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|pi
operator|->
name|ipi_ehdrlen
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|txq
operator|->
name|ift_pullups
operator|++
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|minthlen
argument_list|)
operator|)
operator|==
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|pi
operator|->
name|ipi_ehdrlen
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|>=
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
condition|)
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|pi
operator|->
name|ipi_ehdrlen
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|>=
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
condition|)
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
block|}
name|pi
operator|->
name|ipi_ip_hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|pi
operator|->
name|ipi_ipproto
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|pi
operator|->
name|ipi_flags
operator||=
name|IPI_TX_IPV4
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|ipi_csum_flags
operator|&
name|CSUM_IP
condition|)
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|ipi_ipproto
operator|==
name|IPPROTO_TCP
condition|)
block|{
if|if
condition|(
name|__predict_false
argument_list|(
name|th
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|txq
operator|->
name|ift_pullups
operator|++
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|th
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|pi
operator|->
name|ipi_ip_hlen
operator|)
expr_stmt|;
block|}
name|pi
operator|->
name|ipi_tcp_hflags
operator|=
name|th
operator|->
name|th_flags
expr_stmt|;
name|pi
operator|->
name|ipi_tcp_hlen
operator|=
name|th
operator|->
name|th_off
operator|<<
literal|2
expr_stmt|;
name|pi
operator|->
name|ipi_tcp_seq
operator|=
name|th
operator|->
name|th_seq
expr_stmt|;
block|}
if|if
condition|(
name|IS_TSO4
argument_list|(
name|pi
argument_list|)
condition|)
block|{
if|if
condition|(
name|__predict_false
argument_list|(
name|ip
operator|->
name|ip_p
operator|!=
name|IPPROTO_TCP
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|th
operator|->
name|th_sum
operator|=
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htons
argument_list|(
name|IPPROTO_TCP
argument_list|)
argument_list|)
expr_stmt|;
name|pi
operator|->
name|ipi_tso_segsz
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
expr_stmt|;
if|if
condition|(
name|sctx
operator|->
name|isc_flags
operator|&
name|IFLIB_TSO_INIT_IP
condition|)
block|{
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|pi
operator|->
name|ipi_ip_hlen
operator|+
name|pi
operator|->
name|ipi_tcp_hlen
operator|+
name|pi
operator|->
name|ipi_tso_segsz
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|ETHERTYPE_IPV6
case|:
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
init|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|+
name|pi
operator|->
name|ipi_ehdrlen
operator|)
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
name|pi
operator|->
name|ipi_ip_hlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
name|pi
operator|->
name|ipi_ehdrlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|pi
operator|->
name|ipi_ehdrlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip6
operator|+
name|pi
operator|->
name|ipi_ip_hlen
operator|)
expr_stmt|;
comment|/* XXX-BZ this will go badly in case of ext hdrs. */
name|pi
operator|->
name|ipi_ipproto
operator|=
name|ip6
operator|->
name|ip6_nxt
expr_stmt|;
name|pi
operator|->
name|ipi_flags
operator||=
name|IPI_TX_IPV6
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|ipi_ipproto
operator|==
name|IPPROTO_TCP
condition|)
block|{
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<
name|pi
operator|->
name|ipi_ehdrlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|pi
operator|->
name|ipi_ehdrlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|pi
operator|->
name|ipi_tcp_hflags
operator|=
name|th
operator|->
name|th_flags
expr_stmt|;
name|pi
operator|->
name|ipi_tcp_hlen
operator|=
name|th
operator|->
name|th_off
operator|<<
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|IS_TSO6
argument_list|(
name|pi
argument_list|)
condition|)
block|{
if|if
condition|(
name|__predict_false
argument_list|(
name|ip6
operator|->
name|ip6_nxt
operator|!=
name|IPPROTO_TCP
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 			 * The corresponding flag is set by the stack in the IPv4 			 * TSO case, but not in IPv6 (at least in FreeBSD 10.2). 			 * So, set it here because the rest of the flow requires it. 			 */
name|pi
operator|->
name|ipi_csum_flags
operator||=
name|CSUM_TCP_IPV6
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|in6_cksum_pseudo
argument_list|(
name|ip6
argument_list|,
literal|0
argument_list|,
name|IPPROTO_TCP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pi
operator|->
name|ipi_tso_segsz
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|tso_segsz
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
default|default:
name|pi
operator|->
name|ipi_csum_flags
operator|&=
operator|~
name|CSUM_OFFLOAD
expr_stmt|;
name|pi
operator|->
name|ipi_ip_hlen
operator|=
literal|0
expr_stmt|;
break|break;
block|}
operator|*
name|mp
operator|=
name|m
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__noinline
expr|struct
name|mbuf
operator|*
name|collapse_pkthdr
argument_list|(
argument|struct mbuf *m0
argument_list|)
block|{ 	struct
name|mbuf
operator|*
name|m
block|,
operator|*
name|m_next
block|,
operator|*
name|tmp
block|;
name|m
operator|=
name|m0
block|;
name|m_next
operator|=
name|m
operator|->
name|m_next
block|;
while|while
condition|(
name|m_next
operator|!=
name|NULL
operator|&&
name|m_next
operator|->
name|m_len
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m_next
operator|=
name|m_next
operator|->
name|m_next
expr_stmt|;
block|}
name|m
operator|=
name|m0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|m
operator|->
name|m_next
operator|=
name|m_next
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|m_next
operator|->
name|m_flags
operator|&
name|M_EXT
operator|)
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|m_defrag
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp
operator|=
name|m_next
operator|->
name|m_next
expr_stmt|;
name|memcpy
argument_list|(
name|m_next
argument_list|,
name|m
argument_list|,
name|MPKTHSIZE
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|tmp
expr_stmt|;
block|}
end_if

begin_return
return|return
operator|(
name|m
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * If dodgy hardware rejects the scatter gather chain we've handed it  * we'll need to remove the mbuf chain from ifsg_m[] before we can add the  * m_defrag'd mbufs  */
end_comment

begin_function
unit|static
name|__noinline
name|struct
name|mbuf
modifier|*
name|iflib_remove_mbuf
parameter_list|(
name|iflib_txq_t
name|txq
parameter_list|)
block|{
name|int
name|ntxd
decl_stmt|,
name|i
decl_stmt|,
name|pidx
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mh
decl_stmt|,
modifier|*
modifier|*
name|ifsd_m
decl_stmt|;
name|pidx
operator|=
name|txq
operator|->
name|ift_pidx
expr_stmt|;
name|ifsd_m
operator|=
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_m
expr_stmt|;
name|ntxd
operator|=
name|txq
operator|->
name|ift_size
expr_stmt|;
name|mh
operator|=
name|m
operator|=
name|ifsd_m
index|[
name|pidx
index|]
expr_stmt|;
name|ifsd_m
index|[
name|pidx
index|]
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|MEMORY_LOGGING
name|txq
operator|->
name|ift_dequeued
operator|++
expr_stmt|;
endif|#
directive|endif
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|ifsd_m
index|[
operator|(
name|pidx
operator|+
name|i
operator|)
operator|&
operator|(
name|ntxd
operator|-
literal|1
operator|)
index|]
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|MEMORY_LOGGING
name|txq
operator|->
name|ift_dequeued
operator|++
expr_stmt|;
endif|#
directive|endif
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|mh
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iflib_busdma_load_mbuf_sg
parameter_list|(
name|iflib_txq_t
name|txq
parameter_list|,
name|bus_dma_tag_t
name|tag
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m0
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
modifier|*
name|nsegs
parameter_list|,
name|int
name|max_segs
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|if_ctx_t
name|ctx
decl_stmt|;
name|if_shared_ctx_t
name|sctx
decl_stmt|;
name|if_softc_ctx_t
name|scctx
decl_stmt|;
name|int
name|i
decl_stmt|,
name|next
decl_stmt|,
name|pidx
decl_stmt|,
name|err
decl_stmt|,
name|maxsegsz
decl_stmt|,
name|ntxd
decl_stmt|,
name|count
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|tmp
decl_stmt|,
modifier|*
modifier|*
name|ifsd_m
decl_stmt|;
name|m
operator|=
operator|*
name|m0
expr_stmt|;
comment|/* 	 * Please don't ever do this 	 */
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|==
literal|0
argument_list|)
condition|)
operator|*
name|m0
operator|=
name|m
operator|=
name|collapse_pkthdr
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|txq
operator|->
name|ift_ctx
expr_stmt|;
name|sctx
operator|=
name|ctx
operator|->
name|ifc_sctx
expr_stmt|;
name|scctx
operator|=
operator|&
name|ctx
operator|->
name|ifc_softc_ctx
expr_stmt|;
name|ifsd_m
operator|=
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_m
expr_stmt|;
name|ntxd
operator|=
name|txq
operator|->
name|ift_size
expr_stmt|;
name|pidx
operator|=
name|txq
operator|->
name|ift_pidx
expr_stmt|;
if|if
condition|(
name|map
operator|!=
name|NULL
condition|)
block|{
name|uint8_t
modifier|*
name|ifsd_flags
init|=
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_flags
decl_stmt|;
name|err
operator|=
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|tag
argument_list|,
name|map
argument_list|,
operator|*
name|m0
argument_list|,
name|segs
argument_list|,
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|ifsd_flags
index|[
name|pidx
index|]
operator||=
name|TX_SW_DESC_MAPPED
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|m
operator|=
operator|*
name|m0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<=
literal|0
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|tmp
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|m_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|next
operator|=
operator|(
name|pidx
operator|+
name|count
operator|)
operator|&
operator|(
name|ntxd
operator|-
literal|1
operator|)
expr_stmt|;
name|MPASS
argument_list|(
name|ifsd_m
index|[
name|next
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ifsd_m
index|[
name|next
index|]
operator|=
name|m
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|tmp
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
do|while
condition|(
name|m
operator|!=
name|NULL
condition|)
do|;
block|}
else|else
block|{
name|int
name|buflen
decl_stmt|,
name|sgsize
decl_stmt|,
name|max_sgsize
decl_stmt|;
name|vm_offset_t
name|vaddr
decl_stmt|;
name|vm_paddr_t
name|curaddr
decl_stmt|;
name|count
operator|=
name|i
operator|=
literal|0
expr_stmt|;
name|maxsegsz
operator|=
name|sctx
operator|->
name|isc_tx_maxsize
expr_stmt|;
name|m
operator|=
operator|*
name|m0
expr_stmt|;
do|do
block|{
if|if
condition|(
name|__predict_false
argument_list|(
name|m
operator|->
name|m_len
operator|<=
literal|0
argument_list|)
condition|)
block|{
name|tmp
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|tmp
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|m_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|buflen
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|vaddr
operator|=
operator|(
name|vm_offset_t
operator|)
name|m
operator|->
name|m_data
expr_stmt|;
comment|/* 			 * see if we can't be smarter about physically 			 * contiguous mappings 			 */
name|next
operator|=
operator|(
name|pidx
operator|+
name|count
operator|)
operator|&
operator|(
name|ntxd
operator|-
literal|1
operator|)
expr_stmt|;
name|MPASS
argument_list|(
name|ifsd_m
index|[
name|next
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
name|MEMORY_LOGGING
name|txq
operator|->
name|ift_enqueued
operator|++
expr_stmt|;
endif|#
directive|endif
name|ifsd_m
index|[
name|next
index|]
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|buflen
operator|>
literal|0
condition|)
block|{
name|max_sgsize
operator|=
name|MIN
argument_list|(
name|buflen
argument_list|,
name|maxsegsz
argument_list|)
expr_stmt|;
name|curaddr
operator|=
name|pmap_kextract
argument_list|(
name|vaddr
argument_list|)
expr_stmt|;
name|sgsize
operator|=
name|PAGE_SIZE
operator|-
operator|(
name|curaddr
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
name|sgsize
operator|=
name|MIN
argument_list|(
name|sgsize
argument_list|,
name|max_sgsize
argument_list|)
expr_stmt|;
name|segs
index|[
name|i
index|]
operator|.
name|ds_addr
operator|=
name|curaddr
expr_stmt|;
name|segs
index|[
name|i
index|]
operator|.
name|ds_len
operator|=
name|sgsize
expr_stmt|;
name|vaddr
operator|+=
name|sgsize
expr_stmt|;
name|buflen
operator|-=
name|sgsize
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|max_segs
condition|)
goto|goto
name|err
goto|;
block|}
name|count
operator|++
expr_stmt|;
name|tmp
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
do|while
condition|(
name|m
operator|!=
name|NULL
condition|)
do|;
operator|*
name|nsegs
operator|=
name|i
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
operator|*
name|m0
operator|=
name|iflib_remove_mbuf
argument_list|(
name|txq
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFBIG
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|caddr_t
name|calc_next_txd
parameter_list|(
name|iflib_txq_t
name|txq
parameter_list|,
name|int
name|cidx
parameter_list|,
name|uint8_t
name|qid
parameter_list|)
block|{
name|qidx_t
name|size
decl_stmt|;
name|int
name|ntxd
decl_stmt|;
name|caddr_t
name|start
decl_stmt|,
name|end
decl_stmt|,
name|cur
decl_stmt|,
name|next
decl_stmt|;
name|ntxd
operator|=
name|txq
operator|->
name|ift_size
expr_stmt|;
name|size
operator|=
name|txq
operator|->
name|ift_txd_size
index|[
name|qid
index|]
expr_stmt|;
name|start
operator|=
name|txq
operator|->
name|ift_ifdi
index|[
name|qid
index|]
operator|.
name|idi_vaddr
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|size
operator|==
literal|0
argument_list|)
condition|)
return|return
operator|(
name|start
operator|)
return|;
name|cur
operator|=
name|start
operator|+
name|size
operator|*
name|cidx
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|size
operator|*
name|ntxd
expr_stmt|;
name|next
operator|=
name|CACHE_PTR_NEXT
argument_list|(
name|cur
argument_list|)
expr_stmt|;
return|return
operator|(
name|next
operator|<
name|end
condition|?
name|next
else|:
name|start
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iflib_encap
parameter_list|(
name|iflib_txq_t
name|txq
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_headp
parameter_list|)
block|{
name|if_ctx_t
name|ctx
decl_stmt|;
name|if_shared_ctx_t
name|sctx
decl_stmt|;
name|if_softc_ctx_t
name|scctx
decl_stmt|;
name|bus_dma_segment_t
modifier|*
name|segs
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_head
decl_stmt|;
name|void
modifier|*
name|next_txd
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|struct
name|if_pkt_info
name|pi
decl_stmt|;
name|int
name|remap
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|,
name|nsegs
decl_stmt|,
name|ndesc
decl_stmt|,
name|max_segs
decl_stmt|,
name|pidx
decl_stmt|,
name|cidx
decl_stmt|,
name|next
decl_stmt|,
name|ntxd
decl_stmt|;
name|bus_dma_tag_t
name|desc_tag
decl_stmt|;
name|segs
operator|=
name|txq
operator|->
name|ift_segs
expr_stmt|;
name|ctx
operator|=
name|txq
operator|->
name|ift_ctx
expr_stmt|;
name|sctx
operator|=
name|ctx
operator|->
name|ifc_sctx
expr_stmt|;
name|scctx
operator|=
operator|&
name|ctx
operator|->
name|ifc_softc_ctx
expr_stmt|;
name|segs
operator|=
name|txq
operator|->
name|ift_segs
expr_stmt|;
name|ntxd
operator|=
name|txq
operator|->
name|ift_size
expr_stmt|;
name|m_head
operator|=
operator|*
name|m_headp
expr_stmt|;
name|map
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If we're doing TSO the next descriptor to clean may be quite far ahead 	 */
name|cidx
operator|=
name|txq
operator|->
name|ift_cidx
expr_stmt|;
name|pidx
operator|=
name|txq
operator|->
name|ift_pidx
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ifc_flags
operator|&
name|IFC_PREFETCH
condition|)
block|{
name|next
operator|=
operator|(
name|cidx
operator|+
name|CACHE_PTR_INCREMENT
operator|)
operator|&
operator|(
name|ntxd
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ctx
operator|->
name|ifc_flags
operator|&
name|IFLIB_HAS_TXCQ
operator|)
condition|)
block|{
name|next_txd
operator|=
name|calc_next_txd
argument_list|(
name|txq
argument_list|,
name|cidx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|next_txd
argument_list|)
expr_stmt|;
block|}
comment|/* prefetch the next cache line of mbuf pointers and flags */
name|prefetch
argument_list|(
operator|&
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_m
index|[
name|next
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
operator|!=
name|NULL
condition|)
block|{
name|prefetch
argument_list|(
operator|&
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
index|[
name|next
index|]
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|cidx
operator|+
name|CACHE_LINE_SIZE
operator|)
operator|&
operator|(
name|ntxd
operator|-
literal|1
operator|)
expr_stmt|;
name|prefetch
argument_list|(
operator|&
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_flags
index|[
name|next
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
operator|!=
name|NULL
condition|)
name|map
operator|=
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
index|[
name|pidx
index|]
expr_stmt|;
if|if
condition|(
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_TSO
condition|)
block|{
name|desc_tag
operator|=
name|txq
operator|->
name|ift_tso_desc_tag
expr_stmt|;
name|max_segs
operator|=
name|scctx
operator|->
name|isc_tx_tso_segments_max
expr_stmt|;
block|}
else|else
block|{
name|desc_tag
operator|=
name|txq
operator|->
name|ift_desc_tag
expr_stmt|;
name|max_segs
operator|=
name|scctx
operator|->
name|isc_tx_nsegments
expr_stmt|;
block|}
name|m_head
operator|=
operator|*
name|m_headp
expr_stmt|;
name|pkt_info_zero
argument_list|(
operator|&
name|pi
argument_list|)
expr_stmt|;
name|pi
operator|.
name|ipi_len
operator|=
name|m_head
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|pi
operator|.
name|ipi_mflags
operator|=
operator|(
name|m_head
operator|->
name|m_flags
operator|&
operator|(
name|M_VLANTAG
operator||
name|M_BCAST
operator||
name|M_MCAST
operator|)
operator|)
expr_stmt|;
name|pi
operator|.
name|ipi_csum_flags
operator|=
name|m_head
operator|->
name|m_pkthdr
operator|.
name|csum_flags
expr_stmt|;
name|pi
operator|.
name|ipi_vtag
operator|=
operator|(
name|m_head
operator|->
name|m_flags
operator|&
name|M_VLANTAG
operator|)
condition|?
name|m_head
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
else|:
literal|0
expr_stmt|;
name|pi
operator|.
name|ipi_pidx
operator|=
name|pidx
expr_stmt|;
name|pi
operator|.
name|ipi_qsidx
operator|=
name|txq
operator|->
name|ift_id
expr_stmt|;
comment|/* deliberate bitwise OR to make one condition */
if|if
condition|(
name|__predict_true
argument_list|(
operator|(
name|pi
operator|.
name|ipi_csum_flags
operator||
name|pi
operator|.
name|ipi_vtag
operator|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|err
operator|=
name|iflib_parse_header
argument_list|(
name|txq
argument_list|,
operator|&
name|pi
argument_list|,
name|m_headp
argument_list|)
operator|)
operator|!=
literal|0
argument_list|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|m_head
operator|=
operator|*
name|m_headp
expr_stmt|;
block|}
name|retry
label|:
name|err
operator|=
name|iflib_busdma_load_mbuf_sg
argument_list|(
name|txq
argument_list|,
name|desc_tag
argument_list|,
name|map
argument_list|,
name|m_headp
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|max_segs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
name|defrag
label|:
if|if
condition|(
name|__predict_false
argument_list|(
name|err
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|err
condition|)
block|{
case|case
name|EFBIG
case|:
comment|/* try collapse once and defrag once */
if|if
condition|(
name|remap
operator|==
literal|0
condition|)
name|m_head
operator|=
name|m_collapse
argument_list|(
operator|*
name|m_headp
argument_list|,
name|M_NOWAIT
argument_list|,
name|max_segs
argument_list|)
expr_stmt|;
if|if
condition|(
name|remap
operator|==
literal|1
condition|)
name|m_head
operator|=
name|m_defrag
argument_list|(
operator|*
name|m_headp
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|remap
operator|++
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|m_head
operator|==
name|NULL
argument_list|)
condition|)
goto|goto
name|defrag_failed
goto|;
name|txq
operator|->
name|ift_mbuf_defrag
operator|++
expr_stmt|;
operator|*
name|m_headp
operator|=
name|m_head
expr_stmt|;
goto|goto
name|retry
goto|;
break|break;
case|case
name|ENOMEM
case|:
name|txq
operator|->
name|ift_no_tx_dma_setup
operator|++
expr_stmt|;
break|break;
default|default:
name|txq
operator|->
name|ift_no_tx_dma_setup
operator|++
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_headp
argument_list|)
expr_stmt|;
name|DBG_COUNTER_INC
argument_list|(
name|tx_frees
argument_list|)
expr_stmt|;
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|txq
operator|->
name|ift_map_failed
operator|++
expr_stmt|;
name|DBG_COUNTER_INC
argument_list|(
name|encap_load_mbuf_fail
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 	 * XXX assumes a 1 to 1 relationship between segments and 	 *        descriptors - this does not hold true on all drivers, e.g. 	 *        cxgb 	 */
if|if
condition|(
name|__predict_false
argument_list|(
name|nsegs
operator|+
literal|2
operator|>
name|TXQ_AVAIL
argument_list|(
name|txq
argument_list|)
argument_list|)
condition|)
block|{
name|txq
operator|->
name|ift_no_desc_avail
operator|++
expr_stmt|;
if|if
condition|(
name|map
operator|!=
name|NULL
condition|)
name|bus_dmamap_unload
argument_list|(
name|desc_tag
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|DBG_COUNTER_INC
argument_list|(
name|encap_txq_avail_fail
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|txq
operator|->
name|ift_task
operator|.
name|gt_task
operator|.
name|ta_flags
operator|&
name|TASK_ENQUEUED
operator|)
operator|==
literal|0
condition|)
name|GROUPTASK_ENQUEUE
argument_list|(
operator|&
name|txq
operator|->
name|ift_task
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* 	 * On Intel cards we can greatly reduce the number of TX interrupts 	 * we see by only setting report status on every Nth descriptor. 	 * However, this also means that the driver will need to keep track 	 * of the descriptors that RS was set on to check them for the DD bit. 	 */
name|txq
operator|->
name|ift_rs_pending
operator|+=
name|nsegs
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|ift_rs_pending
operator|>
name|TXQ_MAX_RS_DEFERRED
argument_list|(
name|txq
argument_list|)
operator|||
name|iflib_no_tx_batch
operator|||
operator|(
name|TXQ_AVAIL
argument_list|(
name|txq
argument_list|)
operator|-
name|nsegs
operator|-
literal|1
operator|)
operator|<=
name|MAX_TX_DESC
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
name|pi
operator|.
name|ipi_flags
operator||=
name|IPI_TX_INTR
expr_stmt|;
name|txq
operator|->
name|ift_rs_pending
operator|=
literal|0
expr_stmt|;
block|}
name|pi
operator|.
name|ipi_segs
operator|=
name|segs
expr_stmt|;
name|pi
operator|.
name|ipi_nsegs
operator|=
name|nsegs
expr_stmt|;
name|MPASS
argument_list|(
name|pidx
operator|>=
literal|0
operator|&&
name|pidx
operator|<
name|txq
operator|->
name|ift_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PKT_DEBUG
name|print_pkt
argument_list|(
operator|&
name|pi
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|map
operator|!=
name|NULL
condition|)
name|bus_dmamap_sync
argument_list|(
name|desc_tag
argument_list|,
name|map
argument_list|,
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|ctx
operator|->
name|isc_txd_encap
argument_list|(
name|ctx
operator|->
name|ifc_softc
argument_list|,
operator|&
name|pi
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|map
operator|!=
name|NULL
condition|)
name|bus_dmamap_sync
argument_list|(
name|txq
operator|->
name|ift_ifdi
operator|->
name|idi_tag
argument_list|,
name|txq
operator|->
name|ift_ifdi
operator|->
name|idi_map
argument_list|,
name|BUS_DMASYNC_PREREAD
operator||
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|DBG_COUNTER_INC
argument_list|(
name|tx_encap
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|pi
operator|.
name|ipi_new_pidx
operator|<
name|txq
operator|->
name|ift_size
argument_list|)
expr_stmt|;
name|ndesc
operator|=
name|pi
operator|.
name|ipi_new_pidx
operator|-
name|pi
operator|.
name|ipi_pidx
expr_stmt|;
if|if
condition|(
name|pi
operator|.
name|ipi_new_pidx
operator|<
name|pi
operator|.
name|ipi_pidx
condition|)
block|{
name|ndesc
operator|+=
name|txq
operator|->
name|ift_size
expr_stmt|;
name|txq
operator|->
name|ift_gen
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * drivers can need as many as  		 * two sentinels 		 */
name|MPASS
argument_list|(
name|ndesc
operator|<=
name|pi
operator|.
name|ipi_nsegs
operator|+
literal|2
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|pi
operator|.
name|ipi_new_pidx
operator|!=
name|pidx
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|ndesc
operator|>
literal|0
argument_list|)
expr_stmt|;
name|txq
operator|->
name|ift_in_use
operator|+=
name|ndesc
expr_stmt|;
comment|/* 		 * We update the last software descriptor again here because there may 		 * be a sentinel and/or there may be more mbufs than segments 		 */
name|txq
operator|->
name|ift_pidx
operator|=
name|pi
operator|.
name|ipi_new_pidx
expr_stmt|;
name|txq
operator|->
name|ift_npending
operator|+=
name|pi
operator|.
name|ipi_ndescs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|__predict_false
argument_list|(
name|err
operator|==
name|EFBIG
operator|&&
name|remap
operator|<
literal|2
argument_list|)
condition|)
block|{
operator|*
name|m_headp
operator|=
name|m_head
operator|=
name|iflib_remove_mbuf
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|remap
operator|=
literal|1
expr_stmt|;
name|txq
operator|->
name|ift_txd_encap_efbig
operator|++
expr_stmt|;
goto|goto
name|defrag
goto|;
block|}
else|else
name|DBG_COUNTER_INC
argument_list|(
name|encap_txd_encap_fail
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
name|defrag_failed
label|:
name|txq
operator|->
name|ift_mbuf_defrag_failed
operator|++
expr_stmt|;
name|txq
operator|->
name|ift_map_failed
operator|++
expr_stmt|;
name|m_freem
argument_list|(
operator|*
name|m_headp
argument_list|)
expr_stmt|;
name|DBG_COUNTER_INC
argument_list|(
name|tx_frees
argument_list|)
expr_stmt|;
operator|*
name|m_headp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iflib_tx_desc_free
parameter_list|(
name|iflib_txq_t
name|txq
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|hasmap
decl_stmt|;
name|uint32_t
name|qsize
decl_stmt|,
name|cidx
decl_stmt|,
name|mask
decl_stmt|,
name|gen
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|ifsd_m
decl_stmt|;
name|uint8_t
modifier|*
name|ifsd_flags
decl_stmt|;
name|bus_dmamap_t
modifier|*
name|ifsd_map
decl_stmt|;
name|bool
name|do_prefetch
decl_stmt|;
name|cidx
operator|=
name|txq
operator|->
name|ift_cidx
expr_stmt|;
name|gen
operator|=
name|txq
operator|->
name|ift_gen
expr_stmt|;
name|qsize
operator|=
name|txq
operator|->
name|ift_size
expr_stmt|;
name|mask
operator|=
name|qsize
operator|-
literal|1
expr_stmt|;
name|hasmap
operator|=
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
operator|!=
name|NULL
expr_stmt|;
name|ifsd_flags
operator|=
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_flags
expr_stmt|;
name|ifsd_m
operator|=
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_m
expr_stmt|;
name|ifsd_map
operator|=
name|txq
operator|->
name|ift_sds
operator|.
name|ifsd_map
expr_stmt|;
name|do_prefetch
operator|=
operator|(
name|txq
operator|->
name|ift_ctx
operator|->
name|ifc_flags
operator|&
name|IFC_PREFETCH
operator|)
expr_stmt|;
while|while
condition|(
name|n
operator|--
condition|)
block|{
if|if
condition|(
name|do_prefetch
condition|)
block|{
name|prefetch
argument_list|(
name|ifsd_m
index|[
operator|(
name|cidx
operator|+
literal|3
operator|)
operator|&
name|mask
index|]
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|ifsd_m
index|[
operator|(
name|cidx
operator|+
literal|4
operator|)
operator|&
name|mask
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifsd_m
index|[
name|cidx
index|]
operator|!=
name|NULL
condition|)
block|{
name|prefetch
argument_list|(
operator|&
name|ifsd_m
index|[
operator|(
name|cidx
operator|+
name|CACHE_PTR_INCREMENT
operator|)
operator|&
name|mask
index|]
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
operator|&
name|ifsd_flags
index|[
operator|(
name|cidx
operator|+
name|CACHE_PTR_INCREMENT
operator|)
operator|&
name|mask
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hasmap
operator|&&
operator|(
name|ifsd_flags
index|[
name|cidx
index|]
operator|&
name|TX_SW_DESC_MAPPED
operator|)
condition|)
block|{
comment|/* 				 * does it matter if it's not the TSO tag? If so we'll 				 * have to add the type to flags 				 */
name|bus_dmamap_unload
argument_list|(
name|txq
operator|->
name|ift_desc_tag
argument_list|,
name|ifsd_map
index|[
name|cidx
index|]
argument_list|)
expr_stmt|;
name|ifsd_flags
index|[
name|cidx
index|]
operator|&=
operator|~
name|TX_SW_DESC_MAPPED
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|m
operator|=
name|ifsd_m
index|[
name|cidx
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX we don't support any drivers that batch packets yet */
name|MPASS
argument_list|(
name|m
operator|->
name|m_nextpkt
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifsd_m
index|[
name|cidx
index|]
operator|=
name|NULL
expr_stmt|;
if|#
directive|if
name|MEMORY_LOGGING
name|txq
operator|->
name|ift_dequeued
operator|++
expr_stmt|;
endif|#
directive|endif
name|DBG_COUNTER_INC
argument_list|(
name|tx_frees
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|__predict_false
argument_list|(
operator|++
name|cidx
operator|==
name|qsize
argument_list|)
condition|)
block|{
name|cidx
operator|=
literal|0
expr_stmt|;
name|gen
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|txq
operator|->
name|ift_cidx
operator|=
name|cidx
expr_stmt|;
name|txq
operator|->
name|ift_gen
operator|=
name|gen
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|iflib_completed_tx_reclaim
parameter_list|(
name|iflib_txq_t
name|txq
parameter_list|,
name|int
name|thresh
parameter_list|)
block|{
name|int
name|reclaim
decl_stmt|;
name|if_ctx_t
name|ctx
init|=
name|txq
operator|->
name|ift_ctx
decl_stmt|;
name|KASSERT
argument_list|(
name|thresh
operator|>=
literal|0
argument_list|,
operator|(
literal|"invalid threshold to reclaim"
operator|)
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|thresh
comment|/*+ MAX_TX_DESC(txq->ift_ctx) */
operator|<
name|txq
operator|->
name|ift_size
argument_list|)
expr_stmt|;
comment|/* 	 * Need a rate-limiting check so that this isn't called every time 	 */
name|iflib_tx_credits_update
argument_list|(
name|ctx
argument_list|,
name|txq
argument_list|)
expr_stmt|;
name|reclaim
operator|=
name|DESC_RECLAIMABLE
argument_list|(
name|txq
argument_list|)
expr_stmt|;
if|if
condition|(
name|reclaim
operator|<=
name|thresh
comment|/* + MAX_TX_DESC(txq->ift_ctx) */
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|iflib_verbose_debug
condition|)
block|{
name|printf
argument_list|(
literal|"%s processed=%ju cleaned=%ju tx_nsegments=%d reclaim=%d thresh=%d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|txq
operator|->
name|ift_processed
argument_list|,
name|txq
operator|->
name|ift_cleaned
argument_list|,
name|txq
operator|->
name|ift_ctx
operator|->
name|ifc_softc_ctx
operator|.
name|isc_tx_nsegments
argument_list|,
name|reclaim
argument_list|,
name|thresh
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|iflib_tx_desc_free
argument_list|(
name|txq
argument_list|,
name|reclaim
argument_list|)
expr_stmt|;
name|txq
operator|->
name|ift_cleaned
operator|+=
name|reclaim
expr_stmt|;
name|txq
operator|->
name|ift_in_use
operator|-=
name|reclaim
expr_stmt|;
return|return
operator|(
name|reclaim
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
modifier|*
name|_ring_peek_one
parameter_list|(
name|struct
name|ifmp_ring
modifier|*
name|r
parameter_list|,
name|int
name|cidx
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|remaining
parameter_list|)
block|{
name|int
name|next
decl_stmt|,
name|size
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|items
decl_stmt|;
name|size
operator|=
name|r
operator|->
name|size
expr_stmt|;
name|next
operator|=
operator|(
name|cidx
operator|+
name|CACHE_PTR_INCREMENT
operator|)
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
expr_stmt|;
name|items
operator|=
name|__DEVOLATILE
argument_list|(
expr|struct
name|mbuf
operator|*
operator|*
argument_list|,
operator|&
name|r
operator|->
name|items
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|items
index|[
operator|(
name|cidx
operator|+
name|offset
operator|)
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|remaining
operator|>
literal|1
condition|)
block|{
name|prefetch
argument_list|(
operator|&
name|items
index|[
name|next
index|]
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|items
index|[
operator|(
name|cidx
operator|+
name|offset
operator|+
literal|1
operator|)
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
index|]
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|items
index|[
operator|(
name|cidx
operator|+
name|offset
operator|+
literal|2
operator|)
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
index|]
argument_list|)
expr_stmt|;
name|prefetch
argument_list|(
name|items
index|[
operator|(
name|cidx
operator|+
name|offset
operator|+
literal|3
operator|)
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|__DEVOLATILE
argument_list|(
expr|struct
name|mbuf
operator|*
operator|*
argument_list|,
operator|&
name|r
operator|->
name|items
index|[
operator|(
name|cidx
operator|+
name|offset
operator|)
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
index|]
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iflib_txq_check_drain
parameter_list|(
name|iflib_txq_t
name|txq
parameter_list|,
name|int
name|budget
parameter_list|)
block|{
name|ifmp_ring_check_drainage
argument_list|(
name|txq
operator|->
name|ift_br
argument_list|,
name|budget
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|iflib_txq_can_drain
parameter_list|(
name|struct
name|ifmp_ring
modifier|*
name|r
parameter_list|)
block|{
name|iflib_txq_t
name|txq
init|=
name|r
operator|->
name|cookie
decl_stmt|;
name|if_ctx_t
name|ctx
init|=
name|txq
operator|->
name|ift_ctx
decl_stmt|;
return|return
operator|(
operator|(
name|TXQ_AVAIL
argument_list|(
name|txq
argument_list|)
operator|>
name|MAX_TX_DESC
argument_list|(
name|ctx
argument_list|)
operator|+
literal|2
operator|)
operator|||
name|ctx
operator|->
name|isc_txd_credits_update
argument_list|(
name|ctx
operator|->
name|ifc_softc
argument_list|,
name|txq
operator|->
name|ift_id
argument_list|,
name|false
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|iflib_txq_drain
parameter_list|(
name|struct
name|ifmp_ring
modifier|*
name|r
parameter_list|,
name|uint32_t
name|cidx
parameter_list|,
name|uint32_t
name|pidx
parameter_list|)
block|{
name|iflib_txq_t
name|txq
init|=
name|r
operator|->
name|cookie
decl_stmt|;
name|if_ctx_t
name|ctx
init|=
name|txq
operator|->
name|ift_ctx
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ctx
operator|->
name|ifc_ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|,
name|consumed
decl_stmt|,
name|pkt_sent
decl_stmt|,
name|bytes_sent
decl_stmt|,
name|mcast_sent
decl_stmt|,
name|avail
decl_stmt|;
name|int
name|reclaimed
decl_stmt|,
name|err
decl_stmt|,
name|in_use_prev
decl_stmt|,
name|desc_used
decl_stmt|;
name|bool
name|do_prefetch
decl_stmt|,
name|ring
decl_stmt|,
name|rang
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|||
operator|!
name|LINK_ACTIVE
argument_list|(
name|ctx
argument_list|)
argument_list|)
condition|)
block|{
name|DBG_COUNTER_INC
argument_list|(
name|txq_drain_notready
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|reclaimed
operator|=
name|iflib_completed_tx_reclaim
argument_list|(
name|txq
argument_list|,
name|RECLAIM_THRESH
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|rang
operator|=
name|iflib_txd_db_check
argument_list|(
name|ctx
argument_list|,
name|txq
argument_list|,
name|reclaimed
argument_list|,
name|txq
operator|->
name|ift_in_use
argument_list|)
expr_stmt|;
name|avail
operator|=
name|IDXDIFF
argument_list|(
name|pidx
argument_list|,
name|cidx
argument_list|,
name|r
operator|->
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|ctx
operator|->
name|ifc_flags
operator|&
name|IFC_QFLUSH
argument_list|)
condition|)
block|{
name|DBG_COUNTER_INC
argument_list|(
name|txq_drain_flushing
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|avail
condition|;
name|i
operator|++
control|)
block|{
name|m_free
argument_list|(
name|r
operator|->
name|items
index|[
operator|(
name|cidx
operator|+
name|i
operator|)
operator|&
operator|(
name|r
operator|->
name|size
operator|-
literal|1
operator|)
index|]
argument_list|)
expr_stmt|;
name|r
operator|->
name|items
index|[
operator|(
name|cidx
operator|+
name|i
operator|)
operator|&
operator|(
name|r
operator|->
name|size
operator|-
literal|1
operator|)
index|]
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|avail
operator|)
return|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
name|if_getdrvflags
argument_list|(
name|ctx
operator|->
name|ifc_ifp
argument_list|)
operator|&
name|IFF_DRV_OACTIVE
argument_list|)
condition|)
block|{
name|txq
operator|->
name|ift_qstatus
operator|=
name|IFLIB_QUEUE_IDLE
expr_stmt|;
name|CALLOUT_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|txq
operator|->
name|ift_timer
argument_list|)
expr_stmt|;
name|CALLOUT_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|DBG_COUNTER_INC
argument_list|(
name|txq_drain_oactive
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|reclaimed
condition|)
name|txq
operator|->
name|ift_qstatus
operator|=
name|IFLIB_QUEUE_IDLE
expr_stmt|;
name|consumed
operator|=
name|mcast_sent
operator|=
name|bytes_sent
operator|=
name|pkt_sent
operator|=
literal|0
expr_stmt|;
name|count
operator|=
name|MIN
argument_list|(
name|avail
argument_list|,
name|TX_BATCH_SIZE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|iflib_verbose_debug
condition|)
name|printf
argument_list|(
literal|"%s avail=%d ifc_flags=%x txq_avail=%d "
argument_list|,
name|__FUNCTION__
argument_list|,
name|avail
argument_list|,
name|ctx
operator|->
name|ifc_flags
argument_list|,
name|TXQ_AVAIL
argument_list|(
name|txq
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|do_prefetch
operator|=
operator|(
name|ctx
operator|->
name|ifc_flags
operator|&
name|IFC_PREFETCH
operator|)
expr_stmt|;
name|avail
operator|=
name|TXQ_AVAIL
argument_list|(
name|txq
argument_list|)
expr_stmt|;
for|for
control|(
name|desc_used
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
operator|&&
name|avail
operator|>
name|MAX_TX_DESC
argument_list|(
name|ctx
argument_list|)
operator|+
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pidx_prev
decl_stmt|,
name|rem
init|=
name|do_prefetch
condition|?
name|count
operator|-
name|i
else|:
literal|0
decl_stmt|;
name|mp
operator|=
name|_ring_peek_one
argument_list|(
name|r
argument_list|,
name|cidx
argument_list|,
name|i
argument_list|,
name|rem
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|mp
operator|!=
name|NULL
operator|&&
operator|*
name|mp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|*
name|mp
operator|==
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|txq
argument_list|)
condition|)
block|{
name|consumed
operator|++
expr_stmt|;
name|reclaimed
operator|++
expr_stmt|;
continue|continue;
block|}
name|in_use_prev
operator|=
name|txq
operator|->
name|ift_in_use
expr_stmt|;
name|pidx_prev
operator|=
name|txq
operator|->
name|ift_pidx
expr_stmt|;
name|err
operator|=
name|iflib_encap
argument_list|(
name|txq
argument_list|,
name|mp
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|err
argument_list|)
condition|)
block|{
name|DBG_COUNTER_INC
argument_list|(
name|txq_drain_encapfail
argument_list|)
expr_stmt|;
comment|/* no room - bail out */
if|if
condition|(
name|err
operator|==
name|ENOBUFS
condition|)
break|break;
name|consumed
operator|++
expr_stmt|;
name|DBG_COUNTER_INC
argument_list|(
name|txq_drain_encapfail
argument_list|)
expr_stmt|;
comment|/* we can't send this packet - skip it */
continue|continue;
block|}
name|consumed
operator|++
expr_stmt|;
name|pkt_sent
operator|++
expr_stmt|;
name|m
operator|=
operator|*
name|mp
expr_stmt|;
name|DBG_COUNTER_INC
argument_list|(
name|tx_sent
argument_list|)
expr_stmt|;
name|bytes_sent
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|mcast_sent
operator|+=
operator|!
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_MCAST
operator|)
expr_stmt|;
name|avail
operator|=
name|TXQ_AVAIL
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|txq
operator|->
name|ift_db_pending
operator|+=
operator|(
name|txq
operator|->
name|ift_in_use
operator|-
name|in_use_prev
operator|)
expr_stmt|;
name|desc_used
operator|+=
operator|(
name|txq
operator|->
name|ift_in_use
operator|-
name|in_use_prev
operator|)
expr_stmt|;
name|ETHER_BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
argument_list|)
condition|)
break|break;
name|rang
operator|=
name|iflib_txd_db_check
argument_list|(
name|ctx
argument_list|,
name|txq
argument_list|,
name|false
argument_list|,
name|in_use_prev
argument_list|)
expr_stmt|;
block|}
comment|/* deliberate use of bitwise or to avoid gratuitous short-circuit */
name|ring
operator|=
name|rang
condition|?
name|false
else|:
operator|(
name|iflib_min_tx_latency
operator||
name|err
operator|)
operator|||
operator|(
name|TXQ_AVAIL
argument_list|(
name|txq
argument_list|)
operator|<
name|MAX_TX_DESC
argument_list|(
name|ctx
argument_list|)
operator|)
expr_stmt|;
name|iflib_txd_db_check
argument_list|(
name|ctx
argument_list|,
name|txq
argument_list|,
name|ring
argument_list|,
name|txq
operator|->
name|ift_in_use
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OBYTES
argument_list|,
name|bytes_sent
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OPACKETS
argument_list|,
name|pkt_sent
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcast_sent
condition|)
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OMCASTS
argument_list|,
name|mcast_sent
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|iflib_verbose_debug
condition|)
name|printf
argument_list|(
literal|"consumed=%d\n"
argument_list|,
name|consumed
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|consumed
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|iflib_txq_drain_always
parameter_list|(
name|struct
name|ifmp_ring
modifier|*
name|r
parameter_list|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|iflib_txq_drain_free
parameter_list|(
name|struct
name|ifmp_ring
modifier|*
name|r
parameter_list|,
name|uint32_t
name|cidx
parameter_list|,
name|uint32_t
name|pidx
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|avail
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
name|iflib_txq_t
name|txq
decl_stmt|;
name|txq
operator|=
name|r
operator|->
name|cookie
expr_stmt|;
name|txq
operator|->
name|ift_qstatus
operator|=
name|IFLIB_QUEUE_IDLE
expr_stmt|;
name|CALLOUT_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|txq
operator|->
name|ift_timer
argument_list|)
expr_stmt|;
name|CALLOUT_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|avail
operator|=
name|IDXDIFF
argument_list|(
name|pidx
argument_list|,
name|cidx
argument_list|,
name|r
operator|->
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|avail
condition|;
name|i
operator|++
control|)
block|{
name|mp
operator|=
name|_ring_peek_one
argument_list|(
name|r
argument_list|,
name|cidx
argument_list|,
name|i
argument_list|,
name|avail
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|*
name|mp
operator|==
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|txq
argument_list|)
condition|)
continue|continue;
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
block|}
name|MPASS
argument_list|(
name|ifmp_ring_is_stalled
argument_list|(
name|r
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|avail
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iflib_ifmp_purge
parameter_list|(
name|iflib_txq_t
name|txq
parameter_list|)
block|{
name|struct
name|ifmp_ring
modifier|*
name|r
decl_stmt|;
name|r
operator|=
name|txq
operator|->
name|ift_br
expr_stmt|;
name|r
operator|->
name|drain
operator|=
name|iflib_txq_drain_free
expr_stmt|;
name|r
operator|->
name|can_drain
operator|=
name|iflib_txq_drain_always
expr_stmt|;
name|ifmp_ring_check_drainage
argument_list|(
name|r
argument_list|,
name|r
operator|->
name|size
argument_list|)
expr_stmt|;
name|r
operator|->
name|drain
operator|=
name|iflib_txq_drain
expr_stmt|;
name|r
operator|->
name|can_drain
operator|=
name|iflib_txq_can_drain
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_task_fn_tx
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|iflib_txq_t
name|txq
init|=
name|context
decl_stmt|;
name|if_ctx_t
name|ctx
init|=
name|txq
operator|->
name|ift_ctx
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ctx
operator|->
name|ifc_ifp
decl_stmt|;
name|int
name|rc
decl_stmt|;
ifdef|#
directive|ifdef
name|IFLIB_DIAGNOSTICS
name|txq
operator|->
name|ift_cpu_exec_count
index|[
name|curcpu
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|if_getdrvflags
argument_list|(
name|ctx
operator|->
name|ifc_ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
return|return;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_capenable
operator|&
name|IFCAP_NETMAP
operator|)
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|isc_txd_credits_update
argument_list|(
name|ctx
operator|->
name|ifc_softc
argument_list|,
name|txq
operator|->
name|ift_id
argument_list|,
name|false
argument_list|)
condition|)
name|netmap_tx_irq
argument_list|(
name|ifp
argument_list|,
name|txq
operator|->
name|ift_id
argument_list|)
expr_stmt|;
name|IFDI_TX_QUEUE_INTR_ENABLE
argument_list|(
name|ctx
argument_list|,
name|txq
operator|->
name|ift_id
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|txq
operator|->
name|ift_db_pending
condition|)
name|ifmp_ring_enqueue
argument_list|(
name|txq
operator|->
name|ift_br
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|txq
argument_list|,
literal|1
argument_list|,
name|TX_BATCH_SIZE
argument_list|)
expr_stmt|;
else|else
name|ifmp_ring_check_drainage
argument_list|(
name|txq
operator|->
name|ift_br
argument_list|,
name|TX_BATCH_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ifc_flags
operator|&
name|IFC_LEGACY
condition|)
name|IFDI_INTR_ENABLE
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
else|else
block|{
name|rc
operator|=
name|IFDI_TX_QUEUE_INTR_ENABLE
argument_list|(
name|ctx
argument_list|,
name|txq
operator|->
name|ift_id
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rc
operator|!=
name|ENOTSUP
argument_list|,
operator|(
literal|"MSI-X support requires queue_intr_enable, but not implemented in driver"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|_task_fn_rx
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|iflib_rxq_t
name|rxq
init|=
name|context
decl_stmt|;
name|if_ctx_t
name|ctx
init|=
name|rxq
operator|->
name|ifr_ctx
decl_stmt|;
name|bool
name|more
decl_stmt|;
name|int
name|rc
decl_stmt|;
ifdef|#
directive|ifdef
name|IFLIB_DIAGNOSTICS
name|rxq
operator|->
name|ifr_cpu_exec_count
index|[
name|curcpu
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
name|DBG_COUNTER_INC
argument_list|(
name|task_fn_rxs
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
operator|(
name|if_getdrvflags
argument_list|(
name|ctx
operator|->
name|ifc_ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|more
operator|=
name|iflib_rxeof
argument_list|(
name|rxq
argument_list|,
literal|16
comment|/* XXX */
argument_list|)
operator|)
operator|==
name|false
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|ifc_flags
operator|&
name|IFC_LEGACY
condition|)
name|IFDI_INTR_ENABLE
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
else|else
block|{
name|DBG_COUNTER_INC
argument_list|(
name|rx_intr_enables
argument_list|)
expr_stmt|;
name|rc
operator|=
name|IFDI_RX_QUEUE_INTR_ENABLE
argument_list|(
name|ctx
argument_list|,
name|rxq
operator|->
name|ifr_id
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rc
operator|!=
name|ENOTSUP
argument_list|,
operator|(
literal|"MSI-X support requires queue_intr_enable, but not implemented in driver"
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
operator|(
name|if_getdrvflags
argument_list|(
name|ctx
operator|->
name|ifc_ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
argument_list|)
condition|)
return|return;
if|if
condition|(
name|more
condition|)
name|GROUPTASK_ENQUEUE
argument_list|(
operator|&
name|rxq
operator|->
name|ifr_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_task_fn_admin
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|if_ctx_t
name|ctx
init|=
name|context
decl_stmt|;
name|if_softc_ctx_t
name|sctx
init|=
operator|&
name|ctx
operator|->
name|ifc_softc_ctx
decl_stmt|;
name|iflib_txq_t
name|txq
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|if_getdrvflags
argument_list|(
name|ctx
operator|->
name|ifc_ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|if_getdrvflags
argument_list|(
name|ctx
operator|->
name|ifc_ifp
argument_list|)
operator|&
name|IFF_DRV_OACTIVE
operator|)
condition|)
block|{
return|return;
block|}
block|}
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
for|for
control|(
name|txq
operator|=
name|ctx
operator|->
name|ifc_txqs
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sctx
operator|->
name|isc_ntxqsets
condition|;
name|i
operator|++
operator|,
name|txq
operator|++
control|)
block|{
name|CALLOUT_LOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|txq
operator|->
name|ift_timer
argument_list|)
expr_stmt|;
name|CALLOUT_UNLOCK
argument_list|(
name|txq
argument_list|)
expr_stmt|;
block|}
name|IFDI_UPDATE_ADMIN_STATUS
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
for|for
control|(
name|txq
operator|=
name|ctx
operator|->
name|ifc_txqs
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sctx
operator|->
name|isc_ntxqsets
condition|;
name|i
operator|++
operator|,
name|txq
operator|++
control|)
name|callout_reset_on
argument_list|(
operator|&
name|txq
operator|->
name|ift_timer
argument_list|,
name|hz
operator|/
literal|2
argument_list|,
name|iflib_timer
argument_list|,
name|txq
argument_list|,
name|txq
operator|->
name|ift_timer
operator|.
name|c_cpu
argument_list|)
expr_stmt|;
name|IFDI_LINK_INTR_ENABLE
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ifc_flags
operator|&
name|IFC_DO_RESET
condition|)
block|{
name|ctx
operator|->
name|ifc_flags
operator|&=
operator|~
name|IFC_DO_RESET
expr_stmt|;
name|iflib_if_init_locked
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|LINK_ACTIVE
argument_list|(
name|ctx
argument_list|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|txq
operator|=
name|ctx
operator|->
name|ifc_txqs
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sctx
operator|->
name|isc_ntxqsets
condition|;
name|i
operator|++
operator|,
name|txq
operator|++
control|)
name|iflib_txq_check_drain
argument_list|(
name|txq
argument_list|,
name|IFLIB_RESTART_BUDGET
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_task_fn_iov
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
block|{
name|if_ctx_t
name|ctx
init|=
name|context
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|if_getdrvflags
argument_list|(
name|ctx
operator|->
name|ifc_ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
return|return;
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|IFDI_VFLR_HANDLE
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iflib_sysctl_int_delay
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|if_int_delay_info_t
name|info
decl_stmt|;
name|if_ctx_t
name|ctx
decl_stmt|;
name|info
operator|=
operator|(
name|if_int_delay_info_t
operator|)
name|arg1
expr_stmt|;
name|ctx
operator|=
name|info
operator|->
name|iidi_ctx
expr_stmt|;
name|info
operator|->
name|iidi_req
operator|=
name|req
expr_stmt|;
name|info
operator|->
name|iidi_oidp
operator|=
name|oidp
expr_stmt|;
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|err
operator|=
name|IFDI_SYSCTL_INT_DELAY
argument_list|(
name|ctx
argument_list|,
name|info
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  IFNET FUNCTIONS  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|iflib_if_init_locked
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|iflib_stop
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|iflib_init_locked
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iflib_if_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|if_ctx_t
name|ctx
init|=
name|arg
decl_stmt|;
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|iflib_if_init_locked
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iflib_if_transmit
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|if_ctx_t
name|ctx
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|iflib_txq_t
name|txq
decl_stmt|;
name|int
name|err
decl_stmt|,
name|qidx
decl_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
operator|||
operator|!
name|LINK_ACTIVE
argument_list|(
name|ctx
argument_list|)
argument_list|)
condition|)
block|{
name|DBG_COUNTER_INC
argument_list|(
name|tx_frees
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|MPASS
argument_list|(
name|m
operator|->
name|m_nextpkt
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|qidx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|NTXQSETS
argument_list|(
name|ctx
argument_list|)
operator|>
literal|1
operator|)
operator|&&
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
condition|)
name|qidx
operator|=
name|QIDX
argument_list|(
name|ctx
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * XXX calculate buf_ring based on flowid (divvy up bits?) 	 */
name|txq
operator|=
operator|&
name|ctx
operator|->
name|ifc_txqs
index|[
name|qidx
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DRIVER_BACKPRESSURE
if|if
condition|(
name|txq
operator|->
name|ift_closed
condition|)
block|{
while|while
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|next
expr_stmt|;
block|}
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|notyet
name|qidx
operator|=
name|count
operator|=
literal|0
expr_stmt|;
name|mp
operator|=
name|marr
expr_stmt|;
name|next
operator|=
name|m
expr_stmt|;
do|do
block|{
name|count
operator|++
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|m_nextpkt
expr_stmt|;
block|}
do|while
condition|(
name|next
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|count
operator|>
name|nitems
argument_list|(
name|marr
argument_list|)
condition|)
if|if
condition|(
operator|(
name|mp
operator|=
name|malloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mbuf
operator|*
argument_list|)
argument_list|,
name|M_IFLIB
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* XXX check nextpkt */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* XXX simplify for now */
name|DBG_COUNTER_INC
argument_list|(
name|tx_frees
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
for|for
control|(
name|next
operator|=
name|m
operator|,
name|i
operator|=
literal|0
init|;
name|next
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|mp
index|[
name|i
index|]
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|m_nextpkt
expr_stmt|;
name|mp
index|[
name|i
index|]
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
name|DBG_COUNTER_INC
argument_list|(
name|tx_seen
argument_list|)
expr_stmt|;
name|err
operator|=
name|ifmp_ring_enqueue
argument_list|(
name|txq
operator|->
name|ift_br
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|m
argument_list|,
literal|1
argument_list|,
name|TX_BATCH_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|GROUPTASK_ENQUEUE
argument_list|(
operator|&
name|txq
operator|->
name|ift_task
argument_list|)
expr_stmt|;
comment|/* support forthcoming later */
ifdef|#
directive|ifdef
name|DRIVER_BACKPRESSURE
name|txq
operator|->
name|ift_closed
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
name|ifmp_ring_check_drainage
argument_list|(
name|txq
operator|->
name|ift_br
argument_list|,
name|TX_BATCH_SIZE
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TXQ_AVAIL
argument_list|(
name|txq
argument_list|)
operator|<
operator|(
name|txq
operator|->
name|ift_size
operator|>>
literal|1
operator|)
condition|)
block|{
name|GROUPTASK_ENQUEUE
argument_list|(
operator|&
name|txq
operator|->
name|ift_task
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iflib_if_qflush
parameter_list|(
name|if_t
name|ifp
parameter_list|)
block|{
name|if_ctx_t
name|ctx
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|iflib_txq_t
name|txq
init|=
name|ctx
operator|->
name|ifc_txqs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ifc_flags
operator||=
name|IFC_QFLUSH
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTXQSETS
argument_list|(
name|ctx
argument_list|)
condition|;
name|i
operator|++
operator|,
name|txq
operator|++
control|)
while|while
condition|(
operator|!
operator|(
name|ifmp_ring_is_idle
argument_list|(
name|txq
operator|->
name|ift_br
argument_list|)
operator|||
name|ifmp_ring_is_stalled
argument_list|(
name|txq
operator|->
name|ift_br
argument_list|)
operator|)
condition|)
name|iflib_txq_check_drain
argument_list|(
name|txq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ifc_flags
operator|&=
operator|~
name|IFC_QFLUSH
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|if_qflush
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|IFCAP_FLAGS
value|(IFCAP_TXCSUM_IPV6 | IFCAP_RXCSUM_IPV6 | IFCAP_HWCSUM | IFCAP_LRO | \ 		     IFCAP_TSO4 | IFCAP_TSO6 | IFCAP_VLAN_HWTAGGING |	\ 		     IFCAP_VLAN_MTU | IFCAP_VLAN_HWFILTER | IFCAP_VLAN_HWTSO)
end_define

begin_function
specifier|static
name|int
name|iflib_if_ioctl
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|u_long
name|command
parameter_list|,
name|caddr_t
name|data
parameter_list|)
block|{
name|if_ctx_t
name|ctx
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
endif|#
directive|endif
name|bool
name|avoid_reset
init|=
name|FALSE
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|,
name|reinit
init|=
literal|0
decl_stmt|,
name|bits
decl_stmt|;
switch|switch
condition|(
name|command
condition|)
block|{
case|case
name|SIOCSIFADDR
case|:
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|avoid_reset
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
name|avoid_reset
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* 		** Calling init results in link renegotiation, 		** so we avoid doing it when possible. 		*/
if|if
condition|(
name|avoid_reset
condition|)
block|{
name|if_setflagbits
argument_list|(
name|ifp
argument_list|,
name|IFF_UP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
name|reinit
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|!
operator|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_NOARP
operator|)
condition|)
name|arp_ifinit
argument_list|(
name|ifp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|err
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|==
name|if_getmtu
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
break|break;
block|}
name|bits
operator|=
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* stop the driver and free any clusters before proceeding */
name|iflib_stop
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|IFDI_MTU_SET
argument_list|(
name|ctx
argument_list|,
name|ifr
operator|->
name|ifr_mtu
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|ctx
operator|->
name|ifc_max_fl_buf_size
condition|)
name|ctx
operator|->
name|ifc_flags
operator||=
name|IFC_MULTISEG
expr_stmt|;
else|else
name|ctx
operator|->
name|ifc_flags
operator|&=
operator|~
name|IFC_MULTISEG
expr_stmt|;
name|err
operator|=
name|if_setmtu
argument_list|(
name|ifp
argument_list|,
name|ifr
operator|->
name|ifr_mtu
argument_list|)
expr_stmt|;
block|}
name|iflib_init_locked
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|if_setdrvflags
argument_list|(
name|ifp
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCSIFFLAGS
case|:
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_UP
condition|)
block|{
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
if|if
condition|(
operator|(
name|if_getflags
argument_list|(
name|ifp
argument_list|)
operator|^
name|ctx
operator|->
name|ifc_if_flags
operator|)
operator|&
operator|(
name|IFF_PROMISC
operator||
name|IFF_ALLMULTI
operator|)
condition|)
block|{
name|err
operator|=
name|IFDI_PROMISC_SET
argument_list|(
name|ctx
argument_list|,
name|if_getflags
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|reinit
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|iflib_stop
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
name|ctx
operator|->
name|ifc_if_flags
operator|=
name|if_getflags
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
if|if
condition|(
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|IFDI_INTR_DISABLE
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|IFDI_MULTI_SET
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|IFDI_INTR_ENABLE
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCSIFMEDIA
case|:
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|IFDI_MEDIA_SET
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* falls thru */
case|case
name|SIOCGIFMEDIA
case|:
name|err
operator|=
name|ifmedia_ioctl
argument_list|(
name|ifp
argument_list|,
name|ifr
argument_list|,
operator|&
name|ctx
operator|->
name|ifc_media
argument_list|,
name|command
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGI2C
case|:
block|{
name|struct
name|ifi2creq
name|i2c
decl_stmt|;
name|err
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|i2c
argument_list|,
sizeof|sizeof
argument_list|(
name|i2c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|i2c
operator|.
name|dev_addr
operator|!=
literal|0xA0
operator|&&
name|i2c
operator|.
name|dev_addr
operator|!=
literal|0xA2
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i2c
operator|.
name|len
operator|>
sizeof|sizeof
argument_list|(
name|i2c
operator|.
name|data
argument_list|)
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|IFDI_I2C_REQ
argument_list|(
name|ctx
argument_list|,
operator|&
name|i2c
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|err
operator|=
name|copyout
argument_list|(
operator|&
name|i2c
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|i2c
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SIOCSIFCAP
case|:
block|{
name|int
name|mask
decl_stmt|,
name|setmask
decl_stmt|;
name|mask
operator|=
name|ifr
operator|->
name|ifr_reqcap
operator|^
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|setmask
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TCP_OFFLOAD
name|setmask
operator||=
name|mask
operator|&
operator|(
name|IFCAP_TOE4
operator||
name|IFCAP_TOE6
operator|)
expr_stmt|;
endif|#
directive|endif
name|setmask
operator||=
operator|(
name|mask
operator|&
name|IFCAP_FLAGS
operator|)
expr_stmt|;
if|if
condition|(
name|setmask
operator|&
operator|(
name|IFCAP_RXCSUM
operator||
name|IFCAP_RXCSUM_IPV6
operator|)
condition|)
name|setmask
operator||=
operator|(
name|IFCAP_RXCSUM
operator||
name|IFCAP_RXCSUM_IPV6
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
name|IFCAP_WOL
operator|)
operator|&&
operator|(
name|if_getcapabilities
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_WOL
operator|)
operator|!=
literal|0
condition|)
name|setmask
operator||=
operator|(
name|mask
operator|&
operator|(
name|IFCAP_WOL_MCAST
operator||
name|IFCAP_WOL_MAGIC
operator|)
operator|)
expr_stmt|;
name|if_vlancap
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 		 * want to ensure that traffic has stopped before we change any of the flags 		 */
if|if
condition|(
name|setmask
condition|)
block|{
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|bits
operator|=
name|if_getdrvflags
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|IFF_DRV_RUNNING
condition|)
name|iflib_stop
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|if_togglecapenable
argument_list|(
name|ifp
argument_list|,
name|setmask
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
operator|&
name|IFF_DRV_RUNNING
condition|)
name|iflib_init_locked
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|if_setdrvflags
argument_list|(
name|ifp
argument_list|,
name|bits
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SIOCGPRIVATE_0
case|:
case|case
name|SIOCSDRVSPEC
case|:
case|case
name|SIOCGDRVSPEC
case|:
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|err
operator|=
name|IFDI_PRIV_IOCTL
argument_list|(
name|ctx
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|ether_ioctl
argument_list|(
name|ifp
argument_list|,
name|command
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|reinit
condition|)
name|iflib_if_init
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|iflib_if_get_counter
parameter_list|(
name|if_t
name|ifp
parameter_list|,
name|ift_counter
name|cnt
parameter_list|)
block|{
name|if_ctx_t
name|ctx
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
return|return
operator|(
name|IFDI_GET_COUNTER
argument_list|(
name|ctx
argument_list|,
name|cnt
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  OTHER FUNCTIONS EXPORTED TO THE STACK  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|iflib_vlan_register
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|if_t
name|ifp
parameter_list|,
name|uint16_t
name|vtag
parameter_list|)
block|{
name|if_ctx_t
name|ctx
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|void
operator|*
operator|)
name|ctx
operator|!=
name|arg
condition|)
return|return;
if|if
condition|(
operator|(
name|vtag
operator|==
literal|0
operator|)
operator|||
operator|(
name|vtag
operator|>
literal|4095
operator|)
condition|)
return|return;
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|IFDI_VLAN_REGISTER
argument_list|(
name|ctx
argument_list|,
name|vtag
argument_list|)
expr_stmt|;
comment|/* Re-init to load the changes */
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
name|iflib_init_locked
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iflib_vlan_unregister
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|if_t
name|ifp
parameter_list|,
name|uint16_t
name|vtag
parameter_list|)
block|{
name|if_ctx_t
name|ctx
init|=
name|if_getsoftc
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|void
operator|*
operator|)
name|ctx
operator|!=
name|arg
condition|)
return|return;
if|if
condition|(
operator|(
name|vtag
operator|==
literal|0
operator|)
operator|||
operator|(
name|vtag
operator|>
literal|4095
operator|)
condition|)
return|return;
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|IFDI_VLAN_UNREGISTER
argument_list|(
name|ctx
argument_list|,
name|vtag
argument_list|)
expr_stmt|;
comment|/* Re-init to load the changes */
if|if
condition|(
name|if_getcapenable
argument_list|(
name|ifp
argument_list|)
operator|&
name|IFCAP_VLAN_HWFILTER
condition|)
name|iflib_init_locked
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iflib_led_func
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
name|if_ctx_t
name|ctx
init|=
name|arg
decl_stmt|;
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|IFDI_LED_FUNC
argument_list|(
name|ctx
argument_list|,
name|onoff
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  BUS FUNCTION DEFINITIONS  *  **********************************************************************/
end_comment

begin_function
name|int
name|iflib_device_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|pci_vendor_info_t
modifier|*
name|ent
decl_stmt|;
name|uint16_t
name|pci_vendor_id
decl_stmt|,
name|pci_device_id
decl_stmt|;
name|uint16_t
name|pci_subvendor_id
decl_stmt|,
name|pci_subdevice_id
decl_stmt|;
name|uint16_t
name|pci_rev_id
decl_stmt|;
name|if_shared_ctx_t
name|sctx
decl_stmt|;
if|if
condition|(
operator|(
name|sctx
operator|=
name|DEVICE_REGISTER
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|sctx
operator|->
name|isc_magic
operator|!=
name|IFLIB_MAGIC
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
name|pci_vendor_id
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_device_id
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subvendor_id
operator|=
name|pci_get_subvendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_subdevice_id
operator|=
name|pci_get_subdevice
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_rev_id
operator|=
name|pci_get_revid
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctx
operator|->
name|isc_parse_devinfo
operator|!=
name|NULL
condition|)
name|sctx
operator|->
name|isc_parse_devinfo
argument_list|(
operator|&
name|pci_device_id
argument_list|,
operator|&
name|pci_subvendor_id
argument_list|,
operator|&
name|pci_subdevice_id
argument_list|,
operator|&
name|pci_rev_id
argument_list|)
expr_stmt|;
name|ent
operator|=
name|sctx
operator|->
name|isc_vendor_info
expr_stmt|;
while|while
condition|(
name|ent
operator|->
name|pvi_vendor_id
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pci_vendor_id
operator|!=
name|ent
operator|->
name|pvi_vendor_id
condition|)
block|{
name|ent
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|pci_device_id
operator|==
name|ent
operator|->
name|pvi_device_id
operator|)
operator|&&
operator|(
operator|(
name|pci_subvendor_id
operator|==
name|ent
operator|->
name|pvi_subvendor_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|pvi_subvendor_id
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|pci_subdevice_id
operator|==
name|ent
operator|->
name|pvi_subdevice_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|pvi_subdevice_id
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|pci_rev_id
operator|==
name|ent
operator|->
name|pvi_rev_id
operator|)
operator|||
operator|(
name|ent
operator|->
name|pvi_rev_id
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|device_set_desc_copy
argument_list|(
name|dev
argument_list|,
name|ent
operator|->
name|pvi_name
argument_list|)
expr_stmt|;
comment|/* this needs to be changed to zero if the bus probing code 			 * ever stops re-probing on best match because the sctx 			 * may have its values over written by register calls 			 * in subsequent probes 			 */
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
name|ent
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
name|int
name|iflib_device_register
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|void
modifier|*
name|sc
parameter_list|,
name|if_shared_ctx_t
name|sctx
parameter_list|,
name|if_ctx_t
modifier|*
name|ctxp
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|rid
decl_stmt|,
name|msix
decl_stmt|,
name|msix_bar
decl_stmt|;
name|if_ctx_t
name|ctx
decl_stmt|;
name|if_t
name|ifp
decl_stmt|;
name|if_softc_ctx_t
name|scctx
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint16_t
name|main_txq
decl_stmt|;
name|uint16_t
name|main_rxq
decl_stmt|;
name|ctx
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|,
name|M_IFLIB
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|sc
operator|=
name|malloc
argument_list|(
name|sctx
operator|->
name|isc_driver
operator|->
name|size
argument_list|,
name|M_IFLIB
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|device_set_softc
argument_list|(
name|dev
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ifc_flags
operator||=
name|IFC_SC_ALLOCATED
expr_stmt|;
block|}
name|ctx
operator|->
name|ifc_sctx
operator|=
name|sctx
expr_stmt|;
name|ctx
operator|->
name|ifc_dev
operator|=
name|dev
expr_stmt|;
name|ctx
operator|->
name|ifc_softc
operator|=
name|sc
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|iflib_register
argument_list|(
name|ctx
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"iflib_register failed %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|iflib_add_device_sysctl_pre
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|scctx
operator|=
operator|&
name|ctx
operator|->
name|ifc_softc_ctx
expr_stmt|;
name|ifp
operator|=
name|ctx
operator|->
name|ifc_ifp
expr_stmt|;
comment|/* 	 * XXX sanity check that ntxd& nrxd are a power of 2 	 */
if|if
condition|(
name|ctx
operator|->
name|ifc_sysctl_ntxqs
operator|!=
literal|0
condition|)
name|scctx
operator|->
name|isc_ntxqsets
operator|=
name|ctx
operator|->
name|ifc_sysctl_ntxqs
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ifc_sysctl_nrxqs
operator|!=
literal|0
condition|)
name|scctx
operator|->
name|isc_nrxqsets
operator|=
name|ctx
operator|->
name|ifc_sysctl_nrxqs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sctx
operator|->
name|isc_ntxqs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ctx
operator|->
name|ifc_sysctl_ntxds
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|scctx
operator|->
name|isc_ntxd
index|[
name|i
index|]
operator|=
name|ctx
operator|->
name|ifc_sysctl_ntxds
index|[
name|i
index|]
expr_stmt|;
else|else
name|scctx
operator|->
name|isc_ntxd
index|[
name|i
index|]
operator|=
name|sctx
operator|->
name|isc_ntxd_default
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sctx
operator|->
name|isc_nrxqs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ctx
operator|->
name|ifc_sysctl_nrxds
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|scctx
operator|->
name|isc_nrxd
index|[
name|i
index|]
operator|=
name|ctx
operator|->
name|ifc_sysctl_nrxds
index|[
name|i
index|]
expr_stmt|;
else|else
name|scctx
operator|->
name|isc_nrxd
index|[
name|i
index|]
operator|=
name|sctx
operator|->
name|isc_nrxd_default
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sctx
operator|->
name|isc_nrxqs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|scctx
operator|->
name|isc_nrxd
index|[
name|i
index|]
operator|<
name|sctx
operator|->
name|isc_nrxd_min
index|[
name|i
index|]
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"nrxd%d: %d less than nrxd_min %d - resetting to min\n"
argument_list|,
name|i
argument_list|,
name|scctx
operator|->
name|isc_nrxd
index|[
name|i
index|]
argument_list|,
name|sctx
operator|->
name|isc_nrxd_min
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|scctx
operator|->
name|isc_nrxd
index|[
name|i
index|]
operator|=
name|sctx
operator|->
name|isc_nrxd_min
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|scctx
operator|->
name|isc_nrxd
index|[
name|i
index|]
operator|>
name|sctx
operator|->
name|isc_nrxd_max
index|[
name|i
index|]
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"nrxd%d: %d greater than nrxd_max %d - resetting to max\n"
argument_list|,
name|i
argument_list|,
name|scctx
operator|->
name|isc_nrxd
index|[
name|i
index|]
argument_list|,
name|sctx
operator|->
name|isc_nrxd_max
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|scctx
operator|->
name|isc_nrxd
index|[
name|i
index|]
operator|=
name|sctx
operator|->
name|isc_nrxd_max
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sctx
operator|->
name|isc_ntxqs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|scctx
operator|->
name|isc_ntxd
index|[
name|i
index|]
operator|<
name|sctx
operator|->
name|isc_ntxd_min
index|[
name|i
index|]
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ntxd%d: %d less than ntxd_min %d - resetting to min\n"
argument_list|,
name|i
argument_list|,
name|scctx
operator|->
name|isc_ntxd
index|[
name|i
index|]
argument_list|,
name|sctx
operator|->
name|isc_ntxd_min
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|scctx
operator|->
name|isc_ntxd
index|[
name|i
index|]
operator|=
name|sctx
operator|->
name|isc_ntxd_min
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|scctx
operator|->
name|isc_ntxd
index|[
name|i
index|]
operator|>
name|sctx
operator|->
name|isc_ntxd_max
index|[
name|i
index|]
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ntxd%d: %d greater than ntxd_max %d - resetting to max\n"
argument_list|,
name|i
argument_list|,
name|scctx
operator|->
name|isc_ntxd
index|[
name|i
index|]
argument_list|,
name|sctx
operator|->
name|isc_ntxd_max
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|scctx
operator|->
name|isc_ntxd
index|[
name|i
index|]
operator|=
name|sctx
operator|->
name|isc_ntxd_max
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|IFDI_ATTACH_PRE
argument_list|(
name|ctx
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"IFDI_ATTACH_PRE failed %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|_iflib_pre_assert
argument_list|(
name|scctx
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ifc_txrx
operator|=
operator|*
name|scctx
operator|->
name|isc_txrx
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|MPASS
argument_list|(
name|scctx
operator|->
name|isc_capenable
argument_list|)
expr_stmt|;
if|if
condition|(
name|scctx
operator|->
name|isc_capenable
operator|&
name|IFCAP_TXCSUM
condition|)
name|MPASS
argument_list|(
name|scctx
operator|->
name|isc_tx_csum_flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|if_setcapabilities
argument_list|(
name|ifp
argument_list|,
name|scctx
operator|->
name|isc_capenable
argument_list|)
expr_stmt|;
name|if_setcapenable
argument_list|(
name|ifp
argument_list|,
name|scctx
operator|->
name|isc_capenable
argument_list|)
expr_stmt|;
if|if
condition|(
name|scctx
operator|->
name|isc_ntxqsets
operator|==
literal|0
operator|||
operator|(
name|scctx
operator|->
name|isc_ntxqsets_max
operator|&&
name|scctx
operator|->
name|isc_ntxqsets_max
operator|<
name|scctx
operator|->
name|isc_ntxqsets
operator|)
condition|)
name|scctx
operator|->
name|isc_ntxqsets
operator|=
name|scctx
operator|->
name|isc_ntxqsets_max
expr_stmt|;
if|if
condition|(
name|scctx
operator|->
name|isc_nrxqsets
operator|==
literal|0
operator|||
operator|(
name|scctx
operator|->
name|isc_nrxqsets_max
operator|&&
name|scctx
operator|->
name|isc_nrxqsets_max
operator|<
name|scctx
operator|->
name|isc_nrxqsets
operator|)
condition|)
name|scctx
operator|->
name|isc_nrxqsets
operator|=
name|scctx
operator|->
name|isc_nrxqsets_max
expr_stmt|;
ifdef|#
directive|ifdef
name|ACPI_DMAR
if|if
condition|(
name|dmar_get_dma_tag
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
argument_list|)
operator|!=
name|NULL
condition|)
name|ctx
operator|->
name|ifc_flags
operator||=
name|IFC_DMAR
expr_stmt|;
elif|#
directive|elif
operator|!
operator|(
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|)
comment|/* set unconditionally for !x86 */
name|ctx
operator|->
name|ifc_flags
operator||=
name|IFC_DMAR
expr_stmt|;
endif|#
directive|endif
name|msix_bar
operator|=
name|scctx
operator|->
name|isc_msix_bar
expr_stmt|;
name|main_txq
operator|=
operator|(
name|sctx
operator|->
name|isc_flags
operator|&
name|IFLIB_HAS_TXCQ
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|main_rxq
operator|=
operator|(
name|sctx
operator|->
name|isc_flags
operator|&
name|IFLIB_HAS_RXCQ
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* XXX change for per-queue sizes */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"using %d tx descriptors and %d rx descriptors\n"
argument_list|,
name|scctx
operator|->
name|isc_ntxd
index|[
name|main_txq
index|]
argument_list|,
name|scctx
operator|->
name|isc_nrxd
index|[
name|main_rxq
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sctx
operator|->
name|isc_nrxqs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|powerof2
argument_list|(
name|scctx
operator|->
name|isc_nrxd
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|/* round down instead? */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"# rx descriptors must be a power of 2\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sctx
operator|->
name|isc_ntxqs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|powerof2
argument_list|(
name|scctx
operator|->
name|isc_ntxd
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"# tx descriptors must be a power of 2"
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
block|}
if|if
condition|(
name|scctx
operator|->
name|isc_tx_nsegments
operator|>
name|scctx
operator|->
name|isc_ntxd
index|[
name|main_txq
index|]
operator|/
name|MAX_SINGLE_PACKET_FRACTION
condition|)
name|scctx
operator|->
name|isc_tx_nsegments
operator|=
name|max
argument_list|(
literal|1
argument_list|,
name|scctx
operator|->
name|isc_ntxd
index|[
name|main_txq
index|]
operator|/
name|MAX_SINGLE_PACKET_FRACTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|scctx
operator|->
name|isc_tx_tso_segments_max
operator|>
name|scctx
operator|->
name|isc_ntxd
index|[
name|main_txq
index|]
operator|/
name|MAX_SINGLE_PACKET_FRACTION
condition|)
name|scctx
operator|->
name|isc_tx_tso_segments_max
operator|=
name|max
argument_list|(
literal|1
argument_list|,
name|scctx
operator|->
name|isc_ntxd
index|[
name|main_txq
index|]
operator|/
name|MAX_SINGLE_PACKET_FRACTION
argument_list|)
expr_stmt|;
comment|/* 	 * Protect the stack against modern hardware 	 */
if|if
condition|(
name|scctx
operator|->
name|isc_tx_tso_size_max
operator|>
name|FREEBSD_TSO_SIZE_MAX
condition|)
name|scctx
operator|->
name|isc_tx_tso_size_max
operator|=
name|FREEBSD_TSO_SIZE_MAX
expr_stmt|;
comment|/* TSO parameters - dig these out of the data sheet - simply correspond to tag setup */
name|ifp
operator|->
name|if_hw_tsomaxsegcount
operator|=
name|scctx
operator|->
name|isc_tx_tso_segments_max
expr_stmt|;
name|ifp
operator|->
name|if_hw_tsomax
operator|=
name|scctx
operator|->
name|isc_tx_tso_size_max
expr_stmt|;
name|ifp
operator|->
name|if_hw_tsomaxsegsize
operator|=
name|scctx
operator|->
name|isc_tx_tso_segsize_max
expr_stmt|;
if|if
condition|(
name|scctx
operator|->
name|isc_rss_table_size
operator|==
literal|0
condition|)
name|scctx
operator|->
name|isc_rss_table_size
operator|=
literal|64
expr_stmt|;
name|scctx
operator|->
name|isc_rss_table_mask
operator|=
name|scctx
operator|->
name|isc_rss_table_size
operator|-
literal|1
expr_stmt|;
name|GROUPTASK_INIT
argument_list|(
operator|&
name|ctx
operator|->
name|ifc_admin_task
argument_list|,
literal|0
argument_list|,
name|_task_fn_admin
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
comment|/* XXX format name */
name|taskqgroup_attach
argument_list|(
name|qgroup_if_config_tqg
argument_list|,
operator|&
name|ctx
operator|->
name|ifc_admin_task
argument_list|,
name|ctx
argument_list|,
operator|-
literal|1
argument_list|,
literal|"admin"
argument_list|)
expr_stmt|;
comment|/* 	** Now setup MSI or MSI/X, should 	** return us the number of supported 	** vectors. (Will be 1 for MSI) 	*/
if|if
condition|(
name|sctx
operator|->
name|isc_flags
operator|&
name|IFLIB_SKIP_MSIX
condition|)
block|{
name|msix
operator|=
name|scctx
operator|->
name|isc_vectors
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|scctx
operator|->
name|isc_msix_bar
operator|!=
literal|0
condition|)
comment|/* 		* The simple fact that isc_msix_bar is not 0 does not mean we 		* we have a good value there that is known to work. 		*/
name|msix
operator|=
name|iflib_msix_init
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
else|else
block|{
name|scctx
operator|->
name|isc_vectors
operator|=
literal|1
expr_stmt|;
name|scctx
operator|->
name|isc_ntxqsets
operator|=
literal|1
expr_stmt|;
name|scctx
operator|->
name|isc_nrxqsets
operator|=
literal|1
expr_stmt|;
name|scctx
operator|->
name|isc_intr
operator|=
name|IFLIB_INTR_LEGACY
expr_stmt|;
name|msix
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Get memory for the station queues */
if|if
condition|(
operator|(
name|err
operator|=
name|iflib_queues_alloc
argument_list|(
name|ctx
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate queue memory\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|iflib_qset_structures_setup
argument_list|(
name|ctx
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"qset structure setup failed %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|fail_queues
goto|;
block|}
comment|/* 	 * Group taskqueues aren't properly set up until SMP is started, 	 * so we disable interrupts until we can handle them post 	 * SI_SUB_SMP. 	 * 	 * XXX: disabling interrupts doesn't actually work, at least for 	 * the non-MSI case.  When they occur before SI_SUB_SMP completes, 	 * we do null handling and depend on this not causing too large an 	 * interrupt storm. 	 */
name|IFDI_INTR_DISABLE
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|msix
operator|>
literal|1
operator|&&
operator|(
name|err
operator|=
name|IFDI_MSIX_INTR_ASSIGN
argument_list|(
name|ctx
argument_list|,
name|msix
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"IFDI_MSIX_INTR_ASSIGN failed %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|fail_intr_free
goto|;
block|}
if|if
condition|(
name|msix
operator|<=
literal|1
condition|)
block|{
name|rid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|scctx
operator|->
name|isc_intr
operator|==
name|IFLIB_INTR_MSI
condition|)
block|{
name|MPASS
argument_list|(
name|msix
operator|==
literal|1
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|iflib_legacy_setup
argument_list|(
name|ctx
argument_list|,
name|ctx
operator|->
name|isc_legacy_intr
argument_list|,
name|ctx
operator|->
name|ifc_softc
argument_list|,
operator|&
name|rid
argument_list|,
literal|"irq0"
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"iflib_legacy_setup failed %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|fail_intr_free
goto|;
block|}
block|}
name|ether_ifattach
argument_list|(
name|ctx
operator|->
name|ifc_ifp
argument_list|,
name|ctx
operator|->
name|ifc_mac
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|IFDI_ATTACH_POST
argument_list|(
name|ctx
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"IFDI_ATTACH_POST failed %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|fail_detach
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|iflib_netmap_attach
argument_list|(
name|ctx
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|ctx
operator|->
name|ifc_dev
argument_list|,
literal|"netmap attach failed: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|fail_detach
goto|;
block|}
operator|*
name|ctxp
operator|=
name|ctx
expr_stmt|;
name|if_setgetcounterfn
argument_list|(
name|ctx
operator|->
name|ifc_ifp
argument_list|,
name|iflib_if_get_counter
argument_list|)
expr_stmt|;
name|iflib_add_device_sysctl_post
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ifc_flags
operator||=
name|IFC_INIT_DONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|fail_detach
label|:
name|ether_ifdetach
argument_list|(
name|ctx
operator|->
name|ifc_ifp
argument_list|)
expr_stmt|;
name|fail_intr_free
label|:
if|if
condition|(
name|scctx
operator|->
name|isc_intr
operator|==
name|IFLIB_INTR_MSIX
operator|||
name|scctx
operator|->
name|isc_intr
operator|==
name|IFLIB_INTR_MSI
condition|)
name|pci_release_msi
argument_list|(
name|ctx
operator|->
name|ifc_dev
argument_list|)
expr_stmt|;
name|fail_queues
label|:
comment|/* XXX free queues */
name|fail
label|:
name|IFDI_DETACH
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|iflib_device_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|if_ctx_t
name|ctx
decl_stmt|;
name|if_shared_ctx_t
name|sctx
decl_stmt|;
if|if
condition|(
operator|(
name|sctx
operator|=
name|DEVICE_REGISTER
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|sctx
operator|->
name|isc_magic
operator|!=
name|IFLIB_MAGIC
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|iflib_device_register
argument_list|(
name|dev
argument_list|,
name|NULL
argument_list|,
name|sctx
argument_list|,
operator|&
name|ctx
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|iflib_device_deregister
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|if_t
name|ifp
init|=
name|ctx
operator|->
name|ifc_ifp
decl_stmt|;
name|iflib_txq_t
name|txq
decl_stmt|;
name|iflib_rxq_t
name|rxq
decl_stmt|;
name|device_t
name|dev
init|=
name|ctx
operator|->
name|ifc_dev
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|taskqgroup
modifier|*
name|tqg
decl_stmt|;
name|iflib_fl_t
name|fl
decl_stmt|;
comment|/* Make sure VLANS are not using driver */
if|if
condition|(
name|if_vlantrunkinuse
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Vlan in use, detach first\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ifc_in_detach
operator|=
literal|1
expr_stmt|;
name|iflib_stop
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
comment|/* Unregister VLAN events */
if|if
condition|(
name|ctx
operator|->
name|ifc_vlan_attach_event
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_config
argument_list|,
name|ctx
operator|->
name|ifc_vlan_attach_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ifc_vlan_detach_event
operator|!=
name|NULL
condition|)
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|ctx
operator|->
name|ifc_vlan_detach_event
argument_list|)
expr_stmt|;
name|iflib_netmap_detach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* ether_ifdetach calls if_qflush - lock must be destroy afterwards*/
name|CTX_LOCK_DESTROY
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ifc_led_dev
operator|!=
name|NULL
condition|)
name|led_destroy
argument_list|(
name|ctx
operator|->
name|ifc_led_dev
argument_list|)
expr_stmt|;
comment|/* XXX drain any dependent tasks */
name|tqg
operator|=
name|qgroup_if_io_tqg
expr_stmt|;
for|for
control|(
name|txq
operator|=
name|ctx
operator|->
name|ifc_txqs
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTXQSETS
argument_list|(
name|ctx
argument_list|)
condition|;
name|i
operator|++
operator|,
name|txq
operator|++
control|)
block|{
name|callout_drain
argument_list|(
operator|&
name|txq
operator|->
name|ift_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|ift_task
operator|.
name|gt_uniq
operator|!=
name|NULL
condition|)
name|taskqgroup_detach
argument_list|(
name|tqg
argument_list|,
operator|&
name|txq
operator|->
name|ift_task
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rxq
operator|=
name|ctx
operator|->
name|ifc_rxqs
init|;
name|i
operator|<
name|NRXQSETS
argument_list|(
name|ctx
argument_list|)
condition|;
name|i
operator|++
operator|,
name|rxq
operator|++
control|)
block|{
if|if
condition|(
name|rxq
operator|->
name|ifr_task
operator|.
name|gt_uniq
operator|!=
name|NULL
condition|)
name|taskqgroup_detach
argument_list|(
name|tqg
argument_list|,
operator|&
name|rxq
operator|->
name|ifr_task
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|fl
operator|=
name|rxq
operator|->
name|ifr_fl
init|;
name|j
operator|<
name|rxq
operator|->
name|ifr_nfl
condition|;
name|j
operator|++
operator|,
name|fl
operator|++
control|)
name|free
argument_list|(
name|fl
operator|->
name|ifl_rx_bitmap
argument_list|,
name|M_IFLIB
argument_list|)
expr_stmt|;
block|}
name|tqg
operator|=
name|qgroup_if_config_tqg
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ifc_admin_task
operator|.
name|gt_uniq
operator|!=
name|NULL
condition|)
name|taskqgroup_detach
argument_list|(
name|tqg
argument_list|,
operator|&
name|ctx
operator|->
name|ifc_admin_task
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ifc_vflr_task
operator|.
name|gt_uniq
operator|!=
name|NULL
condition|)
name|taskqgroup_detach
argument_list|(
name|tqg
argument_list|,
operator|&
name|ctx
operator|->
name|ifc_vflr_task
argument_list|)
expr_stmt|;
name|IFDI_DETACH
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|device_set_softc
argument_list|(
name|ctx
operator|->
name|ifc_dev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ifc_softc_ctx
operator|.
name|isc_intr
operator|!=
name|IFLIB_INTR_LEGACY
condition|)
block|{
name|pci_release_msi
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|ifc_softc_ctx
operator|.
name|isc_intr
operator|!=
name|IFLIB_INTR_MSIX
condition|)
block|{
name|iflib_irq_free
argument_list|(
name|ctx
argument_list|,
operator|&
name|ctx
operator|->
name|ifc_legacy_irq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|ifc_msix_mem
operator|!=
name|NULL
condition|)
block|{
name|bus_release_resource
argument_list|(
name|ctx
operator|->
name|ifc_dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|ctx
operator|->
name|ifc_softc_ctx
operator|.
name|isc_msix_bar
argument_list|,
name|ctx
operator|->
name|ifc_msix_mem
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ifc_msix_mem
operator|=
name|NULL
expr_stmt|;
block|}
name|bus_generic_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|iflib_tx_structures_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|iflib_rx_structures_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ifc_flags
operator|&
name|IFC_SC_ALLOCATED
condition|)
name|free
argument_list|(
name|ctx
operator|->
name|ifc_softc
argument_list|,
name|M_IFLIB
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
argument_list|,
name|M_IFLIB
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|iflib_device_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|if_ctx_t
name|ctx
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
operator|(
name|iflib_device_deregister
argument_list|(
name|ctx
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|iflib_device_suspend
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|if_ctx_t
name|ctx
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|IFDI_SUSPEND
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|bus_generic_suspend
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|iflib_device_shutdown
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|if_ctx_t
name|ctx
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|IFDI_SHUTDOWN
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
name|bus_generic_suspend
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|iflib_device_resume
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|if_ctx_t
name|ctx
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|iflib_txq_t
name|txq
init|=
name|ctx
operator|->
name|ifc_txqs
decl_stmt|;
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|IFDI_RESUME
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|iflib_init_locked
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|NTXQSETS
argument_list|(
name|ctx
argument_list|)
condition|;
name|i
operator|++
operator|,
name|txq
operator|++
control|)
name|iflib_txq_check_drain
argument_list|(
name|txq
argument_list|,
name|IFLIB_RESTART_BUDGET
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_resume
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|iflib_device_iov_init
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint16_t
name|num_vfs
parameter_list|,
specifier|const
name|nvlist_t
modifier|*
name|params
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|if_ctx_t
name|ctx
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|error
operator|=
name|IFDI_IOV_INIT
argument_list|(
name|ctx
argument_list|,
name|num_vfs
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|iflib_device_iov_uninit
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|if_ctx_t
name|ctx
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|IFDI_IOV_UNINIT
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|iflib_device_iov_add_vf
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|uint16_t
name|vfnum
parameter_list|,
specifier|const
name|nvlist_t
modifier|*
name|params
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|if_ctx_t
name|ctx
init|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|CTX_LOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|error
operator|=
name|IFDI_IOV_VF_ADD
argument_list|(
name|ctx
argument_list|,
name|vfnum
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|CTX_UNLOCK
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  MODULE FUNCTION DEFINITIONS  *  **********************************************************************/
end_comment

begin_comment
comment|/*  * - Start a fast taskqueue thread for each core  * - Start a taskqueue for control operations  */
end_comment

begin_function
specifier|static
name|int
name|iflib_module_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iflib_module_event_handler
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|what
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|MOD_LOAD
case|:
if|if
condition|(
operator|(
name|err
operator|=
name|iflib_module_init
argument_list|()
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
break|break;
case|case
name|MOD_UNLOAD
case|:
return|return
operator|(
name|EBUSY
operator|)
return|;
default|default:
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  PUBLIC FUNCTION DEFINITIONS  *     ordered as in iflib.h  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|_iflib_assert
parameter_list|(
name|if_shared_ctx_t
name|sctx
parameter_list|)
block|{
name|MPASS
argument_list|(
name|sctx
operator|->
name|isc_tx_maxsize
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|sctx
operator|->
name|isc_tx_maxsegsize
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|sctx
operator|->
name|isc_rx_maxsize
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|sctx
operator|->
name|isc_rx_nsegments
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|sctx
operator|->
name|isc_rx_maxsegsize
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|sctx
operator|->
name|isc_nrxd_min
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|sctx
operator|->
name|isc_nrxd_max
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|sctx
operator|->
name|isc_nrxd_default
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|sctx
operator|->
name|isc_ntxd_min
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|sctx
operator|->
name|isc_ntxd_max
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|sctx
operator|->
name|isc_ntxd_default
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_iflib_pre_assert
parameter_list|(
name|if_softc_ctx_t
name|scctx
parameter_list|)
block|{
name|MPASS
argument_list|(
name|scctx
operator|->
name|isc_txrx
operator|->
name|ift_txd_encap
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|scctx
operator|->
name|isc_txrx
operator|->
name|ift_txd_flush
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|scctx
operator|->
name|isc_txrx
operator|->
name|ift_txd_credits_update
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|scctx
operator|->
name|isc_txrx
operator|->
name|ift_rxd_available
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|scctx
operator|->
name|isc_txrx
operator|->
name|ift_rxd_pkt_get
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|scctx
operator|->
name|isc_txrx
operator|->
name|ift_rxd_refill
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|scctx
operator|->
name|isc_txrx
operator|->
name|ift_rxd_flush
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iflib_register
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|if_shared_ctx_t
name|sctx
init|=
name|ctx
operator|->
name|ifc_sctx
decl_stmt|;
name|driver_t
modifier|*
name|driver
init|=
name|sctx
operator|->
name|isc_driver
decl_stmt|;
name|device_t
name|dev
init|=
name|ctx
operator|->
name|ifc_dev
decl_stmt|;
name|if_t
name|ifp
decl_stmt|;
name|_iflib_assert
argument_list|(
name|sctx
argument_list|)
expr_stmt|;
name|CTX_LOCK_INIT
argument_list|(
name|ctx
argument_list|,
name|device_get_nameunit
argument_list|(
name|ctx
operator|->
name|ifc_dev
argument_list|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|ctx
operator|->
name|ifc_ifp
operator|=
name|if_gethandle
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"can not allocate ifnet structure\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* 	 * Initialize our context's device specific methods 	 */
name|kobj_init
argument_list|(
operator|(
name|kobj_t
operator|)
name|ctx
argument_list|,
operator|(
name|kobj_class_t
operator|)
name|driver
argument_list|)
expr_stmt|;
name|kobj_class_compile
argument_list|(
operator|(
name|kobj_class_t
operator|)
name|driver
argument_list|)
expr_stmt|;
name|driver
operator|->
name|refs
operator|++
expr_stmt|;
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|device_get_name
argument_list|(
name|dev
argument_list|)
argument_list|,
name|device_get_unit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|if_setsoftc
argument_list|(
name|ifp
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|if_setdev
argument_list|(
name|ifp
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|if_setinitfn
argument_list|(
name|ifp
argument_list|,
name|iflib_if_init
argument_list|)
expr_stmt|;
name|if_setioctlfn
argument_list|(
name|ifp
argument_list|,
name|iflib_if_ioctl
argument_list|)
expr_stmt|;
name|if_settransmitfn
argument_list|(
name|ifp
argument_list|,
name|iflib_if_transmit
argument_list|)
expr_stmt|;
name|if_setqflushfn
argument_list|(
name|ifp
argument_list|,
name|iflib_if_qflush
argument_list|)
expr_stmt|;
name|if_setflags
argument_list|(
name|ifp
argument_list|,
name|IFF_BROADCAST
operator||
name|IFF_SIMPLEX
operator||
name|IFF_MULTICAST
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ifc_vlan_attach_event
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_config
argument_list|,
name|iflib_vlan_register
argument_list|,
name|ctx
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ifc_vlan_detach_event
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|vlan_unconfig
argument_list|,
name|iflib_vlan_unregister
argument_list|,
name|ctx
argument_list|,
name|EVENTHANDLER_PRI_FIRST
argument_list|)
expr_stmt|;
name|ifmedia_init
argument_list|(
operator|&
name|ctx
operator|->
name|ifc_media
argument_list|,
name|IFM_IMASK
argument_list|,
name|iflib_media_change
argument_list|,
name|iflib_media_status
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iflib_queues_alloc
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|if_shared_ctx_t
name|sctx
init|=
name|ctx
operator|->
name|ifc_sctx
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
operator|&
name|ctx
operator|->
name|ifc_softc_ctx
decl_stmt|;
name|device_t
name|dev
init|=
name|ctx
operator|->
name|ifc_dev
decl_stmt|;
name|int
name|nrxqsets
init|=
name|scctx
operator|->
name|isc_nrxqsets
decl_stmt|;
name|int
name|ntxqsets
init|=
name|scctx
operator|->
name|isc_ntxqsets
decl_stmt|;
name|iflib_txq_t
name|txq
decl_stmt|;
name|iflib_rxq_t
name|rxq
decl_stmt|;
name|iflib_fl_t
name|fl
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|cpu
decl_stmt|,
name|err
decl_stmt|,
name|txconf
decl_stmt|,
name|rxconf
decl_stmt|;
name|iflib_dma_info_t
name|ifdip
decl_stmt|;
name|uint32_t
modifier|*
name|rxqsizes
init|=
name|scctx
operator|->
name|isc_rxqsizes
decl_stmt|;
name|uint32_t
modifier|*
name|txqsizes
init|=
name|scctx
operator|->
name|isc_txqsizes
decl_stmt|;
name|uint8_t
name|nrxqs
init|=
name|sctx
operator|->
name|isc_nrxqs
decl_stmt|;
name|uint8_t
name|ntxqs
init|=
name|sctx
operator|->
name|isc_ntxqs
decl_stmt|;
name|int
name|nfree_lists
init|=
name|sctx
operator|->
name|isc_nfl
condition|?
name|sctx
operator|->
name|isc_nfl
else|:
literal|1
decl_stmt|;
name|caddr_t
modifier|*
name|vaddrs
decl_stmt|;
name|uint64_t
modifier|*
name|paddrs
decl_stmt|;
name|struct
name|ifmp_ring
modifier|*
modifier|*
name|brscp
decl_stmt|;
name|KASSERT
argument_list|(
name|ntxqs
operator|>
literal|0
argument_list|,
operator|(
literal|"number of queues per qset must be at least 1"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nrxqs
operator|>
literal|0
argument_list|,
operator|(
literal|"number of queues per qset must be at least 1"
operator|)
argument_list|)
expr_stmt|;
name|brscp
operator|=
name|NULL
expr_stmt|;
name|txq
operator|=
name|NULL
expr_stmt|;
name|rxq
operator|=
name|NULL
expr_stmt|;
comment|/* Allocate the TX ring struct memory */
if|if
condition|(
operator|!
operator|(
name|txq
operator|=
operator|(
name|iflib_txq_t
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iflib_txq
argument_list|)
operator|*
name|ntxqsets
argument_list|,
name|M_IFLIB
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate TX ring memory\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Now allocate the RX */
if|if
condition|(
operator|!
operator|(
name|rxq
operator|=
operator|(
name|iflib_rxq_t
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iflib_rxq
argument_list|)
operator|*
name|nrxqsets
argument_list|,
name|M_IFLIB
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate RX ring memory\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|rx_fail
goto|;
block|}
name|ctx
operator|->
name|ifc_txqs
operator|=
name|txq
expr_stmt|;
name|ctx
operator|->
name|ifc_rxqs
operator|=
name|rxq
expr_stmt|;
comment|/* 	 * XXX handle allocation failure 	 */
for|for
control|(
name|txconf
operator|=
name|i
operator|=
literal|0
operator|,
name|cpu
operator|=
name|CPU_FIRST
argument_list|()
init|;
name|i
operator|<
name|ntxqsets
condition|;
name|i
operator|++
operator|,
name|txconf
operator|++
operator|,
name|txq
operator|++
operator|,
name|cpu
operator|=
name|CPU_NEXT
argument_list|(
name|cpu
argument_list|)
control|)
block|{
comment|/* Set up some basics */
if|if
condition|(
operator|(
name|ifdip
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iflib_dma_info
argument_list|)
operator|*
name|ntxqs
argument_list|,
name|M_IFLIB
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate iflib_dma_info\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_tx_desc
goto|;
block|}
name|txq
operator|->
name|ift_ifdi
operator|=
name|ifdip
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ntxqs
condition|;
name|j
operator|++
operator|,
name|ifdip
operator|++
control|)
block|{
if|if
condition|(
name|iflib_dma_alloc
argument_list|(
name|ctx
argument_list|,
name|txqsizes
index|[
name|j
index|]
argument_list|,
name|ifdip
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate Descriptor memory\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_tx_desc
goto|;
block|}
name|txq
operator|->
name|ift_txd_size
index|[
name|j
index|]
operator|=
name|scctx
operator|->
name|isc_txd_size
index|[
name|j
index|]
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ifdip
operator|->
name|idi_vaddr
argument_list|,
name|txqsizes
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|txq
operator|->
name|ift_ctx
operator|=
name|ctx
expr_stmt|;
name|txq
operator|->
name|ift_id
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|sctx
operator|->
name|isc_flags
operator|&
name|IFLIB_HAS_TXCQ
condition|)
block|{
name|txq
operator|->
name|ift_br_offset
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|txq
operator|->
name|ift_br_offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* XXX fix this */
name|txq
operator|->
name|ift_timer
operator|.
name|c_cpu
operator|=
name|cpu
expr_stmt|;
if|if
condition|(
name|iflib_txsd_alloc
argument_list|(
name|txq
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up TX buffers\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_tx_desc
goto|;
block|}
comment|/* Initialize the TX lock */
name|snprintf
argument_list|(
name|txq
operator|->
name|ift_mtx_name
argument_list|,
name|MTX_NAME_LEN
argument_list|,
literal|"%s:tx(%d):callout"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|txq
operator|->
name|ift_id
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|txq
operator|->
name|ift_mtx
argument_list|,
name|txq
operator|->
name|ift_mtx_name
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|txq
operator|->
name|ift_timer
argument_list|,
operator|&
name|txq
operator|->
name|ift_mtx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|txq
operator|->
name|ift_db_mtx_name
argument_list|,
name|MTX_NAME_LEN
argument_list|,
literal|"%s:tx(%d):db"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|txq
operator|->
name|ift_id
argument_list|)
expr_stmt|;
name|err
operator|=
name|ifmp_ring_alloc
argument_list|(
operator|&
name|txq
operator|->
name|ift_br
argument_list|,
literal|2048
argument_list|,
name|txq
argument_list|,
name|iflib_txq_drain
argument_list|,
name|iflib_txq_can_drain
argument_list|,
name|M_IFLIB
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* XXX free any allocated rings */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate buf_ring\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_tx_desc
goto|;
block|}
block|}
for|for
control|(
name|rxconf
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrxqsets
condition|;
name|i
operator|++
operator|,
name|rxconf
operator|++
operator|,
name|rxq
operator|++
control|)
block|{
comment|/* Set up some basics */
if|if
condition|(
operator|(
name|ifdip
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iflib_dma_info
argument_list|)
operator|*
name|nrxqs
argument_list|,
name|M_IFLIB
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate iflib_dma_info\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_tx_desc
goto|;
block|}
name|rxq
operator|->
name|ifr_ifdi
operator|=
name|ifdip
expr_stmt|;
comment|/* XXX this needs to be changed if #rx queues != #tx queues */
name|rxq
operator|->
name|ifr_ntxqirq
operator|=
literal|1
expr_stmt|;
name|rxq
operator|->
name|ifr_txqid
index|[
literal|0
index|]
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nrxqs
condition|;
name|j
operator|++
operator|,
name|ifdip
operator|++
control|)
block|{
if|if
condition|(
name|iflib_dma_alloc
argument_list|(
name|ctx
argument_list|,
name|rxqsizes
index|[
name|j
index|]
argument_list|,
name|ifdip
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate Descriptor memory\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_tx_desc
goto|;
block|}
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ifdip
operator|->
name|idi_vaddr
argument_list|,
name|rxqsizes
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|rxq
operator|->
name|ifr_ctx
operator|=
name|ctx
expr_stmt|;
name|rxq
operator|->
name|ifr_id
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|sctx
operator|->
name|isc_flags
operator|&
name|IFLIB_HAS_RXCQ
condition|)
block|{
name|rxq
operator|->
name|ifr_fl_offset
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rxq
operator|->
name|ifr_fl_offset
operator|=
literal|0
expr_stmt|;
block|}
name|rxq
operator|->
name|ifr_nfl
operator|=
name|nfree_lists
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|fl
operator|=
operator|(
name|iflib_fl_t
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iflib_fl
argument_list|)
operator|*
name|nfree_lists
argument_list|,
name|M_IFLIB
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to allocate free list memory\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_tx_desc
goto|;
block|}
name|rxq
operator|->
name|ifr_fl
operator|=
name|fl
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nfree_lists
condition|;
name|j
operator|++
control|)
block|{
name|fl
index|[
name|j
index|]
operator|.
name|ifl_rxq
operator|=
name|rxq
expr_stmt|;
name|fl
index|[
name|j
index|]
operator|.
name|ifl_id
operator|=
name|j
expr_stmt|;
name|fl
index|[
name|j
index|]
operator|.
name|ifl_ifdi
operator|=
operator|&
name|rxq
operator|->
name|ifr_ifdi
index|[
name|j
operator|+
name|rxq
operator|->
name|ifr_fl_offset
index|]
expr_stmt|;
name|fl
index|[
name|j
index|]
operator|.
name|ifl_rxd_size
operator|=
name|scctx
operator|->
name|isc_rxd_size
index|[
name|j
index|]
expr_stmt|;
block|}
comment|/* Allocate receive buffers for the ring*/
if|if
condition|(
name|iflib_rxsd_alloc
argument_list|(
name|rxq
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Critical Failure setting up receive buffers\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err_rx_desc
goto|;
block|}
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|fl
operator|=
name|rxq
operator|->
name|ifr_fl
init|;
name|j
operator|<
name|rxq
operator|->
name|ifr_nfl
condition|;
name|j
operator|++
operator|,
name|fl
operator|++
control|)
name|fl
operator|->
name|ifl_rx_bitmap
operator|=
name|bit_alloc
argument_list|(
name|fl
operator|->
name|ifl_size
argument_list|,
name|M_IFLIB
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
block|}
comment|/* TXQs */
name|vaddrs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|caddr_t
argument_list|)
operator|*
name|ntxqsets
operator|*
name|ntxqs
argument_list|,
name|M_IFLIB
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|paddrs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
name|ntxqsets
operator|*
name|ntxqs
argument_list|,
name|M_IFLIB
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntxqsets
condition|;
name|i
operator|++
control|)
block|{
name|iflib_dma_info_t
name|di
init|=
name|ctx
operator|->
name|ifc_txqs
index|[
name|i
index|]
operator|.
name|ift_ifdi
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ntxqs
condition|;
name|j
operator|++
operator|,
name|di
operator|++
control|)
block|{
name|vaddrs
index|[
name|i
operator|*
name|ntxqs
operator|+
name|j
index|]
operator|=
name|di
operator|->
name|idi_vaddr
expr_stmt|;
name|paddrs
index|[
name|i
operator|*
name|ntxqs
operator|+
name|j
index|]
operator|=
name|di
operator|->
name|idi_paddr
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|IFDI_TX_QUEUES_ALLOC
argument_list|(
name|ctx
argument_list|,
name|vaddrs
argument_list|,
name|paddrs
argument_list|,
name|ntxqs
argument_list|,
name|ntxqsets
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ctx
operator|->
name|ifc_dev
argument_list|,
literal|"device queue allocation failed\n"
argument_list|)
expr_stmt|;
name|iflib_tx_structures_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vaddrs
argument_list|,
name|M_IFLIB
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|paddrs
argument_list|,
name|M_IFLIB
argument_list|)
expr_stmt|;
goto|goto
name|err_rx_desc
goto|;
block|}
name|free
argument_list|(
name|vaddrs
argument_list|,
name|M_IFLIB
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|paddrs
argument_list|,
name|M_IFLIB
argument_list|)
expr_stmt|;
comment|/* RXQs */
name|vaddrs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|caddr_t
argument_list|)
operator|*
name|nrxqsets
operator|*
name|nrxqs
argument_list|,
name|M_IFLIB
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|paddrs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
name|nrxqsets
operator|*
name|nrxqs
argument_list|,
name|M_IFLIB
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrxqsets
condition|;
name|i
operator|++
control|)
block|{
name|iflib_dma_info_t
name|di
init|=
name|ctx
operator|->
name|ifc_rxqs
index|[
name|i
index|]
operator|.
name|ifr_ifdi
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nrxqs
condition|;
name|j
operator|++
operator|,
name|di
operator|++
control|)
block|{
name|vaddrs
index|[
name|i
operator|*
name|nrxqs
operator|+
name|j
index|]
operator|=
name|di
operator|->
name|idi_vaddr
expr_stmt|;
name|paddrs
index|[
name|i
operator|*
name|nrxqs
operator|+
name|j
index|]
operator|=
name|di
operator|->
name|idi_paddr
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|IFDI_RX_QUEUES_ALLOC
argument_list|(
name|ctx
argument_list|,
name|vaddrs
argument_list|,
name|paddrs
argument_list|,
name|nrxqs
argument_list|,
name|nrxqsets
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ctx
operator|->
name|ifc_dev
argument_list|,
literal|"device queue allocation failed\n"
argument_list|)
expr_stmt|;
name|iflib_tx_structures_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vaddrs
argument_list|,
name|M_IFLIB
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|paddrs
argument_list|,
name|M_IFLIB
argument_list|)
expr_stmt|;
goto|goto
name|err_rx_desc
goto|;
block|}
name|free
argument_list|(
name|vaddrs
argument_list|,
name|M_IFLIB
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|paddrs
argument_list|,
name|M_IFLIB
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* XXX handle allocation failure changes */
name|err_rx_desc
label|:
name|err_tx_desc
label|:
if|if
condition|(
name|ctx
operator|->
name|ifc_rxqs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ctx
operator|->
name|ifc_rxqs
argument_list|,
name|M_IFLIB
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ifc_rxqs
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ifc_txqs
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ctx
operator|->
name|ifc_txqs
argument_list|,
name|M_IFLIB
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ifc_txqs
operator|=
name|NULL
expr_stmt|;
name|rx_fail
label|:
if|if
condition|(
name|brscp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|brscp
argument_list|,
name|M_IFLIB
argument_list|)
expr_stmt|;
if|if
condition|(
name|rxq
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|rxq
argument_list|,
name|M_IFLIB
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|txq
argument_list|,
name|M_IFLIB
argument_list|)
expr_stmt|;
name|fail
label|:
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iflib_tx_structures_setup
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|iflib_txq_t
name|txq
init|=
name|ctx
operator|->
name|ifc_txqs
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTXQSETS
argument_list|(
name|ctx
argument_list|)
condition|;
name|i
operator|++
operator|,
name|txq
operator|++
control|)
name|iflib_txq_setup
argument_list|(
name|txq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iflib_tx_structures_free
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|iflib_txq_t
name|txq
init|=
name|ctx
operator|->
name|ifc_txqs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NTXQSETS
argument_list|(
name|ctx
argument_list|)
condition|;
name|i
operator|++
operator|,
name|txq
operator|++
control|)
block|{
name|iflib_txq_destroy
argument_list|(
name|txq
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ctx
operator|->
name|ifc_nhwtxqs
condition|;
name|j
operator|++
control|)
name|iflib_dma_free
argument_list|(
operator|&
name|txq
operator|->
name|ift_ifdi
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|ctx
operator|->
name|ifc_txqs
argument_list|,
name|M_IFLIB
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ifc_txqs
operator|=
name|NULL
expr_stmt|;
name|IFDI_QUEUES_FREE
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Initialize all receive rings.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|int
name|iflib_rx_structures_setup
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|iflib_rxq_t
name|rxq
init|=
name|ctx
operator|->
name|ifc_rxqs
decl_stmt|;
name|int
name|q
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|||
name|defined
argument_list|(
name|INET
argument_list|)
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
endif|#
directive|endif
for|for
control|(
name|q
operator|=
literal|0
init|;
name|q
operator|<
name|ctx
operator|->
name|ifc_softc_ctx
operator|.
name|isc_nrxqsets
condition|;
name|q
operator|++
operator|,
name|rxq
operator|++
control|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|||
name|defined
argument_list|(
name|INET
argument_list|)
name|tcp_lro_free
argument_list|(
operator|&
name|rxq
operator|->
name|ifr_lc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|tcp_lro_init_args
argument_list|(
operator|&
name|rxq
operator|->
name|ifr_lc
argument_list|,
name|ctx
operator|->
name|ifc_ifp
argument_list|,
name|TCP_LRO_ENTRIES
argument_list|,
name|min
argument_list|(
literal|1024
argument_list|,
name|ctx
operator|->
name|ifc_softc_ctx
operator|.
name|isc_nrxd
index|[
name|rxq
operator|->
name|ifr_fl_offset
index|]
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ctx
operator|->
name|ifc_dev
argument_list|,
literal|"LRO Initialization failed!\n"
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|rxq
operator|->
name|ifr_lro_enabled
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
name|IFDI_RXQ_SETUP
argument_list|(
name|ctx
argument_list|,
name|rxq
operator|->
name|ifr_id
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|||
name|defined
argument_list|(
name|INET
argument_list|)
name|fail
label|:
comment|/* 	 * Free RX software descriptors allocated so far, we will only handle 	 * the rings that completed, the failing case will have 	 * cleaned up for itself. 'q' failed, so its the terminus. 	 */
name|rxq
operator|=
name|ctx
operator|->
name|ifc_rxqs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|q
condition|;
operator|++
name|i
operator|,
name|rxq
operator|++
control|)
block|{
name|iflib_rx_sds_free
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
name|rxq
operator|->
name|ifr_cq_gen
operator|=
name|rxq
operator|->
name|ifr_cq_cidx
operator|=
name|rxq
operator|->
name|ifr_cq_pidx
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*********************************************************************  *  *  Free all receive rings.  *  **********************************************************************/
end_comment

begin_function
specifier|static
name|void
name|iflib_rx_structures_free
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|iflib_rxq_t
name|rxq
init|=
name|ctx
operator|->
name|ifc_rxqs
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ctx
operator|->
name|ifc_softc_ctx
operator|.
name|isc_nrxqsets
condition|;
name|i
operator|++
operator|,
name|rxq
operator|++
control|)
block|{
name|iflib_rx_sds_free
argument_list|(
name|rxq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|iflib_qset_structures_setup
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|iflib_tx_structures_setup
argument_list|(
name|ctx
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|iflib_rx_structures_setup
argument_list|(
name|ctx
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ctx
operator|->
name|ifc_dev
argument_list|,
literal|"iflib_rx_structures_setup failed: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|iflib_tx_structures_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|iflib_rx_structures_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|iflib_irq_alloc
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|if_irq_t
name|irq
parameter_list|,
name|int
name|rid
parameter_list|,
name|driver_filter_t
name|filter
parameter_list|,
name|void
modifier|*
name|filter_arg
parameter_list|,
name|driver_intr_t
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|_iflib_irq_alloc
argument_list|(
name|ctx
argument_list|,
name|irq
argument_list|,
name|rid
argument_list|,
name|filter
argument_list|,
name|handler
argument_list|,
name|arg
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_nth
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|cpuset_t
modifier|*
name|cpus
parameter_list|,
name|int
name|qid
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|cpuid
decl_stmt|,
name|eqid
decl_stmt|,
name|count
decl_stmt|;
name|CPU_COPY
argument_list|(
operator|&
name|ctx
operator|->
name|ifc_cpus
argument_list|,
name|cpus
argument_list|)
expr_stmt|;
name|count
operator|=
name|CPU_COUNT
argument_list|(
operator|&
name|ctx
operator|->
name|ifc_cpus
argument_list|)
expr_stmt|;
name|eqid
operator|=
name|qid
operator|%
name|count
expr_stmt|;
comment|/* clear up to the qid'th bit */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|eqid
condition|;
name|i
operator|++
control|)
block|{
name|cpuid
operator|=
name|CPU_FFS
argument_list|(
name|cpus
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|cpuid
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|CPU_CLR
argument_list|(
name|cpuid
operator|-
literal|1
argument_list|,
name|cpus
argument_list|)
expr_stmt|;
block|}
name|cpuid
operator|=
name|CPU_FFS
argument_list|(
name|cpus
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|cpuid
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|cpuid
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|iflib_irq_alloc_generic
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|if_irq_t
name|irq
parameter_list|,
name|int
name|rid
parameter_list|,
name|iflib_intr_type_t
name|type
parameter_list|,
name|driver_filter_t
modifier|*
name|filter
parameter_list|,
name|void
modifier|*
name|filter_arg
parameter_list|,
name|int
name|qid
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|grouptask
modifier|*
name|gtask
decl_stmt|;
name|struct
name|taskqgroup
modifier|*
name|tqg
decl_stmt|;
name|iflib_filter_info_t
name|info
decl_stmt|;
name|cpuset_t
name|cpus
decl_stmt|;
name|gtask_fn_t
modifier|*
name|fn
decl_stmt|;
name|int
name|tqrid
decl_stmt|,
name|err
decl_stmt|,
name|cpuid
decl_stmt|;
name|driver_filter_t
modifier|*
name|intr_fast
decl_stmt|;
name|void
modifier|*
name|q
decl_stmt|;
name|info
operator|=
operator|&
name|ctx
operator|->
name|ifc_filter_info
expr_stmt|;
name|tqrid
operator|=
name|rid
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
comment|/* XXX merge tx/rx for netmap? */
case|case
name|IFLIB_INTR_TX
case|:
name|q
operator|=
operator|&
name|ctx
operator|->
name|ifc_txqs
index|[
name|qid
index|]
expr_stmt|;
name|info
operator|=
operator|&
name|ctx
operator|->
name|ifc_txqs
index|[
name|qid
index|]
operator|.
name|ift_filter_info
expr_stmt|;
name|gtask
operator|=
operator|&
name|ctx
operator|->
name|ifc_txqs
index|[
name|qid
index|]
operator|.
name|ift_task
expr_stmt|;
name|tqg
operator|=
name|qgroup_if_io_tqg
expr_stmt|;
name|fn
operator|=
name|_task_fn_tx
expr_stmt|;
name|intr_fast
operator|=
name|iflib_fast_intr
expr_stmt|;
name|GROUPTASK_INIT
argument_list|(
name|gtask
argument_list|,
literal|0
argument_list|,
name|fn
argument_list|,
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
name|IFLIB_INTR_RX
case|:
name|q
operator|=
operator|&
name|ctx
operator|->
name|ifc_rxqs
index|[
name|qid
index|]
expr_stmt|;
name|info
operator|=
operator|&
name|ctx
operator|->
name|ifc_rxqs
index|[
name|qid
index|]
operator|.
name|ifr_filter_info
expr_stmt|;
name|gtask
operator|=
operator|&
name|ctx
operator|->
name|ifc_rxqs
index|[
name|qid
index|]
operator|.
name|ifr_task
expr_stmt|;
name|tqg
operator|=
name|qgroup_if_io_tqg
expr_stmt|;
name|fn
operator|=
name|_task_fn_rx
expr_stmt|;
name|intr_fast
operator|=
name|iflib_fast_intr
expr_stmt|;
name|GROUPTASK_INIT
argument_list|(
name|gtask
argument_list|,
literal|0
argument_list|,
name|fn
argument_list|,
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
name|IFLIB_INTR_RXTX
case|:
name|q
operator|=
operator|&
name|ctx
operator|->
name|ifc_rxqs
index|[
name|qid
index|]
expr_stmt|;
name|info
operator|=
operator|&
name|ctx
operator|->
name|ifc_rxqs
index|[
name|qid
index|]
operator|.
name|ifr_filter_info
expr_stmt|;
name|gtask
operator|=
operator|&
name|ctx
operator|->
name|ifc_rxqs
index|[
name|qid
index|]
operator|.
name|ifr_task
expr_stmt|;
name|tqg
operator|=
name|qgroup_if_io_tqg
expr_stmt|;
name|fn
operator|=
name|_task_fn_rx
expr_stmt|;
name|intr_fast
operator|=
name|iflib_fast_intr_rxtx
expr_stmt|;
name|GROUPTASK_INIT
argument_list|(
name|gtask
argument_list|,
literal|0
argument_list|,
name|fn
argument_list|,
name|q
argument_list|)
expr_stmt|;
break|break;
case|case
name|IFLIB_INTR_ADMIN
case|:
name|q
operator|=
name|ctx
expr_stmt|;
name|tqrid
operator|=
operator|-
literal|1
expr_stmt|;
name|info
operator|=
operator|&
name|ctx
operator|->
name|ifc_filter_info
expr_stmt|;
name|gtask
operator|=
operator|&
name|ctx
operator|->
name|ifc_admin_task
expr_stmt|;
name|tqg
operator|=
name|qgroup_if_config_tqg
expr_stmt|;
name|fn
operator|=
name|_task_fn_admin
expr_stmt|;
name|intr_fast
operator|=
name|iflib_fast_intr_ctx
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"unknown net intr type"
argument_list|)
expr_stmt|;
block|}
name|info
operator|->
name|ifi_filter
operator|=
name|filter
expr_stmt|;
name|info
operator|->
name|ifi_filter_arg
operator|=
name|filter_arg
expr_stmt|;
name|info
operator|->
name|ifi_task
operator|=
name|gtask
expr_stmt|;
name|info
operator|->
name|ifi_ctx
operator|=
name|q
expr_stmt|;
name|err
operator|=
name|_iflib_irq_alloc
argument_list|(
name|ctx
argument_list|,
name|irq
argument_list|,
name|rid
argument_list|,
name|intr_fast
argument_list|,
name|NULL
argument_list|,
name|info
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|ctx
operator|->
name|ifc_dev
argument_list|,
literal|"_iflib_irq_alloc failed %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|==
name|IFLIB_INTR_ADMIN
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|tqrid
operator|!=
operator|-
literal|1
condition|)
block|{
name|cpuid
operator|=
name|find_nth
argument_list|(
name|ctx
argument_list|,
operator|&
name|cpus
argument_list|,
name|qid
argument_list|)
expr_stmt|;
name|taskqgroup_attach_cpu
argument_list|(
name|tqg
argument_list|,
name|gtask
argument_list|,
name|q
argument_list|,
name|cpuid
argument_list|,
name|irq
operator|->
name|ii_rid
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|taskqgroup_attach
argument_list|(
name|tqg
argument_list|,
name|gtask
argument_list|,
name|q
argument_list|,
name|tqrid
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|iflib_softirq_alloc_generic
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|int
name|rid
parameter_list|,
name|iflib_intr_type_t
name|type
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|qid
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|grouptask
modifier|*
name|gtask
decl_stmt|;
name|struct
name|taskqgroup
modifier|*
name|tqg
decl_stmt|;
name|gtask_fn_t
modifier|*
name|fn
decl_stmt|;
name|void
modifier|*
name|q
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|IFLIB_INTR_TX
case|:
name|q
operator|=
operator|&
name|ctx
operator|->
name|ifc_txqs
index|[
name|qid
index|]
expr_stmt|;
name|gtask
operator|=
operator|&
name|ctx
operator|->
name|ifc_txqs
index|[
name|qid
index|]
operator|.
name|ift_task
expr_stmt|;
name|tqg
operator|=
name|qgroup_if_io_tqg
expr_stmt|;
name|fn
operator|=
name|_task_fn_tx
expr_stmt|;
break|break;
case|case
name|IFLIB_INTR_RX
case|:
name|q
operator|=
operator|&
name|ctx
operator|->
name|ifc_rxqs
index|[
name|qid
index|]
expr_stmt|;
name|gtask
operator|=
operator|&
name|ctx
operator|->
name|ifc_rxqs
index|[
name|qid
index|]
operator|.
name|ifr_task
expr_stmt|;
name|tqg
operator|=
name|qgroup_if_io_tqg
expr_stmt|;
name|fn
operator|=
name|_task_fn_rx
expr_stmt|;
break|break;
case|case
name|IFLIB_INTR_IOV
case|:
name|q
operator|=
name|ctx
expr_stmt|;
name|gtask
operator|=
operator|&
name|ctx
operator|->
name|ifc_vflr_task
expr_stmt|;
name|tqg
operator|=
name|qgroup_if_config_tqg
expr_stmt|;
name|rid
operator|=
operator|-
literal|1
expr_stmt|;
name|fn
operator|=
name|_task_fn_iov
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"unknown net intr type"
argument_list|)
expr_stmt|;
block|}
name|GROUPTASK_INIT
argument_list|(
name|gtask
argument_list|,
literal|0
argument_list|,
name|fn
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|taskqgroup_attach
argument_list|(
name|tqg
argument_list|,
name|gtask
argument_list|,
name|q
argument_list|,
name|rid
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iflib_irq_free
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|if_irq_t
name|irq
parameter_list|)
block|{
if|if
condition|(
name|irq
operator|->
name|ii_tag
condition|)
name|bus_teardown_intr
argument_list|(
name|ctx
operator|->
name|ifc_dev
argument_list|,
name|irq
operator|->
name|ii_res
argument_list|,
name|irq
operator|->
name|ii_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|irq
operator|->
name|ii_res
condition|)
name|bus_release_resource
argument_list|(
name|ctx
operator|->
name|ifc_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
name|irq
operator|->
name|ii_rid
argument_list|,
name|irq
operator|->
name|ii_res
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iflib_legacy_setup
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|driver_filter_t
name|filter
parameter_list|,
name|void
modifier|*
name|filter_arg
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|iflib_txq_t
name|txq
init|=
name|ctx
operator|->
name|ifc_txqs
decl_stmt|;
name|iflib_rxq_t
name|rxq
init|=
name|ctx
operator|->
name|ifc_rxqs
decl_stmt|;
name|if_irq_t
name|irq
init|=
operator|&
name|ctx
operator|->
name|ifc_legacy_irq
decl_stmt|;
name|iflib_filter_info_t
name|info
decl_stmt|;
name|struct
name|grouptask
modifier|*
name|gtask
decl_stmt|;
name|struct
name|taskqgroup
modifier|*
name|tqg
decl_stmt|;
name|gtask_fn_t
modifier|*
name|fn
decl_stmt|;
name|int
name|tqrid
decl_stmt|;
name|void
modifier|*
name|q
decl_stmt|;
name|int
name|err
decl_stmt|;
name|q
operator|=
operator|&
name|ctx
operator|->
name|ifc_rxqs
index|[
literal|0
index|]
expr_stmt|;
name|info
operator|=
operator|&
name|rxq
index|[
literal|0
index|]
operator|.
name|ifr_filter_info
expr_stmt|;
name|gtask
operator|=
operator|&
name|rxq
index|[
literal|0
index|]
operator|.
name|ifr_task
expr_stmt|;
name|tqg
operator|=
name|qgroup_if_io_tqg
expr_stmt|;
name|tqrid
operator|=
name|irq
operator|->
name|ii_rid
operator|=
operator|*
name|rid
expr_stmt|;
name|fn
operator|=
name|_task_fn_rx
expr_stmt|;
name|ctx
operator|->
name|ifc_flags
operator||=
name|IFC_LEGACY
expr_stmt|;
name|info
operator|->
name|ifi_filter
operator|=
name|filter
expr_stmt|;
name|info
operator|->
name|ifi_filter_arg
operator|=
name|filter_arg
expr_stmt|;
name|info
operator|->
name|ifi_task
operator|=
name|gtask
expr_stmt|;
name|info
operator|->
name|ifi_ctx
operator|=
name|ctx
expr_stmt|;
comment|/* We allocate a single interrupt resource */
if|if
condition|(
operator|(
name|err
operator|=
name|_iflib_irq_alloc
argument_list|(
name|ctx
argument_list|,
name|irq
argument_list|,
name|tqrid
argument_list|,
name|iflib_fast_intr_ctx
argument_list|,
name|NULL
argument_list|,
name|info
argument_list|,
name|name
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|GROUPTASK_INIT
argument_list|(
name|gtask
argument_list|,
literal|0
argument_list|,
name|fn
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|taskqgroup_attach
argument_list|(
name|tqg
argument_list|,
name|gtask
argument_list|,
name|q
argument_list|,
name|tqrid
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|GROUPTASK_INIT
argument_list|(
operator|&
name|txq
operator|->
name|ift_task
argument_list|,
literal|0
argument_list|,
name|_task_fn_tx
argument_list|,
name|txq
argument_list|)
expr_stmt|;
name|taskqgroup_attach
argument_list|(
name|qgroup_if_io_tqg
argument_list|,
operator|&
name|txq
operator|->
name|ift_task
argument_list|,
name|txq
argument_list|,
name|tqrid
argument_list|,
literal|"tx"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|iflib_led_create
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|ctx
operator|->
name|ifc_led_dev
operator|=
name|led_create
argument_list|(
name|iflib_led_func
argument_list|,
name|ctx
argument_list|,
name|device_get_nameunit
argument_list|(
name|ctx
operator|->
name|ifc_dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iflib_tx_intr_deferred
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|int
name|txqid
parameter_list|)
block|{
name|GROUPTASK_ENQUEUE
argument_list|(
operator|&
name|ctx
operator|->
name|ifc_txqs
index|[
name|txqid
index|]
operator|.
name|ift_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iflib_rx_intr_deferred
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|int
name|rxqid
parameter_list|)
block|{
name|GROUPTASK_ENQUEUE
argument_list|(
operator|&
name|ctx
operator|->
name|ifc_rxqs
index|[
name|rxqid
index|]
operator|.
name|ifr_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iflib_admin_intr_deferred
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|grouptask
modifier|*
name|gtask
decl_stmt|;
name|gtask
operator|=
operator|&
name|ctx
operator|->
name|ifc_admin_task
expr_stmt|;
name|MPASS
argument_list|(
name|gtask
operator|->
name|gt_taskqueue
operator|!=
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|GROUPTASK_ENQUEUE
argument_list|(
operator|&
name|ctx
operator|->
name|ifc_admin_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iflib_iov_intr_deferred
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|GROUPTASK_ENQUEUE
argument_list|(
operator|&
name|ctx
operator|->
name|ifc_vflr_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iflib_io_tqg_attach
parameter_list|(
name|struct
name|grouptask
modifier|*
name|gt
parameter_list|,
name|void
modifier|*
name|uniq
parameter_list|,
name|int
name|cpu
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|taskqgroup_attach_cpu
argument_list|(
name|qgroup_if_io_tqg
argument_list|,
name|gt
argument_list|,
name|uniq
argument_list|,
name|cpu
argument_list|,
operator|-
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iflib_config_gtask_init
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|struct
name|grouptask
modifier|*
name|gtask
parameter_list|,
name|gtask_fn_t
modifier|*
name|fn
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|GROUPTASK_INIT
argument_list|(
name|gtask
argument_list|,
literal|0
argument_list|,
name|fn
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|taskqgroup_attach
argument_list|(
name|qgroup_if_config_tqg
argument_list|,
name|gtask
argument_list|,
name|gtask
argument_list|,
operator|-
literal|1
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iflib_config_gtask_deinit
parameter_list|(
name|struct
name|grouptask
modifier|*
name|gtask
parameter_list|)
block|{
name|taskqgroup_detach
argument_list|(
name|qgroup_if_config_tqg
argument_list|,
name|gtask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|iflib_link_state_change
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|int
name|link_state
parameter_list|,
name|uint64_t
name|baudrate
parameter_list|)
block|{
name|if_t
name|ifp
init|=
name|ctx
operator|->
name|ifc_ifp
decl_stmt|;
name|iflib_txq_t
name|txq
init|=
name|ctx
operator|->
name|ifc_txqs
decl_stmt|;
name|if_setbaudrate
argument_list|(
name|ifp
argument_list|,
name|baudrate
argument_list|)
expr_stmt|;
if|if
condition|(
name|baudrate
operator|>=
name|IF_Gbps
argument_list|(
literal|10
argument_list|)
condition|)
name|ctx
operator|->
name|ifc_flags
operator||=
name|IFC_PREFETCH
expr_stmt|;
comment|/* If link down, disable watchdog */
if|if
condition|(
operator|(
name|ctx
operator|->
name|ifc_link_state
operator|==
name|LINK_STATE_UP
operator|)
operator|&&
operator|(
name|link_state
operator|==
name|LINK_STATE_DOWN
operator|)
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|ctx
operator|->
name|ifc_softc_ctx
operator|.
name|isc_ntxqsets
condition|;
name|i
operator|++
operator|,
name|txq
operator|++
control|)
name|txq
operator|->
name|ift_qstatus
operator|=
name|IFLIB_QUEUE_IDLE
expr_stmt|;
block|}
name|ctx
operator|->
name|ifc_link_state
operator|=
name|link_state
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|link_state
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iflib_tx_credits_update
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|iflib_txq_t
name|txq
parameter_list|)
block|{
name|int
name|credits
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|int
name|credits_pre
init|=
name|txq
operator|->
name|ift_cidx_processed
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ctx
operator|->
name|isc_txd_credits_update
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|credits
operator|=
name|ctx
operator|->
name|isc_txd_credits_update
argument_list|(
name|ctx
operator|->
name|ifc_softc
argument_list|,
name|txq
operator|->
name|ift_id
argument_list|,
name|true
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|txq
operator|->
name|ift_processed
operator|+=
name|credits
expr_stmt|;
name|txq
operator|->
name|ift_cidx_processed
operator|+=
name|credits
expr_stmt|;
name|MPASS
argument_list|(
name|credits_pre
operator|+
name|credits
operator|==
name|txq
operator|->
name|ift_cidx_processed
argument_list|)
expr_stmt|;
if|if
condition|(
name|txq
operator|->
name|ift_cidx_processed
operator|>=
name|txq
operator|->
name|ift_size
condition|)
name|txq
operator|->
name|ift_cidx_processed
operator|-=
name|txq
operator|->
name|ift_size
expr_stmt|;
return|return
operator|(
name|credits
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iflib_rxd_avail
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
name|iflib_rxq_t
name|rxq
parameter_list|,
name|qidx_t
name|cidx
parameter_list|,
name|qidx_t
name|budget
parameter_list|)
block|{
return|return
operator|(
name|ctx
operator|->
name|isc_rxd_available
argument_list|(
name|ctx
operator|->
name|ifc_softc
argument_list|,
name|rxq
operator|->
name|ifr_id
argument_list|,
name|cidx
argument_list|,
name|budget
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|iflib_add_int_delay_sysctl
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|description
parameter_list|,
name|if_int_delay_info_t
name|info
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|info
operator|->
name|iidi_ctx
operator|=
name|ctx
expr_stmt|;
name|info
operator|->
name|iidi_offset
operator|=
name|offset
expr_stmt|;
name|info
operator|->
name|iidi_value
operator|=
name|value
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|device_get_sysctl_ctx
argument_list|(
name|ctx
operator|->
name|ifc_dev
argument_list|)
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|ctx
operator|->
name|ifc_dev
argument_list|)
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|name
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|info
argument_list|,
literal|0
argument_list|,
name|iflib_sysctl_int_delay
argument_list|,
literal|"I"
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|mtx
modifier|*
name|iflib_ctx_lock_get
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
return|return
operator|(
operator|&
name|ctx
operator|->
name|ifc_mtx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iflib_msix_init
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|ctx
operator|->
name|ifc_dev
decl_stmt|;
name|if_shared_ctx_t
name|sctx
init|=
name|ctx
operator|->
name|ifc_sctx
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
operator|&
name|ctx
operator|->
name|ifc_softc_ctx
decl_stmt|;
name|int
name|vectors
decl_stmt|,
name|queues
decl_stmt|,
name|rx_queues
decl_stmt|,
name|tx_queues
decl_stmt|,
name|queuemsgs
decl_stmt|,
name|msgs
decl_stmt|;
name|int
name|iflib_num_tx_queues
decl_stmt|,
name|iflib_num_rx_queues
decl_stmt|;
name|int
name|err
decl_stmt|,
name|admincnt
decl_stmt|,
name|bar
decl_stmt|;
name|iflib_num_tx_queues
operator|=
name|scctx
operator|->
name|isc_ntxqsets
expr_stmt|;
name|iflib_num_rx_queues
operator|=
name|scctx
operator|->
name|isc_nrxqsets
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"msix_init qsets capped at %d\n"
argument_list|,
name|iflib_num_tx_queues
argument_list|)
expr_stmt|;
name|bar
operator|=
name|ctx
operator|->
name|ifc_softc_ctx
operator|.
name|isc_msix_bar
expr_stmt|;
name|admincnt
operator|=
name|sctx
operator|->
name|isc_admin_intrcnt
expr_stmt|;
comment|/* Override by tuneable */
if|if
condition|(
name|scctx
operator|->
name|isc_disable_msix
condition|)
goto|goto
name|msi
goto|;
comment|/* 	** When used in a virtualized environment 	** PCI BUSMASTER capability may not be set 	** so explicity set it here and rewrite 	** the ENABLE in the MSIX control register 	** at this point to cause the host to 	** successfully initialize us. 	*/
block|{
name|int
name|msix_ctrl
decl_stmt|,
name|rid
decl_stmt|;
name|pci_enable_busmaster
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pci_find_cap
argument_list|(
name|dev
argument_list|,
name|PCIY_MSIX
argument_list|,
operator|&
name|rid
argument_list|)
operator|==
literal|0
operator|&&
name|rid
operator|!=
literal|0
condition|)
block|{
name|rid
operator|+=
name|PCIR_MSIX_CTRL
expr_stmt|;
name|msix_ctrl
operator|=
name|pci_read_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|msix_ctrl
operator||=
name|PCIM_MSIXCTRL_MSIX_ENABLE
expr_stmt|;
name|pci_write_config
argument_list|(
name|dev
argument_list|,
name|rid
argument_list|,
name|msix_ctrl
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"PCIY_MSIX capability not found; "
literal|"or rid %d == 0.\n"
argument_list|,
name|rid
argument_list|)
expr_stmt|;
goto|goto
name|msi
goto|;
block|}
block|}
comment|/* 	 * bar == -1 => "trust me I know what I'm doing" 	 * Some drivers are for hardware that is so shoddily 	 * documented that no one knows which bars are which 	 * so the developer has to map all bars. This hack 	 * allows shoddy garbage to use msix in this framework. 	 */
if|if
condition|(
name|bar
operator|!=
operator|-
literal|1
condition|)
block|{
name|ctx
operator|->
name|ifc_msix_mem
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|bar
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ifc_msix_mem
operator|==
name|NULL
condition|)
block|{
comment|/* May not be enabled */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to map MSIX table \n"
argument_list|)
expr_stmt|;
goto|goto
name|msi
goto|;
block|}
block|}
comment|/* First try MSI/X */
if|if
condition|(
operator|(
name|msgs
operator|=
name|pci_msix_count
argument_list|(
name|dev
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* system has msix disabled */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"System has MSIX disabled \n"
argument_list|)
expr_stmt|;
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|bar
argument_list|,
name|ctx
operator|->
name|ifc_msix_mem
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ifc_msix_mem
operator|=
name|NULL
expr_stmt|;
goto|goto
name|msi
goto|;
block|}
if|#
directive|if
name|IFLIB_DEBUG
comment|/* use only 1 qset in debug mode */
name|queuemsgs
operator|=
name|min
argument_list|(
name|msgs
operator|-
name|admincnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
name|queuemsgs
operator|=
name|msgs
operator|-
name|admincnt
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bus_get_cpus
argument_list|(
name|dev
argument_list|,
name|INTR_CPUS
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|ifc_cpus
argument_list|)
argument_list|,
operator|&
name|ctx
operator|->
name|ifc_cpus
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|RSS
name|queues
operator|=
name|imin
argument_list|(
name|queuemsgs
argument_list|,
name|rss_getnumbuckets
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
name|queues
operator|=
name|queuemsgs
expr_stmt|;
endif|#
directive|endif
name|queues
operator|=
name|imin
argument_list|(
name|CPU_COUNT
argument_list|(
operator|&
name|ctx
operator|->
name|ifc_cpus
argument_list|)
argument_list|,
name|queues
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"pxm cpus: %d queue msgs: %d admincnt: %d\n"
argument_list|,
name|CPU_COUNT
argument_list|(
operator|&
name|ctx
operator|->
name|ifc_cpus
argument_list|)
argument_list|,
name|queuemsgs
argument_list|,
name|admincnt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Unable to fetch CPU list\n"
argument_list|)
expr_stmt|;
comment|/* Figure out a reasonable auto config value */
name|queues
operator|=
name|min
argument_list|(
name|queuemsgs
argument_list|,
name|mp_ncpus
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|RSS
comment|/* If we're doing RSS, clamp at the number of RSS buckets */
if|if
condition|(
name|queues
operator|>
name|rss_getnumbuckets
argument_list|()
condition|)
name|queues
operator|=
name|rss_getnumbuckets
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|iflib_num_rx_queues
operator|>
literal|0
operator|&&
name|iflib_num_rx_queues
operator|<
name|queuemsgs
operator|-
name|admincnt
condition|)
name|rx_queues
operator|=
name|iflib_num_rx_queues
expr_stmt|;
else|else
name|rx_queues
operator|=
name|queues
expr_stmt|;
comment|/* 	 * We want this to be all logical CPUs by default 	 */
if|if
condition|(
name|iflib_num_tx_queues
operator|>
literal|0
operator|&&
name|iflib_num_tx_queues
operator|<
name|queues
condition|)
name|tx_queues
operator|=
name|iflib_num_tx_queues
expr_stmt|;
else|else
name|tx_queues
operator|=
name|mp_ncpus
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ifc_sysctl_qs_eq_override
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|tx_queues
operator|!=
name|rx_queues
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"queue equality override not set, capping rx_queues at %d and tx_queues at %d\n"
argument_list|,
name|min
argument_list|(
name|rx_queues
argument_list|,
name|tx_queues
argument_list|)
argument_list|,
name|min
argument_list|(
name|rx_queues
argument_list|,
name|tx_queues
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tx_queues
operator|=
name|min
argument_list|(
name|rx_queues
argument_list|,
name|tx_queues
argument_list|)
expr_stmt|;
name|rx_queues
operator|=
name|min
argument_list|(
name|rx_queues
argument_list|,
name|tx_queues
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"using %d rx queues %d tx queues \n"
argument_list|,
name|rx_queues
argument_list|,
name|tx_queues
argument_list|)
expr_stmt|;
name|vectors
operator|=
name|rx_queues
operator|+
name|admincnt
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|pci_alloc_msix
argument_list|(
name|dev
argument_list|,
operator|&
name|vectors
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Using MSIX interrupts with %d vectors\n"
argument_list|,
name|vectors
argument_list|)
expr_stmt|;
name|scctx
operator|->
name|isc_vectors
operator|=
name|vectors
expr_stmt|;
name|scctx
operator|->
name|isc_nrxqsets
operator|=
name|rx_queues
expr_stmt|;
name|scctx
operator|->
name|isc_ntxqsets
operator|=
name|tx_queues
expr_stmt|;
name|scctx
operator|->
name|isc_intr
operator|=
name|IFLIB_INTR_MSIX
expr_stmt|;
return|return
operator|(
name|vectors
operator|)
return|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate %d msix vectors, err: %d - using MSI\n"
argument_list|,
name|vectors
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
name|msi
label|:
name|vectors
operator|=
name|pci_msi_count
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|scctx
operator|->
name|isc_nrxqsets
operator|=
literal|1
expr_stmt|;
name|scctx
operator|->
name|isc_ntxqsets
operator|=
literal|1
expr_stmt|;
name|scctx
operator|->
name|isc_vectors
operator|=
name|vectors
expr_stmt|;
if|if
condition|(
name|vectors
operator|==
literal|1
operator|&&
name|pci_alloc_msi
argument_list|(
name|dev
argument_list|,
operator|&
name|vectors
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Using an MSI interrupt\n"
argument_list|)
expr_stmt|;
name|scctx
operator|->
name|isc_intr
operator|=
name|IFLIB_INTR_MSI
expr_stmt|;
block|}
else|else
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Using a Legacy interrupt\n"
argument_list|)
expr_stmt|;
name|scctx
operator|->
name|isc_intr
operator|=
name|IFLIB_INTR_LEGACY
expr_stmt|;
block|}
return|return
operator|(
name|vectors
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|char
modifier|*
name|ring_states
index|[]
init|=
block|{
literal|"IDLE"
block|,
literal|"BUSY"
block|,
literal|"STALLED"
block|,
literal|"ABDICATED"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|mp_ring_state_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|uint16_t
modifier|*
name|state
init|=
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|oidp
operator|->
name|oid_arg1
operator|)
decl_stmt|;
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|char
modifier|*
name|ring_state
init|=
literal|"UNKNOWN"
decl_stmt|;
comment|/* XXX needed ? */
name|rc
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|rc
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
return|return
operator|(
name|rc
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|80
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|MPASS
argument_list|(
name|sb
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|state
index|[
literal|3
index|]
operator|<=
literal|3
condition|)
name|ring_state
operator|=
name|ring_states
index|[
name|state
index|[
literal|3
index|]
index|]
expr_stmt|;
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"pidx_head: %04hd pidx_tail: %04hd cidx: %04hd state: %s"
argument_list|,
name|state
index|[
literal|0
index|]
argument_list|,
name|state
index|[
literal|1
index|]
argument_list|,
name|state
index|[
literal|2
index|]
argument_list|,
name|ring_state
argument_list|)
expr_stmt|;
name|rc
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_enum
enum|enum
name|iflib_ndesc_handler
block|{
name|IFLIB_NTXD_HANDLER
block|,
name|IFLIB_NRXD_HANDLER
block|, }
enum|;
end_enum

begin_function
specifier|static
name|int
name|mp_ndesc_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|if_ctx_t
name|ctx
init|=
operator|(
name|void
operator|*
operator|)
name|arg1
decl_stmt|;
name|enum
name|iflib_ndesc_handler
name|type
init|=
name|arg2
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|qidx_t
modifier|*
name|ndesc
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|nqs
decl_stmt|,
name|rc
decl_stmt|,
name|i
decl_stmt|;
name|MPASS
argument_list|(
name|type
operator|==
name|IFLIB_NTXD_HANDLER
operator|||
name|type
operator|==
name|IFLIB_NRXD_HANDLER
argument_list|)
expr_stmt|;
name|nqs
operator|=
literal|8
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|IFLIB_NTXD_HANDLER
case|:
name|ndesc
operator|=
name|ctx
operator|->
name|ifc_sysctl_ntxds
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ifc_sctx
condition|)
name|nqs
operator|=
name|ctx
operator|->
name|ifc_sctx
operator|->
name|isc_ntxqs
expr_stmt|;
break|break;
case|case
name|IFLIB_NRXD_HANDLER
case|:
name|ndesc
operator|=
name|ctx
operator|->
name|ifc_sysctl_nrxds
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|ifc_sctx
condition|)
name|nqs
operator|=
name|ctx
operator|->
name|ifc_sctx
operator|->
name|isc_nrxqs
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nqs
operator|==
literal|0
condition|)
name|nqs
operator|=
literal|8
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|nqs
condition|)
break|break;
if|if
condition|(
name|i
condition|)
name|strcat
argument_list|(
name|buf
argument_list|,
literal|","
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|strchr
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|ndesc
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|rc
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
name|rc
return|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|next
operator|=
name|buf
operator|,
name|p
operator|=
name|strsep
argument_list|(
operator|&
name|next
argument_list|,
literal|" ,"
argument_list|)
init|;
name|i
operator|<
literal|8
operator|&&
name|p
condition|;
name|i
operator|++
operator|,
name|p
operator|=
name|strsep
argument_list|(
operator|&
name|next
argument_list|,
literal|" ,"
argument_list|)
control|)
block|{
name|ndesc
index|[
name|i
index|]
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NAME_BUFLEN
value|32
end_define

begin_function
specifier|static
name|void
name|iflib_add_device_sysctl_pre
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|device_t
name|dev
init|=
name|iflib_get_dev
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
decl_stmt|,
modifier|*
name|oid_list
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx_list
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|node
decl_stmt|;
name|ctx_list
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|device_get_sysctl_tree
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|ifc_sysctl_node
operator|=
name|node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx_list
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
literal|"iflib"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"IFLIB fields"
argument_list|)
expr_stmt|;
name|oid_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
name|ctx_list
argument_list|,
name|oid_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"driver_version"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|ctx
operator|->
name|ifc_sctx
operator|->
name|isc_driver_version
argument_list|,
literal|0
argument_list|,
literal|"driver version"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U16
argument_list|(
name|ctx_list
argument_list|,
name|oid_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"override_ntxqs"
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|ctx
operator|->
name|ifc_sysctl_ntxqs
argument_list|,
literal|0
argument_list|,
literal|"# of txqs to use, 0 => use default #"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U16
argument_list|(
name|ctx_list
argument_list|,
name|oid_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"override_nrxqs"
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|ctx
operator|->
name|ifc_sysctl_nrxqs
argument_list|,
literal|0
argument_list|,
literal|"# of rxqs to use, 0 => use default #"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U16
argument_list|(
name|ctx_list
argument_list|,
name|oid_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"override_qs_enable"
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|ctx
operator|->
name|ifc_sysctl_qs_eq_override
argument_list|,
literal|0
argument_list|,
literal|"permit #txq != #rxq"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx_list
argument_list|,
name|oid_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"disable_msix"
argument_list|,
name|CTLFLAG_RWTUN
argument_list|,
operator|&
name|ctx
operator|->
name|ifc_softc_ctx
operator|.
name|isc_disable_msix
argument_list|,
literal|0
argument_list|,
literal|"disable MSIX (default 0)"
argument_list|)
expr_stmt|;
comment|/* XXX change for per-queue sizes */
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx_list
argument_list|,
name|oid_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"override_ntxds"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RWTUN
argument_list|,
name|ctx
argument_list|,
name|IFLIB_NTXD_HANDLER
argument_list|,
name|mp_ndesc_handler
argument_list|,
literal|"A"
argument_list|,
literal|"list of # of tx descriptors to use, 0 = use default #"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx_list
argument_list|,
name|oid_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"override_nrxds"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RWTUN
argument_list|,
name|ctx
argument_list|,
name|IFLIB_NRXD_HANDLER
argument_list|,
name|mp_ndesc_handler
argument_list|,
literal|"A"
argument_list|,
literal|"list of # of rx descriptors to use, 0 = use default #"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|iflib_add_device_sysctl_post
parameter_list|(
name|if_ctx_t
name|ctx
parameter_list|)
block|{
name|if_shared_ctx_t
name|sctx
init|=
name|ctx
operator|->
name|ifc_sctx
decl_stmt|;
name|if_softc_ctx_t
name|scctx
init|=
operator|&
name|ctx
operator|->
name|ifc_softc_ctx
decl_stmt|;
name|device_t
name|dev
init|=
name|iflib_get_dev
argument_list|(
name|ctx
argument_list|)
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|child
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx_list
decl_stmt|;
name|iflib_fl_t
name|fl
decl_stmt|;
name|iflib_txq_t
name|txq
decl_stmt|;
name|iflib_rxq_t
name|rxq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|namebuf
index|[
name|NAME_BUFLEN
index|]
decl_stmt|;
name|char
modifier|*
name|qfmt
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|queue_node
decl_stmt|,
modifier|*
name|fl_node
decl_stmt|,
modifier|*
name|node
decl_stmt|;
name|struct
name|sysctl_oid_list
modifier|*
name|queue_list
decl_stmt|,
modifier|*
name|fl_list
decl_stmt|;
name|ctx_list
operator|=
name|device_get_sysctl_ctx
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|node
operator|=
name|ctx
operator|->
name|ifc_sysctl_node
expr_stmt|;
name|child
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|scctx
operator|->
name|isc_ntxqsets
operator|>
literal|100
condition|)
name|qfmt
operator|=
literal|"txq%03d"
expr_stmt|;
elseif|else
if|if
condition|(
name|scctx
operator|->
name|isc_ntxqsets
operator|>
literal|10
condition|)
name|qfmt
operator|=
literal|"txq%02d"
expr_stmt|;
else|else
name|qfmt
operator|=
literal|"txq%d"
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|txq
operator|=
name|ctx
operator|->
name|ifc_txqs
init|;
name|i
operator|<
name|scctx
operator|->
name|isc_ntxqsets
condition|;
name|i
operator|++
operator|,
name|txq
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|namebuf
argument_list|,
name|NAME_BUFLEN
argument_list|,
name|qfmt
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|queue_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx_list
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
name|namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Queue Name"
argument_list|)
expr_stmt|;
name|queue_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|queue_node
argument_list|)
expr_stmt|;
if|#
directive|if
name|MEMORY_LOGGING
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txq_dequeued"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|ift_dequeued
argument_list|,
literal|"total mbufs freed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txq_enqueued"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|ift_enqueued
argument_list|,
literal|"total mbufs enqueued"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_defrag"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|ift_mbuf_defrag
argument_list|,
literal|"# of times m_defrag was called"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"m_pullups"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|ift_pullups
argument_list|,
literal|"# of times m_pullup was called"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"mbuf_defrag_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|ift_mbuf_defrag_failed
argument_list|,
literal|"# of times m_defrag failed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"no_desc_avail"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|ift_no_desc_avail
argument_list|,
literal|"# of times no descriptors were available"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"tx_map_failed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|ift_map_failed
argument_list|,
literal|"# of times dma map failed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txd_encap_efbig"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|ift_txd_encap_efbig
argument_list|,
literal|"# of times txd_encap returned EFBIG"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"no_tx_dma_setup"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|ift_no_tx_dma_setup
argument_list|,
literal|"# of times map failed for other than EFBIG"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U16
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txq_pidx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|ift_pidx
argument_list|,
literal|1
argument_list|,
literal|"Producer Index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U16
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txq_cidx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|ift_cidx
argument_list|,
literal|1
argument_list|,
literal|"Consumer Index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U16
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txq_cidx_processed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|ift_cidx_processed
argument_list|,
literal|1
argument_list|,
literal|"Consumer Index seen by credit update"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U16
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txq_in_use"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|ift_in_use
argument_list|,
literal|1
argument_list|,
literal|"descriptors in use"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txq_processed"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|ift_processed
argument_list|,
literal|"descriptors procesed for clean"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"txq_cleaned"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|ift_cleaned
argument_list|,
literal|"total cleaned"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ring_state"
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|__DEVOLATILE
argument_list|(
name|uint64_t
operator|*
argument_list|,
operator|&
name|txq
operator|->
name|ift_br
operator|->
name|state
argument_list|)
argument_list|,
literal|0
argument_list|,
name|mp_ring_state_handler
argument_list|,
literal|"A"
argument_list|,
literal|"soft ring state"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_COUNTER_U64
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"r_enqueues"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|ift_br
operator|->
name|enqueues
argument_list|,
literal|"# of enqueues to the mp_ring for this queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_COUNTER_U64
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"r_drops"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|ift_br
operator|->
name|drops
argument_list|,
literal|"# of drops in the mp_ring for this queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_COUNTER_U64
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"r_starts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|ift_br
operator|->
name|starts
argument_list|,
literal|"# of normal consumer starts in the mp_ring for this queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_COUNTER_U64
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"r_stalls"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|ift_br
operator|->
name|stalls
argument_list|,
literal|"# of consumer stalls in the mp_ring for this queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_COUNTER_U64
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"r_restarts"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|ift_br
operator|->
name|restarts
argument_list|,
literal|"# of consumer restarts in the mp_ring for this queue"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_COUNTER_U64
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"r_abdications"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|txq
operator|->
name|ift_br
operator|->
name|abdications
argument_list|,
literal|"# of consumer abdications in the mp_ring for this queue"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|scctx
operator|->
name|isc_nrxqsets
operator|>
literal|100
condition|)
name|qfmt
operator|=
literal|"rxq%03d"
expr_stmt|;
elseif|else
if|if
condition|(
name|scctx
operator|->
name|isc_nrxqsets
operator|>
literal|10
condition|)
name|qfmt
operator|=
literal|"rxq%02d"
expr_stmt|;
else|else
name|qfmt
operator|=
literal|"rxq%d"
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|rxq
operator|=
name|ctx
operator|->
name|ifc_rxqs
init|;
name|i
operator|<
name|scctx
operator|->
name|isc_nrxqsets
condition|;
name|i
operator|++
operator|,
name|rxq
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|namebuf
argument_list|,
name|NAME_BUFLEN
argument_list|,
name|qfmt
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|queue_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx_list
argument_list|,
name|child
argument_list|,
name|OID_AUTO
argument_list|,
name|namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"Queue Name"
argument_list|)
expr_stmt|;
name|queue_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|queue_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctx
operator|->
name|isc_flags
operator|&
name|IFLIB_HAS_RXCQ
condition|)
block|{
name|SYSCTL_ADD_U16
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxq_cq_pidx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxq
operator|->
name|ifr_cq_pidx
argument_list|,
literal|1
argument_list|,
literal|"Producer Index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U16
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"rxq_cq_cidx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rxq
operator|->
name|ifr_cq_cidx
argument_list|,
literal|1
argument_list|,
literal|"Consumer Index"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|fl
operator|=
name|rxq
operator|->
name|ifr_fl
init|;
name|j
operator|<
name|rxq
operator|->
name|ifr_nfl
condition|;
name|j
operator|++
operator|,
name|fl
operator|++
control|)
block|{
name|snprintf
argument_list|(
name|namebuf
argument_list|,
name|NAME_BUFLEN
argument_list|,
literal|"rxq_fl%d"
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|fl_node
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx_list
argument_list|,
name|queue_list
argument_list|,
name|OID_AUTO
argument_list|,
name|namebuf
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|"freelist Name"
argument_list|)
expr_stmt|;
name|fl_list
operator|=
name|SYSCTL_CHILDREN
argument_list|(
name|fl_node
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U16
argument_list|(
name|ctx_list
argument_list|,
name|fl_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"pidx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fl
operator|->
name|ifl_pidx
argument_list|,
literal|1
argument_list|,
literal|"Producer Index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U16
argument_list|(
name|ctx_list
argument_list|,
name|fl_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"cidx"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fl
operator|->
name|ifl_cidx
argument_list|,
literal|1
argument_list|,
literal|"Consumer Index"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_U16
argument_list|(
name|ctx_list
argument_list|,
name|fl_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"credits"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fl
operator|->
name|ifl_credits
argument_list|,
literal|1
argument_list|,
literal|"credits available"
argument_list|)
expr_stmt|;
if|#
directive|if
name|MEMORY_LOGGING
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx_list
argument_list|,
name|fl_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fl_m_enqueued"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fl
operator|->
name|ifl_m_enqueued
argument_list|,
literal|"mbufs allocated"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx_list
argument_list|,
name|fl_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fl_m_dequeued"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fl
operator|->
name|ifl_m_dequeued
argument_list|,
literal|"mbufs freed"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx_list
argument_list|,
name|fl_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fl_cl_enqueued"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fl
operator|->
name|ifl_cl_enqueued
argument_list|,
literal|"clusters allocated"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_QUAD
argument_list|(
name|ctx_list
argument_list|,
name|fl_list
argument_list|,
name|OID_AUTO
argument_list|,
literal|"fl_cl_dequeued"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|fl
operator|->
name|ifl_cl_dequeued
argument_list|,
literal|"clusters freed"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
end_ifndef

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|iflib_fixup_rx
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<=
operator|(
name|MCLBYTES
operator|-
name|ETHER_HDR_LEN
operator|)
condition|)
block|{
name|bcopy
argument_list|(
name|m
operator|->
name|m_data
argument_list|,
name|m
operator|->
name|m_data
operator|+
name|ETHER_HDR_LEN
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|ETHER_HDR_LEN
expr_stmt|;
name|n
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
name|MGETHDR
argument_list|(
name|n
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|m
operator|->
name|m_data
argument_list|,
name|n
operator|->
name|m_data
argument_list|,
name|ETHER_HDR_LEN
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|ETHER_HDR_LEN
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|ETHER_HDR_LEN
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
name|ETHER_HDR_LEN
expr_stmt|;
name|M_MOVE_PKTHDR
argument_list|(
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

