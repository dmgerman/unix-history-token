begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * if_ppp.c - Point-to-Point Protocol (PPP) Asynchronous driver.  *  * Copyright (c) 1989 Carnegie Mellon University.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by Carnegie Mellon University.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * Drew D. Perkins  * Carnegie Mellon University  * 4910 Forbes Ave.  * Pittsburgh, PA 15213  * (412) 268-8576  * ddp@andrew.cmu.edu  *  * Based on:  *	@(#)if_sl.c	7.6.1.2 (Berkeley) 2/15/89  *  * Copyright (c) 1987 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * Serial Line interface  *  * Rick Adams  * Center for Seismic Studies  * 1300 N 17th Street, Suite 1450  * Arlington, Virginia 22209  * (703)276-7900  * rick@seismo.ARPA  * seismo!rick  *  * Pounded on heavily by Chris Torek (chris@mimsy.umd.edu, umcp-cs!chris).  * Converted to 4.3BSD Beta by Chris Torek.  * Other changes made at Berkeley, based in part on code by Kirk Smith.  *  * Converted to 4.3BSD+ 386BSD by Brad Parker (brad@cayman.com)  * Added VJ tcp header compression; more unified ioctls  *  * Extensively modified by Paul Mackerras (paulus@cs.anu.edu.au).  * Cleaned up a lot of the mbuf-related code to fix bugs that  * caused system crashes and packet corruption.  Changed pppstart  * so that it doesn't just give up with a collision if the whole  * packet doesn't fit in the output ring buffer.  *  * Added priority queueing for interactive IP packets, following  * the model of if_sl.c, plus hooks for bpf.  * Paul Mackerras (paulus@cs.anu.edu.au).  */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* from if_sl.c,v 1.11 84/10/04 12:54:47 rick Exp */
end_comment

begin_comment
comment|/* from NetBSD: if_ppp.c,v 1.15.2.2 1994/07/28 05:17:58 cgd Exp */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipx.h"
end_include

begin_include
include|#
directive|include
file|"opt_mac.h"
end_include

begin_include
include|#
directive|include
file|"opt_ppp.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_define
define|#
directive|define
name|VJC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PPP_COMPRESS
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mac.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_if
if|#
directive|if
name|INET
end_if

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|IPX
end_if

begin_include
include|#
directive|include
file|<netipx/ipx.h>
end_include

begin_include
include|#
directive|include
file|<netipx/ipx_if.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VJC
end_ifdef

begin_include
include|#
directive|include
file|<net/slcompress.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if_ppp.h>
end_include

begin_include
include|#
directive|include
file|<net/if_pppvar.h>
end_include

begin_comment
comment|/* minimise diffs */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|splsoftnet
end_ifndef

begin_define
define|#
directive|define
name|splsoftnet
value|splnet
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PPP_COMPRESS
end_ifdef

begin_define
define|#
directive|define
name|PACKETPTR
value|struct mbuf *
end_define

begin_include
include|#
directive|include
file|<net/ppp_comp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PPPNAME
value|"ppp"
end_define

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_PPP
argument_list|,
name|PPPNAME
argument_list|,
literal|"PPP interface"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ppp_softc
argument_list|)
name|ppp_softc_list
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* XXX layering violation */
end_comment

begin_function_decl
specifier|extern
name|void
name|pppasyncattach
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|pppasyncdetach
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pppsioctl
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pppintr
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ppp_requeue
parameter_list|(
name|struct
name|ppp_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ppp_ccp
parameter_list|(
name|struct
name|ppp_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|rcvd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ppp_ccp_closed
parameter_list|(
name|struct
name|ppp_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ppp_inproc
parameter_list|(
name|struct
name|ppp_softc
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pppdumpm
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ppp_clone_create
parameter_list|(
name|struct
name|if_clone
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ppp_clone_destroy
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|if_clone
name|ppp_cloner
init|=
name|IF_CLONE_INITIALIZER
argument_list|(
name|PPPNAME
argument_list|,
name|ppp_clone_create
argument_list|,
name|ppp_clone_destroy
argument_list|,
literal|0
argument_list|,
name|IF_MAXUNIT
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Some useful mbuf macros not in mbuf.h.  */
end_comment

begin_define
define|#
directive|define
name|M_IS_CLUSTER
parameter_list|(
name|m
parameter_list|)
value|((m)->m_flags& M_EXT)
end_define

begin_define
define|#
directive|define
name|M_DATASTART
parameter_list|(
name|m
parameter_list|)
define|\
value|(M_IS_CLUSTER(m) ? (m)->m_ext.ext_buf : \ 	    (m)->m_flags& M_PKTHDR ? (m)->m_pktdat : (m)->m_dat)
end_define

begin_define
define|#
directive|define
name|M_DATASIZE
parameter_list|(
name|m
parameter_list|)
define|\
value|(M_IS_CLUSTER(m) ? (m)->m_ext.ext_size : \ 	    (m)->m_flags& M_PKTHDR ? MHLEN: MLEN)
end_define

begin_comment
comment|/*  * We steal two bits in the mbuf m_flags, to mark high-priority packets  * for output, and received packets following lost/corrupted packets.  */
end_comment

begin_define
define|#
directive|define
name|M_HIGHPRI
value|0x2000
end_define

begin_comment
comment|/* output packet for sc_fastq */
end_comment

begin_define
define|#
directive|define
name|M_ERRMARK
value|0x4000
end_define

begin_comment
comment|/* steal a bit in mbuf m_flags */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PPP_COMPRESS
end_ifdef

begin_comment
comment|/*  * List of compressors we know about.  * We leave some space so maybe we can modload compressors.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|compressor
name|ppp_bsd_compress
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|compressor
name|ppp_deflate
decl_stmt|,
name|ppp_deflate_draft
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|compressor
modifier|*
name|ppp_compressors
index|[
literal|8
index|]
init|=
block|{
if|#
directive|if
name|DO_BSD_COMPRESS
operator|&&
name|defined
argument_list|(
name|PPP_BSDCOMP
argument_list|)
operator|&
name|ppp_bsd_compress
block|,
endif|#
directive|endif
if|#
directive|if
name|DO_DEFLATE
operator|&&
name|defined
argument_list|(
name|PPP_DEFLATE
argument_list|)
operator|&
name|ppp_deflate
block|,
operator|&
name|ppp_deflate_draft
block|,
endif|#
directive|endif
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPP_COMPRESS */
end_comment

begin_function
specifier|static
name|int
name|ppp_clone_create
parameter_list|(
name|struct
name|if_clone
modifier|*
name|ifc
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ppp_softc
argument_list|)
argument_list|,
name|M_PPP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_softc
operator|=
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_name
operator|=
name|PPPNAME
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
operator|=
name|unit
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
operator|=
name|PPP_MTU
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|=
name|IFF_POINTOPOINT
operator||
name|IFF_MULTICAST
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_type
operator|=
name|IFT_PPP
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_hdrlen
operator|=
name|PPP_HDRLEN
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ioctl
operator|=
name|pppsioctl
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_output
operator|=
name|pppoutput
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|sc
operator|->
name|sc_inq
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|sc
operator|->
name|sc_fastq
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|sc
operator|->
name|sc_rawq
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_inq
operator|.
name|ifq_mtx
argument_list|,
literal|"ppp_inq"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_fastq
operator|.
name|ifq_mtx
argument_list|,
literal|"ppp_fastq"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_rawq
operator|.
name|ifq_mtx
argument_list|,
literal|"ppp_rawq"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|if_attach
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
name|bpfattach
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|,
name|DLT_PPP
argument_list|,
name|PPP_HDRLEN
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ppp_softc_list
argument_list|,
name|sc
argument_list|,
name|sc_list
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppp_clone_destroy
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sc
argument_list|,
name|sc_list
argument_list|)
expr_stmt|;
name|bpfdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|if_detach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_rawq
operator|.
name|ifq_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_fastq
operator|.
name|ifq_mtx
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|sc
operator|->
name|sc_inq
operator|.
name|ifq_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ppp_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|if_clone_attach
argument_list|(
operator|&
name|ppp_cloner
argument_list|)
expr_stmt|;
name|register_netisr
argument_list|(
name|NETISR_PPP
argument_list|,
name|pppintr
argument_list|)
expr_stmt|;
comment|/* 		 * XXX layering violation - if_ppp can work over any lower 		 * level transport that cares to attach to it. 		 */
name|pppasyncattach
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
comment|/* XXX: layering violation */
name|pppasyncdetach
argument_list|()
expr_stmt|;
name|unregister_netisr
argument_list|(
name|NETISR_PPP
argument_list|)
expr_stmt|;
name|if_clone_detach
argument_list|(
operator|&
name|ppp_cloner
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|ppp_softc_list
argument_list|)
condition|)
name|ppp_clone_destroy
argument_list|(
operator|&
name|LIST_FIRST
argument_list|(
operator|&
name|ppp_softc_list
argument_list|)
operator|->
name|sc_if
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|ppp_mod
init|=
block|{
literal|"if_ppp"
block|,
name|ppp_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|if_ppp
argument_list|,
name|ppp_mod
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Allocate a ppp interface unit and initialize it.  */
end_comment

begin_function
name|struct
name|ppp_softc
modifier|*
name|pppalloc
parameter_list|(
name|pid
parameter_list|)
name|pid_t
name|pid
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
name|tmpname
index|[
name|IFNAMSIZ
index|]
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sc
argument_list|,
argument|&ppp_softc_list
argument_list|,
argument|sc_list
argument_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_xfer
operator|==
name|pid
condition|)
block|{
name|sc
operator|->
name|sc_xfer
operator|=
literal|0
expr_stmt|;
return|return
name|sc
return|;
block|}
block|}
name|LIST_FOREACH
argument_list|(
argument|sc
argument_list|,
argument|&ppp_softc_list
argument_list|,
argument|sc_list
argument_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_devp
operator|==
name|NULL
condition|)
break|break;
block|}
comment|/* Try to clone an interface if we don't have a free one */
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|tmpname
argument_list|,
name|PPPNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_clone_create
argument_list|(
name|tmpname
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpname
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
name|ifp
operator|=
name|ifunit
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|sc
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|sc
operator|->
name|sc_devp
operator|!=
name|NULL
condition|)
return|return
name|NULL
return|;
name|sc
operator|->
name|sc_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_mru
operator|=
name|PPP_MRU
expr_stmt|;
name|sc
operator|->
name|sc_relinq
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sc
operator|->
name|sc_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_stats
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VJC
name|MALLOC
argument_list|(
name|sc
operator|->
name|sc_comp
argument_list|,
expr|struct
name|slcompress
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|slcompress
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_comp
condition|)
name|sl_compress_init
argument_list|(
name|sc
operator|->
name|sc_comp
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PPP_COMPRESS
name|sc
operator|->
name|sc_xc_state
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_rc_state
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* PPP_COMPRESS */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_NP
condition|;
operator|++
name|i
control|)
name|sc
operator|->
name|sc_npmode
index|[
name|i
index|]
operator|=
name|NPMODE_ERROR
expr_stmt|;
name|sc
operator|->
name|sc_npqueue
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_npqtail
operator|=
operator|&
name|sc
operator|->
name|sc_npqueue
expr_stmt|;
name|sc
operator|->
name|sc_last_sent
operator|=
name|sc
operator|->
name|sc_last_recv
operator|=
name|time_second
expr_stmt|;
return|return
name|sc
return|;
block|}
end_function

begin_comment
comment|/*  * Deallocate a ppp unit.  Must be called at splsoftnet or higher.  */
end_comment

begin_function
name|void
name|pppdealloc
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|if_down
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
operator|.
name|if_lastchange
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_devp
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_xfer
operator|=
literal|0
expr_stmt|;
name|IF_DRAIN
argument_list|(
operator|&
name|sc
operator|->
name|sc_rawq
argument_list|)
expr_stmt|;
name|IF_DRAIN
argument_list|(
operator|&
name|sc
operator|->
name|sc_inq
argument_list|)
expr_stmt|;
name|IF_DRAIN
argument_list|(
operator|&
name|sc
operator|->
name|sc_fastq
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|sc
operator|->
name|sc_npqueue
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_npqueue
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PPP_COMPRESS
name|ppp_ccp_closed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_xc_state
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_rc_state
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* PPP_COMPRESS */
ifdef|#
directive|ifdef
name|PPP_FILTER
if|if
condition|(
name|sc
operator|->
name|sc_pass_filt
operator|.
name|bf_insns
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|sc_pass_filt
operator|.
name|bf_insns
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_pass_filt
operator|.
name|bf_insns
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_pass_filt
operator|.
name|bf_len
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_active_filt
operator|.
name|bf_insns
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|sc_active_filt
operator|.
name|bf_insns
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_active_filt
operator|.
name|bf_insns
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_active_filt
operator|.
name|bf_len
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PPP_FILTER */
ifdef|#
directive|ifdef
name|VJC
if|if
condition|(
name|sc
operator|->
name|sc_comp
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|sc
operator|->
name|sc_comp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_comp
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Ioctl routine for generic ppp devices.  */
end_comment

begin_function
name|int
name|pppioctl
parameter_list|(
name|sc
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|,
name|td
parameter_list|)
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|td
operator|->
name|td_proc
decl_stmt|;
name|int
name|s
decl_stmt|,
name|flags
decl_stmt|,
name|mru
decl_stmt|,
name|npx
decl_stmt|;
name|u_int
name|nb
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|ppp_option_data
modifier|*
name|odp
decl_stmt|;
name|struct
name|compressor
modifier|*
modifier|*
name|cp
decl_stmt|;
name|struct
name|npioctl
modifier|*
name|npi
decl_stmt|;
name|time_t
name|t
decl_stmt|;
ifdef|#
directive|ifdef
name|PPP_FILTER
name|struct
name|bpf_program
modifier|*
name|bp
decl_stmt|,
modifier|*
name|nbp
decl_stmt|;
name|struct
name|bpf_insn
modifier|*
name|newcode
decl_stmt|,
modifier|*
name|oldcode
decl_stmt|;
name|int
name|newcodelen
decl_stmt|;
endif|#
directive|endif
comment|/* PPP_FILTER */
ifdef|#
directive|ifdef
name|PPP_COMPRESS
name|u_char
name|ccp_option
index|[
name|CCP_MAX_OPTION_LENGTH
index|]
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FIONREAD
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_inq
operator|.
name|ifq_len
expr_stmt|;
break|break;
case|case
name|PPPIOCGUNIT
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
expr_stmt|;
break|break;
case|case
name|PPPIOCGFLAGS
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_flags
expr_stmt|;
break|break;
case|case
name|PPPIOCSFLAGS
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|flags
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|SC_MASK
expr_stmt|;
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PPP_COMPRESS
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_CCP_OPEN
operator|&&
operator|!
operator|(
name|flags
operator|&
name|SC_CCP_OPEN
operator|)
condition|)
name|ppp_ccp_closed
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
operator|(
name|sc
operator|->
name|sc_flags
operator|&
operator|~
name|SC_MASK
operator|)
operator||
name|flags
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPPIOCSMRU
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mru
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|mru
operator|>=
name|PPP_MRU
operator|&&
name|mru
operator|<=
name|PPP_MAXMRU
condition|)
name|sc
operator|->
name|sc_mru
operator|=
name|mru
expr_stmt|;
break|break;
case|case
name|PPPIOCGMRU
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_mru
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|VJC
case|case
name|PPPIOCSMAXCID
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|sc
operator|->
name|sc_comp
condition|)
block|{
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|sl_compress_init
argument_list|(
name|sc
operator|->
name|sc_comp
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|PPPIOCXFERUNIT
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|sc
operator|->
name|sc_xfer
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|PPP_COMPRESS
case|case
name|PPPIOCSCOMPRESS
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|odp
operator|=
operator|(
expr|struct
name|ppp_option_data
operator|*
operator|)
name|data
expr_stmt|;
name|nb
operator|=
name|odp
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|nb
operator|>
sizeof|sizeof
argument_list|(
name|ccp_option
argument_list|)
condition|)
name|nb
operator|=
sizeof|sizeof
argument_list|(
name|ccp_option
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|odp
operator|->
name|ptr
argument_list|,
name|ccp_option
argument_list|,
name|nb
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|ccp_option
index|[
literal|1
index|]
operator|<
literal|2
condition|)
block|{
comment|/* preliminary check on the length byte */
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
for|for
control|(
name|cp
operator|=
name|ppp_compressors
init|;
operator|*
name|cp
operator|!=
name|NULL
condition|;
operator|++
name|cp
control|)
if|if
condition|(
operator|(
operator|*
name|cp
operator|)
operator|->
name|compress_proto
operator|==
name|ccp_option
index|[
literal|0
index|]
condition|)
block|{
comment|/* 		 * Found a handler for the protocol - try to allocate 		 * a compressor or decompressor. 		 */
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|odp
operator|->
name|transmit
condition|)
block|{
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_xc_state
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_xcomp
operator|->
name|comp_free
call|)
argument_list|(
name|sc
operator|->
name|sc_xc_state
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_xcomp
operator|=
operator|*
name|cp
expr_stmt|;
name|sc
operator|->
name|sc_xc_state
operator|=
operator|(
operator|*
name|cp
operator|)
operator|->
name|comp_alloc
argument_list|(
name|ccp_option
argument_list|,
name|nb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_xc_state
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|printf
argument_list|(
literal|"ppp%d: comp_alloc failed\n"
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
block|}
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_COMP_RUN
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rc_state
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_rcomp
operator|->
name|decomp_free
call|)
argument_list|(
name|sc
operator|->
name|sc_rc_state
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rcomp
operator|=
operator|*
name|cp
expr_stmt|;
name|sc
operator|->
name|sc_rc_state
operator|=
operator|(
operator|*
name|cp
operator|)
operator|->
name|decomp_alloc
argument_list|(
name|ccp_option
argument_list|,
name|nb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rc_state
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|printf
argument_list|(
literal|"ppp%d: decomp_alloc failed\n"
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
block|}
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_DECOMP_RUN
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|printf
argument_list|(
literal|"ppp%d: no compressor for [%x %x %x], %x\n"
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
argument_list|,
name|ccp_option
index|[
literal|0
index|]
argument_list|,
name|ccp_option
index|[
literal|1
index|]
argument_list|,
name|ccp_option
index|[
literal|2
index|]
argument_list|,
name|nb
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* no handler found */
break|break;
endif|#
directive|endif
comment|/* PPP_COMPRESS */
case|case
name|PPPIOCGNPMODE
case|:
case|case
name|PPPIOCSNPMODE
case|:
name|npi
operator|=
operator|(
expr|struct
name|npioctl
operator|*
operator|)
name|data
expr_stmt|;
name|npx
operator|=
literal|0
expr_stmt|;
comment|/* XXX: quiet gcc */
switch|switch
condition|(
name|npi
operator|->
name|protocol
condition|)
block|{
case|case
name|PPP_IP
case|:
name|npx
operator|=
name|NP_IP
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|cmd
operator|==
name|PPPIOCGNPMODE
condition|)
block|{
name|npi
operator|->
name|mode
operator|=
name|sc
operator|->
name|sc_npmode
index|[
name|npx
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|npi
operator|->
name|mode
operator|!=
name|sc
operator|->
name|sc_npmode
index|[
name|npx
index|]
condition|)
block|{
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_npmode
index|[
name|npx
index|]
operator|=
name|npi
operator|->
name|mode
expr_stmt|;
if|if
condition|(
name|npi
operator|->
name|mode
operator|!=
name|NPMODE_QUEUE
condition|)
block|{
name|ppp_requeue
argument_list|(
name|sc
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_start
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PPPIOCGIDLE
case|:
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
name|t
operator|=
name|time_second
expr_stmt|;
operator|(
operator|(
expr|struct
name|ppp_idle
operator|*
operator|)
name|data
operator|)
operator|->
name|xmit_idle
operator|=
name|t
operator|-
name|sc
operator|->
name|sc_last_sent
expr_stmt|;
operator|(
operator|(
expr|struct
name|ppp_idle
operator|*
operator|)
name|data
operator|)
operator|->
name|recv_idle
operator|=
name|t
operator|-
name|sc
operator|->
name|sc_last_recv
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|PPP_FILTER
case|case
name|PPPIOCSPASS
case|:
case|case
name|PPPIOCSACTIVE
case|:
name|nbp
operator|=
operator|(
expr|struct
name|bpf_program
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|nbp
operator|->
name|bf_len
operator|>
name|BPF_MAXINSNS
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|newcodelen
operator|=
name|nbp
operator|->
name|bf_len
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|bpf_insn
argument_list|)
expr_stmt|;
if|if
condition|(
name|newcodelen
operator|!=
literal|0
condition|)
block|{
name|MALLOC
argument_list|(
name|newcode
argument_list|,
expr|struct
name|bpf_insn
operator|*
argument_list|,
name|newcodelen
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|newcode
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* or sumpin */
break|break;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|caddr_t
operator|)
name|nbp
operator|->
name|bf_insns
argument_list|,
operator|(
name|caddr_t
operator|)
name|newcode
argument_list|,
name|newcodelen
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|newcode
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|bpf_validate
argument_list|(
name|newcode
argument_list|,
name|nbp
operator|->
name|bf_len
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|newcode
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
else|else
name|newcode
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
operator|(
name|cmd
operator|==
name|PPPIOCSPASS
operator|)
condition|?
operator|&
name|sc
operator|->
name|sc_pass_filt
else|:
operator|&
name|sc
operator|->
name|sc_active_filt
expr_stmt|;
name|oldcode
operator|=
name|bp
operator|->
name|bf_insns
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|bp
operator|->
name|bf_len
operator|=
name|nbp
operator|->
name|bf_len
expr_stmt|;
name|bp
operator|->
name|bf_insns
operator|=
name|newcode
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldcode
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|oldcode
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|ENOIOCTL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request to the ppp network interface.  */
end_comment

begin_function
specifier|static
name|int
name|pppsioctl
parameter_list|(
name|ifp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_long
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
comment|/* XXX */
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
specifier|register
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|ppp_stats
modifier|*
name|psp
decl_stmt|;
ifdef|#
directive|ifdef
name|PPP_COMPRESS
name|struct
name|ppp_comp_stats
modifier|*
name|pcp
decl_stmt|;
endif|#
directive|endif
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
break|break;
case|case
name|SIOCSIFADDR
case|:
case|case
name|SIOCAIFADDR
case|:
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPX
case|case
name|AF_IPX
case|:
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIOCSIFDSTADDR
case|:
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPX
case|case
name|AF_IPX
case|:
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIOCSIFMTU
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|PPP_MAXMTU
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_setmtu
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_setmtu
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCGIFMTU
case|:
name|ifr
operator|->
name|ifr_mtu
operator|=
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
expr_stmt|;
break|break;
case|case
name|SIOCADDMULTI
case|:
case|case
name|SIOCDELMULTI
case|:
if|if
condition|(
name|ifr
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|ifr
operator|->
name|ifr_addr
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SIOCGPPPSTATS
case|:
name|psp
operator|=
operator|&
operator|(
operator|(
expr|struct
name|ifpppstatsreq
operator|*
operator|)
name|data
operator|)
operator|->
name|stats
expr_stmt|;
name|bzero
argument_list|(
name|psp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|psp
argument_list|)
argument_list|)
expr_stmt|;
name|psp
operator|->
name|p
operator|=
name|sc
operator|->
name|sc_stats
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|VJC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SL_NO_STATS
argument_list|)
if|if
condition|(
name|sc
operator|->
name|sc_comp
condition|)
block|{
name|psp
operator|->
name|vj
operator|.
name|vjs_packets
operator|=
name|sc
operator|->
name|sc_comp
operator|->
name|sls_packets
expr_stmt|;
name|psp
operator|->
name|vj
operator|.
name|vjs_compressed
operator|=
name|sc
operator|->
name|sc_comp
operator|->
name|sls_compressed
expr_stmt|;
name|psp
operator|->
name|vj
operator|.
name|vjs_searches
operator|=
name|sc
operator|->
name|sc_comp
operator|->
name|sls_searches
expr_stmt|;
name|psp
operator|->
name|vj
operator|.
name|vjs_misses
operator|=
name|sc
operator|->
name|sc_comp
operator|->
name|sls_misses
expr_stmt|;
name|psp
operator|->
name|vj
operator|.
name|vjs_uncompressedin
operator|=
name|sc
operator|->
name|sc_comp
operator|->
name|sls_uncompressedin
expr_stmt|;
name|psp
operator|->
name|vj
operator|.
name|vjs_compressedin
operator|=
name|sc
operator|->
name|sc_comp
operator|->
name|sls_compressedin
expr_stmt|;
name|psp
operator|->
name|vj
operator|.
name|vjs_errorin
operator|=
name|sc
operator|->
name|sc_comp
operator|->
name|sls_errorin
expr_stmt|;
name|psp
operator|->
name|vj
operator|.
name|vjs_tossed
operator|=
name|sc
operator|->
name|sc_comp
operator|->
name|sls_tossed
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* VJC */
break|break;
ifdef|#
directive|ifdef
name|PPP_COMPRESS
case|case
name|SIOCGPPPCSTATS
case|:
name|pcp
operator|=
operator|&
operator|(
operator|(
expr|struct
name|ifpppcstatsreq
operator|*
operator|)
name|data
operator|)
operator|->
name|stats
expr_stmt|;
name|bzero
argument_list|(
name|pcp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pcp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_xc_state
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_xcomp
operator|->
name|comp_stat
call|)
argument_list|(
name|sc
operator|->
name|sc_xc_state
argument_list|,
operator|&
name|pcp
operator|->
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rc_state
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_rcomp
operator|->
name|decomp_stat
call|)
argument_list|(
name|sc
operator|->
name|sc_rc_state
argument_list|,
operator|&
name|pcp
operator|->
name|d
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* PPP_COMPRESS */
default|default:
name|error
operator|=
name|ENOTTY
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Queue a packet.  Start transmission if not active.  * Packet is placed in Information field of PPP frame.  * Called at splnet as the if->if_output handler.  * Called at splnet from pppwrite().  */
end_comment

begin_function
name|int
name|pppoutput
parameter_list|(
name|ifp
parameter_list|,
name|m0
parameter_list|,
name|dst
parameter_list|,
name|rtp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rtp
decl_stmt|;
block|{
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|int
name|protocol
decl_stmt|,
name|address
decl_stmt|,
name|control
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|ifqueue
modifier|*
name|ifq
decl_stmt|;
name|enum
name|NPmode
name|mode
decl_stmt|;
name|int
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_ifnet_transmit
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
endif|#
directive|endif
if|if
condition|(
name|sc
operator|->
name|sc_devp
operator|==
name|NULL
operator|||
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
name|dst
operator|->
name|sa_family
operator|!=
name|AF_UNSPEC
operator|)
condition|)
block|{
name|error
operator|=
name|ENETDOWN
expr_stmt|;
comment|/* sort of */
goto|goto
name|bad
goto|;
block|}
comment|/*      * Compute PPP header.      */
name|m0
operator|->
name|m_flags
operator|&=
operator|~
name|M_HIGHPRI
expr_stmt|;
switch|switch
condition|(
name|dst
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|address
operator|=
name|PPP_ALLSTATIONS
expr_stmt|;
name|control
operator|=
name|PPP_UI
expr_stmt|;
name|protocol
operator|=
name|PPP_IP
expr_stmt|;
name|mode
operator|=
name|sc
operator|->
name|sc_npmode
index|[
name|NP_IP
index|]
expr_stmt|;
comment|/* 	 * If this packet has the "low delay" bit set in the IP header, 	 * put it on the fastq instead. 	 */
name|ip
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_tos
operator|&
name|IPTOS_LOWDELAY
condition|)
name|m0
operator|->
name|m_flags
operator||=
name|M_HIGHPRI
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPX
case|case
name|AF_IPX
case|:
comment|/* 	 * This is pretty bogus.. We dont have an ipxcp module in pppd 	 * yet to configure the link parameters.  Sigh. I guess a 	 * manual ifconfig would do....  -Peter 	 */
name|address
operator|=
name|PPP_ALLSTATIONS
expr_stmt|;
name|control
operator|=
name|PPP_UI
expr_stmt|;
name|protocol
operator|=
name|PPP_IPX
expr_stmt|;
name|mode
operator|=
name|NPMODE_PASS
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|AF_UNSPEC
case|:
name|address
operator|=
name|PPP_ADDRESS
argument_list|(
name|dst
operator|->
name|sa_data
argument_list|)
expr_stmt|;
name|control
operator|=
name|PPP_CONTROL
argument_list|(
name|dst
operator|->
name|sa_data
argument_list|)
expr_stmt|;
name|protocol
operator|=
name|PPP_PROTOCOL
argument_list|(
name|dst
operator|->
name|sa_data
argument_list|)
expr_stmt|;
name|mode
operator|=
name|NPMODE_PASS
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ppp%d: af%d not supported\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/*      * Drop this packet, or return an error, if necessary.      */
if|if
condition|(
name|mode
operator|==
name|NPMODE_ERROR
condition|)
block|{
name|error
operator|=
name|ENETDOWN
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|mode
operator|==
name|NPMODE_DROP
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/*      * Add PPP header.  If no space in first mbuf, allocate another.      * (This assumes M_LEADINGSPACE is always 0 for a cluster mbuf.)      */
if|if
condition|(
name|M_LEADINGSPACE
argument_list|(
name|m0
argument_list|)
operator|<
name|PPP_HDRLEN
condition|)
block|{
name|m0
operator|=
name|m_prepend
argument_list|(
name|m0
argument_list|,
name|PPP_HDRLEN
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|m0
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|m0
operator|->
name|m_data
operator|-=
name|PPP_HDRLEN
expr_stmt|;
name|cp
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|address
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|control
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|protocol
operator|>>
literal|8
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|protocol
operator|&
literal|0xff
expr_stmt|;
name|m0
operator|->
name|m_len
operator|+=
name|PPP_HDRLEN
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|!=
literal|0
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
name|len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_LOG_OUTPKT
condition|)
block|{
name|printf
argument_list|(
literal|"ppp%d output: "
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|pppdumpm
argument_list|(
name|m0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|protocol
operator|&
literal|0x8000
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|PPP_FILTER
comment|/* 	 * Apply the pass and active filters to the packet, 	 * but only if it is a data packet. 	 */
operator|*
name|mtod
argument_list|(
name|m0
argument_list|,
name|u_char
operator|*
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* indicates outbound */
if|if
condition|(
name|sc
operator|->
name|sc_pass_filt
operator|.
name|bf_insns
operator|!=
literal|0
operator|&&
name|bpf_filter
argument_list|(
name|sc
operator|->
name|sc_pass_filt
operator|.
name|bf_insns
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|m0
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
comment|/* drop this packet */
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Update the time we sent the most recent packet. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_active_filt
operator|.
name|bf_insns
operator|==
literal|0
operator|||
name|bpf_filter
argument_list|(
name|sc
operator|->
name|sc_active_filt
operator|.
name|bf_insns
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|m0
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
condition|)
name|sc
operator|->
name|sc_last_sent
operator|=
name|time_second
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m0
argument_list|,
name|u_char
operator|*
argument_list|)
operator|=
name|address
expr_stmt|;
else|#
directive|else
comment|/* 	 * Update the time we sent the most recent data packet. 	 */
name|sc
operator|->
name|sc_last_sent
operator|=
name|time_second
expr_stmt|;
endif|#
directive|endif
comment|/* PPP_FILTER */
block|}
comment|/*      * See if bpf wants to look at the packet.      */
if|if
condition|(
name|ifp
operator|->
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|)
expr_stmt|;
comment|/*      * Put the packet on the appropriate queue.      */
name|s
operator|=
name|splsoftnet
argument_list|()
expr_stmt|;
comment|/* redundant */
if|if
condition|(
name|mode
operator|==
name|NPMODE_QUEUE
condition|)
block|{
comment|/* XXX we should limit the number of packets on this queue */
operator|*
name|sc
operator|->
name|sc_npqtail
operator|=
name|m0
expr_stmt|;
name|m0
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_npqtail
operator|=
operator|&
name|m0
operator|->
name|m_nextpkt
expr_stmt|;
block|}
else|else
block|{
comment|/* fastq and if_snd are emptied at spl[soft]net now */
name|ifq
operator|=
operator|(
name|m0
operator|->
name|m_flags
operator|&
name|M_HIGHPRI
operator|)
condition|?
operator|&
name|sc
operator|->
name|sc_fastq
else|:
operator|&
name|ifp
operator|->
name|if_snd
expr_stmt|;
name|IF_LOCK
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
if|if
condition|(
name|_IF_QFULL
argument_list|(
name|ifq
argument_list|)
operator|&&
name|dst
operator|->
name|sa_family
operator|!=
name|AF_UNSPEC
condition|)
block|{
name|_IF_DROP
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
name|IF_UNLOCK
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ppp_oerrors
operator|++
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|_IF_ENQUEUE
argument_list|(
name|ifq
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|IF_UNLOCK
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_start
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|getmicrotime
argument_list|(
operator|&
name|ifp
operator|->
name|if_lastchange
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_obytes
operator|+=
name|len
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * After a change in the NPmode for some NP, move packets from the  * npqueue to the send queue or the fast queue as appropriate.  * Should be called at spl[soft]net.  */
end_comment

begin_function
specifier|static
name|void
name|ppp_requeue
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|mpp
decl_stmt|;
name|struct
name|ifqueue
modifier|*
name|ifq
decl_stmt|;
name|enum
name|NPmode
name|mode
decl_stmt|;
for|for
control|(
name|mpp
operator|=
operator|&
name|sc
operator|->
name|sc_npqueue
init|;
operator|(
name|m
operator|=
operator|*
name|mpp
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
switch|switch
condition|(
name|PPP_PROTOCOL
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|PPP_IP
case|:
name|mode
operator|=
name|sc
operator|->
name|sc_npmode
index|[
name|NP_IP
index|]
expr_stmt|;
break|break;
default|default:
name|mode
operator|=
name|NPMODE_PASS
expr_stmt|;
block|}
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|NPMODE_PASS
case|:
comment|/* 	     * This packet can now go on one of the queues to be sent. 	     */
operator|*
name|mpp
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|ifq
operator|=
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_HIGHPRI
operator|)
condition|?
operator|&
name|sc
operator|->
name|sc_fastq
else|:
operator|&
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
expr_stmt|;
if|if
condition|(
operator|!
name|IF_HANDOFF
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|sc
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ppp_oerrors
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|NPMODE_DROP
case|:
case|case
name|NPMODE_ERROR
case|:
operator|*
name|mpp
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
name|NPMODE_QUEUE
case|:
name|mpp
operator|=
operator|&
name|m
operator|->
name|m_nextpkt
expr_stmt|;
break|break;
block|}
block|}
name|sc
operator|->
name|sc_npqtail
operator|=
name|mpp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Transmitter has finished outputting some stuff;  * remember to call sc->sc_start later at splsoftnet.  */
end_comment

begin_function
name|void
name|ppp_restart
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_TBUSY
expr_stmt|;
name|schednetisr
argument_list|(
name|NETISR_PPP
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get a packet to send.  This procedure is intended to be called at  * splsoftnet, since it may involve time-consuming operations such as  * applying VJ compression, packet compression, address/control and/or  * protocol field compression to the packet.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ppp_dequeue
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mp
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|address
decl_stmt|,
name|control
decl_stmt|,
name|protocol
decl_stmt|;
comment|/*      * Grab a packet to send: first try the fast queue, then the      * normal queue.      */
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_fastq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|++
name|sc
operator|->
name|sc_stats
operator|.
name|ppp_opackets
expr_stmt|;
comment|/*      * Extract the ppp header of the new packet.      * The ppp header will be in one mbuf.      */
name|cp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|address
operator|=
name|PPP_ADDRESS
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|control
operator|=
name|PPP_CONTROL
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|protocol
operator|=
name|PPP_PROTOCOL
argument_list|(
name|cp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|protocol
condition|)
block|{
case|case
name|PPP_IP
case|:
ifdef|#
directive|ifdef
name|VJC
comment|/* 	 * If the packet is a TCP/IP packet, see if we can compress it. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_COMP_TCP
operator|)
operator|&&
name|sc
operator|->
name|sc_comp
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|type
decl_stmt|;
name|mp
operator|=
name|m
expr_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|cp
operator|+
name|PPP_HDRLEN
operator|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_len
operator|<=
name|PPP_HDRLEN
condition|)
block|{
name|mp
operator|=
name|mp
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
break|break;
name|ip
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
comment|/* this code assumes the IP/TCP header is in one non-shared mbuf */
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
condition|)
block|{
name|type
operator|=
name|sl_compress_tcp
argument_list|(
name|mp
argument_list|,
name|ip
argument_list|,
name|sc
operator|->
name|sc_comp
argument_list|,
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_NO_TCP_CCID
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYPE_UNCOMPRESSED_TCP
case|:
name|protocol
operator|=
name|PPP_VJC_UNCOMP
expr_stmt|;
break|break;
case|case
name|TYPE_COMPRESSED_TCP
case|:
name|protocol
operator|=
name|PPP_VJC_COMP
expr_stmt|;
name|cp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
name|address
expr_stmt|;
comment|/* header has moved */
name|cp
index|[
literal|1
index|]
operator|=
name|control
expr_stmt|;
name|cp
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|cp
index|[
literal|3
index|]
operator|=
name|protocol
expr_stmt|;
comment|/* update protocol in PPP header */
block|}
block|}
endif|#
directive|endif
comment|/* VJC */
break|break;
ifdef|#
directive|ifdef
name|PPP_COMPRESS
case|case
name|PPP_CCP
case|:
name|ppp_ccp
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* PPP_COMPRESS */
block|}
ifdef|#
directive|ifdef
name|PPP_COMPRESS
if|if
condition|(
name|protocol
operator|!=
name|PPP_LCP
operator|&&
name|protocol
operator|!=
name|PPP_CCP
operator|&&
name|sc
operator|->
name|sc_xc_state
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_COMP_RUN
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mcomp
init|=
name|NULL
decl_stmt|;
name|int
name|slen
decl_stmt|,
name|clen
decl_stmt|;
name|slen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|m
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_next
control|)
name|slen
operator|+=
name|mp
operator|->
name|m_len
expr_stmt|;
name|clen
operator|=
call|(
modifier|*
name|sc
operator|->
name|sc_xcomp
operator|->
name|compress
call|)
argument_list|(
name|sc
operator|->
name|sc_xc_state
argument_list|,
operator|&
name|mcomp
argument_list|,
name|m
argument_list|,
name|slen
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
operator|+
name|PPP_HDRLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcomp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_CCP_UP
condition|)
block|{
comment|/* Send the compressed packet instead of the original. */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|mcomp
expr_stmt|;
name|cp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|protocol
operator|=
name|cp
index|[
literal|3
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* Can't transmit compressed packets until CCP is up. */
name|m_freem
argument_list|(
name|mcomp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* PPP_COMPRESS */
comment|/*      * Compress the address/control and protocol, if possible.      */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_COMP_AC
operator|&&
name|address
operator|==
name|PPP_ALLSTATIONS
operator|&&
name|control
operator|==
name|PPP_UI
operator|&&
name|protocol
operator|!=
name|PPP_ALLSTATIONS
operator|&&
name|protocol
operator|!=
name|PPP_LCP
condition|)
block|{
comment|/* can compress address/control */
name|m
operator|->
name|m_data
operator|+=
literal|2
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_COMP_PROT
operator|&&
name|protocol
operator|<
literal|0xFF
condition|)
block|{
comment|/* can compress protocol */
if|if
condition|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator|==
name|cp
condition|)
block|{
name|cp
index|[
literal|2
index|]
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
comment|/* move address/control up */
name|cp
index|[
literal|1
index|]
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
block|}
operator|++
name|m
operator|->
name|m_data
expr_stmt|;
operator|--
name|m
operator|->
name|m_len
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * Software interrupt routine, called at spl[soft]net.  */
end_comment

begin_function
specifier|static
name|void
name|pppintr
parameter_list|()
block|{
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sc
argument_list|,
argument|&ppp_softc_list
argument_list|,
argument|sc_list
argument_list|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_TBUSY
operator|)
operator|&&
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
operator|.
name|ifq_head
operator|||
name|sc
operator|->
name|sc_fastq
operator|.
name|ifq_head
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|SC_TBUSY
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
call|(
modifier|*
name|sc
operator|->
name|sc_start
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
else|else
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_rawq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
ifdef|#
directive|ifdef
name|MAC
name|mac_create_mbuf_from_ifnet
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ppp_inproc
argument_list|(
name|sc
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PPP_COMPRESS
end_ifdef

begin_comment
comment|/*  * Handle a CCP packet.  `rcvd' is 1 if the packet was received,  * 0 if it is about to be transmitted.  */
end_comment

begin_function
specifier|static
name|void
name|ppp_ccp
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|rcvd
parameter_list|)
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|rcvd
decl_stmt|;
block|{
name|u_char
modifier|*
name|dp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
name|int
name|slen
decl_stmt|,
name|s
decl_stmt|;
comment|/*      * Get a pointer to the data after the PPP header.      */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<=
name|PPP_HDRLEN
condition|)
block|{
name|mp
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
return|return;
name|dp
operator|=
operator|(
name|mp
operator|!=
name|NULL
operator|)
condition|?
name|mtod
argument_list|(
name|mp
argument_list|,
name|u_char
operator|*
argument_list|)
else|:
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|=
name|m
expr_stmt|;
name|dp
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
name|PPP_HDRLEN
expr_stmt|;
block|}
name|ep
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
name|mp
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
name|dp
operator|+
name|CCP_HDRLEN
operator|>
name|ep
condition|)
return|return;
name|slen
operator|=
name|CCP_LENGTH
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|+
name|slen
operator|>
name|ep
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|printf
argument_list|(
literal|"if_ppp/ccp: not enough data in mbuf (%p+%x> %p+%x)\n"
argument_list|,
name|dp
argument_list|,
name|slen
argument_list|,
name|mtod
argument_list|(
name|mp
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|mp
operator|->
name|m_len
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|CCP_CODE
argument_list|(
name|dp
argument_list|)
condition|)
block|{
case|case
name|CCP_CONFREQ
case|:
case|case
name|CCP_TERMREQ
case|:
case|case
name|CCP_TERMACK
case|:
comment|/* CCP must be going down - disable compression */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_CCP_UP
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
operator|(
name|SC_CCP_UP
operator||
name|SC_COMP_RUN
operator||
name|SC_DECOMP_RUN
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CCP_CONFACK
case|:
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_CCP_OPEN
operator|&&
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_CCP_UP
operator|)
operator|&&
name|slen
operator|>=
name|CCP_HDRLEN
operator|+
name|CCP_OPT_MINLEN
operator|&&
name|slen
operator|>=
name|CCP_OPT_LENGTH
argument_list|(
name|dp
operator|+
name|CCP_HDRLEN
argument_list|)
operator|+
name|CCP_HDRLEN
condition|)
block|{
if|if
condition|(
operator|!
name|rcvd
condition|)
block|{
comment|/* we're agreeing to send compressed packets. */
if|if
condition|(
name|sc
operator|->
name|sc_xc_state
operator|!=
name|NULL
operator|&&
call|(
modifier|*
name|sc
operator|->
name|sc_xcomp
operator|->
name|comp_init
call|)
argument_list|(
name|sc
operator|->
name|sc_xc_state
argument_list|,
name|dp
operator|+
name|CCP_HDRLEN
argument_list|,
name|slen
operator|-
name|CCP_HDRLEN
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
argument_list|)
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|SC_COMP_RUN
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* peer is agreeing to send compressed packets. */
if|if
condition|(
name|sc
operator|->
name|sc_rc_state
operator|!=
name|NULL
operator|&&
call|(
modifier|*
name|sc
operator|->
name|sc_rcomp
operator|->
name|decomp_init
call|)
argument_list|(
name|sc
operator|->
name|sc_rc_state
argument_list|,
name|dp
operator|+
name|CCP_HDRLEN
argument_list|,
name|slen
operator|-
name|CCP_HDRLEN
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_mru
argument_list|,
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
argument_list|)
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|SC_DECOMP_RUN
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
operator|(
name|SC_DC_ERROR
operator||
name|SC_DC_FERROR
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|CCP_RESETACK
case|:
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_CCP_UP
condition|)
block|{
if|if
condition|(
operator|!
name|rcvd
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_xc_state
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_COMP_RUN
operator|)
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_xcomp
operator|->
name|comp_reset
call|)
argument_list|(
name|sc
operator|->
name|sc_xc_state
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sc_rc_state
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DECOMP_RUN
operator|)
condition|)
block|{
call|(
modifier|*
name|sc
operator|->
name|sc_rcomp
operator|->
name|decomp_reset
call|)
argument_list|(
name|sc
operator|->
name|sc_rc_state
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_DC_ERROR
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * CCP is down; free (de)compressor state if necessary.  */
end_comment

begin_function
specifier|static
name|void
name|ppp_ccp_closed
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
block|{
if|if
condition|(
name|sc
operator|->
name|sc_xc_state
condition|)
block|{
call|(
modifier|*
name|sc
operator|->
name|sc_xcomp
operator|->
name|comp_free
call|)
argument_list|(
name|sc
operator|->
name|sc_xc_state
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_xc_state
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_rc_state
condition|)
block|{
call|(
modifier|*
name|sc
operator|->
name|sc_rcomp
operator|->
name|decomp_free
call|)
argument_list|(
name|sc
operator|->
name|sc_rc_state
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rc_state
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PPP_COMPRESS */
end_comment

begin_comment
comment|/*  * PPP packet input routine.  * The caller has checked and removed the FCS and has inserted  * the address/control bytes and the protocol high byte if they  * were omitted.  */
end_comment

begin_function
name|void
name|ppppktin
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|lost
parameter_list|)
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|lost
decl_stmt|;
block|{
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|;
if|if
condition|(
name|lost
condition|)
name|m
operator|->
name|m_flags
operator||=
name|M_ERRMARK
expr_stmt|;
name|IF_ENQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_rawq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|schednetisr
argument_list|(
name|NETISR_PPP
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a received PPP packet, doing decompression as necessary.  * Should be called at splsoftnet.  */
end_comment

begin_define
define|#
directive|define
name|COMPTYPE
parameter_list|(
name|proto
parameter_list|)
value|((proto) == PPP_VJC_COMP? TYPE_COMPRESSED_TCP: \ 			 TYPE_UNCOMPRESSED_TCP)
end_define

begin_function
specifier|static
name|void
name|ppp_inproc
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|)
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|sc
operator|->
name|sc_if
decl_stmt|;
name|struct
name|ifqueue
modifier|*
name|inq
decl_stmt|;
name|int
name|s
decl_stmt|,
name|ilen
init|=
literal|0
decl_stmt|,
name|xlen
decl_stmt|,
name|proto
decl_stmt|,
name|rv
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
name|adrs
decl_stmt|,
name|ctrl
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|,
modifier|*
name|dmp
init|=
name|NULL
decl_stmt|;
name|u_char
modifier|*
name|iphdr
decl_stmt|;
name|u_int
name|hlen
decl_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ppp_ipackets
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_LOG_INPKT
condition|)
block|{
name|ilen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|m
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_next
control|)
name|ilen
operator|+=
name|mp
operator|->
name|m_len
expr_stmt|;
name|printf
argument_list|(
literal|"ppp%d: got %d bytes\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
name|pppdumpm
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|adrs
operator|=
name|PPP_ADDRESS
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|ctrl
operator|=
name|PPP_CONTROL
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|proto
operator|=
name|PPP_PROTOCOL
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_ERRMARK
condition|)
block|{
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_ERRMARK
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|SC_VJ_RESET
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PPP_COMPRESS
comment|/*      * Decompress this packet if necessary, update the receiver's      * dictionary, or take appropriate action on a CCP packet.      */
if|if
condition|(
name|proto
operator|==
name|PPP_COMP
operator|&&
name|sc
operator|->
name|sc_rc_state
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DECOMP_RUN
operator|)
operator|&&
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DC_ERROR
operator|)
operator|&&
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DC_FERROR
operator|)
condition|)
block|{
comment|/* decompress this packet */
name|rv
operator|=
call|(
modifier|*
name|sc
operator|->
name|sc_rcomp
operator|->
name|decompress
call|)
argument_list|(
name|sc
operator|->
name|sc_rc_state
argument_list|,
name|m
argument_list|,
operator|&
name|dmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|DECOMP_OK
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmp
operator|==
name|NULL
condition|)
block|{
comment|/* no error, but no decompressed packet produced */
return|return;
block|}
name|m
operator|=
name|dmp
expr_stmt|;
name|cp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|proto
operator|=
name|PPP_PROTOCOL
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 	     * An error has occurred in decompression. 	     * Pass the compressed packet up to pppd, which may take 	     * CCP down or issue a Reset-Req. 	     */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|printf
argument_list|(
literal|"ppp%d: decompress failed %d\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|rv
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|SC_VJ_RESET
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|DECOMP_ERROR
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|SC_DC_ERROR
expr_stmt|;
else|else
name|sc
operator|->
name|sc_flags
operator||=
name|SC_DC_FERROR
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sc_rc_state
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DECOMP_RUN
operator|)
condition|)
block|{
call|(
modifier|*
name|sc
operator|->
name|sc_rcomp
operator|->
name|incomp
call|)
argument_list|(
name|sc
operator|->
name|sc_rc_state
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|proto
operator|==
name|PPP_CCP
condition|)
block|{
name|ppp_ccp
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|ilen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|m
init|;
name|mp
operator|!=
name|NULL
condition|;
name|mp
operator|=
name|mp
operator|->
name|m_next
control|)
name|ilen
operator|+=
name|mp
operator|->
name|m_len
expr_stmt|;
ifdef|#
directive|ifdef
name|VJC
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_VJ_RESET
condition|)
block|{
comment|/* 	 * If we've missed a packet, we must toss subsequent compressed 	 * packets which don't have an explicit connection ID. 	 */
if|if
condition|(
name|sc
operator|->
name|sc_comp
condition|)
name|sl_uncompress_tcp
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|TYPE_ERROR
argument_list|,
name|sc
operator|->
name|sc_comp
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_VJ_RESET
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
comment|/*      * See if we have a VJ-compressed packet to uncompress.      */
if|if
condition|(
name|proto
operator|==
name|PPP_VJC_COMP
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_REJ_COMP_TCP
operator|)
operator|||
name|sc
operator|->
name|sc_comp
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|xlen
operator|=
name|sl_uncompress_tcp_core
argument_list|(
name|cp
operator|+
name|PPP_HDRLEN
argument_list|,
name|m
operator|->
name|m_len
operator|-
name|PPP_HDRLEN
argument_list|,
name|ilen
operator|-
name|PPP_HDRLEN
argument_list|,
name|TYPE_COMPRESSED_TCP
argument_list|,
name|sc
operator|->
name|sc_comp
argument_list|,
operator|&
name|iphdr
argument_list|,
operator|&
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|xlen
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|printf
argument_list|(
literal|"ppp%d: VJ uncompress failed on type comp\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* Copy the PPP and IP headers into a new mbuf. */
name|MGETHDR
argument_list|(
name|mp
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|mp
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hlen
operator|+
name|PPP_HDRLEN
operator|>
name|MHLEN
condition|)
block|{
name|MCLGET
argument_list|(
name|mp
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|mp
argument_list|)
operator|<
name|hlen
operator|+
name|PPP_HDRLEN
condition|)
block|{
name|m_freem
argument_list|(
name|mp
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
comment|/* lose if big headers and no clusters */
block|}
block|}
ifdef|#
directive|ifdef
name|MAC
name|mac_create_mbuf_from_mbuf
argument_list|(
name|m
argument_list|,
name|mp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
name|adrs
expr_stmt|;
name|cp
index|[
literal|1
index|]
operator|=
name|ctrl
expr_stmt|;
name|cp
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|cp
index|[
literal|3
index|]
operator|=
name|PPP_IP
expr_stmt|;
name|proto
operator|=
name|PPP_IP
expr_stmt|;
name|bcopy
argument_list|(
name|iphdr
argument_list|,
name|cp
operator|+
name|PPP_HDRLEN
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_len
operator|=
name|hlen
operator|+
name|PPP_HDRLEN
expr_stmt|;
comment|/* 	 * Trim the PPP and VJ headers off the old mbuf 	 * and stick the new and old mbufs together. 	 */
name|m
operator|->
name|m_data
operator|+=
name|PPP_HDRLEN
operator|+
name|xlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|PPP_HDRLEN
operator|+
name|xlen
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<=
name|M_TRAILINGSPACE
argument_list|(
name|mp
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|mp
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
name|mp
operator|->
name|m_len
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|mp
operator|->
name|m_len
operator|+=
name|m
operator|->
name|m_len
expr_stmt|;
name|mp
operator|->
name|m_next
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
block|}
name|m
operator|=
name|mp
expr_stmt|;
name|ilen
operator|+=
name|hlen
operator|-
name|xlen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|proto
operator|==
name|PPP_VJC_UNCOMP
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_REJ_COMP_TCP
operator|)
operator|||
name|sc
operator|->
name|sc_comp
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
name|xlen
operator|=
name|sl_uncompress_tcp_core
argument_list|(
name|cp
operator|+
name|PPP_HDRLEN
argument_list|,
name|m
operator|->
name|m_len
operator|-
name|PPP_HDRLEN
argument_list|,
name|ilen
operator|-
name|PPP_HDRLEN
argument_list|,
name|TYPE_UNCOMPRESSED_TCP
argument_list|,
name|sc
operator|->
name|sc_comp
argument_list|,
operator|&
name|iphdr
argument_list|,
operator|&
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|xlen
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|printf
argument_list|(
literal|"ppp%d: VJ uncompress failed on type uncomp\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|proto
operator|=
name|PPP_IP
expr_stmt|;
name|cp
index|[
literal|3
index|]
operator|=
name|PPP_IP
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* VJC */
comment|/*      * If the packet will fit in a header mbuf, don't waste a      * whole cluster on it.      */
if|if
condition|(
name|ilen
operator|<=
name|MHLEN
operator|&&
name|M_IS_CLUSTER
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|MGETHDR
argument_list|(
name|mp
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|MAC
name|mac_create_mbuf_from_mbuf
argument_list|(
name|m
argument_list|,
name|mp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|ilen
argument_list|,
name|mtod
argument_list|(
name|mp
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|mp
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|ilen
expr_stmt|;
block|}
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|ilen
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
if|if
condition|(
operator|(
name|proto
operator|&
literal|0x8000
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|PPP_FILTER
comment|/* 	 * See whether we want to pass this packet, and 	 * if it counts as link activity. 	 */
name|adrs
operator|=
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
comment|/* save address field */
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* indicate inbound */
if|if
condition|(
name|sc
operator|->
name|sc_pass_filt
operator|.
name|bf_insns
operator|!=
literal|0
operator|&&
name|bpf_filter
argument_list|(
name|sc
operator|->
name|sc_pass_filt
operator|.
name|bf_insns
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|m
argument_list|,
name|ilen
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* drop this packet */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_active_filt
operator|.
name|bf_insns
operator|==
literal|0
operator|||
name|bpf_filter
argument_list|(
name|sc
operator|->
name|sc_active_filt
operator|.
name|bf_insns
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|m
argument_list|,
name|ilen
argument_list|,
literal|0
argument_list|)
condition|)
name|sc
operator|->
name|sc_last_recv
operator|=
name|time_second
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator|=
name|adrs
expr_stmt|;
else|#
directive|else
comment|/* 	 * Record the time that we received this packet. 	 */
name|sc
operator|->
name|sc_last_recv
operator|=
name|time_second
expr_stmt|;
endif|#
directive|endif
comment|/* PPP_FILTER */
block|}
comment|/* See if bpf wants to look at the packet. */
if|if
condition|(
name|sc
operator|->
name|sc_if
operator|.
name|if_bpf
condition|)
name|bpf_mtap
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|proto
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|PPP_IP
case|:
comment|/* 	 * IP packet - take off the ppp header and pass it up to IP. 	 */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|||
name|sc
operator|->
name|sc_npmode
index|[
name|NP_IP
index|]
operator|!=
name|NPMODE_PASS
condition|)
block|{
comment|/* interface is down - drop the packet. */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|PPP_HDRLEN
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|PPP_HDRLEN
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|PPP_HDRLEN
expr_stmt|;
if|if
condition|(
name|ipflow_fastforward
argument_list|(
name|m
argument_list|)
condition|)
return|return;
name|schednetisr
argument_list|(
name|NETISR_IP
argument_list|)
expr_stmt|;
name|inq
operator|=
operator|&
name|ipintrq
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPX
case|case
name|PPP_IPX
case|:
comment|/* 	 * IPX packet - take off the ppp header and pass it up to IPX. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
comment|/* XXX: || sc->sc_npmode[NP_IPX] != NPMODE_PASS*/
condition|)
block|{
comment|/* interface is down - drop the packet. */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|PPP_HDRLEN
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|PPP_HDRLEN
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|PPP_HDRLEN
expr_stmt|;
name|schednetisr
argument_list|(
name|NETISR_IPX
argument_list|)
expr_stmt|;
name|inq
operator|=
operator|&
name|ipxintrq
expr_stmt|;
name|sc
operator|->
name|sc_last_recv
operator|=
name|time_second
expr_stmt|;
comment|/* update time of last pkt rcvd */
break|break;
endif|#
directive|endif
default|default:
comment|/* 	 * Some other protocol - place on input queue for read(). 	 */
name|inq
operator|=
operator|&
name|sc
operator|->
name|sc_inq
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/*      * Put the packet on the appropriate input queue.      */
if|if
condition|(
operator|!
name|IF_HANDOFF
argument_list|(
name|inq
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|printf
argument_list|(
literal|"ppp%d: input queue full\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_iqdrops
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ifp
operator|->
name|if_ipackets
operator|++
expr_stmt|;
name|ifp
operator|->
name|if_ibytes
operator|+=
name|ilen
expr_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|ifp
operator|->
name|if_lastchange
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
call|(
modifier|*
name|sc
operator|->
name|sc_ctlp
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_stats
operator|.
name|ppp_ierrors
operator|++
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_DUMP_BYTES
value|128
end_define

begin_function
specifier|static
name|void
name|pppdumpm
parameter_list|(
name|m0
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|3
operator|*
name|MAX_DUMP_BYTES
operator|+
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|int
name|l
init|=
name|m
operator|->
name|m_len
decl_stmt|;
name|u_char
modifier|*
name|rptr
init|=
operator|(
name|u_char
operator|*
operator|)
name|m
operator|->
name|m_data
decl_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
block|{
if|if
condition|(
name|bp
operator|>
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|4
condition|)
goto|goto
name|done
goto|;
operator|*
name|bp
operator|++
operator|=
name|hex2ascii
argument_list|(
operator|*
name|rptr
operator|>>
literal|4
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
name|hex2ascii
argument_list|(
operator|*
name|rptr
operator|++
operator|&
literal|0xf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
block|{
if|if
condition|(
name|bp
operator|>
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|3
condition|)
goto|goto
name|done
goto|;
operator|*
name|bp
operator|++
operator|=
literal|'|'
expr_stmt|;
block|}
else|else
operator|*
name|bp
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|m
condition|)
operator|*
name|bp
operator|++
operator|=
literal|'>'
expr_stmt|;
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

