begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * if_ppp.c - Point-to-Point Protocol (PPP) Asynchronous driver.  *  * Copyright (c) 1989 Carnegie Mellon University.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by Carnegie Mellon University.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * Drew D. Perkins  * Carnegie Mellon University  * 4910 Forbes Ave.  * Pittsburgh, PA 15213  * (412) 268-8576  * ddp@andrew.cmu.edu  *  * Based on:  *	@(#)if_sl.c	7.6.1.2 (Berkeley) 2/15/89  *  * Copyright (c) 1987 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * Serial Line interface  *  * Rick Adams  * Center for Seismic Studies  * 1300 N 17th Street, Suite 1450  * Arlington, Virginia 22209  * (703)276-7900  * rick@seismo.ARPA  * seismo!rick  *  * Pounded on heavily by Chris Torek (chris@mimsy.umd.edu, umcp-cs!chris).  * Converted to 4.3BSD Beta by Chris Torek.  * Other changes made at Berkeley, based in part on code by Kirk Smith.  *  * Converted to 4.3BSD+ 386BSD by Brad Parker (brad@cayman.com)  * Added VJ tcp header compression; more unified ioctls  *  * Extensively modified by Paul Mackerras (paulus@cs.anu.edu.au).  * Cleaned up a lot of the mbuf-related code to fix bugs that  * caused system crashes and packet corruption.  Changed pppstart  * so that it doesn't just give up with a collision if the whole  * packet doesn't fit in the output ring buffer.  *  * Added priority queueing for interactive IP packets, following  * the model of if_sl.c, plus hooks for bpf.  * Paul Mackerras (paulus@cs.anu.edu.au).  */
end_comment

begin_comment
comment|/* $Id: if_ppp.c,v 1.7 1994/11/23 08:29:44 ugen Exp $ */
end_comment

begin_comment
comment|/* from if_sl.c,v 1.11 84/10/04 12:54:47 rick Exp */
end_comment

begin_include
include|#
directive|include
file|"ppp.h"
end_include

begin_if
if|#
directive|if
name|NPPP
operator|>
literal|0
end_if

begin_define
define|#
directive|define
name|VJC
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/tty.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_if
if|#
directive|if
name|INET
end_if

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"bpfilter.h"
end_include

begin_if
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VJC
end_ifdef

begin_include
include|#
directive|include
file|<net/pppcompress.h>
end_include

begin_define
define|#
directive|define
name|HDROFF
value|MAX_HDR
end_define

begin_comment
comment|/* HDROFF should really be 128, but other parts of the system will    panic on TCP+IP headers bigger than MAX_HDR = MHLEN (100). */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HDROFF
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if_ppp.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_comment
comment|/* This is a FreeBSD-2.x kernel. */
end_comment

begin_define
define|#
directive|define
name|CCOUNT
parameter_list|(
name|q
parameter_list|)
value|((q)->c_cc)
end_define

begin_define
define|#
directive|define
name|PPP_HIWAT
value|400
end_define

begin_comment
comment|/* Don't start a new packet if HIWAT on que */
end_comment

begin_define
define|#
directive|define
name|PPP_MAXMTU
value|16384
end_define

begin_comment
comment|/* Largest MTU we allow */
end_comment

begin_decl_stmt
name|struct
name|ppp_softc
name|ppp_softc
index|[
name|NPPP
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|pppattach
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pppopen
name|__P
argument_list|(
operator|(
name|dev_t
name|dev
operator|,
expr|struct
name|tty
operator|*
name|tp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pppclose
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|,
name|int
name|flag
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pppread
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|,
expr|struct
name|uio
operator|*
name|uio
operator|,
name|int
name|flag
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pppwrite
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|,
expr|struct
name|uio
operator|*
name|uio
operator|,
name|int
name|flag
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ppptioctl
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|,
name|int
name|cmd
operator|,
name|caddr_t
name|data
operator|,
name|int
name|flag
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pppoutput
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
operator|,
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|sockaddr
operator|*
operator|,
expr|struct
name|rtentry
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pppinput
name|__P
argument_list|(
operator|(
name|int
name|c
operator|,
expr|struct
name|tty
operator|*
name|tp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pppioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|,
name|int
name|cmd
operator|,
name|caddr_t
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pppstart
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|linesw
name|pppdisc
init|=
block|{
name|pppopen
block|,
name|pppclose
block|,
name|pppread
block|,
name|pppwrite
block|,
name|ppptioctl
block|,
name|pppinput
block|,
name|pppstart
block|,
name|nullmodem
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pppasyncstart
name|__P
argument_list|(
operator|(
expr|struct
name|ppp_softc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|pppfcs
name|__P
argument_list|(
operator|(
name|u_short
name|fcs
operator|,
name|u_char
operator|*
name|cp
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pppgetm
name|__P
argument_list|(
operator|(
expr|struct
name|ppp_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|ppp_btom
name|__P
argument_list|(
operator|(
expr|struct
name|ppp_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pppdumpm
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
name|m0
operator|,
name|int
name|pktlen
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pppdumpb
name|__P
argument_list|(
operator|(
name|u_char
operator|*
name|b
operator|,
name|int
name|l
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ppplogchar
name|__P
argument_list|(
operator|(
expr|struct
name|ppp_softc
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Some useful mbuf macros not in mbuf.h.  */
end_comment

begin_define
define|#
directive|define
name|M_DATASTART
parameter_list|(
name|m
parameter_list|)
define|\
value|((m)->m_flags& M_EXT ? (m)->m_ext.ext_buf : \ 	    (m)->m_flags& M_PKTHDR ? (m)->m_pktdat : (m)->m_dat)
end_define

begin_define
define|#
directive|define
name|M_DATASIZE
parameter_list|(
name|m
parameter_list|)
define|\
value|((m)->m_flags& M_EXT ? (m)->m_ext.ext_size : \ 	    (m)->m_flags& M_PKTHDR ? MHLEN: MLEN)
end_define

begin_comment
comment|/*  * The following disgusting hack gets around the problem that IP TOS  * can't be set yet.  We want to put "interactive" traffic on a high  * priority queue.  To decide if traffic is interactive, we check that  * a) it is TCP and b) one of its ports is telnet, rlogin or ftp control.  */
end_comment

begin_decl_stmt
specifier|static
name|u_short
name|interactive_ports
index|[
literal|8
index|]
init|=
block|{
literal|0
block|,
literal|513
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|21
block|,
literal|0
block|,
literal|23
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INTERACTIVE
parameter_list|(
name|p
parameter_list|)
value|(interactive_ports[(p)& 7] == (p))
end_define

begin_comment
comment|/*  * Does c need to be escaped?  */
end_comment

begin_define
define|#
directive|define
name|ESCAPE_P
parameter_list|(
name|c
parameter_list|)
value|(sc->sc_asyncmap[(c)>> 5]& (1<< ((c)& 0x1F)))
end_define

begin_comment
comment|/*  * Called from boot code to establish ppp interfaces.  */
end_comment

begin_function
name|void
name|pppattach
parameter_list|()
block|{
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
name|linesw
index|[
name|PPPDISC
index|]
operator|=
name|pppdisc
expr_stmt|;
for|for
control|(
name|sc
operator|=
name|ppp_softc
init|;
name|i
operator|<
name|NPPP
condition|;
name|sc
operator|++
control|)
block|{
name|sc
operator|->
name|sc_if
operator|.
name|if_name
operator|=
literal|"ppp"
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
operator|=
name|i
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
operator|=
name|PPP_MTU
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|=
name|IFF_POINTOPOINT
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_type
operator|=
name|IFT_PPP
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_hdrlen
operator|=
name|PPP_HDRLEN
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ioctl
operator|=
name|pppioctl
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_output
operator|=
name|pppoutput
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|sc
operator|->
name|sc_inq
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|sc
operator|->
name|sc_fastq
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|if_attach
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
name|bpfattach
argument_list|(
operator|&
name|sc
operator|->
name|sc_bpf
argument_list|,
operator|&
name|sc
operator|->
name|sc_if
argument_list|,
name|DLT_PPP
argument_list|,
name|PPP_HDRLEN
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate a ppp interface unit and initialize it.  */
end_comment

begin_function
name|struct
name|ppp_softc
modifier|*
name|pppalloc
parameter_list|(
name|pid
parameter_list|)
name|pid_t
name|pid
decl_stmt|;
block|{
name|int
name|nppp
decl_stmt|;
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
for|for
control|(
name|nppp
operator|=
literal|0
operator|,
name|sc
operator|=
name|ppp_softc
init|;
name|nppp
operator|<
name|NPPP
condition|;
name|nppp
operator|++
operator|,
name|sc
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_xfer
operator|==
name|pid
condition|)
block|{
name|sc
operator|->
name|sc_xfer
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nppp
operator|>=
name|NPPP
condition|)
for|for
control|(
name|nppp
operator|=
literal|0
operator|,
name|sc
operator|=
name|ppp_softc
init|;
name|nppp
operator|<
name|NPPP
condition|;
name|nppp
operator|++
operator|,
name|sc
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_devp
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|nppp
operator|>=
name|NPPP
condition|)
return|return
name|NULL
return|;
name|sc
operator|->
name|sc_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_mru
operator|=
name|PPP_MRU
expr_stmt|;
ifdef|#
directive|ifdef
name|VJC
name|sl_compress_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_comp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
return|return
name|sc
return|;
block|}
end_function

begin_comment
comment|/*  * Deallocate a ppp unit.  */
end_comment

begin_function
name|void
name|pppdealloc
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|if_down
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_devp
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_xfer
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_inq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_fastq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Line specific open routine for async tty devices.  * Attach the given tty to the first available ppp unit.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|pppopen
parameter_list|(
name|dev
parameter_list|,
name|tp
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|tp
operator|->
name|t_line
operator|==
name|PPPDISC
condition|)
block|{
name|sc
operator|=
operator|(
expr|struct
name|ppp_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
operator|&&
name|sc
operator|->
name|sc_devp
operator|==
operator|(
name|void
operator|*
operator|)
name|tp
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sc
operator|=
name|pppalloc
argument_list|(
name|p
operator|->
name|p_pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
if|if
condition|(
name|sc
operator|->
name|sc_outm
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_outm
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_outm
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pppgetm
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|sc
operator|->
name|sc_asyncmap
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_asyncmap
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_asyncmap
index|[
literal|0
index|]
operator|=
literal|0xffffffff
expr_stmt|;
name|sc
operator|->
name|sc_asyncmap
index|[
literal|3
index|]
operator|=
literal|0x60000000
expr_stmt|;
name|sc
operator|->
name|sc_rasyncmap
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_devp
operator|=
operator|(
name|void
operator|*
operator|)
name|tp
expr_stmt|;
name|sc
operator|->
name|sc_start
operator|=
name|pppasyncstart
expr_stmt|;
name|tp
operator|->
name|t_sc
operator|=
operator|(
name|caddr_t
operator|)
name|sc
expr_stmt|;
name|ttyflush
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
comment|/*      * XXX we fudge t_canq to avoid providing pppselect() and FIONREAD.      * I hope one char is enough.  The following actually gives CBSIZE      * chars.      */
name|clist_alloc_cblocks
argument_list|(
operator|&
name|tp
operator|->
name|t_canq
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|clist_alloc_cblocks
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
operator|+
name|PPP_HIWAT
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
operator|+
name|PPP_HIWAT
argument_list|)
expr_stmt|;
name|clist_alloc_cblocks
argument_list|(
operator|&
name|tp
operator|->
name|t_rawq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Line specific close routine.  * Detach the tty from the ppp unit.  * Mimics part of ttyclose().  */
end_comment

begin_function
name|int
name|pppclose
parameter_list|(
name|tp
parameter_list|,
name|flag
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ttywflush
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* paranoid; splnet probably ok */
name|clist_free_cblocks
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_line
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|ppp_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
name|tp
operator|->
name|t_sc
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tp
operator|==
operator|(
expr|struct
name|tty
operator|*
operator|)
name|sc
operator|->
name|sc_devp
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_outm
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_outm
operator|=
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_m
operator|=
name|NULL
expr_stmt|;
name|pppdealloc
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
end_function

begin_comment
comment|/*  * Line specific (tty) read routine.  */
end_comment

begin_function
name|int
name|pppread
parameter_list|(
name|tp
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ppp_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
operator|&&
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* end of file */
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|tp
operator|!=
operator|(
expr|struct
name|tty
operator|*
operator|)
name|sc
operator|->
name|sc_devp
condition|)
return|return
literal|0
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|sc_inq
operator|.
name|ifq_head
operator|==
name|NULL
operator|&&
name|tp
operator|->
name|t_line
operator|==
name|PPPDISC
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASYNC
operator|||
name|flag
operator|&
name|IO_NDELAY
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
block|}
name|error
operator|=
name|ttysleep
argument_list|(
name|tp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_rawq
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
name|ttyin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_line
operator|!=
name|PPPDISC
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Pull place-holder byte out of canonical queue */
name|getc
argument_list|(
operator|&
name|tp
operator|->
name|t_canq
argument_list|)
expr_stmt|;
comment|/* Get the packet from the input queue */
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_inq
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|&&
name|uio
operator|->
name|uio_resid
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
if|if
condition|(
name|error
operator|=
name|uiomove
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|uio
argument_list|)
condition|)
break|break;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Line specific (tty) write routine.  */
end_comment

begin_function
name|int
name|pppwrite
parameter_list|(
name|tp
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ppp_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|;
name|struct
name|sockaddr
name|dst
decl_stmt|;
name|struct
name|ppp_header
modifier|*
name|ph1
decl_stmt|,
modifier|*
name|ph2
decl_stmt|;
name|int
name|len
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
operator|&&
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* wrote 0 bytes */
if|if
condition|(
name|tp
operator|->
name|t_line
operator|!=
name|PPPDISC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|tp
operator|!=
operator|(
expr|struct
name|tty
operator|*
operator|)
name|sc
operator|->
name|sc_devp
condition|)
return|return
name|EIO
return|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|>
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
operator|+
name|PPP_HDRLEN
operator|||
name|uio
operator|->
name|uio_resid
operator|<
name|PPP_HDRLEN
condition|)
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
for|for
control|(
name|mp
operator|=
operator|&
name|m0
init|;
name|uio
operator|->
name|uio_resid
condition|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
control|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_WAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|mp
operator|=
name|m
operator|)
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|>=
name|MCLBYTES
operator|/
literal|2
condition|)
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|len
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|uio
operator|->
name|uio_resid
condition|)
name|len
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|uiomove
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|len
argument_list|,
name|uio
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
block|}
name|dst
operator|.
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|ph1
operator|=
operator|(
expr|struct
name|ppp_header
operator|*
operator|)
operator|&
name|dst
operator|.
name|sa_data
expr_stmt|;
name|ph2
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ppp_header
operator|*
argument_list|)
expr_stmt|;
operator|*
name|ph1
operator|=
operator|*
name|ph2
expr_stmt|;
name|m0
operator|->
name|m_data
operator|+=
name|PPP_HDRLEN
expr_stmt|;
name|m0
operator|->
name|m_len
operator|-=
name|PPP_HDRLEN
expr_stmt|;
return|return
operator|(
name|pppoutput
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|,
name|m0
argument_list|,
operator|&
name|dst
argument_list|,
operator|(
expr|struct
name|rtentry
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Line specific (tty) ioctl routine.  * Provide a way to get the ppp unit number.  * This discipline requires that tty device drivers call  * the line specific l_ioctl routine from their ioctl routines.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|ppptioctl
parameter_list|(
name|tp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|,
name|p
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|cmd
decl_stmt|,
name|flag
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ppp_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|,
name|flags
decl_stmt|,
name|mru
decl_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|tp
operator|!=
operator|(
expr|struct
name|tty
operator|*
operator|)
name|sc
operator|->
name|sc_devp
condition|)
return|return
operator|-
literal|1
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|FIONREAD
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_inq
operator|.
name|ifq_len
expr_stmt|;
break|break;
case|case
name|PPPIOCGUNIT
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
expr_stmt|;
break|break;
case|case
name|PPPIOCGFLAGS
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_flags
expr_stmt|;
break|break;
case|case
name|PPPIOCSFLAGS
case|:
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|flags
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|&
name|SC_MASK
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
operator|(
name|sc
operator|->
name|sc_flags
operator|&
operator|~
name|SC_MASK
operator|)
operator||
name|flags
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPPIOCSASYNCMAP
case|:
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|sc_asyncmap
index|[
literal|0
index|]
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
expr_stmt|;
break|break;
case|case
name|PPPIOCGASYNCMAP
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_asyncmap
index|[
literal|0
index|]
expr_stmt|;
break|break;
case|case
name|PPPIOCSRASYNCMAP
case|:
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|sc_rasyncmap
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
expr_stmt|;
break|break;
case|case
name|PPPIOCGRASYNCMAP
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_rasyncmap
expr_stmt|;
break|break;
case|case
name|PPPIOCSXASYNCMAP
case|:
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|sc
operator|->
name|sc_asyncmap
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_asyncmap
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_asyncmap
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* mustn't escape 0x20 - 0x3f */
name|sc
operator|->
name|sc_asyncmap
index|[
literal|2
index|]
operator|&=
operator|~
literal|0x40000000
expr_stmt|;
comment|/* mustn't escape 0x5e */
name|sc
operator|->
name|sc_asyncmap
index|[
literal|3
index|]
operator||=
literal|0x60000000
expr_stmt|;
comment|/* must escape 0x7d, 0x7e */
break|break;
case|case
name|PPPIOCGXASYNCMAP
case|:
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_asyncmap
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_asyncmap
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPPIOCSMRU
case|:
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|mru
operator|=
operator|*
operator|(
name|int
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|mru
operator|>=
name|PPP_MRU
operator|&&
name|mru
operator|<=
name|PPP_MAXMRU
condition|)
block|{
name|sc
operator|->
name|sc_mru
operator|=
name|mru
expr_stmt|;
if|if
condition|(
name|pppgetm
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
name|sc
operator|->
name|sc_mru
operator|=
name|PPP_MRU
expr_stmt|;
if|if
condition|(
name|pppgetm
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
block|}
block|}
break|break;
case|case
name|PPPIOCGMRU
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_mru
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|VJC
case|case
name|PPPIOCSMAXCID
case|:
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sl_compress_setup
argument_list|(
operator|&
name|sc
operator|->
name|sc_comp
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|PPPIOCXFERUNIT
case|:
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|sc_xfer
operator|=
name|p
operator|->
name|p_pid
expr_stmt|;
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * FCS lookup table as calculated by genfcstab.  */
end_comment

begin_decl_stmt
specifier|static
name|u_short
name|fcstab
index|[
literal|256
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x1189
block|,
literal|0x2312
block|,
literal|0x329b
block|,
literal|0x4624
block|,
literal|0x57ad
block|,
literal|0x6536
block|,
literal|0x74bf
block|,
literal|0x8c48
block|,
literal|0x9dc1
block|,
literal|0xaf5a
block|,
literal|0xbed3
block|,
literal|0xca6c
block|,
literal|0xdbe5
block|,
literal|0xe97e
block|,
literal|0xf8f7
block|,
literal|0x1081
block|,
literal|0x0108
block|,
literal|0x3393
block|,
literal|0x221a
block|,
literal|0x56a5
block|,
literal|0x472c
block|,
literal|0x75b7
block|,
literal|0x643e
block|,
literal|0x9cc9
block|,
literal|0x8d40
block|,
literal|0xbfdb
block|,
literal|0xae52
block|,
literal|0xdaed
block|,
literal|0xcb64
block|,
literal|0xf9ff
block|,
literal|0xe876
block|,
literal|0x2102
block|,
literal|0x308b
block|,
literal|0x0210
block|,
literal|0x1399
block|,
literal|0x6726
block|,
literal|0x76af
block|,
literal|0x4434
block|,
literal|0x55bd
block|,
literal|0xad4a
block|,
literal|0xbcc3
block|,
literal|0x8e58
block|,
literal|0x9fd1
block|,
literal|0xeb6e
block|,
literal|0xfae7
block|,
literal|0xc87c
block|,
literal|0xd9f5
block|,
literal|0x3183
block|,
literal|0x200a
block|,
literal|0x1291
block|,
literal|0x0318
block|,
literal|0x77a7
block|,
literal|0x662e
block|,
literal|0x54b5
block|,
literal|0x453c
block|,
literal|0xbdcb
block|,
literal|0xac42
block|,
literal|0x9ed9
block|,
literal|0x8f50
block|,
literal|0xfbef
block|,
literal|0xea66
block|,
literal|0xd8fd
block|,
literal|0xc974
block|,
literal|0x4204
block|,
literal|0x538d
block|,
literal|0x6116
block|,
literal|0x709f
block|,
literal|0x0420
block|,
literal|0x15a9
block|,
literal|0x2732
block|,
literal|0x36bb
block|,
literal|0xce4c
block|,
literal|0xdfc5
block|,
literal|0xed5e
block|,
literal|0xfcd7
block|,
literal|0x8868
block|,
literal|0x99e1
block|,
literal|0xab7a
block|,
literal|0xbaf3
block|,
literal|0x5285
block|,
literal|0x430c
block|,
literal|0x7197
block|,
literal|0x601e
block|,
literal|0x14a1
block|,
literal|0x0528
block|,
literal|0x37b3
block|,
literal|0x263a
block|,
literal|0xdecd
block|,
literal|0xcf44
block|,
literal|0xfddf
block|,
literal|0xec56
block|,
literal|0x98e9
block|,
literal|0x8960
block|,
literal|0xbbfb
block|,
literal|0xaa72
block|,
literal|0x6306
block|,
literal|0x728f
block|,
literal|0x4014
block|,
literal|0x519d
block|,
literal|0x2522
block|,
literal|0x34ab
block|,
literal|0x0630
block|,
literal|0x17b9
block|,
literal|0xef4e
block|,
literal|0xfec7
block|,
literal|0xcc5c
block|,
literal|0xddd5
block|,
literal|0xa96a
block|,
literal|0xb8e3
block|,
literal|0x8a78
block|,
literal|0x9bf1
block|,
literal|0x7387
block|,
literal|0x620e
block|,
literal|0x5095
block|,
literal|0x411c
block|,
literal|0x35a3
block|,
literal|0x242a
block|,
literal|0x16b1
block|,
literal|0x0738
block|,
literal|0xffcf
block|,
literal|0xee46
block|,
literal|0xdcdd
block|,
literal|0xcd54
block|,
literal|0xb9eb
block|,
literal|0xa862
block|,
literal|0x9af9
block|,
literal|0x8b70
block|,
literal|0x8408
block|,
literal|0x9581
block|,
literal|0xa71a
block|,
literal|0xb693
block|,
literal|0xc22c
block|,
literal|0xd3a5
block|,
literal|0xe13e
block|,
literal|0xf0b7
block|,
literal|0x0840
block|,
literal|0x19c9
block|,
literal|0x2b52
block|,
literal|0x3adb
block|,
literal|0x4e64
block|,
literal|0x5fed
block|,
literal|0x6d76
block|,
literal|0x7cff
block|,
literal|0x9489
block|,
literal|0x8500
block|,
literal|0xb79b
block|,
literal|0xa612
block|,
literal|0xd2ad
block|,
literal|0xc324
block|,
literal|0xf1bf
block|,
literal|0xe036
block|,
literal|0x18c1
block|,
literal|0x0948
block|,
literal|0x3bd3
block|,
literal|0x2a5a
block|,
literal|0x5ee5
block|,
literal|0x4f6c
block|,
literal|0x7df7
block|,
literal|0x6c7e
block|,
literal|0xa50a
block|,
literal|0xb483
block|,
literal|0x8618
block|,
literal|0x9791
block|,
literal|0xe32e
block|,
literal|0xf2a7
block|,
literal|0xc03c
block|,
literal|0xd1b5
block|,
literal|0x2942
block|,
literal|0x38cb
block|,
literal|0x0a50
block|,
literal|0x1bd9
block|,
literal|0x6f66
block|,
literal|0x7eef
block|,
literal|0x4c74
block|,
literal|0x5dfd
block|,
literal|0xb58b
block|,
literal|0xa402
block|,
literal|0x9699
block|,
literal|0x8710
block|,
literal|0xf3af
block|,
literal|0xe226
block|,
literal|0xd0bd
block|,
literal|0xc134
block|,
literal|0x39c3
block|,
literal|0x284a
block|,
literal|0x1ad1
block|,
literal|0x0b58
block|,
literal|0x7fe7
block|,
literal|0x6e6e
block|,
literal|0x5cf5
block|,
literal|0x4d7c
block|,
literal|0xc60c
block|,
literal|0xd785
block|,
literal|0xe51e
block|,
literal|0xf497
block|,
literal|0x8028
block|,
literal|0x91a1
block|,
literal|0xa33a
block|,
literal|0xb2b3
block|,
literal|0x4a44
block|,
literal|0x5bcd
block|,
literal|0x6956
block|,
literal|0x78df
block|,
literal|0x0c60
block|,
literal|0x1de9
block|,
literal|0x2f72
block|,
literal|0x3efb
block|,
literal|0xd68d
block|,
literal|0xc704
block|,
literal|0xf59f
block|,
literal|0xe416
block|,
literal|0x90a9
block|,
literal|0x8120
block|,
literal|0xb3bb
block|,
literal|0xa232
block|,
literal|0x5ac5
block|,
literal|0x4b4c
block|,
literal|0x79d7
block|,
literal|0x685e
block|,
literal|0x1ce1
block|,
literal|0x0d68
block|,
literal|0x3ff3
block|,
literal|0x2e7a
block|,
literal|0xe70e
block|,
literal|0xf687
block|,
literal|0xc41c
block|,
literal|0xd595
block|,
literal|0xa12a
block|,
literal|0xb0a3
block|,
literal|0x8238
block|,
literal|0x93b1
block|,
literal|0x6b46
block|,
literal|0x7acf
block|,
literal|0x4854
block|,
literal|0x59dd
block|,
literal|0x2d62
block|,
literal|0x3ceb
block|,
literal|0x0e70
block|,
literal|0x1ff9
block|,
literal|0xf78f
block|,
literal|0xe606
block|,
literal|0xd49d
block|,
literal|0xc514
block|,
literal|0xb1ab
block|,
literal|0xa022
block|,
literal|0x92b9
block|,
literal|0x8330
block|,
literal|0x7bc7
block|,
literal|0x6a4e
block|,
literal|0x58d5
block|,
literal|0x495c
block|,
literal|0x3de3
block|,
literal|0x2c6a
block|,
literal|0x1ef1
block|,
literal|0x0f78
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Calculate a new FCS given the current FCS and the new data.  */
end_comment

begin_function
specifier|static
name|u_short
name|pppfcs
parameter_list|(
name|fcs
parameter_list|,
name|cp
parameter_list|,
name|len
parameter_list|)
specifier|register
name|u_short
name|fcs
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
while|while
condition|(
name|len
operator|--
condition|)
name|fcs
operator|=
name|PPP_FCS
argument_list|(
name|fcs
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
name|fcs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Queue a packet.  Start transmission if not active.  * Packet is placed in Information field of PPP frame.  */
end_comment

begin_function
name|int
name|pppoutput
parameter_list|(
name|ifp
parameter_list|,
name|m0
parameter_list|,
name|dst
parameter_list|,
name|rt
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
block|{
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
init|=
operator|&
name|ppp_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|struct
name|ppp_header
modifier|*
name|ph
decl_stmt|;
name|int
name|protocol
decl_stmt|,
name|address
decl_stmt|,
name|control
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|ifqueue
modifier|*
name|ifq
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_devp
operator|==
name|NULL
operator|||
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
operator|||
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
name|dst
operator|->
name|sa_family
operator|!=
name|AF_UNSPEC
condition|)
block|{
name|error
operator|=
name|ENETDOWN
expr_stmt|;
comment|/* sort of */
goto|goto
name|bad
goto|;
block|}
comment|/*      * Compute PPP header.      */
name|address
operator|=
name|PPP_ALLSTATIONS
expr_stmt|;
name|control
operator|=
name|PPP_UI
expr_stmt|;
name|ifq
operator|=
operator|&
name|ifp
operator|->
name|if_snd
expr_stmt|;
switch|switch
condition|(
name|dst
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|protocol
operator|=
name|PPP_IP
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_ENABLE_IP
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENETDOWN
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * If this is a TCP packet to or from an "interactive" port, 	 * put the packet on the fastq instead. 	 */
if|if
condition|(
operator|(
name|ip
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
operator|)
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
condition|)
block|{
specifier|register
name|int
name|p
init|=
name|ntohl
argument_list|(
operator|(
operator|(
name|int
operator|*
operator|)
name|ip
operator|)
index|[
name|ip
operator|->
name|ip_hl
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|INTERACTIVE
argument_list|(
name|p
operator|&
literal|0xffff
argument_list|)
operator|||
name|INTERACTIVE
argument_list|(
name|p
operator|>>
literal|16
argument_list|)
condition|)
name|ifq
operator|=
operator|&
name|sc
operator|->
name|sc_fastq
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
case|case
name|AF_NS
case|:
name|protocol
operator|=
name|PPP_XNS
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|AF_UNSPEC
case|:
name|ph
operator|=
operator|(
expr|struct
name|ppp_header
operator|*
operator|)
name|dst
operator|->
name|sa_data
expr_stmt|;
name|address
operator|=
name|ph
operator|->
name|ph_address
expr_stmt|;
name|control
operator|=
name|ph
operator|->
name|ph_control
expr_stmt|;
name|protocol
operator|=
name|ntohs
argument_list|(
name|ph
operator|->
name|ph_protocol
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ppp%d: af%d not supported\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/*      * Add PPP header.  If no space in first mbuf, allocate another.      * (This assumes M_LEADINGSPACE is always 0 for a cluster mbuf.)      */
if|if
condition|(
name|M_LEADINGSPACE
argument_list|(
name|m0
argument_list|)
operator|<
name|PPP_HDRLEN
condition|)
block|{
name|m0
operator|=
name|m_prepend
argument_list|(
name|m0
argument_list|,
name|PPP_HDRLEN
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|m0
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|m0
operator|->
name|m_data
operator|-=
name|PPP_HDRLEN
expr_stmt|;
name|cp
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|address
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|control
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|protocol
operator|>>
literal|8
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|protocol
operator|&
literal|0xff
expr_stmt|;
name|m0
operator|->
name|m_len
operator|+=
name|PPP_HDRLEN
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_LOG_OUTPKT
condition|)
block|{
name|printf
argument_list|(
literal|"ppp%d output: "
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|pppdumpm
argument_list|(
name|m0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* See if bpf wants to look at the packet. */
if|if
condition|(
name|sc
operator|->
name|sc_bpf
condition|)
name|bpf_mtap
argument_list|(
name|sc
operator|->
name|sc_bpf
argument_list|,
name|m0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*      * Put the packet on the appropriate queue.      */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
name|ifq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|IF_ENQUEUE
argument_list|(
name|ifq
argument_list|,
name|m0
argument_list|)
expr_stmt|;
comment|/*      * Tell the device to send it out.      */
call|(
modifier|*
name|sc
operator|->
name|sc_start
call|)
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Grab another packet off a queue and apply VJ compression,  * address/control and/or protocol compression if appropriate.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ppp_dequeue
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|address
decl_stmt|,
name|control
decl_stmt|,
name|protocol
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_fastq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/*      * Extract the ppp header of the new packet.      * The ppp header will be in one mbuf.      */
name|cp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|address
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
name|control
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
name|protocol
operator|=
operator|(
name|cp
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator|+
name|cp
index|[
literal|3
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|VJC
comment|/*      * If the packet is a TCP/IP packet, see if we can compress it.      */
if|if
condition|(
name|protocol
operator|==
name|PPP_IP
operator|&&
name|sc
operator|->
name|sc_flags
operator|&
name|SC_COMP_TCP
condition|)
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|type
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mp
decl_stmt|;
name|mp
operator|=
name|m
expr_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|cp
operator|+
name|PPP_HDRLEN
operator|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|m_len
operator|<=
name|PPP_HDRLEN
condition|)
block|{
name|mp
operator|=
name|mp
operator|->
name|m_next
expr_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|mp
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
comment|/* this code assumes the IP/TCP header is in one non-shared mbuf */
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
condition|)
block|{
name|type
operator|=
name|sl_compress_tcp
argument_list|(
name|mp
argument_list|,
name|ip
argument_list|,
operator|&
name|sc
operator|->
name|sc_comp
argument_list|,
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_NO_TCP_CCID
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYPE_UNCOMPRESSED_TCP
case|:
name|protocol
operator|=
name|PPP_VJC_UNCOMP
expr_stmt|;
break|break;
case|case
name|TYPE_COMPRESSED_TCP
case|:
name|protocol
operator|=
name|PPP_VJC_COMP
expr_stmt|;
name|cp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
name|address
expr_stmt|;
comment|/* header has moved */
name|cp
index|[
literal|1
index|]
operator|=
name|control
expr_stmt|;
name|cp
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|cp
index|[
literal|3
index|]
operator|=
name|protocol
expr_stmt|;
comment|/* update protocol in PPP header */
block|}
block|}
endif|#
directive|endif
comment|/* VJC */
ifdef|#
directive|ifdef
name|BSD_COMP
if|if
condition|(
name|protocol
operator|<
name|PPP_COMP
operator|&&
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_BSD_COMP
operator|)
condition|)
block|{
name|slen
operator|=
name|m_totallen
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|clen
operator|=
name|pf_bsd_comp
argument_list|(
name|sc
operator|->
name|sc_bsd_db
argument_list|,
name|cbuf
argument_list|,
name|proto
argument_list|,
name|m0
argument_list|,
name|slen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* BSD_COMP */
comment|/*      * Compress the address/control and protocol, if possible.      */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_COMP_AC
operator|&&
name|address
operator|==
name|PPP_ALLSTATIONS
operator|&&
name|control
operator|==
name|PPP_UI
operator|&&
name|protocol
operator|!=
name|PPP_ALLSTATIONS
operator|&&
name|protocol
operator|!=
name|PPP_LCP
condition|)
block|{
comment|/* can compress address/control */
name|m
operator|->
name|m_data
operator|+=
literal|2
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_COMP_PROT
operator|&&
name|protocol
operator|<
literal|0xFF
condition|)
block|{
comment|/* can compress protocol */
if|if
condition|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
operator|==
name|cp
condition|)
block|{
name|cp
index|[
literal|2
index|]
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
comment|/* move address/control up */
name|cp
index|[
literal|1
index|]
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
block|}
operator|++
name|m
operator|->
name|m_data
expr_stmt|;
operator|--
name|m
operator|->
name|m_len
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * This gets called from pppoutput when a new packet is  * put on a queue.  */
end_comment

begin_function
specifier|static
name|int
name|pppasyncstart
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
init|=
operator|(
expr|struct
name|tty
operator|*
operator|)
name|sc
operator|->
name|sc_devp
decl_stmt|;
name|pppstart
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Start output on async tty interface.  Get another datagram  * to send from the interface queue and start sending it.  */
end_comment

begin_function
name|int
name|pppstart
parameter_list|(
name|tp
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ppp_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|start
decl_stmt|,
modifier|*
name|stop
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|n
decl_stmt|,
name|s
decl_stmt|,
name|ndone
decl_stmt|,
name|done
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m2
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
operator|&&
operator|(
name|tp
operator|->
name|t_cflag
operator|&
name|CLOCAL
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* sorry, I can't talk now */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|tp
operator|!=
operator|(
expr|struct
name|tty
operator|*
operator|)
name|sc
operator|->
name|sc_devp
condition|)
block|{
call|(
modifier|*
name|tp
operator|->
name|t_oproc
call|)
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 	 * If there is more in the output queue, just send it now. 	 * We are being called in lieu of ttstart and must do what 	 * it would. 	 */
if|if
condition|(
name|CCOUNT
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
operator|!=
literal|0
operator|&&
name|tp
operator|->
name|t_oproc
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|tp
operator|->
name|t_oproc
call|)
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|CCOUNT
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
operator|>
name|PPP_HIWAT
condition|)
return|return
literal|0
return|;
block|}
comment|/* 	 * See if we have an existing packet partly sent. 	 * If not, get a new packet and start sending it. 	 * We take packets on the priority queue ahead of those 	 * on the normal queue. 	 */
name|m
operator|=
name|sc
operator|->
name|sc_outm
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* 	     * Get another packet to be sent 	     */
name|m
operator|=
name|ppp_dequeue
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* 	     * The extra PPP_FLAG will start up a new packet, and thus 	     * will flush any accumulated garbage.  We do this whenever 	     * the line may have been idle for some time. 	     */
if|if
condition|(
name|CCOUNT
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|sc
operator|->
name|sc_bytessent
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
name|PPP_FLAG
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
comment|/* Calculate the FCS for the first mbuf's worth. */
name|sc
operator|->
name|sc_outfcs
operator|=
name|pppfcs
argument_list|(
name|PPP_INITFCS
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|start
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|stop
operator|=
name|start
operator|+
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Find out how many bytes in the string we can 		 * handle without doing something special. 		 */
for|for
control|(
name|cp
operator|=
name|start
init|;
name|cp
operator|<
name|stop
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|ESCAPE_P
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
break|break;
name|n
operator|=
name|cp
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
comment|/* NetBSD (0.9 or later), 4.3-Reno or similar. */
name|ndone
operator|=
name|n
operator|-
name|b_to_q
argument_list|(
name|start
argument_list|,
name|n
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
name|len
operator|-=
name|ndone
expr_stmt|;
name|start
operator|+=
name|ndone
expr_stmt|;
name|sc
operator|->
name|sc_bytessent
operator|+=
name|ndone
expr_stmt|;
if|if
condition|(
name|ndone
operator|<
name|n
condition|)
break|break;
comment|/* packet doesn't fit */
block|}
comment|/* 		 * If there are characters left in the mbuf, 		 * the first one must be special.. 		 * Put it out in a different form. 		 */
if|if
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|putc
argument_list|(
name|PPP_ESCAPE
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
break|break;
if|if
condition|(
name|putc
argument_list|(
operator|*
name|start
operator|^
name|PPP_TRANS
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|unputc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|sc_bytessent
operator|+=
literal|2
expr_stmt|;
name|start
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
block|}
comment|/* 	     * If we didn't empty this mbuf, remember where we're up to. 	     * If we emptied the last mbuf, try to add the FCS and closing 	     * flag, and if we can't, leave sc_outm pointing to m, but with 	     * m->m_len == 0, to remind us to output the FCS and flag later. 	     */
name|done
operator|=
name|len
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|done
operator|&&
name|m
operator|->
name|m_next
operator|==
name|NULL
condition|)
block|{
name|u_char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|int
name|c
decl_stmt|;
name|u_char
name|endseq
index|[
literal|8
index|]
decl_stmt|;
comment|/* 		 * We may have to escape the bytes in the FCS. 		 */
name|p
operator|=
name|endseq
expr_stmt|;
name|c
operator|=
operator|~
name|sc
operator|->
name|sc_outfcs
operator|&
literal|0xFF
expr_stmt|;
if|if
condition|(
name|ESCAPE_P
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|PPP_ESCAPE
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
operator|^
name|PPP_TRANS
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
operator|(
operator|~
name|sc
operator|->
name|sc_outfcs
operator|>>
literal|8
operator|)
operator|&
literal|0xFF
expr_stmt|;
if|if
condition|(
name|ESCAPE_P
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|PPP_ESCAPE
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|c
operator|^
name|PPP_TRANS
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|PPP_FLAG
expr_stmt|;
comment|/* 		 * Try to output the FCS and flag.  If the bytes 		 * don't all fit, back out. 		 */
for|for
control|(
name|q
operator|=
name|endseq
init|;
name|q
operator|<
name|p
condition|;
operator|++
name|q
control|)
if|if
condition|(
name|putc
argument_list|(
operator|*
name|q
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
block|{
name|done
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|q
operator|>
name|endseq
condition|;
operator|--
name|q
control|)
name|unputc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|m
operator|->
name|m_data
operator|=
name|start
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|sc
operator|->
name|sc_outm
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_oproc
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|tp
operator|->
name|t_oproc
call|)
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* can't do any more at the moment */
block|}
comment|/* Finished with this mbuf; free it and move on. */
name|MFREE
argument_list|(
name|m
argument_list|,
name|m2
argument_list|)
expr_stmt|;
if|if
condition|(
name|m2
operator|==
name|NULL
condition|)
break|break;
name|m
operator|=
name|m2
expr_stmt|;
name|sc
operator|->
name|sc_outfcs
operator|=
name|pppfcs
argument_list|(
name|sc
operator|->
name|sc_outfcs
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
comment|/* Finished a packet */
name|sc
operator|->
name|sc_outm
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_bytessent
operator|++
expr_stmt|;
comment|/* account for closing flag */
name|sc
operator|->
name|sc_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_obytes
operator|=
name|sc
operator|->
name|sc_bytessent
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate enough mbuf to handle current MRU.  */
end_comment

begin_function
specifier|static
name|int
name|pppgetm
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|;
name|int
name|len
init|=
name|HDROFF
operator|+
name|sc
operator|->
name|sc_mru
operator|+
name|PPP_HDRLEN
operator|+
name|PPP_FCSLEN
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
for|for
control|(
name|mp
operator|=
operator|&
name|sc
operator|->
name|sc_m
init|;
operator|(
name|m
operator|=
operator|*
name|mp
operator|)
operator|!=
name|NULL
condition|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
control|)
if|if
condition|(
operator|(
name|len
operator|-=
name|M_DATASIZE
argument_list|(
name|m
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
for|for
control|(
init|;
condition|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
control|)
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_m
operator|=
name|NULL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ppp%d: can't allocate mbuf\n"
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|-=
name|M_DATASIZE
argument_list|(
name|m
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Copy mbuf chain.  Would like to use m_copy(), but we need a real copy  * of the data, not just copies of pointers to the data.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|ppp_btom
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
init|=
name|sc
operator|->
name|sc_m
decl_stmt|;
comment|/*      * First check current mbuf.  If we have more than a small mbuf,      * return the whole cluster and set beginning of buffer to the      * next mbuf.      * Else, copy the current bytes into a small mbuf, attach the new      * mbuf to the end of the chain and set beginning of buffer to the      * current mbuf.      */
if|if
condition|(
name|sc
operator|->
name|sc_mc
operator|->
name|m_len
operator|>
name|MHLEN
condition|)
block|{
name|sc
operator|->
name|sc_m
operator|=
name|sc
operator|->
name|sc_mc
operator|->
name|m_next
expr_stmt|;
name|sc
operator|->
name|sc_mc
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* rather than waste a whole cluster on<= MHLEN bytes, 	   alloc a small mbuf and copy to it */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|sc
operator|->
name|sc_mc
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_mc
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|sc
operator|->
name|sc_mc
operator|->
name|m_len
expr_stmt|;
for|for
control|(
name|mp
operator|=
operator|&
name|top
init|;
operator|*
name|mp
operator|!=
name|sc
operator|->
name|sc_mc
condition|;
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
control|)
empty_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|sc
operator|->
name|sc_m
operator|=
name|sc
operator|->
name|sc_mc
expr_stmt|;
block|}
comment|/*      * Try to allocate enough extra mbufs to handle the next packet.      */
if|if
condition|(
name|pppgetm
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|pppgetm
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * PPP packet input routine.  * The caller has checked and removed the FCS.  * The return value is 1 if the packet was put on sc->sc_inq,  * 0 otherwise.  */
end_comment

begin_define
define|#
directive|define
name|COMPTYPE
parameter_list|(
name|proto
parameter_list|)
value|((proto) == PPP_VJC_COMP? TYPE_COMPRESSED_TCP: \ 			 TYPE_UNCOMPRESSED_TCP)
end_define

begin_function
name|int
name|ppppktin
parameter_list|(
name|sc
parameter_list|,
name|m
parameter_list|,
name|ilen
parameter_list|)
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|ilen
decl_stmt|;
block|{
name|struct
name|ifqueue
modifier|*
name|inq
decl_stmt|;
name|int
name|s
decl_stmt|,
name|xlen
decl_stmt|,
name|proto
decl_stmt|,
name|rv
decl_stmt|;
name|struct
name|ppp_header
name|hdr
decl_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
name|hdr
operator|=
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ppp_header
operator|*
argument_list|)
expr_stmt|;
name|proto
operator|=
name|ntohs
argument_list|(
name|hdr
operator|.
name|ph_protocol
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VJC
comment|/*      * See if we have a VJ-compressed packet to uncompress.      */
if|if
condition|(
name|proto
operator|==
name|PPP_VJC_COMP
operator|||
name|proto
operator|==
name|PPP_VJC_UNCOMP
condition|)
block|{
name|char
modifier|*
name|pkttype
init|=
name|proto
operator|==
name|PPP_VJC_COMP
condition|?
literal|""
else|:
literal|"un"
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_REJ_COMP_TCP
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|printf
argument_list|(
literal|"ppp%d: %scomp pkt w/o compression; flags 0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
argument_list|,
name|pkttype
argument_list|,
name|sc
operator|->
name|sc_flags
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
name|m
operator|->
name|m_data
operator|+=
name|PPP_HDRLEN
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|PPP_HDRLEN
expr_stmt|;
name|ilen
operator|-=
name|PPP_HDRLEN
expr_stmt|;
name|xlen
operator|=
name|sl_uncompress_tcp_part
argument_list|(
operator|(
name|u_char
operator|*
operator|*
operator|)
operator|(
operator|&
name|m
operator|->
name|m_data
operator|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|ilen
argument_list|,
name|COMPTYPE
argument_list|(
name|proto
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sc_comp
argument_list|)
expr_stmt|;
if|if
condition|(
name|xlen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|printf
argument_list|(
literal|"ppp%d: sl_uncompress failed on type %scomp\n"
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
argument_list|,
name|pkttype
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* adjust the first mbuf by the decompressed amt */
name|xlen
operator|+=
name|PPP_HDRLEN
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|xlen
operator|-
name|ilen
expr_stmt|;
name|ilen
operator|=
name|xlen
expr_stmt|;
name|m
operator|->
name|m_data
operator|-=
name|PPP_HDRLEN
expr_stmt|;
name|proto
operator|=
name|PPP_IP
expr_stmt|;
comment|/* put the ppp header back in place */
name|hdr
operator|.
name|ph_protocol
operator|=
name|htons
argument_list|(
name|PPP_IP
argument_list|)
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ppp_header
operator|*
argument_list|)
operator|=
name|hdr
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* VJC */
comment|/* get this packet as an mbuf chain */
if|if
condition|(
operator|(
name|m
operator|=
name|ppp_btom
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|ilen
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|sc
operator|->
name|sc_if
expr_stmt|;
if|#
directive|if
name|NBPFILTER
operator|>
literal|0
comment|/* See if bpf wants to look at the packet. */
if|if
condition|(
name|sc
operator|->
name|sc_bpf
condition|)
name|bpf_mtap
argument_list|(
name|sc
operator|->
name|sc_bpf
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|proto
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|PPP_IP
case|:
comment|/* 	 * IP packet - take off the ppp header and pass it up to IP. 	 */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|||
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_ENABLE_IP
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* interface is down - drop the packet. */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|PPP_HDRLEN
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|PPP_HDRLEN
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|PPP_HDRLEN
expr_stmt|;
name|schednetisr
argument_list|(
name|NETISR_IP
argument_list|)
expr_stmt|;
name|inq
operator|=
operator|&
name|ipintrq
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* 	 * Some other protocol - place on input queue for read(). 	 */
name|inq
operator|=
operator|&
name|sc
operator|->
name|sc_inq
expr_stmt|;
name|rv
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/*      * Put the packet on the appropriate input queue.      */
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
name|inq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
name|inq
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|printf
argument_list|(
literal|"ppp%d: queue full\n"
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_iqdrops
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|rv
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|IF_ENQUEUE
argument_list|(
name|inq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

begin_comment
comment|/*  * tty interface receiver interrupt.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|paritytab
index|[
literal|8
index|]
init|=
block|{
literal|0x96696996
block|,
literal|0x69969669
block|,
literal|0x69969669
block|,
literal|0x96696996
block|,
literal|0x69969669
block|,
literal|0x96696996
block|,
literal|0x96696996
block|,
literal|0x69969669
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|pppinput
parameter_list|(
name|c
parameter_list|,
name|tp
parameter_list|)
name|int
name|c
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|ilen
decl_stmt|;
name|tk_nin
operator|++
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|ppp_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
operator|||
name|tp
operator|!=
operator|(
expr|struct
name|tty
operator|*
operator|)
name|sc
operator|->
name|sc_devp
condition|)
return|return
literal|0
return|;
operator|++
name|sc
operator|->
name|sc_bytesrcvd
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|TTY_FE
condition|)
block|{
comment|/* framing error or overrun on this char - abort packet */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|printf
argument_list|(
literal|"ppp%d: bad char %x\n"
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
argument_list|,
name|c
argument_list|)
expr_stmt|;
goto|goto
name|flush
goto|;
block|}
name|c
operator|&=
literal|0xff
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|0x80
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|SC_RCV_B7_1
expr_stmt|;
else|else
name|sc
operator|->
name|sc_flags
operator||=
name|SC_RCV_B7_0
expr_stmt|;
if|if
condition|(
name|paritytab
index|[
name|c
operator|>>
literal|5
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|c
operator|&
literal|0x1F
operator|)
operator|)
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|SC_RCV_ODDP
expr_stmt|;
else|else
name|sc
operator|->
name|sc_flags
operator||=
name|SC_RCV_EVNP
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_LOG_RAWIN
condition|)
name|ppplogchar
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|PPP_FLAG
condition|)
block|{
name|ilen
operator|=
name|sc
operator|->
name|sc_ilen
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ibytes
operator|=
name|sc
operator|->
name|sc_bytesrcvd
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rawin_count
operator|>
literal|0
condition|)
name|ppplogchar
argument_list|(
name|sc
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * If SC_ESCAPED is set, then we've seen the packet 	 * abort sequence "}~". 	 */
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
operator|(
name|SC_FLUSH
operator||
name|SC_ESCAPED
operator|)
operator|||
name|ilen
operator|>
literal|0
operator|&&
name|sc
operator|->
name|sc_fcs
operator|!=
name|PPP_GOODFCS
condition|)
block|{
ifdef|#
directive|ifdef
name|VJC
comment|/* 	     * If we've missed a packet, we must toss subsequent compressed 	     * packets which don't have an explicit connection ID. 	     */
name|sl_uncompress_tcp
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|TYPE_ERROR
argument_list|,
operator|&
name|sc
operator|->
name|sc_comp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
operator|(
name|SC_FLUSH
operator||
name|SC_ESCAPED
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|printf
argument_list|(
literal|"ppp%d: bad fcs\n"
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
operator|(
name|SC_FLUSH
operator||
name|SC_ESCAPED
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ilen
operator|<
name|PPP_HDRLEN
operator|+
name|PPP_FCSLEN
condition|)
block|{
if|if
condition|(
name|ilen
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|printf
argument_list|(
literal|"ppp%d: too short (%d)\n"
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
comment|/* 	 * Remove FCS trailer.  Somewhat painful... 	 */
name|ilen
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_mc
operator|->
name|m_len
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|m
operator|=
name|sc
operator|->
name|sc_m
init|;
name|m
operator|->
name|m_next
operator|!=
name|sc
operator|->
name|sc_mc
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
empty_stmt|;
name|sc
operator|->
name|sc_mc
operator|=
name|m
expr_stmt|;
block|}
name|sc
operator|->
name|sc_mc
operator|->
name|m_len
operator|--
expr_stmt|;
name|m
operator|=
name|sc
operator|->
name|sc_m
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_LOG_INPKT
condition|)
block|{
name|printf
argument_list|(
literal|"ppp%d: got %d bytes\n"
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
name|pppdumpm
argument_list|(
name|m
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ppppktin
argument_list|(
name|sc
argument_list|,
name|m
argument_list|,
name|ilen
argument_list|)
condition|)
block|{
comment|/* Put a placeholder byte in canq for ttselect()/ttnread(). */
name|putc
argument_list|(
literal|0
argument_list|,
operator|&
name|tp
operator|->
name|t_canq
argument_list|)
expr_stmt|;
name|ttwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_FLUSH
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_LOG_FLUSH
condition|)
name|ppplogchar
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|c
operator|<
literal|0x20
operator|&&
operator|(
name|sc
operator|->
name|sc_rasyncmap
operator|&
operator|(
literal|1
operator|<<
name|c
operator|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_ESCAPED
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_ESCAPED
expr_stmt|;
name|c
operator|^=
name|PPP_TRANS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|PPP_ESCAPE
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|SC_ESCAPED
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*      * Initialize buffer on first octet received.      * First octet could be address or protocol (when compressing      * address/control).      * Second octet is control.      * Third octet is first or second (when compressing protocol)      * octet of protocol.      * Fourth octet is second octet of protocol.      */
if|if
condition|(
name|sc
operator|->
name|sc_ilen
operator|==
literal|0
condition|)
block|{
comment|/* reset the first input mbuf */
name|m
operator|=
name|sc
operator|->
name|sc_m
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|M_DATASTART
argument_list|(
name|sc
operator|->
name|sc_m
argument_list|)
operator|+
name|HDROFF
expr_stmt|;
name|sc
operator|->
name|sc_mc
operator|=
name|m
expr_stmt|;
name|sc
operator|->
name|sc_mp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_fcs
operator|=
name|PPP_INITFCS
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|PPP_ALLSTATIONS
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_REJ_COMP_AC
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|printf
argument_list|(
literal|"ppp%d: garbage received: 0x%x (need 0xFF)\n"
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
argument_list|,
name|c
argument_list|)
expr_stmt|;
goto|goto
name|flush
goto|;
block|}
operator|*
name|sc
operator|->
name|sc_mp
operator|++
operator|=
name|PPP_ALLSTATIONS
expr_stmt|;
operator|*
name|sc
operator|->
name|sc_mp
operator|++
operator|=
name|PPP_UI
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|+=
literal|2
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|sc_ilen
operator|==
literal|1
operator|&&
name|c
operator|!=
name|PPP_UI
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|printf
argument_list|(
literal|"ppp%d: missing UI (0x3), got 0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
argument_list|,
name|c
argument_list|)
expr_stmt|;
goto|goto
name|flush
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_ilen
operator|==
literal|2
operator|&&
operator|(
name|c
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
block|{
comment|/* a compressed protocol */
operator|*
name|sc
operator|->
name|sc_mp
operator|++
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_mc
operator|->
name|m_len
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_ilen
operator|==
literal|3
operator|&&
operator|(
name|c
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|printf
argument_list|(
literal|"ppp%d: bad protocol %x\n"
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
argument_list|,
operator|(
name|sc
operator|->
name|sc_mp
index|[
operator|-
literal|1
index|]
operator|<<
literal|8
operator|)
operator|+
name|c
argument_list|)
expr_stmt|;
goto|goto
name|flush
goto|;
block|}
comment|/* packet beyond configured mru? */
if|if
condition|(
operator|++
name|sc
operator|->
name|sc_ilen
operator|>
name|sc
operator|->
name|sc_mru
operator|+
name|PPP_HDRLEN
operator|+
name|PPP_FCSLEN
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_DEBUG
condition|)
name|printf
argument_list|(
literal|"ppp%d: packet too big\n"
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
argument_list|)
expr_stmt|;
goto|goto
name|flush
goto|;
block|}
comment|/* is this mbuf full? */
name|m
operator|=
name|sc
operator|->
name|sc_mc
expr_stmt|;
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_mc
operator|=
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ppp%d: too few input mbufs!\n"
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
argument_list|)
expr_stmt|;
goto|goto
name|flush
goto|;
block|}
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|M_DATASTART
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
operator|++
name|m
operator|->
name|m_len
expr_stmt|;
operator|*
name|sc
operator|->
name|sc_mp
operator|++
operator|=
name|c
expr_stmt|;
name|sc
operator|->
name|sc_fcs
operator|=
name|PPP_FCS
argument_list|(
name|sc
operator|->
name|sc_fcs
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|flush
label|:
if|if
condition|(
operator|!
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_FLUSH
operator|)
condition|)
block|{
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|SC_FLUSH
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_LOG_FLUSH
condition|)
name|ppplogchar
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request to interface.  */
end_comment

begin_function
name|int
name|pppioctl
parameter_list|(
name|ifp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
init|=
operator|&
name|ppp_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
specifier|register
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
break|break;
case|case
name|SIOCSIFADDR
case|:
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
case|case
name|SIOCSIFDSTADDR
case|:
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|ifr
operator|->
name|ifr_mtu
operator|>
name|PPP_MAXMTU
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
name|clist_alloc_cblocks
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|tty
operator|*
operator|)
name|sc
operator|->
name|sc_devp
operator|)
operator|->
name|t_outq
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
operator|+
name|PPP_HIWAT
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
operator|+
name|PPP_HIWAT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SIOCGIFMTU
case|:
name|ifr
operator|->
name|ifr_mtu
operator|=
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX_DUMP_BYTES
value|128
end_define

begin_function
specifier|static
name|void
name|pppdumpm
parameter_list|(
name|m0
parameter_list|,
name|pktlen
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|3
operator|*
name|MAX_DUMP_BYTES
operator|+
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|static
name|char
name|digits
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|&&
name|pktlen
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|int
name|l
init|=
name|m
operator|->
name|m_len
decl_stmt|;
name|u_char
modifier|*
name|rptr
init|=
operator|(
name|u_char
operator|*
operator|)
name|m
operator|->
name|m_data
decl_stmt|;
if|if
condition|(
name|pktlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|l
operator|>
name|pktlen
condition|)
name|l
operator|=
name|pktlen
expr_stmt|;
name|pktlen
operator|-=
name|l
expr_stmt|;
block|}
while|while
condition|(
name|l
operator|--
condition|)
block|{
if|if
condition|(
name|bp
operator|>
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|4
condition|)
goto|goto
name|done
goto|;
operator|*
name|bp
operator|++
operator|=
name|digits
index|[
operator|*
name|rptr
operator|>>
literal|4
index|]
expr_stmt|;
comment|/* convert byte to ascii hex */
operator|*
name|bp
operator|++
operator|=
name|digits
index|[
operator|*
name|rptr
operator|++
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
block|{
if|if
condition|(
name|bp
operator|>
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|3
condition|)
goto|goto
name|done
goto|;
operator|*
name|bp
operator|++
operator|=
literal|'|'
expr_stmt|;
block|}
else|else
operator|*
name|bp
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|m
operator|&&
name|pktlen
condition|)
operator|*
name|bp
operator|++
operator|=
literal|'>'
expr_stmt|;
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ppplogchar
parameter_list|(
name|sc
parameter_list|,
name|c
parameter_list|)
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|>=
literal|0
condition|)
name|sc
operator|->
name|sc_rawin
index|[
name|sc
operator|->
name|sc_rawin_count
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rawin_count
operator|>=
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_rawin
argument_list|)
operator|||
name|c
operator|<
literal|0
operator|&&
name|sc
operator|->
name|sc_rawin_count
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ppp%d input: "
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
argument_list|)
expr_stmt|;
name|pppdumpb
argument_list|(
name|sc
operator|->
name|sc_rawin
argument_list|,
name|sc
operator|->
name|sc_rawin_count
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rawin_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pppdumpb
parameter_list|(
name|b
parameter_list|,
name|l
parameter_list|)
name|u_char
modifier|*
name|b
decl_stmt|;
name|int
name|l
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|3
operator|*
name|MAX_DUMP_BYTES
operator|+
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
specifier|static
name|char
name|digits
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
block|{
if|if
condition|(
name|bp
operator|>=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|3
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|'>'
expr_stmt|;
break|break;
block|}
operator|*
name|bp
operator|++
operator|=
name|digits
index|[
operator|*
name|b
operator|>>
literal|4
index|]
expr_stmt|;
comment|/* convert byte to ascii hex */
operator|*
name|bp
operator|++
operator|=
name|digits
index|[
operator|*
name|b
operator|++
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|TEXT_SET
argument_list|(
name|pseudo_set
argument_list|,
name|pppattach
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPPP> 0 */
end_comment

end_unit

