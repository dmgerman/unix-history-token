begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * if_ppp.c - Point-to-Point Protocol (PPP) Asynchronous driver.  *  * Copyright (c) 1989 Carnegie Mellon University.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by Carnegie Mellon University.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * Drew D. Perkins  * Carnegie Mellon University  * 4910 Forbes Ave.  * Pittsburgh, PA 15213  * (412) 268-8576  * ddp@andrew.cmu.edu  *  * Based on:  *	@(#)if_sl.c	7.6.1.2 (Berkeley) 2/15/89  *  * Copyright (c) 1987 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * Serial Line interface  *  * Rick Adams  * Center for Seismic Studies  * 1300 N 17th Street, Suite 1450  * Arlington, Virginia 22209  * (703)276-7900  * rick@seismo.ARPA  * seismo!rick  *  * Pounded on heavily by Chris Torek (chris@mimsy.umd.edu, umcp-cs!chris).  * Converted to 4.3BSD Beta by Chris Torek.  * Other changes made at Berkeley, based in part on code by Kirk Smith.  *  * Converted to 4.3BSD+ 386BSD by Brad Parker (brad@cayman.com)  * Added VJ tcp header compression; more unified ioctls  *  * Extensively modified by Paul Mackerras (paulus@cs.anu.edu.au).  * Cleaned up a lot of the mbuf-related code to fix bugs that  * caused system crashes and packet corruption.  Changed pppstart  * so that it doesn't just give up with a collision if the whole  * packet doesn't fit in the output ring buffer.  */
end_comment

begin_comment
comment|/*  *	$Id$  *	From: if_ppp.c,v 1.20 1993/08/16 02:13:13 paulus Exp  *	From: if_sl.c,v 1.11 84/10/04 12:54:47 rick Exp   */
end_comment

begin_include
include|#
directive|include
file|"ppp.h"
end_include

begin_if
if|#
directive|if
name|NPPP
operator|>
literal|0
end_if

begin_define
define|#
directive|define
name|VJC
end_define

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"buf.h"
end_include

begin_include
include|#
directive|include
file|"dkstat.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_include
include|#
directive|include
file|"tty.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"if.h"
end_include

begin_include
include|#
directive|include
file|"if_types.h"
end_include

begin_include
include|#
directive|include
file|"netisr.h"
end_include

begin_include
include|#
directive|include
file|"route.h"
end_include

begin_if
if|#
directive|if
name|INET
end_if

begin_include
include|#
directive|include
file|"../netinet/in.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in_systm.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/in_var.h"
end_include

begin_include
include|#
directive|include
file|"../netinet/ip.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Here we try to tell whether we are in a 386BSD kernel, or  * in a NetBSD/Net-2/4.3-Reno kernel.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|RB_LEN
end_ifndef

begin_comment
comment|/* NetBSD, 4.3-Reno or similar */
end_comment

begin_define
define|#
directive|define
name|CCOUNT
parameter_list|(
name|q
parameter_list|)
value|((q)->c_cc)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* 386BSD, Jolitz-style ring buffers */
end_comment

begin_define
define|#
directive|define
name|t_outq
value|t_out
end_define

begin_define
define|#
directive|define
name|t_rawq
value|t_raw
end_define

begin_define
define|#
directive|define
name|t_canq
value|t_can
end_define

begin_define
define|#
directive|define
name|CCOUNT
parameter_list|(
name|q
parameter_list|)
value|(RB_LEN(q))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VJC
end_ifdef

begin_include
include|#
directive|include
file|"slcompress.h"
end_include

begin_define
define|#
directive|define
name|HDROFF
value|MAX_HDR
end_define

begin_comment
comment|/* HDROFF should really be 128, but other parts of the system will    panic on TCP+IP headers bigger than MAX_HDR = MHLEN (100). */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|HDROFF
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"if_ppp.h"
end_include

begin_include
include|#
directive|include
file|"machine/mtpr.h"
end_include

begin_decl_stmt
name|struct
name|ppp_softc
name|ppp_softc
index|[
name|NPPP
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ppp_async_out_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ppp_async_in_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ppp_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|pppattach
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pppopen
name|__P
argument_list|(
operator|(
name|dev_t
name|dev
operator|,
expr|struct
name|tty
operator|*
name|tp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|pppclose
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|,
name|int
name|flag
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pppread
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|,
expr|struct
name|uio
operator|*
name|uio
operator|,
name|int
name|flag
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pppwrite
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|,
expr|struct
name|uio
operator|*
name|uio
operator|,
name|int
name|flag
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ppptioctl
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|,
name|int
name|cmd
operator|,
name|caddr_t
name|data
operator|,
name|int
name|flag
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pppoutput
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|,
expr|struct
name|mbuf
operator|*
name|m0
operator|,
expr|struct
name|sockaddr
operator|*
name|dst
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|pppstart
name|__P
argument_list|(
operator|(
expr|struct
name|tty
operator|*
name|tp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|pppinput
name|__P
argument_list|(
operator|(
name|int
name|c
operator|,
expr|struct
name|tty
operator|*
name|tp
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pppioctl
name|__P
argument_list|(
operator|(
expr|struct
name|ifnet
operator|*
name|ifp
operator|,
name|int
name|cmd
operator|,
name|caddr_t
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_short
name|pppfcs
name|__P
argument_list|(
operator|(
name|u_short
name|fcs
operator|,
name|u_char
operator|*
name|cp
operator|,
name|int
name|len
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pppinit
name|__P
argument_list|(
operator|(
expr|struct
name|ppp_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|ppp_btom
name|__P
argument_list|(
operator|(
expr|struct
name|ppp_softc
operator|*
name|sc
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pppdumpm
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
name|m0
operator|,
name|int
name|pktlen
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|pppdumpb
name|__P
argument_list|(
operator|(
name|u_char
operator|*
name|b
operator|,
name|int
name|l
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Some useful mbuf macros not in mbuf.h.  */
end_comment

begin_define
define|#
directive|define
name|M_DATASTART
parameter_list|(
name|m
parameter_list|)
define|\
value|((m)->m_flags& M_EXT ? (m)->m_ext.ext_buf : \ 	    (m)->m_flags& M_PKTHDR ? (m)->m_pktdat : (m)->m_dat)
end_define

begin_define
define|#
directive|define
name|M_DATASIZE
parameter_list|(
name|m
parameter_list|)
define|\
value|((m)->m_flags& M_EXT ? (m)->m_ext.ext_size : \ 	    (m)->m_flags& M_PKTHDR ? MHLEN: MLEN)
end_define

begin_comment
comment|/*  * Called from boot code to establish ppp interfaces.  */
end_comment

begin_function
name|void
name|pppattach
parameter_list|()
block|{
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|sc
operator|=
name|ppp_softc
init|;
name|i
operator|<
name|NPPP
condition|;
name|sc
operator|++
control|)
block|{
name|sc
operator|->
name|sc_if
operator|.
name|if_name
operator|=
literal|"ppp"
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
operator|=
name|i
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
operator|=
name|PPP_MTU
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|=
name|IFF_POINTOPOINT
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_type
operator|=
name|IFT_PPP
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ppp_header
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ioctl
operator|=
name|pppioctl
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_output
operator|=
name|pppoutput
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|sc
operator|->
name|sc_inq
operator|.
name|ifq_maxlen
operator|=
name|IFQ_MAXLEN
expr_stmt|;
name|if_attach
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Line specific open routine.  * Attach the given tty to the first available ppp unit.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|pppopen
parameter_list|(
name|dev
parameter_list|,
name|tp
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
specifier|register
name|int
name|nppp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|tp
operator|->
name|t_line
operator|==
name|PPPDISC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|nppp
operator|=
literal|0
operator|,
name|sc
operator|=
name|ppp_softc
init|;
name|nppp
operator|<
name|NPPP
condition|;
name|nppp
operator|++
operator|,
name|sc
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_ttyp
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_asyncmap
operator|=
literal|0xffffffff
expr_stmt|;
ifdef|#
directive|ifdef
name|VJC
name|sl_compress_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_comp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pppinit
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|tp
operator|->
name|t_sc
operator|=
operator|(
name|caddr_t
operator|)
name|sc
expr_stmt|;
name|sc
operator|->
name|sc_ttyp
operator|=
name|tp
expr_stmt|;
name|sc
operator|->
name|sc_outm
operator|=
name|NULL
expr_stmt|;
name|ttyflush
argument_list|(
name|tp
argument_list|,
name|FREAD
operator||
name|FWRITE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator||=
name|IFF_RUNNING
expr_stmt|;
ifdef|#
directive|ifdef
name|PPP_OUTQ_SIZE
comment|/* N.B. this code is designed *only* for use in NetBSD */
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* get rid of the default outq clist buffer */
name|clfree
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
comment|/* and get a new one, without quoting support, much larger */
name|clalloc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
name|PPP_OUTQ_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PPP_OUTQ_SIZE */
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Line specific close routine.  * Detach the tty from the ppp unit.  * Mimics part of ttyclose().  */
end_comment

begin_function
name|void
name|pppclose
parameter_list|(
name|tp
parameter_list|,
name|flag
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ttywflush
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
comment|/* paranoid; splnet probably ok */
name|tp
operator|->
name|t_line
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|ppp_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
expr_stmt|;
if|if
condition|(
name|sc
operator|!=
name|NULL
condition|)
block|{
name|if_down
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ttyp
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|t_sc
operator|=
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_outm
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_outm
operator|=
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_m
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_inq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
operator|(
name|IFF_UP
operator||
name|IFF_RUNNING
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PPP_OUTQ_SIZE
comment|/* reinstall default clist-buffer for outq 	   XXXX should really remember old value and restore that!! */
name|clfree
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
name|clalloc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|,
literal|1024
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PPP_OUTQ_SIZE */
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Line specific (tty) read routine.  */
end_comment

begin_function
name|int
name|pppread
parameter_list|(
name|tp
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ppp_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
while|while
condition|(
name|sc
operator|->
name|sc_inq
operator|.
name|ifq_head
operator|==
name|NULL
operator|&&
name|tp
operator|->
name|t_line
operator|==
name|PPPDISC
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASYNC
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EWOULDBLOCK
operator|)
return|;
block|}
name|error
operator|=
name|ttysleep
argument_list|(
name|tp
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_rawq
argument_list|,
name|TTIPRI
operator||
name|PCATCH
argument_list|,
name|ttyin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_line
operator|!=
name|PPPDISC
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Pull place-holder byte out of canonical queue */
name|getc
argument_list|(
operator|&
name|tp
operator|->
name|t_canq
argument_list|)
expr_stmt|;
comment|/* Get the packet from the input queue */
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_inq
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|&&
name|uio
operator|->
name|uio_resid
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
if|if
condition|(
name|error
operator|=
name|uiomove
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|uio
argument_list|)
condition|)
break|break;
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Line specific (tty) write routine.  */
end_comment

begin_function
name|int
name|pppwrite
parameter_list|(
name|tp
parameter_list|,
name|uio
parameter_list|,
name|flag
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
name|int
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ppp_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|;
name|struct
name|sockaddr
name|dst
decl_stmt|;
name|struct
name|ppp_header
modifier|*
name|ph1
decl_stmt|,
modifier|*
name|ph2
decl_stmt|;
name|int
name|len
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|tp
operator|->
name|t_line
operator|!=
name|PPPDISC
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|>
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ppp_header
argument_list|)
operator|||
name|uio
operator|->
name|uio_resid
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ppp_header
argument_list|)
condition|)
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
for|for
control|(
name|mp
operator|=
operator|&
name|m0
init|;
name|uio
operator|->
name|uio_resid
condition|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
control|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_WAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|mp
operator|=
name|m
operator|)
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|>=
name|MCLBYTES
operator|/
literal|2
condition|)
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|len
operator|=
name|MIN
argument_list|(
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|uiomove
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|len
argument_list|,
name|uio
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
block|}
name|dst
operator|.
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|ph1
operator|=
operator|(
expr|struct
name|ppp_header
operator|*
operator|)
operator|&
name|dst
operator|.
name|sa_data
expr_stmt|;
name|ph2
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ppp_header
operator|*
argument_list|)
expr_stmt|;
operator|*
name|ph1
operator|=
operator|*
name|ph2
expr_stmt|;
name|m0
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ppp_header
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ppp_header
argument_list|)
expr_stmt|;
return|return
operator|(
name|pppoutput
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
argument_list|,
name|m0
argument_list|,
operator|&
name|dst
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Line specific (tty) ioctl routine.  * Provide a way to get the ppp unit number.  * This discipline requires that tty device drivers call  * the line specific l_ioctl routine from their ioctl routines.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|ppptioctl
parameter_list|(
name|tp
parameter_list|,
name|cmd
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|)
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|int
name|cmd
decl_stmt|,
name|flag
decl_stmt|;
block|{
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ppp_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
if|#
directive|if
literal|0
comment|/* this is handled (properly) by ttioctl */
block|case TIOCGETD: 	*(int *)data = sc->sc_if.if_unit; 	break;
endif|#
directive|endif
case|case
name|FIONREAD
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_inq
operator|.
name|ifq_len
expr_stmt|;
break|break;
case|case
name|PPPIOCGUNIT
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
expr_stmt|;
break|break;
case|case
name|PPPIOCGFLAGS
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_flags
expr_stmt|;
break|break;
case|case
name|PPPIOCSFLAGS
case|:
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
define|#
directive|define
name|SC_MASK
value|0xffff
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
operator|(
name|sc
operator|->
name|sc_flags
operator|&
operator|~
name|SC_MASK
operator|)
operator||
operator|(
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|)
operator|&
name|SC_MASK
operator|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|PPPIOCSASYNCMAP
case|:
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|sc_asyncmap
operator|=
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
expr_stmt|;
break|break;
case|case
name|PPPIOCGASYNCMAP
case|:
operator|*
operator|(
name|u_int
operator|*
operator|)
name|data
operator|=
name|sc
operator|->
name|sc_asyncmap
expr_stmt|;
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * FCS lookup table as calculated by genfcstab.  */
end_comment

begin_decl_stmt
specifier|static
name|u_short
name|fcstab
index|[
literal|256
index|]
init|=
block|{
literal|0x0000
block|,
literal|0x1189
block|,
literal|0x2312
block|,
literal|0x329b
block|,
literal|0x4624
block|,
literal|0x57ad
block|,
literal|0x6536
block|,
literal|0x74bf
block|,
literal|0x8c48
block|,
literal|0x9dc1
block|,
literal|0xaf5a
block|,
literal|0xbed3
block|,
literal|0xca6c
block|,
literal|0xdbe5
block|,
literal|0xe97e
block|,
literal|0xf8f7
block|,
literal|0x1081
block|,
literal|0x0108
block|,
literal|0x3393
block|,
literal|0x221a
block|,
literal|0x56a5
block|,
literal|0x472c
block|,
literal|0x75b7
block|,
literal|0x643e
block|,
literal|0x9cc9
block|,
literal|0x8d40
block|,
literal|0xbfdb
block|,
literal|0xae52
block|,
literal|0xdaed
block|,
literal|0xcb64
block|,
literal|0xf9ff
block|,
literal|0xe876
block|,
literal|0x2102
block|,
literal|0x308b
block|,
literal|0x0210
block|,
literal|0x1399
block|,
literal|0x6726
block|,
literal|0x76af
block|,
literal|0x4434
block|,
literal|0x55bd
block|,
literal|0xad4a
block|,
literal|0xbcc3
block|,
literal|0x8e58
block|,
literal|0x9fd1
block|,
literal|0xeb6e
block|,
literal|0xfae7
block|,
literal|0xc87c
block|,
literal|0xd9f5
block|,
literal|0x3183
block|,
literal|0x200a
block|,
literal|0x1291
block|,
literal|0x0318
block|,
literal|0x77a7
block|,
literal|0x662e
block|,
literal|0x54b5
block|,
literal|0x453c
block|,
literal|0xbdcb
block|,
literal|0xac42
block|,
literal|0x9ed9
block|,
literal|0x8f50
block|,
literal|0xfbef
block|,
literal|0xea66
block|,
literal|0xd8fd
block|,
literal|0xc974
block|,
literal|0x4204
block|,
literal|0x538d
block|,
literal|0x6116
block|,
literal|0x709f
block|,
literal|0x0420
block|,
literal|0x15a9
block|,
literal|0x2732
block|,
literal|0x36bb
block|,
literal|0xce4c
block|,
literal|0xdfc5
block|,
literal|0xed5e
block|,
literal|0xfcd7
block|,
literal|0x8868
block|,
literal|0x99e1
block|,
literal|0xab7a
block|,
literal|0xbaf3
block|,
literal|0x5285
block|,
literal|0x430c
block|,
literal|0x7197
block|,
literal|0x601e
block|,
literal|0x14a1
block|,
literal|0x0528
block|,
literal|0x37b3
block|,
literal|0x263a
block|,
literal|0xdecd
block|,
literal|0xcf44
block|,
literal|0xfddf
block|,
literal|0xec56
block|,
literal|0x98e9
block|,
literal|0x8960
block|,
literal|0xbbfb
block|,
literal|0xaa72
block|,
literal|0x6306
block|,
literal|0x728f
block|,
literal|0x4014
block|,
literal|0x519d
block|,
literal|0x2522
block|,
literal|0x34ab
block|,
literal|0x0630
block|,
literal|0x17b9
block|,
literal|0xef4e
block|,
literal|0xfec7
block|,
literal|0xcc5c
block|,
literal|0xddd5
block|,
literal|0xa96a
block|,
literal|0xb8e3
block|,
literal|0x8a78
block|,
literal|0x9bf1
block|,
literal|0x7387
block|,
literal|0x620e
block|,
literal|0x5095
block|,
literal|0x411c
block|,
literal|0x35a3
block|,
literal|0x242a
block|,
literal|0x16b1
block|,
literal|0x0738
block|,
literal|0xffcf
block|,
literal|0xee46
block|,
literal|0xdcdd
block|,
literal|0xcd54
block|,
literal|0xb9eb
block|,
literal|0xa862
block|,
literal|0x9af9
block|,
literal|0x8b70
block|,
literal|0x8408
block|,
literal|0x9581
block|,
literal|0xa71a
block|,
literal|0xb693
block|,
literal|0xc22c
block|,
literal|0xd3a5
block|,
literal|0xe13e
block|,
literal|0xf0b7
block|,
literal|0x0840
block|,
literal|0x19c9
block|,
literal|0x2b52
block|,
literal|0x3adb
block|,
literal|0x4e64
block|,
literal|0x5fed
block|,
literal|0x6d76
block|,
literal|0x7cff
block|,
literal|0x9489
block|,
literal|0x8500
block|,
literal|0xb79b
block|,
literal|0xa612
block|,
literal|0xd2ad
block|,
literal|0xc324
block|,
literal|0xf1bf
block|,
literal|0xe036
block|,
literal|0x18c1
block|,
literal|0x0948
block|,
literal|0x3bd3
block|,
literal|0x2a5a
block|,
literal|0x5ee5
block|,
literal|0x4f6c
block|,
literal|0x7df7
block|,
literal|0x6c7e
block|,
literal|0xa50a
block|,
literal|0xb483
block|,
literal|0x8618
block|,
literal|0x9791
block|,
literal|0xe32e
block|,
literal|0xf2a7
block|,
literal|0xc03c
block|,
literal|0xd1b5
block|,
literal|0x2942
block|,
literal|0x38cb
block|,
literal|0x0a50
block|,
literal|0x1bd9
block|,
literal|0x6f66
block|,
literal|0x7eef
block|,
literal|0x4c74
block|,
literal|0x5dfd
block|,
literal|0xb58b
block|,
literal|0xa402
block|,
literal|0x9699
block|,
literal|0x8710
block|,
literal|0xf3af
block|,
literal|0xe226
block|,
literal|0xd0bd
block|,
literal|0xc134
block|,
literal|0x39c3
block|,
literal|0x284a
block|,
literal|0x1ad1
block|,
literal|0x0b58
block|,
literal|0x7fe7
block|,
literal|0x6e6e
block|,
literal|0x5cf5
block|,
literal|0x4d7c
block|,
literal|0xc60c
block|,
literal|0xd785
block|,
literal|0xe51e
block|,
literal|0xf497
block|,
literal|0x8028
block|,
literal|0x91a1
block|,
literal|0xa33a
block|,
literal|0xb2b3
block|,
literal|0x4a44
block|,
literal|0x5bcd
block|,
literal|0x6956
block|,
literal|0x78df
block|,
literal|0x0c60
block|,
literal|0x1de9
block|,
literal|0x2f72
block|,
literal|0x3efb
block|,
literal|0xd68d
block|,
literal|0xc704
block|,
literal|0xf59f
block|,
literal|0xe416
block|,
literal|0x90a9
block|,
literal|0x8120
block|,
literal|0xb3bb
block|,
literal|0xa232
block|,
literal|0x5ac5
block|,
literal|0x4b4c
block|,
literal|0x79d7
block|,
literal|0x685e
block|,
literal|0x1ce1
block|,
literal|0x0d68
block|,
literal|0x3ff3
block|,
literal|0x2e7a
block|,
literal|0xe70e
block|,
literal|0xf687
block|,
literal|0xc41c
block|,
literal|0xd595
block|,
literal|0xa12a
block|,
literal|0xb0a3
block|,
literal|0x8238
block|,
literal|0x93b1
block|,
literal|0x6b46
block|,
literal|0x7acf
block|,
literal|0x4854
block|,
literal|0x59dd
block|,
literal|0x2d62
block|,
literal|0x3ceb
block|,
literal|0x0e70
block|,
literal|0x1ff9
block|,
literal|0xf78f
block|,
literal|0xe606
block|,
literal|0xd49d
block|,
literal|0xc514
block|,
literal|0xb1ab
block|,
literal|0xa022
block|,
literal|0x92b9
block|,
literal|0x8330
block|,
literal|0x7bc7
block|,
literal|0x6a4e
block|,
literal|0x58d5
block|,
literal|0x495c
block|,
literal|0x3de3
block|,
literal|0x2c6a
block|,
literal|0x1ef1
block|,
literal|0x0f78
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Calculate a new FCS given the current FCS and the new data.  */
end_comment

begin_function
specifier|static
name|u_short
name|pppfcs
parameter_list|(
name|fcs
parameter_list|,
name|cp
parameter_list|,
name|len
parameter_list|)
specifier|register
name|u_short
name|fcs
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
while|while
condition|(
name|len
operator|--
condition|)
name|fcs
operator|=
name|PPP_FCS
argument_list|(
name|fcs
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
name|fcs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Queue a packet.  Start transmission if not active.  * Packet is placed in Information field of PPP frame.  */
end_comment

begin_function
name|int
name|pppoutput
parameter_list|(
name|ifp
parameter_list|,
name|m0
parameter_list|,
name|dst
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
block|{
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
init|=
operator|&
name|ppp_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m1
decl_stmt|;
name|struct
name|ppp_header
modifier|*
name|ph
decl_stmt|;
name|u_short
name|protocol
decl_stmt|,
name|fcs
decl_stmt|;
name|u_char
name|address
decl_stmt|,
name|control
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|,
name|compac
decl_stmt|,
name|compprot
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_ttyp
operator|==
name|NULL
operator|||
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
operator|||
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|&&
name|dst
operator|->
name|sa_family
operator|!=
name|AF_UNSPEC
condition|)
block|{
name|error
operator|=
name|ENETDOWN
expr_stmt|;
comment|/* sort of */
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_ttyp
operator|->
name|t_state
operator|&
name|TS_CARR_ON
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EHOSTUNREACH
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/*      * Compute PPP header.      */
name|address
operator|=
name|PPP_ALLSTATIONS
expr_stmt|;
name|control
operator|=
name|PPP_UI
expr_stmt|;
switch|switch
condition|(
name|dst
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|protocol
operator|=
name|PPP_IP
expr_stmt|;
ifdef|#
directive|ifdef
name|VJC
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_COMP_TCP
condition|)
block|{
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
if|if
condition|(
operator|(
name|ip
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
operator|)
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
condition|)
block|{
name|int
name|type
init|=
name|sl_compress_tcp
argument_list|(
name|m0
argument_list|,
name|ip
argument_list|,
operator|&
name|sc
operator|->
name|sc_comp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYPE_UNCOMPRESSED_TCP
case|:
name|protocol
operator|=
name|PPP_VJC_UNCOMP
expr_stmt|;
break|break;
case|case
name|TYPE_COMPRESSED_TCP
case|:
name|protocol
operator|=
name|PPP_VJC_COMP
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NS
case|case
name|AF_NS
case|:
name|protocol
operator|=
name|PPP_XNS
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|AF_UNSPEC
case|:
name|ph
operator|=
operator|(
expr|struct
name|ppp_header
operator|*
operator|)
name|dst
operator|->
name|sa_data
expr_stmt|;
name|address
operator|=
name|ph
operator|->
name|ph_address
expr_stmt|;
name|control
operator|=
name|ph
operator|->
name|ph_control
expr_stmt|;
name|protocol
operator|=
name|ntohs
argument_list|(
name|ph
operator|->
name|ph_protocol
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ppp%d: af%d not supported\n"
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|compac
operator|=
name|sc
operator|->
name|sc_flags
operator|&
name|SC_COMP_AC
operator|&&
name|address
operator|==
name|PPP_ALLSTATIONS
operator|&&
name|control
operator|==
name|PPP_UI
operator|&&
name|protocol
operator|!=
name|PPP_ALLSTATIONS
operator|&&
name|protocol
operator|!=
name|PPP_LCP
expr_stmt|;
name|compprot
operator|=
name|sc
operator|->
name|sc_flags
operator|&
name|SC_COMP_PROT
operator|&&
name|protocol
operator|<
literal|0x100
expr_stmt|;
comment|/*      * Add PPP header.  If no space in first mbuf, allocate another.      */
if|if
condition|(
name|M_LEADINGSPACE
argument_list|(
name|m0
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ppp_header
argument_list|)
condition|)
block|{
name|m0
operator|=
name|m_prepend
argument_list|(
name|m0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ppp_header
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m0
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|m0
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|m0
operator|->
name|m_data
operator|-=
operator|(
name|compac
condition|?
literal|0
else|:
literal|2
operator|)
operator|+
operator|(
name|compprot
condition|?
literal|1
else|:
literal|2
operator|)
expr_stmt|;
name|cp
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|compac
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|address
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|control
expr_stmt|;
name|m0
operator|->
name|m_len
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|compprot
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
name|protocol
operator|>>
literal|8
expr_stmt|;
name|m0
operator|->
name|m_len
operator|++
expr_stmt|;
block|}
operator|*
name|cp
operator|++
operator|=
name|protocol
operator|&
literal|0xff
expr_stmt|;
name|m0
operator|->
name|m_len
operator|++
expr_stmt|;
comment|/*      * Add PPP trailer.  Compute one's complement of FCS over frame      * and attach to mbuf chain least significant byte first.      */
name|fcs
operator|=
name|PPP_INITFCS
expr_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|fcs
operator|=
name|pppfcs
argument_list|(
name|fcs
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m1
operator|=
name|m
expr_stmt|;
block|}
name|fcs
operator|^=
literal|0xffff
expr_stmt|;
comment|/*      * If the last mbuf is a cluster, we can't just store the      * FCS in it (other mbufs might point to the same cluster).      */
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|m1
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|||
name|m1
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
block|{
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|m1
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|m1
operator|=
name|m
expr_stmt|;
block|}
name|cp
operator|=
name|mtod
argument_list|(
name|m1
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
name|m1
operator|->
name|m_len
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|fcs
operator|&
literal|0xff
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|fcs
operator|>>
literal|8
expr_stmt|;
name|m1
operator|->
name|m_len
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ppp_async_out_debug
condition|)
block|{
name|printf
argument_list|(
literal|"ppp%d output: "
argument_list|,
name|ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
name|pppdumpm
argument_list|(
name|m0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_oerrors
operator|++
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|IF_ENQUEUE
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|m0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CCOUNT
argument_list|(
operator|&
name|sc
operator|->
name|sc_ttyp
operator|->
name|t_outq
argument_list|)
operator|==
literal|0
condition|)
name|pppstart
argument_list|(
name|sc
operator|->
name|sc_ttyp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|m_freem
argument_list|(
name|m0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start output on interface.  Get another datagram  * to send from the interface queue and map it to  * the interface before starting output.  */
end_comment

begin_function
name|void
name|pppstart
parameter_list|(
name|tp
parameter_list|)
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
init|=
operator|(
expr|struct
name|ppp_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|start
decl_stmt|,
modifier|*
name|stop
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|n
decl_stmt|,
name|s
decl_stmt|,
name|ndone
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m2
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 	 * If there is more in the output queue, just send it now. 	 * We are being called in lieu of ttstart and must do what 	 * it would. 	 */
if|if
condition|(
name|CCOUNT
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
operator|!=
literal|0
operator|&&
name|tp
operator|->
name|t_oproc
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|tp
operator|->
name|t_oproc
call|)
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|CCOUNT
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
operator|>
name|PPP_HIWAT
condition|)
return|return;
block|}
comment|/* 	 * This happens briefly when the line shuts down. 	 */
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * See if we have an existing packet partly sent. 	 * If not, get a new packet and start sending it. 	 */
name|m
operator|=
name|sc
operator|->
name|sc_outm
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|sc
operator|->
name|sc_if
operator|.
name|if_snd
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
comment|/* 	     * The extra PPP_FLAG will start up a new packet, and thus 	     * will flush any accumulated garbage.  We do this whenever 	     * the line may have been idle for some time. 	     */
if|if
condition|(
name|CCOUNT
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|sc
operator|->
name|sc_bytessent
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
name|PPP_FLAG
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
block|}
block|}
do|do
block|{
name|start
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|stop
operator|=
name|start
operator|+
name|len
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Find out how many bytes in the string we can 		 * handle without doing something special. 		 */
for|for
control|(
name|cp
operator|=
name|start
init|;
name|cp
operator|<
name|stop
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
name|PPP_FLAG
operator|)
operator|||
operator|(
operator|*
name|cp
operator|==
name|PPP_ESCAPE
operator|)
operator|||
operator|(
operator|*
name|cp
operator|<
literal|0x20
operator|&&
operator|(
name|sc
operator|->
name|sc_asyncmap
operator|&
operator|(
literal|1
operator|<<
operator|*
name|cp
operator|)
operator|)
operator|)
condition|)
break|break;
name|n
operator|=
name|cp
operator|-
name|start
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
ifndef|#
directive|ifndef
name|RB_LEN
comment|/* NetBSD (0.9 or later), 4.3-Reno or similar. */
name|ndone
operator|=
name|n
operator|-
name|b_to_q
argument_list|(
name|start
argument_list|,
name|n
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|NetBSD
comment|/* NetBSD, 0.8 or earlier */
name|ndone
operator|=
name|rb_cwrite
argument_list|(
operator|&
name|tp
operator|->
name|t_out
argument_list|,
name|start
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 386BSD */
name|int
name|cc
decl_stmt|,
name|nleft
decl_stmt|;
for|for
control|(
name|nleft
operator|=
name|n
init|;
name|nleft
operator|>
literal|0
condition|;
name|nleft
operator|-=
name|cc
control|)
block|{
if|if
condition|(
operator|(
name|cc
operator|=
name|RB_CONTIGPUT
argument_list|(
operator|&
name|tp
operator|->
name|t_out
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|cc
operator|=
name|min
argument_list|(
name|cc
argument_list|,
name|nleft
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|start
argument_list|,
name|tp
operator|->
name|t_out
operator|.
name|rb_tl
argument_list|,
name|cc
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_out
operator|.
name|rb_tl
operator|=
name|RB_ROLLOVER
argument_list|(
operator|&
name|tp
operator|->
name|t_out
argument_list|,
name|tp
operator|->
name|t_out
operator|.
name|rb_tl
operator|+
name|cc
argument_list|)
expr_stmt|;
block|}
name|ndone
operator|=
name|n
operator|-
name|nleft
expr_stmt|;
endif|#
directive|endif
comment|/* NetBSD */
endif|#
directive|endif
comment|/* RB_LEN */
name|len
operator|-=
name|ndone
expr_stmt|;
name|start
operator|+=
name|ndone
expr_stmt|;
name|sc
operator|->
name|sc_bytessent
operator|+=
name|ndone
expr_stmt|;
if|if
condition|(
name|ndone
operator|<
name|n
condition|)
break|break;
comment|/* packet doesn't fit */
block|}
comment|/* 		 * If there are characters left in the mbuf, 		 * the first one must be special.. 		 * Put it out in a different form. 		 */
if|if
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|putc
argument_list|(
name|PPP_ESCAPE
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
break|break;
if|if
condition|(
name|putc
argument_list|(
operator|*
name|start
operator|^
name|PPP_TRANS
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|unputc
argument_list|(
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|sc_bytessent
operator|+=
literal|2
expr_stmt|;
name|start
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
block|}
comment|/* 	     * If we didn't empty this mbuf, remember where we're up to. 	     * If we emptied the last mbuf, try to add the closing flag, 	     * and if we can't, leave sc_outm pointing to m, but with 	     * m->m_len == 0, to remind us to output the flag later. 	     */
if|if
condition|(
name|len
operator|>
literal|0
operator|||
name|m
operator|->
name|m_next
operator|==
name|NULL
operator|&&
name|putc
argument_list|(
name|PPP_FLAG
argument_list|,
operator|&
name|tp
operator|->
name|t_outq
argument_list|)
condition|)
block|{
name|m
operator|->
name|m_data
operator|=
name|start
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|sc
operator|->
name|sc_outm
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_oproc
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|tp
operator|->
name|t_oproc
call|)
argument_list|(
name|tp
argument_list|)
expr_stmt|;
return|return;
comment|/* can't do any more at the moment */
block|}
comment|/* Finished with this mbuf; free it and move on. */
name|MFREE
argument_list|(
name|m
argument_list|,
name|m2
argument_list|)
expr_stmt|;
name|m
operator|=
name|m2
expr_stmt|;
block|}
do|while
condition|(
name|m
condition|)
do|;
comment|/* Finished a packet */
name|sc
operator|->
name|sc_outm
operator|=
name|NULL
expr_stmt|;
name|sc
operator|->
name|sc_bytessent
operator|++
expr_stmt|;
comment|/* account for closing flag */
name|sc
operator|->
name|sc_if
operator|.
name|if_opackets
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_obytes
operator|=
name|sc
operator|->
name|sc_bytessent
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate enough mbuf to handle current MTU.  */
end_comment

begin_function
specifier|static
name|int
name|pppinit
parameter_list|(
name|sc
parameter_list|)
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|;
name|int
name|len
init|=
name|HDROFF
operator|+
name|MAX
argument_list|(
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
argument_list|,
name|PPP_MRU
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ppp_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
for|for
control|(
name|mp
operator|=
operator|&
name|sc
operator|->
name|sc_m
init|;
operator|(
name|m
operator|=
operator|*
name|mp
operator|)
operator|!=
name|NULL
condition|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
control|)
if|if
condition|(
operator|(
name|len
operator|-=
name|M_DATASIZE
argument_list|(
name|m
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
for|for
control|(
init|;
condition|;
name|mp
operator|=
operator|&
name|m
operator|->
name|m_next
control|)
block|{
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|sc
operator|->
name|sc_m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_m
operator|=
name|NULL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ppp%d: can't allocate mbuf\n"
argument_list|,
name|sc
operator|-
name|ppp_softc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|MCLGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|-=
name|M_DATASIZE
argument_list|(
name|m
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Copy mbuf chain.  Would like to use m_copy(), but we need a real copy  * of the data, not just copies of pointers to the data.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|ppp_btom
parameter_list|(
name|sc
parameter_list|)
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|mp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
init|=
name|sc
operator|->
name|sc_m
decl_stmt|;
comment|/*      * First check current mbuf.  If we have more than a small mbuf,      * return the whole cluster and set beginning of buffer to the      * next mbuf.      * Else, copy the current bytes into a small mbuf, attach the new      * mbuf to the end of the chain and set beginning of buffer to the      * current mbuf.      */
if|if
condition|(
name|sc
operator|->
name|sc_mc
operator|->
name|m_len
operator|>
name|MHLEN
condition|)
block|{
name|sc
operator|->
name|sc_m
operator|=
name|sc
operator|->
name|sc_mc
operator|->
name|m_next
expr_stmt|;
name|sc
operator|->
name|sc_mc
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* rather than waste a whole cluster on<= MHLEN bytes, 	   alloc a small mbuf and copy to it */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|sc
operator|->
name|sc_mc
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_mc
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|sc
operator|->
name|sc_mc
operator|->
name|m_len
expr_stmt|;
for|for
control|(
name|mp
operator|=
operator|&
name|top
init|;
operator|*
name|mp
operator|!=
name|sc
operator|->
name|sc_mc
condition|;
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
control|)
empty_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|sc
operator|->
name|sc_m
operator|=
name|sc
operator|->
name|sc_mc
expr_stmt|;
block|}
comment|/*      * Try to allocate enough extra mbufs to handle the next packet.      */
if|if
condition|(
name|pppinit
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
if|if
condition|(
name|pppinit
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|top
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * tty interface receiver interrupt.  */
end_comment

begin_define
define|#
directive|define
name|COMPTYPE
parameter_list|(
name|proto
parameter_list|)
value|((proto) == PPP_VJC_COMP? TYPE_COMPRESSED_TCP: \ 			 TYPE_UNCOMPRESSED_TCP)
end_define

begin_function
name|void
name|pppinput
parameter_list|(
name|c
parameter_list|,
name|tp
parameter_list|)
name|int
name|c
decl_stmt|;
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
block|{
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ifqueue
modifier|*
name|inq
decl_stmt|;
name|int
name|s
decl_stmt|,
name|ilen
decl_stmt|,
name|xlen
decl_stmt|,
name|proto
decl_stmt|;
name|char
modifier|*
name|pkttype
decl_stmt|;
name|tk_nin
operator|++
expr_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|ppp_softc
operator|*
operator|)
name|tp
operator|->
name|t_sc
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
return|return;
operator|++
name|sc
operator|->
name|sc_if
operator|.
name|if_ibytes
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|TTY_FE
condition|)
comment|/* framing error or overrun on this char - abort packet */
goto|goto
name|flush
goto|;
name|c
operator|&=
literal|0xff
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|PPP_FLAG
condition|)
block|{
name|ilen
operator|=
name|sc
operator|->
name|sc_ilen
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_FLUSH
operator|||
name|ilen
operator|>
literal|0
operator|&&
name|sc
operator|->
name|sc_fcs
operator|!=
name|PPP_GOODFCS
condition|)
block|{
ifdef|#
directive|ifdef
name|VJC
comment|/* 	     * If we've missed a packet, we must toss subsequent compressed 	     * packets which don't have an explicit connection ID. 	     */
name|sl_uncompress_tcp
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|TYPE_ERROR
argument_list|,
operator|&
name|sc
operator|->
name|sc_comp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_FLUSH
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ppp_debug
condition|)
name|printf
argument_list|(
literal|"ppp: bad fcs\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_FLUSH
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ilen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ppp_header
argument_list|)
operator|+
literal|2
condition|)
block|{
if|if
condition|(
name|ilen
condition|)
block|{
if|if
condition|(
name|ppp_debug
condition|)
name|printf
argument_list|(
literal|"ppp: too short (%d)\n"
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * Remove FCS trailer.  Somewhat painful... 	 */
name|ilen
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
operator|--
name|sc
operator|->
name|sc_mc
operator|->
name|m_len
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|m
operator|=
name|sc
operator|->
name|sc_m
init|;
name|m
operator|->
name|m_next
operator|!=
name|sc
operator|->
name|sc_mc
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
empty_stmt|;
name|sc
operator|->
name|sc_mc
operator|=
name|m
expr_stmt|;
block|}
name|sc
operator|->
name|sc_mc
operator|->
name|m_len
operator|--
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ipackets
operator|++
expr_stmt|;
name|m
operator|=
name|sc
operator|->
name|sc_m
expr_stmt|;
if|if
condition|(
name|ppp_async_in_debug
condition|)
block|{
name|printf
argument_list|(
literal|"ppp%d: got %d bytes\n"
argument_list|,
name|sc
operator|-
name|ppp_softc
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
name|pppdumpm
argument_list|(
name|m
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
block|}
name|proto
operator|=
name|ntohs
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ppp_header
operator|*
argument_list|)
operator|->
name|ph_protocol
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|proto
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|PPP_IP
case|:
name|ilen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ppp_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ppp_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ppp_header
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|VJC
case|case
name|PPP_VJC_COMP
case|:
case|case
name|PPP_VJC_UNCOMP
case|:
name|pkttype
operator|=
name|proto
operator|==
name|PPP_VJC_COMP
condition|?
literal|""
else|:
literal|"un"
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_COMP_TCP
condition|)
block|{
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ppp_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ppp_header
argument_list|)
expr_stmt|;
name|ilen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ppp_header
argument_list|)
expr_stmt|;
name|xlen
operator|=
name|sl_uncompress_tcp_part
argument_list|(
operator|(
name|u_char
operator|*
operator|*
operator|)
operator|(
operator|&
name|m
operator|->
name|m_data
operator|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|ilen
argument_list|,
name|COMPTYPE
argument_list|(
name|proto
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sc_comp
argument_list|)
expr_stmt|;
if|if
condition|(
name|xlen
condition|)
block|{
comment|/* adjust the first mbuf by the decompressed amt */
name|m
operator|->
name|m_len
operator|+=
name|xlen
operator|-
name|ilen
expr_stmt|;
name|ilen
operator|=
name|xlen
expr_stmt|;
name|proto
operator|=
name|PPP_IP
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ppp_debug
condition|)
name|printf
argument_list|(
literal|"ppp%d: sl_uncompress failed on type %scomp\n"
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
argument_list|,
name|pkttype
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ppp_debug
condition|)
name|printf
argument_list|(
literal|"ppp%d: %scomp pkt w/o compression; flags 0x%x\n"
argument_list|,
name|sc
operator|->
name|sc_if
operator|.
name|if_unit
argument_list|,
name|pkttype
argument_list|,
name|sc
operator|->
name|sc_flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ppp_debug
condition|)
name|printf
argument_list|(
literal|"ppp: packet rejected, protocol 0x%x\n"
argument_list|,
name|proto
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
return|return;
endif|#
directive|endif
endif|#
directive|endif
block|}
comment|/* get this packet as an mbuf chain */
if|if
condition|(
operator|(
name|m
operator|=
name|ppp_btom
argument_list|(
name|sc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|ilen
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|&
name|sc
operator|->
name|sc_if
expr_stmt|;
if|if
condition|(
name|proto
operator|==
name|PPP_IP
condition|)
block|{
comment|/* IP packet - pass it up to IP */
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_if
operator|.
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* interface is down - drop the packet. */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
return|return;
block|}
name|schednetisr
argument_list|(
name|NETISR_IP
argument_list|)
expr_stmt|;
name|inq
operator|=
operator|&
name|ipintrq
expr_stmt|;
block|}
else|else
block|{
comment|/* some other protocol - place on input queue for read() */
comment|/* Put a placeholder byte in canq for ttselect()/ttnread() */
name|putc
argument_list|(
literal|0
argument_list|,
operator|&
name|tp
operator|->
name|t_canq
argument_list|)
expr_stmt|;
name|ttwakeup
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|inq
operator|=
operator|&
name|sc
operator|->
name|sc_inq
expr_stmt|;
block|}
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
name|inq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
name|inq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ppp_debug
condition|)
name|printf
argument_list|(
literal|"ppp: queue full\n"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_if
operator|.
name|if_iqdrops
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
name|IF_ENQUEUE
argument_list|(
name|inq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_FLUSH
condition|)
return|return;
if|if
condition|(
name|c
operator|==
name|PPP_ESCAPE
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator||=
name|SC_ESCAPED
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_ESCAPED
condition|)
block|{
name|sc
operator|->
name|sc_flags
operator|&=
operator|~
name|SC_ESCAPED
expr_stmt|;
name|c
operator|^=
name|PPP_TRANS
expr_stmt|;
block|}
comment|/*      * Initialize buffer on first octet received.      * First octet could be address or protocol (when compressing      * address/control).      * Second octet is control.      * Third octet is first or second (when compressing protocol)      * octet of protocol.      * Fourth octet is second octet of protocol.      */
if|if
condition|(
name|sc
operator|->
name|sc_ilen
operator|==
literal|0
condition|)
block|{
comment|/* reset the first input mbuf */
name|m
operator|=
name|sc
operator|->
name|sc_m
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|M_DATASTART
argument_list|(
name|sc
operator|->
name|sc_m
argument_list|)
operator|+
name|HDROFF
expr_stmt|;
name|sc
operator|->
name|sc_mc
operator|=
name|m
expr_stmt|;
name|sc
operator|->
name|sc_mp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_fcs
operator|=
name|PPP_INITFCS
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|PPP_ALLSTATIONS
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_COMP_AC
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ppp_debug
condition|)
name|printf
argument_list|(
literal|"ppp: missing ALLSTATIONS, got 0x%x; flags %x\n"
argument_list|,
name|c
argument_list|,
name|sc
operator|->
name|sc_flags
argument_list|)
expr_stmt|;
goto|goto
name|flush
goto|;
block|}
operator|*
name|sc
operator|->
name|sc_mp
operator|++
operator|=
name|PPP_ALLSTATIONS
expr_stmt|;
operator|*
name|sc
operator|->
name|sc_mp
operator|++
operator|=
name|PPP_UI
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|+=
literal|2
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc
operator|->
name|sc_ilen
operator|==
literal|1
operator|&&
name|c
operator|!=
name|PPP_UI
condition|)
block|{
if|if
condition|(
name|ppp_debug
condition|)
name|printf
argument_list|(
literal|"ppp: missing UI, got 0x%x\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
goto|goto
name|flush
goto|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_ilen
operator|==
literal|2
operator|&&
operator|(
name|c
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|SC_COMP_PROT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ppp_debug
condition|)
name|printf
argument_list|(
literal|"ppp: compressed protocol %x, but compression off\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
goto|goto
name|flush
goto|;
block|}
operator|*
name|sc
operator|->
name|sc_mp
operator|++
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_ilen
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_mc
operator|->
name|m_len
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_ilen
operator|==
literal|3
operator|&&
operator|(
name|c
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ppp_debug
condition|)
name|printf
argument_list|(
literal|"ppp: bad protocol %x\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
goto|goto
name|flush
goto|;
block|}
comment|/* packet beyond configured mtu? */
if|if
condition|(
operator|++
name|sc
operator|->
name|sc_ilen
operator|>
name|MAX
argument_list|(
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
argument_list|,
name|PPP_MRU
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ppp_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
condition|)
block|{
if|if
condition|(
name|ppp_debug
condition|)
name|printf
argument_list|(
literal|"ppp: packet too big\n"
argument_list|)
expr_stmt|;
goto|goto
name|flush
goto|;
block|}
comment|/* is this mbuf full? */
name|m
operator|=
name|sc
operator|->
name|sc_mc
expr_stmt|;
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_mc
operator|=
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ppp%d: too few input mbufs!\n"
argument_list|)
expr_stmt|;
goto|goto
name|flush
goto|;
block|}
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_data
operator|=
name|M_DATASTART
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_mp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
operator|++
name|m
operator|->
name|m_len
expr_stmt|;
operator|*
name|sc
operator|->
name|sc_mp
operator|++
operator|=
name|c
expr_stmt|;
name|sc
operator|->
name|sc_fcs
operator|=
name|PPP_FCS
argument_list|(
name|sc
operator|->
name|sc_fcs
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
name|flush
label|:
name|sc
operator|->
name|sc_if
operator|.
name|if_ierrors
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator||=
name|SC_FLUSH
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an ioctl request to interface.  */
end_comment

begin_expr_stmt
name|pppioctl
argument_list|(
name|ifp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|)
specifier|register
expr|struct
name|ifnet
operator|*
name|ifp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|proc
modifier|*
name|p
init|=
name|curproc
decl_stmt|;
comment|/* XXX */
specifier|register
name|struct
name|ppp_softc
modifier|*
name|sc
init|=
operator|&
name|ppp_softc
index|[
name|ifp
operator|->
name|if_unit
index|]
decl_stmt|;
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|data
decl_stmt|;
specifier|register
name|struct
name|ifreq
modifier|*
name|ifr
init|=
operator|(
expr|struct
name|ifreq
operator|*
operator|)
name|data
decl_stmt|;
name|int
name|s
init|=
name|splimp
argument_list|()
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSIFFLAGS
case|:
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_RUNNING
operator|)
operator|==
literal|0
condition|)
name|ifp
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
break|break;
case|case
name|SIOCSIFADDR
case|:
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
case|case
name|SIOCSIFDSTADDR
case|:
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
case|case
name|SIOCSIFMTU
case|:
if|if
condition|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
operator|=
name|ifr
operator|->
name|ifr_mtu
expr_stmt|;
if|if
condition|(
name|pppinit
argument_list|(
name|sc
argument_list|)
operator|==
literal|0
condition|)
name|error
operator|=
name|ENOBUFS
expr_stmt|;
break|break;
case|case
name|SIOCGIFMTU
case|:
name|ifr
operator|->
name|ifr_mtu
operator|=
name|sc
operator|->
name|sc_if
operator|.
name|if_mtu
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_block

begin_define
define|#
directive|define
name|MAX_DUMP_BYTES
value|128
end_define

begin_function
specifier|static
name|void
name|pppdumpm
parameter_list|(
name|m0
parameter_list|,
name|pktlen
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|2
operator|*
name|MAX_DUMP_BYTES
operator|+
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|static
name|char
name|digits
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
for|for
control|(
name|m
operator|=
name|m0
init|;
name|m
operator|&&
name|pktlen
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|int
name|l
init|=
name|m
operator|->
name|m_len
decl_stmt|;
name|u_char
modifier|*
name|rptr
init|=
operator|(
name|u_char
operator|*
operator|)
name|m
operator|->
name|m_data
decl_stmt|;
if|if
condition|(
name|pktlen
operator|>
literal|0
condition|)
block|{
name|l
operator|=
name|min
argument_list|(
name|l
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
name|pktlen
operator|-=
name|l
expr_stmt|;
block|}
while|while
condition|(
name|l
operator|--
condition|)
block|{
if|if
condition|(
name|bp
operator|>
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|4
condition|)
goto|goto
name|done
goto|;
operator|*
name|bp
operator|++
operator|=
name|digits
index|[
operator|*
name|rptr
operator|>>
literal|4
index|]
expr_stmt|;
comment|/* convert byte to ascii hex */
operator|*
name|bp
operator|++
operator|=
name|digits
index|[
operator|*
name|rptr
operator|++
operator|&
literal|0xf
index|]
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_next
condition|)
block|{
if|if
condition|(
name|bp
operator|>
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|3
condition|)
goto|goto
name|done
goto|;
operator|*
name|bp
operator|++
operator|=
literal|'|'
expr_stmt|;
block|}
block|}
name|done
label|:
if|if
condition|(
name|m
operator|&&
name|pktlen
condition|)
operator|*
name|bp
operator|++
operator|=
literal|'>'
expr_stmt|;
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pppdumpb
parameter_list|(
name|b
parameter_list|,
name|l
parameter_list|)
name|u_char
modifier|*
name|b
decl_stmt|;
name|int
name|l
decl_stmt|;
block|{
name|char
name|buf
index|[
literal|2
operator|*
name|MAX_DUMP_BYTES
operator|+
literal|4
index|]
decl_stmt|;
name|char
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
specifier|static
name|char
name|digits
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
name|digits
index|[
operator|*
name|b
operator|>>
literal|4
index|]
expr_stmt|;
comment|/* convert byte to ascii hex */
operator|*
name|bp
operator|++
operator|=
name|digits
index|[
operator|*
name|b
operator|++
operator|&
literal|0xf
index|]
expr_stmt|;
if|if
condition|(
name|bp
operator|>=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|2
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|'>'
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|bp
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NPPP> 0 */
end_comment

end_unit

