begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1989, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)slcompress.c	8.2 (Berkeley) 4/16/94  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Routines to compress and uncompess tcp packets (for transmission  * over low speed serial lines.  *  * Van Jacobson (van@helios.ee.lbl.gov), Dec 31, 1989:  *	- Initial distribution.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<net/slcompress.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|SL_NO_STATS
end_ifndef

begin_define
define|#
directive|define
name|INCR
parameter_list|(
name|counter
parameter_list|)
value|++comp->counter;
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INCR
parameter_list|(
name|counter
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|BCMP
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|,
name|n
parameter_list|)
value|bcmp((char *)(p1), (char *)(p2), (int)(n))
end_define

begin_define
define|#
directive|define
name|BCOPY
parameter_list|(
name|p1
parameter_list|,
name|p2
parameter_list|,
name|n
parameter_list|)
value|bcopy((char *)(p1), (char *)(p2), (int)(n))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|_KERNEL
end_ifndef

begin_define
define|#
directive|define
name|ovbcopy
value|bcopy
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|sl_compress_init
parameter_list|(
name|comp
parameter_list|,
name|max_state
parameter_list|)
name|struct
name|slcompress
modifier|*
name|comp
decl_stmt|;
name|int
name|max_state
decl_stmt|;
block|{
specifier|register
name|u_int
name|i
decl_stmt|;
specifier|register
name|struct
name|cstate
modifier|*
name|tstate
init|=
name|comp
operator|->
name|tstate
decl_stmt|;
if|if
condition|(
name|max_state
operator|==
operator|-
literal|1
condition|)
block|{
name|max_state
operator|=
name|MAX_STATES
operator|-
literal|1
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|comp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|comp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Don't reset statistics */
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|comp
operator|->
name|tstate
argument_list|,
sizeof|sizeof
argument_list|(
name|comp
operator|->
name|tstate
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|comp
operator|->
name|rstate
argument_list|,
sizeof|sizeof
argument_list|(
name|comp
operator|->
name|rstate
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|max_state
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|tstate
index|[
name|i
index|]
operator|.
name|cs_id
operator|=
name|i
expr_stmt|;
name|tstate
index|[
name|i
index|]
operator|.
name|cs_next
operator|=
operator|&
name|tstate
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|tstate
index|[
literal|0
index|]
operator|.
name|cs_next
operator|=
operator|&
name|tstate
index|[
name|max_state
index|]
expr_stmt|;
name|tstate
index|[
literal|0
index|]
operator|.
name|cs_id
operator|=
literal|0
expr_stmt|;
name|comp
operator|->
name|last_cs
operator|=
operator|&
name|tstate
index|[
literal|0
index|]
expr_stmt|;
name|comp
operator|->
name|last_recv
operator|=
literal|255
expr_stmt|;
name|comp
operator|->
name|last_xmit
operator|=
literal|255
expr_stmt|;
name|comp
operator|->
name|flags
operator|=
name|SLF_TOSS
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ENCODE encodes a number that is known to be non-zero.  ENCODEZ  * checks for zero (since zero has to be encoded in the long, 3 byte  * form).  */
end_comment

begin_define
define|#
directive|define
name|ENCODE
parameter_list|(
name|n
parameter_list|)
value|{ \ 	if ((u_int16_t)(n)>= 256) { \ 		*cp++ = 0; \ 		cp[1] = (n); \ 		cp[0] = (n)>> 8; \ 		cp += 2; \ 	} else { \ 		*cp++ = (n); \ 	} \ }
end_define

begin_define
define|#
directive|define
name|ENCODEZ
parameter_list|(
name|n
parameter_list|)
value|{ \ 	if ((u_int16_t)(n)>= 256 || (u_int16_t)(n) == 0) { \ 		*cp++ = 0; \ 		cp[1] = (n); \ 		cp[0] = (n)>> 8; \ 		cp += 2; \ 	} else { \ 		*cp++ = (n); \ 	} \ }
end_define

begin_define
define|#
directive|define
name|DECODEL
parameter_list|(
name|f
parameter_list|)
value|{ \ 	if (*cp == 0) {\ 		(f) = htonl(ntohl(f) + ((cp[1]<< 8) | cp[2])); \ 		cp += 3; \ 	} else { \ 		(f) = htonl(ntohl(f) + (u_int32_t)*cp++); \ 	} \ }
end_define

begin_define
define|#
directive|define
name|DECODES
parameter_list|(
name|f
parameter_list|)
value|{ \ 	if (*cp == 0) {\ 		(f) = htons(ntohs(f) + ((cp[1]<< 8) | cp[2])); \ 		cp += 3; \ 	} else { \ 		(f) = htons(ntohs(f) + (u_int32_t)*cp++); \ 	} \ }
end_define

begin_define
define|#
directive|define
name|DECODEU
parameter_list|(
name|f
parameter_list|)
value|{ \ 	if (*cp == 0) {\ 		(f) = htons((cp[1]<< 8) | cp[2]); \ 		cp += 3; \ 	} else { \ 		(f) = htons((u_int32_t)*cp++); \ 	} \ }
end_define

begin_comment
comment|/*  * Attempt to compress an outgoing TCP packet and return the type of  * the result.  The caller must have already verified that the protocol  * is TCP.  The first mbuf must contain the complete IP and TCP headers,  * and "ip" must be == mtod(m, struct ip *).  "comp" supplies the  * compression state, and "compress_cid" tells us whether it is OK  * to leave out the CID field when feasible.  *  * The caller is responsible for adjusting m->m_pkthdr.len upon return,  * if m is an M_PKTHDR mbuf.  */
end_comment

begin_function
name|u_int
name|sl_compress_tcp
parameter_list|(
name|m
parameter_list|,
name|ip
parameter_list|,
name|comp
parameter_list|,
name|compress_cid
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|slcompress
modifier|*
name|comp
decl_stmt|;
name|int
name|compress_cid
decl_stmt|;
block|{
specifier|register
name|struct
name|cstate
modifier|*
name|cs
init|=
name|comp
operator|->
name|last_cs
operator|->
name|cs_next
decl_stmt|;
specifier|register
name|u_int
name|hlen
init|=
name|ip
operator|->
name|ip_hl
decl_stmt|;
specifier|register
name|struct
name|tcphdr
modifier|*
name|oth
decl_stmt|;
specifier|register
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
specifier|register
name|u_int
name|deltaS
decl_stmt|,
name|deltaA
decl_stmt|;
specifier|register
name|u_int
name|changes
init|=
literal|0
decl_stmt|;
name|u_char
name|new_seq
index|[
literal|16
index|]
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
init|=
name|new_seq
decl_stmt|;
comment|/* 	 * Bail if this is an IP fragment or if the TCP packet isn't 	 * `compressible' (i.e., ACK isn't set or some other control bit is 	 * set).  (We assume that the caller has already made sure the 	 * packet is IP proto TCP). 	 */
if|if
condition|(
operator|(
name|ip
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
literal|0x3fff
argument_list|)
operator|)
operator|||
name|m
operator|->
name|m_len
operator|<
literal|40
condition|)
return|return
operator|(
name|TYPE_IP
operator|)
return|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|&
operator|(
operator|(
name|int32_t
operator|*
operator|)
name|ip
operator|)
index|[
name|hlen
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|th
operator|->
name|th_flags
operator|&
operator|(
name|TH_SYN
operator||
name|TH_FIN
operator||
name|TH_RST
operator||
name|TH_ACK
operator|)
operator|)
operator|!=
name|TH_ACK
condition|)
return|return
operator|(
name|TYPE_IP
operator|)
return|;
comment|/* 	 * Packet is compressible -- we're going to send either a 	 * COMPRESSED_TCP or UNCOMPRESSED_TCP packet.  Either way we need 	 * to locate (or create) the connection state.  Special case the 	 * most recently used connection since it's most likely to be used 	 * again& we don't have to do any reordering if it's used. 	 */
name|INCR
argument_list|(
argument|sls_packets
argument_list|)
if|if
condition|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|!=
name|cs
operator|->
name|cs_ip
operator|.
name|ip_src
operator|.
name|s_addr
operator|||
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|!=
name|cs
operator|->
name|cs_ip
operator|.
name|ip_dst
operator|.
name|s_addr
operator|||
operator|*
operator|(
name|int32_t
operator|*
operator|)
name|th
operator|!=
operator|(
operator|(
name|int32_t
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
name|cs
operator|->
name|cs_ip
operator|.
name|ip_hl
index|]
condition|)
block|{
comment|/* 		 * Wasn't the first -- search for it. 		 * 		 * States are kept in a circularly linked list with 		 * last_cs pointing to the end of the list.  The 		 * list is kept in lru order by moving a state to the 		 * head of the list whenever it is referenced.  Since 		 * the list is short and, empirically, the connection 		 * we want is almost always near the front, we locate 		 * states via linear search.  If we don't find a state 		 * for the datagram, the oldest state is (re-)used. 		 */
specifier|register
name|struct
name|cstate
modifier|*
name|lcs
decl_stmt|;
specifier|register
name|struct
name|cstate
modifier|*
name|lastcs
init|=
name|comp
operator|->
name|last_cs
decl_stmt|;
do|do
block|{
name|lcs
operator|=
name|cs
expr_stmt|;
name|cs
operator|=
name|cs
operator|->
name|cs_next
expr_stmt|;
name|INCR
argument_list|(
argument|sls_searches
argument_list|)
if|if
condition|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|==
name|cs
operator|->
name|cs_ip
operator|.
name|ip_src
operator|.
name|s_addr
operator|&&
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|==
name|cs
operator|->
name|cs_ip
operator|.
name|ip_dst
operator|.
name|s_addr
operator|&&
operator|*
operator|(
name|int32_t
operator|*
operator|)
name|th
operator|==
operator|(
operator|(
name|int32_t
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
name|cs
operator|->
name|cs_ip
operator|.
name|ip_hl
index|]
condition|)
goto|goto
name|found
goto|;
block|}
do|while
condition|(
name|cs
operator|!=
name|lastcs
condition|)
do|;
comment|/* 		 * Didn't find it -- re-use oldest cstate.  Send an 		 * uncompressed packet that tells the other side what 		 * connection number we're using for this conversation. 		 * Note that since the state list is circular, the oldest 		 * state points to the newest and we only need to set 		 * last_cs to update the lru linkage. 		 */
name|INCR
argument_list|(
argument|sls_misses
argument_list|)
name|comp
operator|->
name|last_cs
operator|=
name|lcs
expr_stmt|;
name|hlen
operator|+=
name|th
operator|->
name|th_off
expr_stmt|;
name|hlen
operator|<<=
literal|2
expr_stmt|;
if|if
condition|(
name|hlen
operator|>
name|m
operator|->
name|m_len
condition|)
return|return
name|TYPE_IP
return|;
goto|goto
name|uncompressed
goto|;
name|found
label|:
comment|/* 		 * Found it -- move to the front on the connection list. 		 */
if|if
condition|(
name|cs
operator|==
name|lastcs
condition|)
name|comp
operator|->
name|last_cs
operator|=
name|lcs
expr_stmt|;
else|else
block|{
name|lcs
operator|->
name|cs_next
operator|=
name|cs
operator|->
name|cs_next
expr_stmt|;
name|cs
operator|->
name|cs_next
operator|=
name|lastcs
operator|->
name|cs_next
expr_stmt|;
name|lastcs
operator|->
name|cs_next
operator|=
name|cs
expr_stmt|;
block|}
block|}
comment|/* 	 * Make sure that only what we expect to change changed. The first 	 * line of the `if' checks the IP protocol version, header length& 	 * type of service.  The 2nd line checks the "Don't fragment" bit. 	 * The 3rd line checks the time-to-live and protocol (the protocol 	 * check is unnecessary but costless).  The 4th line checks the TCP 	 * header length.  The 5th line checks IP options, if any.  The 6th 	 * line checks TCP options, if any.  If any of these things are 	 * different between the previous& current datagram, we send the 	 * current datagram `uncompressed'. 	 */
name|oth
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|&
operator|(
operator|(
name|int32_t
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
name|hlen
index|]
expr_stmt|;
name|deltaS
operator|=
name|hlen
expr_stmt|;
name|hlen
operator|+=
name|th
operator|->
name|th_off
expr_stmt|;
name|hlen
operator|<<=
literal|2
expr_stmt|;
if|if
condition|(
name|hlen
operator|>
name|m
operator|->
name|m_len
condition|)
return|return
name|TYPE_IP
return|;
if|if
condition|(
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|ip
operator|)
index|[
literal|0
index|]
operator|!=
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
literal|0
index|]
operator|||
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|ip
operator|)
index|[
literal|3
index|]
operator|!=
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
literal|3
index|]
operator|||
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|ip
operator|)
index|[
literal|4
index|]
operator|!=
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
literal|4
index|]
operator|||
name|th
operator|->
name|th_off
operator|!=
name|oth
operator|->
name|th_off
operator|||
operator|(
name|deltaS
operator|>
literal|5
operator|&&
name|BCMP
argument_list|(
name|ip
operator|+
literal|1
argument_list|,
operator|&
name|cs
operator|->
name|cs_ip
operator|+
literal|1
argument_list|,
operator|(
name|deltaS
operator|-
literal|5
operator|)
operator|<<
literal|2
argument_list|)
operator|)
operator|||
operator|(
name|th
operator|->
name|th_off
operator|>
literal|5
operator|&&
name|BCMP
argument_list|(
name|th
operator|+
literal|1
argument_list|,
name|oth
operator|+
literal|1
argument_list|,
operator|(
name|th
operator|->
name|th_off
operator|-
literal|5
operator|)
operator|<<
literal|2
argument_list|)
operator|)
condition|)
goto|goto
name|uncompressed
goto|;
comment|/* 	 * Figure out which of the changing fields changed.  The 	 * receiver expects changes in the order: urgent, window, 	 * ack, seq (the order minimizes the number of temporaries 	 * needed in this section of code). 	 */
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_URG
condition|)
block|{
name|deltaS
operator|=
name|ntohs
argument_list|(
name|th
operator|->
name|th_urp
argument_list|)
expr_stmt|;
name|ENCODEZ
argument_list|(
name|deltaS
argument_list|)
expr_stmt|;
name|changes
operator||=
name|NEW_U
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|th
operator|->
name|th_urp
operator|!=
name|oth
operator|->
name|th_urp
condition|)
comment|/* argh! URG not set but urp changed -- a sensible 		 * implementation should never do this but RFC793 		 * doesn't prohibit the change so we have to deal 		 * with it. */
goto|goto
name|uncompressed
goto|;
name|deltaS
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
name|ntohs
argument_list|(
name|th
operator|->
name|th_win
argument_list|)
operator|-
name|ntohs
argument_list|(
name|oth
operator|->
name|th_win
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|deltaS
condition|)
block|{
name|ENCODE
argument_list|(
name|deltaS
argument_list|)
expr_stmt|;
name|changes
operator||=
name|NEW_W
expr_stmt|;
block|}
name|deltaA
operator|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_ack
argument_list|)
operator|-
name|ntohl
argument_list|(
name|oth
operator|->
name|th_ack
argument_list|)
expr_stmt|;
if|if
condition|(
name|deltaA
condition|)
block|{
if|if
condition|(
name|deltaA
operator|>
literal|0xffff
condition|)
goto|goto
name|uncompressed
goto|;
name|ENCODE
argument_list|(
name|deltaA
argument_list|)
expr_stmt|;
name|changes
operator||=
name|NEW_A
expr_stmt|;
block|}
name|deltaS
operator|=
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
operator|-
name|ntohl
argument_list|(
name|oth
operator|->
name|th_seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|deltaS
condition|)
block|{
if|if
condition|(
name|deltaS
operator|>
literal|0xffff
condition|)
goto|goto
name|uncompressed
goto|;
name|ENCODE
argument_list|(
name|deltaS
argument_list|)
expr_stmt|;
name|changes
operator||=
name|NEW_S
expr_stmt|;
block|}
switch|switch
condition|(
name|changes
condition|)
block|{
case|case
literal|0
case|:
comment|/* 		 * Nothing changed. If this packet contains data and the 		 * last one didn't, this is probably a data packet following 		 * an ack (normal on an interactive connection) and we send 		 * it compressed.  Otherwise it's probably a retransmit, 		 * retransmitted ack or window probe.  Send it uncompressed 		 * in case the other side missed the compressed version. 		 */
if|if
condition|(
name|ip
operator|->
name|ip_len
operator|!=
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
operator|&&
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
argument_list|)
operator|==
name|hlen
condition|)
break|break;
comment|/* (fall through) */
case|case
name|SPECIAL_I
case|:
case|case
name|SPECIAL_D
case|:
comment|/* 		 * actual changes match one of our special case encodings -- 		 * send packet uncompressed. 		 */
goto|goto
name|uncompressed
goto|;
case|case
name|NEW_S
operator||
name|NEW_A
case|:
if|if
condition|(
name|deltaS
operator|==
name|deltaA
operator|&&
name|deltaS
operator|==
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
argument_list|)
operator|-
name|hlen
condition|)
block|{
comment|/* special case for echoed terminal traffic */
name|changes
operator|=
name|SPECIAL_I
expr_stmt|;
name|cp
operator|=
name|new_seq
expr_stmt|;
block|}
break|break;
case|case
name|NEW_S
case|:
if|if
condition|(
name|deltaS
operator|==
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
argument_list|)
operator|-
name|hlen
condition|)
block|{
comment|/* special case for data xfer */
name|changes
operator|=
name|SPECIAL_D
expr_stmt|;
name|cp
operator|=
name|new_seq
expr_stmt|;
block|}
break|break;
block|}
name|deltaS
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_id
argument_list|)
operator|-
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|deltaS
operator|!=
literal|1
condition|)
block|{
name|ENCODEZ
argument_list|(
name|deltaS
argument_list|)
expr_stmt|;
name|changes
operator||=
name|NEW_I
expr_stmt|;
block|}
if|if
condition|(
name|th
operator|->
name|th_flags
operator|&
name|TH_PUSH
condition|)
name|changes
operator||=
name|TCP_PUSH_BIT
expr_stmt|;
comment|/* 	 * Grab the cksum before we overwrite it below.  Then update our 	 * state with this packet's header. 	 */
name|deltaA
operator|=
name|ntohs
argument_list|(
name|th
operator|->
name|th_sum
argument_list|)
expr_stmt|;
name|BCOPY
argument_list|(
name|ip
argument_list|,
operator|&
name|cs
operator|->
name|cs_ip
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
comment|/* 	 * We want to use the original packet as our compressed packet. 	 * (cp - new_seq) is the number of bytes we need for compressed 	 * sequence numbers.  In addition we need one byte for the change 	 * mask, one for the connection id and two for the tcp checksum. 	 * So, (cp - new_seq) + 4 bytes of header are needed.  hlen is how 	 * many bytes of the original packet to toss so subtract the two to 	 * get the new packet size. 	 */
name|deltaS
operator|=
name|cp
operator|-
name|new_seq
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|ip
expr_stmt|;
if|if
condition|(
name|compress_cid
operator|==
literal|0
operator|||
name|comp
operator|->
name|last_xmit
operator|!=
name|cs
operator|->
name|cs_id
condition|)
block|{
name|comp
operator|->
name|last_xmit
operator|=
name|cs
operator|->
name|cs_id
expr_stmt|;
name|hlen
operator|-=
name|deltaS
operator|+
literal|4
expr_stmt|;
name|cp
operator|+=
name|hlen
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|changes
operator||
name|NEW_C
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|cs
operator|->
name|cs_id
expr_stmt|;
block|}
else|else
block|{
name|hlen
operator|-=
name|deltaS
operator|+
literal|3
expr_stmt|;
name|cp
operator|+=
name|hlen
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|changes
expr_stmt|;
block|}
name|m
operator|->
name|m_len
operator|-=
name|hlen
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|hlen
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|deltaA
operator|>>
literal|8
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|deltaA
expr_stmt|;
name|BCOPY
argument_list|(
name|new_seq
argument_list|,
name|cp
argument_list|,
name|deltaS
argument_list|)
expr_stmt|;
name|INCR
argument_list|(
argument|sls_compressed
argument_list|)
return|return
operator|(
name|TYPE_COMPRESSED_TCP
operator|)
return|;
comment|/* 	 * Update connection state cs& send uncompressed packet ('uncompressed' 	 * means a regular ip/tcp packet but with the 'conversation id' we hope 	 * to use on future compressed packets in the protocol field). 	 */
name|uncompressed
label|:
name|BCOPY
argument_list|(
name|ip
argument_list|,
operator|&
name|cs
operator|->
name|cs_ip
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|cs
operator|->
name|cs_id
expr_stmt|;
name|comp
operator|->
name|last_xmit
operator|=
name|cs
operator|->
name|cs_id
expr_stmt|;
return|return
operator|(
name|TYPE_UNCOMPRESSED_TCP
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sl_uncompress_tcp
parameter_list|(
name|bufp
parameter_list|,
name|len
parameter_list|,
name|type
parameter_list|,
name|comp
parameter_list|)
name|u_char
modifier|*
modifier|*
name|bufp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|u_int
name|type
decl_stmt|;
name|struct
name|slcompress
modifier|*
name|comp
decl_stmt|;
block|{
name|u_char
modifier|*
name|hdr
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|hlen
decl_stmt|,
name|vjlen
decl_stmt|;
name|cp
operator|=
name|bufp
condition|?
operator|*
name|bufp
else|:
name|NULL
expr_stmt|;
name|vjlen
operator|=
name|sl_uncompress_tcp_core
argument_list|(
name|cp
argument_list|,
name|len
argument_list|,
name|len
argument_list|,
name|type
argument_list|,
name|comp
argument_list|,
operator|&
name|hdr
argument_list|,
operator|&
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|vjlen
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* error */
if|if
condition|(
name|vjlen
operator|==
literal|0
condition|)
return|return
operator|(
name|len
operator|)
return|;
comment|/* was uncompressed already */
name|cp
operator|+=
name|vjlen
expr_stmt|;
name|len
operator|-=
name|vjlen
expr_stmt|;
comment|/* 	 * At this point, cp points to the first byte of data in the 	 * packet.  If we're not aligned on a 4-byte boundary, copy the 	 * data down so the ip& tcp headers will be aligned.  Then back up 	 * cp by the tcp/ip header length to make room for the reconstructed 	 * header (we assume the packet we were handed has enough space to 	 * prepend 128 bytes of header). 	 */
if|if
condition|(
operator|(
name|intptr_t
operator|)
name|cp
operator|&
literal|3
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|ovbcopy
argument_list|(
name|cp
argument_list|,
call|(
name|caddr_t
call|)
argument_list|(
operator|(
name|intptr_t
operator|)
name|cp
operator|&
operator|~
literal|3
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
operator|(
name|intptr_t
operator|)
name|cp
operator|&
operator|~
literal|3
operator|)
expr_stmt|;
block|}
name|cp
operator|-=
name|hlen
expr_stmt|;
name|len
operator|+=
name|hlen
expr_stmt|;
name|BCOPY
argument_list|(
name|hdr
argument_list|,
name|cp
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
operator|*
name|bufp
operator|=
name|cp
expr_stmt|;
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Uncompress a packet of total length total_len.  The first buflen  * bytes are at buf; this must include the entire (compressed or  * uncompressed) TCP/IP header.  This procedure returns the length  * of the VJ header, with a pointer to the uncompressed IP header  * in *hdrp and its length in *hlenp.  */
end_comment

begin_function
name|int
name|sl_uncompress_tcp_core
parameter_list|(
name|buf
parameter_list|,
name|buflen
parameter_list|,
name|total_len
parameter_list|,
name|type
parameter_list|,
name|comp
parameter_list|,
name|hdrp
parameter_list|,
name|hlenp
parameter_list|)
name|u_char
modifier|*
name|buf
decl_stmt|;
name|int
name|buflen
decl_stmt|,
name|total_len
decl_stmt|;
name|u_int
name|type
decl_stmt|;
name|struct
name|slcompress
modifier|*
name|comp
decl_stmt|;
name|u_char
modifier|*
modifier|*
name|hdrp
decl_stmt|;
name|u_int
modifier|*
name|hlenp
decl_stmt|;
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|u_int
name|hlen
decl_stmt|,
name|changes
decl_stmt|;
specifier|register
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
specifier|register
name|struct
name|cstate
modifier|*
name|cs
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
specifier|register
name|u_int16_t
modifier|*
name|bp
decl_stmt|;
specifier|register
name|u_int
name|vjlen
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|TYPE_UNCOMPRESSED_TCP
case|:
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|buf
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|>=
name|MAX_STATES
condition|)
goto|goto
name|bad
goto|;
name|cs
operator|=
operator|&
name|comp
operator|->
name|rstate
index|[
name|comp
operator|->
name|last_recv
operator|=
name|ip
operator|->
name|ip_p
index|]
expr_stmt|;
name|comp
operator|->
name|flags
operator|&=
operator|~
name|SLF_TOSS
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_TCP
expr_stmt|;
comment|/* 		 * Calculate the size of the TCP/IP header and make sure that 		 * we don't overflow the space we have available for it. 		 */
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|hlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
operator|>
name|buflen
condition|)
goto|goto
name|bad
goto|;
name|hlen
operator|+=
operator|(
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|)
index|[
name|hlen
index|]
operator|)
operator|->
name|th_off
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|hlen
operator|>
name|MAX_HDR
operator|||
name|hlen
operator|>
name|buflen
condition|)
goto|goto
name|bad
goto|;
name|BCOPY
argument_list|(
name|ip
argument_list|,
operator|&
name|cs
operator|->
name|cs_ip
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|cs
operator|->
name|cs_hlen
operator|=
name|hlen
expr_stmt|;
name|INCR
argument_list|(
name|sls_uncompressedin
argument_list|)
operator|*
name|hdrp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
expr_stmt|;
operator|*
name|hlenp
operator|=
name|hlen
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
goto|goto
name|bad
goto|;
case|case
name|TYPE_COMPRESSED_TCP
case|:
break|break;
block|}
comment|/* We've got a compressed packet. */
name|INCR
argument_list|(
argument|sls_compressedin
argument_list|)
name|cp
operator|=
name|buf
expr_stmt|;
name|changes
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|changes
operator|&
name|NEW_C
condition|)
block|{
comment|/* Make sure the state index is in range, then grab the state. 		 * If we have a good state index, clear the 'discard' flag. */
if|if
condition|(
operator|*
name|cp
operator|>=
name|MAX_STATES
condition|)
goto|goto
name|bad
goto|;
name|comp
operator|->
name|flags
operator|&=
operator|~
name|SLF_TOSS
expr_stmt|;
name|comp
operator|->
name|last_recv
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* this packet has an implicit state index.  If we've 		 * had a line error since the last time we got an 		 * explicit state index, we have to toss the packet. */
if|if
condition|(
name|comp
operator|->
name|flags
operator|&
name|SLF_TOSS
condition|)
block|{
name|INCR
argument_list|(
argument|sls_tossed
argument_list|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|cs
operator|=
operator|&
name|comp
operator|->
name|rstate
index|[
name|comp
operator|->
name|last_recv
index|]
expr_stmt|;
name|hlen
operator|=
name|cs
operator|->
name|cs_ip
operator|.
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|&
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
operator|)
index|[
name|hlen
index|]
expr_stmt|;
name|th
operator|->
name|th_sum
operator|=
name|htons
argument_list|(
operator|(
operator|*
name|cp
operator|<<
literal|8
operator|)
operator||
name|cp
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|changes
operator|&
name|TCP_PUSH_BIT
condition|)
name|th
operator|->
name|th_flags
operator||=
name|TH_PUSH
expr_stmt|;
else|else
name|th
operator|->
name|th_flags
operator|&=
operator|~
name|TH_PUSH
expr_stmt|;
switch|switch
condition|(
name|changes
operator|&
name|SPECIALS_MASK
condition|)
block|{
case|case
name|SPECIAL_I
case|:
block|{
specifier|register
name|u_int
name|i
init|=
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
argument_list|)
operator|-
name|cs
operator|->
name|cs_hlen
decl_stmt|;
name|th
operator|->
name|th_ack
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|th
operator|->
name|th_ack
argument_list|)
operator|+
name|i
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_seq
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SPECIAL_D
case|:
name|th
operator|->
name|th_seq
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|th
operator|->
name|th_seq
argument_list|)
operator|+
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
argument_list|)
operator|-
name|cs
operator|->
name|cs_hlen
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|changes
operator|&
name|NEW_U
condition|)
block|{
name|th
operator|->
name|th_flags
operator||=
name|TH_URG
expr_stmt|;
name|DECODEU
argument_list|(
argument|th->th_urp
argument_list|)
block|}
else|else
name|th
operator|->
name|th_flags
operator|&=
operator|~
name|TH_URG
expr_stmt|;
if|if
condition|(
name|changes
operator|&
name|NEW_W
condition|)
name|DECODES
argument_list|(
argument|th->th_win
argument_list|)
if|if
condition|(
name|changes
operator|&
name|NEW_A
condition|)
name|DECODEL
argument_list|(
argument|th->th_ack
argument_list|)
if|if
condition|(
name|changes
operator|&
name|NEW_S
condition|)
name|DECODEL
argument_list|(
argument|th->th_seq
argument_list|)
break|break;
block|}
if|if
condition|(
name|changes
operator|&
name|NEW_I
condition|)
block|{
name|DECODES
argument_list|(
argument|cs->cs_ip.ip_id
argument_list|)
block|}
else|else
name|cs
operator|->
name|cs_ip
operator|.
name|ip_id
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|cs
operator|->
name|cs_ip
operator|.
name|ip_id
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * At this point, cp points to the first byte of data in the 	 * packet.  Fill in the IP total length and update the IP 	 * header checksum. 	 */
name|vjlen
operator|=
name|cp
operator|-
name|buf
expr_stmt|;
name|buflen
operator|-=
name|vjlen
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
literal|0
condition|)
comment|/* we must have dropped some characters (crc should detect 		 * this but the old slip framing won't) */
goto|goto
name|bad
goto|;
name|total_len
operator|+=
name|cs
operator|->
name|cs_hlen
operator|-
name|vjlen
expr_stmt|;
name|cs
operator|->
name|cs_ip
operator|.
name|ip_len
operator|=
name|htons
argument_list|(
name|total_len
argument_list|)
expr_stmt|;
comment|/* recompute the ip header checksum */
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
expr_stmt|;
name|cs
operator|->
name|cs_ip
operator|.
name|ip_sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|changes
operator|=
literal|0
init|;
name|hlen
operator|>
literal|0
condition|;
name|hlen
operator|-=
literal|2
control|)
name|changes
operator|+=
operator|*
name|bp
operator|++
expr_stmt|;
name|changes
operator|=
operator|(
name|changes
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|changes
operator|>>
literal|16
operator|)
expr_stmt|;
name|changes
operator|=
operator|(
name|changes
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|changes
operator|>>
literal|16
operator|)
expr_stmt|;
name|cs
operator|->
name|cs_ip
operator|.
name|ip_sum
operator|=
operator|~
name|changes
expr_stmt|;
operator|*
name|hdrp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|cs
operator|->
name|cs_ip
expr_stmt|;
operator|*
name|hlenp
operator|=
name|cs
operator|->
name|cs_hlen
expr_stmt|;
return|return
name|vjlen
return|;
name|bad
label|:
name|comp
operator|->
name|flags
operator||=
name|SLF_TOSS
expr_stmt|;
name|INCR
argument_list|(
argument|sls_errorin
argument_list|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

end_unit

