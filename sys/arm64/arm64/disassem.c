begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 Cavium  * All rights reserved.  *  * This software was developed by Semihalf.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/disassem.h>
end_include

begin_include
include|#
directive|include
file|<machine/armreg.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_define
define|#
directive|define
name|ARM64_MAX_TOKEN_LEN
value|8
end_define

begin_define
define|#
directive|define
name|ARM64_MAX_TOKEN_CNT
value|10
end_define

begin_define
define|#
directive|define
name|ARM_INSN_SIZE_OFFSET
value|30
end_define

begin_define
define|#
directive|define
name|ARM_INSN_SIZE_MASK
value|0x3
end_define

begin_comment
comment|/* Special options for instruction printing */
end_comment

begin_define
define|#
directive|define
name|OP_SIGN_EXT
value|(1UL<< 0)
end_define

begin_comment
comment|/* Sign-extend immediate value */
end_comment

begin_define
define|#
directive|define
name|OP_LITERAL
value|(1UL<< 1)
end_define

begin_comment
comment|/* Use literal (memory offset) */
end_comment

begin_define
define|#
directive|define
name|OP_MULT_4
value|(1UL<< 2)
end_define

begin_comment
comment|/* Multiply immediate by 4 */
end_comment

begin_define
define|#
directive|define
name|OP_SF32
value|(1UL<< 3)
end_define

begin_comment
comment|/* Force 32-bit access */
end_comment

begin_define
define|#
directive|define
name|OP_SF_INV
value|(1UL<< 6)
end_define

begin_comment
comment|/* SF is inverted (1 means 32 bit access) */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|w_reg
index|[]
init|=
block|{
literal|"w0"
block|,
literal|"w1"
block|,
literal|"w2"
block|,
literal|"w3"
block|,
literal|"w4"
block|,
literal|"w5"
block|,
literal|"w6"
block|,
literal|"w7"
block|,
literal|"w8"
block|,
literal|"w9"
block|,
literal|"w10"
block|,
literal|"w11"
block|,
literal|"w12"
block|,
literal|"w13"
block|,
literal|"w14"
block|,
literal|"w15"
block|,
literal|"w16"
block|,
literal|"w17"
block|,
literal|"w18"
block|,
literal|"w19"
block|,
literal|"w20"
block|,
literal|"w21"
block|,
literal|"w22"
block|,
literal|"w23"
block|,
literal|"w24"
block|,
literal|"w25"
block|,
literal|"w26"
block|,
literal|"w27"
block|,
literal|"w28"
block|,
literal|"w29"
block|,
literal|"w30"
block|,
literal|"wSP"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|x_reg
index|[]
init|=
block|{
literal|"x0"
block|,
literal|"x1"
block|,
literal|"x2"
block|,
literal|"x3"
block|,
literal|"x4"
block|,
literal|"x5"
block|,
literal|"x6"
block|,
literal|"x7"
block|,
literal|"x8"
block|,
literal|"x9"
block|,
literal|"x10"
block|,
literal|"x11"
block|,
literal|"x12"
block|,
literal|"x13"
block|,
literal|"x14"
block|,
literal|"x15"
block|,
literal|"x16"
block|,
literal|"x17"
block|,
literal|"x18"
block|,
literal|"x19"
block|,
literal|"x20"
block|,
literal|"x21"
block|,
literal|"x22"
block|,
literal|"x23"
block|,
literal|"x24"
block|,
literal|"x25"
block|,
literal|"x26"
block|,
literal|"x27"
block|,
literal|"x28"
block|,
literal|"x29"
block|,
literal|"LR"
block|,
literal|"SP"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|shift_2
index|[]
init|=
block|{
literal|"LSL"
block|,
literal|"LSR"
block|,
literal|"ASR"
block|,
literal|"RSV"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Structure representing single token (operand) inside instruction.  * name   - name of operand  * pos    - position within the instruction (in bits)  * len    - operand length (in bits)  */
end_comment

begin_struct
struct|struct
name|arm64_insn_token
block|{
name|char
name|name
index|[
name|ARM64_MAX_TOKEN_LEN
index|]
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|int
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Define generic types for instruction printing.  */
end_comment

begin_enum
enum|enum
name|arm64_format_type
block|{
name|TYPE_01
block|,
comment|/* OP<RD>,<RN>,<RM>{,<shift [LSL, LSR, ASR]> #<imm>} SF32/64 			   OP<RD>,<RN>, #<imm>{,<shift [0, 12]>} SF32/64 */
name|TYPE_02
block|,
comment|/* OP<RT>, [<RN>, #<imm>]{!}] SF32/64 			   OP<RT>, [<RN>], #<imm>{!} SF32/64 			   OP<RT>,<RN>,<RM> {, EXTEND AMOUNT } */
name|TYPE_03
block|,
comment|/* OP<RT>, #imm SF32/64 */
block|}
enum|;
end_enum

begin_comment
comment|/*  * Structure representing single parsed instruction format.  * name   - opcode name  * format - opcode format in a human-readable way  * type   - syntax type for printing  * special_ops  - special options passed to a printer (if any)  * mask   - bitmask for instruction matching  * pattern      - pattern to look for  * tokens - array of tokens (operands) inside instruction  */
end_comment

begin_struct
struct|struct
name|arm64_insn
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|enum
name|arm64_format_type
name|type
decl_stmt|;
name|uint64_t
name|special_ops
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
name|uint32_t
name|pattern
decl_stmt|;
name|struct
name|arm64_insn_token
name|tokens
index|[
name|ARM64_MAX_TOKEN_CNT
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Specify instruction opcode format in a human-readable way. Use notation  * obtained from ARM Architecture Reference Manual for ARMv8-A.  *  * Format string description:  *  Each group must be separated by "|". Group made of 0/1 is used to  *  generate mask and pattern for instruction matching. Groups containing  *  an operand token (in format NAME(length_bits)) are used to retrieve any  *  operand data from the instruction. Names here must be meaningful  *  and match the one described in the Manual.  *  * Token description:  * SF     - "0" represents 32-bit access, "1" represents 64-bit access  * SHIFT  - type of shift (instruction dependent)  * IMM    - immediate value  * Rx     - register number  * OPTION - command specific options  * SCALE  - scaling of immediate value  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|arm64_insn
name|arm64_i
index|[]
init|=
block|{
block|{
literal|"add"
block|,
literal|"SF(1)|0001011|SHIFT(2)|0|RM(5)|IMM(6)|RN(5)|RD(5)"
block|,
name|TYPE_01
block|,
literal|0
block|}
block|,
block|{
literal|"mov"
block|,
literal|"SF(1)|001000100000000000000|RN(5)|RD(5)"
block|,
name|TYPE_01
block|,
literal|0
block|}
block|,
block|{
literal|"add"
block|,
literal|"SF(1)|0010001|SHIFT(2)|IMM(12)|RN(5)|RD(5)"
block|,
name|TYPE_01
block|,
literal|0
block|}
block|,
block|{
literal|"ldr"
block|,
literal|"1|SF(1)|111000010|IMM(9)|OPTION(2)|RN(5)|RT(5)"
block|,
name|TYPE_02
block|,
name|OP_SIGN_EXT
block|}
block|,
comment|/* ldr immediate post/pre index */
block|{
literal|"ldr"
block|,
literal|"1|SF(1)|11100101|IMM(12)|RN(5)|RT(5)"
block|,
name|TYPE_02
block|,
literal|0
block|}
block|,
comment|/* ldr immediate unsigned */
block|{
literal|"ldr"
block|,
literal|"1|SF(1)|111000011|RM(5)|OPTION(3)|SCALE(1)|10|RN(5)|RT(5)"
block|,
name|TYPE_02
block|,
literal|0
block|}
block|,
comment|/* ldr register */
block|{
literal|"ldr"
block|,
literal|"0|SF(1)|011000|IMM(19)|RT(5)"
block|,
name|TYPE_03
block|,
name|OP_SIGN_EXT
operator||
name|OP_LITERAL
operator||
name|OP_MULT_4
block|}
block|,
comment|/* ldr literal */
block|{
literal|"ldrb"
block|,
literal|"00|111000010|IMM(9)|OPTION(2)|RN(5)|RT(5)"
block|,
name|TYPE_02
block|,
name|OP_SIGN_EXT
operator||
name|OP_SF32
block|}
block|,
comment|/* ldrb immediate post/pre index */
block|{
literal|"ldrb"
block|,
literal|"00|11100101|IMM(12)|RN(5)|RT(5)"
block|,
name|TYPE_02
block|,
name|OP_SF32
block|}
block|,
comment|/* ldrb immediate unsigned */
block|{
literal|"ldrb"
block|,
literal|"00|111000011|RM(5)|OPTION(3)|SCALE(1)|10|RN(5)|RT(5)"
block|,
name|TYPE_02
block|,
name|OP_SF32
block|}
block|,
comment|/* ldrb register */
block|{
literal|"ldrh"
block|,
literal|"01|111000010|IMM(9)|OPTION(2)|RN(5)|RT(5)"
block|,
name|TYPE_02
block|,
name|OP_SIGN_EXT
operator||
name|OP_SF32
block|}
block|,
comment|/* ldrh immediate post/pre index */
block|{
literal|"ldrh"
block|,
literal|"01|11100101|IMM(12)|RN(5)|RT(5)"
block|,
name|TYPE_02
block|,
name|OP_SF32
block|}
block|,
comment|/* ldrh immediate unsigned */
block|{
literal|"ldrh"
block|,
literal|"01|111000011|RM(5)|OPTION(3)|SCALE(1)|10|RN(5)|RT(5)"
block|,
name|TYPE_02
block|,
name|OP_SF32
block|}
block|,
comment|/* ldrh register */
block|{
literal|"ldrsb"
block|,
literal|"001110001|SF(1)|0|IMM(9)|OPTION(2)|RN(5)|RT(5)"
block|,
name|TYPE_02
block|,
name|OP_SIGN_EXT
operator||
name|OP_SF_INV
block|}
block|,
comment|/* ldrsb immediate post/pre index */
block|{
literal|"ldrsb"
block|,
literal|"001110011|SF(1)|IMM(12)|RN(5)|RT(5)"
block|,\
name|TYPE_02
block|,
name|OP_SF_INV
block|}
block|,
comment|/* ldrsb immediate unsigned */
block|{
literal|"ldrsb"
block|,
literal|"001110001|SF(1)|1|RM(5)|OPTION(3)|SCALE(1)|10|RN(5)|RT(5)"
block|,
name|TYPE_02
block|,
name|OP_SF_INV
block|}
block|,
comment|/* ldrsb register */
block|{
literal|"ldrsh"
block|,
literal|"011110001|SF(1)|0|IMM(9)|OPTION(2)|RN(5)|RT(5)"
block|,
name|TYPE_02
block|,
name|OP_SIGN_EXT
operator||
name|OP_SF_INV
block|}
block|,
comment|/* ldrsh immediate post/pre index */
block|{
literal|"ldrsh"
block|,
literal|"011110011|SF(1)|IMM(12)|RN(5)|RT(5)"
block|,
name|TYPE_02
block|,
name|OP_SF_INV
block|}
block|,
comment|/* ldrsh immediate unsigned */
block|{
literal|"ldrsh"
block|,
literal|"011110001|SF(1)|1|RM(5)|OPTION(3)|SCALE(1)|10|RN(5)|RT(5)"
block|,
name|TYPE_02
block|,
name|OP_SF_INV
block|}
block|,
comment|/* ldrsh register */
block|{
literal|"ldrsw"
block|,
literal|"10111000100|IMM(9)|OPTION(2)|RN(5)|RT(5)"
block|,
name|TYPE_02
block|,
name|OP_SIGN_EXT
block|}
block|,
comment|/* ldrsw immediate post/pre index */
block|{
literal|"ldrsw"
block|,
literal|"1011100110|IMM(12)|RN(5)|RT(5)"
block|,
name|TYPE_02
block|,
literal|0
block|}
block|,
comment|/* ldrsw immediate unsigned */
block|{
literal|"ldrsw"
block|,
literal|"10111000101|RM(5)|OPTION(3)|SCALE(1)|10|RN(5)|RT(5)"
block|,
name|TYPE_02
block|,
literal|0
block|}
block|,
comment|/* ldrsw register */
block|{
literal|"ldrsw"
block|,
literal|"10011000|IMM(19)|RT(5)"
block|,
name|TYPE_03
block|,
name|OP_SIGN_EXT
operator||
name|OP_LITERAL
operator||
name|OP_MULT_4
block|}
block|,
comment|/* ldr literal */
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|arm64_disasm_generate_masks
parameter_list|(
name|struct
name|arm64_insn
modifier|*
name|tab
parameter_list|)
block|{
name|uint32_t
name|mask
decl_stmt|,
name|val
decl_stmt|;
name|int
name|a
decl_stmt|,
name|i
decl_stmt|;
name|int
name|len
decl_stmt|,
name|ret
decl_stmt|;
name|int
name|token
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|int
name|error
decl_stmt|;
while|while
condition|(
name|tab
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
name|mask
operator|=
literal|0
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|format
operator|=
name|tab
operator|->
name|format
expr_stmt|;
name|token
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 		 * For each entry analyze format strings from the 		 * left (i.e. from the MSB). 		 */
name|a
operator|=
operator|(
name|INSN_SIZE
operator|*
name|NBBY
operator|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|format
operator|!=
literal|'\0'
operator|&&
operator|(
name|a
operator|>=
literal|0
operator|)
condition|)
block|{
switch|switch
condition|(
operator|*
name|format
condition|)
block|{
case|case
literal|'0'
case|:
comment|/* Bit is 0, add to mask and pattern */
name|mask
operator||=
operator|(
literal|1
operator|<<
name|a
operator|)
expr_stmt|;
name|a
operator|--
expr_stmt|;
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
comment|/* Bit is 1, add to mask and pattern */
name|mask
operator||=
operator|(
literal|1
operator|<<
name|a
operator|)
expr_stmt|;
name|val
operator||=
operator|(
literal|1
operator|<<
name|a
operator|)
expr_stmt|;
name|a
operator|--
expr_stmt|;
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
comment|/* skip */
name|format
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* Token found, copy the name */
name|memset
argument_list|(
name|tab
operator|->
name|tokens
index|[
name|token
index|]
operator|.
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tab
operator|->
name|tokens
index|[
name|token
index|]
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|format
operator|!=
literal|'('
condition|)
block|{
name|tab
operator|->
name|tokens
index|[
name|token
index|]
operator|.
name|name
index|[
name|i
index|]
operator|=
operator|*
name|format
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|format
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|ARM64_MAX_TOKEN_LEN
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR: token too long in op %s\n"
argument_list|,
name|tab
operator|->
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
comment|/* Read the length value */
name|ret
operator|=
name|sscanf
argument_list|(
name|format
argument_list|,
literal|"(%d)"
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|token
operator|>=
name|ARM64_MAX_TOKEN_CNT
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR: to many tokens in op %s\n"
argument_list|,
name|tab
operator|->
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|a
operator|-=
name|len
expr_stmt|;
name|tab
operator|->
name|tokens
index|[
name|token
index|]
operator|.
name|pos
operator|=
name|a
operator|+
literal|1
expr_stmt|;
name|tab
operator|->
name|tokens
index|[
name|token
index|]
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|token
operator|++
expr_stmt|;
block|}
comment|/* Skip to the end of the token */
while|while
condition|(
operator|*
name|format
operator|!=
literal|0
operator|&&
operator|*
name|format
operator|!=
literal|'|'
condition|)
name|format
operator|++
expr_stmt|;
block|}
block|}
comment|/* Write mask and pattern to the instruction array */
name|tab
operator|->
name|mask
operator|=
name|mask
expr_stmt|;
name|tab
operator|->
name|pattern
operator|=
name|val
expr_stmt|;
comment|/* 		 * If we got here, format string must be parsed and "a" 		 * should point to -1. If it's not, wrong number of bits 		 * in format string. Mark this as invalid and prevent 		 * from being matched. 		 */
if|if
condition|(
operator|*
name|format
operator|!=
literal|0
operator|||
operator|(
name|a
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|(
name|error
operator|!=
literal|0
operator|)
condition|)
block|{
name|tab
operator|->
name|mask
operator|=
literal|0
expr_stmt|;
name|tab
operator|->
name|pattern
operator|=
literal|0xffffffff
expr_stmt|;
name|printf
argument_list|(
literal|"ERROR: skipping instruction op %s\n"
argument_list|,
name|tab
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|tab
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|arm64_disasm_read_token
parameter_list|(
name|struct
name|arm64_insn
modifier|*
name|insn
parameter_list|,
name|u_int
name|opcode
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|,
name|int
modifier|*
name|val
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARM64_MAX_TOKEN_CNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|insn
operator|->
name|tokens
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|token
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|val
operator|=
operator|(
name|opcode
operator|>>
name|insn
operator|->
name|tokens
index|[
name|i
index|]
operator|.
name|pos
operator|&
operator|(
operator|(
literal|1
operator|<<
name|insn
operator|->
name|tokens
index|[
name|i
index|]
operator|.
name|len
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|arm64_disasm_read_token_sign_ext
parameter_list|(
name|struct
name|arm64_insn
modifier|*
name|insn
parameter_list|,
name|u_int
name|opcode
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|,
name|int
modifier|*
name|val
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|msk
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARM64_MAX_TOKEN_CNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|insn
operator|->
name|tokens
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|token
argument_list|)
operator|==
literal|0
condition|)
block|{
name|msk
operator|=
operator|(
literal|1
operator|<<
name|insn
operator|->
name|tokens
index|[
name|i
index|]
operator|.
name|len
operator|)
operator|-
literal|1
expr_stmt|;
operator|*
name|val
operator|=
operator|(
operator|(
name|opcode
operator|>>
name|insn
operator|->
name|tokens
index|[
name|i
index|]
operator|.
name|pos
operator|)
operator|&
name|msk
operator|)
expr_stmt|;
comment|/* If last bit is 1, sign-extend the value */
if|if
condition|(
operator|*
name|val
operator|&
operator|(
literal|1
operator|<<
operator|(
name|insn
operator|->
name|tokens
index|[
name|i
index|]
operator|.
name|len
operator|-
literal|1
operator|)
operator|)
condition|)
operator|*
name|val
operator||=
operator|~
name|msk
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|arm64_reg
parameter_list|(
name|int
name|b64
parameter_list|,
name|int
name|num
parameter_list|)
block|{
if|if
condition|(
name|b64
operator|!=
literal|0
condition|)
return|return
operator|(
name|x_reg
index|[
name|num
index|]
operator|)
return|;
return|return
operator|(
name|w_reg
index|[
name|num
index|]
operator|)
return|;
block|}
end_function

begin_function
name|vm_offset_t
name|disasm
parameter_list|(
specifier|const
name|struct
name|disasm_interface
modifier|*
name|di
parameter_list|,
name|vm_offset_t
name|loc
parameter_list|,
name|int
name|altfmt
parameter_list|)
block|{
name|struct
name|arm64_insn
modifier|*
name|i_ptr
init|=
name|arm64_i
decl_stmt|;
name|uint32_t
name|insn
decl_stmt|;
name|int
name|matchp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|shift
decl_stmt|,
name|rm
decl_stmt|,
name|rt
decl_stmt|,
name|rd
decl_stmt|,
name|rn
decl_stmt|,
name|imm
decl_stmt|,
name|sf
decl_stmt|,
name|idx
decl_stmt|,
name|option
decl_stmt|,
name|scale
decl_stmt|,
name|amount
decl_stmt|;
name|int
name|sign_ext
decl_stmt|;
name|int
name|rm_absent
decl_stmt|;
comment|/* Indicate if immediate should be outside or inside brackets */
name|int
name|inside
decl_stmt|;
comment|/* Print exclamation mark if pre-incremented */
name|int
name|pre
decl_stmt|;
comment|/* Initialize defaults, all are 0 except SF indicating 64bit access */
name|shift
operator|=
name|rd
operator|=
name|rm
operator|=
name|rn
operator|=
name|imm
operator|=
name|idx
operator|=
name|option
operator|=
name|amount
operator|=
name|scale
operator|=
literal|0
expr_stmt|;
name|sign_ext
operator|=
literal|0
expr_stmt|;
name|sf
operator|=
literal|1
expr_stmt|;
name|matchp
operator|=
literal|0
expr_stmt|;
name|insn
operator|=
name|di
operator|->
name|di_readword
argument_list|(
name|loc
argument_list|)
expr_stmt|;
while|while
condition|(
name|i_ptr
operator|->
name|name
condition|)
block|{
comment|/* If mask is 0 then the parser was not initialized yet */
if|if
condition|(
operator|(
name|i_ptr
operator|->
name|mask
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|insn
operator|&
name|i_ptr
operator|->
name|mask
operator|)
operator|==
name|i_ptr
operator|->
name|pattern
operator|)
condition|)
block|{
name|matchp
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|i_ptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|matchp
operator|==
literal|0
condition|)
goto|goto
name|undefined
goto|;
comment|/* Global options */
if|if
condition|(
name|i_ptr
operator|->
name|special_ops
operator|&
name|OP_SF32
condition|)
name|sf
operator|=
literal|0
expr_stmt|;
comment|/* Global optional tokens */
name|arm64_disasm_read_token
argument_list|(
name|i_ptr
argument_list|,
name|insn
argument_list|,
literal|"SF"
argument_list|,
operator|&
name|sf
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_ptr
operator|->
name|special_ops
operator|&
name|OP_SF_INV
condition|)
name|sf
operator|=
literal|1
operator|-
name|sf
expr_stmt|;
if|if
condition|(
name|arm64_disasm_read_token
argument_list|(
name|i_ptr
argument_list|,
name|insn
argument_list|,
literal|"SIGN"
argument_list|,
operator|&
name|sign_ext
argument_list|)
operator|==
literal|0
condition|)
name|sign_ext
operator|=
literal|1
operator|-
name|sign_ext
expr_stmt|;
if|if
condition|(
name|i_ptr
operator|->
name|special_ops
operator|&
name|OP_SIGN_EXT
condition|)
name|sign_ext
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sign_ext
operator|!=
literal|0
condition|)
name|arm64_disasm_read_token_sign_ext
argument_list|(
name|i_ptr
argument_list|,
name|insn
argument_list|,
literal|"IMM"
argument_list|,
operator|&
name|imm
argument_list|)
expr_stmt|;
else|else
name|arm64_disasm_read_token
argument_list|(
name|i_ptr
argument_list|,
name|insn
argument_list|,
literal|"IMM"
argument_list|,
operator|&
name|imm
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_ptr
operator|->
name|special_ops
operator|&
name|OP_MULT_4
condition|)
name|imm
operator|<<=
literal|2
expr_stmt|;
comment|/* Print opcode by type */
switch|switch
condition|(
name|i_ptr
operator|->
name|type
condition|)
block|{
case|case
name|TYPE_01
case|:
comment|/* OP<RD>,<RN>,<RM>{,<shift [LSL, LSR, ASR]> #<imm>} SF32/64 		   OP<RD>,<RN>, #<imm>{,<shift [0, 12]>} SF32/64 */
comment|/* Mandatory tokens */
name|ret
operator|=
name|arm64_disasm_read_token
argument_list|(
name|i_ptr
argument_list|,
name|insn
argument_list|,
literal|"RD"
argument_list|,
operator|&
name|rd
argument_list|)
expr_stmt|;
name|ret
operator||=
name|arm64_disasm_read_token
argument_list|(
name|i_ptr
argument_list|,
name|insn
argument_list|,
literal|"RN"
argument_list|,
operator|&
name|rn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR: Missing mandatory token for op %s type %d\n"
argument_list|,
name|i_ptr
operator|->
name|name
argument_list|,
name|i_ptr
operator|->
name|type
argument_list|)
expr_stmt|;
goto|goto
name|undefined
goto|;
block|}
comment|/* Optional tokens */
name|arm64_disasm_read_token
argument_list|(
name|i_ptr
argument_list|,
name|insn
argument_list|,
literal|"SHIFT"
argument_list|,
operator|&
name|shift
argument_list|)
expr_stmt|;
name|rm_absent
operator|=
name|arm64_disasm_read_token
argument_list|(
name|i_ptr
argument_list|,
name|insn
argument_list|,
literal|"RM"
argument_list|,
operator|&
name|rm
argument_list|)
expr_stmt|;
name|di
operator|->
name|di_printf
argument_list|(
literal|"%s\t%s, %s"
argument_list|,
name|i_ptr
operator|->
name|name
argument_list|,
name|arm64_reg
argument_list|(
name|sf
argument_list|,
name|rd
argument_list|)
argument_list|,
name|arm64_reg
argument_list|(
name|sf
argument_list|,
name|rn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If RM is present use it, otherwise use immediate notation */
if|if
condition|(
name|rm_absent
operator|==
literal|0
condition|)
block|{
name|di
operator|->
name|di_printf
argument_list|(
literal|", %s"
argument_list|,
name|arm64_reg
argument_list|(
name|sf
argument_list|,
name|rm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
operator|!=
literal|0
condition|)
name|di
operator|->
name|di_printf
argument_list|(
literal|", %s #%d"
argument_list|,
name|shift_2
index|[
name|shift
index|]
argument_list|,
name|imm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|imm
operator|!=
literal|0
operator|||
name|shift
operator|!=
literal|0
condition|)
name|di
operator|->
name|di_printf
argument_list|(
literal|", #0x%x"
argument_list|,
name|imm
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift
operator|!=
literal|0
condition|)
name|di
operator|->
name|di_printf
argument_list|(
literal|" LSL #12"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_02
case|:
comment|/* OP<RT>, [<RN>, #<imm>]{!}] SF32/64 		   OP<RT>, [<RN>], #<imm>{!} SF32/64 		   OP<RT>,<RN>,<RM> {, EXTEND AMOUNT } */
comment|/* Mandatory tokens */
name|ret
operator|=
name|arm64_disasm_read_token
argument_list|(
name|i_ptr
argument_list|,
name|insn
argument_list|,
literal|"RT"
argument_list|,
operator|&
name|rt
argument_list|)
expr_stmt|;
name|ret
operator||=
name|arm64_disasm_read_token
argument_list|(
name|i_ptr
argument_list|,
name|insn
argument_list|,
literal|"RN"
argument_list|,
operator|&
name|rn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR: Missing mandatory token for op %s type %d\n"
argument_list|,
name|i_ptr
operator|->
name|name
argument_list|,
name|i_ptr
operator|->
name|type
argument_list|)
expr_stmt|;
goto|goto
name|undefined
goto|;
block|}
comment|/* Optional tokens */
name|arm64_disasm_read_token
argument_list|(
name|i_ptr
argument_list|,
name|insn
argument_list|,
literal|"OPTION"
argument_list|,
operator|&
name|option
argument_list|)
expr_stmt|;
name|arm64_disasm_read_token
argument_list|(
name|i_ptr
argument_list|,
name|insn
argument_list|,
literal|"SCALE"
argument_list|,
operator|&
name|scale
argument_list|)
expr_stmt|;
name|rm_absent
operator|=
name|arm64_disasm_read_token
argument_list|(
name|i_ptr
argument_list|,
name|insn
argument_list|,
literal|"RM"
argument_list|,
operator|&
name|rm
argument_list|)
expr_stmt|;
if|if
condition|(
name|rm_absent
condition|)
block|{
comment|/* 			 * In unsigned operation, shift immediate value 			 * and reset options to default. 			 */
if|if
condition|(
name|sign_ext
operator|==
literal|0
condition|)
block|{
name|imm
operator|=
name|imm
operator|<<
operator|(
operator|(
name|insn
operator|>>
name|ARM_INSN_SIZE_OFFSET
operator|)
operator|&
name|ARM_INSN_SIZE_MASK
operator|)
expr_stmt|;
name|option
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|option
condition|)
block|{
case|case
literal|0x0
case|:
name|pre
operator|=
literal|0
expr_stmt|;
name|inside
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0x1
case|:
name|pre
operator|=
literal|0
expr_stmt|;
name|inside
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|0x2
case|:
default|default:
name|pre
operator|=
literal|1
expr_stmt|;
name|inside
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|di
operator|->
name|di_printf
argument_list|(
literal|"%s\t%s, "
argument_list|,
name|i_ptr
operator|->
name|name
argument_list|,
name|arm64_reg
argument_list|(
name|sf
argument_list|,
name|rt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inside
operator|!=
literal|0
condition|)
block|{
name|di
operator|->
name|di_printf
argument_list|(
literal|"[%s"
argument_list|,
name|arm64_reg
argument_list|(
literal|1
argument_list|,
name|rn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
operator|!=
literal|0
condition|)
name|di
operator|->
name|di_printf
argument_list|(
literal|", #%d"
argument_list|,
name|imm
argument_list|)
expr_stmt|;
name|di
operator|->
name|di_printf
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|di
operator|->
name|di_printf
argument_list|(
literal|"[%s]"
argument_list|,
name|arm64_reg
argument_list|(
literal|1
argument_list|,
name|rn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
operator|!=
literal|0
condition|)
name|di
operator|->
name|di_printf
argument_list|(
literal|", #%d"
argument_list|,
name|imm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pre
operator|!=
literal|0
condition|)
name|di
operator|->
name|di_printf
argument_list|(
literal|"!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Last bit of option field determines 32/64 bit offset */
name|di
operator|->
name|di_printf
argument_list|(
literal|"%s\t%s, [%s, %s"
argument_list|,
name|i_ptr
operator|->
name|name
argument_list|,
name|arm64_reg
argument_list|(
name|sf
argument_list|,
name|rt
argument_list|)
argument_list|,
name|arm64_reg
argument_list|(
literal|1
argument_list|,
name|rn
argument_list|)
argument_list|,
name|arm64_reg
argument_list|(
name|option
operator|&
literal|1
argument_list|,
name|rm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Calculate amount, it's op(31:30) */
name|amount
operator|=
operator|(
name|insn
operator|>>
name|ARM_INSN_SIZE_OFFSET
operator|)
operator|&
name|ARM_INSN_SIZE_MASK
expr_stmt|;
switch|switch
condition|(
name|option
condition|)
block|{
case|case
literal|0x2
case|:
name|di
operator|->
name|di_printf
argument_list|(
literal|", uxtw #%d"
argument_list|,
name|amount
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x3
case|:
if|if
condition|(
name|scale
operator|!=
literal|0
condition|)
name|di
operator|->
name|di_printf
argument_list|(
literal|", lsl #%d"
argument_list|,
name|amount
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x6
case|:
name|di
operator|->
name|di_printf
argument_list|(
literal|", sxtw #%d"
argument_list|,
name|amount
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x7
case|:
name|di
operator|->
name|di_printf
argument_list|(
literal|", sxts #%d"
argument_list|,
name|amount
argument_list|)
expr_stmt|;
break|break;
default|default:
name|di
operator|->
name|di_printf
argument_list|(
literal|", RSVD"
argument_list|)
expr_stmt|;
break|break;
block|}
name|di
operator|->
name|di_printf
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_03
case|:
comment|/* OP<RT>, #imm SF32/64 */
comment|/* Mandatory tokens */
name|ret
operator|=
name|arm64_disasm_read_token
argument_list|(
name|i_ptr
argument_list|,
name|insn
argument_list|,
literal|"RT"
argument_list|,
operator|&
name|rt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR: Missing mandatory token for op %s type %d\n"
argument_list|,
name|i_ptr
operator|->
name|name
argument_list|,
name|i_ptr
operator|->
name|type
argument_list|)
expr_stmt|;
goto|goto
name|undefined
goto|;
block|}
name|di
operator|->
name|di_printf
argument_list|(
literal|"%s\t%s, "
argument_list|,
name|i_ptr
operator|->
name|name
argument_list|,
name|arm64_reg
argument_list|(
name|sf
argument_list|,
name|rt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_ptr
operator|->
name|special_ops
operator|&
name|OP_LITERAL
condition|)
name|di
operator|->
name|di_printf
argument_list|(
literal|"0x%lx"
argument_list|,
name|loc
operator|+
name|imm
argument_list|)
expr_stmt|;
else|else
name|di
operator|->
name|di_printf
argument_list|(
literal|"#%d"
argument_list|,
name|imm
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|undefined
goto|;
block|}
name|di
operator|->
name|di_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|loc
operator|+
name|INSN_SIZE
operator|)
return|;
name|undefined
label|:
name|di
operator|->
name|di_printf
argument_list|(
literal|"undefined\t%08x\n"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
operator|(
name|loc
operator|+
name|INSN_SIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Parse format strings at the very beginning */
end_comment

begin_expr_stmt
name|SYSINIT
argument_list|(
name|arm64_disasm_generate_masks
argument_list|,
name|SI_SUB_DDB_SERVICES
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|arm64_disasm_generate_masks
argument_list|,
name|arm64_i
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

