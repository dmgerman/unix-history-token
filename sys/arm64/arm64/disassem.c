begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2016 Cavium  * All rights reserved.  *  * This software was developed by Semihalf.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/disassem.h>
end_include

begin_include
include|#
directive|include
file|<machine/armreg.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_define
define|#
directive|define
name|ARM64_MAX_TOKEN_LEN
value|8
end_define

begin_define
define|#
directive|define
name|ARM64_MAX_TOKEN_CNT
value|10
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|w_reg
index|[]
init|=
block|{
literal|"w0"
block|,
literal|"w1"
block|,
literal|"w2"
block|,
literal|"w3"
block|,
literal|"w4"
block|,
literal|"w5"
block|,
literal|"w6"
block|,
literal|"w7"
block|,
literal|"w8"
block|,
literal|"w9"
block|,
literal|"w10"
block|,
literal|"w11"
block|,
literal|"w12"
block|,
literal|"w13"
block|,
literal|"w14"
block|,
literal|"w15"
block|,
literal|"w16"
block|,
literal|"w17"
block|,
literal|"w18"
block|,
literal|"w19"
block|,
literal|"w20"
block|,
literal|"w21"
block|,
literal|"w22"
block|,
literal|"w23"
block|,
literal|"w24"
block|,
literal|"w25"
block|,
literal|"w26"
block|,
literal|"w27"
block|,
literal|"w28"
block|,
literal|"w29"
block|,
literal|"w30"
block|,
literal|"wSP"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|x_reg
index|[]
init|=
block|{
literal|"x0"
block|,
literal|"x1"
block|,
literal|"x2"
block|,
literal|"x3"
block|,
literal|"x4"
block|,
literal|"x5"
block|,
literal|"x6"
block|,
literal|"x7"
block|,
literal|"x8"
block|,
literal|"x9"
block|,
literal|"x10"
block|,
literal|"x11"
block|,
literal|"x12"
block|,
literal|"x13"
block|,
literal|"x14"
block|,
literal|"x15"
block|,
literal|"x16"
block|,
literal|"x17"
block|,
literal|"x18"
block|,
literal|"x19"
block|,
literal|"x20"
block|,
literal|"x21"
block|,
literal|"x22"
block|,
literal|"x23"
block|,
literal|"x24"
block|,
literal|"x25"
block|,
literal|"x26"
block|,
literal|"x27"
block|,
literal|"x28"
block|,
literal|"x29"
block|,
literal|"LR"
block|,
literal|"SP"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|shift_2
index|[]
init|=
block|{
literal|"LSL"
block|,
literal|"LSR"
block|,
literal|"ASR"
block|,
literal|"RSV"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Structure representing single token (operand) inside instruction.  * name   - name of operand  * pos    - position within the instruction (in bits)  * len    - operand length (in bits)  */
end_comment

begin_struct
struct|struct
name|arm64_insn_token
block|{
name|char
name|name
index|[
name|ARM64_MAX_TOKEN_LEN
index|]
decl_stmt|;
name|int
name|pos
decl_stmt|;
name|int
name|len
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Define generic types for instruction printing.  */
end_comment

begin_enum
enum|enum
name|arm64_format_type
block|{
name|TYPE_01
block|,
comment|/* OP<RD>,<RN>,<RM>{,<shift [LSL, LSR, ASR]> #<imm>} SF32/64 			   OP<RD>,<RN>, #<imm>{,<shift [0, 12]>} SF32/64 */
block|}
enum|;
end_enum

begin_comment
comment|/*  * Structure representing single parsed instruction format.  * name   - opcode name  * format - opcode format in a human-readable way  * type   - syntax type for printing  * special_ops  - special options passed to a printer (if any)  * mask   - bitmask for instruction matching  * pattern      - pattern to look for  * tokens - array of tokens (operands) inside instruction  */
end_comment

begin_struct
struct|struct
name|arm64_insn
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|enum
name|arm64_format_type
name|type
decl_stmt|;
name|uint64_t
name|special_ops
decl_stmt|;
name|uint32_t
name|mask
decl_stmt|;
name|uint32_t
name|pattern
decl_stmt|;
name|struct
name|arm64_insn_token
name|tokens
index|[
name|ARM64_MAX_TOKEN_CNT
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Specify instruction opcode format in a human-readable way. Use notation  * obtained from ARM Architecture Reference Manual for ARMv8-A.  *  * Format string description:  *  Each group must be separated by "|". Group made of 0/1 is used to  *  generate mask and pattern for instruction matching. Groups containing  *  an operand token (in format NAME(length_bits)) are used to retrieve any  *  operand data from the instruction. Names here must be meaningful  *  and match the one described in the Manual.  *  * Token description:  * SF     - "0" represents 32-bit access, "1" represents 64-bit access  * SHIFT  - type of shift (instruction dependent)  * IMM    - immediate value  * Rx     - register number  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|arm64_insn
name|arm64_i
index|[]
init|=
block|{
block|{
literal|"add"
block|,
literal|"SF(1)|0001011|SHIFT(2)|0|RM(5)|IMM(6)|RN(5)|RD(5)"
block|,
name|TYPE_01
block|,
literal|0
block|}
block|,
block|{
literal|"mov"
block|,
literal|"SF(1)|001000100000000000000|RN(5)|RD(5)"
block|,
name|TYPE_01
block|,
literal|0
block|}
block|,
block|{
literal|"add"
block|,
literal|"SF(1)|0010001|SHIFT(2)|IMM(12)|RN(5)|RD(5)"
block|,
name|TYPE_01
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|arm64_disasm_generate_masks
parameter_list|(
name|struct
name|arm64_insn
modifier|*
name|tab
parameter_list|)
block|{
name|uint32_t
name|mask
decl_stmt|,
name|val
decl_stmt|;
name|int
name|a
decl_stmt|,
name|i
decl_stmt|;
name|int
name|len
decl_stmt|,
name|ret
decl_stmt|;
name|int
name|token
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|format
decl_stmt|;
name|int
name|error
decl_stmt|;
while|while
condition|(
name|tab
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
name|mask
operator|=
literal|0
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|format
operator|=
name|tab
operator|->
name|format
expr_stmt|;
name|token
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 		 * For each entry analyze format strings from the 		 * left (i.e. from the MSB). 		 */
name|a
operator|=
operator|(
name|INSN_SIZE
operator|*
name|NBBY
operator|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|format
operator|!=
literal|'\0'
operator|&&
operator|(
name|a
operator|>=
literal|0
operator|)
condition|)
block|{
switch|switch
condition|(
operator|*
name|format
condition|)
block|{
case|case
literal|'0'
case|:
comment|/* Bit is 0, add to mask and pattern */
name|mask
operator||=
operator|(
literal|1
operator|<<
name|a
operator|)
expr_stmt|;
name|a
operator|--
expr_stmt|;
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
comment|/* Bit is 1, add to mask and pattern */
name|mask
operator||=
operator|(
literal|1
operator|<<
name|a
operator|)
expr_stmt|;
name|val
operator||=
operator|(
literal|1
operator|<<
name|a
operator|)
expr_stmt|;
name|a
operator|--
expr_stmt|;
name|format
operator|++
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
comment|/* skip */
name|format
operator|++
expr_stmt|;
break|break;
default|default:
comment|/* Token found, copy the name */
name|memset
argument_list|(
name|tab
operator|->
name|tokens
index|[
name|token
index|]
operator|.
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tab
operator|->
name|tokens
index|[
name|token
index|]
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|format
operator|!=
literal|'('
condition|)
block|{
name|tab
operator|->
name|tokens
index|[
name|token
index|]
operator|.
name|name
index|[
name|i
index|]
operator|=
operator|*
name|format
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|format
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|ARM64_MAX_TOKEN_LEN
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR: token too long in op %s\n"
argument_list|,
name|tab
operator|->
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
comment|/* Read the length value */
name|ret
operator|=
name|sscanf
argument_list|(
name|format
argument_list|,
literal|"(%d)"
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|token
operator|>=
name|ARM64_MAX_TOKEN_CNT
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR: to many tokens in op %s\n"
argument_list|,
name|tab
operator|->
name|name
argument_list|)
expr_stmt|;
name|error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|a
operator|-=
name|len
expr_stmt|;
name|tab
operator|->
name|tokens
index|[
name|token
index|]
operator|.
name|pos
operator|=
name|a
operator|+
literal|1
expr_stmt|;
name|tab
operator|->
name|tokens
index|[
name|token
index|]
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|token
operator|++
expr_stmt|;
block|}
comment|/* Skip to the end of the token */
while|while
condition|(
operator|*
name|format
operator|!=
literal|0
operator|&&
operator|*
name|format
operator|!=
literal|'|'
condition|)
name|format
operator|++
expr_stmt|;
block|}
block|}
comment|/* Write mask and pattern to the instruction array */
name|tab
operator|->
name|mask
operator|=
name|mask
expr_stmt|;
name|tab
operator|->
name|pattern
operator|=
name|val
expr_stmt|;
comment|/* 		 * If we got here, format string must be parsed and "a" 		 * should point to -1. If it's not, wrong number of bits 		 * in format string. Mark this as invalid and prevent 		 * from being matched. 		 */
if|if
condition|(
operator|*
name|format
operator|!=
literal|0
operator|||
operator|(
name|a
operator|!=
operator|-
literal|1
operator|)
operator|||
operator|(
name|error
operator|!=
literal|0
operator|)
condition|)
block|{
name|tab
operator|->
name|mask
operator|=
literal|0
expr_stmt|;
name|tab
operator|->
name|pattern
operator|=
literal|0xffffffff
expr_stmt|;
name|printf
argument_list|(
literal|"ERROR: skipping instruction op %s\n"
argument_list|,
name|tab
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|tab
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|arm64_disasm_read_token
parameter_list|(
name|struct
name|arm64_insn
modifier|*
name|insn
parameter_list|,
name|u_int
name|opcode
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|,
name|int
modifier|*
name|val
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARM64_MAX_TOKEN_CNT
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|insn
operator|->
name|tokens
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|token
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|val
operator|=
operator|(
name|opcode
operator|>>
name|insn
operator|->
name|tokens
index|[
name|i
index|]
operator|.
name|pos
operator|&
operator|(
operator|(
literal|1
operator|<<
name|insn
operator|->
name|tokens
index|[
name|i
index|]
operator|.
name|len
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|arm64_reg
parameter_list|(
name|int
name|b64
parameter_list|,
name|int
name|num
parameter_list|)
block|{
if|if
condition|(
name|b64
operator|!=
literal|0
condition|)
return|return
operator|(
name|x_reg
index|[
name|num
index|]
operator|)
return|;
return|return
operator|(
name|w_reg
index|[
name|num
index|]
operator|)
return|;
block|}
end_function

begin_function
name|vm_offset_t
name|disasm
parameter_list|(
specifier|const
name|struct
name|disasm_interface
modifier|*
name|di
parameter_list|,
name|vm_offset_t
name|loc
parameter_list|,
name|int
name|altfmt
parameter_list|)
block|{
name|struct
name|arm64_insn
modifier|*
name|i_ptr
init|=
name|arm64_i
decl_stmt|;
name|uint32_t
name|insn
decl_stmt|;
name|int
name|matchp
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|shift
decl_stmt|,
name|rm
decl_stmt|,
name|rd
decl_stmt|,
name|rn
decl_stmt|,
name|imm
decl_stmt|,
name|sf
decl_stmt|;
name|int
name|rm_absent
decl_stmt|;
comment|/* Initialize defaults, all are 0 except SF indicating 64bit access */
name|shift
operator|=
name|rd
operator|=
name|rm
operator|=
name|rn
operator|=
name|imm
operator|=
literal|0
expr_stmt|;
name|sf
operator|=
literal|1
expr_stmt|;
name|matchp
operator|=
literal|0
expr_stmt|;
name|insn
operator|=
name|di
operator|->
name|di_readword
argument_list|(
name|loc
argument_list|)
expr_stmt|;
while|while
condition|(
name|i_ptr
operator|->
name|name
condition|)
block|{
comment|/* If mask is 0 then the parser was not initialized yet */
if|if
condition|(
operator|(
name|i_ptr
operator|->
name|mask
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|insn
operator|&
name|i_ptr
operator|->
name|mask
operator|)
operator|==
name|i_ptr
operator|->
name|pattern
operator|)
condition|)
block|{
name|matchp
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|i_ptr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|matchp
operator|==
literal|0
condition|)
goto|goto
name|undefined
goto|;
switch|switch
condition|(
name|i_ptr
operator|->
name|type
condition|)
block|{
case|case
name|TYPE_01
case|:
comment|/* OP<RD>,<RN>,<RM>{,<shift [LSL, LSR, ASR]> #<imm>} SF32/64 		   OP<RD>,<RN>, #<imm>{,<shift [0, 12]>} SF32/64 */
comment|/* Mandatory tokens */
name|ret
operator|=
name|arm64_disasm_read_token
argument_list|(
name|i_ptr
argument_list|,
name|insn
argument_list|,
literal|"SF"
argument_list|,
operator|&
name|sf
argument_list|)
expr_stmt|;
name|ret
operator||=
name|arm64_disasm_read_token
argument_list|(
name|i_ptr
argument_list|,
name|insn
argument_list|,
literal|"RD"
argument_list|,
operator|&
name|rd
argument_list|)
expr_stmt|;
name|ret
operator||=
name|arm64_disasm_read_token
argument_list|(
name|i_ptr
argument_list|,
name|insn
argument_list|,
literal|"RN"
argument_list|,
operator|&
name|rn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR: Missing mandatory token for op %s type %d\n"
argument_list|,
name|i_ptr
operator|->
name|name
argument_list|,
name|i_ptr
operator|->
name|type
argument_list|)
expr_stmt|;
goto|goto
name|undefined
goto|;
block|}
comment|/* Optional tokens */
name|arm64_disasm_read_token
argument_list|(
name|i_ptr
argument_list|,
name|insn
argument_list|,
literal|"IMM"
argument_list|,
operator|&
name|imm
argument_list|)
expr_stmt|;
name|arm64_disasm_read_token
argument_list|(
name|i_ptr
argument_list|,
name|insn
argument_list|,
literal|"SHIFT"
argument_list|,
operator|&
name|shift
argument_list|)
expr_stmt|;
name|rm_absent
operator|=
name|arm64_disasm_read_token
argument_list|(
name|i_ptr
argument_list|,
name|insn
argument_list|,
literal|"RM"
argument_list|,
operator|&
name|rm
argument_list|)
expr_stmt|;
name|di
operator|->
name|di_printf
argument_list|(
literal|"%s\t%s, %s"
argument_list|,
name|i_ptr
operator|->
name|name
argument_list|,
name|arm64_reg
argument_list|(
name|sf
argument_list|,
name|rd
argument_list|)
argument_list|,
name|arm64_reg
argument_list|(
name|sf
argument_list|,
name|rn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If RM is present use it, otherwise use immediate notation */
if|if
condition|(
name|rm_absent
operator|==
literal|0
condition|)
block|{
name|di
operator|->
name|di_printf
argument_list|(
literal|", %s"
argument_list|,
name|arm64_reg
argument_list|(
name|sf
argument_list|,
name|rm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|imm
operator|!=
literal|0
condition|)
name|di
operator|->
name|di_printf
argument_list|(
literal|", %s #%d"
argument_list|,
name|shift_2
index|[
name|shift
index|]
argument_list|,
name|imm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|imm
operator|!=
literal|0
operator|||
name|shift
operator|!=
literal|0
condition|)
name|di
operator|->
name|di_printf
argument_list|(
literal|", #0x%x"
argument_list|,
name|imm
argument_list|)
expr_stmt|;
if|if
condition|(
name|shift
operator|!=
literal|0
condition|)
name|di
operator|->
name|di_printf
argument_list|(
literal|" LSL #12"
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
goto|goto
name|undefined
goto|;
block|}
name|di
operator|->
name|di_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|loc
operator|+
name|INSN_SIZE
operator|)
return|;
name|undefined
label|:
name|di
operator|->
name|di_printf
argument_list|(
literal|"undefined\t%08x\n"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
return|return
operator|(
name|loc
operator|+
name|INSN_SIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Parse format strings at the very beginning */
end_comment

begin_expr_stmt
name|SYSINIT
argument_list|(
name|arm64_disasm_generate_masks
argument_list|,
name|SI_SUB_DDB_SERVICES
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|arm64_disasm_generate_masks
argument_list|,
name|arm64_i
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

