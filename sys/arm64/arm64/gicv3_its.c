begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015-2016 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Andrew Turner under  * the sponsorship of the FreeBSD Foundation.  *  * This software was developed by Semihalf under  * the sponsorship of the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_platform.h"
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmem.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|<arm64/arm64/gic_v3_reg.h>
end_include

begin_include
include|#
directive|include
file|<arm64/arm64/gic_v3_var.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|FDT
end_ifdef

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus_subr.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|"pcib_if.h"
end_include

begin_include
include|#
directive|include
file|"pic_if.h"
end_include

begin_include
include|#
directive|include
file|"msi_if.h"
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_GICV3_ITS
argument_list|,
literal|"GICv3 ITS"
argument_list|,
literal|"ARM GICv3 Interrupt Translation Service"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|LPI_NIRQS
value|(64 * 1024)
end_define

begin_comment
comment|/* The size and alignment of the command circular buffer */
end_comment

begin_define
define|#
directive|define
name|ITS_CMDQ_SIZE
value|(64 * 1024)
end_define

begin_comment
comment|/* Must be a multiple of 4K */
end_comment

begin_define
define|#
directive|define
name|ITS_CMDQ_ALIGN
value|(64 * 1024)
end_define

begin_define
define|#
directive|define
name|LPI_CONFTAB_SIZE
value|LPI_NIRQS
end_define

begin_define
define|#
directive|define
name|LPI_CONFTAB_ALIGN
value|(64 * 1024)
end_define

begin_define
define|#
directive|define
name|LPI_CONFTAB_MAX_ADDR
value|((1ul<< 48) - 1)
end_define

begin_comment
comment|/* We need a 47 bit PA */
end_comment

begin_comment
comment|/* 1 bit per SPI, PPI, and SGI (8k), and 1 bit per LPI (LPI_CONFTAB_SIZE) */
end_comment

begin_define
define|#
directive|define
name|LPI_PENDTAB_SIZE
value|((LPI_NIRQS + GIC_FIRST_LPI) / 8)
end_define

begin_define
define|#
directive|define
name|LPI_PENDTAB_ALIGN
value|(64 * 1024)
end_define

begin_define
define|#
directive|define
name|LPI_PENDTAB_MAX_ADDR
value|((1ul<< 48) - 1)
end_define

begin_comment
comment|/* We need a 47 bit PA */
end_comment

begin_define
define|#
directive|define
name|LPI_INT_TRANS_TAB_ALIGN
value|256
end_define

begin_define
define|#
directive|define
name|LPI_INT_TRANS_TAB_MAX_ADDR
value|((1ul<< 48) - 1)
end_define

begin_comment
comment|/* ITS commands encoding */
end_comment

begin_define
define|#
directive|define
name|ITS_CMD_MOVI
value|(0x01)
end_define

begin_define
define|#
directive|define
name|ITS_CMD_SYNC
value|(0x05)
end_define

begin_define
define|#
directive|define
name|ITS_CMD_MAPD
value|(0x08)
end_define

begin_define
define|#
directive|define
name|ITS_CMD_MAPC
value|(0x09)
end_define

begin_define
define|#
directive|define
name|ITS_CMD_MAPTI
value|(0x0a)
end_define

begin_define
define|#
directive|define
name|ITS_CMD_MAPI
value|(0x0b)
end_define

begin_define
define|#
directive|define
name|ITS_CMD_INV
value|(0x0c)
end_define

begin_define
define|#
directive|define
name|ITS_CMD_INVALL
value|(0x0d)
end_define

begin_comment
comment|/* Command */
end_comment

begin_define
define|#
directive|define
name|CMD_COMMAND_MASK
value|(0xFFUL)
end_define

begin_comment
comment|/* PCI device ID */
end_comment

begin_define
define|#
directive|define
name|CMD_DEVID_SHIFT
value|(32)
end_define

begin_define
define|#
directive|define
name|CMD_DEVID_MASK
value|(0xFFFFFFFFUL<< CMD_DEVID_SHIFT)
end_define

begin_comment
comment|/* Size of IRQ ID bitfield */
end_comment

begin_define
define|#
directive|define
name|CMD_SIZE_MASK
value|(0xFFUL)
end_define

begin_comment
comment|/* Virtual LPI ID */
end_comment

begin_define
define|#
directive|define
name|CMD_ID_MASK
value|(0xFFFFFFFFUL)
end_define

begin_comment
comment|/* Physical LPI ID */
end_comment

begin_define
define|#
directive|define
name|CMD_PID_SHIFT
value|(32)
end_define

begin_define
define|#
directive|define
name|CMD_PID_MASK
value|(0xFFFFFFFFUL<< CMD_PID_SHIFT)
end_define

begin_comment
comment|/* Collection */
end_comment

begin_define
define|#
directive|define
name|CMD_COL_MASK
value|(0xFFFFUL)
end_define

begin_comment
comment|/* Target (CPU or Re-Distributor) */
end_comment

begin_define
define|#
directive|define
name|CMD_TARGET_SHIFT
value|(16)
end_define

begin_define
define|#
directive|define
name|CMD_TARGET_MASK
value|(0xFFFFFFFFUL<< CMD_TARGET_SHIFT)
end_define

begin_comment
comment|/* Interrupt Translation Table address */
end_comment

begin_define
define|#
directive|define
name|CMD_ITT_MASK
value|(0xFFFFFFFFFF00UL)
end_define

begin_comment
comment|/* Valid command bit */
end_comment

begin_define
define|#
directive|define
name|CMD_VALID_SHIFT
value|(63)
end_define

begin_define
define|#
directive|define
name|CMD_VALID_MASK
value|(1UL<< CMD_VALID_SHIFT)
end_define

begin_define
define|#
directive|define
name|ITS_TARGET_NONE
value|0xFBADBEEF
end_define

begin_comment
comment|/* LPI chunk owned by ITS device */
end_comment

begin_struct
struct|struct
name|lpi_chunk
block|{
name|u_int
name|lpi_base
decl_stmt|;
name|u_int
name|lpi_free
decl_stmt|;
comment|/* First free LPI in set */
name|u_int
name|lpi_num
decl_stmt|;
comment|/* Total number of LPIs in chunk */
name|u_int
name|lpi_busy
decl_stmt|;
comment|/* Number of busy LPIs in chink */
block|}
struct|;
end_struct

begin_comment
comment|/* ITS device */
end_comment

begin_struct
struct|struct
name|its_dev
block|{
name|TAILQ_ENTRY
argument_list|(
argument|its_dev
argument_list|)
name|entry
expr_stmt|;
comment|/* PCI device */
name|device_t
name|pci_dev
decl_stmt|;
comment|/* Device ID (i.e. PCI device ID) */
name|uint32_t
name|devid
decl_stmt|;
comment|/* List of assigned LPIs */
name|struct
name|lpi_chunk
name|lpis
decl_stmt|;
comment|/* Virtual address of ITT */
name|vm_offset_t
name|itt
decl_stmt|;
name|size_t
name|itt_size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * ITS command descriptor.  * Idea for command description passing taken from Linux.  */
end_comment

begin_struct
struct|struct
name|its_cmd_desc
block|{
name|uint8_t
name|cmd_type
decl_stmt|;
union|union
block|{
struct|struct
block|{
name|struct
name|its_dev
modifier|*
name|its_dev
decl_stmt|;
name|struct
name|its_col
modifier|*
name|col
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
block|}
name|cmd_desc_movi
struct|;
struct|struct
block|{
name|struct
name|its_col
modifier|*
name|col
decl_stmt|;
block|}
name|cmd_desc_sync
struct|;
struct|struct
block|{
name|struct
name|its_col
modifier|*
name|col
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
block|}
name|cmd_desc_mapc
struct|;
struct|struct
block|{
name|struct
name|its_dev
modifier|*
name|its_dev
decl_stmt|;
name|struct
name|its_col
modifier|*
name|col
decl_stmt|;
name|uint32_t
name|pid
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
block|}
name|cmd_desc_mapvi
struct|;
struct|struct
block|{
name|struct
name|its_dev
modifier|*
name|its_dev
decl_stmt|;
name|struct
name|its_col
modifier|*
name|col
decl_stmt|;
name|uint32_t
name|pid
decl_stmt|;
block|}
name|cmd_desc_mapi
struct|;
struct|struct
block|{
name|struct
name|its_dev
modifier|*
name|its_dev
decl_stmt|;
name|uint8_t
name|valid
decl_stmt|;
block|}
name|cmd_desc_mapd
struct|;
struct|struct
block|{
name|struct
name|its_dev
modifier|*
name|its_dev
decl_stmt|;
name|struct
name|its_col
modifier|*
name|col
decl_stmt|;
name|uint32_t
name|pid
decl_stmt|;
block|}
name|cmd_desc_inv
struct|;
struct|struct
block|{
name|struct
name|its_col
modifier|*
name|col
decl_stmt|;
block|}
name|cmd_desc_invall
struct|;
block|}
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* ITS command. Each command is 32 bytes long */
end_comment

begin_struct
struct|struct
name|its_cmd
block|{
name|uint64_t
name|cmd_dword
index|[
literal|4
index|]
decl_stmt|;
comment|/* ITS command double word */
block|}
struct|;
end_struct

begin_comment
comment|/* An ITS private table */
end_comment

begin_struct
struct|struct
name|its_ptable
block|{
name|vm_offset_t
name|ptab_vaddr
decl_stmt|;
name|unsigned
name|long
name|ptab_size
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ITS collection description. */
end_comment

begin_struct
struct|struct
name|its_col
block|{
name|uint64_t
name|col_target
decl_stmt|;
comment|/* Target Re-Distributor */
name|uint64_t
name|col_id
decl_stmt|;
comment|/* Collection ID */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|gicv3_its_irqsrc
block|{
name|struct
name|intr_irqsrc
name|gi_isrc
decl_stmt|;
name|u_int
name|gi_irq
decl_stmt|;
name|struct
name|its_dev
modifier|*
name|gi_its_dev
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|gicv3_its_softc
block|{
name|struct
name|intr_pic
modifier|*
name|sc_pic
decl_stmt|;
name|struct
name|resource
modifier|*
name|sc_its_res
decl_stmt|;
name|struct
name|its_ptable
name|sc_its_ptab
index|[
name|GITS_BASER_NUM
index|]
decl_stmt|;
name|struct
name|its_col
modifier|*
name|sc_its_cols
index|[
name|MAXCPU
index|]
decl_stmt|;
comment|/* Per-CPU collections */
comment|/* 	 * TODO: We should get these from the parent as we only want a 	 * single copy of each across the interrupt controller. 	 */
name|vm_offset_t
name|sc_conf_base
decl_stmt|;
name|vm_offset_t
name|sc_pend_base
index|[
name|MAXCPU
index|]
decl_stmt|;
comment|/* Command handling */
name|struct
name|mtx
name|sc_its_cmd_lock
decl_stmt|;
name|struct
name|its_cmd
modifier|*
name|sc_its_cmd_base
decl_stmt|;
comment|/* Command circular buffer address */
name|size_t
name|sc_its_cmd_next_idx
decl_stmt|;
name|vmem_t
modifier|*
name|sc_irq_alloc
decl_stmt|;
name|struct
name|gicv3_its_irqsrc
modifier|*
name|sc_irqs
decl_stmt|;
name|struct
name|mtx
name|sc_its_dev_lock
decl_stmt|;
name|TAILQ_HEAD
argument_list|(
argument|its_dev_list
argument_list|,
argument|its_dev
argument_list|)
name|sc_its_dev_list
expr_stmt|;
define|#
directive|define
name|ITS_FLAGS_CMDQ_FLUSH
value|0x00000001
define|#
directive|define
name|ITS_FLAGS_LPI_CONF_FLUSH
value|0x00000002
define|#
directive|define
name|ITS_FLAGS_ERRATA_CAVIUM_22375
value|0x00000004
name|u_int
name|sc_its_flags
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|void
function_decl|(
name|its_quirk_func_t
function_decl|)
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|its_quirk_func_t
name|its_quirk_cavium_22375
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
name|uint32_t
name|iidr
decl_stmt|;
name|uint32_t
name|iidr_mask
decl_stmt|;
name|its_quirk_func_t
modifier|*
name|func
decl_stmt|;
block|}
name|its_quirks
index|[]
init|=
block|{
block|{
comment|/* Cavium ThunderX Pass 1.x */
operator|.
name|desc
operator|=
literal|"Cavoum ThunderX errata: 22375, 24313"
block|,
operator|.
name|iidr
operator|=
name|GITS_IIDR_RAW
argument_list|(
name|GITS_IIDR_IMPL_CAVIUM
argument_list|,
name|GITS_IIDR_PROD_THUNDER
argument_list|,
name|GITS_IIDR_VAR_THUNDER_1
argument_list|,
literal|0
argument_list|)
block|,
operator|.
name|iidr_mask
operator|=
operator|~
name|GITS_IIDR_REVISION_MASK
block|,
operator|.
name|func
operator|=
name|its_quirk_cavium_22375
block|, 	}
block|, }
struct|;
end_struct

begin_decl_stmt
specifier|static
name|u_int
name|gic_irq_cpu
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|gic_its_read_4
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|)
define|\
value|bus_read_4((sc)->sc_its_res, (reg))
end_define

begin_define
define|#
directive|define
name|gic_its_read_8
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|)
define|\
value|bus_read_8((sc)->sc_its_res, (reg))
end_define

begin_define
define|#
directive|define
name|gic_its_write_4
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_write_4((sc)->sc_its_res, (reg), (val))
end_define

begin_define
define|#
directive|define
name|gic_its_write_8
parameter_list|(
name|sc
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_write_8((sc)->sc_its_res, (reg), (val))
end_define

begin_decl_stmt
specifier|static
name|device_attach_t
name|gicv3_its_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_detach_t
name|gicv3_its_detach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pic_disable_intr_t
name|gicv3_its_disable_intr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pic_enable_intr_t
name|gicv3_its_enable_intr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pic_map_intr_t
name|gicv3_its_map_intr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pic_setup_intr_t
name|gicv3_its_setup_intr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pic_post_filter_t
name|gicv3_its_post_filter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pic_post_ithread_t
name|gicv3_its_post_ithread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pic_pre_ithread_t
name|gicv3_its_pre_ithread
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pic_bind_intr_t
name|gicv3_its_bind_intr
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_decl_stmt
specifier|static
name|pic_init_secondary_t
name|gicv3_its_init_secondary
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|msi_alloc_msi_t
name|gicv3_its_alloc_msi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|msi_release_msi_t
name|gicv3_its_release_msi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|msi_alloc_msix_t
name|gicv3_its_alloc_msix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|msi_release_msix_t
name|gicv3_its_release_msix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|msi_map_msi_t
name|gicv3_its_map_msi
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|its_cmd_movi
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|gicv3_its_irqsrc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|its_cmd_mapc
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|its_col
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|its_cmd_mapti
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|gicv3_its_irqsrc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|its_cmd_mapd
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|its_dev
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|its_cmd_inv
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|its_dev
modifier|*
parameter_list|,
name|struct
name|gicv3_its_irqsrc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|its_cmd_invall
parameter_list|(
name|device_t
parameter_list|,
name|struct
name|its_col
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|gicv3_its_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|gicv3_its_detach
argument_list|)
block|,
comment|/* Interrupt controller interface */
name|DEVMETHOD
argument_list|(
name|pic_disable_intr
argument_list|,
name|gicv3_its_disable_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_enable_intr
argument_list|,
name|gicv3_its_enable_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_map_intr
argument_list|,
name|gicv3_its_map_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_setup_intr
argument_list|,
name|gicv3_its_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_post_filter
argument_list|,
name|gicv3_its_post_filter
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_post_ithread
argument_list|,
name|gicv3_its_post_ithread
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_pre_ithread
argument_list|,
name|gicv3_its_pre_ithread
argument_list|)
block|,
ifdef|#
directive|ifdef
name|SMP
name|DEVMETHOD
argument_list|(
name|pic_bind_intr
argument_list|,
name|gicv3_its_bind_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_init_secondary
argument_list|,
name|gicv3_its_init_secondary
argument_list|)
block|,
endif|#
directive|endif
comment|/* MSI/MSI-X */
name|DEVMETHOD
argument_list|(
name|msi_alloc_msi
argument_list|,
name|gicv3_its_alloc_msi
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|msi_release_msi
argument_list|,
name|gicv3_its_release_msi
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|msi_alloc_msix
argument_list|,
name|gicv3_its_alloc_msix
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|msi_release_msix
argument_list|,
name|gicv3_its_release_msix
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|msi_map_msi
argument_list|,
name|gicv3_its_map_msi
argument_list|)
block|,
comment|/* End */
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|DEFINE_CLASS_0
argument_list|(
name|gic
argument_list|,
name|gicv3_its_driver
argument_list|,
name|gicv3_its_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|gicv3_its_softc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|gicv3_its_cmdq_init
parameter_list|(
name|struct
name|gicv3_its_softc
modifier|*
name|sc
parameter_list|)
block|{
name|vm_paddr_t
name|cmd_paddr
decl_stmt|;
name|uint64_t
name|reg
decl_stmt|,
name|tmp
decl_stmt|;
comment|/* Set up the command circular buffer */
name|sc
operator|->
name|sc_its_cmd_base
operator|=
name|contigmalloc
argument_list|(
name|ITS_CMDQ_SIZE
argument_list|,
name|M_GICV3_ITS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|,
literal|0
argument_list|,
operator|(
literal|1ul
operator|<<
literal|48
operator|)
operator|-
literal|1
argument_list|,
name|ITS_CMDQ_ALIGN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_its_cmd_next_idx
operator|=
literal|0
expr_stmt|;
name|cmd_paddr
operator|=
name|vtophys
argument_list|(
name|sc
operator|->
name|sc_its_cmd_base
argument_list|)
expr_stmt|;
comment|/* Set the base of the command buffer */
name|reg
operator|=
name|GITS_CBASER_VALID
operator||
operator|(
name|GITS_CBASER_CACHE_NIWAWB
operator|<<
name|GITS_CBASER_CACHE_SHIFT
operator|)
operator||
name|cmd_paddr
operator||
operator|(
name|GITS_CBASER_SHARE_IS
operator|<<
name|GITS_CBASER_SHARE_SHIFT
operator|)
operator||
operator|(
name|ITS_CMDQ_SIZE
operator|/
literal|4096
operator|-
literal|1
operator|)
expr_stmt|;
name|gic_its_write_8
argument_list|(
name|sc
argument_list|,
name|GITS_CBASER
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Read back to check for fixed value fields */
name|tmp
operator|=
name|gic_its_read_8
argument_list|(
name|sc
argument_list|,
name|GITS_CBASER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|&
name|GITS_CBASER_SHARE_MASK
operator|)
operator|!=
operator|(
name|GITS_CBASER_SHARE_IS
operator|<<
name|GITS_CBASER_SHARE_SHIFT
operator|)
condition|)
block|{
comment|/* Check if the hardware reported non-shareable */
if|if
condition|(
operator|(
name|tmp
operator|&
name|GITS_CBASER_SHARE_MASK
operator|)
operator|==
operator|(
name|GITS_CBASER_SHARE_NS
operator|<<
name|GITS_CBASER_SHARE_SHIFT
operator|)
condition|)
block|{
comment|/* If so remove the cache attribute */
name|reg
operator|&=
operator|~
name|GITS_CBASER_CACHE_MASK
expr_stmt|;
name|reg
operator|&=
operator|~
name|GITS_CBASER_SHARE_MASK
expr_stmt|;
comment|/* Set to Non-cacheable, Non-shareable */
name|reg
operator||=
name|GITS_CBASER_CACHE_NIN
operator|<<
name|GITS_CBASER_CACHE_SHIFT
expr_stmt|;
name|reg
operator||=
name|GITS_CBASER_SHARE_NS
operator|<<
name|GITS_CBASER_SHARE_SHIFT
expr_stmt|;
name|gic_its_write_8
argument_list|(
name|sc
argument_list|,
name|GITS_CBASER
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
comment|/* The command queue has to be flushed after each command */
name|sc
operator|->
name|sc_its_flags
operator||=
name|ITS_FLAGS_CMDQ_FLUSH
expr_stmt|;
block|}
comment|/* Get the next command from the start of the buffer */
name|gic_its_write_8
argument_list|(
name|sc
argument_list|,
name|GITS_CWRITER
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gicv3_its_table_init
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|gicv3_its_softc
modifier|*
name|sc
parameter_list|)
block|{
name|vm_offset_t
name|table
decl_stmt|;
name|vm_paddr_t
name|paddr
decl_stmt|;
name|uint64_t
name|cache
decl_stmt|,
name|reg
decl_stmt|,
name|share
decl_stmt|,
name|tmp
decl_stmt|,
name|type
decl_stmt|;
name|size_t
name|esize
decl_stmt|,
name|its_tbl_size
decl_stmt|,
name|nidents
decl_stmt|,
name|nitspages
decl_stmt|,
name|npages
decl_stmt|;
name|int
name|i
decl_stmt|,
name|page_size
decl_stmt|;
name|int
name|devbits
decl_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_its_flags
operator|&
name|ITS_FLAGS_ERRATA_CAVIUM_22375
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * GITS_TYPER[17:13] of ThunderX reports that device IDs 		 * are to be 21 bits in length. The entry size of the ITS 		 * table can be read from GITS_BASERn[52:48] and on ThunderX 		 * is supposed to be 8 bytes in length (for device table). 		 * Finally the page size that is to be used by ITS to access 		 * this table will be set to 64KB. 		 * 		 * This gives 0x200000 entries of size 0x8 bytes covered by 		 * 256 pages each of which 64KB in size. The number of pages 		 * (minus 1) should then be written to GITS_BASERn[7:0]. In 		 * that case this value would be 0xFF but on ThunderX the 		 * maximum value that HW accepts is 0xFD. 		 * 		 * Set an arbitrary number of device ID bits to 20 in order 		 * to limit the number of entries in ITS device table to 		 * 0x100000 and the table size to 8MB. 		 */
name|devbits
operator|=
literal|20
expr_stmt|;
name|cache
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|devbits
operator|=
name|GITS_TYPER_DEVB
argument_list|(
name|gic_its_read_8
argument_list|(
name|sc
argument_list|,
name|GITS_TYPER
argument_list|)
argument_list|)
expr_stmt|;
name|cache
operator|=
name|GITS_BASER_CACHE_WAWB
expr_stmt|;
block|}
name|share
operator|=
name|GITS_BASER_SHARE_IS
expr_stmt|;
name|page_size
operator|=
name|PAGE_SIZE_64K
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GITS_BASER_NUM
condition|;
name|i
operator|++
control|)
block|{
name|reg
operator|=
name|gic_its_read_8
argument_list|(
name|sc
argument_list|,
name|GITS_BASER
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The type of table */
name|type
operator|=
name|GITS_BASER_TYPE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
comment|/* The table entry size */
name|esize
operator|=
name|GITS_BASER_ESIZE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GITS_BASER_TYPE_DEV
case|:
name|nidents
operator|=
operator|(
literal|1
operator|<<
name|devbits
operator|)
expr_stmt|;
name|its_tbl_size
operator|=
name|esize
operator|*
name|nidents
expr_stmt|;
name|its_tbl_size
operator|=
name|roundup2
argument_list|(
name|its_tbl_size
argument_list|,
name|PAGE_SIZE_64K
argument_list|)
expr_stmt|;
break|break;
case|case
name|GITS_BASER_TYPE_VP
case|:
case|case
name|GITS_BASER_TYPE_PP
case|:
comment|/* Undocumented? */
case|case
name|GITS_BASER_TYPE_IC
case|:
name|its_tbl_size
operator|=
name|page_size
expr_stmt|;
break|break;
default|default:
continue|continue;
block|}
name|npages
operator|=
name|howmany
argument_list|(
name|its_tbl_size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* Allocate the table */
name|table
operator|=
operator|(
name|vm_offset_t
operator|)
name|contigmalloc
argument_list|(
name|npages
operator|*
name|PAGE_SIZE
argument_list|,
name|M_GICV3_ITS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|,
literal|0
argument_list|,
operator|(
literal|1ul
operator|<<
literal|48
operator|)
operator|-
literal|1
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_its_ptab
index|[
name|i
index|]
operator|.
name|ptab_vaddr
operator|=
name|table
expr_stmt|;
name|sc
operator|->
name|sc_its_ptab
index|[
name|i
index|]
operator|.
name|ptab_size
operator|=
name|npages
operator|*
name|PAGE_SIZE
expr_stmt|;
name|paddr
operator|=
name|vtophys
argument_list|(
name|table
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|nitspages
operator|=
name|howmany
argument_list|(
name|its_tbl_size
argument_list|,
name|page_size
argument_list|)
expr_stmt|;
comment|/* Clear the fields we will be setting */
name|reg
operator|&=
operator|~
operator|(
name|GITS_BASER_VALID
operator||
name|GITS_BASER_CACHE_MASK
operator||
name|GITS_BASER_TYPE_MASK
operator||
name|GITS_BASER_ESIZE_MASK
operator||
name|GITS_BASER_PA_MASK
operator||
name|GITS_BASER_SHARE_MASK
operator||
name|GITS_BASER_PSZ_MASK
operator||
name|GITS_BASER_SIZE_MASK
operator|)
expr_stmt|;
comment|/* Set the new values */
name|reg
operator||=
name|GITS_BASER_VALID
operator||
operator|(
name|cache
operator|<<
name|GITS_BASER_CACHE_SHIFT
operator|)
operator||
operator|(
name|type
operator|<<
name|GITS_BASER_TYPE_SHIFT
operator|)
operator||
operator|(
operator|(
name|esize
operator|-
literal|1
operator|)
operator|<<
name|GITS_BASER_ESIZE_SHIFT
operator|)
operator||
name|paddr
operator||
operator|(
name|share
operator|<<
name|GITS_BASER_SHARE_SHIFT
operator|)
operator||
operator|(
name|nitspages
operator|-
literal|1
operator|)
expr_stmt|;
switch|switch
condition|(
name|page_size
condition|)
block|{
case|case
name|PAGE_SIZE
case|:
comment|/* 4KB */
name|reg
operator||=
name|GITS_BASER_PSZ_4K
operator|<<
name|GITS_BASER_PSZ_SHIFT
expr_stmt|;
break|break;
case|case
name|PAGE_SIZE_16K
case|:
comment|/* 16KB */
name|reg
operator||=
name|GITS_BASER_PSZ_4K
operator|<<
name|GITS_BASER_PSZ_SHIFT
expr_stmt|;
break|break;
case|case
name|PAGE_SIZE_64K
case|:
comment|/* 64KB */
name|reg
operator||=
name|GITS_BASER_PSZ_64K
operator|<<
name|GITS_BASER_PSZ_SHIFT
expr_stmt|;
break|break;
block|}
name|gic_its_write_8
argument_list|(
name|sc
argument_list|,
name|GITS_BASER
argument_list|(
name|i
argument_list|)
argument_list|,
name|reg
argument_list|)
expr_stmt|;
comment|/* Read back to check */
name|tmp
operator|=
name|gic_its_read_8
argument_list|(
name|sc
argument_list|,
name|GITS_BASER
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do the snareability masks line up? */
if|if
condition|(
operator|(
name|tmp
operator|&
name|GITS_BASER_SHARE_MASK
operator|)
operator|!=
operator|(
name|reg
operator|&
name|GITS_BASER_SHARE_MASK
operator|)
condition|)
block|{
name|share
operator|=
operator|(
name|tmp
operator|&
name|GITS_BASER_SHARE_MASK
operator|)
operator|>>
name|GITS_BASER_SHARE_SHIFT
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|tmp
operator|&
name|GITS_BASER_PSZ_MASK
operator|)
operator|!=
operator|(
name|reg
operator|&
name|GITS_BASER_PSZ_MASK
operator|)
condition|)
block|{
switch|switch
condition|(
name|page_size
condition|)
block|{
case|case
name|PAGE_SIZE_16K
case|:
name|page_size
operator|=
name|PAGE_SIZE
expr_stmt|;
continue|continue;
case|case
name|PAGE_SIZE_64K
case|:
name|page_size
operator|=
name|PAGE_SIZE_16K
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|tmp
operator|!=
name|reg
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"GITS_BASER%d: "
literal|"unable to be updated: %lx != %lx\n"
argument_list|,
name|i
argument_list|,
name|reg
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* We should have made all needed changes */
break|break;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gicv3_its_conftable_init
parameter_list|(
name|struct
name|gicv3_its_softc
modifier|*
name|sc
parameter_list|)
block|{
name|sc
operator|->
name|sc_conf_base
operator|=
operator|(
name|vm_offset_t
operator|)
name|contigmalloc
argument_list|(
name|LPI_CONFTAB_SIZE
argument_list|,
name|M_GICV3_ITS
argument_list|,
name|M_WAITOK
argument_list|,
literal|0
argument_list|,
name|LPI_CONFTAB_MAX_ADDR
argument_list|,
name|LPI_CONFTAB_ALIGN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set the default configuration */
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|sc_conf_base
argument_list|,
name|GIC_PRIORITY_MAX
operator||
name|LPI_CONF_GROUP1
argument_list|,
name|LPI_CONFTAB_SIZE
argument_list|)
expr_stmt|;
comment|/* Flush the table to memory */
name|cpu_dcache_wb_range
argument_list|(
name|sc
operator|->
name|sc_conf_base
argument_list|,
name|LPI_CONFTAB_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gicv3_its_pendtables_init
parameter_list|(
name|struct
name|gicv3_its_softc
modifier|*
name|sc
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp_ncpus
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|all_cpus
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|sc
operator|->
name|sc_pend_base
index|[
name|i
index|]
operator|=
operator|(
name|vm_offset_t
operator|)
name|contigmalloc
argument_list|(
name|LPI_PENDTAB_SIZE
argument_list|,
name|M_GICV3_ITS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|,
literal|0
argument_list|,
name|LPI_PENDTAB_MAX_ADDR
argument_list|,
name|LPI_PENDTAB_ALIGN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Flush so the ITS can see the memory */
name|cpu_dcache_wb_range
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|sc
operator|->
name|sc_pend_base
argument_list|,
name|LPI_PENDTAB_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|its_init_cpu
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|gicv3_its_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|gicv3
decl_stmt|;
name|vm_paddr_t
name|target
decl_stmt|;
name|uint64_t
name|xbaser
decl_stmt|,
name|tmp
decl_stmt|;
name|uint32_t
name|ctlr
decl_stmt|;
name|u_int
name|cpuid
decl_stmt|;
name|gicv3
operator|=
name|device_get_parent
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cpuid
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
comment|/* Check if the ITS is enabled on this CPU */
if|if
condition|(
operator|(
name|gic_r_read_4
argument_list|(
name|gicv3
argument_list|,
name|GICR_TYPER
argument_list|)
operator|&
name|GICR_TYPER_PLPIS
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Disable LPIs */
name|ctlr
operator|=
name|gic_r_read_4
argument_list|(
name|gicv3
argument_list|,
name|GICR_CTLR
argument_list|)
expr_stmt|;
name|ctlr
operator|&=
operator|~
name|GICR_CTLR_LPI_ENABLE
expr_stmt|;
name|gic_r_write_4
argument_list|(
name|gicv3
argument_list|,
name|GICR_CTLR
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
comment|/* Make sure changes are observable my the GIC */
name|dsb
argument_list|(
name|sy
argument_list|)
expr_stmt|;
comment|/* 	 * Set the redistributor base 	 */
name|xbaser
operator|=
name|vtophys
argument_list|(
name|sc
operator|->
name|sc_conf_base
argument_list|)
operator||
operator|(
name|GICR_PROPBASER_SHARE_IS
operator|<<
name|GICR_PROPBASER_SHARE_SHIFT
operator|)
operator||
operator|(
name|GICR_PROPBASER_CACHE_NIWAWB
operator|<<
name|GICR_PROPBASER_CACHE_SHIFT
operator|)
operator||
operator|(
name|flsl
argument_list|(
name|LPI_CONFTAB_SIZE
operator||
name|GIC_FIRST_LPI
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|gic_r_write_8
argument_list|(
name|gicv3
argument_list|,
name|GICR_PROPBASER
argument_list|,
name|xbaser
argument_list|)
expr_stmt|;
comment|/* Check the cache attributes we set */
name|tmp
operator|=
name|gic_r_read_8
argument_list|(
name|gicv3
argument_list|,
name|GICR_PROPBASER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|&
name|GICR_PROPBASER_SHARE_MASK
operator|)
operator|!=
operator|(
name|xbaser
operator|&
name|GICR_PROPBASER_SHARE_MASK
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|tmp
operator|&
name|GICR_PROPBASER_SHARE_MASK
operator|)
operator|==
operator|(
name|GICR_PROPBASER_SHARE_NS
operator|<<
name|GICR_PROPBASER_SHARE_SHIFT
operator|)
condition|)
block|{
comment|/* We need to mark as non-cacheable */
name|xbaser
operator|&=
operator|~
operator|(
name|GICR_PROPBASER_SHARE_MASK
operator||
name|GICR_PROPBASER_CACHE_MASK
operator|)
expr_stmt|;
comment|/* Non-cacheable */
name|xbaser
operator||=
name|GICR_PROPBASER_CACHE_NIN
operator|<<
name|GICR_PROPBASER_CACHE_SHIFT
expr_stmt|;
comment|/* Non-sareable */
name|xbaser
operator||=
name|GICR_PROPBASER_SHARE_NS
operator|<<
name|GICR_PROPBASER_SHARE_SHIFT
expr_stmt|;
name|gic_r_write_8
argument_list|(
name|gicv3
argument_list|,
name|GICR_PROPBASER
argument_list|,
name|xbaser
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_its_flags
operator||=
name|ITS_FLAGS_LPI_CONF_FLUSH
expr_stmt|;
block|}
comment|/* 	 * Set the LPI pending table base 	 */
name|xbaser
operator|=
name|vtophys
argument_list|(
name|sc
operator|->
name|sc_pend_base
index|[
name|cpuid
index|]
argument_list|)
operator||
operator|(
name|GICR_PENDBASER_CACHE_NIWAWB
operator|<<
name|GICR_PENDBASER_CACHE_SHIFT
operator|)
operator||
operator|(
name|GICR_PENDBASER_SHARE_IS
operator|<<
name|GICR_PENDBASER_SHARE_SHIFT
operator|)
expr_stmt|;
name|gic_r_write_8
argument_list|(
name|gicv3
argument_list|,
name|GICR_PENDBASER
argument_list|,
name|xbaser
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|gic_r_read_8
argument_list|(
name|gicv3
argument_list|,
name|GICR_PENDBASER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|&
name|GICR_PENDBASER_SHARE_MASK
operator|)
operator|==
operator|(
name|GICR_PENDBASER_SHARE_NS
operator|<<
name|GICR_PENDBASER_SHARE_SHIFT
operator|)
condition|)
block|{
comment|/* Clear the cahce and shareability bits */
name|xbaser
operator|&=
operator|~
operator|(
name|GICR_PENDBASER_CACHE_MASK
operator||
name|GICR_PENDBASER_SHARE_MASK
operator|)
expr_stmt|;
comment|/* Mark as non-shareable */
name|xbaser
operator||=
name|GICR_PENDBASER_SHARE_NS
operator|<<
name|GICR_PENDBASER_SHARE_SHIFT
expr_stmt|;
comment|/* And non-cacheable */
name|xbaser
operator||=
name|GICR_PENDBASER_CACHE_NIN
operator|<<
name|GICR_PENDBASER_CACHE_SHIFT
expr_stmt|;
block|}
comment|/* Enable LPIs */
name|ctlr
operator|=
name|gic_r_read_4
argument_list|(
name|gicv3
argument_list|,
name|GICR_CTLR
argument_list|)
expr_stmt|;
name|ctlr
operator||=
name|GICR_CTLR_LPI_ENABLE
expr_stmt|;
name|gic_r_write_4
argument_list|(
name|gicv3
argument_list|,
name|GICR_CTLR
argument_list|,
name|ctlr
argument_list|)
expr_stmt|;
comment|/* Make sure the GIC has seen everything */
name|dsb
argument_list|(
name|sy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gic_its_read_8
argument_list|(
name|sc
argument_list|,
name|GITS_TYPER
argument_list|)
operator|&
name|GITS_TYPER_PTA
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* This ITS wants the redistributor physical address */
name|target
operator|=
name|vtophys
argument_list|(
name|gicv3_get_redist_vaddr
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This ITS wants the unique processor number */
name|target
operator|=
name|GICR_TYPER_CPUNUM
argument_list|(
name|gic_r_read_8
argument_list|(
name|gicv3
argument_list|,
name|GICR_TYPER
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_its_cols
index|[
name|cpuid
index|]
operator|->
name|col_target
operator|=
name|target
expr_stmt|;
name|sc
operator|->
name|sc_its_cols
index|[
name|cpuid
index|]
operator|->
name|col_id
operator|=
name|cpuid
expr_stmt|;
name|its_cmd_mapc
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_its_cols
index|[
name|cpuid
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|its_cmd_invall
argument_list|(
name|dev
argument_list|,
name|sc
operator|->
name|sc_its_cols
index|[
name|cpuid
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gicv3_its_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|gicv3_its_softc
modifier|*
name|sc
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|uint32_t
name|iidr
decl_stmt|;
name|int
name|err
decl_stmt|,
name|i
decl_stmt|,
name|rid
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_its_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_its_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|iidr
operator|=
name|gic_its_read_4
argument_list|(
name|sc
argument_list|,
name|GITS_IIDR
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|its_quirks
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|iidr
operator|&
name|its_quirks
index|[
name|i
index|]
operator|.
name|iidr_mask
operator|)
operator|==
name|its_quirks
index|[
name|i
index|]
operator|.
name|iidr
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Applying %s\n"
argument_list|,
name|its_quirks
index|[
name|i
index|]
operator|.
name|desc
argument_list|)
expr_stmt|;
block|}
name|its_quirks
index|[
name|i
index|]
operator|.
name|func
argument_list|(
name|dev
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Allocate the private tables */
name|err
operator|=
name|gicv3_its_table_init
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Protects access to the device list */
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_its_dev_lock
argument_list|,
literal|"ITS device lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
comment|/* Protects access to the ITS command circular buffer. */
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_its_cmd_lock
argument_list|,
literal|"ITS cmd lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
comment|/* Allocate the command circular buffer */
name|gicv3_its_cmdq_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Allocate the per-CPU collections */
for|for
control|(
name|int
name|cpu
init|=
literal|0
init|;
name|cpu
operator|<
name|mp_ncpus
condition|;
name|cpu
operator|++
control|)
if|if
condition|(
name|CPU_ISSET
argument_list|(
name|cpu
argument_list|,
operator|&
name|all_cpus
argument_list|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|sc_its_cols
index|[
name|cpu
index|]
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|sc_its_cols
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|M_GICV3_ITS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|sc_its_cols
index|[
name|cpu
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Enable the ITS */
name|gic_its_write_4
argument_list|(
name|sc
argument_list|,
name|GITS_CTLR
argument_list|,
name|gic_its_read_4
argument_list|(
name|sc
argument_list|,
name|GITS_CTLR
argument_list|)
operator||
name|GITS_CTLR_EN
argument_list|)
expr_stmt|;
comment|/* Create the LPI configuration table */
name|gicv3_its_conftable_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* And the pending tebles */
name|gicv3_its_pendtables_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Enable LPIs on this CPU */
name|its_init_cpu
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|sc_its_dev_list
argument_list|)
expr_stmt|;
comment|/* 	 * Create the vmem object to allocate IRQs from. We try to use all 	 * IRQs not already used by the GICv3. 	 * XXX: This assumes there are no other interrupt controllers in the 	 * system. 	 */
name|sc
operator|->
name|sc_irq_alloc
operator|=
name|vmem_create
argument_list|(
literal|"GICv3 ITS IRQs"
argument_list|,
literal|0
argument_list|,
name|NIRQ
operator|-
name|gicv3_get_nirqs
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|M_FIRSTFIT
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_irqs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|sc_irqs
argument_list|)
operator|*
name|LPI_NIRQS
argument_list|,
name|M_GICV3_ITS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|name
operator|=
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LPI_NIRQS
condition|;
name|i
operator|++
control|)
block|{
name|sc
operator|->
name|sc_irqs
index|[
name|i
index|]
operator|.
name|gi_irq
operator|=
name|i
expr_stmt|;
name|err
operator|=
name|intr_isrc_register
argument_list|(
operator|&
name|sc
operator|->
name|sc_irqs
index|[
name|i
index|]
operator|.
name|gi_isrc
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|,
literal|"%s,%u"
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gicv3_its_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|its_quirk_cavium_22375
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|gicv3_its_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_its_flags
operator||=
name|ITS_FLAGS_ERRATA_CAVIUM_22375
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gicv3_its_disable_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|gicv3_its_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|gicv3_its_irqsrc
modifier|*
name|girq
decl_stmt|;
name|uint8_t
modifier|*
name|conf
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|girq
operator|=
operator|(
expr|struct
name|gicv3_its_irqsrc
operator|*
operator|)
name|isrc
expr_stmt|;
name|conf
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|sc
operator|->
name|sc_conf_base
expr_stmt|;
name|conf
index|[
name|girq
operator|->
name|gi_irq
index|]
operator|&=
operator|~
name|LPI_CONF_ENABLE
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_its_flags
operator|&
name|ITS_FLAGS_LPI_CONF_FLUSH
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Clean D-cache under command. */
name|cpu_dcache_wb_range
argument_list|(
operator|(
name|vm_offset_t
operator|)
operator|&
name|conf
index|[
name|girq
operator|->
name|gi_irq
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* DSB inner shareable, store */
name|dsb
argument_list|(
name|ishst
argument_list|)
expr_stmt|;
block|}
name|its_cmd_inv
argument_list|(
name|dev
argument_list|,
name|girq
operator|->
name|gi_its_dev
argument_list|,
name|girq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gicv3_its_enable_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|gicv3_its_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|gicv3_its_irqsrc
modifier|*
name|girq
decl_stmt|;
name|uint8_t
modifier|*
name|conf
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|girq
operator|=
operator|(
expr|struct
name|gicv3_its_irqsrc
operator|*
operator|)
name|isrc
expr_stmt|;
name|conf
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|sc
operator|->
name|sc_conf_base
expr_stmt|;
name|conf
index|[
name|girq
operator|->
name|gi_irq
index|]
operator||=
name|LPI_CONF_ENABLE
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_its_flags
operator|&
name|ITS_FLAGS_LPI_CONF_FLUSH
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Clean D-cache under command. */
name|cpu_dcache_wb_range
argument_list|(
operator|(
name|vm_offset_t
operator|)
operator|&
name|conf
index|[
name|girq
operator|->
name|gi_irq
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* DSB inner shareable, store */
name|dsb
argument_list|(
name|ishst
argument_list|)
expr_stmt|;
block|}
name|its_cmd_inv
argument_list|(
name|dev
argument_list|,
name|girq
operator|->
name|gi_its_dev
argument_list|,
name|girq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gicv3_its_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uintptr_t
name|irq
parameter_list|)
block|{
name|struct
name|gicv3_its_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|gicv3_its_irqsrc
modifier|*
name|girq
decl_stmt|;
name|struct
name|trapframe
modifier|*
name|tf
decl_stmt|;
name|irq
operator|-=
name|GIC_FIRST_LPI
expr_stmt|;
name|girq
operator|=
operator|&
name|sc
operator|->
name|sc_irqs
index|[
name|irq
index|]
expr_stmt|;
if|if
condition|(
name|girq
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"gicv3_its_intr: Invalid interrupt %ld"
argument_list|,
name|irq
operator|+
name|GIC_FIRST_LPI
argument_list|)
expr_stmt|;
name|tf
operator|=
name|curthread
operator|->
name|td_intr_frame
expr_stmt|;
name|intr_isrc_dispatch
argument_list|(
operator|&
name|girq
operator|->
name|gi_isrc
argument_list|,
name|tf
argument_list|)
expr_stmt|;
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gicv3_its_pre_ithread
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|gicv3_its_irqsrc
modifier|*
name|girq
decl_stmt|;
name|girq
operator|=
operator|(
expr|struct
name|gicv3_its_irqsrc
operator|*
operator|)
name|isrc
expr_stmt|;
name|gicv3_its_disable_intr
argument_list|(
name|dev
argument_list|,
name|isrc
argument_list|)
expr_stmt|;
name|gic_icc_write
argument_list|(
name|EOIR1
argument_list|,
name|girq
operator|->
name|gi_irq
operator|+
name|GIC_FIRST_LPI
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gicv3_its_post_ithread
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|gicv3_its_enable_intr
argument_list|(
name|dev
argument_list|,
name|isrc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gicv3_its_post_filter
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|gicv3_its_irqsrc
modifier|*
name|girq
decl_stmt|;
name|girq
operator|=
operator|(
expr|struct
name|gicv3_its_irqsrc
operator|*
operator|)
name|isrc
expr_stmt|;
name|gic_icc_write
argument_list|(
name|EOIR1
argument_list|,
name|girq
operator|->
name|gi_irq
operator|+
name|GIC_FIRST_LPI
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gicv3_its_bind_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|gicv3_its_irqsrc
modifier|*
name|girq
decl_stmt|;
name|girq
operator|=
operator|(
expr|struct
name|gicv3_its_irqsrc
operator|*
operator|)
name|isrc
expr_stmt|;
if|if
condition|(
name|CPU_EMPTY
argument_list|(
operator|&
name|isrc
operator|->
name|isrc_cpu
argument_list|)
condition|)
block|{
name|gic_irq_cpu
operator|=
name|intr_irq_next_cpu
argument_list|(
name|gic_irq_cpu
argument_list|,
operator|&
name|all_cpus
argument_list|)
expr_stmt|;
name|CPU_SETOF
argument_list|(
name|gic_irq_cpu
argument_list|,
operator|&
name|isrc
operator|->
name|isrc_cpu
argument_list|)
expr_stmt|;
block|}
name|its_cmd_movi
argument_list|(
name|dev
argument_list|,
name|girq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gicv3_its_map_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_map_data
modifier|*
name|data
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
modifier|*
name|isrcp
parameter_list|)
block|{
comment|/* 	 * This should never happen, we only call this function to map 	 * interrupts found before the controller driver is ready. 	 */
name|panic
argument_list|(
literal|"gicv3_its_map_intr: Unable to map a MSI interrupt"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gicv3_its_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|,
name|struct
name|intr_map_data
modifier|*
name|data
parameter_list|)
block|{
comment|/* Bind the interrupt to a CPU */
name|gicv3_its_bind_intr
argument_list|(
name|dev
argument_list|,
name|isrc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SMP
end_ifdef

begin_function
specifier|static
name|void
name|gicv3_its_init_secondary
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|gicv3_its_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * This is fatal as otherwise we may bind interrupts to this CPU. 	 * We need a way to tell the interrupt framework to only bind to a 	 * subset of given CPUs when it performs the shuffle. 	 */
if|if
condition|(
name|its_init_cpu
argument_list|(
name|dev
argument_list|,
name|sc
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"gicv3_its_init_secondary: No usable ITS on CPU%d"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|uint32_t
name|its_get_devid
parameter_list|(
name|device_t
name|pci_dev
parameter_list|)
block|{
name|uintptr_t
name|id
decl_stmt|;
if|if
condition|(
name|pci_get_id
argument_list|(
name|pci_dev
argument_list|,
name|PCI_ID_MSI
argument_list|,
operator|&
name|id
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"its_get_devid: Unable to get the MSI DeviceID"
argument_list|)
expr_stmt|;
return|return
operator|(
name|id
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|its_dev
modifier|*
name|its_device_find
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|gicv3_its_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|its_dev
modifier|*
name|its_dev
init|=
name|NULL
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_its_dev_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|its_dev
argument_list|,
argument|&sc->sc_its_dev_list
argument_list|,
argument|entry
argument_list|)
block|{
if|if
condition|(
name|its_dev
operator|->
name|pci_dev
operator|==
name|child
condition|)
break|break;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_its_dev_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|its_dev
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|its_dev
modifier|*
name|its_device_get
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|u_int
name|nvecs
parameter_list|)
block|{
name|struct
name|gicv3_its_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|its_dev
modifier|*
name|its_dev
decl_stmt|;
name|vmem_addr_t
name|irq_base
decl_stmt|;
name|size_t
name|esize
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|its_dev
operator|=
name|its_device_find
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|its_dev
operator|!=
name|NULL
condition|)
return|return
operator|(
name|its_dev
operator|)
return|;
name|its_dev
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|its_dev
argument_list|)
argument_list|,
name|M_GICV3_ITS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|its_dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|its_dev
operator|->
name|pci_dev
operator|=
name|child
expr_stmt|;
name|its_dev
operator|->
name|devid
operator|=
name|its_get_devid
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_busy
operator|=
literal|0
expr_stmt|;
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_num
operator|=
name|nvecs
expr_stmt|;
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_free
operator|=
name|nvecs
expr_stmt|;
if|if
condition|(
name|vmem_alloc
argument_list|(
name|sc
operator|->
name|sc_irq_alloc
argument_list|,
name|nvecs
argument_list|,
name|M_FIRSTFIT
operator||
name|M_NOWAIT
argument_list|,
operator|&
name|irq_base
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|its_dev
argument_list|,
name|M_GICV3_ITS
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_base
operator|=
name|irq_base
expr_stmt|;
comment|/* Get ITT entry size */
name|esize
operator|=
name|GITS_TYPER_ITTES
argument_list|(
name|gic_its_read_8
argument_list|(
name|sc
argument_list|,
name|GITS_TYPER
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate ITT for this device. 	 * PA has to be 256 B aligned. At least two entries for device. 	 */
name|its_dev
operator|->
name|itt_size
operator|=
name|roundup2
argument_list|(
name|MAX
argument_list|(
name|nvecs
argument_list|,
literal|2
argument_list|)
operator|*
name|esize
argument_list|,
literal|256
argument_list|)
expr_stmt|;
name|its_dev
operator|->
name|itt
operator|=
operator|(
name|vm_offset_t
operator|)
name|contigmalloc
argument_list|(
name|its_dev
operator|->
name|itt_size
argument_list|,
name|M_GICV3_ITS
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|,
literal|0
argument_list|,
name|LPI_INT_TRANS_TAB_MAX_ADDR
argument_list|,
name|LPI_INT_TRANS_TAB_ALIGN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|its_dev
operator|->
name|itt
operator|==
literal|0
condition|)
block|{
name|vmem_free
argument_list|(
name|sc
operator|->
name|sc_irq_alloc
argument_list|,
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_base
argument_list|,
name|nvecs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|its_dev
argument_list|,
name|M_GICV3_ITS
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_its_dev_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|sc_its_dev_list
argument_list|,
name|its_dev
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_its_dev_lock
argument_list|)
expr_stmt|;
comment|/* Map device to its ITT */
name|its_cmd_mapd
argument_list|(
name|dev
argument_list|,
name|its_dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|its_dev
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|its_device_release
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|its_dev
modifier|*
name|its_dev
parameter_list|)
block|{
name|struct
name|gicv3_its_softc
modifier|*
name|sc
decl_stmt|;
name|KASSERT
argument_list|(
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_busy
operator|==
literal|0
argument_list|,
operator|(
literal|"its_device_release: Trying to release an inuse ITS device"
operator|)
argument_list|)
expr_stmt|;
comment|/* Unmap device in ITS */
name|its_cmd_mapd
argument_list|(
name|dev
argument_list|,
name|its_dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Remove the device from the list of devices */
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_its_dev_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sc
operator|->
name|sc_its_dev_list
argument_list|,
name|its_dev
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_its_dev_lock
argument_list|)
expr_stmt|;
comment|/* Free ITT */
name|KASSERT
argument_list|(
name|its_dev
operator|->
name|itt
operator|!=
literal|0
argument_list|,
operator|(
literal|"Invalid ITT in valid ITS device"
operator|)
argument_list|)
expr_stmt|;
name|contigfree
argument_list|(
operator|(
name|void
operator|*
operator|)
name|its_dev
operator|->
name|itt
argument_list|,
name|its_dev
operator|->
name|itt_size
argument_list|,
name|M_GICV3_ITS
argument_list|)
expr_stmt|;
comment|/* Free the IRQ allocation */
name|vmem_free
argument_list|(
name|sc
operator|->
name|sc_irq_alloc
argument_list|,
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_base
argument_list|,
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_num
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|its_dev
argument_list|,
name|M_GICV3_ITS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gicv3_its_alloc_msi
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|maxcount
parameter_list|,
name|device_t
modifier|*
name|pic
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
modifier|*
name|srcs
parameter_list|)
block|{
name|struct
name|gicv3_its_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|gicv3_its_irqsrc
modifier|*
name|girq
decl_stmt|;
name|struct
name|its_dev
modifier|*
name|its_dev
decl_stmt|;
name|u_int
name|irq
decl_stmt|;
name|int
name|i
decl_stmt|;
name|its_dev
operator|=
name|its_device_get
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|its_dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|KASSERT
argument_list|(
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_free
operator|>=
name|count
argument_list|,
operator|(
literal|"gicv3_its_alloc_msi: No free LPIs"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|irq
operator|=
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_base
operator|+
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_num
operator|-
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_free
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|irq
operator|++
control|)
block|{
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_free
operator|--
expr_stmt|;
name|girq
operator|=
operator|&
name|sc
operator|->
name|sc_irqs
index|[
name|irq
index|]
expr_stmt|;
name|girq
operator|->
name|gi_its_dev
operator|=
name|its_dev
expr_stmt|;
name|srcs
index|[
name|i
index|]
operator|=
operator|(
expr|struct
name|intr_irqsrc
operator|*
operator|)
name|girq
expr_stmt|;
block|}
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_busy
operator|+=
name|count
expr_stmt|;
operator|*
name|pic
operator|=
name|dev
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gicv3_its_release_msi
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|count
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|gicv3_its_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|gicv3_its_irqsrc
modifier|*
name|girq
decl_stmt|;
name|struct
name|its_dev
modifier|*
name|its_dev
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|its_dev
operator|=
name|its_device_find
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|its_dev
operator|!=
name|NULL
argument_list|,
operator|(
literal|"gicv3_its_release_msi: Releasing a MSI interrupt with "
literal|"no ITS device"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_busy
operator|>=
name|count
argument_list|,
operator|(
literal|"gicv3_its_release_msi: Releasing more interrupts than "
literal|"were allocated: releasing %d, allocated %d"
operator|,
name|count
operator|,
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_busy
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|girq
operator|=
operator|(
expr|struct
name|gicv3_its_irqsrc
operator|*
operator|)
name|isrc
index|[
name|i
index|]
expr_stmt|;
name|girq
operator|->
name|gi_its_dev
operator|=
name|NULL
expr_stmt|;
block|}
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_busy
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_busy
operator|==
literal|0
condition|)
name|its_device_release
argument_list|(
name|dev
argument_list|,
name|its_dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gicv3_its_alloc_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|device_t
modifier|*
name|pic
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
modifier|*
name|isrcp
parameter_list|)
block|{
name|struct
name|gicv3_its_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|gicv3_its_irqsrc
modifier|*
name|girq
decl_stmt|;
name|struct
name|its_dev
modifier|*
name|its_dev
decl_stmt|;
name|u_int
name|nvecs
decl_stmt|,
name|irq
decl_stmt|;
name|nvecs
operator|=
name|pci_msix_count
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|its_dev
operator|=
name|its_device_get
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|nvecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|its_dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|KASSERT
argument_list|(
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_free
operator|>
literal|0
argument_list|,
operator|(
literal|"gicv3_its_alloc_msix: No free LPIs"
operator|)
argument_list|)
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|irq
operator|=
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_base
operator|+
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_num
operator|-
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_free
expr_stmt|;
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_free
operator|--
expr_stmt|;
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_busy
operator|++
expr_stmt|;
name|girq
operator|=
operator|&
name|sc
operator|->
name|sc_irqs
index|[
name|irq
index|]
expr_stmt|;
name|girq
operator|->
name|gi_its_dev
operator|=
name|its_dev
expr_stmt|;
operator|*
name|pic
operator|=
name|dev
expr_stmt|;
operator|*
name|isrcp
operator|=
operator|(
expr|struct
name|intr_irqsrc
operator|*
operator|)
name|girq
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gicv3_its_release_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|)
block|{
name|struct
name|gicv3_its_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|gicv3_its_irqsrc
modifier|*
name|girq
decl_stmt|;
name|struct
name|its_dev
modifier|*
name|its_dev
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|its_dev
operator|=
name|its_device_find
argument_list|(
name|dev
argument_list|,
name|child
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|its_dev
operator|!=
name|NULL
argument_list|,
operator|(
literal|"gicv3_its_release_msix: Releasing a MSI-X interrupt with "
literal|"no ITS device"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_busy
operator|>
literal|0
argument_list|,
operator|(
literal|"gicv3_its_release_msix: Releasing more interrupts than "
literal|"were allocated: allocated %d"
operator|,
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_busy
operator|)
argument_list|)
expr_stmt|;
name|girq
operator|=
operator|(
expr|struct
name|gicv3_its_irqsrc
operator|*
operator|)
name|isrc
expr_stmt|;
name|girq
operator|->
name|gi_its_dev
operator|=
name|NULL
expr_stmt|;
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_busy
operator|--
expr_stmt|;
if|if
condition|(
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_busy
operator|==
literal|0
condition|)
name|its_device_release
argument_list|(
name|dev
argument_list|,
name|its_dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gicv3_its_map_msi
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|intr_irqsrc
modifier|*
name|isrc
parameter_list|,
name|uint64_t
modifier|*
name|addr
parameter_list|,
name|uint32_t
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|gicv3_its_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|gicv3_its_irqsrc
modifier|*
name|girq
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|girq
operator|=
operator|(
expr|struct
name|gicv3_its_irqsrc
operator|*
operator|)
name|isrc
expr_stmt|;
comment|/* Map the message to the given IRQ */
name|its_cmd_mapti
argument_list|(
name|dev
argument_list|,
name|girq
argument_list|)
expr_stmt|;
operator|*
name|addr
operator|=
name|vtophys
argument_list|(
name|rman_get_virtual
argument_list|(
name|sc
operator|->
name|sc_its_res
argument_list|)
argument_list|)
operator|+
name|GITS_TRANSLATER
expr_stmt|;
operator|*
name|data
operator|=
name|girq
operator|->
name|gi_irq
operator|-
name|girq
operator|->
name|gi_its_dev
operator|->
name|lpis
operator|.
name|lpi_base
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Commands handling.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|cmd_format_command
parameter_list|(
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|,
name|uint8_t
name|cmd_type
parameter_list|)
block|{
comment|/* Command field: DW0 [7:0] */
name|cmd
operator|->
name|cmd_dword
index|[
literal|0
index|]
operator|&=
name|htole64
argument_list|(
operator|~
name|CMD_COMMAND_MASK
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|cmd_dword
index|[
literal|0
index|]
operator||=
name|htole64
argument_list|(
name|cmd_type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|cmd_format_devid
parameter_list|(
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|,
name|uint32_t
name|devid
parameter_list|)
block|{
comment|/* Device ID field: DW0 [63:32] */
name|cmd
operator|->
name|cmd_dword
index|[
literal|0
index|]
operator|&=
name|htole64
argument_list|(
operator|~
name|CMD_DEVID_MASK
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|cmd_dword
index|[
literal|0
index|]
operator||=
name|htole64
argument_list|(
operator|(
name|uint64_t
operator|)
name|devid
operator|<<
name|CMD_DEVID_SHIFT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|cmd_format_size
parameter_list|(
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|,
name|uint16_t
name|size
parameter_list|)
block|{
comment|/* Size field: DW1 [4:0] */
name|cmd
operator|->
name|cmd_dword
index|[
literal|1
index|]
operator|&=
name|htole64
argument_list|(
operator|~
name|CMD_SIZE_MASK
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|cmd_dword
index|[
literal|1
index|]
operator||=
name|htole64
argument_list|(
operator|(
name|size
operator|&
name|CMD_SIZE_MASK
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|cmd_format_id
parameter_list|(
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|,
name|uint32_t
name|id
parameter_list|)
block|{
comment|/* ID field: DW1 [31:0] */
name|cmd
operator|->
name|cmd_dword
index|[
literal|1
index|]
operator|&=
name|htole64
argument_list|(
operator|~
name|CMD_ID_MASK
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|cmd_dword
index|[
literal|1
index|]
operator||=
name|htole64
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|cmd_format_pid
parameter_list|(
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|,
name|uint32_t
name|pid
parameter_list|)
block|{
comment|/* Physical ID field: DW1 [63:32] */
name|cmd
operator|->
name|cmd_dword
index|[
literal|1
index|]
operator|&=
name|htole64
argument_list|(
operator|~
name|CMD_PID_MASK
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|cmd_dword
index|[
literal|1
index|]
operator||=
name|htole64
argument_list|(
operator|(
name|uint64_t
operator|)
name|pid
operator|<<
name|CMD_PID_SHIFT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|cmd_format_col
parameter_list|(
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|,
name|uint16_t
name|col_id
parameter_list|)
block|{
comment|/* Collection field: DW2 [16:0] */
name|cmd
operator|->
name|cmd_dword
index|[
literal|2
index|]
operator|&=
name|htole64
argument_list|(
operator|~
name|CMD_COL_MASK
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|cmd_dword
index|[
literal|2
index|]
operator||=
name|htole64
argument_list|(
name|col_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|cmd_format_target
parameter_list|(
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|,
name|uint64_t
name|target
parameter_list|)
block|{
comment|/* Target Address field: DW2 [47:16] */
name|cmd
operator|->
name|cmd_dword
index|[
literal|2
index|]
operator|&=
name|htole64
argument_list|(
operator|~
name|CMD_TARGET_MASK
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|cmd_dword
index|[
literal|2
index|]
operator||=
name|htole64
argument_list|(
name|target
operator|&
name|CMD_TARGET_MASK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|cmd_format_itt
parameter_list|(
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|,
name|uint64_t
name|itt
parameter_list|)
block|{
comment|/* ITT Address field: DW2 [47:8] */
name|cmd
operator|->
name|cmd_dword
index|[
literal|2
index|]
operator|&=
name|htole64
argument_list|(
operator|~
name|CMD_ITT_MASK
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|cmd_dword
index|[
literal|2
index|]
operator||=
name|htole64
argument_list|(
name|itt
operator|&
name|CMD_ITT_MASK
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|cmd_format_valid
parameter_list|(
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|,
name|uint8_t
name|valid
parameter_list|)
block|{
comment|/* Valid field: DW2 [63] */
name|cmd
operator|->
name|cmd_dword
index|[
literal|2
index|]
operator|&=
name|htole64
argument_list|(
operator|~
name|CMD_VALID_MASK
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|cmd_dword
index|[
literal|2
index|]
operator||=
name|htole64
argument_list|(
operator|(
name|uint64_t
operator|)
name|valid
operator|<<
name|CMD_VALID_SHIFT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|its_cmd_queue_full
parameter_list|(
name|struct
name|gicv3_its_softc
modifier|*
name|sc
parameter_list|)
block|{
name|size_t
name|read_idx
decl_stmt|,
name|next_write_idx
decl_stmt|;
comment|/* Get the index of the next command */
name|next_write_idx
operator|=
operator|(
name|sc
operator|->
name|sc_its_cmd_next_idx
operator|+
literal|1
operator|)
operator|%
operator|(
name|ITS_CMDQ_SIZE
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|its_cmd
argument_list|)
operator|)
expr_stmt|;
comment|/* And the index of the current command being read */
name|read_idx
operator|=
name|gic_its_read_4
argument_list|(
name|sc
argument_list|,
name|GITS_CREADR
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|its_cmd
argument_list|)
expr_stmt|;
comment|/* 	 * The queue is full when the write offset points 	 * at the command before the current read offset. 	 */
return|return
operator|(
name|next_write_idx
operator|==
name|read_idx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|its_cmd_sync
parameter_list|(
name|struct
name|gicv3_its_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_its_flags
operator|&
name|ITS_FLAGS_CMDQ_FLUSH
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Clean D-cache under command. */
name|cpu_dcache_wb_range
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* DSB inner shareable, store */
name|dsb
argument_list|(
name|ishst
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|its_cmd_cwriter_offset
parameter_list|(
name|struct
name|gicv3_its_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|uint64_t
name|off
decl_stmt|;
name|off
operator|=
operator|(
name|cmd
operator|-
name|sc
operator|->
name|sc_its_cmd_base
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
name|off
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|its_cmd_wait_completion
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|its_cmd
modifier|*
name|cmd_first
parameter_list|,
name|struct
name|its_cmd
modifier|*
name|cmd_last
parameter_list|)
block|{
name|struct
name|gicv3_its_softc
modifier|*
name|sc
decl_stmt|;
name|uint64_t
name|first
decl_stmt|,
name|last
decl_stmt|,
name|read
decl_stmt|;
name|size_t
name|us_left
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * XXX ARM64TODO: This is obviously a significant delay. 	 * The reason for that is that currently the time frames for 	 * the command to complete are not known. 	 */
name|us_left
operator|=
literal|1000000
expr_stmt|;
name|first
operator|=
name|its_cmd_cwriter_offset
argument_list|(
name|sc
argument_list|,
name|cmd_first
argument_list|)
expr_stmt|;
name|last
operator|=
name|its_cmd_cwriter_offset
argument_list|(
name|sc
argument_list|,
name|cmd_last
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|read
operator|=
name|gic_its_read_8
argument_list|(
name|sc
argument_list|,
name|GITS_CREADR
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|<
name|last
condition|)
block|{
if|if
condition|(
name|read
operator|<
name|first
operator|||
name|read
operator|>=
name|last
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|read
operator|<
name|first
operator|&&
name|read
operator|>=
name|last
condition|)
break|break;
if|if
condition|(
name|us_left
operator|--
operator|==
literal|0
condition|)
block|{
comment|/* This means timeout */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Timeout while waiting for CMD completion.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|its_cmd
modifier|*
name|its_cmd_alloc_locked
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|gicv3_its_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|its_cmd
modifier|*
name|cmd
decl_stmt|;
name|size_t
name|us_left
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * XXX ARM64TODO: This is obviously a significant delay. 	 * The reason for that is that currently the time frames for 	 * the command to complete (and therefore free the descriptor) 	 * are not known. 	 */
name|us_left
operator|=
literal|1000000
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|sc_its_cmd_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
while|while
condition|(
name|its_cmd_queue_full
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|us_left
operator|--
operator|==
literal|0
condition|)
block|{
comment|/* Timeout while waiting for free command */
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Timeout while waiting for free command\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|=
operator|&
name|sc
operator|->
name|sc_its_cmd_base
index|[
name|sc
operator|->
name|sc_its_cmd_next_idx
index|]
expr_stmt|;
name|sc
operator|->
name|sc_its_cmd_next_idx
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_its_cmd_next_idx
operator|%=
name|ITS_CMDQ_SIZE
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|its_cmd
argument_list|)
expr_stmt|;
return|return
operator|(
name|cmd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|its_cmd_prepare
parameter_list|(
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|,
name|struct
name|its_cmd_desc
modifier|*
name|desc
parameter_list|)
block|{
name|uint64_t
name|target
decl_stmt|;
name|uint8_t
name|cmd_type
decl_stmt|;
name|u_int
name|size
decl_stmt|;
name|boolean_t
name|error
decl_stmt|;
name|error
operator|=
name|FALSE
expr_stmt|;
name|cmd_type
operator|=
name|desc
operator|->
name|cmd_type
expr_stmt|;
name|target
operator|=
name|ITS_TARGET_NONE
expr_stmt|;
switch|switch
condition|(
name|cmd_type
condition|)
block|{
case|case
name|ITS_CMD_MOVI
case|:
comment|/* Move interrupt ID to another collection */
name|target
operator|=
name|desc
operator|->
name|cmd_desc_movi
operator|.
name|col
operator|->
name|col_target
expr_stmt|;
name|cmd_format_command
argument_list|(
name|cmd
argument_list|,
name|ITS_CMD_MOVI
argument_list|)
expr_stmt|;
name|cmd_format_id
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_movi
operator|.
name|id
argument_list|)
expr_stmt|;
name|cmd_format_col
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_movi
operator|.
name|col
operator|->
name|col_id
argument_list|)
expr_stmt|;
name|cmd_format_devid
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_movi
operator|.
name|its_dev
operator|->
name|devid
argument_list|)
expr_stmt|;
break|break;
case|case
name|ITS_CMD_SYNC
case|:
comment|/* Wait for previous commands completion */
name|target
operator|=
name|desc
operator|->
name|cmd_desc_sync
operator|.
name|col
operator|->
name|col_target
expr_stmt|;
name|cmd_format_command
argument_list|(
name|cmd
argument_list|,
name|ITS_CMD_SYNC
argument_list|)
expr_stmt|;
name|cmd_format_target
argument_list|(
name|cmd
argument_list|,
name|target
argument_list|)
expr_stmt|;
break|break;
case|case
name|ITS_CMD_MAPD
case|:
comment|/* Assign ITT to device */
name|cmd_format_command
argument_list|(
name|cmd
argument_list|,
name|ITS_CMD_MAPD
argument_list|)
expr_stmt|;
name|cmd_format_itt
argument_list|(
name|cmd
argument_list|,
name|vtophys
argument_list|(
name|desc
operator|->
name|cmd_desc_mapd
operator|.
name|its_dev
operator|->
name|itt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Size describes number of bits to encode interrupt IDs 		 * supported by the device minus one. 		 * When V (valid) bit is zero, this field should be written 		 * as zero. 		 */
if|if
condition|(
name|desc
operator|->
name|cmd_desc_mapd
operator|.
name|valid
operator|!=
literal|0
condition|)
block|{
name|size
operator|=
name|fls
argument_list|(
name|desc
operator|->
name|cmd_desc_mapd
operator|.
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_num
argument_list|)
expr_stmt|;
name|size
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|size
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|size
operator|=
literal|0
expr_stmt|;
name|cmd_format_size
argument_list|(
name|cmd
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|cmd_format_devid
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_mapd
operator|.
name|its_dev
operator|->
name|devid
argument_list|)
expr_stmt|;
name|cmd_format_valid
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_mapd
operator|.
name|valid
argument_list|)
expr_stmt|;
break|break;
case|case
name|ITS_CMD_MAPC
case|:
comment|/* Map collection to Re-Distributor */
name|target
operator|=
name|desc
operator|->
name|cmd_desc_mapc
operator|.
name|col
operator|->
name|col_target
expr_stmt|;
name|cmd_format_command
argument_list|(
name|cmd
argument_list|,
name|ITS_CMD_MAPC
argument_list|)
expr_stmt|;
name|cmd_format_col
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_mapc
operator|.
name|col
operator|->
name|col_id
argument_list|)
expr_stmt|;
name|cmd_format_valid
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_mapc
operator|.
name|valid
argument_list|)
expr_stmt|;
name|cmd_format_target
argument_list|(
name|cmd
argument_list|,
name|target
argument_list|)
expr_stmt|;
break|break;
case|case
name|ITS_CMD_MAPTI
case|:
name|target
operator|=
name|desc
operator|->
name|cmd_desc_mapvi
operator|.
name|col
operator|->
name|col_target
expr_stmt|;
name|cmd_format_command
argument_list|(
name|cmd
argument_list|,
name|ITS_CMD_MAPTI
argument_list|)
expr_stmt|;
name|cmd_format_devid
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_mapvi
operator|.
name|its_dev
operator|->
name|devid
argument_list|)
expr_stmt|;
name|cmd_format_id
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_mapvi
operator|.
name|id
argument_list|)
expr_stmt|;
name|cmd_format_pid
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_mapvi
operator|.
name|pid
argument_list|)
expr_stmt|;
name|cmd_format_col
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_mapvi
operator|.
name|col
operator|->
name|col_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|ITS_CMD_MAPI
case|:
name|target
operator|=
name|desc
operator|->
name|cmd_desc_mapi
operator|.
name|col
operator|->
name|col_target
expr_stmt|;
name|cmd_format_command
argument_list|(
name|cmd
argument_list|,
name|ITS_CMD_MAPI
argument_list|)
expr_stmt|;
name|cmd_format_devid
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_mapi
operator|.
name|its_dev
operator|->
name|devid
argument_list|)
expr_stmt|;
name|cmd_format_id
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_mapi
operator|.
name|pid
argument_list|)
expr_stmt|;
name|cmd_format_col
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_mapi
operator|.
name|col
operator|->
name|col_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|ITS_CMD_INV
case|:
name|target
operator|=
name|desc
operator|->
name|cmd_desc_inv
operator|.
name|col
operator|->
name|col_target
expr_stmt|;
name|cmd_format_command
argument_list|(
name|cmd
argument_list|,
name|ITS_CMD_INV
argument_list|)
expr_stmt|;
name|cmd_format_devid
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_inv
operator|.
name|its_dev
operator|->
name|devid
argument_list|)
expr_stmt|;
name|cmd_format_id
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_inv
operator|.
name|pid
argument_list|)
expr_stmt|;
break|break;
case|case
name|ITS_CMD_INVALL
case|:
name|cmd_format_command
argument_list|(
name|cmd
argument_list|,
name|ITS_CMD_INVALL
argument_list|)
expr_stmt|;
name|cmd_format_col
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_invall
operator|.
name|col
operator|->
name|col_id
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"its_cmd_prepare: Invalid command: %x"
argument_list|,
name|cmd_type
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|target
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|its_cmd_send
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|its_cmd_desc
modifier|*
name|desc
parameter_list|)
block|{
name|struct
name|gicv3_its_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|its_cmd
modifier|*
name|cmd
decl_stmt|,
modifier|*
name|cmd_sync
decl_stmt|,
modifier|*
name|cmd_write
decl_stmt|;
name|struct
name|its_col
name|col_sync
decl_stmt|;
name|struct
name|its_cmd_desc
name|desc_sync
decl_stmt|;
name|uint64_t
name|target
decl_stmt|,
name|cwriter
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_its_cmd_lock
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|its_cmd_alloc_locked
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not allocate ITS command\n"
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_its_cmd_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|target
operator|=
name|its_cmd_prepare
argument_list|(
name|cmd
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|its_cmd_sync
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|ITS_TARGET_NONE
condition|)
block|{
name|cmd_sync
operator|=
name|its_cmd_alloc_locked
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd_sync
operator|!=
name|NULL
condition|)
block|{
name|desc_sync
operator|.
name|cmd_type
operator|=
name|ITS_CMD_SYNC
expr_stmt|;
name|col_sync
operator|.
name|col_target
operator|=
name|target
expr_stmt|;
name|desc_sync
operator|.
name|cmd_desc_sync
operator|.
name|col
operator|=
operator|&
name|col_sync
expr_stmt|;
name|its_cmd_prepare
argument_list|(
name|cmd_sync
argument_list|,
operator|&
name|desc_sync
argument_list|)
expr_stmt|;
name|its_cmd_sync
argument_list|(
name|sc
argument_list|,
name|cmd_sync
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Update GITS_CWRITER */
name|cwriter
operator|=
name|sc
operator|->
name|sc_its_cmd_next_idx
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|its_cmd
argument_list|)
expr_stmt|;
name|gic_its_write_8
argument_list|(
name|sc
argument_list|,
name|GITS_CWRITER
argument_list|,
name|cwriter
argument_list|)
expr_stmt|;
name|cmd_write
operator|=
operator|&
name|sc
operator|->
name|sc_its_cmd_base
index|[
name|sc
operator|->
name|sc_its_cmd_next_idx
index|]
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_its_cmd_lock
argument_list|)
expr_stmt|;
name|its_cmd_wait_completion
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|cmd_write
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Handlers to send commands */
end_comment

begin_function
specifier|static
name|void
name|its_cmd_movi
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|gicv3_its_irqsrc
modifier|*
name|girq
parameter_list|)
block|{
name|struct
name|gicv3_its_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|its_cmd_desc
name|desc
decl_stmt|;
name|struct
name|its_col
modifier|*
name|col
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|col
operator|=
name|sc
operator|->
name|sc_its_cols
index|[
name|CPU_FFS
argument_list|(
operator|&
name|girq
operator|->
name|gi_isrc
operator|.
name|isrc_cpu
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|desc
operator|.
name|cmd_type
operator|=
name|ITS_CMD_MOVI
expr_stmt|;
name|desc
operator|.
name|cmd_desc_movi
operator|.
name|its_dev
operator|=
name|girq
operator|->
name|gi_its_dev
expr_stmt|;
name|desc
operator|.
name|cmd_desc_movi
operator|.
name|col
operator|=
name|col
expr_stmt|;
name|desc
operator|.
name|cmd_desc_movi
operator|.
name|id
operator|=
name|girq
operator|->
name|gi_irq
operator|-
name|girq
operator|->
name|gi_its_dev
operator|->
name|lpis
operator|.
name|lpi_base
expr_stmt|;
name|its_cmd_send
argument_list|(
name|dev
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|its_cmd_mapc
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|its_col
modifier|*
name|col
parameter_list|,
name|uint8_t
name|valid
parameter_list|)
block|{
name|struct
name|its_cmd_desc
name|desc
decl_stmt|;
name|desc
operator|.
name|cmd_type
operator|=
name|ITS_CMD_MAPC
expr_stmt|;
name|desc
operator|.
name|cmd_desc_mapc
operator|.
name|col
operator|=
name|col
expr_stmt|;
comment|/* 	 * Valid bit set - map the collection. 	 * Valid bit cleared - unmap the collection. 	 */
name|desc
operator|.
name|cmd_desc_mapc
operator|.
name|valid
operator|=
name|valid
expr_stmt|;
name|its_cmd_send
argument_list|(
name|dev
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|its_cmd_mapti
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|gicv3_its_irqsrc
modifier|*
name|girq
parameter_list|)
block|{
name|struct
name|gicv3_its_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|its_cmd_desc
name|desc
decl_stmt|;
name|struct
name|its_col
modifier|*
name|col
decl_stmt|;
name|u_int
name|col_id
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|col_id
operator|=
name|CPU_FFS
argument_list|(
operator|&
name|girq
operator|->
name|gi_isrc
operator|.
name|isrc_cpu
argument_list|)
operator|-
literal|1
expr_stmt|;
name|col
operator|=
name|sc
operator|->
name|sc_its_cols
index|[
name|col_id
index|]
expr_stmt|;
name|desc
operator|.
name|cmd_type
operator|=
name|ITS_CMD_MAPTI
expr_stmt|;
name|desc
operator|.
name|cmd_desc_mapvi
operator|.
name|its_dev
operator|=
name|girq
operator|->
name|gi_its_dev
expr_stmt|;
name|desc
operator|.
name|cmd_desc_mapvi
operator|.
name|col
operator|=
name|col
expr_stmt|;
comment|/* The EventID sent to the device */
name|desc
operator|.
name|cmd_desc_mapvi
operator|.
name|id
operator|=
name|girq
operator|->
name|gi_irq
operator|-
name|girq
operator|->
name|gi_its_dev
operator|->
name|lpis
operator|.
name|lpi_base
expr_stmt|;
comment|/* The physical interrupt presented to softeware */
name|desc
operator|.
name|cmd_desc_mapvi
operator|.
name|pid
operator|=
name|girq
operator|->
name|gi_irq
operator|+
name|GIC_FIRST_LPI
expr_stmt|;
name|its_cmd_send
argument_list|(
name|dev
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|its_cmd_mapd
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|its_dev
modifier|*
name|its_dev
parameter_list|,
name|uint8_t
name|valid
parameter_list|)
block|{
name|struct
name|its_cmd_desc
name|desc
decl_stmt|;
name|desc
operator|.
name|cmd_type
operator|=
name|ITS_CMD_MAPD
expr_stmt|;
name|desc
operator|.
name|cmd_desc_mapd
operator|.
name|its_dev
operator|=
name|its_dev
expr_stmt|;
name|desc
operator|.
name|cmd_desc_mapd
operator|.
name|valid
operator|=
name|valid
expr_stmt|;
name|its_cmd_send
argument_list|(
name|dev
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|its_cmd_inv
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|its_dev
modifier|*
name|its_dev
parameter_list|,
name|struct
name|gicv3_its_irqsrc
modifier|*
name|girq
parameter_list|)
block|{
name|struct
name|gicv3_its_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|its_cmd_desc
name|desc
decl_stmt|;
name|struct
name|its_col
modifier|*
name|col
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|col
operator|=
name|sc
operator|->
name|sc_its_cols
index|[
name|CPU_FFS
argument_list|(
operator|&
name|girq
operator|->
name|gi_isrc
operator|.
name|isrc_cpu
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
name|desc
operator|.
name|cmd_type
operator|=
name|ITS_CMD_INV
expr_stmt|;
comment|/* The EventID sent to the device */
name|desc
operator|.
name|cmd_desc_inv
operator|.
name|pid
operator|=
name|girq
operator|->
name|gi_irq
operator|-
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_base
expr_stmt|;
name|desc
operator|.
name|cmd_desc_inv
operator|.
name|its_dev
operator|=
name|its_dev
expr_stmt|;
name|desc
operator|.
name|cmd_desc_inv
operator|.
name|col
operator|=
name|col
expr_stmt|;
name|its_cmd_send
argument_list|(
name|dev
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|its_cmd_invall
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|its_col
modifier|*
name|col
parameter_list|)
block|{
name|struct
name|its_cmd_desc
name|desc
decl_stmt|;
name|desc
operator|.
name|cmd_type
operator|=
name|ITS_CMD_INVALL
expr_stmt|;
name|desc
operator|.
name|cmd_desc_invall
operator|.
name|col
operator|=
name|col
expr_stmt|;
name|its_cmd_send
argument_list|(
name|dev
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FDT
end_ifdef

begin_decl_stmt
specifier|static
name|device_probe_t
name|gicv3_its_fdt_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_attach_t
name|gicv3_its_fdt_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|gicv3_its_fdt_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|gicv3_its_fdt_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|gicv3_its_fdt_attach
argument_list|)
block|,
comment|/* End */
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|its_baseclasses
value|its_fdt_baseclasses
end_define

begin_expr_stmt
name|DEFINE_CLASS_1
argument_list|(
name|its
argument_list|,
name|gicv3_its_fdt_driver
argument_list|,
name|gicv3_its_fdt_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|gicv3_its_softc
argument_list|)
argument_list|,
name|gicv3_its_driver
argument_list|)
expr_stmt|;
end_expr_stmt

begin_undef
undef|#
directive|undef
name|its_baseclasses
end_undef

begin_decl_stmt
specifier|static
name|devclass_t
name|gicv3_its_fdt_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|EARLY_DRIVER_MODULE
argument_list|(
name|its
argument_list|,
name|gic
argument_list|,
name|gicv3_its_fdt_driver
argument_list|,
name|gicv3_its_fdt_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_PASS_INTERRUPT
operator|+
name|BUS_PASS_ORDER_MIDDLE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|gicv3_its_fdt_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ofw_bus_status_okay
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
name|ofw_bus_is_compatible
argument_list|(
name|dev
argument_list|,
literal|"arm,gic-v3-its"
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"ARM GIC Interrupt Translation Service"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gicv3_its_fdt_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|gicv3_its_softc
modifier|*
name|sc
decl_stmt|;
name|phandle_t
name|xref
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|gicv3_its_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Register this device as a interrupt controller */
name|xref
operator|=
name|OF_xref_from_node
argument_list|(
name|ofw_bus_get_node
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_pic
operator|=
name|intr_pic_register
argument_list|(
name|dev
argument_list|,
name|xref
argument_list|)
expr_stmt|;
name|intr_pic_add_handler
argument_list|(
name|device_get_parent
argument_list|(
name|dev
argument_list|)
argument_list|,
name|sc
operator|->
name|sc_pic
argument_list|,
name|gicv3_its_intr
argument_list|,
name|sc
argument_list|,
name|GIC_FIRST_LPI
argument_list|,
name|LPI_NIRQS
argument_list|)
expr_stmt|;
comment|/* Register this device to handle MSI interrupts */
name|intr_msi_register
argument_list|(
name|dev
argument_list|,
name|xref
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

