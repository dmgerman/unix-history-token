begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991 Regents of the University of California.  * All rights reserved.  * Copyright (c) 1994 John S. Dyson  * All rights reserved.  * Copyright (c) 1994 David Greenman  * All rights reserved.  * Copyright (c) 2003 Peter Wemm  * All rights reserved.  * Copyright (c) 2005-2010 Alan L. Cox<alc@cs.rice.edu>  * All rights reserved.  * Copyright (c) 2014 Andrew Turner  * All rights reserved.  * Copyright (c) 2014-2016 The FreeBSD Foundation  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department and William Jolitz of UUNET Technologies Inc.  *  * This software was developed by Andrew Turner under sponsorship from  * the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from:	@(#)pmap.c	7.7 (Berkeley)	5/12/91  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2003 Networks Associates Technology, Inc.  * All rights reserved.  *  * This software was developed for the FreeBSD Project by Jake Burkholder,  * Safeport Network Services, and Network Associates Laboratories, the  * Security Research Division of Network Associates, Inc. under  * DARPA/SPAWAR contract N66001-01-C-8035 ("CBOSS"), as part of the DARPA  * CHATS research program.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  *	Manages physical address maps.  *  *	Since the information managed by this module is  *	also stored by the logical address mapping module,  *	this module may throw away valid virtual-to-physical  *	mappings at almost any time.  However, invalidations  *	of virtual-to-physical mappings must be done as  *	requested.  *  *	In order to cope with hardware architectures which  *	make virtual-to-physical map invalidates expensive,  *	this module may delay invalidate or reduced protection  *	operations until such time as they are actually  *	necessary.  This module is given full information as  *	to which processors are currently using which maps,  *	and to when physical maps must be made correct.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bitstring.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/msgbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/_unrhdr.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_phys.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_radix.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_reserv.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<machine/machdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_define
define|#
directive|define
name|NL0PG
value|(PAGE_SIZE/(sizeof (pd_entry_t)))
end_define

begin_define
define|#
directive|define
name|NL1PG
value|(PAGE_SIZE/(sizeof (pd_entry_t)))
end_define

begin_define
define|#
directive|define
name|NL2PG
value|(PAGE_SIZE/(sizeof (pd_entry_t)))
end_define

begin_define
define|#
directive|define
name|NL3PG
value|(PAGE_SIZE/(sizeof (pt_entry_t)))
end_define

begin_define
define|#
directive|define
name|NUL0E
value|L0_ENTRIES
end_define

begin_define
define|#
directive|define
name|NUL1E
value|(NUL0E * NL1PG)
end_define

begin_define
define|#
directive|define
name|NUL2E
value|(NUL1E * NL2PG)
end_define

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DIAGNOSTIC
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC_GNU_INLINE__
end_ifdef

begin_define
define|#
directive|define
name|PMAP_INLINE
value|__attribute__((__gnu_inline__)) inline
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PMAP_INLINE
value|extern inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PMAP_INLINE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * These are configured by the mair_el1 register. This is set up in locore.S  */
end_comment

begin_define
define|#
directive|define
name|DEVICE_MEMORY
value|0
end_define

begin_define
define|#
directive|define
name|UNCACHED_MEMORY
value|1
end_define

begin_define
define|#
directive|define
name|CACHED_MEMORY
value|2
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PV_STATS
end_ifdef

begin_define
define|#
directive|define
name|PV_STAT
parameter_list|(
name|x
parameter_list|)
value|do { x ; } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PV_STAT
parameter_list|(
name|x
parameter_list|)
value|do { } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|pmap_l2_pindex
parameter_list|(
name|v
parameter_list|)
value|((v)>> L2_SHIFT)
end_define

begin_define
define|#
directive|define
name|pa_to_pvh
parameter_list|(
name|pa
parameter_list|)
value|(&pv_table[pmap_l2_pindex(pa)])
end_define

begin_define
define|#
directive|define
name|NPV_LIST_LOCKS
value|MAXCPU
end_define

begin_define
define|#
directive|define
name|PHYS_TO_PV_LIST_LOCK
parameter_list|(
name|pa
parameter_list|)
define|\
value|(&pv_list_locks[pa_index(pa) % NPV_LIST_LOCKS])
end_define

begin_define
define|#
directive|define
name|CHANGE_PV_LIST_LOCK_TO_PHYS
parameter_list|(
name|lockp
parameter_list|,
name|pa
parameter_list|)
value|do {	\ 	struct rwlock **_lockp = (lockp);		\ 	struct rwlock *_new_lock;			\ 							\ 	_new_lock = PHYS_TO_PV_LIST_LOCK(pa);		\ 	if (_new_lock != *_lockp) {			\ 		if (*_lockp != NULL)			\ 			rw_wunlock(*_lockp);		\ 		*_lockp = _new_lock;			\ 		rw_wlock(*_lockp);			\ 	}						\ } while (0)
end_define

begin_define
define|#
directive|define
name|CHANGE_PV_LIST_LOCK_TO_VM_PAGE
parameter_list|(
name|lockp
parameter_list|,
name|m
parameter_list|)
define|\
value|CHANGE_PV_LIST_LOCK_TO_PHYS(lockp, VM_PAGE_TO_PHYS(m))
end_define

begin_define
define|#
directive|define
name|RELEASE_PV_LIST_LOCK
parameter_list|(
name|lockp
parameter_list|)
value|do {	\ 	struct rwlock **_lockp = (lockp);		\ 							\ 	if (*_lockp != NULL) {				\ 		rw_wunlock(*_lockp);			\ 		*_lockp = NULL;				\ 	}						\ } while (0)
end_define

begin_define
define|#
directive|define
name|VM_PAGE_TO_PV_LIST_LOCK
parameter_list|(
name|m
parameter_list|)
define|\
value|PHYS_TO_PV_LIST_LOCK(VM_PAGE_TO_PHYS(m))
end_define

begin_decl_stmt
name|struct
name|pmap
name|kernel_pmap_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|virtual_avail
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of first avail page (after kernel bss) */
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VA of last avail page (end of kernel AS) */
end_comment

begin_decl_stmt
name|vm_offset_t
name|kernel_vm_end
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|msgbuf
modifier|*
name|msgbufp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Data for the pv entry allocation mechanism.  * Updates to pv_invl_gen are protected by the pv_list_locks[]  * elements, but reads are not.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|md_page
modifier|*
name|pv_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|md_page
name|pv_dummy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_paddr_t
name|dmap_phys_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The start of the dmap region */
end_comment

begin_decl_stmt
name|vm_paddr_t
name|dmap_phys_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The limit of the dmap region */
end_comment

begin_decl_stmt
name|vm_offset_t
name|dmap_max_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The virtual address limit of the dmap */
end_comment

begin_comment
comment|/* This code assumes all L1 DMAP entries will be used */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
operator|(
name|DMAP_MIN_ADDRESS
operator|&
operator|~
name|L0_OFFSET
operator|)
operator|==
name|DMAP_MIN_ADDRESS
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
operator|(
name|DMAP_MAX_ADDRESS
operator|&
operator|~
name|L0_OFFSET
operator|)
operator|==
name|DMAP_MAX_ADDRESS
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|DMAP_TABLES
value|((DMAP_MAX_ADDRESS - DMAP_MIN_ADDRESS)>> L0_SHIFT)
end_define

begin_decl_stmt
specifier|extern
name|pt_entry_t
name|pagetable_dmap
index|[]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|pmap
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"VM/pmap parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|superpages_enabled
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|superpages_enabled
argument_list|,
name|CTLFLAG_RDTUN
operator||
name|CTLFLAG_NOFETCH
argument_list|,
operator|&
name|superpages_enabled
argument_list|,
literal|0
argument_list|,
literal|"Are large page mappings enabled?"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Data for the pv entry allocation mechanism  */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument|pch
argument_list|,
argument|pv_chunk
argument_list|)
name|pv_chunks
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|pv_chunks
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|pv_chunks_mutex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rwlock
name|pv_list_locks
index|[
name|NPV_LIST_LOCKS
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|free_pv_chunk
parameter_list|(
name|struct
name|pv_chunk
modifier|*
name|pc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pv_entry_t
name|pv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pv_entry_t
name|get_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|struct
name|rwlock
modifier|*
modifier|*
name|lockp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_page_t
name|reclaim_pv_chunk
parameter_list|(
name|pmap_t
name|locked_pmap
parameter_list|,
name|struct
name|rwlock
modifier|*
modifier|*
name|lockp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_pvh_free
parameter_list|(
name|struct
name|md_page
modifier|*
name|pvh
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pv_entry_t
name|pmap_pvh_remove
parameter_list|(
name|struct
name|md_page
modifier|*
name|pvh
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmap_change_attr
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmap_change_attr_locked
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pt_entry_t
modifier|*
name|pmap_demote_l1
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pt_entry_t
modifier|*
name|l1
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pt_entry_t
modifier|*
name|pmap_demote_l2_locked
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pt_entry_t
modifier|*
name|l2
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|struct
name|rwlock
modifier|*
modifier|*
name|lockp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|pt_entry_t
modifier|*
name|pmap_demote_l2
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pt_entry_t
modifier|*
name|l2
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_page_t
name|pmap_enter_quick_locked
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_page_t
name|mpte
parameter_list|,
name|struct
name|rwlock
modifier|*
modifier|*
name|lockp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmap_remove_l3
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pt_entry_t
modifier|*
name|l3
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|pd_entry_t
name|ptepde
parameter_list|,
name|struct
name|spglist
modifier|*
name|free
parameter_list|,
name|struct
name|rwlock
modifier|*
modifier|*
name|lockp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|pmap_try_insert_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|struct
name|rwlock
modifier|*
modifier|*
name|lockp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vm_page_t
name|_pmap_alloc_l3
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_pindex_t
name|ptepindex
parameter_list|,
name|struct
name|rwlock
modifier|*
modifier|*
name|lockp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_pmap_unwire_l3
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|struct
name|spglist
modifier|*
name|free
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmap_unuse_l3
parameter_list|(
name|pmap_t
parameter_list|,
name|vm_offset_t
parameter_list|,
name|pd_entry_t
parameter_list|,
name|struct
name|spglist
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * These load the old table data and store the new value.  * They need to be atomic as the System MMU may write to the table at  * the same time as the CPU.  */
end_comment

begin_define
define|#
directive|define
name|pmap_load_store
parameter_list|(
name|table
parameter_list|,
name|entry
parameter_list|)
value|atomic_swap_64(table, entry)
end_define

begin_define
define|#
directive|define
name|pmap_set
parameter_list|(
name|table
parameter_list|,
name|mask
parameter_list|)
value|atomic_set_64(table, mask)
end_define

begin_define
define|#
directive|define
name|pmap_load_clear
parameter_list|(
name|table
parameter_list|)
value|atomic_swap_64(table, 0)
end_define

begin_define
define|#
directive|define
name|pmap_load
parameter_list|(
name|table
parameter_list|)
value|(*table)
end_define

begin_comment
comment|/********************/
end_comment

begin_comment
comment|/* Inline functions */
end_comment

begin_comment
comment|/********************/
end_comment

begin_function
specifier|static
name|__inline
name|void
name|pagecopy
parameter_list|(
name|void
modifier|*
name|s
parameter_list|,
name|void
modifier|*
name|d
parameter_list|)
block|{
name|memcpy
argument_list|(
name|d
argument_list|,
name|s
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|pmap_l0_index
parameter_list|(
name|va
parameter_list|)
value|(((va)>> L0_SHIFT)& L0_ADDR_MASK)
end_define

begin_define
define|#
directive|define
name|pmap_l1_index
parameter_list|(
name|va
parameter_list|)
value|(((va)>> L1_SHIFT)& Ln_ADDR_MASK)
end_define

begin_define
define|#
directive|define
name|pmap_l2_index
parameter_list|(
name|va
parameter_list|)
value|(((va)>> L2_SHIFT)& Ln_ADDR_MASK)
end_define

begin_define
define|#
directive|define
name|pmap_l3_index
parameter_list|(
name|va
parameter_list|)
value|(((va)>> L3_SHIFT)& Ln_ADDR_MASK)
end_define

begin_function
specifier|static
name|__inline
name|pd_entry_t
modifier|*
name|pmap_l0
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
return|return
operator|(
operator|&
name|pmap
operator|->
name|pm_l0
index|[
name|pmap_l0_index
argument_list|(
name|va
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|pd_entry_t
modifier|*
name|pmap_l0_to_l1
parameter_list|(
name|pd_entry_t
modifier|*
name|l0
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|l1
decl_stmt|;
name|l1
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|pmap_load
argument_list|(
name|l0
argument_list|)
operator|&
operator|~
name|ATTR_MASK
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|l1
index|[
name|pmap_l1_index
argument_list|(
name|va
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|pd_entry_t
modifier|*
name|pmap_l1
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|l0
decl_stmt|;
name|l0
operator|=
name|pmap_l0
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pmap_load
argument_list|(
name|l0
argument_list|)
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|!=
name|L0_TABLE
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|pmap_l0_to_l1
argument_list|(
name|l0
argument_list|,
name|va
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|pd_entry_t
modifier|*
name|pmap_l1_to_l2
parameter_list|(
name|pd_entry_t
modifier|*
name|l1
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|l2
decl_stmt|;
name|l2
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|pmap_load
argument_list|(
name|l1
argument_list|)
operator|&
operator|~
name|ATTR_MASK
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|l2
index|[
name|pmap_l2_index
argument_list|(
name|va
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|pd_entry_t
modifier|*
name|pmap_l2
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|l1
decl_stmt|;
name|l1
operator|=
name|pmap_l1
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pmap_load
argument_list|(
name|l1
argument_list|)
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|!=
name|L1_TABLE
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|pmap_l1_to_l2
argument_list|(
name|l1
argument_list|,
name|va
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|pt_entry_t
modifier|*
name|pmap_l2_to_l3
parameter_list|(
name|pd_entry_t
modifier|*
name|l2
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|l3
decl_stmt|;
name|l3
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|pmap_load
argument_list|(
name|l2
argument_list|)
operator|&
operator|~
name|ATTR_MASK
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|l3
index|[
name|pmap_l3_index
argument_list|(
name|va
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the lowest valid pde for a given virtual address.  * The next level may or may not point to a valid page or block.  */
end_comment

begin_function
specifier|static
name|__inline
name|pd_entry_t
modifier|*
name|pmap_pde
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|int
modifier|*
name|level
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|l0
decl_stmt|,
modifier|*
name|l1
decl_stmt|,
modifier|*
name|l2
decl_stmt|,
name|desc
decl_stmt|;
name|l0
operator|=
name|pmap_l0
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|desc
operator|=
name|pmap_load
argument_list|(
name|l0
argument_list|)
operator|&
name|ATTR_DESCR_MASK
expr_stmt|;
if|if
condition|(
name|desc
operator|!=
name|L0_TABLE
condition|)
block|{
operator|*
name|level
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|l1
operator|=
name|pmap_l0_to_l1
argument_list|(
name|l0
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|desc
operator|=
name|pmap_load
argument_list|(
name|l1
argument_list|)
operator|&
name|ATTR_DESCR_MASK
expr_stmt|;
if|if
condition|(
name|desc
operator|!=
name|L1_TABLE
condition|)
block|{
operator|*
name|level
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|l0
operator|)
return|;
block|}
name|l2
operator|=
name|pmap_l1_to_l2
argument_list|(
name|l1
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|desc
operator|=
name|pmap_load
argument_list|(
name|l2
argument_list|)
operator|&
name|ATTR_DESCR_MASK
expr_stmt|;
if|if
condition|(
name|desc
operator|!=
name|L2_TABLE
condition|)
block|{
operator|*
name|level
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|l1
operator|)
return|;
block|}
operator|*
name|level
operator|=
literal|2
expr_stmt|;
return|return
operator|(
name|l2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the lowest valid pte block or table entry for a given virtual  * address. If there are no valid entries return NULL and set the level to  * the first invalid level.  */
end_comment

begin_function
specifier|static
name|__inline
name|pt_entry_t
modifier|*
name|pmap_pte
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|int
modifier|*
name|level
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|l1
decl_stmt|,
modifier|*
name|l2
decl_stmt|,
name|desc
decl_stmt|;
name|pt_entry_t
modifier|*
name|l3
decl_stmt|;
name|l1
operator|=
name|pmap_l1
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|l1
operator|==
name|NULL
condition|)
block|{
operator|*
name|level
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|desc
operator|=
name|pmap_load
argument_list|(
name|l1
argument_list|)
operator|&
name|ATTR_DESCR_MASK
expr_stmt|;
if|if
condition|(
name|desc
operator|==
name|L1_BLOCK
condition|)
block|{
operator|*
name|level
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|l1
operator|)
return|;
block|}
if|if
condition|(
name|desc
operator|!=
name|L1_TABLE
condition|)
block|{
operator|*
name|level
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|l2
operator|=
name|pmap_l1_to_l2
argument_list|(
name|l1
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|desc
operator|=
name|pmap_load
argument_list|(
name|l2
argument_list|)
operator|&
name|ATTR_DESCR_MASK
expr_stmt|;
if|if
condition|(
name|desc
operator|==
name|L2_BLOCK
condition|)
block|{
operator|*
name|level
operator|=
literal|2
expr_stmt|;
return|return
operator|(
name|l2
operator|)
return|;
block|}
if|if
condition|(
name|desc
operator|!=
name|L2_TABLE
condition|)
block|{
operator|*
name|level
operator|=
literal|2
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|level
operator|=
literal|3
expr_stmt|;
name|l3
operator|=
name|pmap_l2_to_l3
argument_list|(
name|l2
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pmap_load
argument_list|(
name|l3
argument_list|)
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|!=
name|L3_PAGE
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|l3
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|pmap_superpages_enabled
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|superpages_enabled
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|pmap_get_tables
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|pd_entry_t
modifier|*
modifier|*
name|l0
parameter_list|,
name|pd_entry_t
modifier|*
modifier|*
name|l1
parameter_list|,
name|pd_entry_t
modifier|*
modifier|*
name|l2
parameter_list|,
name|pt_entry_t
modifier|*
modifier|*
name|l3
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|l0p
decl_stmt|,
modifier|*
name|l1p
decl_stmt|,
modifier|*
name|l2p
decl_stmt|;
if|if
condition|(
name|pmap
operator|->
name|pm_l0
operator|==
name|NULL
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|l0p
operator|=
name|pmap_l0
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
operator|*
name|l0
operator|=
name|l0p
expr_stmt|;
if|if
condition|(
operator|(
name|pmap_load
argument_list|(
name|l0p
argument_list|)
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|!=
name|L0_TABLE
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|l1p
operator|=
name|pmap_l0_to_l1
argument_list|(
name|l0p
argument_list|,
name|va
argument_list|)
expr_stmt|;
operator|*
name|l1
operator|=
name|l1p
expr_stmt|;
if|if
condition|(
operator|(
name|pmap_load
argument_list|(
name|l1p
argument_list|)
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L1_BLOCK
condition|)
block|{
operator|*
name|l2
operator|=
name|NULL
expr_stmt|;
operator|*
name|l3
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|pmap_load
argument_list|(
name|l1p
argument_list|)
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|!=
name|L1_TABLE
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|l2p
operator|=
name|pmap_l1_to_l2
argument_list|(
name|l1p
argument_list|,
name|va
argument_list|)
expr_stmt|;
operator|*
name|l2
operator|=
name|l2p
expr_stmt|;
if|if
condition|(
operator|(
name|pmap_load
argument_list|(
name|l2p
argument_list|)
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L2_BLOCK
condition|)
block|{
operator|*
name|l3
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
operator|*
name|l3
operator|=
name|pmap_l2_to_l3
argument_list|(
name|l2p
argument_list|,
name|va
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|pmap_is_current
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
return|return
operator|(
operator|(
name|pmap
operator|==
name|pmap_kernel
argument_list|()
operator|)
operator|||
operator|(
name|pmap
operator|==
name|curthread
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_map
operator|.
name|pmap
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|pmap_l3_valid
parameter_list|(
name|pt_entry_t
name|l3
parameter_list|)
block|{
return|return
operator|(
operator|(
name|l3
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L3_PAGE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Is a level 1 or 2entry a valid block and cacheable */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
name|L1_BLOCK
operator|==
name|L2_BLOCK
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|__inline
name|int
name|pmap_pte_valid_cacheable
parameter_list|(
name|pt_entry_t
name|pte
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|pte
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L1_BLOCK
operator|)
operator|&&
operator|(
operator|(
name|pte
operator|&
name|ATTR_IDX_MASK
operator|)
operator|==
name|ATTR_IDX
argument_list|(
name|CACHED_MEMORY
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|pmap_l3_valid_cacheable
parameter_list|(
name|pt_entry_t
name|l3
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|l3
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L3_PAGE
operator|)
operator|&&
operator|(
operator|(
name|l3
operator|&
name|ATTR_IDX_MASK
operator|)
operator|==
name|ATTR_IDX
argument_list|(
name|CACHED_MEMORY
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PTE_SYNC
parameter_list|(
name|pte
parameter_list|)
value|cpu_dcache_wb_range((vm_offset_t)pte, sizeof(*pte))
end_define

begin_comment
comment|/*  * Checks if the page is dirty. We currently lack proper tracking of this on  * arm64 so for now assume is a page mapped as rw was accessed it is.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|pmap_page_dirty
parameter_list|(
name|pt_entry_t
name|pte
parameter_list|)
block|{
return|return
operator|(
operator|(
name|pte
operator|&
operator|(
name|ATTR_AF
operator||
name|ATTR_AP_RW_BIT
operator|)
operator|)
operator|==
operator|(
name|ATTR_AF
operator||
name|ATTR_AP
argument_list|(
name|ATTR_AP_RW
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pmap_resident_count_inc
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|+=
name|count
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|pmap_resident_count_dec
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|>=
name|count
argument_list|,
operator|(
literal|"pmap %p resident count underflow %ld %d"
operator|,
name|pmap
operator|,
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|-=
name|count
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|pt_entry_t
modifier|*
name|pmap_early_page_idx
parameter_list|(
name|vm_offset_t
name|l1pt
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|u_int
modifier|*
name|l1_slot
parameter_list|,
name|u_int
modifier|*
name|l2_slot
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|l2
decl_stmt|;
name|pd_entry_t
modifier|*
name|l1
decl_stmt|;
name|l1
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|l1pt
expr_stmt|;
operator|*
name|l1_slot
operator|=
operator|(
name|va
operator|>>
name|L1_SHIFT
operator|)
operator|&
name|Ln_ADDR_MASK
expr_stmt|;
comment|/* Check locore has used a table L1 map */
name|KASSERT
argument_list|(
operator|(
name|l1
index|[
operator|*
name|l1_slot
index|]
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L1_TABLE
argument_list|,
operator|(
literal|"Invalid bootstrap L1 table"
operator|)
argument_list|)
expr_stmt|;
comment|/* Find the address of the L2 table */
name|l2
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|init_pt_va
expr_stmt|;
operator|*
name|l2_slot
operator|=
name|pmap_l2_index
argument_list|(
name|va
argument_list|)
expr_stmt|;
return|return
operator|(
name|l2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|vm_paddr_t
name|pmap_early_vtophys
parameter_list|(
name|vm_offset_t
name|l1pt
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|u_int
name|l1_slot
decl_stmt|,
name|l2_slot
decl_stmt|;
name|pt_entry_t
modifier|*
name|l2
decl_stmt|;
name|l2
operator|=
name|pmap_early_page_idx
argument_list|(
name|l1pt
argument_list|,
name|va
argument_list|,
operator|&
name|l1_slot
argument_list|,
operator|&
name|l2_slot
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|l2
index|[
name|l2_slot
index|]
operator|&
operator|~
name|ATTR_MASK
operator|)
operator|+
operator|(
name|va
operator|&
name|L2_OFFSET
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_bootstrap_dmap
parameter_list|(
name|vm_offset_t
name|kern_l1
parameter_list|,
name|vm_paddr_t
name|min_pa
parameter_list|,
name|vm_paddr_t
name|max_pa
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|u_int
name|l1_slot
decl_stmt|;
name|pa
operator|=
name|dmap_phys_base
operator|=
name|min_pa
operator|&
operator|~
name|L1_OFFSET
expr_stmt|;
name|va
operator|=
name|DMAP_MIN_ADDRESS
expr_stmt|;
for|for
control|(
init|;
name|va
operator|<
name|DMAP_MAX_ADDRESS
operator|&&
name|pa
operator|<
name|max_pa
condition|;
name|pa
operator|+=
name|L1_SIZE
operator|,
name|va
operator|+=
name|L1_SIZE
operator|,
name|l1_slot
operator|++
control|)
block|{
name|l1_slot
operator|=
operator|(
operator|(
name|va
operator|-
name|DMAP_MIN_ADDRESS
operator|)
operator|>>
name|L1_SHIFT
operator|)
expr_stmt|;
name|pmap_load_store
argument_list|(
operator|&
name|pagetable_dmap
index|[
name|l1_slot
index|]
argument_list|,
operator|(
name|pa
operator|&
operator|~
name|L1_OFFSET
operator|)
operator||
name|ATTR_DEFAULT
operator||
name|ATTR_IDX
argument_list|(
name|CACHED_MEMORY
argument_list|)
operator||
name|L1_BLOCK
argument_list|)
expr_stmt|;
block|}
comment|/* Set the upper limit of the DMAP region */
name|dmap_phys_max
operator|=
name|pa
expr_stmt|;
name|dmap_max_addr
operator|=
name|va
expr_stmt|;
name|cpu_dcache_wb_range
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pagetable_dmap
argument_list|,
name|PAGE_SIZE
operator|*
name|DMAP_TABLES
argument_list|)
expr_stmt|;
name|cpu_tlb_flushID
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|vm_offset_t
name|pmap_bootstrap_l2
parameter_list|(
name|vm_offset_t
name|l1pt
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|l2_start
parameter_list|)
block|{
name|vm_offset_t
name|l2pt
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|pd_entry_t
modifier|*
name|l1
decl_stmt|;
name|u_int
name|l1_slot
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|va
operator|&
name|L1_OFFSET
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"Invalid virtual address"
operator|)
argument_list|)
expr_stmt|;
name|l1
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|l1pt
expr_stmt|;
name|l1_slot
operator|=
name|pmap_l1_index
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|l2pt
operator|=
name|l2_start
expr_stmt|;
for|for
control|(
init|;
name|va
operator|<
name|VM_MAX_KERNEL_ADDRESS
condition|;
name|l1_slot
operator|++
operator|,
name|va
operator|+=
name|L1_SIZE
control|)
block|{
name|KASSERT
argument_list|(
name|l1_slot
operator|<
name|Ln_ENTRIES
argument_list|,
operator|(
literal|"Invalid L1 index"
operator|)
argument_list|)
expr_stmt|;
name|pa
operator|=
name|pmap_early_vtophys
argument_list|(
name|l1pt
argument_list|,
name|l2pt
argument_list|)
expr_stmt|;
name|pmap_load_store
argument_list|(
operator|&
name|l1
index|[
name|l1_slot
index|]
argument_list|,
operator|(
name|pa
operator|&
operator|~
name|Ln_TABLE_MASK
operator|)
operator||
name|L1_TABLE
argument_list|)
expr_stmt|;
name|l2pt
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
comment|/* Clean the L2 page table */
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|l2_start
argument_list|,
literal|0
argument_list|,
name|l2pt
operator|-
name|l2_start
argument_list|)
expr_stmt|;
name|cpu_dcache_wb_range
argument_list|(
name|l2_start
argument_list|,
name|l2pt
operator|-
name|l2_start
argument_list|)
expr_stmt|;
comment|/* Flush the l1 table to ram */
name|cpu_dcache_wb_range
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|l1
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return
name|l2pt
return|;
block|}
end_function

begin_function
specifier|static
name|vm_offset_t
name|pmap_bootstrap_l3
parameter_list|(
name|vm_offset_t
name|l1pt
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|l3_start
parameter_list|)
block|{
name|vm_offset_t
name|l2pt
decl_stmt|,
name|l3pt
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|pd_entry_t
modifier|*
name|l2
decl_stmt|;
name|u_int
name|l2_slot
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|va
operator|&
name|L2_OFFSET
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"Invalid virtual address"
operator|)
argument_list|)
expr_stmt|;
name|l2
operator|=
name|pmap_l2
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|l2
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|rounddown2
argument_list|(
operator|(
name|uintptr_t
operator|)
name|l2
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|l2pt
operator|=
operator|(
name|vm_offset_t
operator|)
name|l2
expr_stmt|;
name|l2_slot
operator|=
name|pmap_l2_index
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|l3pt
operator|=
name|l3_start
expr_stmt|;
for|for
control|(
init|;
name|va
operator|<
name|VM_MAX_KERNEL_ADDRESS
condition|;
name|l2_slot
operator|++
operator|,
name|va
operator|+=
name|L2_SIZE
control|)
block|{
name|KASSERT
argument_list|(
name|l2_slot
operator|<
name|Ln_ENTRIES
argument_list|,
operator|(
literal|"Invalid L2 index"
operator|)
argument_list|)
expr_stmt|;
name|pa
operator|=
name|pmap_early_vtophys
argument_list|(
name|l1pt
argument_list|,
name|l3pt
argument_list|)
expr_stmt|;
name|pmap_load_store
argument_list|(
operator|&
name|l2
index|[
name|l2_slot
index|]
argument_list|,
operator|(
name|pa
operator|&
operator|~
name|Ln_TABLE_MASK
operator|)
operator||
name|L2_TABLE
argument_list|)
expr_stmt|;
name|l3pt
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
comment|/* Clean the L2 page table */
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|l3_start
argument_list|,
literal|0
argument_list|,
name|l3pt
operator|-
name|l3_start
argument_list|)
expr_stmt|;
name|cpu_dcache_wb_range
argument_list|(
name|l3_start
argument_list|,
name|l3pt
operator|-
name|l3_start
argument_list|)
expr_stmt|;
name|cpu_dcache_wb_range
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|l2
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return
name|l3pt
return|;
block|}
end_function

begin_comment
comment|/*  *	Bootstrap the system enough to run with virtual memory.  */
end_comment

begin_function
name|void
name|pmap_bootstrap
parameter_list|(
name|vm_offset_t
name|l0pt
parameter_list|,
name|vm_offset_t
name|l1pt
parameter_list|,
name|vm_paddr_t
name|kernstart
parameter_list|,
name|vm_size_t
name|kernlen
parameter_list|)
block|{
name|u_int
name|l1_slot
decl_stmt|,
name|l2_slot
decl_stmt|,
name|avail_slot
decl_stmt|,
name|map_slot
decl_stmt|,
name|used_map_slot
decl_stmt|;
name|uint64_t
name|kern_delta
decl_stmt|;
name|pt_entry_t
modifier|*
name|l2
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|,
name|freemempos
decl_stmt|;
name|vm_offset_t
name|dpcpu
decl_stmt|,
name|msgbufpv
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|,
name|max_pa
decl_stmt|,
name|min_pa
decl_stmt|;
name|int
name|i
decl_stmt|;
name|kern_delta
operator|=
name|KERNBASE
operator|-
name|kernstart
expr_stmt|;
name|physmem
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|"pmap_bootstrap %lx %lx %lx\n"
argument_list|,
name|l1pt
argument_list|,
name|kernstart
argument_list|,
name|kernlen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%lx\n"
argument_list|,
name|l1pt
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%lx\n"
argument_list|,
operator|(
name|KERNBASE
operator|>>
name|L1_SHIFT
operator|)
operator|&
name|Ln_ADDR_MASK
argument_list|)
expr_stmt|;
comment|/* Set this early so we can use the pagetable walking functions */
name|kernel_pmap_store
operator|.
name|pm_l0
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|l0pt
expr_stmt|;
name|PMAP_LOCK_INIT
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
comment|/* Assume the address we were loaded to is a valid physical address */
name|min_pa
operator|=
name|max_pa
operator|=
name|KERNBASE
operator|-
name|kern_delta
expr_stmt|;
comment|/* 	 * Find the minimum physical address. physmap is sorted, 	 * but may contain empty ranges. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|physmap_idx
operator|*
literal|2
operator|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|physmap
index|[
name|i
index|]
operator|==
name|physmap
index|[
name|i
operator|+
literal|1
index|]
condition|)
continue|continue;
if|if
condition|(
name|physmap
index|[
name|i
index|]
operator|<=
name|min_pa
condition|)
name|min_pa
operator|=
name|physmap
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|physmap
index|[
name|i
operator|+
literal|1
index|]
operator|>
name|max_pa
condition|)
name|max_pa
operator|=
name|physmap
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
comment|/* Create a direct map region early so we can use it for pa -> va */
name|pmap_bootstrap_dmap
argument_list|(
name|l1pt
argument_list|,
name|min_pa
argument_list|,
name|max_pa
argument_list|)
expr_stmt|;
name|va
operator|=
name|KERNBASE
expr_stmt|;
name|pa
operator|=
name|KERNBASE
operator|-
name|kern_delta
expr_stmt|;
comment|/* 	 * Start to initialise phys_avail by copying from physmap 	 * up to the physical address KERNBASE points at. 	 */
name|map_slot
operator|=
name|avail_slot
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|map_slot
operator|<
operator|(
name|physmap_idx
operator|*
literal|2
operator|)
operator|&&
name|avail_slot
operator|<
operator|(
name|PHYS_AVAIL_SIZE
operator|-
literal|2
operator|)
condition|;
name|map_slot
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|physmap
index|[
name|map_slot
index|]
operator|==
name|physmap
index|[
name|map_slot
operator|+
literal|1
index|]
condition|)
continue|continue;
if|if
condition|(
name|physmap
index|[
name|map_slot
index|]
operator|<=
name|pa
operator|&&
name|physmap
index|[
name|map_slot
operator|+
literal|1
index|]
operator|>
name|pa
condition|)
break|break;
name|phys_avail
index|[
name|avail_slot
index|]
operator|=
name|physmap
index|[
name|map_slot
index|]
expr_stmt|;
name|phys_avail
index|[
name|avail_slot
operator|+
literal|1
index|]
operator|=
name|physmap
index|[
name|map_slot
operator|+
literal|1
index|]
expr_stmt|;
name|physmem
operator|+=
operator|(
name|phys_avail
index|[
name|avail_slot
operator|+
literal|1
index|]
operator|-
name|phys_avail
index|[
name|avail_slot
index|]
operator|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|avail_slot
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Add the memory before the kernel */
if|if
condition|(
name|physmap
index|[
name|avail_slot
index|]
operator|<
name|pa
operator|&&
name|avail_slot
operator|<
operator|(
name|PHYS_AVAIL_SIZE
operator|-
literal|2
operator|)
condition|)
block|{
name|phys_avail
index|[
name|avail_slot
index|]
operator|=
name|physmap
index|[
name|map_slot
index|]
expr_stmt|;
name|phys_avail
index|[
name|avail_slot
operator|+
literal|1
index|]
operator|=
name|pa
expr_stmt|;
name|physmem
operator|+=
operator|(
name|phys_avail
index|[
name|avail_slot
operator|+
literal|1
index|]
operator|-
name|phys_avail
index|[
name|avail_slot
index|]
operator|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|avail_slot
operator|+=
literal|2
expr_stmt|;
block|}
name|used_map_slot
operator|=
name|map_slot
expr_stmt|;
comment|/* 	 * Read the page table to find out what is already mapped. 	 * This assumes we have mapped a block of memory from KERNBASE 	 * using a single L1 entry. 	 */
name|l2
operator|=
name|pmap_early_page_idx
argument_list|(
name|l1pt
argument_list|,
name|KERNBASE
argument_list|,
operator|&
name|l1_slot
argument_list|,
operator|&
name|l2_slot
argument_list|)
expr_stmt|;
comment|/* Sanity check the index, KERNBASE should be the first VA */
name|KASSERT
argument_list|(
name|l2_slot
operator|==
literal|0
argument_list|,
operator|(
literal|"The L2 index is non-zero"
operator|)
argument_list|)
expr_stmt|;
comment|/* Find how many pages we have mapped */
for|for
control|(
init|;
name|l2_slot
operator|<
name|Ln_ENTRIES
condition|;
name|l2_slot
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|l2
index|[
name|l2_slot
index|]
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* Check locore used L2 blocks */
name|KASSERT
argument_list|(
operator|(
name|l2
index|[
name|l2_slot
index|]
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L2_BLOCK
argument_list|,
operator|(
literal|"Invalid bootstrap L2 table"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|l2
index|[
name|l2_slot
index|]
operator|&
operator|~
name|ATTR_MASK
operator|)
operator|==
name|pa
argument_list|,
operator|(
literal|"Incorrect PA in L2 table"
operator|)
argument_list|)
expr_stmt|;
name|va
operator|+=
name|L2_SIZE
expr_stmt|;
name|pa
operator|+=
name|L2_SIZE
expr_stmt|;
block|}
name|va
operator|=
name|roundup2
argument_list|(
name|va
argument_list|,
name|L1_SIZE
argument_list|)
expr_stmt|;
name|freemempos
operator|=
name|KERNBASE
operator|+
name|kernlen
expr_stmt|;
name|freemempos
operator|=
name|roundup2
argument_list|(
name|freemempos
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* Create the l2 tables up to VM_MAX_KERNEL_ADDRESS */
name|freemempos
operator|=
name|pmap_bootstrap_l2
argument_list|(
name|l1pt
argument_list|,
name|va
argument_list|,
name|freemempos
argument_list|)
expr_stmt|;
comment|/* And the l3 tables for the early devmap */
name|freemempos
operator|=
name|pmap_bootstrap_l3
argument_list|(
name|l1pt
argument_list|,
name|VM_MAX_KERNEL_ADDRESS
operator|-
name|L2_SIZE
argument_list|,
name|freemempos
argument_list|)
expr_stmt|;
name|cpu_tlb_flushID
argument_list|()
expr_stmt|;
define|#
directive|define
name|alloc_pages
parameter_list|(
name|var
parameter_list|,
name|np
parameter_list|)
define|\
value|(var) = freemempos;						\ 	freemempos += (np * PAGE_SIZE);					\ 	memset((char *)(var), 0, ((np) * PAGE_SIZE));
comment|/* Allocate dynamic per-cpu area. */
name|alloc_pages
argument_list|(
name|dpcpu
argument_list|,
name|DPCPU_SIZE
operator|/
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|dpcpu_init
argument_list|(
operator|(
name|void
operator|*
operator|)
name|dpcpu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Allocate memory for the msgbuf, e.g. for /sbin/dmesg */
name|alloc_pages
argument_list|(
name|msgbufpv
argument_list|,
name|round_page
argument_list|(
name|msgbufsize
argument_list|)
operator|/
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|msgbufp
operator|=
operator|(
name|void
operator|*
operator|)
name|msgbufpv
expr_stmt|;
name|virtual_avail
operator|=
name|roundup2
argument_list|(
name|freemempos
argument_list|,
name|L1_SIZE
argument_list|)
expr_stmt|;
name|virtual_end
operator|=
name|VM_MAX_KERNEL_ADDRESS
operator|-
name|L2_SIZE
expr_stmt|;
name|kernel_vm_end
operator|=
name|virtual_avail
expr_stmt|;
name|pa
operator|=
name|pmap_early_vtophys
argument_list|(
name|l1pt
argument_list|,
name|freemempos
argument_list|)
expr_stmt|;
comment|/* Finish initialising physmap */
name|map_slot
operator|=
name|used_map_slot
expr_stmt|;
for|for
control|(
init|;
name|avail_slot
operator|<
operator|(
name|PHYS_AVAIL_SIZE
operator|-
literal|2
operator|)
operator|&&
name|map_slot
operator|<
operator|(
name|physmap_idx
operator|*
literal|2
operator|)
condition|;
name|map_slot
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|physmap
index|[
name|map_slot
index|]
operator|==
name|physmap
index|[
name|map_slot
operator|+
literal|1
index|]
condition|)
continue|continue;
comment|/* Have we used the current range? */
if|if
condition|(
name|physmap
index|[
name|map_slot
operator|+
literal|1
index|]
operator|<=
name|pa
condition|)
continue|continue;
comment|/* Do we need to split the entry? */
if|if
condition|(
name|physmap
index|[
name|map_slot
index|]
operator|<
name|pa
condition|)
block|{
name|phys_avail
index|[
name|avail_slot
index|]
operator|=
name|pa
expr_stmt|;
name|phys_avail
index|[
name|avail_slot
operator|+
literal|1
index|]
operator|=
name|physmap
index|[
name|map_slot
operator|+
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|phys_avail
index|[
name|avail_slot
index|]
operator|=
name|physmap
index|[
name|map_slot
index|]
expr_stmt|;
name|phys_avail
index|[
name|avail_slot
operator|+
literal|1
index|]
operator|=
name|physmap
index|[
name|map_slot
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|physmem
operator|+=
operator|(
name|phys_avail
index|[
name|avail_slot
operator|+
literal|1
index|]
operator|-
name|phys_avail
index|[
name|avail_slot
index|]
operator|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|avail_slot
operator|+=
literal|2
expr_stmt|;
block|}
name|phys_avail
index|[
name|avail_slot
index|]
operator|=
literal|0
expr_stmt|;
name|phys_avail
index|[
name|avail_slot
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Maxmem isn't the "maximum memory", it's one larger than the 	 * highest page of the physical address space.  It should be 	 * called something like "Maxphyspage". 	 */
name|Maxmem
operator|=
name|atop
argument_list|(
name|phys_avail
index|[
name|avail_slot
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|cpu_tlb_flushID
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Initialize a vm_page's machine-dependent fields.  */
end_comment

begin_function
name|void
name|pmap_page_init
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_memattr
operator|=
name|VM_MEMATTR_WRITE_BACK
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Initialize the pmap module.  *	Called by vm_init, to initialize any structures that the pmap  *	system needs to map virtual memory.  */
end_comment

begin_function
name|void
name|pmap_init
parameter_list|(
name|void
parameter_list|)
block|{
name|vm_size_t
name|s
decl_stmt|;
name|int
name|i
decl_stmt|,
name|pv_npg
decl_stmt|;
comment|/* 	 * Are large page mappings enabled? 	 */
name|TUNABLE_INT_FETCH
argument_list|(
literal|"vm.pmap.superpages_enabled"
argument_list|,
operator|&
name|superpages_enabled
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the pv chunk list mutex. 	 */
name|mtx_init
argument_list|(
operator|&
name|pv_chunks_mutex
argument_list|,
literal|"pmap pv chunk list"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the pool of pv list locks. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPV_LIST_LOCKS
condition|;
name|i
operator|++
control|)
name|rw_init
argument_list|(
operator|&
name|pv_list_locks
index|[
name|i
index|]
argument_list|,
literal|"pmap pv list"
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the size of the pv head table for superpages. 	 */
name|pv_npg
operator|=
name|howmany
argument_list|(
name|vm_phys_segs
index|[
name|vm_phys_nsegs
operator|-
literal|1
index|]
operator|.
name|end
argument_list|,
name|L2_SIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate memory for the pv head table for superpages. 	 */
name|s
operator|=
call|(
name|vm_size_t
call|)
argument_list|(
name|pv_npg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|md_page
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|round_page
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|pv_table
operator|=
operator|(
expr|struct
name|md_page
operator|*
operator|)
name|kmem_malloc
argument_list|(
name|kernel_arena
argument_list|,
name|s
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pv_npg
condition|;
name|i
operator|++
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|pv_table
index|[
name|i
index|]
operator|.
name|pv_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pv_dummy
operator|.
name|pv_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_vm_pmap
argument_list|,
name|OID_AUTO
argument_list|,
name|l2
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"2MB page mapping counters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|pmap_l2_demotions
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_vm_pmap_l2
argument_list|,
name|OID_AUTO
argument_list|,
name|demotions
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_l2_demotions
argument_list|,
literal|0
argument_list|,
literal|"2MB page demotions"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|pmap_l2_p_failures
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_vm_pmap_l2
argument_list|,
name|OID_AUTO
argument_list|,
name|p_failures
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_l2_p_failures
argument_list|,
literal|0
argument_list|,
literal|"2MB page promotion failures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|pmap_l2_promotions
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_vm_pmap_l2
argument_list|,
name|OID_AUTO
argument_list|,
name|promotions
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_l2_promotions
argument_list|,
literal|0
argument_list|,
literal|"2MB page promotions"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Invalidate a single TLB entry.  */
end_comment

begin_function
name|PMAP_INLINE
name|void
name|pmap_invalidate_page
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|sched_pin
argument_list|()
expr_stmt|;
asm|__asm __volatile(
literal|"dsb  ishst		\n"
literal|"tlbi vaae1is, %0	\n"
literal|"dsb  ish		\n"
literal|"isb		\n"
operator|:
operator|:
literal|"r"
operator|(
name|va
operator|>>
name|PAGE_SHIFT
operator|)
block|)
function|;
end_function

begin_expr_stmt
name|sched_unpin
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function
unit|}  PMAP_INLINE
name|void
name|pmap_invalidate_range
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|)
block|{
name|vm_offset_t
name|addr
decl_stmt|;
name|sched_pin
argument_list|()
expr_stmt|;
name|dsb
argument_list|(
name|ishst
argument_list|)
expr_stmt|;
for|for
control|(
name|addr
operator|=
name|sva
init|;
name|addr
operator|<
name|eva
condition|;
name|addr
operator|+=
name|PAGE_SIZE
control|)
block|{
asm|__asm __volatile(
literal|"tlbi vaae1is, %0"
operator|:
operator|:
literal|"r"
operator|(
name|addr
operator|>>
name|PAGE_SHIFT
operator|)
block|)
empty_stmt|;
block|}
end_function

begin_asm
asm|__asm __volatile(
end_asm

begin_expr_stmt
literal|"dsb  ish	\n"
literal|"isb	\n"
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|sched_unpin
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function
unit|}  PMAP_INLINE
name|void
name|pmap_invalidate_all
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|sched_pin
argument_list|()
expr_stmt|;
asm|__asm __volatile(
literal|"dsb  ishst		\n"
literal|"tlbi vmalle1is	\n"
literal|"dsb  ish		\n"
literal|"isb		\n"
block|)
function|;
end_function

begin_expr_stmt
name|sched_unpin
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/*  *	Routine:	pmap_extract  *	Function:  *		Extract the physical page address associated  *		with the given map/virtual_address pair.  */
end_comment

begin_macro
unit|vm_paddr_t
name|pmap_extract
argument_list|(
argument|pmap_t pmap
argument_list|,
argument|vm_offset_t va
argument_list|)
end_macro

begin_block
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
name|tpte
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|int
name|lvl
decl_stmt|;
name|pa
operator|=
literal|0
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
comment|/* 	 * Find the block or page map for this virtual address. pmap_pte 	 * will return either a valid block/page entry, or NULL. 	 */
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|!=
name|NULL
condition|)
block|{
name|tpte
operator|=
name|pmap_load
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|pa
operator|=
name|tpte
operator|&
operator|~
name|ATTR_MASK
expr_stmt|;
switch|switch
condition|(
name|lvl
condition|)
block|{
case|case
literal|1
case|:
name|KASSERT
argument_list|(
operator|(
name|tpte
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L1_BLOCK
argument_list|,
operator|(
literal|"pmap_extract: Invalid L1 pte found: %lx"
operator|,
name|tpte
operator|&
name|ATTR_DESCR_MASK
operator|)
argument_list|)
expr_stmt|;
name|pa
operator||=
operator|(
name|va
operator|&
name|L1_OFFSET
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|KASSERT
argument_list|(
operator|(
name|tpte
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L2_BLOCK
argument_list|,
operator|(
literal|"pmap_extract: Invalid L2 pte found: %lx"
operator|,
name|tpte
operator|&
name|ATTR_DESCR_MASK
operator|)
argument_list|)
expr_stmt|;
name|pa
operator||=
operator|(
name|va
operator|&
name|L2_OFFSET
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|KASSERT
argument_list|(
operator|(
name|tpte
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L3_PAGE
argument_list|,
operator|(
literal|"pmap_extract: Invalid L3 pte found: %lx"
operator|,
name|tpte
operator|&
name|ATTR_DESCR_MASK
operator|)
argument_list|)
expr_stmt|;
name|pa
operator||=
operator|(
name|va
operator|&
name|L3_OFFSET
operator|)
expr_stmt|;
break|break;
block|}
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|pa
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *	Routine:	pmap_extract_and_hold  *	Function:  *		Atomically extract and hold the physical page  *		with the given pmap and virtual address pair  *		if that mapping permits the given protection.  */
end_comment

begin_function
name|vm_page_t
name|pmap_extract_and_hold
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
name|tpte
decl_stmt|;
name|vm_offset_t
name|off
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|lvl
decl_stmt|;
name|pa
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|retry
label|:
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|!=
name|NULL
condition|)
block|{
name|tpte
operator|=
name|pmap_load
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lvl
operator|>
literal|0
operator|&&
name|lvl
operator|<=
literal|3
argument_list|,
operator|(
literal|"pmap_extract_and_hold: Invalid level %d"
operator|,
name|lvl
operator|)
argument_list|)
expr_stmt|;
name|CTASSERT
argument_list|(
name|L1_BLOCK
operator|==
name|L2_BLOCK
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|lvl
operator|==
literal|3
operator|&&
operator|(
name|tpte
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L3_PAGE
operator|)
operator|||
operator|(
name|lvl
operator|<
literal|3
operator|&&
operator|(
name|tpte
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L1_BLOCK
operator|)
argument_list|,
operator|(
literal|"pmap_extract_and_hold: Invalid pte at L%d: %lx"
operator|,
name|lvl
operator|,
name|tpte
operator|&
name|ATTR_DESCR_MASK
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|tpte
operator|&
name|ATTR_AP_RW_BIT
operator|)
operator|==
name|ATTR_AP
argument_list|(
name|ATTR_AP_RW
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
switch|switch
condition|(
name|lvl
condition|)
block|{
case|case
literal|1
case|:
name|off
operator|=
name|va
operator|&
name|L1_OFFSET
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|off
operator|=
name|va
operator|&
name|L2_OFFSET
expr_stmt|;
break|break;
case|case
literal|3
case|:
default|default:
name|off
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|vm_page_pa_tryrelock
argument_list|(
name|pmap
argument_list|,
operator|(
name|tpte
operator|&
operator|~
name|ATTR_MASK
operator|)
operator||
name|off
argument_list|,
operator|&
name|pa
argument_list|)
condition|)
goto|goto
name|retry
goto|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
operator|(
name|tpte
operator|&
operator|~
name|ATTR_MASK
operator|)
operator||
name|off
argument_list|)
expr_stmt|;
name|vm_page_hold
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
name|PA_UNLOCK_COND
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
name|vm_paddr_t
name|pmap_kextract
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
name|tpte
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|int
name|lvl
decl_stmt|;
if|if
condition|(
name|va
operator|>=
name|DMAP_MIN_ADDRESS
operator|&&
name|va
operator|<
name|DMAP_MAX_ADDRESS
condition|)
block|{
name|pa
operator|=
name|DMAP_TO_PHYS
argument_list|(
name|va
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pa
operator|=
literal|0
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|!=
name|NULL
condition|)
block|{
name|tpte
operator|=
name|pmap_load
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|pa
operator|=
name|tpte
operator|&
operator|~
name|ATTR_MASK
expr_stmt|;
switch|switch
condition|(
name|lvl
condition|)
block|{
case|case
literal|1
case|:
name|KASSERT
argument_list|(
operator|(
name|tpte
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L1_BLOCK
argument_list|,
operator|(
literal|"pmap_kextract: Invalid L1 pte found: %lx"
operator|,
name|tpte
operator|&
name|ATTR_DESCR_MASK
operator|)
argument_list|)
expr_stmt|;
name|pa
operator||=
operator|(
name|va
operator|&
name|L1_OFFSET
operator|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|KASSERT
argument_list|(
operator|(
name|tpte
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L2_BLOCK
argument_list|,
operator|(
literal|"pmap_kextract: Invalid L2 pte found: %lx"
operator|,
name|tpte
operator|&
name|ATTR_DESCR_MASK
operator|)
argument_list|)
expr_stmt|;
name|pa
operator||=
operator|(
name|va
operator|&
name|L2_OFFSET
operator|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|KASSERT
argument_list|(
operator|(
name|tpte
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L3_PAGE
argument_list|,
operator|(
literal|"pmap_kextract: Invalid L3 pte found: %lx"
operator|,
name|tpte
operator|&
name|ATTR_DESCR_MASK
operator|)
argument_list|)
expr_stmt|;
name|pa
operator||=
operator|(
name|va
operator|&
name|L3_OFFSET
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
operator|(
name|pa
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************  * Low level mapping routines.....  ***************************************************/
end_comment

begin_function
specifier|static
name|void
name|pmap_kenter
parameter_list|(
name|vm_offset_t
name|sva
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|int
name|lvl
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|pa
operator|&
name|L3_OFFSET
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_kenter: Invalid physical address"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|sva
operator|&
name|L3_OFFSET
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_kenter: Invalid virtual address"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|size
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_kenter: Mapping is not page-sized"
operator|)
argument_list|)
expr_stmt|;
name|va
operator|=
name|sva
expr_stmt|;
while|while
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
name|pde
operator|=
name|pmap_pde
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pde
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_kenter: Invalid page entry, va: 0x%lx"
operator|,
name|va
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lvl
operator|==
literal|2
argument_list|,
operator|(
literal|"pmap_kenter: Invalid level %d"
operator|,
name|lvl
operator|)
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_l2_to_l3
argument_list|(
name|pde
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pmap_load_store
argument_list|(
name|pte
argument_list|,
operator|(
name|pa
operator|&
operator|~
name|L3_OFFSET
operator|)
operator||
name|ATTR_DEFAULT
operator||
name|ATTR_IDX
argument_list|(
name|mode
argument_list|)
operator||
name|L3_PAGE
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|pa
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|size
operator|-=
name|PAGE_SIZE
expr_stmt|;
block|}
name|pmap_invalidate_range
argument_list|(
name|kernel_pmap
argument_list|,
name|sva
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_kenter_device
parameter_list|(
name|vm_offset_t
name|sva
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|)
block|{
name|pmap_kenter
argument_list|(
name|sva
argument_list|,
name|size
argument_list|,
name|pa
argument_list|,
name|DEVICE_MEMORY
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a page from the kernel pagetables.  */
end_comment

begin_function
name|PMAP_INLINE
name|void
name|pmap_kremove
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|int
name|lvl
decl_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pte
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_kremove: Invalid address"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lvl
operator|==
literal|3
argument_list|,
operator|(
literal|"pmap_kremove: Invalid pte level %d"
operator|,
name|lvl
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_l3_valid_cacheable
argument_list|(
name|pmap_load
argument_list|(
name|pte
argument_list|)
argument_list|)
condition|)
name|cpu_dcache_wb_range
argument_list|(
name|va
argument_list|,
name|L3_SIZE
argument_list|)
expr_stmt|;
name|pmap_load_clear
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_kremove_device
parameter_list|(
name|vm_offset_t
name|sva
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|int
name|lvl
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|sva
operator|&
name|L3_OFFSET
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_kremove_device: Invalid virtual address"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|size
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_kremove_device: Mapping is not page-sized"
operator|)
argument_list|)
expr_stmt|;
name|va
operator|=
name|sva
expr_stmt|;
while|while
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
name|pte
operator|=
name|pmap_pte
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pte
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Invalid page table, va: 0x%lx"
operator|,
name|va
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lvl
operator|==
literal|3
argument_list|,
operator|(
literal|"Invalid device pagetable level: %d != 3"
operator|,
name|lvl
operator|)
argument_list|)
expr_stmt|;
name|pmap_load_clear
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|size
operator|-=
name|PAGE_SIZE
expr_stmt|;
block|}
name|pmap_invalidate_range
argument_list|(
name|kernel_pmap
argument_list|,
name|sva
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Used to map a range of physical addresses into kernel  *	virtual address space.  *  *	The value passed in '*virt' is a suggested virtual address for  *	the mapping. Architectures which can support a direct-mapped  *	physical to virtual region can return the appropriate address  *	within that region, leaving '*virt' unchanged. Other  *	architectures should map the pages starting at '*virt' and  *	update '*virt' with the first usable address after the mapped  *	region.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_map
parameter_list|(
name|vm_offset_t
modifier|*
name|virt
parameter_list|,
name|vm_paddr_t
name|start
parameter_list|,
name|vm_paddr_t
name|end
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
return|return
name|PHYS_TO_DMAP
argument_list|(
name|start
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a list of wired pages to the kva  * this routine is only used for temporary  * kernel mappings that do not need to have  * page modification or references recorded.  * Note that old mappings are simply written  * over.  The page *must* be wired.  * Note: SMP coherent.  Uses a ranged shootdown IPI.  */
end_comment

begin_function
name|void
name|pmap_qenter
parameter_list|(
name|vm_offset_t
name|sva
parameter_list|,
name|vm_page_t
modifier|*
name|ma
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
name|pa
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|i
decl_stmt|,
name|lvl
decl_stmt|;
name|va
operator|=
name|sva
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|pde
operator|=
name|pmap_pde
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pde
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_qenter: Invalid page entry, va: 0x%lx"
operator|,
name|va
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lvl
operator|==
literal|2
argument_list|,
operator|(
literal|"pmap_qenter: Invalid level %d"
operator|,
name|lvl
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|ma
index|[
name|i
index|]
expr_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator||
name|ATTR_DEFAULT
operator||
name|ATTR_AP
argument_list|(
name|ATTR_AP_RW
argument_list|)
operator||
name|ATTR_IDX
argument_list|(
name|m
operator|->
name|md
operator|.
name|pv_memattr
argument_list|)
operator||
name|L3_PAGE
expr_stmt|;
name|pte
operator|=
name|pmap_l2_to_l3
argument_list|(
name|pde
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pmap_load_store
argument_list|(
name|pte
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|va
operator|+=
name|L3_SIZE
expr_stmt|;
block|}
name|pmap_invalidate_range
argument_list|(
name|kernel_pmap
argument_list|,
name|sva
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine tears out page mappings from the  * kernel -- it is meant only for temporary mappings.  */
end_comment

begin_function
name|void
name|pmap_qremove
parameter_list|(
name|vm_offset_t
name|sva
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|int
name|lvl
decl_stmt|;
name|KASSERT
argument_list|(
name|sva
operator|>=
name|VM_MIN_KERNEL_ADDRESS
argument_list|,
operator|(
literal|"usermode va %lx"
operator|,
name|sva
operator|)
argument_list|)
expr_stmt|;
name|va
operator|=
name|sva
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|pte
operator|=
name|pmap_pte
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lvl
operator|==
literal|3
argument_list|,
operator|(
literal|"Invalid device pagetable level: %d != 3"
operator|,
name|lvl
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pmap_l3_valid_cacheable
argument_list|(
name|pmap_load
argument_list|(
name|pte
argument_list|)
argument_list|)
condition|)
name|cpu_dcache_wb_range
argument_list|(
name|va
argument_list|,
name|L3_SIZE
argument_list|)
expr_stmt|;
name|pmap_load_clear
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pte
argument_list|)
expr_stmt|;
block|}
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
name|pmap_invalidate_range
argument_list|(
name|kernel_pmap
argument_list|,
name|sva
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/***************************************************  * Page table page management routines.....  ***************************************************/
end_comment

begin_function
specifier|static
name|__inline
name|void
name|pmap_free_zero_pages
parameter_list|(
name|struct
name|spglist
modifier|*
name|free
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|SLIST_FIRST
argument_list|(
name|free
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
name|free
argument_list|,
name|plinks
operator|.
name|s
operator|.
name|ss
argument_list|)
expr_stmt|;
comment|/* Preserve the page's PG_ZERO setting. */
name|vm_page_free_toq
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Schedule the specified unused page table page to be freed.  Specifically,  * add the page to the specified list of pages that will be released to the  * physical memory manager after the TLB has been updated.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|pmap_add_delayed_free_list
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|struct
name|spglist
modifier|*
name|free
parameter_list|,
name|boolean_t
name|set_PG_ZERO
parameter_list|)
block|{
if|if
condition|(
name|set_PG_ZERO
condition|)
name|m
operator|->
name|flags
operator||=
name|PG_ZERO
expr_stmt|;
else|else
name|m
operator|->
name|flags
operator|&=
operator|~
name|PG_ZERO
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
name|free
argument_list|,
name|m
argument_list|,
name|plinks
operator|.
name|s
operator|.
name|ss
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Decrements a page table page's wire count, which is used to record the  * number of valid page table entries within the page.  If the wire count  * drops to zero, then the page table page is unmapped.  Returns TRUE if the  * page table page was unmapped and FALSE otherwise.  */
end_comment

begin_function
specifier|static
specifier|inline
name|boolean_t
name|pmap_unwire_l3
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|struct
name|spglist
modifier|*
name|free
parameter_list|)
block|{
operator|--
name|m
operator|->
name|wire_count
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|wire_count
operator|==
literal|0
condition|)
block|{
name|_pmap_unwire_l3
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
name|free
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_pmap_unwire_l3
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|struct
name|spglist
modifier|*
name|free
parameter_list|)
block|{
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * unmap the page table page 	 */
if|if
condition|(
name|m
operator|->
name|pindex
operator|>=
operator|(
name|NUL2E
operator|+
name|NUL1E
operator|)
condition|)
block|{
comment|/* l1 page */
name|pd_entry_t
modifier|*
name|l0
decl_stmt|;
name|l0
operator|=
name|pmap_l0
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pmap_load_clear
argument_list|(
name|l0
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|l0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|pindex
operator|>=
name|NUL2E
condition|)
block|{
comment|/* l2 page */
name|pd_entry_t
modifier|*
name|l1
decl_stmt|;
name|l1
operator|=
name|pmap_l1
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pmap_load_clear
argument_list|(
name|l1
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|l1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* l3 page */
name|pd_entry_t
modifier|*
name|l2
decl_stmt|;
name|l2
operator|=
name|pmap_l2
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pmap_load_clear
argument_list|(
name|l2
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|l2
argument_list|)
expr_stmt|;
block|}
name|pmap_resident_count_dec
argument_list|(
name|pmap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|pindex
operator|<
name|NUL2E
condition|)
block|{
comment|/* We just released an l3, unhold the matching l2 */
name|pd_entry_t
modifier|*
name|l1
decl_stmt|,
name|tl1
decl_stmt|;
name|vm_page_t
name|l2pg
decl_stmt|;
name|l1
operator|=
name|pmap_l1
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|tl1
operator|=
name|pmap_load
argument_list|(
name|l1
argument_list|)
expr_stmt|;
name|l2pg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|tl1
operator|&
operator|~
name|ATTR_MASK
argument_list|)
expr_stmt|;
name|pmap_unwire_l3
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|l2pg
argument_list|,
name|free
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|pindex
operator|<
operator|(
name|NUL2E
operator|+
name|NUL1E
operator|)
condition|)
block|{
comment|/* We just released an l2, unhold the matching l1 */
name|pd_entry_t
modifier|*
name|l0
decl_stmt|,
name|tl0
decl_stmt|;
name|vm_page_t
name|l1pg
decl_stmt|;
name|l0
operator|=
name|pmap_l0
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|tl0
operator|=
name|pmap_load
argument_list|(
name|l0
argument_list|)
expr_stmt|;
name|l1pg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|tl0
operator|&
operator|~
name|ATTR_MASK
argument_list|)
expr_stmt|;
name|pmap_unwire_l3
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|l1pg
argument_list|,
name|free
argument_list|)
expr_stmt|;
block|}
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* 	 * This is a release store so that the ordinary store unmapping 	 * the page table page is globally performed before TLB shoot- 	 * down is begun. 	 */
name|atomic_subtract_rel_int
argument_list|(
operator|&
name|vm_cnt
operator|.
name|v_wire_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Put page on a list so that it is released after 	 * *ALL* TLB shootdown is done 	 */
name|pmap_add_delayed_free_list
argument_list|(
name|m
argument_list|,
name|free
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * After removing an l3 entry, this routine is used to  * conditionally free the page, and manage the hold/wire counts.  */
end_comment

begin_function
specifier|static
name|int
name|pmap_unuse_l3
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|pd_entry_t
name|ptepde
parameter_list|,
name|struct
name|spglist
modifier|*
name|free
parameter_list|)
block|{
name|vm_page_t
name|mpte
decl_stmt|;
if|if
condition|(
name|va
operator|>=
name|VM_MAXUSER_ADDRESS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|KASSERT
argument_list|(
name|ptepde
operator|!=
literal|0
argument_list|,
operator|(
literal|"pmap_unuse_pt: ptepde != 0"
operator|)
argument_list|)
expr_stmt|;
name|mpte
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|ptepde
operator|&
operator|~
name|ATTR_MASK
argument_list|)
expr_stmt|;
return|return
operator|(
name|pmap_unwire_l3
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|mpte
argument_list|,
name|free
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_pinit0
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|PMAP_LOCK_INIT
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pmap
operator|->
name|pm_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|pmap
operator|->
name|pm_stats
argument_list|)
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_l0
operator|=
name|kernel_pmap
operator|->
name|pm_l0
expr_stmt|;
name|pmap
operator|->
name|pm_root
operator|.
name|rt_root
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pmap_pinit
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|vm_paddr_t
name|l0phys
decl_stmt|;
name|vm_page_t
name|l0pt
decl_stmt|;
comment|/* 	 * allocate the l0 page 	 */
while|while
condition|(
operator|(
name|l0pt
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_WIRED
operator||
name|VM_ALLOC_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|VM_WAIT
expr_stmt|;
name|l0phys
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|l0pt
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_l0
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|l0phys
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l0pt
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
condition|)
name|pagezero
argument_list|(
name|pmap
operator|->
name|pm_l0
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_root
operator|.
name|rt_root
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pmap
operator|->
name|pm_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|pmap
operator|->
name|pm_stats
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine is called if the desired page table page does not exist.  *  * If page table page allocation fails, this routine may sleep before  * returning NULL.  It sleeps only if a lock pointer was given.  *  * Note: If a page allocation fails at page table level two or three,  * one or two pages may be held during the wait, only to be released  * afterwards.  This conservative approach is easily argued to avoid  * race conditions.  */
end_comment

begin_function
specifier|static
name|vm_page_t
name|_pmap_alloc_l3
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_pindex_t
name|ptepindex
parameter_list|,
name|struct
name|rwlock
modifier|*
modifier|*
name|lockp
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|,
name|l1pg
decl_stmt|,
name|l2pg
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate a page table page. 	 */
if|if
condition|(
operator|(
name|m
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
name|ptepindex
argument_list|,
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_WIRED
operator||
name|VM_ALLOC_ZERO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|lockp
operator|!=
name|NULL
condition|)
block|{
name|RELEASE_PV_LIST_LOCK
argument_list|(
name|lockp
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|VM_WAIT
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Indicate the need to retry.  While waiting, the page table 		 * page may have been allocated. 		 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
condition|)
name|pmap_zero_page
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Map the pagetable page into the process address space, if 	 * it isn't already there. 	 */
if|if
condition|(
name|ptepindex
operator|>=
operator|(
name|NUL2E
operator|+
name|NUL1E
operator|)
condition|)
block|{
name|pd_entry_t
modifier|*
name|l0
decl_stmt|;
name|vm_pindex_t
name|l0index
decl_stmt|;
name|l0index
operator|=
name|ptepindex
operator|-
operator|(
name|NUL2E
operator|+
name|NUL1E
operator|)
expr_stmt|;
name|l0
operator|=
operator|&
name|pmap
operator|->
name|pm_l0
index|[
name|l0index
index|]
expr_stmt|;
name|pmap_load_store
argument_list|(
name|l0
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator||
name|L0_TABLE
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|l0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptepindex
operator|>=
name|NUL2E
condition|)
block|{
name|vm_pindex_t
name|l0index
decl_stmt|,
name|l1index
decl_stmt|;
name|pd_entry_t
modifier|*
name|l0
decl_stmt|,
modifier|*
name|l1
decl_stmt|;
name|pd_entry_t
name|tl0
decl_stmt|;
name|l1index
operator|=
name|ptepindex
operator|-
name|NUL2E
expr_stmt|;
name|l0index
operator|=
name|l1index
operator|>>
name|L0_ENTRIES_SHIFT
expr_stmt|;
name|l0
operator|=
operator|&
name|pmap
operator|->
name|pm_l0
index|[
name|l0index
index|]
expr_stmt|;
name|tl0
operator|=
name|pmap_load
argument_list|(
name|l0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tl0
operator|==
literal|0
condition|)
block|{
comment|/* recurse for allocating page dir */
if|if
condition|(
name|_pmap_alloc_l3
argument_list|(
name|pmap
argument_list|,
name|NUL2E
operator|+
name|NUL1E
operator|+
name|l0index
argument_list|,
name|lockp
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|--
name|m
operator|->
name|wire_count
expr_stmt|;
comment|/* XXX: release mem barrier? */
name|atomic_subtract_int
argument_list|(
operator|&
name|vm_cnt
operator|.
name|v_wire_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vm_page_free_zero
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
name|l1pg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|tl0
operator|&
operator|~
name|ATTR_MASK
argument_list|)
expr_stmt|;
name|l1pg
operator|->
name|wire_count
operator|++
expr_stmt|;
block|}
name|l1
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|pmap_load
argument_list|(
name|l0
argument_list|)
operator|&
operator|~
name|ATTR_MASK
argument_list|)
expr_stmt|;
name|l1
operator|=
operator|&
name|l1
index|[
name|ptepindex
operator|&
name|Ln_ADDR_MASK
index|]
expr_stmt|;
name|pmap_load_store
argument_list|(
name|l1
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator||
name|L1_TABLE
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|l1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vm_pindex_t
name|l0index
decl_stmt|,
name|l1index
decl_stmt|;
name|pd_entry_t
modifier|*
name|l0
decl_stmt|,
modifier|*
name|l1
decl_stmt|,
modifier|*
name|l2
decl_stmt|;
name|pd_entry_t
name|tl0
decl_stmt|,
name|tl1
decl_stmt|;
name|l1index
operator|=
name|ptepindex
operator|>>
name|Ln_ENTRIES_SHIFT
expr_stmt|;
name|l0index
operator|=
name|l1index
operator|>>
name|L0_ENTRIES_SHIFT
expr_stmt|;
name|l0
operator|=
operator|&
name|pmap
operator|->
name|pm_l0
index|[
name|l0index
index|]
expr_stmt|;
name|tl0
operator|=
name|pmap_load
argument_list|(
name|l0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tl0
operator|==
literal|0
condition|)
block|{
comment|/* recurse for allocating page dir */
if|if
condition|(
name|_pmap_alloc_l3
argument_list|(
name|pmap
argument_list|,
name|NUL2E
operator|+
name|l1index
argument_list|,
name|lockp
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|--
name|m
operator|->
name|wire_count
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|vm_cnt
operator|.
name|v_wire_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vm_page_free_zero
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|tl0
operator|=
name|pmap_load
argument_list|(
name|l0
argument_list|)
expr_stmt|;
name|l1
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|tl0
operator|&
operator|~
name|ATTR_MASK
argument_list|)
expr_stmt|;
name|l1
operator|=
operator|&
name|l1
index|[
name|l1index
operator|&
name|Ln_ADDR_MASK
index|]
expr_stmt|;
block|}
else|else
block|{
name|l1
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|tl0
operator|&
operator|~
name|ATTR_MASK
argument_list|)
expr_stmt|;
name|l1
operator|=
operator|&
name|l1
index|[
name|l1index
operator|&
name|Ln_ADDR_MASK
index|]
expr_stmt|;
name|tl1
operator|=
name|pmap_load
argument_list|(
name|l1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tl1
operator|==
literal|0
condition|)
block|{
comment|/* recurse for allocating page dir */
if|if
condition|(
name|_pmap_alloc_l3
argument_list|(
name|pmap
argument_list|,
name|NUL2E
operator|+
name|l1index
argument_list|,
name|lockp
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|--
name|m
operator|->
name|wire_count
expr_stmt|;
comment|/* XXX: release mem barrier? */
name|atomic_subtract_int
argument_list|(
operator|&
name|vm_cnt
operator|.
name|v_wire_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vm_page_free_zero
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
name|l2pg
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|tl1
operator|&
operator|~
name|ATTR_MASK
argument_list|)
expr_stmt|;
name|l2pg
operator|->
name|wire_count
operator|++
expr_stmt|;
block|}
block|}
name|l2
operator|=
operator|(
name|pd_entry_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|pmap_load
argument_list|(
name|l1
argument_list|)
operator|&
operator|~
name|ATTR_MASK
argument_list|)
expr_stmt|;
name|l2
operator|=
operator|&
name|l2
index|[
name|ptepindex
operator|&
name|Ln_ADDR_MASK
index|]
expr_stmt|;
name|pmap_load_store
argument_list|(
name|l2
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator||
name|L2_TABLE
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|l2
argument_list|)
expr_stmt|;
block|}
name|pmap_resident_count_inc
argument_list|(
name|pmap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|vm_page_t
name|pmap_alloc_l3
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|struct
name|rwlock
modifier|*
modifier|*
name|lockp
parameter_list|)
block|{
name|vm_pindex_t
name|ptepindex
decl_stmt|;
name|pd_entry_t
modifier|*
name|pde
decl_stmt|,
name|tpde
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
endif|#
directive|endif
name|vm_page_t
name|m
decl_stmt|;
name|int
name|lvl
decl_stmt|;
comment|/* 	 * Calculate pagetable page index 	 */
name|ptepindex
operator|=
name|pmap_l2_pindex
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|retry
label|:
comment|/* 	 * Get the page directory entry 	 */
name|pde
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
comment|/* 	 * If the page table page is mapped, we just increment the hold count, 	 * and activate it. If we get a level 2 pde it will point to a level 3 	 * table. 	 */
switch|switch
condition|(
name|lvl
condition|)
block|{
case|case
operator|-
literal|1
case|:
break|break;
case|case
literal|0
case|:
ifdef|#
directive|ifdef
name|INVARIANTS
name|pte
operator|=
name|pmap_l0_to_l1
argument_list|(
name|pde
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pmap_load
argument_list|(
name|pte
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_alloc_l3: TODO: l0 superpages"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|1
case|:
ifdef|#
directive|ifdef
name|INVARIANTS
name|pte
operator|=
name|pmap_l1_to_l2
argument_list|(
name|pde
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pmap_load
argument_list|(
name|pte
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_alloc_l3: TODO: l1 superpages"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|2
case|:
name|tpde
operator|=
name|pmap_load
argument_list|(
name|pde
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpde
operator|!=
literal|0
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|tpde
operator|&
operator|~
name|ATTR_MASK
argument_list|)
expr_stmt|;
name|m
operator|->
name|wire_count
operator|++
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
break|break;
default|default:
name|panic
argument_list|(
literal|"pmap_alloc_l3: Invalid level %d"
argument_list|,
name|lvl
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Here if the pte page isn't mapped, or if it has been deallocated. 	 */
name|m
operator|=
name|_pmap_alloc_l3
argument_list|(
name|pmap
argument_list|,
name|ptepindex
argument_list|,
name|lockp
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
operator|&&
name|lockp
operator|!=
name|NULL
condition|)
goto|goto
name|retry
goto|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************  * Pmap allocation/deallocation routines.  ***************************************************/
end_comment

begin_comment
comment|/*  * Release any resources held by the given physical map.  * Called when a pmap initialized by pmap_pinit is being released.  * Should only be called if the map contains no valid mappings.  */
end_comment

begin_function
name|void
name|pmap_release
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|KASSERT
argument_list|(
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_release: pmap resident count %ld != 0"
operator|,
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vm_radix_is_empty
argument_list|(
operator|&
name|pmap
operator|->
name|pm_root
argument_list|)
argument_list|,
operator|(
literal|"pmap_release: pmap has reserved page table page(s)"
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|DMAP_TO_PHYS
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pmap
operator|->
name|pm_l0
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|wire_count
operator|--
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|vm_cnt
operator|.
name|v_wire_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vm_page_free_zero
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|kvm_size
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|unsigned
name|long
name|ksize
init|=
name|VM_MAX_KERNEL_ADDRESS
operator|-
name|VM_MIN_KERNEL_ADDRESS
decl_stmt|;
return|return
name|sysctl_handle_long
argument_list|(
name|oidp
argument_list|,
operator|&
name|ksize
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|kvm_size
argument_list|,
name|CTLTYPE_LONG
operator||
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|kvm_size
argument_list|,
literal|"LU"
argument_list|,
literal|"Size of KVM"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|kvm_free
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|unsigned
name|long
name|kfree
init|=
name|VM_MAX_KERNEL_ADDRESS
operator|-
name|kernel_vm_end
decl_stmt|;
return|return
name|sysctl_handle_long
argument_list|(
name|oidp
argument_list|,
operator|&
name|kfree
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_vm
argument_list|,
name|OID_AUTO
argument_list|,
name|kvm_free
argument_list|,
name|CTLTYPE_LONG
operator||
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|kvm_free
argument_list|,
literal|"LU"
argument_list|,
literal|"Amount of KVM free"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * grow the number of kernel page table entries, if needed  */
end_comment

begin_function
name|void
name|pmap_growkernel
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|vm_paddr_t
name|paddr
decl_stmt|;
name|vm_page_t
name|nkpg
decl_stmt|;
name|pd_entry_t
modifier|*
name|l0
decl_stmt|,
modifier|*
name|l1
decl_stmt|,
modifier|*
name|l2
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|kernel_map
operator|->
name|system_mtx
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|addr
operator|=
name|roundup2
argument_list|(
name|addr
argument_list|,
name|L2_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|-
literal|1
operator|>=
name|kernel_map
operator|->
name|max_offset
condition|)
name|addr
operator|=
name|kernel_map
operator|->
name|max_offset
expr_stmt|;
while|while
condition|(
name|kernel_vm_end
operator|<
name|addr
condition|)
block|{
name|l0
operator|=
name|pmap_l0
argument_list|(
name|kernel_pmap
argument_list|,
name|kernel_vm_end
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pmap_load
argument_list|(
name|l0
argument_list|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"pmap_growkernel: No level 0 kernel entry"
operator|)
argument_list|)
expr_stmt|;
name|l1
operator|=
name|pmap_l0_to_l1
argument_list|(
name|l0
argument_list|,
name|kernel_vm_end
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_load
argument_list|(
name|l1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* We need a new PDP entry */
name|nkpg
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
name|kernel_vm_end
operator|>>
name|L1_SHIFT
argument_list|,
name|VM_ALLOC_INTERRUPT
operator||
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_WIRED
operator||
name|VM_ALLOC_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nkpg
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_growkernel: no memory to grow kernel"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nkpg
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
condition|)
name|pmap_zero_page
argument_list|(
name|nkpg
argument_list|)
expr_stmt|;
name|paddr
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|nkpg
argument_list|)
expr_stmt|;
name|pmap_load_store
argument_list|(
name|l1
argument_list|,
name|paddr
operator||
name|L1_TABLE
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|l1
argument_list|)
expr_stmt|;
continue|continue;
comment|/* try again */
block|}
name|l2
operator|=
name|pmap_l1_to_l2
argument_list|(
name|l1
argument_list|,
name|kernel_vm_end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pmap_load
argument_list|(
name|l2
argument_list|)
operator|&
name|ATTR_AF
operator|)
operator|!=
literal|0
condition|)
block|{
name|kernel_vm_end
operator|=
operator|(
name|kernel_vm_end
operator|+
name|L2_SIZE
operator|)
operator|&
operator|~
name|L2_OFFSET
expr_stmt|;
if|if
condition|(
name|kernel_vm_end
operator|-
literal|1
operator|>=
name|kernel_map
operator|->
name|max_offset
condition|)
block|{
name|kernel_vm_end
operator|=
name|kernel_map
operator|->
name|max_offset
expr_stmt|;
break|break;
block|}
continue|continue;
block|}
name|nkpg
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
name|kernel_vm_end
operator|>>
name|L2_SHIFT
argument_list|,
name|VM_ALLOC_INTERRUPT
operator||
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_WIRED
operator||
name|VM_ALLOC_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nkpg
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_growkernel: no memory to grow kernel"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nkpg
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
condition|)
name|pmap_zero_page
argument_list|(
name|nkpg
argument_list|)
expr_stmt|;
name|paddr
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|nkpg
argument_list|)
expr_stmt|;
name|pmap_load_store
argument_list|(
name|l2
argument_list|,
name|paddr
operator||
name|L2_TABLE
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|l2
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|kernel_pmap
argument_list|,
name|kernel_vm_end
argument_list|)
expr_stmt|;
name|kernel_vm_end
operator|=
operator|(
name|kernel_vm_end
operator|+
name|L2_SIZE
operator|)
operator|&
operator|~
name|L2_OFFSET
expr_stmt|;
if|if
condition|(
name|kernel_vm_end
operator|-
literal|1
operator|>=
name|kernel_map
operator|->
name|max_offset
condition|)
block|{
name|kernel_vm_end
operator|=
name|kernel_map
operator|->
name|max_offset
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/***************************************************  * page management routines.  ***************************************************/
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pv_chunk
argument_list|)
operator|==
name|PAGE_SIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|_NPCM
operator|==
literal|3
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
name|_NPCPV
operator|==
literal|168
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|pv_chunk
operator|*
name|pv_to_chunk
argument_list|(
argument|pv_entry_t pv
argument_list|)
block|{
return|return
operator|(
operator|(
expr|struct
name|pv_chunk
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|pv
operator|&
operator|~
operator|(
name|uintptr_t
operator|)
name|PAGE_MASK
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_define
define|#
directive|define
name|PV_PMAP
parameter_list|(
name|pv
parameter_list|)
value|(pv_to_chunk(pv)->pc_pmap)
end_define

begin_define
define|#
directive|define
name|PC_FREE0
value|0xfffffffffffffffful
end_define

begin_define
define|#
directive|define
name|PC_FREE1
value|0xfffffffffffffffful
end_define

begin_define
define|#
directive|define
name|PC_FREE2
value|0x000000fffffffffful
end_define

begin_decl_stmt
specifier|static
specifier|const
name|uint64_t
name|pc_freemask
index|[
name|_NPCM
index|]
init|=
block|{
name|PC_FREE0
block|,
name|PC_FREE1
block|,
name|PC_FREE2
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|PV_STATS
end_ifdef

begin_endif
unit|static int pc_chunk_count, pc_chunk_allocs, pc_chunk_frees, pc_chunk_tryfail;  SYSCTL_INT(_vm_pmap, OID_AUTO, pc_chunk_count, CTLFLAG_RD,&pc_chunk_count, 0, 	"Current number of pv entry chunks"); SYSCTL_INT(_vm_pmap, OID_AUTO, pc_chunk_allocs, CTLFLAG_RD,&pc_chunk_allocs, 0, 	"Current number of pv entry chunks allocated"); SYSCTL_INT(_vm_pmap, OID_AUTO, pc_chunk_frees, CTLFLAG_RD,&pc_chunk_frees, 0, 	"Current number of pv entry chunks frees"); SYSCTL_INT(_vm_pmap, OID_AUTO, pc_chunk_tryfail, CTLFLAG_RD,&pc_chunk_tryfail, 0, 	"Number of times tried to get a chunk page but failed.");  static long pv_entry_frees, pv_entry_allocs, pv_entry_count; static int pv_entry_spare;  SYSCTL_LONG(_vm_pmap, OID_AUTO, pv_entry_frees, CTLFLAG_RD,&pv_entry_frees, 0, 	"Current number of pv entry frees"); SYSCTL_LONG(_vm_pmap, OID_AUTO, pv_entry_allocs, CTLFLAG_RD,&pv_entry_allocs, 0, 	"Current number of pv entry allocs"); SYSCTL_LONG(_vm_pmap, OID_AUTO, pv_entry_count, CTLFLAG_RD,&pv_entry_count, 0, 	"Current number of pv entries"); SYSCTL_INT(_vm_pmap, OID_AUTO, pv_entry_spare, CTLFLAG_RD,&pv_entry_spare, 0, 	"Current number of spare pv entries");
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

begin_comment
comment|/*  * We are in a serious low memory condition.  Resort to  * drastic measures to free some pages so we can allocate  * another pv entry chunk.  *  * Returns NULL if PV entries were reclaimed from the specified pmap.  *  * We do not, however, unmap 2mpages because subsequent accesses will  * allocate per-page pv entries until repromotion occurs, thereby  * exacerbating the shortage of free pv entries.  */
end_comment

begin_function
specifier|static
name|vm_page_t
name|reclaim_pv_chunk
parameter_list|(
name|pmap_t
name|locked_pmap
parameter_list|,
name|struct
name|rwlock
modifier|*
modifier|*
name|lockp
parameter_list|)
block|{
name|panic
argument_list|(
literal|"ARM64TODO: reclaim_pv_chunk"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * free the pv_entry back to the free list  */
end_comment

begin_function
specifier|static
name|void
name|free_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pv_entry_t
name|pv
parameter_list|)
block|{
name|struct
name|pv_chunk
modifier|*
name|pc
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|field
decl_stmt|,
name|bit
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|atomic_add_long
argument_list|(
operator|&
name|pv_entry_frees
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|atomic_add_int
argument_list|(
operator|&
name|pv_entry_spare
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|atomic_subtract_long
argument_list|(
operator|&
name|pv_entry_count
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|pc
operator|=
name|pv_to_chunk
argument_list|(
name|pv
argument_list|)
expr_stmt|;
name|idx
operator|=
name|pv
operator|-
operator|&
name|pc
operator|->
name|pc_pventry
index|[
literal|0
index|]
expr_stmt|;
name|field
operator|=
name|idx
operator|/
literal|64
expr_stmt|;
name|bit
operator|=
name|idx
operator|%
literal|64
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator||=
literal|1ul
operator|<<
name|bit
expr_stmt|;
if|if
condition|(
name|pc
operator|->
name|pc_map
index|[
literal|0
index|]
operator|!=
name|PC_FREE0
operator|||
name|pc
operator|->
name|pc_map
index|[
literal|1
index|]
operator|!=
name|PC_FREE1
operator|||
name|pc
operator|->
name|pc_map
index|[
literal|2
index|]
operator|!=
name|PC_FREE2
condition|)
block|{
comment|/* 98% of the time, pc is already at the head of the list. */
if|if
condition|(
name|__predict_false
argument_list|(
name|pc
operator|!=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|)
argument_list|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|free_pv_chunk
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_pv_chunk
parameter_list|(
name|struct
name|pv_chunk
modifier|*
name|pc
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|pv_chunks_mutex
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pv_chunks
argument_list|,
name|pc
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pv_chunks_mutex
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|atomic_subtract_int
argument_list|(
operator|&
name|pv_entry_spare
argument_list|,
name|_NPCPV
argument_list|)
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|atomic_subtract_int
argument_list|(
operator|&
name|pc_chunk_count
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|atomic_add_int
argument_list|(
operator|&
name|pc_chunk_frees
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* entire chunk is free, return it */
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|DMAP_TO_PHYS
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pc
argument_list|)
argument_list|)
expr_stmt|;
name|dump_drop_page
argument_list|(
name|m
operator|->
name|phys_addr
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|m
argument_list|,
name|PQ_NONE
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns a new PV entry, allocating a new PV chunk from the system when  * needed.  If this PV chunk allocation fails and a PV list lock pointer was  * given, a PV chunk is reclaimed from an arbitrary pmap.  Otherwise, NULL is  * returned.  *  * The given PV list lock may be released.  */
end_comment

begin_function
specifier|static
name|pv_entry_t
name|get_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|struct
name|rwlock
modifier|*
modifier|*
name|lockp
parameter_list|)
block|{
name|int
name|bit
decl_stmt|,
name|field
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|struct
name|pv_chunk
modifier|*
name|pc
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|atomic_add_long
argument_list|(
operator|&
name|pv_entry_allocs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|retry
label|:
name|pc
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|field
operator|=
literal|0
init|;
name|field
operator|<
name|_NPCM
condition|;
name|field
operator|++
control|)
block|{
if|if
condition|(
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
condition|)
block|{
name|bit
operator|=
name|ffsl
argument_list|(
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|field
operator|<
name|_NPCM
condition|)
block|{
name|pv
operator|=
operator|&
name|pc
operator|->
name|pc_pventry
index|[
name|field
operator|*
literal|64
operator|+
name|bit
index|]
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator|&=
operator|~
operator|(
literal|1ul
operator|<<
name|bit
operator|)
expr_stmt|;
comment|/* If this was the last item, move it to tail */
if|if
condition|(
name|pc
operator|->
name|pc_map
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|pc
operator|->
name|pc_map
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|pc
operator|->
name|pc_map
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
block|}
name|PV_STAT
argument_list|(
name|atomic_add_long
argument_list|(
operator|&
name|pv_entry_count
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|atomic_subtract_int
argument_list|(
operator|&
name|pv_entry_spare
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|pv
operator|)
return|;
block|}
block|}
comment|/* No free items, allocate another chunk */
name|m
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_WIRED
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|lockp
operator|==
name|NULL
condition|)
block|{
name|PV_STAT
argument_list|(
name|pc_chunk_tryfail
operator|++
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|m
operator|=
name|reclaim_pv_chunk
argument_list|(
name|pmap
argument_list|,
name|lockp
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|retry
goto|;
block|}
name|PV_STAT
argument_list|(
name|atomic_add_int
argument_list|(
operator|&
name|pc_chunk_count
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|atomic_add_int
argument_list|(
operator|&
name|pc_chunk_allocs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dump_add_page
argument_list|(
name|m
operator|->
name|phys_addr
argument_list|)
expr_stmt|;
name|pc
operator|=
operator|(
name|void
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|m
operator|->
name|phys_addr
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_pmap
operator|=
name|pmap
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
literal|0
index|]
operator|=
name|PC_FREE0
operator|&
operator|~
literal|1ul
expr_stmt|;
comment|/* preallocated bit 0 */
name|pc
operator|->
name|pc_map
index|[
literal|1
index|]
operator|=
name|PC_FREE1
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
literal|2
index|]
operator|=
name|PC_FREE2
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|pv_chunks_mutex
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pv_chunks
argument_list|,
name|pc
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pv_chunks_mutex
argument_list|)
expr_stmt|;
name|pv
operator|=
operator|&
name|pc
operator|->
name|pc_pventry
index|[
literal|0
index|]
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|atomic_add_long
argument_list|(
operator|&
name|pv_entry_count
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|atomic_add_int
argument_list|(
operator|&
name|pv_entry_spare
argument_list|,
name|_NPCPV
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|pv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Ensure that the number of spare PV entries in the specified pmap meets or  * exceeds the given count, "needed".  *  * The given PV list lock may be released.  */
end_comment

begin_function
specifier|static
name|void
name|reserve_pv_entries
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|int
name|needed
parameter_list|,
name|struct
name|rwlock
modifier|*
modifier|*
name|lockp
parameter_list|)
block|{
name|struct
name|pch
name|new_tail
decl_stmt|;
name|struct
name|pv_chunk
modifier|*
name|pc
decl_stmt|;
name|int
name|avail
decl_stmt|,
name|free
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lockp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"reserve_pv_entries: lockp is NULL"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Newly allocated PV chunks must be stored in a private list until 	 * the required number of PV chunks have been allocated.  Otherwise, 	 * reclaim_pv_chunk() could recycle one of these chunks.  In 	 * contrast, these chunks must be added to the pmap upon allocation. 	 */
name|TAILQ_INIT
argument_list|(
operator|&
name|new_tail
argument_list|)
expr_stmt|;
name|retry
label|:
name|avail
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pc
argument_list|,
argument|&pmap->pm_pvchunk
argument_list|,
argument|pc_list
argument_list|)
block|{
name|bit_count
argument_list|(
operator|(
name|bitstr_t
operator|*
operator|)
name|pc
operator|->
name|pc_map
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pc
operator|->
name|pc_map
argument_list|)
operator|*
name|NBBY
argument_list|,
operator|&
name|free
argument_list|)
expr_stmt|;
if|if
condition|(
name|free
operator|==
literal|0
condition|)
break|break;
name|avail
operator|+=
name|free
expr_stmt|;
if|if
condition|(
name|avail
operator|>=
name|needed
condition|)
break|break;
block|}
for|for
control|(
init|;
name|avail
operator|<
name|needed
condition|;
name|avail
operator|+=
name|_NPCPV
control|)
block|{
name|m
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_WIRED
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
name|reclaim_pv_chunk
argument_list|(
name|pmap
argument_list|,
name|lockp
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|retry
goto|;
block|}
name|PV_STAT
argument_list|(
name|atomic_add_int
argument_list|(
operator|&
name|pc_chunk_count
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|atomic_add_int
argument_list|(
operator|&
name|pc_chunk_allocs
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|dump_add_page
argument_list|(
name|m
operator|->
name|phys_addr
argument_list|)
expr_stmt|;
name|pc
operator|=
operator|(
name|void
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|m
operator|->
name|phys_addr
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_pmap
operator|=
name|pmap
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
literal|0
index|]
operator|=
name|PC_FREE0
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
literal|1
index|]
operator|=
name|PC_FREE1
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
literal|2
index|]
operator|=
name|PC_FREE2
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|new_tail
argument_list|,
name|pc
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|atomic_add_int
argument_list|(
operator|&
name|pv_entry_spare
argument_list|,
name|_NPCPV
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|new_tail
argument_list|)
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|pv_chunks_mutex
argument_list|)
expr_stmt|;
name|TAILQ_CONCAT
argument_list|(
operator|&
name|pv_chunks
argument_list|,
operator|&
name|new_tail
argument_list|,
name|pc_lru
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|pv_chunks_mutex
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * First find and then remove the pv entry for the specified pmap and virtual  * address from the specified pv list.  Returns the pv entry if found and NULL  * otherwise.  This operation can be performed on pv lists for either 4KB or  * 2MB page mappings.  */
end_comment

begin_function
specifier|static
name|__inline
name|pv_entry_t
name|pmap_pvh_remove
parameter_list|(
name|struct
name|md_page
modifier|*
name|pvh
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&pvh->pv_list
argument_list|,
argument|pv_next
argument_list|)
block|{
if|if
condition|(
name|pmap
operator|==
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
operator|&&
name|va
operator|==
name|pv
operator|->
name|pv_va
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pvh
operator|->
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_next
argument_list|)
expr_stmt|;
name|pvh
operator|->
name|pv_gen
operator|++
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|pv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * After demotion from a 2MB page mapping to 512 4KB page mappings,  * destroy the pv entry for the 2MB page mapping and reinstantiate the pv  * entries for each of the 4KB page mappings.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_pv_demote_l2
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|,
name|struct
name|rwlock
modifier|*
modifier|*
name|lockp
parameter_list|)
block|{
name|struct
name|md_page
modifier|*
name|pvh
decl_stmt|;
name|struct
name|pv_chunk
modifier|*
name|pc
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|vm_offset_t
name|va_last
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|bit
decl_stmt|,
name|field
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|pa
operator|&
name|L2_OFFSET
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_pv_demote_l2: pa is not 2mpage aligned"
operator|)
argument_list|)
expr_stmt|;
name|CHANGE_PV_LIST_LOCK_TO_PHYS
argument_list|(
name|lockp
argument_list|,
name|pa
argument_list|)
expr_stmt|;
comment|/* 	 * Transfer the 2mpage's pv entry for this mapping to the first 	 * page's pv list.  Once this transfer begins, the pv list lock 	 * must not be released until the last pv entry is reinstantiated. 	 */
name|pvh
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|va
operator|=
name|va
operator|&
operator|~
name|L2_OFFSET
expr_stmt|;
name|pv
operator|=
name|pmap_pvh_remove
argument_list|(
name|pvh
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pv
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_pv_demote_l2: pv not found"
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_next
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_gen
operator|++
expr_stmt|;
comment|/* Instantiate the remaining Ln_ENTRIES - 1 pv entries. */
name|PV_STAT
argument_list|(
name|atomic_add_long
argument_list|(
operator|&
name|pv_entry_allocs
argument_list|,
name|Ln_ENTRIES
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|va_last
operator|=
name|va
operator|+
name|L2_SIZE
operator|-
name|PAGE_SIZE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|pc
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pc
operator|->
name|pc_map
index|[
literal|0
index|]
operator|!=
literal|0
operator|||
name|pc
operator|->
name|pc_map
index|[
literal|1
index|]
operator|!=
literal|0
operator|||
name|pc
operator|->
name|pc_map
index|[
literal|2
index|]
operator|!=
literal|0
argument_list|,
operator|(
literal|"pmap_pv_demote_l2: missing spare"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|field
operator|=
literal|0
init|;
name|field
operator|<
name|_NPCM
condition|;
name|field
operator|++
control|)
block|{
while|while
condition|(
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
condition|)
block|{
name|bit
operator|=
name|ffsl
argument_list|(
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator|&=
operator|~
operator|(
literal|1ul
operator|<<
name|bit
operator|)
expr_stmt|;
name|pv
operator|=
operator|&
name|pc
operator|->
name|pc_pventry
index|[
name|field
operator|*
literal|64
operator|+
name|bit
index|]
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|pv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|m
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_pv_demote_l2: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_next
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_gen
operator|++
expr_stmt|;
if|if
condition|(
name|va
operator|==
name|va_last
condition|)
goto|goto
name|out
goto|;
block|}
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|pc
operator|->
name|pc_map
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|pc
operator|->
name|pc_map
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|pc
operator|->
name|pc_map
index|[
literal|2
index|]
operator|==
literal|0
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
block|}
name|PV_STAT
argument_list|(
name|atomic_add_long
argument_list|(
operator|&
name|pv_entry_count
argument_list|,
name|Ln_ENTRIES
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|atomic_subtract_int
argument_list|(
operator|&
name|pv_entry_spare
argument_list|,
name|Ln_ENTRIES
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * First find and then destroy the pv entry for the specified pmap and virtual  * address.  This operation can be performed on pv lists for either 4KB or 2MB  * page mappings.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_pvh_free
parameter_list|(
name|struct
name|md_page
modifier|*
name|pvh
parameter_list|,
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|pv
operator|=
name|pmap_pvh_remove
argument_list|(
name|pvh
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pv
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_pvh_free: pv not found"
operator|)
argument_list|)
expr_stmt|;
name|free_pv_entry
argument_list|(
name|pmap
argument_list|,
name|pv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Conditionally create the PV entry for a 4KB page mapping if the required  * memory can be allocated without resorting to reclamation.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|pmap_try_insert_pv_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|struct
name|rwlock
modifier|*
modifier|*
name|lockp
parameter_list|)
block|{
name|pv_entry_t
name|pv
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* Pass NULL instead of the lock pointer to disable reclamation. */
if|if
condition|(
operator|(
name|pv
operator|=
name|get_pv_entry
argument_list|(
name|pmap
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|CHANGE_PV_LIST_LOCK_TO_VM_PAGE
argument_list|(
name|lockp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_next
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_gen
operator|++
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
else|else
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * pmap_remove_l3: do the things to unmap a page in a process  */
end_comment

begin_function
specifier|static
name|int
name|pmap_remove_l3
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pt_entry_t
modifier|*
name|l3
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|pd_entry_t
name|l2e
parameter_list|,
name|struct
name|spglist
modifier|*
name|free
parameter_list|,
name|struct
name|rwlock
modifier|*
modifier|*
name|lockp
parameter_list|)
block|{
name|struct
name|md_page
modifier|*
name|pvh
decl_stmt|;
name|pt_entry_t
name|old_l3
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_is_current
argument_list|(
name|pmap
argument_list|)
operator|&&
name|pmap_l3_valid_cacheable
argument_list|(
name|pmap_load
argument_list|(
name|l3
argument_list|)
argument_list|)
condition|)
name|cpu_dcache_wb_range
argument_list|(
name|va
argument_list|,
name|L3_SIZE
argument_list|)
expr_stmt|;
name|old_l3
operator|=
name|pmap_load_clear
argument_list|(
name|l3
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|l3
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_l3
operator|&
name|ATTR_SW_WIRED
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|-=
literal|1
expr_stmt|;
name|pmap_resident_count_dec
argument_list|(
name|pmap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_l3
operator|&
name|ATTR_SW_MANAGED
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|old_l3
operator|&
operator|~
name|ATTR_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_page_dirty
argument_list|(
name|old_l3
argument_list|)
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_l3
operator|&
name|ATTR_AF
condition|)
name|vm_page_aflag_set
argument_list|(
name|m
argument_list|,
name|PGA_REFERENCED
argument_list|)
expr_stmt|;
name|CHANGE_PV_LIST_LOCK_TO_VM_PAGE
argument_list|(
name|lockp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|pmap_pvh_free
argument_list|(
operator|&
name|m
operator|->
name|md
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|&&
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
condition|)
block|{
name|pvh
operator|=
name|pa_to_pvh
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|pvh
operator|->
name|pv_list
argument_list|)
condition|)
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|pmap_unuse_l3
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|l2e
argument_list|,
name|free
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Remove the given range of addresses from the specified map.  *  *	It is assumed that the start and end are properly  *	rounded to the page size.  */
end_comment

begin_function
name|void
name|pmap_remove
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|)
block|{
name|struct
name|rwlock
modifier|*
name|lock
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|,
name|va_next
decl_stmt|;
name|pd_entry_t
modifier|*
name|l0
decl_stmt|,
modifier|*
name|l1
decl_stmt|,
modifier|*
name|l2
decl_stmt|;
name|pt_entry_t
name|l3_paddr
decl_stmt|,
modifier|*
name|l3
decl_stmt|;
name|struct
name|spglist
name|free
decl_stmt|;
name|int
name|anyvalid
decl_stmt|;
comment|/* 	 * Perform an unsynchronized read.  This is, however, safe. 	 */
if|if
condition|(
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|==
literal|0
condition|)
return|return;
name|anyvalid
operator|=
literal|0
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|free
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|lock
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
name|sva
operator|<
name|eva
condition|;
name|sva
operator|=
name|va_next
control|)
block|{
if|if
condition|(
name|pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|==
literal|0
condition|)
break|break;
name|l0
operator|=
name|pmap_l0
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_load
argument_list|(
name|l0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|va_next
operator|=
operator|(
name|sva
operator|+
name|L0_SIZE
operator|)
operator|&
operator|~
name|L0_OFFSET
expr_stmt|;
if|if
condition|(
name|va_next
operator|<
name|sva
condition|)
name|va_next
operator|=
name|eva
expr_stmt|;
continue|continue;
block|}
name|l1
operator|=
name|pmap_l0_to_l1
argument_list|(
name|l0
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_load
argument_list|(
name|l1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|va_next
operator|=
operator|(
name|sva
operator|+
name|L1_SIZE
operator|)
operator|&
operator|~
name|L1_OFFSET
expr_stmt|;
if|if
condition|(
name|va_next
operator|<
name|sva
condition|)
name|va_next
operator|=
name|eva
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Calculate index for next page table. 		 */
name|va_next
operator|=
operator|(
name|sva
operator|+
name|L2_SIZE
operator|)
operator|&
operator|~
name|L2_OFFSET
expr_stmt|;
if|if
condition|(
name|va_next
operator|<
name|sva
condition|)
name|va_next
operator|=
name|eva
expr_stmt|;
name|l2
operator|=
name|pmap_l1_to_l2
argument_list|(
name|l1
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2
operator|==
name|NULL
condition|)
continue|continue;
name|l3_paddr
operator|=
name|pmap_load
argument_list|(
name|l2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l3_paddr
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L2_BLOCK
condition|)
block|{
comment|/* TODO: Add pmap_remove_l2 */
if|if
condition|(
name|pmap_demote_l2_locked
argument_list|(
name|pmap
argument_list|,
name|l2
argument_list|,
name|sva
operator|&
operator|~
name|L2_OFFSET
argument_list|,
operator|&
name|lock
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
name|l3_paddr
operator|=
name|pmap_load
argument_list|(
name|l2
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Weed out invalid mappings. 		 */
if|if
condition|(
operator|(
name|l3_paddr
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|!=
name|L2_TABLE
condition|)
continue|continue;
comment|/* 		 * Limit our scan to either the end of the va represented 		 * by the current page table page, or to the end of the 		 * range being removed. 		 */
if|if
condition|(
name|va_next
operator|>
name|eva
condition|)
name|va_next
operator|=
name|eva
expr_stmt|;
name|va
operator|=
name|va_next
expr_stmt|;
for|for
control|(
name|l3
operator|=
name|pmap_l2_to_l3
argument_list|(
name|l2
argument_list|,
name|sva
argument_list|)
init|;
name|sva
operator|!=
name|va_next
condition|;
name|l3
operator|++
operator|,
name|sva
operator|+=
name|L3_SIZE
control|)
block|{
if|if
condition|(
name|l3
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"l3 == NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_load
argument_list|(
name|l3
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|va
operator|!=
name|va_next
condition|)
block|{
name|pmap_invalidate_range
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|sva
argument_list|)
expr_stmt|;
name|va
operator|=
name|va_next
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|va
operator|==
name|va_next
condition|)
name|va
operator|=
name|sva
expr_stmt|;
if|if
condition|(
name|pmap_remove_l3
argument_list|(
name|pmap
argument_list|,
name|l3
argument_list|,
name|sva
argument_list|,
name|l3_paddr
argument_list|,
operator|&
name|free
argument_list|,
operator|&
name|lock
argument_list|)
condition|)
block|{
name|sva
operator|+=
name|L3_SIZE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|va
operator|!=
name|va_next
condition|)
name|pmap_invalidate_range
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|sva
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lock
operator|!=
name|NULL
condition|)
name|rw_wunlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|anyvalid
condition|)
name|pmap_invalidate_all
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pmap_free_zero_pages
argument_list|(
operator|&
name|free
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Routine:	pmap_remove_all  *	Function:  *		Removes this physical page from  *		all physical maps in which it resides.  *		Reflects back modify bits to the pager.  *  *	Notes:  *		Original versions of this routine were very  *		inefficient because they iteratively called  *		pmap_remove (slow...)  */
end_comment

begin_function
name|void
name|pmap_remove_all
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|md_page
modifier|*
name|pvh
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|struct
name|rwlock
modifier|*
name|lock
decl_stmt|;
name|pd_entry_t
modifier|*
name|pde
decl_stmt|,
name|tpde
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
name|tpte
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|struct
name|spglist
name|free
decl_stmt|;
name|int
name|lvl
decl_stmt|,
name|pvh_gen
decl_stmt|,
name|md_gen
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_remove_all: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|free
argument_list|)
expr_stmt|;
name|lock
operator|=
name|VM_PAGE_TO_PV_LIST_LOCK
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pvh
operator|=
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|!=
literal|0
condition|?
operator|&
name|pv_dummy
else|:
name|pa_to_pvh
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|retry
label|:
name|rw_wlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pvh
operator|->
name|pv_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PMAP_TRYLOCK
argument_list|(
name|pmap
argument_list|)
condition|)
block|{
name|pvh_gen
operator|=
name|pvh
operator|->
name|pv_gen
expr_stmt|;
name|rw_wunlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvh_gen
operator|!=
name|pvh
operator|->
name|pv_gen
condition|)
block|{
name|rw_wunlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
name|va
operator|=
name|pv
operator|->
name|pv_va
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pte
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_remove_all: no page table entry found"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lvl
operator|==
literal|2
argument_list|,
operator|(
literal|"pmap_remove_all: invalid pte level %d"
operator|,
name|lvl
operator|)
argument_list|)
expr_stmt|;
name|pmap_demote_l2_locked
argument_list|(
name|pmap
argument_list|,
name|pte
argument_list|,
name|va
argument_list|,
operator|&
name|lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PMAP_TRYLOCK
argument_list|(
name|pmap
argument_list|)
condition|)
block|{
name|pvh_gen
operator|=
name|pvh
operator|->
name|pv_gen
expr_stmt|;
name|md_gen
operator|=
name|m
operator|->
name|md
operator|.
name|pv_gen
expr_stmt|;
name|rw_wunlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvh_gen
operator|!=
name|pvh
operator|->
name|pv_gen
operator|||
name|md_gen
operator|!=
name|m
operator|->
name|md
operator|.
name|pv_gen
condition|)
block|{
name|rw_wunlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
name|pmap_resident_count_dec
argument_list|(
name|pmap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pde
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pde
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_remove_all: no page directory entry found"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lvl
operator|==
literal|2
argument_list|,
operator|(
literal|"pmap_remove_all: invalid pde level %d"
operator|,
name|lvl
operator|)
argument_list|)
expr_stmt|;
name|tpde
operator|=
name|pmap_load
argument_list|(
name|pde
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_l2_to_l3
argument_list|(
name|pde
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|tpte
operator|=
name|pmap_load
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_is_current
argument_list|(
name|pmap
argument_list|)
operator|&&
name|pmap_l3_valid_cacheable
argument_list|(
name|tpte
argument_list|)
condition|)
name|cpu_dcache_wb_range
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|,
name|L3_SIZE
argument_list|)
expr_stmt|;
name|pmap_load_clear
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpte
operator|&
name|ATTR_SW_WIRED
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|tpte
operator|&
name|ATTR_AF
operator|)
operator|!=
literal|0
condition|)
name|vm_page_aflag_set
argument_list|(
name|m
argument_list|,
name|PGA_REFERENCED
argument_list|)
expr_stmt|;
comment|/* 		 * Update the vm_page_t clean and reference bits. 		 */
if|if
condition|(
name|pmap_page_dirty
argument_list|(
name|tpte
argument_list|)
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pmap_unuse_l3
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|tpde
argument_list|,
operator|&
name|free
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_next
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_gen
operator|++
expr_stmt|;
name|free_pv_entry
argument_list|(
name|pmap
argument_list|,
name|pv
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|pmap_free_zero_pages
argument_list|(
operator|&
name|free
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Set the physical protection on the  *	specified range of this map as requested.  */
end_comment

begin_function
name|void
name|pmap_protect
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|,
name|va_next
decl_stmt|;
name|pd_entry_t
modifier|*
name|l0
decl_stmt|,
modifier|*
name|l1
decl_stmt|,
modifier|*
name|l2
decl_stmt|;
name|pt_entry_t
modifier|*
name|l3p
decl_stmt|,
name|l3
decl_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_READ
operator|)
operator|==
name|VM_PROT_NONE
condition|)
block|{
name|pmap_remove
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
name|VM_PROT_WRITE
condition|)
return|return;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sva
operator|<
name|eva
condition|;
name|sva
operator|=
name|va_next
control|)
block|{
name|l0
operator|=
name|pmap_l0
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_load
argument_list|(
name|l0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|va_next
operator|=
operator|(
name|sva
operator|+
name|L0_SIZE
operator|)
operator|&
operator|~
name|L0_OFFSET
expr_stmt|;
if|if
condition|(
name|va_next
operator|<
name|sva
condition|)
name|va_next
operator|=
name|eva
expr_stmt|;
continue|continue;
block|}
name|l1
operator|=
name|pmap_l0_to_l1
argument_list|(
name|l0
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_load
argument_list|(
name|l1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|va_next
operator|=
operator|(
name|sva
operator|+
name|L1_SIZE
operator|)
operator|&
operator|~
name|L1_OFFSET
expr_stmt|;
if|if
condition|(
name|va_next
operator|<
name|sva
condition|)
name|va_next
operator|=
name|eva
expr_stmt|;
continue|continue;
block|}
name|va_next
operator|=
operator|(
name|sva
operator|+
name|L2_SIZE
operator|)
operator|&
operator|~
name|L2_OFFSET
expr_stmt|;
if|if
condition|(
name|va_next
operator|<
name|sva
condition|)
name|va_next
operator|=
name|eva
expr_stmt|;
name|l2
operator|=
name|pmap_l1_to_l2
argument_list|(
name|l1
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_load
argument_list|(
name|l2
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|pmap_load
argument_list|(
name|l2
argument_list|)
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L2_BLOCK
condition|)
block|{
name|l3p
operator|=
name|pmap_demote_l2
argument_list|(
name|pmap
argument_list|,
name|l2
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|l3p
operator|==
name|NULL
condition|)
continue|continue;
block|}
name|KASSERT
argument_list|(
operator|(
name|pmap_load
argument_list|(
name|l2
argument_list|)
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L2_TABLE
argument_list|,
operator|(
literal|"pmap_protect: Invalid L2 entry after demotion"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|va_next
operator|>
name|eva
condition|)
name|va_next
operator|=
name|eva
expr_stmt|;
name|va
operator|=
name|va_next
expr_stmt|;
for|for
control|(
name|l3p
operator|=
name|pmap_l2_to_l3
argument_list|(
name|l2
argument_list|,
name|sva
argument_list|)
init|;
name|sva
operator|!=
name|va_next
condition|;
name|l3p
operator|++
operator|,
name|sva
operator|+=
name|L3_SIZE
control|)
block|{
name|l3
operator|=
name|pmap_load
argument_list|(
name|l3p
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_l3_valid
argument_list|(
name|l3
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|l3
operator|&
name|ATTR_SW_MANAGED
operator|)
operator|&&
name|pmap_page_dirty
argument_list|(
name|l3
argument_list|)
condition|)
block|{
name|vm_page_dirty
argument_list|(
name|PHYS_TO_VM_PAGE
argument_list|(
name|l3
operator|&
operator|~
name|ATTR_MASK
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|pmap_set
argument_list|(
name|l3p
argument_list|,
name|ATTR_AP
argument_list|(
name|ATTR_AP_RO
argument_list|)
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|l3p
argument_list|)
expr_stmt|;
comment|/* XXX: Use pmap_invalidate_range */
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
comment|/* TODO: Only invalidate entries we are touching */
name|pmap_invalidate_all
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Inserts the specified page table page into the specified pmap's collection  * of idle page table pages.  Each of a pmap's page table pages is responsible  * for mapping a distinct range of virtual addresses.  The pmap's collection is  * ordered by this virtual address range.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|pmap_insert_pt_page
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|mpte
parameter_list|)
block|{
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
return|return
operator|(
name|vm_radix_insert
argument_list|(
operator|&
name|pmap
operator|->
name|pm_root
argument_list|,
name|mpte
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Looks for a page table page mapping the specified virtual address in the  * specified pmap's collection of idle page table pages.  Returns NULL if there  * is no page table page corresponding to the specified virtual address.  */
end_comment

begin_function
specifier|static
name|__inline
name|vm_page_t
name|pmap_lookup_pt_page
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
return|return
operator|(
name|vm_radix_lookup
argument_list|(
operator|&
name|pmap
operator|->
name|pm_root
argument_list|,
name|pmap_l2_pindex
argument_list|(
name|va
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Removes the specified page table page from the specified pmap's collection  * of idle page table pages.  The specified page table page must be a member of  * the pmap's collection.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|pmap_remove_pt_page
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|mpte
parameter_list|)
block|{
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|vm_radix_remove
argument_list|(
operator|&
name|pmap
operator|->
name|pm_root
argument_list|,
name|mpte
operator|->
name|pindex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Performs a break-before-make update of a pmap entry. This is needed when  * either promoting or demoting pages to ensure the TLB doesn't get into an  * inconsistent state.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_update_entry
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pd_entry_t
modifier|*
name|pte
parameter_list|,
name|pd_entry_t
name|newpte
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|register_t
name|intr
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure we don't get switched out with the page table in an 	 * inconsistent state. We also need to ensure no interrupts fire 	 * as they may make use of an address we are about to invalidate. 	 */
name|intr
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
comment|/* Clear the old mapping */
name|pmap_load_clear
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|pmap_invalidate_range
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|va
operator|+
name|size
argument_list|)
expr_stmt|;
comment|/* Create the new mapping */
name|pmap_load_store
argument_list|(
name|pte
argument_list|,
name|newpte
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
name|intr_restore
argument_list|(
name|intr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * After promotion from 512 4KB page mappings to a single 2MB page mapping,  * replace the many pv entries for the 4KB page mappings by a single pv entry  * for the 2MB page mapping.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_pv_promote_l2
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|,
name|struct
name|rwlock
modifier|*
modifier|*
name|lockp
parameter_list|)
block|{
name|struct
name|md_page
modifier|*
name|pvh
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|vm_offset_t
name|va_last
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|pa
operator|&
name|L2_OFFSET
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_pv_promote_l2: pa is not 2mpage aligned"
operator|)
argument_list|)
expr_stmt|;
name|CHANGE_PV_LIST_LOCK_TO_PHYS
argument_list|(
name|lockp
argument_list|,
name|pa
argument_list|)
expr_stmt|;
comment|/* 	 * Transfer the first page's pv entry for this mapping to the 2mpage's 	 * pv list.  Aside from avoiding the cost of a call to get_pv_entry(), 	 * a transfer avoids the possibility that get_pv_entry() calls 	 * reclaim_pv_chunk() and that reclaim_pv_chunk() removes one of the 	 * mappings that is being promoted. 	 */
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|va
operator|=
name|va
operator|&
operator|~
name|L2_OFFSET
expr_stmt|;
name|pv
operator|=
name|pmap_pvh_remove
argument_list|(
operator|&
name|m
operator|->
name|md
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pv
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_pv_promote_l2: pv not found"
operator|)
argument_list|)
expr_stmt|;
name|pvh
operator|=
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pvh
operator|->
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_next
argument_list|)
expr_stmt|;
name|pvh
operator|->
name|pv_gen
operator|++
expr_stmt|;
comment|/* Free the remaining NPTEPG - 1 pv entries. */
name|va_last
operator|=
name|va
operator|+
name|L2_SIZE
operator|-
name|PAGE_SIZE
expr_stmt|;
do|do
block|{
name|m
operator|++
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|pmap_pvh_free
argument_list|(
operator|&
name|m
operator|->
name|md
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|va
operator|<
name|va_last
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Tries to promote the 512, contiguous 4KB page mappings that are within a  * single level 2 table entry to a single 2MB page mapping.  For promotion  * to occur, two conditions must be met: (1) the 4KB page mappings must map  * aligned, contiguous physical memory and (2) the 4KB page mappings must have  * identical characteristics.  */
end_comment

begin_function
specifier|static
name|void
name|pmap_promote_l2
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pd_entry_t
modifier|*
name|l2
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|struct
name|rwlock
modifier|*
modifier|*
name|lockp
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|firstl3
decl_stmt|,
modifier|*
name|l3
decl_stmt|,
name|newl2
decl_stmt|,
name|oldl3
decl_stmt|,
name|pa
decl_stmt|;
name|vm_page_t
name|mpte
decl_stmt|;
name|vm_offset_t
name|sva
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|sva
operator|=
name|va
operator|&
operator|~
name|L2_OFFSET
expr_stmt|;
name|firstl3
operator|=
name|pmap_l2_to_l3
argument_list|(
name|l2
argument_list|,
name|sva
argument_list|)
expr_stmt|;
name|newl2
operator|=
name|pmap_load
argument_list|(
name|firstl3
argument_list|)
expr_stmt|;
comment|/* Check the alingment is valid */
if|if
condition|(
operator|(
operator|(
name|newl2
operator|&
operator|~
name|ATTR_MASK
operator|)
operator|&
name|L2_OFFSET
operator|)
operator|!=
literal|0
condition|)
block|{
name|atomic_add_long
argument_list|(
operator|&
name|pmap_l2_p_failures
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_promote_l2: failure for va %#lx"
literal|" in pmap %p"
argument_list|,
name|va
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
return|return;
block|}
name|pa
operator|=
name|newl2
operator|+
name|L2_SIZE
operator|-
name|PAGE_SIZE
expr_stmt|;
for|for
control|(
name|l3
operator|=
name|firstl3
operator|+
name|NL3PG
operator|-
literal|1
init|;
name|l3
operator|>
name|firstl3
condition|;
name|l3
operator|--
control|)
block|{
name|oldl3
operator|=
name|pmap_load
argument_list|(
name|l3
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldl3
operator|!=
name|pa
condition|)
block|{
name|atomic_add_long
argument_list|(
operator|&
name|pmap_l2_p_failures
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_promote_l2: failure for va %#lx"
literal|" in pmap %p"
argument_list|,
name|va
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
return|return;
block|}
name|pa
operator|-=
name|PAGE_SIZE
expr_stmt|;
block|}
comment|/* 	 * Save the page table page in its current state until the L2 	 * mapping the superpage is demoted by pmap_demote_l2() or 	 * destroyed by pmap_remove_l3(). 	 */
name|mpte
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pmap_load
argument_list|(
name|l2
argument_list|)
operator|&
operator|~
name|ATTR_MASK
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|mpte
operator|>=
name|vm_page_array
operator|&&
name|mpte
operator|<
operator|&
name|vm_page_array
index|[
name|vm_page_array_size
index|]
argument_list|,
operator|(
literal|"pmap_promote_l2: page table page is out of range"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|mpte
operator|->
name|pindex
operator|==
name|pmap_l2_pindex
argument_list|(
name|va
argument_list|)
argument_list|,
operator|(
literal|"pmap_promote_l2: page table page's pindex is wrong"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_insert_pt_page
argument_list|(
name|pmap
argument_list|,
name|mpte
argument_list|)
condition|)
block|{
name|atomic_add_long
argument_list|(
operator|&
name|pmap_l2_p_failures
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_promote_l2: failure for va %#lx in pmap %p"
argument_list|,
name|va
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|newl2
operator|&
name|ATTR_SW_MANAGED
operator|)
operator|!=
literal|0
condition|)
name|pmap_pv_promote_l2
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|newl2
operator|&
operator|~
name|ATTR_MASK
argument_list|,
name|lockp
argument_list|)
expr_stmt|;
name|newl2
operator|&=
operator|~
name|ATTR_DESCR_MASK
expr_stmt|;
name|newl2
operator||=
name|L2_BLOCK
expr_stmt|;
name|pmap_update_entry
argument_list|(
name|pmap
argument_list|,
name|l2
argument_list|,
name|newl2
argument_list|,
name|sva
argument_list|,
name|L2_SIZE
argument_list|)
expr_stmt|;
name|atomic_add_long
argument_list|(
operator|&
name|pmap_l2_promotions
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_promote_l2: success for va %#lx in pmap %p"
argument_list|,
name|va
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Insert the given physical page (p) at  *	the specified virtual address (v) in the  *	target physical map with the protection requested.  *  *	If specified, the page will be wired down, meaning  *	that the related pte can not be reclaimed.  *  *	NB:  This is the only routine which MAY NOT lazy-evaluate  *	or lose information.  That is, this routine must actually  *	insert this page into the given map NOW.  */
end_comment

begin_function
name|int
name|pmap_enter
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|int8_t
name|psind
name|__unused
parameter_list|)
block|{
name|struct
name|rwlock
modifier|*
name|lock
decl_stmt|;
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|pt_entry_t
name|new_l3
decl_stmt|,
name|orig_l3
decl_stmt|;
name|pt_entry_t
modifier|*
name|l2
decl_stmt|,
modifier|*
name|l3
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|vm_paddr_t
name|opa
decl_stmt|,
name|pa
decl_stmt|,
name|l1_pa
decl_stmt|,
name|l2_pa
decl_stmt|,
name|l3_pa
decl_stmt|;
name|vm_page_t
name|mpte
decl_stmt|,
name|om
decl_stmt|,
name|l1_m
decl_stmt|,
name|l2_m
decl_stmt|,
name|l3_m
decl_stmt|;
name|boolean_t
name|nosleep
decl_stmt|;
name|int
name|lvl
decl_stmt|;
name|va
operator|=
name|trunc_page
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
operator|&&
operator|!
name|vm_page_xbusied
argument_list|(
name|m
argument_list|)
condition|)
name|VM_OBJECT_ASSERT_LOCKED
argument_list|(
name|m
operator|->
name|object
argument_list|)
expr_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|new_l3
operator|=
call|(
name|pt_entry_t
call|)
argument_list|(
name|pa
operator||
name|ATTR_DEFAULT
operator||
name|ATTR_IDX
argument_list|(
name|m
operator|->
name|md
operator|.
name|pv_memattr
argument_list|)
operator||
name|L3_PAGE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
condition|)
name|new_l3
operator||=
name|ATTR_AP
argument_list|(
name|ATTR_AP_RO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|PMAP_ENTER_WIRED
operator|)
operator|!=
literal|0
condition|)
name|new_l3
operator||=
name|ATTR_SW_WIRED
expr_stmt|;
if|if
condition|(
operator|(
name|va
operator|>>
literal|63
operator|)
operator|==
literal|0
condition|)
name|new_l3
operator||=
name|ATTR_AP
argument_list|(
name|ATTR_AP_USER
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_enter: %.16lx -> %.16lx"
argument_list|,
name|va
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|mpte
operator|=
name|NULL
expr_stmt|;
name|lock
operator|=
name|NULL
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pde
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|pde
operator|!=
name|NULL
operator|&&
name|lvl
operator|==
literal|1
condition|)
block|{
name|l2
operator|=
name|pmap_l1_to_l2
argument_list|(
name|pde
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pmap_load
argument_list|(
name|l2
argument_list|)
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L2_BLOCK
operator|&&
operator|(
name|l3
operator|=
name|pmap_demote_l2_locked
argument_list|(
name|pmap
argument_list|,
name|l2
argument_list|,
name|va
operator|&
operator|~
name|L2_OFFSET
argument_list|,
operator|&
name|lock
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|l3
operator|=
operator|&
name|l3
index|[
name|pmap_l3_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|va
operator|<
name|VM_MAXUSER_ADDRESS
condition|)
block|{
name|mpte
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pmap_load
argument_list|(
name|l2
argument_list|)
operator|&
operator|~
name|ATTR_MASK
argument_list|)
expr_stmt|;
name|mpte
operator|->
name|wire_count
operator|++
expr_stmt|;
block|}
goto|goto
name|havel3
goto|;
block|}
block|}
if|if
condition|(
name|va
operator|<
name|VM_MAXUSER_ADDRESS
condition|)
block|{
name|nosleep
operator|=
operator|(
name|flags
operator|&
name|PMAP_ENTER_NOSLEEP
operator|)
operator|!=
literal|0
expr_stmt|;
name|mpte
operator|=
name|pmap_alloc_l3
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|nosleep
condition|?
name|NULL
else|:
operator|&
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpte
operator|==
name|NULL
operator|&&
name|nosleep
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_enter: mpte == NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|!=
name|NULL
condition|)
name|rw_wunlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_RESOURCE_SHORTAGE
operator|)
return|;
block|}
name|pde
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pde
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_enter: Invalid page entry, va: 0x%lx"
operator|,
name|va
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lvl
operator|==
literal|2
argument_list|,
operator|(
literal|"pmap_enter: Invalid level %d"
operator|,
name|lvl
operator|)
argument_list|)
expr_stmt|;
name|l3
operator|=
name|pmap_l2_to_l3
argument_list|(
name|pde
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If we get a level 2 pde it must point to a level 3 entry 		 * otherwise we will need to create the intermediate tables 		 */
if|if
condition|(
name|lvl
operator|<
literal|2
condition|)
block|{
switch|switch
condition|(
name|lvl
condition|)
block|{
default|default:
case|case
operator|-
literal|1
case|:
comment|/* Get the l0 pde to update */
name|pde
operator|=
name|pmap_l0
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pde
operator|!=
name|NULL
argument_list|,
operator|(
literal|"..."
operator|)
argument_list|)
expr_stmt|;
name|l1_m
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_WIRED
operator||
name|VM_ALLOC_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|l1_m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_enter: l1 pte_m == NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l1_m
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
condition|)
name|pmap_zero_page
argument_list|(
name|l1_m
argument_list|)
expr_stmt|;
name|l1_pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|l1_m
argument_list|)
expr_stmt|;
name|pmap_load_store
argument_list|(
name|pde
argument_list|,
name|l1_pa
operator||
name|L0_TABLE
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pde
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|0
case|:
comment|/* Get the l1 pde to update */
name|pde
operator|=
name|pmap_l1_to_l2
argument_list|(
name|pde
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pde
operator|!=
name|NULL
argument_list|,
operator|(
literal|"..."
operator|)
argument_list|)
expr_stmt|;
name|l2_m
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_WIRED
operator||
name|VM_ALLOC_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2_m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_enter: l2 pte_m == NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l2_m
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
condition|)
name|pmap_zero_page
argument_list|(
name|l2_m
argument_list|)
expr_stmt|;
name|l2_pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|l2_m
argument_list|)
expr_stmt|;
name|pmap_load_store
argument_list|(
name|pde
argument_list|,
name|l2_pa
operator||
name|L1_TABLE
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pde
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
comment|/* Get the l2 pde to update */
name|pde
operator|=
name|pmap_l1_to_l2
argument_list|(
name|pde
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|l3_m
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_WIRED
operator||
name|VM_ALLOC_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|l3_m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_enter: l3 pte_m == NULL"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l3_m
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
condition|)
name|pmap_zero_page
argument_list|(
name|l3_m
argument_list|)
expr_stmt|;
name|l3_pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|l3_m
argument_list|)
expr_stmt|;
name|pmap_load_store
argument_list|(
name|pde
argument_list|,
name|l3_pa
operator||
name|L2_TABLE
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pde
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|l3
operator|=
name|pmap_l2_to_l3
argument_list|(
name|pde
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
name|havel3
label|:
name|om
operator|=
name|NULL
expr_stmt|;
name|orig_l3
operator|=
name|pmap_load
argument_list|(
name|l3
argument_list|)
expr_stmt|;
name|opa
operator|=
name|orig_l3
operator|&
operator|~
name|ATTR_MASK
expr_stmt|;
comment|/* 	 * Is the specified virtual address already mapped? 	 */
if|if
condition|(
name|pmap_l3_valid
argument_list|(
name|orig_l3
argument_list|)
condition|)
block|{
comment|/* 		 * Wiring change, just update stats. We don't worry about 		 * wiring PT pages as they remain resident as long as there 		 * are valid mappings in them. Hence, if a user page is wired, 		 * the PT page will be also. 		 */
if|if
condition|(
operator|(
name|flags
operator|&
name|PMAP_ENTER_WIRED
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|orig_l3
operator|&
name|ATTR_SW_WIRED
operator|)
operator|==
literal|0
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|PMAP_ENTER_WIRED
operator|)
operator|==
literal|0
operator|&&
operator|(
name|orig_l3
operator|&
name|ATTR_SW_WIRED
operator|)
operator|!=
literal|0
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
comment|/* 		 * Remove the extra PT page reference. 		 */
if|if
condition|(
name|mpte
operator|!=
name|NULL
condition|)
block|{
name|mpte
operator|->
name|wire_count
operator|--
expr_stmt|;
name|KASSERT
argument_list|(
name|mpte
operator|->
name|wire_count
operator|>
literal|0
argument_list|,
operator|(
literal|"pmap_enter: missing reference to page table page,"
literal|" va: 0x%lx"
operator|,
name|va
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Has the physical page changed? 		 */
if|if
condition|(
name|opa
operator|==
name|pa
condition|)
block|{
comment|/* 			 * No, might be a protection or wiring change. 			 */
if|if
condition|(
operator|(
name|orig_l3
operator|&
name|ATTR_SW_MANAGED
operator|)
operator|!=
literal|0
condition|)
block|{
name|new_l3
operator||=
name|ATTR_SW_MANAGED
expr_stmt|;
if|if
condition|(
operator|(
name|new_l3
operator|&
name|ATTR_AP
argument_list|(
name|ATTR_AP_RW
argument_list|)
operator|)
operator|==
name|ATTR_AP
argument_list|(
name|ATTR_AP_RW
argument_list|)
condition|)
block|{
name|vm_page_aflag_set
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|validate
goto|;
block|}
comment|/* Flush the cache, there might be uncommitted data in it */
if|if
condition|(
name|pmap_is_current
argument_list|(
name|pmap
argument_list|)
operator|&&
name|pmap_l3_valid_cacheable
argument_list|(
name|orig_l3
argument_list|)
condition|)
name|cpu_dcache_wb_range
argument_list|(
name|va
argument_list|,
name|L3_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Increment the counters. 		 */
if|if
condition|(
operator|(
name|new_l3
operator|&
name|ATTR_SW_WIRED
operator|)
operator|!=
literal|0
condition|)
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
name|pmap_resident_count_inc
argument_list|(
name|pmap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Enter on the PV list if part of our managed memory. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
condition|)
block|{
name|new_l3
operator||=
name|ATTR_SW_MANAGED
expr_stmt|;
name|pv
operator|=
name|get_pv_entry
argument_list|(
name|pmap
argument_list|,
operator|&
name|lock
argument_list|)
expr_stmt|;
name|pv
operator|->
name|pv_va
operator|=
name|va
expr_stmt|;
name|CHANGE_PV_LIST_LOCK_TO_PHYS
argument_list|(
operator|&
name|lock
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_next
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_gen
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|new_l3
operator|&
name|ATTR_AP_RW_BIT
operator|)
operator|==
name|ATTR_AP
argument_list|(
name|ATTR_AP_RW
argument_list|)
condition|)
name|vm_page_aflag_set
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update the L3 entry. 	 */
if|if
condition|(
name|orig_l3
operator|!=
literal|0
condition|)
block|{
name|validate
label|:
name|orig_l3
operator|=
name|pmap_load
argument_list|(
name|l3
argument_list|)
expr_stmt|;
name|opa
operator|=
name|orig_l3
operator|&
operator|~
name|ATTR_MASK
expr_stmt|;
if|if
condition|(
name|opa
operator|!=
name|pa
condition|)
block|{
name|pmap_update_entry
argument_list|(
name|pmap
argument_list|,
name|l3
argument_list|,
name|new_l3
argument_list|,
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|orig_l3
operator|&
name|ATTR_SW_MANAGED
operator|)
operator|!=
literal|0
condition|)
block|{
name|om
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|opa
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_page_dirty
argument_list|(
name|orig_l3
argument_list|)
condition|)
name|vm_page_dirty
argument_list|(
name|om
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|orig_l3
operator|&
name|ATTR_AF
operator|)
operator|!=
literal|0
condition|)
name|vm_page_aflag_set
argument_list|(
name|om
argument_list|,
name|PGA_REFERENCED
argument_list|)
expr_stmt|;
name|CHANGE_PV_LIST_LOCK_TO_PHYS
argument_list|(
operator|&
name|lock
argument_list|,
name|opa
argument_list|)
expr_stmt|;
name|pmap_pvh_free
argument_list|(
operator|&
name|om
operator|->
name|md
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|om
operator|->
name|aflags
operator|&
name|PGA_WRITEABLE
operator|)
operator|!=
literal|0
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|om
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|&&
operator|(
operator|(
name|om
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|!=
literal|0
operator|||
name|TAILQ_EMPTY
argument_list|(
operator|&
name|pa_to_pvh
argument_list|(
name|opa
argument_list|)
operator|->
name|pv_list
argument_list|)
operator|)
condition|)
name|vm_page_aflag_clear
argument_list|(
name|om
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pmap_load_store
argument_list|(
name|l3
argument_list|,
name|new_l3
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|l3
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_page_dirty
argument_list|(
name|orig_l3
argument_list|)
operator|&&
operator|(
name|orig_l3
operator|&
name|ATTR_SW_MANAGED
operator|)
operator|!=
literal|0
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|pmap_load_store
argument_list|(
name|l3
argument_list|,
name|new_l3
argument_list|)
expr_stmt|;
block|}
name|PTE_SYNC
argument_list|(
name|l3
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap
operator|!=
name|pmap_kernel
argument_list|()
condition|)
block|{
if|if
condition|(
name|pmap
operator|==
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
operator|&&
operator|(
name|prot
operator|&
name|VM_PROT_EXECUTE
operator|)
operator|!=
literal|0
condition|)
name|cpu_icache_sync_range
argument_list|(
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mpte
operator|==
name|NULL
operator|||
name|mpte
operator|->
name|wire_count
operator|==
name|NL3PG
operator|)
operator|&&
name|pmap_superpages_enabled
argument_list|()
operator|&&
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
operator|&&
name|vm_reserv_level_iffullpop
argument_list|(
name|m
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pmap_promote_l2
argument_list|(
name|pmap
argument_list|,
name|pde
argument_list|,
name|va
argument_list|,
operator|&
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lock
operator|!=
name|NULL
condition|)
name|rw_wunlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Maps a sequence of resident pages belonging to the same object.  * The sequence begins with the given page m_start.  This page is  * mapped at the given virtual address start.  Each subsequent page is  * mapped at a virtual address that is offset from start by the same  * amount as the page is offset from m_start within the object.  The  * last page in the sequence is the page with the largest offset from  * m_start that can be mapped at a virtual address less than the given  * virtual address end.  Not every virtual page between start and end  * is mapped; only those for which a resident page exists with the  * corresponding offset from m_start are mapped.  */
end_comment

begin_function
name|void
name|pmap_enter_object
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|vm_page_t
name|m_start
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|struct
name|rwlock
modifier|*
name|lock
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|,
name|mpte
decl_stmt|;
name|vm_pindex_t
name|diff
decl_stmt|,
name|psize
decl_stmt|;
name|VM_OBJECT_ASSERT_LOCKED
argument_list|(
name|m_start
operator|->
name|object
argument_list|)
expr_stmt|;
name|psize
operator|=
name|atop
argument_list|(
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|mpte
operator|=
name|NULL
expr_stmt|;
name|m
operator|=
name|m_start
expr_stmt|;
name|lock
operator|=
name|NULL
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
operator|(
name|diff
operator|=
name|m
operator|->
name|pindex
operator|-
name|m_start
operator|->
name|pindex
operator|)
operator|<
name|psize
condition|)
block|{
name|va
operator|=
name|start
operator|+
name|ptoa
argument_list|(
name|diff
argument_list|)
expr_stmt|;
name|mpte
operator|=
name|pmap_enter_quick_locked
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
name|prot
argument_list|,
name|mpte
argument_list|,
operator|&
name|lock
argument_list|)
expr_stmt|;
name|m
operator|=
name|TAILQ_NEXT
argument_list|(
name|m
argument_list|,
name|listq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lock
operator|!=
name|NULL
condition|)
name|rw_wunlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this code makes some *MAJOR* assumptions:  * 1. Current pmap& pmap exists.  * 2. Not wired.  * 3. Read access.  * 4. No page table pages.  * but is *MUCH* faster than pmap_enter...  */
end_comment

begin_function
name|void
name|pmap_enter_quick
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|struct
name|rwlock
modifier|*
name|lock
decl_stmt|;
name|lock
operator|=
name|NULL
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pmap_enter_quick_locked
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
name|prot
argument_list|,
name|NULL
argument_list|,
operator|&
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|!=
name|NULL
condition|)
name|rw_wunlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|vm_page_t
name|pmap_enter_quick_locked
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|vm_page_t
name|mpte
parameter_list|,
name|struct
name|rwlock
modifier|*
modifier|*
name|lockp
parameter_list|)
block|{
name|struct
name|spglist
name|free
decl_stmt|;
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|pt_entry_t
modifier|*
name|l2
decl_stmt|,
modifier|*
name|l3
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|int
name|lvl
decl_stmt|;
name|KASSERT
argument_list|(
name|va
operator|<
name|kmi
operator|.
name|clean_sva
operator|||
name|va
operator|>=
name|kmi
operator|.
name|clean_eva
operator|||
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"pmap_enter_quick_locked: managed mapping within the clean submap"
operator|)
argument_list|)
expr_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_enter_quick_locked: %p %lx"
argument_list|,
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
comment|/* 	 * In the case that a page table page is not 	 * resident, we are creating it here. 	 */
if|if
condition|(
name|va
operator|<
name|VM_MAXUSER_ADDRESS
condition|)
block|{
name|vm_pindex_t
name|l2pindex
decl_stmt|;
comment|/* 		 * Calculate pagetable page index 		 */
name|l2pindex
operator|=
name|pmap_l2_pindex
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpte
operator|&&
operator|(
name|mpte
operator|->
name|pindex
operator|==
name|l2pindex
operator|)
condition|)
block|{
name|mpte
operator|->
name|wire_count
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Get the l2 entry 			 */
name|pde
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
comment|/* 			 * If the page table page is mapped, we just increment 			 * the hold count, and activate it.  Otherwise, we 			 * attempt to allocate a page table page.  If this 			 * attempt fails, we don't retry.  Instead, we give up. 			 */
if|if
condition|(
name|lvl
operator|==
literal|1
condition|)
block|{
name|l2
operator|=
name|pmap_l1_to_l2
argument_list|(
name|pde
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pmap_load
argument_list|(
name|l2
argument_list|)
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L2_BLOCK
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|lvl
operator|==
literal|2
operator|&&
name|pmap_load
argument_list|(
name|pde
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mpte
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pmap_load
argument_list|(
name|pde
argument_list|)
operator|&
operator|~
name|ATTR_MASK
argument_list|)
expr_stmt|;
name|mpte
operator|->
name|wire_count
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Pass NULL instead of the PV list lock 				 * pointer, because we don't intend to sleep. 				 */
name|mpte
operator|=
name|_pmap_alloc_l3
argument_list|(
name|pmap
argument_list|,
name|l2pindex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mpte
operator|==
name|NULL
condition|)
return|return
operator|(
name|mpte
operator|)
return|;
block|}
block|}
name|l3
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|mpte
argument_list|)
argument_list|)
expr_stmt|;
name|l3
operator|=
operator|&
name|l3
index|[
name|pmap_l3_index
argument_list|(
name|va
argument_list|)
index|]
expr_stmt|;
block|}
else|else
block|{
name|mpte
operator|=
name|NULL
expr_stmt|;
name|pde
operator|=
name|pmap_pde
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pde
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_enter_quick_locked: Invalid page entry, va: 0x%lx"
operator|,
name|va
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lvl
operator|==
literal|2
argument_list|,
operator|(
literal|"pmap_enter_quick_locked: Invalid level %d"
operator|,
name|lvl
operator|)
argument_list|)
expr_stmt|;
name|l3
operator|=
name|pmap_l2_to_l3
argument_list|(
name|pde
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pmap_load
argument_list|(
name|l3
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|mpte
operator|!=
name|NULL
condition|)
block|{
name|mpte
operator|->
name|wire_count
operator|--
expr_stmt|;
name|mpte
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|mpte
operator|)
return|;
block|}
comment|/* 	 * Enter on the PV list if part of our managed memory. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
operator|&&
operator|!
name|pmap_try_insert_pv_entry
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
name|lockp
argument_list|)
condition|)
block|{
if|if
condition|(
name|mpte
operator|!=
name|NULL
condition|)
block|{
name|SLIST_INIT
argument_list|(
operator|&
name|free
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_unwire_l3
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|mpte
argument_list|,
operator|&
name|free
argument_list|)
condition|)
block|{
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pmap_free_zero_pages
argument_list|(
operator|&
name|free
argument_list|)
expr_stmt|;
block|}
name|mpte
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|mpte
operator|)
return|;
block|}
comment|/* 	 * Increment counters 	 */
name|pmap_resident_count_inc
argument_list|(
name|pmap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator||
name|ATTR_DEFAULT
operator||
name|ATTR_IDX
argument_list|(
name|m
operator|->
name|md
operator|.
name|pv_memattr
argument_list|)
operator||
name|ATTR_AP
argument_list|(
name|ATTR_AP_RO
argument_list|)
operator||
name|L3_PAGE
expr_stmt|;
comment|/* 	 * Now validate mapping with RO protection 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
condition|)
name|pa
operator||=
name|ATTR_SW_MANAGED
expr_stmt|;
name|pmap_load_store
argument_list|(
name|l3
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|l3
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
return|return
operator|(
name|mpte
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This code maps large physical mmap regions into the  * processor address space.  Note that some shortcuts  * are taken, but the code works.  */
end_comment

begin_function
name|void
name|pmap_object_init_pt
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|->
name|type
operator|==
name|OBJT_DEVICE
operator|||
name|object
operator|->
name|type
operator|==
name|OBJT_SG
argument_list|,
operator|(
literal|"pmap_object_init_pt: non-device object"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Clear the wired attribute from the mappings for the specified range of  *	addresses in the given pmap.  Every valid mapping within that range  *	must have the wired attribute set.  In contrast, invalid mappings  *	cannot have the wired attribute set, so they are ignored.  *  *	The wired attribute of the page table entry is not a hardware feature,  *	so there is no need to invalidate any TLB entries.  */
end_comment

begin_function
name|void
name|pmap_unwire
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|)
block|{
name|vm_offset_t
name|va_next
decl_stmt|;
name|pd_entry_t
modifier|*
name|l0
decl_stmt|,
modifier|*
name|l1
decl_stmt|,
modifier|*
name|l2
decl_stmt|;
name|pt_entry_t
modifier|*
name|l3
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|sva
operator|<
name|eva
condition|;
name|sva
operator|=
name|va_next
control|)
block|{
name|l0
operator|=
name|pmap_l0
argument_list|(
name|pmap
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_load
argument_list|(
name|l0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|va_next
operator|=
operator|(
name|sva
operator|+
name|L0_SIZE
operator|)
operator|&
operator|~
name|L0_OFFSET
expr_stmt|;
if|if
condition|(
name|va_next
operator|<
name|sva
condition|)
name|va_next
operator|=
name|eva
expr_stmt|;
continue|continue;
block|}
name|l1
operator|=
name|pmap_l0_to_l1
argument_list|(
name|l0
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_load
argument_list|(
name|l1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|va_next
operator|=
operator|(
name|sva
operator|+
name|L1_SIZE
operator|)
operator|&
operator|~
name|L1_OFFSET
expr_stmt|;
if|if
condition|(
name|va_next
operator|<
name|sva
condition|)
name|va_next
operator|=
name|eva
expr_stmt|;
continue|continue;
block|}
name|va_next
operator|=
operator|(
name|sva
operator|+
name|L2_SIZE
operator|)
operator|&
operator|~
name|L2_OFFSET
expr_stmt|;
if|if
condition|(
name|va_next
operator|<
name|sva
condition|)
name|va_next
operator|=
name|eva
expr_stmt|;
name|l2
operator|=
name|pmap_l1_to_l2
argument_list|(
name|l1
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_load
argument_list|(
name|l2
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|pmap_load
argument_list|(
name|l2
argument_list|)
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L2_BLOCK
condition|)
block|{
name|l3
operator|=
name|pmap_demote_l2
argument_list|(
name|pmap
argument_list|,
name|l2
argument_list|,
name|sva
argument_list|)
expr_stmt|;
if|if
condition|(
name|l3
operator|==
name|NULL
condition|)
continue|continue;
block|}
name|KASSERT
argument_list|(
operator|(
name|pmap_load
argument_list|(
name|l2
argument_list|)
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L2_TABLE
argument_list|,
operator|(
literal|"pmap_unwire: Invalid l2 entry after demotion"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|va_next
operator|>
name|eva
condition|)
name|va_next
operator|=
name|eva
expr_stmt|;
for|for
control|(
name|l3
operator|=
name|pmap_l2_to_l3
argument_list|(
name|l2
argument_list|,
name|sva
argument_list|)
init|;
name|sva
operator|!=
name|va_next
condition|;
name|l3
operator|++
operator|,
name|sva
operator|+=
name|L3_SIZE
control|)
block|{
if|if
condition|(
name|pmap_load
argument_list|(
name|l3
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|pmap_load
argument_list|(
name|l3
argument_list|)
operator|&
name|ATTR_SW_WIRED
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_unwire: l3 %#jx is missing "
literal|"ATTR_SW_WIRED"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|pmap_load
argument_list|(
name|l3
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * PG_W must be cleared atomically.  Although the pmap 			 * lock synchronizes access to PG_W, another processor 			 * could be setting PG_M and/or PG_A concurrently. 			 */
name|atomic_clear_long
argument_list|(
name|l3
argument_list|,
name|ATTR_SW_WIRED
argument_list|)
expr_stmt|;
name|pmap
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
block|}
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	Copy the range specified by src_addr/len  *	from the source map to the range dst_addr/len  *	in the destination map.  *  *	This routine is only advisory and need not do anything.  */
end_comment

begin_function
name|void
name|pmap_copy
parameter_list|(
name|pmap_t
name|dst_pmap
parameter_list|,
name|pmap_t
name|src_pmap
parameter_list|,
name|vm_offset_t
name|dst_addr
parameter_list|,
name|vm_size_t
name|len
parameter_list|,
name|vm_offset_t
name|src_addr
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  *	pmap_zero_page zeros the specified hardware page by mapping  *	the page into KVM and using bzero to clear its contents.  */
end_comment

begin_function
name|void
name|pmap_zero_page
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|vm_offset_t
name|va
init|=
name|PHYS_TO_DMAP
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
decl_stmt|;
name|pagezero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page_area zeros the specified hardware page by mapping  *	the page into KVM and using bzero to clear its contents.  *  *	off and size may not cover an area beyond a single hardware page.  */
end_comment

begin_function
name|void
name|pmap_zero_page_area
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|vm_offset_t
name|va
init|=
name|PHYS_TO_DMAP
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|off
operator|==
literal|0
operator|&&
name|size
operator|==
name|PAGE_SIZE
condition|)
name|pagezero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|va
argument_list|)
expr_stmt|;
else|else
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|va
operator|+
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_zero_page_idle zeros the specified hardware page by mapping  *	the page into KVM and using bzero to clear its contents.  This  *	is intended to be called from the vm_pagezero process only and  *	outside of Giant.  */
end_comment

begin_function
name|void
name|pmap_zero_page_idle
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|vm_offset_t
name|va
init|=
name|PHYS_TO_DMAP
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
decl_stmt|;
name|pagezero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	pmap_copy_page copies the specified (machine independent)  *	page by mapping the page into virtual memory and using  *	bcopy to copy the page, one machine dependent page at a  *	time.  */
end_comment

begin_function
name|void
name|pmap_copy_page
parameter_list|(
name|vm_page_t
name|msrc
parameter_list|,
name|vm_page_t
name|mdst
parameter_list|)
block|{
name|vm_offset_t
name|src
init|=
name|PHYS_TO_DMAP
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|msrc
argument_list|)
argument_list|)
decl_stmt|;
name|vm_offset_t
name|dst
init|=
name|PHYS_TO_DMAP
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|mdst
argument_list|)
argument_list|)
decl_stmt|;
name|pagecopy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|src
argument_list|,
operator|(
name|void
operator|*
operator|)
name|dst
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|unmapped_buf_allowed
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|pmap_copy_pages
parameter_list|(
name|vm_page_t
name|ma
index|[]
parameter_list|,
name|vm_offset_t
name|a_offset
parameter_list|,
name|vm_page_t
name|mb
index|[]
parameter_list|,
name|vm_offset_t
name|b_offset
parameter_list|,
name|int
name|xfersize
parameter_list|)
block|{
name|void
modifier|*
name|a_cp
decl_stmt|,
modifier|*
name|b_cp
decl_stmt|;
name|vm_page_t
name|m_a
decl_stmt|,
name|m_b
decl_stmt|;
name|vm_paddr_t
name|p_a
decl_stmt|,
name|p_b
decl_stmt|;
name|vm_offset_t
name|a_pg_offset
decl_stmt|,
name|b_pg_offset
decl_stmt|;
name|int
name|cnt
decl_stmt|;
while|while
condition|(
name|xfersize
operator|>
literal|0
condition|)
block|{
name|a_pg_offset
operator|=
name|a_offset
operator|&
name|PAGE_MASK
expr_stmt|;
name|m_a
operator|=
name|ma
index|[
name|a_offset
operator|>>
name|PAGE_SHIFT
index|]
expr_stmt|;
name|p_a
operator|=
name|m_a
operator|->
name|phys_addr
expr_stmt|;
name|b_pg_offset
operator|=
name|b_offset
operator|&
name|PAGE_MASK
expr_stmt|;
name|m_b
operator|=
name|mb
index|[
name|b_offset
operator|>>
name|PAGE_SHIFT
index|]
expr_stmt|;
name|p_b
operator|=
name|m_b
operator|->
name|phys_addr
expr_stmt|;
name|cnt
operator|=
name|min
argument_list|(
name|xfersize
argument_list|,
name|PAGE_SIZE
operator|-
name|a_pg_offset
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|min
argument_list|(
name|cnt
argument_list|,
name|PAGE_SIZE
operator|-
name|b_pg_offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|PHYS_IN_DMAP
argument_list|(
name|p_a
argument_list|)
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"!DMAP a %lx"
argument_list|,
name|p_a
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|a_cp
operator|=
operator|(
name|char
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|p_a
argument_list|)
operator|+
name|a_pg_offset
expr_stmt|;
block|}
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|PHYS_IN_DMAP
argument_list|(
name|p_b
argument_list|)
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"!DMAP b %lx"
argument_list|,
name|p_b
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|b_cp
operator|=
operator|(
name|char
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|p_b
argument_list|)
operator|+
name|b_pg_offset
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|a_cp
argument_list|,
name|b_cp
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|a_offset
operator|+=
name|cnt
expr_stmt|;
name|b_offset
operator|+=
name|cnt
expr_stmt|;
name|xfersize
operator|-=
name|cnt
expr_stmt|;
block|}
block|}
end_function

begin_function
name|vm_offset_t
name|pmap_quick_enter_page
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
return|return
operator|(
name|PHYS_TO_DMAP
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_quick_remove_page
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  * Returns true if the pmap's pv is one of the first  * 16 pvs linked to from this page.  This count may  * be changed upwards or downwards in the future; it  * is only necessary that true be returned for a small  * subset of pmaps for proper page aging.  */
end_comment

begin_function
name|boolean_t
name|pmap_page_exists_quick
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|md_page
modifier|*
name|pvh
decl_stmt|;
name|struct
name|rwlock
modifier|*
name|lock
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|int
name|loops
init|=
literal|0
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_page_exists_quick: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|rv
operator|=
name|FALSE
expr_stmt|;
name|lock
operator|=
name|VM_PAGE_TO_PV_LIST_LOCK
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|rw_rlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_next
argument_list|)
block|{
if|if
condition|(
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
operator|==
name|pmap
condition|)
block|{
name|rv
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|loops
operator|++
expr_stmt|;
if|if
condition|(
name|loops
operator|>=
literal|16
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|rv
operator|&&
name|loops
operator|<
literal|16
operator|&&
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
condition|)
block|{
name|pvh
operator|=
name|pa_to_pvh
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&pvh->pv_list
argument_list|,
argument|pv_next
argument_list|)
block|{
if|if
condition|(
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
operator|==
name|pmap
condition|)
block|{
name|rv
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|loops
operator|++
expr_stmt|;
if|if
condition|(
name|loops
operator|>=
literal|16
condition|)
break|break;
block|}
block|}
name|rw_runlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_page_wired_mappings:  *  *	Return the number of managed mappings to the given physical page  *	that are wired.  */
end_comment

begin_function
name|int
name|pmap_page_wired_mappings
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|rwlock
modifier|*
name|lock
decl_stmt|;
name|struct
name|md_page
modifier|*
name|pvh
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|int
name|count
decl_stmt|,
name|lvl
decl_stmt|,
name|md_gen
decl_stmt|,
name|pvh_gen
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|lock
operator|=
name|VM_PAGE_TO_PV_LIST_LOCK
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|rw_rlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|restart
label|:
name|count
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_next
argument_list|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PMAP_TRYLOCK
argument_list|(
name|pmap
argument_list|)
condition|)
block|{
name|md_gen
operator|=
name|m
operator|->
name|md
operator|.
name|pv_gen
expr_stmt|;
name|rw_runlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_rlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|md_gen
operator|!=
name|m
operator|->
name|md
operator|.
name|pv_gen
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|!=
name|NULL
operator|&&
operator|(
name|pmap_load
argument_list|(
name|pte
argument_list|)
operator|&
name|ATTR_SW_WIRED
operator|)
operator|!=
literal|0
condition|)
name|count
operator|++
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
condition|)
block|{
name|pvh
operator|=
name|pa_to_pvh
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&pvh->pv_list
argument_list|,
argument|pv_next
argument_list|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PMAP_TRYLOCK
argument_list|(
name|pmap
argument_list|)
condition|)
block|{
name|md_gen
operator|=
name|m
operator|->
name|md
operator|.
name|pv_gen
expr_stmt|;
name|pvh_gen
operator|=
name|pvh
operator|->
name|pv_gen
expr_stmt|;
name|rw_runlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_rlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|md_gen
operator|!=
name|m
operator|->
name|md
operator|.
name|pv_gen
operator|||
name|pvh_gen
operator|!=
name|pvh
operator|->
name|pv_gen
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|!=
name|NULL
operator|&&
operator|(
name|pmap_load
argument_list|(
name|pte
argument_list|)
operator|&
name|ATTR_SW_WIRED
operator|)
operator|!=
literal|0
condition|)
name|count
operator|++
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
block|}
name|rw_runlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy all managed, non-wired mappings in the given user-space  * pmap.  This pmap cannot be active on any processor besides the  * caller.  *  * This function cannot be applied to the kernel pmap.  Moreover, it  * is not intended for general use.  It is only to be used during  * process termination.  Consequently, it can be implemented in ways  * that make it faster than pmap_remove().  First, it can more quickly  * destroy mappings by iterating over the pmap's collection of PV  * entries, rather than searching the page table.  Second, it doesn't  * have to test and clear the page table entries atomically, because  * no processor is currently accessing the user address space.  In  * particular, a page table entry's dirty bit won't change state once  * this function starts.  */
end_comment

begin_function
name|void
name|pmap_remove_pages
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|pde
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
name|tpte
decl_stmt|;
name|struct
name|spglist
name|free
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|,
name|ml3
decl_stmt|,
name|mt
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|struct
name|md_page
modifier|*
name|pvh
decl_stmt|;
name|struct
name|pv_chunk
modifier|*
name|pc
decl_stmt|,
modifier|*
name|npc
decl_stmt|;
name|struct
name|rwlock
modifier|*
name|lock
decl_stmt|;
name|int64_t
name|bit
decl_stmt|;
name|uint64_t
name|inuse
decl_stmt|,
name|bitmask
decl_stmt|;
name|int
name|allfree
decl_stmt|,
name|field
decl_stmt|,
name|freed
decl_stmt|,
name|idx
decl_stmt|,
name|lvl
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|lock
operator|=
name|NULL
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|free
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|pc
argument_list|,
argument|&pmap->pm_pvchunk
argument_list|,
argument|pc_list
argument_list|,
argument|npc
argument_list|)
block|{
name|allfree
operator|=
literal|1
expr_stmt|;
name|freed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|field
operator|=
literal|0
init|;
name|field
operator|<
name|_NPCM
condition|;
name|field
operator|++
control|)
block|{
name|inuse
operator|=
operator|~
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator|&
name|pc_freemask
index|[
name|field
index|]
expr_stmt|;
while|while
condition|(
name|inuse
operator|!=
literal|0
condition|)
block|{
name|bit
operator|=
name|ffsl
argument_list|(
name|inuse
argument_list|)
operator|-
literal|1
expr_stmt|;
name|bitmask
operator|=
literal|1UL
operator|<<
name|bit
expr_stmt|;
name|idx
operator|=
name|field
operator|*
literal|64
operator|+
name|bit
expr_stmt|;
name|pv
operator|=
operator|&
name|pc
operator|->
name|pc_pventry
index|[
name|idx
index|]
expr_stmt|;
name|inuse
operator|&=
operator|~
name|bitmask
expr_stmt|;
name|pde
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pde
operator|!=
name|NULL
argument_list|,
operator|(
literal|"Attempting to remove an unmapped page"
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lvl
condition|)
block|{
case|case
literal|1
case|:
name|pte
operator|=
name|pmap_l1_to_l2
argument_list|(
name|pde
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|tpte
operator|=
name|pmap_load
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|tpte
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L2_BLOCK
argument_list|,
operator|(
literal|"Attempting to remove an invalid "
literal|"block: %lx"
operator|,
name|tpte
operator|)
argument_list|)
expr_stmt|;
name|tpte
operator|=
name|pmap_load
argument_list|(
name|pte
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|pte
operator|=
name|pmap_l2_to_l3
argument_list|(
name|pde
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|tpte
operator|=
name|pmap_load
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|tpte
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L3_PAGE
argument_list|,
operator|(
literal|"Attempting to remove an invalid "
literal|"page: %lx"
operator|,
name|tpte
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"Invalid page directory level: %d"
argument_list|,
name|lvl
argument_list|)
expr_stmt|;
block|}
comment|/*  * We cannot remove wired pages from a process' mapping at this time  */
if|if
condition|(
name|tpte
operator|&
name|ATTR_SW_WIRED
condition|)
block|{
name|allfree
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
name|pa
operator|=
name|tpte
operator|&
operator|~
name|ATTR_MASK
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|phys_addr
operator|==
name|pa
argument_list|,
operator|(
literal|"vm_page_t %p phys_addr mismatch %016jx %016jx"
operator|,
name|m
operator|,
operator|(
name|uintmax_t
operator|)
name|m
operator|->
name|phys_addr
operator|,
operator|(
name|uintmax_t
operator|)
name|tpte
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|!=
literal|0
operator|||
name|m
operator|<
operator|&
name|vm_page_array
index|[
name|vm_page_array_size
index|]
argument_list|,
operator|(
literal|"pmap_remove_pages: bad pte %#jx"
operator|,
operator|(
name|uintmax_t
operator|)
name|tpte
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_is_current
argument_list|(
name|pmap
argument_list|)
condition|)
block|{
if|if
condition|(
name|lvl
operator|==
literal|2
operator|&&
name|pmap_l3_valid_cacheable
argument_list|(
name|tpte
argument_list|)
condition|)
block|{
name|cpu_dcache_wb_range
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|,
name|L3_SIZE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lvl
operator|==
literal|1
operator|&&
name|pmap_pte_valid_cacheable
argument_list|(
name|tpte
argument_list|)
condition|)
block|{
name|cpu_dcache_wb_range
argument_list|(
name|pv
operator|->
name|pv_va
argument_list|,
name|L2_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
name|pmap_load_clear
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|PTE_SYNC
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
comment|/* 				 * Update the vm_page_t clean/reference bits. 				 */
if|if
condition|(
operator|(
name|tpte
operator|&
name|ATTR_AP_RW_BIT
operator|)
operator|==
name|ATTR_AP
argument_list|(
name|ATTR_AP_RW
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|lvl
condition|)
block|{
case|case
literal|1
case|:
for|for
control|(
name|mt
operator|=
name|m
init|;
name|mt
operator|<
operator|&
name|m
index|[
name|L2_SIZE
operator|/
name|PAGE_SIZE
index|]
condition|;
name|mt
operator|++
control|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|CHANGE_PV_LIST_LOCK_TO_VM_PAGE
argument_list|(
operator|&
name|lock
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* Mark free */
name|pc
operator|->
name|pc_map
index|[
name|field
index|]
operator||=
name|bitmask
expr_stmt|;
switch|switch
condition|(
name|lvl
condition|)
block|{
case|case
literal|1
case|:
name|pmap_resident_count_dec
argument_list|(
name|pmap
argument_list|,
name|L2_SIZE
operator|/
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|pvh
operator|=
name|pa_to_pvh
argument_list|(
name|tpte
operator|&
operator|~
name|ATTR_MASK
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pvh
operator|->
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_next
argument_list|)
expr_stmt|;
name|pvh
operator|->
name|pv_gen
operator|++
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|pvh
operator|->
name|pv_list
argument_list|)
condition|)
block|{
for|for
control|(
name|mt
operator|=
name|m
init|;
name|mt
operator|<
operator|&
name|m
index|[
name|L2_SIZE
operator|/
name|PAGE_SIZE
index|]
condition|;
name|mt
operator|++
control|)
if|if
condition|(
operator|(
name|mt
operator|->
name|aflags
operator|&
name|PGA_WRITEABLE
operator|)
operator|!=
literal|0
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|mt
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
name|vm_page_aflag_clear
argument_list|(
name|mt
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
block|}
name|ml3
operator|=
name|pmap_lookup_pt_page
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
if|if
condition|(
name|ml3
operator|!=
name|NULL
condition|)
block|{
name|pmap_remove_pt_page
argument_list|(
name|pmap
argument_list|,
name|ml3
argument_list|)
expr_stmt|;
name|pmap_resident_count_dec
argument_list|(
name|pmap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ml3
operator|->
name|wire_count
operator|==
name|NL3PG
argument_list|,
operator|(
literal|"pmap_remove_pages: l3 page wire count error"
operator|)
argument_list|)
expr_stmt|;
name|ml3
operator|->
name|wire_count
operator|=
literal|0
expr_stmt|;
name|pmap_add_delayed_free_list
argument_list|(
name|ml3
argument_list|,
operator|&
name|free
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|vm_cnt
operator|.
name|v_wire_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
name|pmap_resident_count_dec
argument_list|(
name|pmap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_next
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_gen
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|aflags
operator|&
name|PGA_WRITEABLE
operator|)
operator|!=
literal|0
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|&&
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
condition|)
block|{
name|pvh
operator|=
name|pa_to_pvh
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|pvh
operator|->
name|pv_list
argument_list|)
condition|)
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|pmap_unuse_l3
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|pmap_load
argument_list|(
name|pde
argument_list|)
argument_list|,
operator|&
name|free
argument_list|)
expr_stmt|;
name|freed
operator|++
expr_stmt|;
block|}
block|}
name|PV_STAT
argument_list|(
name|atomic_add_long
argument_list|(
operator|&
name|pv_entry_frees
argument_list|,
name|freed
argument_list|)
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|atomic_add_int
argument_list|(
operator|&
name|pv_entry_spare
argument_list|,
name|freed
argument_list|)
argument_list|)
expr_stmt|;
name|PV_STAT
argument_list|(
name|atomic_subtract_long
argument_list|(
operator|&
name|pv_entry_count
argument_list|,
name|freed
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|allfree
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pmap
operator|->
name|pm_pvchunk
argument_list|,
name|pc
argument_list|,
name|pc_list
argument_list|)
expr_stmt|;
name|free_pv_chunk
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
block|}
name|pmap_invalidate_all
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|!=
name|NULL
condition|)
name|rw_wunlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pmap_free_zero_pages
argument_list|(
operator|&
name|free
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is used to check if a page has been accessed or modified. As we  * don't have a bit to see if it has been modified we have to assume it  * has been if the page is read/write.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|pmap_page_test_mappings
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|boolean_t
name|accessed
parameter_list|,
name|boolean_t
name|modified
parameter_list|)
block|{
name|struct
name|rwlock
modifier|*
name|lock
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|struct
name|md_page
modifier|*
name|pvh
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
name|mask
decl_stmt|,
name|value
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|int
name|lvl
decl_stmt|,
name|md_gen
decl_stmt|,
name|pvh_gen
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|rv
operator|=
name|FALSE
expr_stmt|;
name|lock
operator|=
name|VM_PAGE_TO_PV_LIST_LOCK
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|rw_rlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|restart
label|:
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_next
argument_list|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PMAP_TRYLOCK
argument_list|(
name|pmap
argument_list|)
condition|)
block|{
name|md_gen
operator|=
name|m
operator|->
name|md
operator|.
name|pv_gen
expr_stmt|;
name|rw_runlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_rlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|md_gen
operator|!=
name|m
operator|->
name|md
operator|.
name|pv_gen
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lvl
operator|==
literal|3
argument_list|,
operator|(
literal|"pmap_page_test_mappings: Invalid level %d"
operator|,
name|lvl
operator|)
argument_list|)
expr_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|modified
condition|)
block|{
name|mask
operator||=
name|ATTR_AP_RW_BIT
expr_stmt|;
name|value
operator||=
name|ATTR_AP
argument_list|(
name|ATTR_AP_RW
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|accessed
condition|)
block|{
name|mask
operator||=
name|ATTR_AF
operator||
name|ATTR_DESCR_MASK
expr_stmt|;
name|value
operator||=
name|ATTR_AF
operator||
name|L3_PAGE
expr_stmt|;
block|}
name|rv
operator|=
operator|(
name|pmap_load
argument_list|(
name|pte
argument_list|)
operator|&
name|mask
operator|)
operator|==
name|value
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
condition|)
block|{
name|pvh
operator|=
name|pa_to_pvh
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&pvh->pv_list
argument_list|,
argument|pv_next
argument_list|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PMAP_TRYLOCK
argument_list|(
name|pmap
argument_list|)
condition|)
block|{
name|md_gen
operator|=
name|m
operator|->
name|md
operator|.
name|pv_gen
expr_stmt|;
name|pvh_gen
operator|=
name|pvh
operator|->
name|pv_gen
expr_stmt|;
name|rw_runlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_rlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|md_gen
operator|!=
name|m
operator|->
name|md
operator|.
name|pv_gen
operator|||
name|pvh_gen
operator|!=
name|pvh
operator|->
name|pv_gen
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lvl
operator|==
literal|2
argument_list|,
operator|(
literal|"pmap_page_test_mappings: Invalid level %d"
operator|,
name|lvl
operator|)
argument_list|)
expr_stmt|;
name|mask
operator|=
literal|0
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|modified
condition|)
block|{
name|mask
operator||=
name|ATTR_AP_RW_BIT
expr_stmt|;
name|value
operator||=
name|ATTR_AP
argument_list|(
name|ATTR_AP_RW
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|accessed
condition|)
block|{
name|mask
operator||=
name|ATTR_AF
operator||
name|ATTR_DESCR_MASK
expr_stmt|;
name|value
operator||=
name|ATTR_AF
operator||
name|L2_BLOCK
expr_stmt|;
block|}
name|rv
operator|=
operator|(
name|pmap_load
argument_list|(
name|pte
argument_list|)
operator|&
name|mask
operator|)
operator|==
name|value
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
name|rw_runlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_is_modified:  *  *	Return whether or not the specified physical page was modified  *	in any physical maps.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_modified
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_is_modified: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the page is not exclusive busied, then PGA_WRITEABLE cannot be 	 * concurrently set while the object is locked.  Thus, if PGA_WRITEABLE 	 * is clear, no PTEs can have PG_M set. 	 */
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|m
operator|->
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vm_page_xbusied
argument_list|(
name|m
argument_list|)
operator|&&
operator|(
name|m
operator|->
name|aflags
operator|&
name|PGA_WRITEABLE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|pmap_page_test_mappings
argument_list|(
name|m
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_is_prefaultable:  *  *	Return whether or not the specified virtual address is eligible  *	for prefault.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_prefaultable
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|pte
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|int
name|lvl
decl_stmt|;
name|rv
operator|=
name|FALSE
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|addr
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|!=
name|NULL
operator|&&
name|pmap_load
argument_list|(
name|pte
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rv
operator|=
name|TRUE
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_is_referenced:  *  *	Return whether or not the specified physical page was referenced  *	in any physical maps.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_referenced
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_is_referenced: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|pmap_page_test_mappings
argument_list|(
name|m
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear the write and modified bits in each of the given page's mappings.  */
end_comment

begin_function
name|void
name|pmap_remove_write
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|md_page
modifier|*
name|pvh
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|struct
name|rwlock
modifier|*
name|lock
decl_stmt|;
name|pv_entry_t
name|next_pv
decl_stmt|,
name|pv
decl_stmt|;
name|pt_entry_t
name|oldpte
decl_stmt|,
modifier|*
name|pte
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|int
name|lvl
decl_stmt|,
name|md_gen
decl_stmt|,
name|pvh_gen
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_remove_write: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the page is not exclusive busied, then PGA_WRITEABLE cannot be 	 * set by another thread while the object is locked.  Thus, 	 * if PGA_WRITEABLE is clear, no page table entries need updating. 	 */
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|m
operator|->
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vm_page_xbusied
argument_list|(
name|m
argument_list|)
operator|&&
operator|(
name|m
operator|->
name|aflags
operator|&
name|PGA_WRITEABLE
operator|)
operator|==
literal|0
condition|)
return|return;
name|lock
operator|=
name|VM_PAGE_TO_PV_LIST_LOCK
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pvh
operator|=
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|!=
literal|0
condition|?
operator|&
name|pv_dummy
else|:
name|pa_to_pvh
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|retry_pv_loop
label|:
name|rw_wlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|pv
argument_list|,
argument|&pvh->pv_list
argument_list|,
argument|pv_next
argument_list|,
argument|next_pv
argument_list|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PMAP_TRYLOCK
argument_list|(
name|pmap
argument_list|)
condition|)
block|{
name|pvh_gen
operator|=
name|pvh
operator|->
name|pv_gen
expr_stmt|;
name|rw_wunlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvh_gen
operator|!=
name|pvh
operator|->
name|pv_gen
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|retry_pv_loop
goto|;
block|}
block|}
name|va
operator|=
name|pv
operator|->
name|pv_va
expr_stmt|;
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pmap_load
argument_list|(
name|pte
argument_list|)
operator|&
name|ATTR_AP_RW_BIT
operator|)
operator|==
name|ATTR_AP
argument_list|(
name|ATTR_AP_RW
argument_list|)
condition|)
name|pmap_demote_l2_locked
argument_list|(
name|pmap
argument_list|,
name|pte
argument_list|,
name|va
operator|&
operator|~
name|L2_OFFSET
argument_list|,
operator|&
name|lock
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lock
operator|==
name|VM_PAGE_TO_PV_LIST_LOCK
argument_list|(
name|m
argument_list|)
argument_list|,
operator|(
literal|"inconsistent pv lock %p %p for page %p"
operator|,
name|lock
operator|,
name|VM_PAGE_TO_PV_LIST_LOCK
argument_list|(
name|m
argument_list|)
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_next
argument_list|)
block|{
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PMAP_TRYLOCK
argument_list|(
name|pmap
argument_list|)
condition|)
block|{
name|pvh_gen
operator|=
name|pvh
operator|->
name|pv_gen
expr_stmt|;
name|md_gen
operator|=
name|m
operator|->
name|md
operator|.
name|pv_gen
expr_stmt|;
name|rw_wunlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvh_gen
operator|!=
name|pvh
operator|->
name|pv_gen
operator|||
name|md_gen
operator|!=
name|m
operator|->
name|md
operator|.
name|pv_gen
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|retry_pv_loop
goto|;
block|}
block|}
name|pte
operator|=
name|pmap_pte
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
name|retry
label|:
name|oldpte
operator|=
name|pmap_load
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oldpte
operator|&
name|ATTR_AP_RW_BIT
operator|)
operator|==
name|ATTR_AP
argument_list|(
name|ATTR_AP_RW
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|atomic_cmpset_long
argument_list|(
name|pte
argument_list|,
name|oldpte
argument_list|,
name|oldpte
operator||
name|ATTR_AP
argument_list|(
name|ATTR_AP_RO
argument_list|)
argument_list|)
condition|)
goto|goto
name|retry
goto|;
if|if
condition|(
operator|(
name|oldpte
operator|&
name|ATTR_AF
operator|)
operator|!=
literal|0
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|boolean_t
name|safe_to_clear_referenced
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pt_entry_t
name|pte
parameter_list|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PMAP_TS_REFERENCED_MAX
value|5
end_define

begin_comment
comment|/*  *	pmap_ts_referenced:  *  *	Return a count of reference bits for a page, clearing those bits.  *	It is not necessary for every reference bit to be cleared, but it  *	is necessary that 0 only be returned when there are truly no  *	reference bits set.  *  *	XXX: The exact number of bits to check and clear is a matter that  *	should be tested and standardized at some point in the future for  *	optimal aging of shared pages.  */
end_comment

begin_function
name|int
name|pmap_ts_referenced
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|md_page
modifier|*
name|pvh
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|,
name|pvf
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|struct
name|rwlock
modifier|*
name|lock
decl_stmt|;
name|pd_entry_t
modifier|*
name|pde
decl_stmt|,
name|tpde
decl_stmt|;
name|pt_entry_t
modifier|*
name|pte
decl_stmt|,
name|tpte
decl_stmt|;
name|pt_entry_t
modifier|*
name|l3
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|int
name|cleared
decl_stmt|,
name|md_gen
decl_stmt|,
name|not_cleared
decl_stmt|,
name|lvl
decl_stmt|,
name|pvh_gen
decl_stmt|;
name|struct
name|spglist
name|free
decl_stmt|;
name|bool
name|demoted
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_ts_referenced: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|SLIST_INIT
argument_list|(
operator|&
name|free
argument_list|)
expr_stmt|;
name|cleared
operator|=
literal|0
expr_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|lock
operator|=
name|PHYS_TO_PV_LIST_LOCK
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|pvh
operator|=
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|!=
literal|0
condition|?
operator|&
name|pv_dummy
else|:
name|pa_to_pvh
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|retry
label|:
name|not_cleared
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|pvf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pvh
operator|->
name|pv_list
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|small_mappings
goto|;
name|pv
operator|=
name|pvf
expr_stmt|;
do|do
block|{
if|if
condition|(
name|pvf
operator|==
name|NULL
condition|)
name|pvf
operator|=
name|pv
expr_stmt|;
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PMAP_TRYLOCK
argument_list|(
name|pmap
argument_list|)
condition|)
block|{
name|pvh_gen
operator|=
name|pvh
operator|->
name|pv_gen
expr_stmt|;
name|rw_wunlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvh_gen
operator|!=
name|pvh
operator|->
name|pv_gen
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
name|va
operator|=
name|pv
operator|->
name|pv_va
expr_stmt|;
name|pde
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pde
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_ts_referenced: no l1 table found"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lvl
operator|==
literal|1
argument_list|,
operator|(
literal|"pmap_ts_referenced: invalid pde level %d"
operator|,
name|lvl
operator|)
argument_list|)
expr_stmt|;
name|tpde
operator|=
name|pmap_load
argument_list|(
name|pde
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|tpde
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L1_TABLE
argument_list|,
operator|(
literal|"pmap_ts_referenced: found an invalid l1 table"
operator|)
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_l1_to_l2
argument_list|(
name|pde
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|tpte
operator|=
name|pmap_load
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tpte
operator|&
name|ATTR_AF
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Since this reference bit is shared by 512 4KB 			 * pages, it should not be cleared every time it is 			 * tested.  Apply a simple "hash" function on the 			 * physical page number, the virtual superpage number, 			 * and the pmap address to select one 4KB page out of 			 * the 512 on which testing the reference bit will 			 * result in clearing that reference bit.  This 			 * function is designed to avoid the selection of the 			 * same 4KB page for every 2MB page mapping. 			 * 			 * On demotion, a mapping that hasn't been referenced 			 * is simply destroyed.  To avoid the possibility of a 			 * subsequent page fault on a demoted wired mapping, 			 * always leave its reference bit set.  Moreover, 			 * since the superpage is wired, the current state of 			 * its reference bit won't affect page replacement. 			 */
if|if
condition|(
operator|(
operator|(
operator|(
name|pa
operator|>>
name|PAGE_SHIFT
operator|)
operator|^
operator|(
name|pv
operator|->
name|pv_va
operator|>>
name|L2_SHIFT
operator|)
operator|^
operator|(
name|uintptr_t
operator|)
name|pmap
operator|)
operator|&
operator|(
name|Ln_ENTRIES
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|tpte
operator|&
name|ATTR_SW_WIRED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|safe_to_clear_referenced
argument_list|(
name|pmap
argument_list|,
name|tpte
argument_list|)
condition|)
block|{
comment|/* 					 * TODO: We don't handle the access 					 * flag at all. We need to be able 					 * to set it in  the exception handler. 					 */
name|panic
argument_list|(
literal|"ARM64TODO: "
literal|"safe_to_clear_referenced\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pmap_demote_l2_locked
argument_list|(
name|pmap
argument_list|,
name|pte
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
operator|&
name|lock
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|demoted
operator|=
name|true
expr_stmt|;
name|va
operator|+=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator|-
operator|(
name|tpte
operator|&
operator|~
name|ATTR_MASK
operator|)
expr_stmt|;
name|l3
operator|=
name|pmap_l2_to_l3
argument_list|(
name|pte
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pmap_remove_l3
argument_list|(
name|pmap
argument_list|,
name|l3
argument_list|,
name|va
argument_list|,
name|pmap_load
argument_list|(
name|pte
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
name|demoted
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|demoted
condition|)
block|{
comment|/* 					 * The superpage mapping was removed 					 * entirely and therefore 'pv' is no 					 * longer valid. 					 */
if|if
condition|(
name|pvf
operator|==
name|pv
condition|)
name|pvf
operator|=
name|NULL
expr_stmt|;
name|pv
operator|=
name|NULL
expr_stmt|;
block|}
name|cleared
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
name|lock
operator|==
name|VM_PAGE_TO_PV_LIST_LOCK
argument_list|(
name|m
argument_list|)
argument_list|,
operator|(
literal|"inconsistent pv lock %p %p for page %p"
operator|,
name|lock
operator|,
name|VM_PAGE_TO_PV_LIST_LOCK
argument_list|(
name|m
argument_list|)
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|not_cleared
operator|++
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
comment|/* Rotate the PV list if it has more than one entry. */
if|if
condition|(
name|pv
operator|!=
name|NULL
operator|&&
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_next
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pvh
operator|->
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pvh
operator|->
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_next
argument_list|)
expr_stmt|;
name|pvh
operator|->
name|pv_gen
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cleared
operator|+
name|not_cleared
operator|>=
name|PMAP_TS_REFERENCED_MAX
condition|)
goto|goto
name|out
goto|;
block|}
do|while
condition|(
operator|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pvh
operator|->
name|pv_list
argument_list|)
operator|)
operator|!=
name|pvf
condition|)
do|;
name|small_mappings
label|:
if|if
condition|(
operator|(
name|pvf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|pv
operator|=
name|pvf
expr_stmt|;
do|do
block|{
if|if
condition|(
name|pvf
operator|==
name|NULL
condition|)
name|pvf
operator|=
name|pv
expr_stmt|;
name|pmap
operator|=
name|PV_PMAP
argument_list|(
name|pv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PMAP_TRYLOCK
argument_list|(
name|pmap
argument_list|)
condition|)
block|{
name|pvh_gen
operator|=
name|pvh
operator|->
name|pv_gen
expr_stmt|;
name|md_gen
operator|=
name|m
operator|->
name|md
operator|.
name|pv_gen
expr_stmt|;
name|rw_wunlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvh_gen
operator|!=
name|pvh
operator|->
name|pv_gen
operator|||
name|md_gen
operator|!=
name|m
operator|->
name|md
operator|.
name|pv_gen
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
name|pde
operator|=
name|pmap_pde
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pde
operator|!=
name|NULL
argument_list|,
operator|(
literal|"pmap_ts_referenced: no l2 table found"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|lvl
operator|==
literal|2
argument_list|,
operator|(
literal|"pmap_ts_referenced: invalid pde level %d"
operator|,
name|lvl
operator|)
argument_list|)
expr_stmt|;
name|tpde
operator|=
name|pmap_load
argument_list|(
name|pde
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|tpde
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L2_TABLE
argument_list|,
operator|(
literal|"pmap_ts_referenced: found an invalid l2 table"
operator|)
argument_list|)
expr_stmt|;
name|pte
operator|=
name|pmap_l2_to_l3
argument_list|(
name|pde
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|tpte
operator|=
name|pmap_load
argument_list|(
name|pte
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tpte
operator|&
name|ATTR_AF
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|safe_to_clear_referenced
argument_list|(
name|pmap
argument_list|,
name|tpte
argument_list|)
condition|)
block|{
comment|/* 				 * TODO: We don't handle the access flag 				 * at all. We need to be able to set it in 				 * the exception handler. 				 */
name|panic
argument_list|(
literal|"ARM64TODO: safe_to_clear_referenced\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tpte
operator|&
name|ATTR_SW_WIRED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Wired pages cannot be paged out so 				 * doing accessed bit emulation for 				 * them is wasted effort. We do the 				 * hard work for unwired pages only. 				 */
name|pmap_remove_l3
argument_list|(
name|pmap
argument_list|,
name|pte
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|,
name|tpde
argument_list|,
operator|&
name|free
argument_list|,
operator|&
name|lock
argument_list|)
expr_stmt|;
name|pmap_invalidate_page
argument_list|(
name|pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|cleared
operator|++
expr_stmt|;
if|if
condition|(
name|pvf
operator|==
name|pv
condition|)
name|pvf
operator|=
name|NULL
expr_stmt|;
name|pv
operator|=
name|NULL
expr_stmt|;
name|KASSERT
argument_list|(
name|lock
operator|==
name|VM_PAGE_TO_PV_LIST_LOCK
argument_list|(
name|m
argument_list|)
argument_list|,
operator|(
literal|"inconsistent pv lock %p %p for page %p"
operator|,
name|lock
operator|,
name|VM_PAGE_TO_PV_LIST_LOCK
argument_list|(
name|m
argument_list|)
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
name|not_cleared
operator|++
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
comment|/* Rotate the PV list if it has more than one entry. */
if|if
condition|(
name|pv
operator|!=
name|NULL
operator|&&
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_next
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_next
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_gen
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
operator|)
operator|!=
name|pvf
operator|&&
name|cleared
operator|+
name|not_cleared
operator|<
name|PMAP_TS_REFERENCED_MAX
condition|)
do|;
name|out
label|:
name|rw_wunlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|pmap_free_zero_pages
argument_list|(
operator|&
name|free
argument_list|)
expr_stmt|;
return|return
operator|(
name|cleared
operator|+
name|not_cleared
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Apply the given advice to the specified range of addresses within the  *	given pmap.  Depending on the advice, clear the referenced and/or  *	modified flags in each mapping and set the mapped page's dirty field.  */
end_comment

begin_function
name|void
name|pmap_advise
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|,
name|int
name|advice
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  *	Clear the modify bits on the specified physical page.  */
end_comment

begin_function
name|void
name|pmap_clear_modify
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_clear_modify: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|m
operator|->
name|object
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|vm_page_xbusied
argument_list|(
name|m
argument_list|)
argument_list|,
operator|(
literal|"pmap_clear_modify: page %p is exclusive busied"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the page is not PGA_WRITEABLE, then no PTEs can have PG_M set. 	 * If the object containing the page is locked and the page is not 	 * exclusive busied, then PGA_WRITEABLE cannot be concurrently set. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|aflags
operator|&
name|PGA_WRITEABLE
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* ARM64TODO: We lack support for tracking if a page is modified */
block|}
end_function

begin_function
name|void
modifier|*
name|pmap_mapbios
parameter_list|(
name|vm_paddr_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
return|return
operator|(
operator|(
name|void
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|pa
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_unmapbios
parameter_list|(
name|vm_paddr_t
name|pa
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  * Sets the memory attribute for the specified page.  */
end_comment

begin_function
name|void
name|pmap_page_set_memattr
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|vm_memattr_t
name|ma
parameter_list|)
block|{
name|m
operator|->
name|md
operator|.
name|pv_memattr
operator|=
name|ma
expr_stmt|;
comment|/* 	 * If "m" is a normal page, update its direct mapping.  This update 	 * can be relied upon to perform any cache operations that are 	 * required for data coherence. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
operator|&&
name|pmap_change_attr
argument_list|(
name|PHYS_TO_DMAP
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
argument_list|,
name|PAGE_SIZE
argument_list|,
name|m
operator|->
name|md
operator|.
name|pv_memattr
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"memory attribute change on the direct map failed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Changes the specified virtual address range's memory type to that given by  * the parameter "mode".  The specified virtual address range must be  * completely contained within either the direct map or the kernel map.  If  * the virtual address range is contained within the kernel map, then the  * memory type for each of the corresponding ranges of the direct map is also  * changed.  (The corresponding ranges of the direct map are those ranges that  * map the same physical pages as the specified virtual address range.)  These  * changes to the direct map are necessary because Intel describes the  * behavior of their processors as "undefined" if two or more mappings to the  * same physical page have different memory types.  *  * Returns zero if the change completed successfully, and either EINVAL or  * ENOMEM if the change failed.  Specifically, EINVAL is returned if some part  * of the virtual address range was not mapped, and ENOMEM is returned if  * there was insufficient memory available to complete the change.  In the  * latter case, the memory type may have been changed on some part of the  * virtual address range or the direct map.  */
end_comment

begin_function
specifier|static
name|int
name|pmap_change_attr
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
name|error
operator|=
name|pmap_change_attr_locked
argument_list|(
name|va
argument_list|,
name|size
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pmap_change_attr_locked
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|vm_offset_t
name|base
decl_stmt|,
name|offset
decl_stmt|,
name|tmpva
decl_stmt|;
name|pt_entry_t
name|l3
decl_stmt|,
modifier|*
name|pte
decl_stmt|,
modifier|*
name|newpte
decl_stmt|;
name|int
name|lvl
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|kernel_pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|base
operator|=
name|trunc_page
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|offset
operator|=
name|va
operator|&
name|PAGE_MASK
expr_stmt|;
name|size
operator|=
name|round_page
argument_list|(
name|offset
operator|+
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|VIRT_IN_DMAP
argument_list|(
name|base
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
for|for
control|(
name|tmpva
operator|=
name|base
init|;
name|tmpva
operator|<
name|base
operator|+
name|size
condition|;
control|)
block|{
name|pte
operator|=
name|pmap_pte
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|,
operator|&
name|lvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|pte
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|pmap_load
argument_list|(
name|pte
argument_list|)
operator|&
name|ATTR_IDX_MASK
operator|)
operator|==
name|ATTR_IDX
argument_list|(
name|mode
argument_list|)
condition|)
block|{
comment|/* 			 * We already have the correct attribute, 			 * ignore this entry. 			 */
switch|switch
condition|(
name|lvl
condition|)
block|{
default|default:
name|panic
argument_list|(
literal|"Invalid DMAP table level: %d\n"
argument_list|,
name|lvl
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|tmpva
operator|=
operator|(
name|tmpva
operator|&
operator|~
name|L1_OFFSET
operator|)
operator|+
name|L1_SIZE
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|tmpva
operator|=
operator|(
name|tmpva
operator|&
operator|~
name|L2_OFFSET
operator|)
operator|+
name|L2_SIZE
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|tmpva
operator|+=
name|PAGE_SIZE
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* 			 * Split the entry to an level 3 table, then 			 * set the new attribute. 			 */
switch|switch
condition|(
name|lvl
condition|)
block|{
default|default:
name|panic
argument_list|(
literal|"Invalid DMAP table level: %d\n"
argument_list|,
name|lvl
argument_list|)
expr_stmt|;
case|case
literal|1
case|:
name|newpte
operator|=
name|pmap_demote_l1
argument_list|(
name|kernel_pmap
argument_list|,
name|pte
argument_list|,
name|tmpva
operator|&
operator|~
name|L1_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|newpte
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pte
operator|=
name|pmap_l1_to_l2
argument_list|(
name|pte
argument_list|,
name|tmpva
argument_list|)
expr_stmt|;
case|case
literal|2
case|:
name|newpte
operator|=
name|pmap_demote_l2
argument_list|(
name|kernel_pmap
argument_list|,
name|pte
argument_list|,
name|tmpva
operator|&
operator|~
name|L2_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|newpte
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|pte
operator|=
name|pmap_l2_to_l3
argument_list|(
name|pte
argument_list|,
name|tmpva
argument_list|)
expr_stmt|;
case|case
literal|3
case|:
comment|/* Update the entry */
name|l3
operator|=
name|pmap_load
argument_list|(
name|pte
argument_list|)
expr_stmt|;
name|l3
operator|&=
operator|~
name|ATTR_IDX_MASK
expr_stmt|;
name|l3
operator||=
name|ATTR_IDX
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|pmap_update_entry
argument_list|(
name|kernel_pmap
argument_list|,
name|pte
argument_list|,
name|l3
argument_list|,
name|tmpva
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* 				 * If moving to a non-cacheable entry flush 				 * the cache. 				 */
if|if
condition|(
name|mode
operator|==
name|VM_MEMATTR_UNCACHEABLE
condition|)
name|cpu_dcache_wbinv_range
argument_list|(
name|tmpva
argument_list|,
name|L3_SIZE
argument_list|)
expr_stmt|;
break|break;
block|}
name|tmpva
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create an L2 table to map all addresses within an L1 mapping.  */
end_comment

begin_function
specifier|static
name|pt_entry_t
modifier|*
name|pmap_demote_l1
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pt_entry_t
modifier|*
name|l1
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|l2
decl_stmt|,
name|newl2
decl_stmt|,
name|oldl1
decl_stmt|;
name|vm_offset_t
name|tmpl1
decl_stmt|;
name|vm_paddr_t
name|l2phys
decl_stmt|,
name|phys
decl_stmt|;
name|vm_page_t
name|ml2
decl_stmt|;
name|int
name|i
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|oldl1
operator|=
name|pmap_load
argument_list|(
name|l1
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|oldl1
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L1_BLOCK
argument_list|,
operator|(
literal|"pmap_demote_l1: Demoting a non-block entry"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|va
operator|&
name|L1_OFFSET
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_demote_l1: Invalid virtual address %#lx"
operator|,
name|va
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|oldl1
operator|&
name|ATTR_SW_MANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_demote_l1: Level 1 table shouldn't be managed"
operator|)
argument_list|)
expr_stmt|;
name|tmpl1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|va
operator|<=
operator|(
name|vm_offset_t
operator|)
name|l1
operator|&&
name|va
operator|+
name|L1_SIZE
operator|>
operator|(
name|vm_offset_t
operator|)
name|l1
condition|)
block|{
name|tmpl1
operator|=
name|kva_alloc
argument_list|(
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpl1
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ml2
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|VM_ALLOC_INTERRUPT
operator||
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_WIRED
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_demote_l1: failure for va %#lx"
literal|" in pmap %p"
argument_list|,
name|va
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|l2phys
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|ml2
argument_list|)
expr_stmt|;
name|l2
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|l2phys
argument_list|)
expr_stmt|;
comment|/* Address the range points at */
name|phys
operator|=
name|oldl1
operator|&
operator|~
name|ATTR_MASK
expr_stmt|;
comment|/* The attributed from the old l1 table to be copied */
name|newl2
operator|=
name|oldl1
operator|&
name|ATTR_MASK
expr_stmt|;
comment|/* Create the new entries */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Ln_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|l2
index|[
name|i
index|]
operator|=
name|newl2
operator||
name|phys
expr_stmt|;
name|phys
operator|+=
name|L2_SIZE
expr_stmt|;
block|}
name|cpu_dcache_wb_range
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|l2
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|l2
index|[
literal|0
index|]
operator|==
operator|(
operator|(
name|oldl1
operator|&
operator|~
name|ATTR_DESCR_MASK
operator|)
operator||
name|L2_BLOCK
operator|)
argument_list|,
operator|(
literal|"Invalid l2 page (%lx != %lx)"
operator|,
name|l2
index|[
literal|0
index|]
operator|,
operator|(
name|oldl1
operator|&
operator|~
name|ATTR_DESCR_MASK
operator|)
operator||
name|L2_BLOCK
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpl1
operator|!=
literal|0
condition|)
block|{
name|pmap_kenter
argument_list|(
name|tmpl1
argument_list|,
name|PAGE_SIZE
argument_list|,
name|DMAP_TO_PHYS
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|l1
argument_list|)
operator|&
operator|~
name|L3_OFFSET
argument_list|,
name|CACHED_MEMORY
argument_list|)
expr_stmt|;
name|l1
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
operator|(
name|tmpl1
operator|+
operator|(
operator|(
name|vm_offset_t
operator|)
name|l1
operator|&
name|PAGE_MASK
operator|)
operator|)
expr_stmt|;
block|}
name|pmap_update_entry
argument_list|(
name|pmap
argument_list|,
name|l1
argument_list|,
name|l2phys
operator||
name|L1_TABLE
argument_list|,
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpl1
operator|!=
literal|0
condition|)
block|{
name|pmap_kremove
argument_list|(
name|tmpl1
argument_list|)
expr_stmt|;
name|kva_free
argument_list|(
name|tmpl1
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create an L3 table to map all addresses within an L2 mapping.  */
end_comment

begin_function
specifier|static
name|pt_entry_t
modifier|*
name|pmap_demote_l2_locked
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pt_entry_t
modifier|*
name|l2
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|struct
name|rwlock
modifier|*
modifier|*
name|lockp
parameter_list|)
block|{
name|pt_entry_t
modifier|*
name|l3
decl_stmt|,
name|newl3
decl_stmt|,
name|oldl2
decl_stmt|;
name|vm_offset_t
name|tmpl2
decl_stmt|;
name|vm_paddr_t
name|l3phys
decl_stmt|,
name|phys
decl_stmt|;
name|vm_page_t
name|ml3
decl_stmt|;
name|int
name|i
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pmap
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|l3
operator|=
name|NULL
expr_stmt|;
name|oldl2
operator|=
name|pmap_load
argument_list|(
name|l2
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|oldl2
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L2_BLOCK
argument_list|,
operator|(
literal|"pmap_demote_l2: Demoting a non-block entry"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|va
operator|&
name|L2_OFFSET
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_demote_l2: Invalid virtual address %#lx"
operator|,
name|va
operator|)
argument_list|)
expr_stmt|;
name|tmpl2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|va
operator|<=
operator|(
name|vm_offset_t
operator|)
name|l2
operator|&&
name|va
operator|+
name|L2_SIZE
operator|>
operator|(
name|vm_offset_t
operator|)
name|l2
condition|)
block|{
name|tmpl2
operator|=
name|kva_alloc
argument_list|(
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpl2
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ml3
operator|=
name|pmap_lookup_pt_page
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pmap_remove_pt_page
argument_list|(
name|pmap
argument_list|,
name|ml3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ml3
operator|=
name|vm_page_alloc
argument_list|(
name|NULL
argument_list|,
name|pmap_l2_pindex
argument_list|(
name|va
argument_list|)
argument_list|,
operator|(
name|VIRT_IN_DMAP
argument_list|(
name|va
argument_list|)
condition|?
name|VM_ALLOC_INTERRUPT
else|:
name|VM_ALLOC_NORMAL
operator|)
operator||
name|VM_ALLOC_NOOBJ
operator||
name|VM_ALLOC_WIRED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ml3
operator|==
name|NULL
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_demote_l2: failure for va %#lx"
literal|" in pmap %p"
argument_list|,
name|va
argument_list|,
name|pmap
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|va
operator|<
name|VM_MAXUSER_ADDRESS
condition|)
name|pmap_resident_count_inc
argument_list|(
name|pmap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|l3phys
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|ml3
argument_list|)
expr_stmt|;
name|l3
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
name|PHYS_TO_DMAP
argument_list|(
name|l3phys
argument_list|)
expr_stmt|;
comment|/* Address the range points at */
name|phys
operator|=
name|oldl2
operator|&
operator|~
name|ATTR_MASK
expr_stmt|;
comment|/* The attributed from the old l2 table to be copied */
name|newl3
operator|=
operator|(
name|oldl2
operator|&
operator|(
name|ATTR_MASK
operator|&
operator|~
name|ATTR_DESCR_MASK
operator|)
operator|)
operator||
name|L3_PAGE
expr_stmt|;
comment|/* 	 * If the page table page is new, initialize it. 	 */
if|if
condition|(
name|ml3
operator|->
name|wire_count
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|Ln_ENTRIES
condition|;
name|i
operator|++
control|)
block|{
name|l3
index|[
name|i
index|]
operator|=
name|newl3
operator||
name|phys
expr_stmt|;
name|phys
operator|+=
name|L3_SIZE
expr_stmt|;
block|}
name|cpu_dcache_wb_range
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|l3
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|l3
index|[
literal|0
index|]
operator|==
operator|(
operator|(
name|oldl2
operator|&
operator|~
name|ATTR_DESCR_MASK
operator|)
operator||
name|L3_PAGE
operator|)
argument_list|,
operator|(
literal|"Invalid l3 page (%lx != %lx)"
operator|,
name|l3
index|[
literal|0
index|]
operator|,
operator|(
name|oldl2
operator|&
operator|~
name|ATTR_DESCR_MASK
operator|)
operator||
name|L3_PAGE
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Map the temporary page so we don't lose access to the l2 table. 	 */
if|if
condition|(
name|tmpl2
operator|!=
literal|0
condition|)
block|{
name|pmap_kenter
argument_list|(
name|tmpl2
argument_list|,
name|PAGE_SIZE
argument_list|,
name|DMAP_TO_PHYS
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|l2
argument_list|)
operator|&
operator|~
name|L3_OFFSET
argument_list|,
name|CACHED_MEMORY
argument_list|)
expr_stmt|;
name|l2
operator|=
operator|(
name|pt_entry_t
operator|*
operator|)
operator|(
name|tmpl2
operator|+
operator|(
operator|(
name|vm_offset_t
operator|)
name|l2
operator|&
name|PAGE_MASK
operator|)
operator|)
expr_stmt|;
block|}
comment|/* 	 * The spare PV entries must be reserved prior to demoting the 	 * mapping, that is, prior to changing the PDE.  Otherwise, the state 	 * of the L2 and the PV lists will be inconsistent, which can result 	 * in reclaim_pv_chunk() attempting to remove a PV entry from the 	 * wrong PV list and pmap_pv_demote_l2() failing to find the expected 	 * PV entry for the 2MB page mapping that is being demoted. 	 */
if|if
condition|(
operator|(
name|oldl2
operator|&
name|ATTR_SW_MANAGED
operator|)
operator|!=
literal|0
condition|)
name|reserve_pv_entries
argument_list|(
name|pmap
argument_list|,
name|Ln_ENTRIES
operator|-
literal|1
argument_list|,
name|lockp
argument_list|)
expr_stmt|;
name|pmap_update_entry
argument_list|(
name|pmap
argument_list|,
name|l2
argument_list|,
name|l3phys
operator||
name|L2_TABLE
argument_list|,
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Demote the PV entry. 	 */
if|if
condition|(
operator|(
name|oldl2
operator|&
name|ATTR_SW_MANAGED
operator|)
operator|!=
literal|0
condition|)
name|pmap_pv_demote_l2
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|,
name|oldl2
operator|&
operator|~
name|ATTR_MASK
argument_list|,
name|lockp
argument_list|)
expr_stmt|;
name|atomic_add_long
argument_list|(
operator|&
name|pmap_l2_demotions
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_demote_l2: success for va %#lx"
literal|" in pmap %p %lx"
argument_list|,
name|va
argument_list|,
name|pmap
argument_list|,
name|l3
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fail
label|:
if|if
condition|(
name|tmpl2
operator|!=
literal|0
condition|)
block|{
name|pmap_kremove
argument_list|(
name|tmpl2
argument_list|)
expr_stmt|;
name|kva_free
argument_list|(
name|tmpl2
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|l3
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|pt_entry_t
modifier|*
name|pmap_demote_l2
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|pt_entry_t
modifier|*
name|l2
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|rwlock
modifier|*
name|lock
decl_stmt|;
name|pt_entry_t
modifier|*
name|l3
decl_stmt|;
name|lock
operator|=
name|NULL
expr_stmt|;
name|l3
operator|=
name|pmap_demote_l2_locked
argument_list|(
name|pmap
argument_list|,
name|l2
argument_list|,
name|va
argument_list|,
operator|&
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|!=
name|NULL
condition|)
name|rw_wunlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|l3
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * perform the pmap work for mincore  */
end_comment

begin_function
name|int
name|pmap_mincore
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_paddr_t
modifier|*
name|locked_pa
parameter_list|)
block|{
name|pd_entry_t
modifier|*
name|l1p
decl_stmt|,
name|l1
decl_stmt|;
name|pd_entry_t
modifier|*
name|l2p
decl_stmt|,
name|l2
decl_stmt|;
name|pt_entry_t
modifier|*
name|l3p
decl_stmt|,
name|l3
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|bool
name|managed
decl_stmt|;
name|int
name|val
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|retry
label|:
name|pa
operator|=
literal|0
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|managed
operator|=
name|false
expr_stmt|;
name|l1p
operator|=
name|pmap_l1
argument_list|(
name|pmap
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|l1p
operator|==
name|NULL
condition|)
comment|/* No l1 */
goto|goto
name|done
goto|;
name|l1
operator|=
name|pmap_load
argument_list|(
name|l1p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l1
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L1_INVAL
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|(
name|l1
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L1_BLOCK
condition|)
block|{
name|pa
operator|=
operator|(
name|l1
operator|&
operator|~
name|ATTR_MASK
operator|)
operator||
operator|(
name|addr
operator|&
name|L1_OFFSET
operator|)
expr_stmt|;
name|managed
operator|=
operator|(
name|l1
operator|&
name|ATTR_SW_MANAGED
operator|)
operator|==
name|ATTR_SW_MANAGED
expr_stmt|;
name|val
operator|=
name|MINCORE_SUPER
operator||
name|MINCORE_INCORE
expr_stmt|;
if|if
condition|(
name|pmap_page_dirty
argument_list|(
name|l1
argument_list|)
condition|)
name|val
operator||=
name|MINCORE_MODIFIED
operator||
name|MINCORE_MODIFIED_OTHER
expr_stmt|;
if|if
condition|(
operator|(
name|l1
operator|&
name|ATTR_AF
operator|)
operator|==
name|ATTR_AF
condition|)
name|val
operator||=
name|MINCORE_REFERENCED
operator||
name|MINCORE_REFERENCED_OTHER
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|l2p
operator|=
name|pmap_l1_to_l2
argument_list|(
name|l1p
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2p
operator|==
name|NULL
condition|)
comment|/* No l2 */
goto|goto
name|done
goto|;
name|l2
operator|=
name|pmap_load
argument_list|(
name|l2p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l2
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L2_INVAL
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|(
name|l2
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L2_BLOCK
condition|)
block|{
name|pa
operator|=
operator|(
name|l2
operator|&
operator|~
name|ATTR_MASK
operator|)
operator||
operator|(
name|addr
operator|&
name|L2_OFFSET
operator|)
expr_stmt|;
name|managed
operator|=
operator|(
name|l2
operator|&
name|ATTR_SW_MANAGED
operator|)
operator|==
name|ATTR_SW_MANAGED
expr_stmt|;
name|val
operator|=
name|MINCORE_SUPER
operator||
name|MINCORE_INCORE
expr_stmt|;
if|if
condition|(
name|pmap_page_dirty
argument_list|(
name|l2
argument_list|)
condition|)
name|val
operator||=
name|MINCORE_MODIFIED
operator||
name|MINCORE_MODIFIED_OTHER
expr_stmt|;
if|if
condition|(
operator|(
name|l2
operator|&
name|ATTR_AF
operator|)
operator|==
name|ATTR_AF
condition|)
name|val
operator||=
name|MINCORE_REFERENCED
operator||
name|MINCORE_REFERENCED_OTHER
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|l3p
operator|=
name|pmap_l2_to_l3
argument_list|(
name|l2p
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|l3p
operator|==
name|NULL
condition|)
comment|/* No l3 */
goto|goto
name|done
goto|;
name|l3
operator|=
name|pmap_load
argument_list|(
name|l2p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l3
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L3_INVAL
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
operator|(
name|l3
operator|&
name|ATTR_DESCR_MASK
operator|)
operator|==
name|L3_PAGE
condition|)
block|{
name|pa
operator|=
operator|(
name|l3
operator|&
operator|~
name|ATTR_MASK
operator|)
operator||
operator|(
name|addr
operator|&
name|L3_OFFSET
operator|)
expr_stmt|;
name|managed
operator|=
operator|(
name|l3
operator|&
name|ATTR_SW_MANAGED
operator|)
operator|==
name|ATTR_SW_MANAGED
expr_stmt|;
name|val
operator|=
name|MINCORE_INCORE
expr_stmt|;
if|if
condition|(
name|pmap_page_dirty
argument_list|(
name|l3
argument_list|)
condition|)
name|val
operator||=
name|MINCORE_MODIFIED
operator||
name|MINCORE_MODIFIED_OTHER
expr_stmt|;
if|if
condition|(
operator|(
name|l3
operator|&
name|ATTR_AF
operator|)
operator|==
name|ATTR_AF
condition|)
name|val
operator||=
name|MINCORE_REFERENCED
operator||
name|MINCORE_REFERENCED_OTHER
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
operator|(
name|val
operator|&
operator|(
name|MINCORE_MODIFIED_OTHER
operator||
name|MINCORE_REFERENCED_OTHER
operator|)
operator|)
operator|!=
operator|(
name|MINCORE_MODIFIED_OTHER
operator||
name|MINCORE_REFERENCED_OTHER
operator|)
operator|&&
name|managed
condition|)
block|{
comment|/* Ensure that "PHYS_TO_VM_PAGE(pa)->object" doesn't change. */
if|if
condition|(
name|vm_page_pa_tryrelock
argument_list|(
name|pmap
argument_list|,
name|pa
argument_list|,
name|locked_pa
argument_list|)
condition|)
goto|goto
name|retry
goto|;
block|}
else|else
name|PA_UNLOCK_COND
argument_list|(
operator|*
name|locked_pa
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_activate
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|pmap_t
name|pmap
decl_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|pmap
operator|=
name|vmspace_pmap
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_pcb
operator|->
name|pcb_l0addr
operator|=
name|vtophys
argument_list|(
name|pmap
operator|->
name|pm_l0
argument_list|)
expr_stmt|;
asm|__asm __volatile("msr ttbr0_el1, %0" : : "r"(td->td_pcb->pcb_l0addr));
name|pmap_invalidate_all
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_sync_icache
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|sz
parameter_list|)
block|{
if|if
condition|(
name|va
operator|>=
name|VM_MIN_KERNEL_ADDRESS
condition|)
block|{
name|cpu_icache_sync_range
argument_list|(
name|va
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|u_int
name|len
decl_stmt|,
name|offset
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
comment|/* Find the length of data in this page to flush */
name|offset
operator|=
name|va
operator|&
name|PAGE_MASK
expr_stmt|;
name|len
operator|=
name|imin
argument_list|(
name|PAGE_SIZE
operator|-
name|offset
argument_list|,
name|sz
argument_list|)
expr_stmt|;
while|while
condition|(
name|sz
operator|!=
literal|0
condition|)
block|{
comment|/* Extract the physical address& find it in the DMAP */
name|pa
operator|=
name|pmap_extract
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|!=
literal|0
condition|)
name|cpu_icache_sync_range
argument_list|(
name|PHYS_TO_DMAP
argument_list|(
name|pa
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Move to the next page */
name|sz
operator|-=
name|len
expr_stmt|;
name|va
operator|+=
name|len
expr_stmt|;
comment|/* Set the length for the next iteration */
name|len
operator|=
name|imin
argument_list|(
name|PAGE_SIZE
argument_list|,
name|sz
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|pmap_fault
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|uint64_t
name|esr
parameter_list|,
name|uint64_t
name|far
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SMP
name|uint64_t
name|par
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|ESR_ELx_EXCEPTION
argument_list|(
name|esr
argument_list|)
condition|)
block|{
case|case
name|EXCP_DATA_ABORT_L
case|:
case|case
name|EXCP_DATA_ABORT
case|:
break|break;
default|default:
return|return
operator|(
name|KERN_FAILURE
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SMP
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|esr
operator|&
name|ISS_DATA_DFSC_MASK
condition|)
block|{
case|case
name|ISS_DATA_DFSC_TF_L0
case|:
case|case
name|ISS_DATA_DFSC_TF_L1
case|:
case|case
name|ISS_DATA_DFSC_TF_L2
case|:
case|case
name|ISS_DATA_DFSC_TF_L3
case|:
comment|/* Ask the MMU to check the address */
if|if
condition|(
name|pmap
operator|==
name|kernel_pmap
condition|)
name|par
operator|=
name|arm64_address_translate_s1e1r
argument_list|(
name|far
argument_list|)
expr_stmt|;
else|else
name|par
operator|=
name|arm64_address_translate_s1e0r
argument_list|(
name|far
argument_list|)
expr_stmt|;
comment|/* 		 * If the translation was successful the address was invalid 		 * due to a break-before-make sequence. We can unlock and 		 * return success to the trap handler. 		 */
if|if
condition|(
name|PAR_SUCCESS
argument_list|(
name|par
argument_list|)
condition|)
block|{
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
break|break;
default|default:
break|break;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|KERN_FAILURE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	Increase the starting virtual address of the given mapping if a  *	different alignment might result in more superpage mappings.  */
end_comment

begin_function
name|void
name|pmap_align_superpage
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_offset_t
modifier|*
name|addr
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|vm_offset_t
name|superpage_offset
decl_stmt|;
if|if
condition|(
name|size
operator|<
name|L2_SIZE
condition|)
return|return;
if|if
condition|(
name|object
operator|!=
name|NULL
operator|&&
operator|(
name|object
operator|->
name|flags
operator|&
name|OBJ_COLORED
operator|)
operator|!=
literal|0
condition|)
name|offset
operator|+=
name|ptoa
argument_list|(
name|object
operator|->
name|pg_color
argument_list|)
expr_stmt|;
name|superpage_offset
operator|=
name|offset
operator|&
name|L2_OFFSET
expr_stmt|;
if|if
condition|(
name|size
operator|-
operator|(
operator|(
name|L2_SIZE
operator|-
name|superpage_offset
operator|)
operator|&
name|L2_OFFSET
operator|)
operator|<
name|L2_SIZE
operator|||
operator|(
operator|*
name|addr
operator|&
name|L2_OFFSET
operator|)
operator|==
name|superpage_offset
condition|)
return|return;
if|if
condition|(
operator|(
operator|*
name|addr
operator|&
name|L2_OFFSET
operator|)
operator|<
name|superpage_offset
condition|)
operator|*
name|addr
operator|=
operator|(
operator|*
name|addr
operator|&
operator|~
name|L2_OFFSET
operator|)
operator|+
name|superpage_offset
expr_stmt|;
else|else
operator|*
name|addr
operator|=
operator|(
operator|(
operator|*
name|addr
operator|+
name|L2_OFFSET
operator|)
operator|&
operator|~
name|L2_OFFSET
operator|)
operator|+
name|superpage_offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Get the kernel virtual address of a set of physical pages. If there are  * physical addresses not covered by the DMAP perform a transient mapping  * that will be removed when calling pmap_unmap_io_transient.  *  * \param page        The pages the caller wishes to obtain the virtual  *                    address on the kernel memory map.  * \param vaddr       On return contains the kernel virtual memory address  *                    of the pages passed in the page parameter.  * \param count       Number of pages passed in.  * \param can_fault   TRUE if the thread using the mapped pages can take  *                    page faults, FALSE otherwise.  *  * \returns TRUE if the caller must call pmap_unmap_io_transient when  *          finished or FALSE otherwise.  *  */
end_comment

begin_function
name|boolean_t
name|pmap_map_io_transient
parameter_list|(
name|vm_page_t
name|page
index|[]
parameter_list|,
name|vm_offset_t
name|vaddr
index|[]
parameter_list|,
name|int
name|count
parameter_list|,
name|boolean_t
name|can_fault
parameter_list|)
block|{
name|vm_paddr_t
name|paddr
decl_stmt|;
name|boolean_t
name|needs_mapping
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * Allocate any KVA space that we need, this is done in a separate 	 * loop to prevent calling vmem_alloc while pinned. 	 */
name|needs_mapping
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|paddr
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|page
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|!
name|PHYS_IN_DMAP
argument_list|(
name|paddr
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|=
name|vmem_alloc
argument_list|(
name|kernel_arena
argument_list|,
name|PAGE_SIZE
argument_list|,
name|M_BESTFIT
operator||
name|M_WAITOK
argument_list|,
operator|&
name|vaddr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"vmem_alloc failed: %d"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
name|needs_mapping
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|vaddr
index|[
name|i
index|]
operator|=
name|PHYS_TO_DMAP
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Exit early if everything is covered by the DMAP */
if|if
condition|(
operator|!
name|needs_mapping
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|can_fault
condition|)
name|sched_pin
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|paddr
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|page
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PHYS_IN_DMAP
argument_list|(
name|paddr
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"pmap_map_io_transient: TODO: Map out of DMAP data"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|needs_mapping
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_unmap_io_transient
parameter_list|(
name|vm_page_t
name|page
index|[]
parameter_list|,
name|vm_offset_t
name|vaddr
index|[]
parameter_list|,
name|int
name|count
parameter_list|,
name|boolean_t
name|can_fault
parameter_list|)
block|{
name|vm_paddr_t
name|paddr
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|can_fault
condition|)
name|sched_unpin
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|paddr
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|page
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|PHYS_IN_DMAP
argument_list|(
name|paddr
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"ARM64TODO: pmap_unmap_io_transient: Unmap data"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

