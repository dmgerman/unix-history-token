begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Semihalf under  * the sponsorship of the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bitset.h>
end_include

begin_include
include|#
directive|include
file|<sys/bitstring.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/intr.h>
end_include

begin_include
include|#
directive|include
file|"gic_v3_reg.h"
end_include

begin_include
include|#
directive|include
file|"gic_v3_var.h"
end_include

begin_define
define|#
directive|define
name|GIC_V3_ITS_QUIRK_THUNDERX_PEM_BUS_OFFSET
value|88
end_define

begin_include
include|#
directive|include
file|"pic_if.h"
end_include

begin_comment
comment|/* Device and PIC methods */
end_comment

begin_function_decl
specifier|static
name|int
name|gic_v3_its_attach
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|device_method_t
name|gic_v3_its_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|gic_v3_its_attach
argument_list|)
block|,
comment|/* 	 * PIC interface 	 */
comment|/* MSI-X */
name|DEVMETHOD
argument_list|(
name|pic_alloc_msix
argument_list|,
name|gic_v3_its_alloc_msix
argument_list|)
block|,
comment|/* MSI */
name|DEVMETHOD
argument_list|(
name|pic_alloc_msi
argument_list|,
name|gic_v3_its_alloc_msi
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pic_map_msi
argument_list|,
name|gic_v3_its_map_msi
argument_list|)
block|,
comment|/* End */
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_0
argument_list|(
name|its
argument_list|,
name|gic_v3_its_driver
argument_list|,
name|gic_v3_its_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|gic_v3_its_softc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_GIC_V3_ITS
argument_list|,
literal|"GICv3 ITS"
argument_list|,
name|GIC_V3_ITS_DEVSTR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|its_alloc_tables
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|its_free_tables
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|its_init_commandq
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|its_init_cpu_collection
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|its_get_devid
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|its_dev
modifier|*
name|its_device_find_locked
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
parameter_list|,
name|device_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|its_cmd_send
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
parameter_list|,
name|struct
name|its_cmd_desc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|its_cmd_movi
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
parameter_list|,
name|struct
name|its_dev
modifier|*
parameter_list|,
name|struct
name|its_col
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|its_cmd_mapc
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
parameter_list|,
name|struct
name|its_col
modifier|*
parameter_list|,
name|uint8_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|its_cmd_mapvi
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
parameter_list|,
name|struct
name|its_dev
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|its_cmd_mapi
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
parameter_list|,
name|struct
name|its_dev
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|its_cmd_inv
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
parameter_list|,
name|struct
name|its_dev
modifier|*
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|its_cmd_invall
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
parameter_list|,
name|struct
name|its_col
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|its_get_devbits
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lpi_init_conftable
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lpi_bitmap_init
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lpi_config_cpu
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lpi_alloc_cpu_pendtables
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|const
name|char
modifier|*
name|its_ptab_cache
index|[]
init|=
block|{
index|[
name|GITS_BASER_CACHE_NCNB
index|]
operator|=
literal|"(NC,NB)"
block|,
index|[
name|GITS_BASER_CACHE_NC
index|]
operator|=
literal|"(NC)"
block|,
index|[
name|GITS_BASER_CACHE_RAWT
index|]
operator|=
literal|"(RA,WT)"
block|,
index|[
name|GITS_BASER_CACHE_RAWB
index|]
operator|=
literal|"(RA,WB)"
block|,
index|[
name|GITS_BASER_CACHE_WAWT
index|]
operator|=
literal|"(WA,WT)"
block|,
index|[
name|GITS_BASER_CACHE_WAWB
index|]
operator|=
literal|"(WA,WB)"
block|,
index|[
name|GITS_BASER_CACHE_RAWAWT
index|]
operator|=
literal|"(RAWA,WT)"
block|,
index|[
name|GITS_BASER_CACHE_RAWAWB
index|]
operator|=
literal|"(RAWA,WB)"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|its_ptab_share
index|[]
init|=
block|{
index|[
name|GITS_BASER_SHARE_NS
index|]
operator|=
literal|"none"
block|,
index|[
name|GITS_BASER_SHARE_IS
index|]
operator|=
literal|"inner"
block|,
index|[
name|GITS_BASER_SHARE_OS
index|]
operator|=
literal|"outer"
block|,
index|[
name|GITS_BASER_SHARE_RES
index|]
operator|=
literal|"none"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|its_ptab_type
index|[]
init|=
block|{
index|[
name|GITS_BASER_TYPE_UNIMPL
index|]
operator|=
literal|"Unimplemented"
block|,
index|[
name|GITS_BASER_TYPE_DEV
index|]
operator|=
literal|"Devices"
block|,
index|[
name|GITS_BASER_TYPE_VP
index|]
operator|=
literal|"Virtual Processors"
block|,
index|[
name|GITS_BASER_TYPE_PP
index|]
operator|=
literal|"Physical Processors"
block|,
index|[
name|GITS_BASER_TYPE_IC
index|]
operator|=
literal|"Interrupt Collections"
block|,
index|[
name|GITS_BASER_TYPE_RES5
index|]
operator|=
literal|"Reserved (5)"
block|,
index|[
name|GITS_BASER_TYPE_RES6
index|]
operator|=
literal|"Reserved (6)"
block|,
index|[
name|GITS_BASER_TYPE_RES7
index|]
operator|=
literal|"Reserved (7)"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Vendor specific quirks.  * One needs to add appropriate entry to its_quirks[]  * table if the imlementation varies from the generic ARM ITS.  */
end_comment

begin_comment
comment|/* Cavium ThunderX PCI devid acquire function */
end_comment

begin_function_decl
specifier|static
name|uint32_t
name|its_get_devbits_thunder
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|its_get_devid_thunder
parameter_list|(
name|device_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|its_quirks
name|its_quirks
index|[]
init|=
block|{
block|{
comment|/* 		 * Hardware:		Cavium ThunderX 		 * Chip revision:	Pass 1.0, Pass 1.1 		 */
operator|.
name|cpuid
operator|=
name|CPU_ID_RAW
argument_list|(
name|CPU_IMPL_CAVIUM
argument_list|,
name|CPU_PART_THUNDER
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
block|,
operator|.
name|cpuid_mask
operator|=
name|CPU_IMPL_MASK
operator||
name|CPU_PART_MASK
block|,
operator|.
name|devid_func
operator|=
name|its_get_devid_thunder
block|,
operator|.
name|devbits_func
operator|=
name|its_get_devbits_thunder
block|, 	}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|gic_v3_its_softc
modifier|*
name|its_sc
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|gic_its_read
parameter_list|(
name|sc
parameter_list|,
name|len
parameter_list|,
name|reg
parameter_list|)
define|\
value|bus_read_##len(&sc->its_res[0], reg)
end_define

begin_define
define|#
directive|define
name|gic_its_write
parameter_list|(
name|sc
parameter_list|,
name|len
parameter_list|,
name|reg
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_write_##len(&sc->its_res[0], reg, val)
end_define

begin_function
specifier|static
name|int
name|gic_v3_its_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
decl_stmt|;
name|uint64_t
name|gits_tmp
decl_stmt|;
name|uint32_t
name|gits_pidr2
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * XXX ARM64TODO: Avoid configuration of more than one ITS 	 * device. To be removed when multi-PIC support is added 	 * to FreeBSD (or at least multi-ITS is implemented). Limit 	 * supported ITS sockets to '0' only. 	 */
if|if
condition|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Only single instance of ITS is supported, exiting...\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|its_socket
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Initialize sleep& spin mutex for ITS 	 */
comment|/* Protects ITS device list and assigned LPIs bitmaps. */
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|its_dev_lock
argument_list|,
literal|"ITS dev lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
comment|/* Protects access to ITS command circular buffer. */
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|its_cmd_lock
argument_list|,
literal|"ITS cmd lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|rid
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|its_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|its_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Could not allocate memory\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|sc
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|gits_pidr2
operator|=
name|gic_its_read
argument_list|(
name|sc
argument_list|,
literal|4
argument_list|,
name|GITS_PIDR2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gits_pidr2
operator|&
name|GITS_PIDR2_ARCH_MASK
condition|)
block|{
case|case
name|GITS_PIDR2_ARCH_GICv3
case|:
comment|/* fall through */
case|case
name|GITS_PIDR2_ARCH_GICv4
case|:
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ITS found. Architecture rev. %u\n"
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|gits_pidr2
operator|&
name|GITS_PIDR2_ARCH_MASK
argument_list|)
operator|>>
literal|4
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"No ITS found in the system\n"
argument_list|)
expr_stmt|;
name|gic_v3_its_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
block|}
comment|/* 1. Initialize commands queue */
name|its_init_commandq
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 2. Provide memory for any private ITS tables */
name|ret
operator|=
name|its_alloc_tables
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|gic_v3_its_detach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* 3. Allocate collections. One per-CPU */
for|for
control|(
name|int
name|cpu
init|=
literal|0
init|;
name|cpu
operator|<
name|mp_ncpus
condition|;
name|cpu
operator|++
control|)
if|if
condition|(
name|CPU_ISSET
argument_list|(
name|cpu
argument_list|,
operator|&
name|all_cpus
argument_list|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|its_cols
index|[
name|cpu
index|]
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|its_cols
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|M_GIC_V3_ITS
argument_list|,
operator|(
name|M_WAITOK
operator||
name|M_ZERO
operator|)
argument_list|)
expr_stmt|;
else|else
name|sc
operator|->
name|its_cols
index|[
name|cpu
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* 4. Enable ITS in GITS_CTLR */
name|gits_tmp
operator|=
name|gic_its_read
argument_list|(
name|sc
argument_list|,
literal|4
argument_list|,
name|GITS_CTLR
argument_list|)
expr_stmt|;
name|gic_its_write
argument_list|(
name|sc
argument_list|,
literal|4
argument_list|,
name|GITS_CTLR
argument_list|,
name|gits_tmp
operator||
name|GITS_CTLR_EN
argument_list|)
expr_stmt|;
comment|/* 5. Initialize LPIs configuration table */
name|lpi_init_conftable
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 6. LPIs bitmap init */
name|lpi_bitmap_init
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 7. Allocate pending tables for all CPUs */
name|lpi_alloc_cpu_pendtables
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 8. CPU init */
operator|(
name|void
operator|)
name|its_init_cpu
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* 9. Init ITS devices list */
name|TAILQ_INIT
argument_list|(
operator|&
name|sc
operator|->
name|its_dev_list
argument_list|)
expr_stmt|;
name|arm_register_msi_pic
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * XXX ARM64TODO: We need to have ITS software context 	 * when being called by the interrupt code (mask/unmask). 	 * This may be used only when one ITS is present in 	 * the system and eventually should be removed. 	 */
name|KASSERT
argument_list|(
name|its_sc
operator|==
name|NULL
argument_list|,
operator|(
literal|"Trying to assign its_sc that is already set"
operator|)
argument_list|)
expr_stmt|;
name|its_sc
operator|=
name|sc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Will not detach but use it for convenience */
end_comment

begin_function
name|int
name|gic_v3_its_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|device_t
name|parent
decl_stmt|;
name|struct
name|gic_v3_softc
modifier|*
name|gic_sc
decl_stmt|;
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
decl_stmt|;
name|u_int
name|cpuid
decl_stmt|;
name|int
name|rid
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|cpuid
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
comment|/* Release what's possible */
comment|/* Command queue */
if|if
condition|(
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|its_cmdq_base
operator|!=
name|NULL
condition|)
block|{
name|contigfree
argument_list|(
operator|(
name|void
operator|*
operator|)
name|sc
operator|->
name|its_cmdq_base
argument_list|,
name|ITS_CMDQ_SIZE
argument_list|,
name|M_GIC_V3_ITS
argument_list|)
expr_stmt|;
block|}
comment|/* ITTs */
name|its_free_tables
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Collections */
for|for
control|(
name|cpuid
operator|=
literal|0
init|;
name|cpuid
operator|<
name|mp_ncpus
condition|;
name|cpuid
operator|++
control|)
name|free
argument_list|(
name|sc
operator|->
name|its_cols
index|[
name|cpuid
index|]
argument_list|,
name|M_GIC_V3_ITS
argument_list|)
expr_stmt|;
comment|/* LPI config table */
name|parent
operator|=
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|gic_sc
operator|=
name|device_get_softc
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|void
operator|*
operator|)
name|gic_sc
operator|->
name|gic_redists
operator|.
name|lpis
operator|.
name|conf_base
operator|!=
name|NULL
condition|)
block|{
name|contigfree
argument_list|(
operator|(
name|void
operator|*
operator|)
name|gic_sc
operator|->
name|gic_redists
operator|.
name|lpis
operator|.
name|conf_base
argument_list|,
name|LPI_CONFTAB_SIZE
argument_list|,
name|M_GIC_V3_ITS
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|cpuid
operator|=
literal|0
init|;
name|cpuid
operator|<
name|mp_ncpus
condition|;
name|cpuid
operator|++
control|)
if|if
condition|(
operator|(
name|void
operator|*
operator|)
name|gic_sc
operator|->
name|gic_redists
operator|.
name|lpis
operator|.
name|pend_base
index|[
name|cpuid
index|]
operator|!=
name|NULL
condition|)
block|{
name|contigfree
argument_list|(
operator|(
name|void
operator|*
operator|)
name|gic_sc
operator|->
name|gic_redists
operator|.
name|lpis
operator|.
name|pend_base
index|[
name|cpuid
index|]
argument_list|,
name|roundup2
argument_list|(
name|LPI_PENDTAB_SIZE
argument_list|,
name|PAGE_SIZE_64K
argument_list|)
argument_list|,
name|M_GIC_V3_ITS
argument_list|)
expr_stmt|;
block|}
comment|/* Resource... */
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|sc
operator|->
name|its_res
argument_list|)
expr_stmt|;
comment|/* XXX ARM64TODO: Reset global pointer to ITS software context */
name|its_sc
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|its_alloc_tables
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint64_t
name|gits_baser
decl_stmt|,
name|gits_tmp
decl_stmt|;
name|uint64_t
name|type
decl_stmt|,
name|esize
decl_stmt|,
name|cache
decl_stmt|,
name|share
decl_stmt|,
name|psz
decl_stmt|;
name|size_t
name|page_size
decl_stmt|,
name|npages
decl_stmt|,
name|nitspages
decl_stmt|,
name|nidents
decl_stmt|,
name|tn
decl_stmt|;
name|size_t
name|its_tbl_size
decl_stmt|;
name|vm_offset_t
name|ptab_vaddr
decl_stmt|;
name|vm_paddr_t
name|ptab_paddr
decl_stmt|;
name|boolean_t
name|first
init|=
name|TRUE
decl_stmt|;
name|page_size
operator|=
name|PAGE_SIZE_64K
expr_stmt|;
for|for
control|(
name|tn
operator|=
literal|0
init|;
name|tn
operator|<
name|GITS_BASER_NUM
condition|;
name|tn
operator|++
control|)
block|{
name|gits_baser
operator|=
name|gic_its_read
argument_list|(
name|sc
argument_list|,
literal|8
argument_list|,
name|GITS_BASER
argument_list|(
name|tn
argument_list|)
argument_list|)
expr_stmt|;
name|type
operator|=
name|GITS_BASER_TYPE
argument_list|(
name|gits_baser
argument_list|)
expr_stmt|;
comment|/* Get the Table Entry size */
name|esize
operator|=
name|GITS_BASER_ESIZE
argument_list|(
name|gits_baser
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|GITS_BASER_TYPE_UNIMPL
case|:
comment|/* fall through */
case|case
name|GITS_BASER_TYPE_RES5
case|:
case|case
name|GITS_BASER_TYPE_RES6
case|:
case|case
name|GITS_BASER_TYPE_RES7
case|:
continue|continue;
case|case
name|GITS_BASER_TYPE_DEV
case|:
name|nidents
operator|=
operator|(
literal|1
operator|<<
name|its_get_devbits
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
operator|)
expr_stmt|;
name|its_tbl_size
operator|=
name|esize
operator|*
name|nidents
expr_stmt|;
name|its_tbl_size
operator|=
name|roundup2
argument_list|(
name|its_tbl_size
argument_list|,
name|page_size
argument_list|)
expr_stmt|;
name|npages
operator|=
name|howmany
argument_list|(
name|its_tbl_size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|npages
operator|=
name|howmany
argument_list|(
name|page_size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Allocate required space */
name|ptab_vaddr
operator|=
operator|(
name|vm_offset_t
operator|)
name|contigmalloc
argument_list|(
name|npages
operator|*
name|PAGE_SIZE
argument_list|,
name|M_GIC_V3_ITS
argument_list|,
operator|(
name|M_WAITOK
operator||
name|M_ZERO
operator|)
argument_list|,
literal|0
argument_list|,
operator|~
literal|0UL
argument_list|,
name|PAGE_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|its_ptabs
index|[
name|tn
index|]
operator|.
name|ptab_vaddr
operator|=
name|ptab_vaddr
expr_stmt|;
name|sc
operator|->
name|its_ptabs
index|[
name|tn
index|]
operator|.
name|ptab_pgsz
operator|=
name|PAGE_SIZE
expr_stmt|;
name|sc
operator|->
name|its_ptabs
index|[
name|tn
index|]
operator|.
name|ptab_npages
operator|=
name|npages
expr_stmt|;
name|ptab_paddr
operator|=
name|vtophys
argument_list|(
name|ptab_vaddr
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ptab_paddr
operator|&
name|GITS_BASER_PA_MASK
operator|)
operator|==
name|ptab_paddr
argument_list|,
operator|(
literal|"%s: Unaligned PA for Interrupt Translation Table"
operator|,
name|device_get_name
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Set defaults: WAWB, IS */
name|cache
operator|=
name|GITS_BASER_CACHE_WAWB
expr_stmt|;
name|share
operator|=
name|GITS_BASER_SHARE_IS
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|nitspages
operator|=
name|howmany
argument_list|(
name|its_tbl_size
argument_list|,
name|page_size
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|page_size
condition|)
block|{
case|case
name|PAGE_SIZE
case|:
comment|/* 4KB */
name|psz
operator|=
name|GITS_BASER_PSZ_4K
expr_stmt|;
break|break;
case|case
name|PAGE_SIZE_16K
case|:
comment|/* 16KB */
name|psz
operator|=
name|GITS_BASER_PSZ_4K
expr_stmt|;
break|break;
case|case
name|PAGE_SIZE_64K
case|:
comment|/* 64KB */
name|psz
operator|=
name|GITS_BASER_PSZ_64K
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Unsupported page size: %zuKB\n"
argument_list|,
operator|(
name|page_size
operator|/
literal|1024
operator|)
argument_list|)
expr_stmt|;
name|its_free_tables
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Clear fields under modification first */
name|gits_baser
operator|&=
operator|~
operator|(
name|GITS_BASER_VALID
operator||
name|GITS_BASER_CACHE_MASK
operator||
name|GITS_BASER_TYPE_MASK
operator||
name|GITS_BASER_ESIZE_MASK
operator||
name|GITS_BASER_PA_MASK
operator||
name|GITS_BASER_SHARE_MASK
operator||
name|GITS_BASER_PSZ_MASK
operator||
name|GITS_BASER_SIZE_MASK
operator|)
expr_stmt|;
comment|/* Construct register value */
name|gits_baser
operator||=
operator|(
name|type
operator|<<
name|GITS_BASER_TYPE_SHIFT
operator|)
operator||
operator|(
operator|(
name|esize
operator|-
literal|1
operator|)
operator|<<
name|GITS_BASER_ESIZE_SHIFT
operator|)
operator||
operator|(
name|cache
operator|<<
name|GITS_BASER_CACHE_SHIFT
operator|)
operator||
operator|(
name|share
operator|<<
name|GITS_BASER_SHARE_SHIFT
operator|)
operator||
operator|(
name|psz
operator|<<
name|GITS_BASER_PSZ_SHIFT
operator|)
operator||
name|ptab_paddr
operator||
operator|(
name|nitspages
operator|-
literal|1
operator|)
operator||
name|GITS_BASER_VALID
expr_stmt|;
name|gic_its_write
argument_list|(
name|sc
argument_list|,
literal|8
argument_list|,
name|GITS_BASER
argument_list|(
name|tn
argument_list|)
argument_list|,
name|gits_baser
argument_list|)
expr_stmt|;
comment|/* 			 * Verify. 			 * Depending on implementation we may encounter 			 * shareability and page size mismatch. 			 */
name|gits_tmp
operator|=
name|gic_its_read
argument_list|(
name|sc
argument_list|,
literal|8
argument_list|,
name|GITS_BASER
argument_list|(
name|tn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|gits_tmp
operator|^
name|gits_baser
operator|)
operator|&
name|GITS_BASER_SHARE_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|share
operator|=
name|gits_tmp
operator|&
name|GITS_BASER_SHARE_MASK
expr_stmt|;
name|share
operator|>>=
name|GITS_BASER_SHARE_SHIFT
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
operator|(
name|gits_tmp
operator|^
name|gits_baser
operator|)
operator|&
name|GITS_BASER_PSZ_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|page_size
condition|)
block|{
case|case
name|PAGE_SIZE_16K
case|:
comment|/* Drop to 4KB page */
name|page_size
operator|=
name|PAGE_SIZE
expr_stmt|;
continue|continue;
case|case
name|PAGE_SIZE_64K
case|:
comment|/* Drop to 16KB page */
name|page_size
operator|=
name|PAGE_SIZE_16K
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 			 * All possible adjustments should 			 * be applied by now so just break the loop. 			 */
break|break;
block|}
comment|/* 		 * Do not compare Cacheability field since 		 * it is implementation defined. 		 */
name|gits_tmp
operator|&=
operator|~
name|GITS_BASER_CACHE_MASK
expr_stmt|;
name|gits_baser
operator|&=
operator|~
name|GITS_BASER_CACHE_MASK
expr_stmt|;
if|if
condition|(
name|gits_tmp
operator|!=
name|gits_baser
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Could not allocate ITS tables\n"
argument_list|)
expr_stmt|;
name|its_free_tables
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|bootverbose
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Allocated ITS private tables:\n"
argument_list|)
expr_stmt|;
name|first
operator|=
name|FALSE
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"\tPTAB%zu for %s: PA 0x%lx,"
literal|" %lu entries,"
literal|" cache policy %s, %s shareable,"
literal|" page size %zuKB\n"
argument_list|,
name|tn
argument_list|,
name|its_ptab_type
index|[
name|type
index|]
argument_list|,
name|ptab_paddr
argument_list|,
operator|(
name|page_size
operator|*
name|nitspages
operator|)
operator|/
name|esize
argument_list|,
name|its_ptab_cache
index|[
name|cache
index|]
argument_list|,
name|its_ptab_share
index|[
name|share
index|]
argument_list|,
name|page_size
operator|/
literal|1024
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|its_free_tables
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|)
block|{
name|vm_offset_t
name|ptab_vaddr
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|size_t
name|tn
decl_stmt|;
for|for
control|(
name|tn
operator|=
literal|0
init|;
name|tn
operator|<
name|GITS_BASER_NUM
condition|;
name|tn
operator|++
control|)
block|{
name|ptab_vaddr
operator|=
name|sc
operator|->
name|its_ptabs
index|[
name|tn
index|]
operator|.
name|ptab_vaddr
expr_stmt|;
if|if
condition|(
name|ptab_vaddr
operator|==
literal|0
condition|)
continue|continue;
name|size
operator|=
name|sc
operator|->
name|its_ptabs
index|[
name|tn
index|]
operator|.
name|ptab_pgsz
expr_stmt|;
name|size
operator|*=
name|sc
operator|->
name|its_ptabs
index|[
name|tn
index|]
operator|.
name|ptab_npages
expr_stmt|;
if|if
condition|(
operator|(
name|void
operator|*
operator|)
name|ptab_vaddr
operator|!=
name|NULL
condition|)
name|contigfree
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ptab_vaddr
argument_list|,
name|size
argument_list|,
name|M_GIC_V3_ITS
argument_list|)
expr_stmt|;
comment|/* Clear the table description */
name|memset
argument_list|(
operator|&
name|sc
operator|->
name|its_ptabs
index|[
name|tn
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|its_ptabs
index|[
name|tn
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|its_init_commandq
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint64_t
name|gits_cbaser
decl_stmt|,
name|gits_tmp
decl_stmt|;
name|uint64_t
name|cache
decl_stmt|,
name|share
decl_stmt|;
name|vm_paddr_t
name|cmdq_paddr
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|dev
operator|=
name|sc
operator|->
name|dev
expr_stmt|;
comment|/* Allocate memory for command queue */
name|sc
operator|->
name|its_cmdq_base
operator|=
name|contigmalloc
argument_list|(
name|ITS_CMDQ_SIZE
argument_list|,
name|M_GIC_V3_ITS
argument_list|,
operator|(
name|M_WAITOK
operator||
name|M_ZERO
operator|)
argument_list|,
literal|0
argument_list|,
operator|~
literal|0UL
argument_list|,
name|ITS_CMDQ_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set command queue write pointer (command queue empty) */
name|sc
operator|->
name|its_cmdq_write
operator|=
name|sc
operator|->
name|its_cmdq_base
expr_stmt|;
comment|/* Save command queue pointer and attributes */
name|cmdq_paddr
operator|=
name|vtophys
argument_list|(
name|sc
operator|->
name|its_cmdq_base
argument_list|)
expr_stmt|;
comment|/* Set defaults: Normal Inner WAWB, IS */
name|cache
operator|=
name|GITS_CBASER_CACHE_NIWAWB
expr_stmt|;
name|share
operator|=
name|GITS_CBASER_SHARE_IS
expr_stmt|;
name|gits_cbaser
operator|=
operator|(
name|cmdq_paddr
operator||
operator|(
name|cache
operator|<<
name|GITS_CBASER_CACHE_SHIFT
operator|)
operator||
operator|(
name|share
operator|<<
name|GITS_CBASER_SHARE_SHIFT
operator|)
operator||
comment|/* Number of 4KB pages - 1 */
operator|(
operator|(
name|ITS_CMDQ_SIZE
operator|/
name|PAGE_SIZE
operator|)
operator|-
literal|1
operator|)
operator||
comment|/* Valid bit */
name|GITS_CBASER_VALID
operator|)
expr_stmt|;
name|gic_its_write
argument_list|(
name|sc
argument_list|,
literal|8
argument_list|,
name|GITS_CBASER
argument_list|,
name|gits_cbaser
argument_list|)
expr_stmt|;
name|gits_tmp
operator|=
name|gic_its_read
argument_list|(
name|sc
argument_list|,
literal|8
argument_list|,
name|GITS_CBASER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|gits_tmp
operator|^
name|gits_cbaser
operator|)
operator|&
name|GITS_CBASER_SHARE_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Will use cache flushing for commands queue\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Command queue needs cache flushing */
name|sc
operator|->
name|its_flags
operator||=
name|ITS_FLAGS_CMDQ_FLUSH
expr_stmt|;
block|}
name|gic_its_write
argument_list|(
name|sc
argument_list|,
literal|8
argument_list|,
name|GITS_CWRITER
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|its_init_cpu
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|parent
decl_stmt|;
name|struct
name|gic_v3_softc
modifier|*
name|gic_sc
decl_stmt|;
comment|/* 	 * NULL in place of the softc pointer means that 	 * this function was called during GICv3 secondary initialization. 	 */
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|device_is_attached
argument_list|(
name|its_sc
operator|->
name|dev
argument_list|)
condition|)
block|{
comment|/* 			 * XXX ARM64TODO: This is part of the workaround that 			 * saves ITS software context for further use in 			 * mask/unmask and here. This should be removed as soon 			 * as the upper layer is capable of passing the ITS 			 * context to this function. 			 */
name|sc
operator|=
name|its_sc
expr_stmt|;
block|}
else|else
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Skip if running secondary init on a wrong socket */
if|if
condition|(
name|sc
operator|->
name|its_socket
operator|!=
name|CPU_CURRENT_SOCKET
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* 	 * Check for LPIs support on this Re-Distributor. 	 */
name|parent
operator|=
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|gic_sc
operator|=
name|device_get_softc
argument_list|(
name|parent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|gic_r_read
argument_list|(
name|gic_sc
argument_list|,
literal|4
argument_list|,
name|GICR_TYPER
argument_list|)
operator|&
name|GICR_TYPER_PLPIS
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"LPIs not supported on CPU%u\n"
argument_list|,
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Configure LPIs for this CPU */
name|lpi_config_cpu
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Initialize collections */
name|its_init_cpu_collection
argument_list|(
name|sc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|its_init_cpu_collection
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|parent
decl_stmt|;
name|struct
name|gic_v3_softc
modifier|*
name|gic_sc
decl_stmt|;
name|uint64_t
name|typer
decl_stmt|;
name|uint64_t
name|target
decl_stmt|;
name|vm_offset_t
name|redist_base
decl_stmt|;
name|u_int
name|cpuid
decl_stmt|;
name|cpuid
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
name|parent
operator|=
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|gic_sc
operator|=
name|device_get_softc
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|typer
operator|=
name|gic_its_read
argument_list|(
name|sc
argument_list|,
literal|8
argument_list|,
name|GITS_TYPER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|typer
operator|&
name|GITS_TYPER_PTA
operator|)
operator|!=
literal|0
condition|)
block|{
name|redist_base
operator|=
name|rman_get_bushandle
argument_list|(
name|gic_sc
operator|->
name|gic_redists
operator|.
name|pcpu
index|[
name|cpuid
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * Target Address correspond to the base physical 		 * address of Re-Distributors. 		 */
name|target
operator|=
name|vtophys
argument_list|(
name|redist_base
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Target Address correspond to unique processor numbers */
name|typer
operator|=
name|gic_r_read
argument_list|(
name|gic_sc
argument_list|,
literal|8
argument_list|,
name|GICR_TYPER
argument_list|)
expr_stmt|;
name|target
operator|=
name|GICR_TYPER_CPUNUM
argument_list|(
name|typer
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|its_cols
index|[
name|cpuid
index|]
operator|->
name|col_target
operator|=
name|target
expr_stmt|;
name|sc
operator|->
name|its_cols
index|[
name|cpuid
index|]
operator|->
name|col_id
operator|=
name|cpuid
expr_stmt|;
name|its_cmd_mapc
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|its_cols
index|[
name|cpuid
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|its_cmd_invall
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|its_cols
index|[
name|cpuid
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lpi_init_conftable
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|parent
decl_stmt|;
name|struct
name|gic_v3_softc
modifier|*
name|gic_sc
decl_stmt|;
name|vm_offset_t
name|conf_base
decl_stmt|;
name|uint8_t
name|prio_default
decl_stmt|;
name|parent
operator|=
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|gic_sc
operator|=
name|device_get_softc
argument_list|(
name|parent
argument_list|)
expr_stmt|;
comment|/* 	 * LPI Configuration Table settings. 	 * Notice that Configuration Table is shared among all 	 * Re-Distributors, so this is going to be created just once. 	 */
name|conf_base
operator|=
operator|(
name|vm_offset_t
operator|)
name|contigmalloc
argument_list|(
name|LPI_CONFTAB_SIZE
argument_list|,
name|M_GIC_V3_ITS
argument_list|,
operator|(
name|M_WAITOK
operator||
name|M_ZERO
operator|)
argument_list|,
literal|0
argument_list|,
operator|~
literal|0UL
argument_list|,
name|PAGE_SIZE_64K
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"LPI Configuration Table at PA: 0x%lx\n"
argument_list|,
name|vtophys
argument_list|(
name|conf_base
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Let the default priority be aligned with all other 	 * interrupts assuming that each interrupt is assigned 	 * MAX priority at startup. MAX priority on the other 	 * hand cannot be higher than 0xFC for LPIs. 	 */
name|prio_default
operator|=
name|GIC_PRIORITY_MAX
expr_stmt|;
comment|/* Write each settings byte to LPI configuration table */
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
name|conf_base
argument_list|,
operator|(
name|prio_default
operator|&
name|LPI_CONF_PRIO_MASK
operator|)
operator||
name|LPI_CONF_GROUP1
argument_list|,
name|LPI_CONFTAB_SIZE
argument_list|)
expr_stmt|;
name|cpu_dcache_wb_range
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|conf_base
argument_list|,
name|roundup2
argument_list|(
name|LPI_CONFTAB_SIZE
argument_list|,
name|PAGE_SIZE_64K
argument_list|)
argument_list|)
expr_stmt|;
name|gic_sc
operator|->
name|gic_redists
operator|.
name|lpis
operator|.
name|conf_base
operator|=
name|conf_base
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lpi_alloc_cpu_pendtables
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|parent
decl_stmt|;
name|struct
name|gic_v3_softc
modifier|*
name|gic_sc
decl_stmt|;
name|vm_offset_t
name|pend_base
decl_stmt|;
name|u_int
name|cpuid
decl_stmt|;
name|parent
operator|=
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|gic_sc
operator|=
name|device_get_softc
argument_list|(
name|parent
argument_list|)
expr_stmt|;
comment|/* 	 * LPI Pending Table settings. 	 * This has to be done for each Re-Distributor, hence for each CPU. 	 */
for|for
control|(
name|cpuid
operator|=
literal|0
init|;
name|cpuid
operator|<
name|mp_ncpus
condition|;
name|cpuid
operator|++
control|)
block|{
comment|/* Limit allocation to active CPUs only */
if|if
condition|(
name|CPU_ISSET
argument_list|(
name|cpuid
argument_list|,
operator|&
name|all_cpus
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|pend_base
operator|=
operator|(
name|vm_offset_t
operator|)
name|contigmalloc
argument_list|(
name|roundup2
argument_list|(
name|LPI_PENDTAB_SIZE
argument_list|,
name|PAGE_SIZE_64K
argument_list|)
argument_list|,
name|M_GIC_V3_ITS
argument_list|,
operator|(
name|M_WAITOK
operator||
name|M_ZERO
operator|)
argument_list|,
literal|0
argument_list|,
operator|~
literal|0UL
argument_list|,
name|PAGE_SIZE_64K
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Clean D-cache so that ITS can see zeroed pages */
name|cpu_dcache_wb_range
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pend_base
argument_list|,
name|roundup2
argument_list|(
name|LPI_PENDTAB_SIZE
argument_list|,
name|PAGE_SIZE_64K
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"LPI Pending Table for CPU%u at PA: 0x%lx\n"
argument_list|,
name|cpuid
argument_list|,
name|vtophys
argument_list|(
name|pend_base
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|gic_sc
operator|->
name|gic_redists
operator|.
name|lpis
operator|.
name|pend_base
index|[
name|cpuid
index|]
operator|=
name|pend_base
expr_stmt|;
block|}
comment|/* Ensure visibility of pend_base addresses on other CPUs */
name|wmb
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lpi_config_cpu
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|parent
decl_stmt|;
name|struct
name|gic_v3_softc
modifier|*
name|gic_sc
decl_stmt|;
name|vm_offset_t
name|conf_base
decl_stmt|,
name|pend_base
decl_stmt|;
name|uint64_t
name|gicr_xbaser
decl_stmt|,
name|gicr_temp
decl_stmt|;
name|uint64_t
name|cache
decl_stmt|,
name|share
decl_stmt|,
name|idbits
decl_stmt|;
name|uint32_t
name|gicr_ctlr
decl_stmt|;
name|u_int
name|cpuid
decl_stmt|;
name|parent
operator|=
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|gic_sc
operator|=
name|device_get_softc
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|cpuid
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
comment|/* Ensure data observability on a current CPU */
name|rmb
argument_list|()
expr_stmt|;
name|conf_base
operator|=
name|gic_sc
operator|->
name|gic_redists
operator|.
name|lpis
operator|.
name|conf_base
expr_stmt|;
name|pend_base
operator|=
name|gic_sc
operator|->
name|gic_redists
operator|.
name|lpis
operator|.
name|pend_base
index|[
name|cpuid
index|]
expr_stmt|;
comment|/* Disable LPIs */
name|gicr_ctlr
operator|=
name|gic_r_read
argument_list|(
name|gic_sc
argument_list|,
literal|4
argument_list|,
name|GICR_CTLR
argument_list|)
expr_stmt|;
name|gicr_ctlr
operator|&=
operator|~
name|GICR_CTLR_LPI_ENABLE
expr_stmt|;
name|gic_r_write
argument_list|(
name|gic_sc
argument_list|,
literal|4
argument_list|,
name|GICR_CTLR
argument_list|,
name|gicr_ctlr
argument_list|)
expr_stmt|;
comment|/* Perform full system barrier */
name|dsb
argument_list|(
name|sy
argument_list|)
expr_stmt|;
comment|/* 	 * Set GICR_PROPBASER 	 */
comment|/* 	 * Find out how many bits do we need for LPI identifiers. 	 * Remark 1.: Even though we have (LPI_CONFTAB_SIZE / 8) LPIs 	 *	      the notified LPI ID still starts from 8192 	 *	      (GIC_FIRST_LPI). 	 * Remark 2.: This could be done on compilation time but there 	 *	      seems to be no sufficient macro. 	 */
name|idbits
operator|=
name|flsl
argument_list|(
name|LPI_CONFTAB_SIZE
operator|+
name|GIC_FIRST_LPI
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Set defaults: Normal Inner WAWB, IS */
name|cache
operator|=
name|GICR_PROPBASER_CACHE_NIWAWB
expr_stmt|;
name|share
operator|=
name|GICR_PROPBASER_SHARE_IS
expr_stmt|;
name|gicr_xbaser
operator|=
name|vtophys
argument_list|(
name|conf_base
argument_list|)
operator||
operator|(
operator|(
name|idbits
operator|-
literal|1
operator|)
operator|&
name|GICR_PROPBASER_IDBITS_MASK
operator|)
operator||
operator|(
name|cache
operator|<<
name|GICR_PROPBASER_CACHE_SHIFT
operator|)
operator||
operator|(
name|share
operator|<<
name|GICR_PROPBASER_SHARE_SHIFT
operator|)
expr_stmt|;
name|gic_r_write
argument_list|(
name|gic_sc
argument_list|,
literal|8
argument_list|,
name|GICR_PROPBASER
argument_list|,
name|gicr_xbaser
argument_list|)
expr_stmt|;
name|gicr_temp
operator|=
name|gic_r_read
argument_list|(
name|gic_sc
argument_list|,
literal|8
argument_list|,
name|GICR_PROPBASER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|gicr_xbaser
operator|^
name|gicr_temp
operator|)
operator|&
name|GICR_PROPBASER_SHARE_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Will use cache flushing for LPI "
literal|"Configuration Table\n"
argument_list|)
expr_stmt|;
block|}
name|gic_sc
operator|->
name|gic_redists
operator|.
name|lpis
operator|.
name|flags
operator||=
name|LPI_FLAGS_CONF_FLUSH
expr_stmt|;
block|}
comment|/* 	 * Set GICR_PENDBASER 	 */
comment|/* Set defaults: Normal Inner WAWB, IS */
name|cache
operator|=
name|GICR_PENDBASER_CACHE_NIWAWB
expr_stmt|;
name|share
operator|=
name|GICR_PENDBASER_SHARE_IS
expr_stmt|;
name|gicr_xbaser
operator|=
name|vtophys
argument_list|(
name|pend_base
argument_list|)
operator||
operator|(
name|cache
operator|<<
name|GICR_PENDBASER_CACHE_SHIFT
operator|)
operator||
operator|(
name|share
operator|<<
name|GICR_PENDBASER_SHARE_SHIFT
operator|)
expr_stmt|;
name|gic_r_write
argument_list|(
name|gic_sc
argument_list|,
literal|8
argument_list|,
name|GICR_PENDBASER
argument_list|,
name|gicr_xbaser
argument_list|)
expr_stmt|;
comment|/* Enable LPIs */
name|gicr_ctlr
operator|=
name|gic_r_read
argument_list|(
name|gic_sc
argument_list|,
literal|4
argument_list|,
name|GICR_CTLR
argument_list|)
expr_stmt|;
name|gicr_ctlr
operator||=
name|GICR_CTLR_LPI_ENABLE
expr_stmt|;
name|gic_r_write
argument_list|(
name|gic_sc
argument_list|,
literal|4
argument_list|,
name|GICR_CTLR
argument_list|,
name|gicr_ctlr
argument_list|)
expr_stmt|;
name|dsb
argument_list|(
name|sy
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lpi_bitmap_init
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|)
block|{
name|device_t
name|parent
decl_stmt|;
name|struct
name|gic_v3_softc
modifier|*
name|gic_sc
decl_stmt|;
name|uint32_t
name|lpi_id_num
decl_stmt|;
name|size_t
name|lpi_chunks_num
decl_stmt|;
name|size_t
name|bits_in_chunk
decl_stmt|;
name|parent
operator|=
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|gic_sc
operator|=
name|device_get_softc
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|lpi_id_num
operator|=
operator|(
literal|1
operator|<<
name|gic_sc
operator|->
name|gic_idbits
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* Substract IDs dedicated for SGIs, PPIs and SPIs */
name|lpi_id_num
operator|-=
name|GIC_FIRST_LPI
expr_stmt|;
name|sc
operator|->
name|its_lpi_maxid
operator|=
name|lpi_id_num
expr_stmt|;
name|bits_in_chunk
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|its_lpi_bitmap
argument_list|)
operator|*
name|NBBY
expr_stmt|;
comment|/* 	 * Round up to the number of bits in chunk. 	 * We will need to take care to avoid using invalid LPI IDs later. 	 */
name|lpi_id_num
operator|=
name|roundup2
argument_list|(
name|lpi_id_num
argument_list|,
name|bits_in_chunk
argument_list|)
expr_stmt|;
name|lpi_chunks_num
operator|=
name|lpi_id_num
operator|/
name|bits_in_chunk
expr_stmt|;
name|sc
operator|->
name|its_lpi_bitmap
operator|=
name|contigmalloc
argument_list|(
operator|(
name|lpi_chunks_num
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|its_lpi_bitmap
argument_list|)
operator|)
argument_list|,
name|M_GIC_V3_ITS
argument_list|,
operator|(
name|M_WAITOK
operator||
name|M_ZERO
operator|)
argument_list|,
literal|0
argument_list|,
operator|~
literal|0UL
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|its_lpi_bitmap
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lpi_alloc_chunk
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lpi_chunk
modifier|*
name|lpic
parameter_list|,
name|u_int
name|nvecs
parameter_list|)
block|{
name|u_int
modifier|*
name|col_ids
decl_stmt|;
name|int
name|fclr
decl_stmt|;
comment|/* First cleared bit */
name|uint8_t
modifier|*
name|bitmap
decl_stmt|;
name|size_t
name|nb
decl_stmt|,
name|i
decl_stmt|;
name|col_ids
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|col_ids
argument_list|)
operator|*
name|nvecs
argument_list|,
name|M_GIC_V3_ITS
argument_list|,
operator|(
name|M_NOWAIT
operator||
name|M_ZERO
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|col_ids
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|its_dev_lock
argument_list|)
expr_stmt|;
name|bitmap
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|sc
operator|->
name|its_lpi_bitmap
expr_stmt|;
name|fclr
operator|=
literal|0
expr_stmt|;
name|retry
label|:
comment|/* Check other bits - sloooow */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|nb
operator|=
name|fclr
init|;
name|i
operator|<
name|nvecs
condition|;
name|i
operator|++
operator|,
name|nb
operator|++
control|)
block|{
if|if
condition|(
name|nb
operator|>
name|sc
operator|->
name|its_lpi_maxid
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|its_dev_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|col_ids
argument_list|,
name|M_GIC_V3_ITS
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|isset
argument_list|(
name|bitmap
argument_list|,
name|nb
argument_list|)
condition|)
block|{
comment|/* To little free bits in this area. Move on. */
name|fclr
operator|=
name|nb
operator|+
literal|1
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
comment|/* This area is free. Take it. */
name|bit_nset
argument_list|(
name|bitmap
argument_list|,
name|fclr
argument_list|,
name|fclr
operator|+
name|nvecs
operator|-
literal|1
argument_list|)
expr_stmt|;
name|lpic
operator|->
name|lpi_base
operator|=
name|fclr
operator|+
name|GIC_FIRST_LPI
expr_stmt|;
name|lpic
operator|->
name|lpi_num
operator|=
name|nvecs
expr_stmt|;
name|lpic
operator|->
name|lpi_free
operator|=
name|lpic
operator|->
name|lpi_num
expr_stmt|;
name|lpic
operator|->
name|lpi_col_ids
operator|=
name|col_ids
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lpic
operator|->
name|lpi_num
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Initially all interrupts go to CPU0 but can be moved 		 * to another CPU by bus_bind_intr() or interrupts shuffling. 		 */
name|lpic
operator|->
name|lpi_col_ids
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|its_dev_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lpi_free_chunk
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|lpi_chunk
modifier|*
name|lpic
parameter_list|)
block|{
name|int
name|start
decl_stmt|,
name|end
decl_stmt|;
name|uint8_t
modifier|*
name|bitmap
decl_stmt|;
name|bitmap
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|sc
operator|->
name|its_lpi_bitmap
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|lpic
operator|->
name|lpi_free
operator|==
name|lpic
operator|->
name|lpi_num
operator|)
argument_list|,
operator|(
literal|"Trying to free LPI chunk that is still in use.\n"
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|its_dev_lock
argument_list|)
expr_stmt|;
comment|/* First bit of this chunk in a global bitmap */
name|start
operator|=
name|lpic
operator|->
name|lpi_base
operator|-
name|GIC_FIRST_LPI
expr_stmt|;
comment|/* and last bit of this chunk... */
name|end
operator|=
name|start
operator|+
name|lpic
operator|->
name|lpi_num
operator|-
literal|1
expr_stmt|;
comment|/* Finally free this chunk */
name|bit_nclear
argument_list|(
name|bitmap
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|its_dev_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lpic
operator|->
name|lpi_col_ids
argument_list|,
name|M_GIC_V3_ITS
argument_list|)
expr_stmt|;
name|lpic
operator|->
name|lpi_col_ids
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lpi_configure
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|its_dev
modifier|*
name|its_dev
parameter_list|,
name|uint32_t
name|lpinum
parameter_list|,
name|boolean_t
name|unmask
parameter_list|)
block|{
name|device_t
name|parent
decl_stmt|;
name|struct
name|gic_v3_softc
modifier|*
name|gic_sc
decl_stmt|;
name|uint8_t
modifier|*
name|conf_byte
decl_stmt|;
name|parent
operator|=
name|device_get_parent
argument_list|(
name|sc
operator|->
name|dev
argument_list|)
expr_stmt|;
name|gic_sc
operator|=
name|device_get_softc
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|conf_byte
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|gic_sc
operator|->
name|gic_redists
operator|.
name|lpis
operator|.
name|conf_base
expr_stmt|;
name|conf_byte
operator|+=
operator|(
name|lpinum
operator|-
name|GIC_FIRST_LPI
operator|)
expr_stmt|;
if|if
condition|(
name|unmask
condition|)
operator|*
name|conf_byte
operator||=
name|LPI_CONF_ENABLE
expr_stmt|;
else|else
operator|*
name|conf_byte
operator|&=
operator|~
name|LPI_CONF_ENABLE
expr_stmt|;
if|if
condition|(
operator|(
name|gic_sc
operator|->
name|gic_redists
operator|.
name|lpis
operator|.
name|flags
operator|&
name|LPI_FLAGS_CONF_FLUSH
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Clean D-cache under configuration byte */
name|cpu_dcache_wb_range
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|conf_byte
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|conf_byte
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* DSB inner shareable, store */
name|dsb
argument_list|(
name|ishst
argument_list|)
expr_stmt|;
block|}
name|its_cmd_inv
argument_list|(
name|sc
argument_list|,
name|its_dev
argument_list|,
name|lpinum
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lpi_map_to_device
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|its_dev
modifier|*
name|its_dev
parameter_list|,
name|uint32_t
name|id
parameter_list|,
name|uint32_t
name|pid
parameter_list|)
block|{
if|if
condition|(
operator|(
name|pid
operator|<
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_base
operator|)
operator|||
operator|(
name|pid
operator|>=
operator|(
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_base
operator|+
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_num
operator|)
operator|)
condition|)
name|panic
argument_list|(
literal|"Trying to map ivalid LPI %u for the device\n"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|its_cmd_mapvi
argument_list|(
name|sc
argument_list|,
name|its_dev
argument_list|,
name|id
argument_list|,
name|pid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lpi_xmask_irq
parameter_list|(
name|device_t
name|parent
parameter_list|,
name|uint32_t
name|irq
parameter_list|,
name|boolean_t
name|unmask
parameter_list|)
block|{
name|struct
name|its_dev
modifier|*
name|its_dev
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|its_dev
argument_list|,
argument|&its_sc->its_dev_list
argument_list|,
argument|entry
argument_list|)
block|{
if|if
condition|(
name|irq
operator|>=
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_base
operator|&&
name|irq
operator|<
operator|(
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_base
operator|+
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_num
operator|)
condition|)
block|{
name|lpi_configure
argument_list|(
name|its_sc
argument_list|,
name|its_dev
argument_list|,
name|irq
argument_list|,
name|unmask
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|panic
argument_list|(
literal|"Trying to %s not existing LPI: %u\n"
argument_list|,
operator|(
name|unmask
operator|==
name|TRUE
operator|)
condition|?
literal|"unmask"
else|:
literal|"mask"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|lpi_migrate
parameter_list|(
name|device_t
name|parent
parameter_list|,
name|uint32_t
name|irq
parameter_list|,
name|u_int
name|cpuid
parameter_list|)
block|{
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|its_dev
modifier|*
name|its_dev
decl_stmt|;
name|struct
name|its_col
modifier|*
name|col
decl_stmt|;
name|sc
operator|=
name|its_sc
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|its_dev_lock
argument_list|)
expr_stmt|;
name|its_dev
operator|=
name|its_device_find_locked
argument_list|(
name|sc
argument_list|,
name|NULL
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|its_dev_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|its_dev
operator|==
name|NULL
condition|)
block|{
comment|/* Cannot migrate not configured LPI */
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* Find local device's interrupt identifier */
name|irq
operator|=
name|irq
operator|-
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_base
expr_stmt|;
comment|/* Move interrupt to another collection */
name|col
operator|=
name|sc
operator|->
name|its_cols
index|[
name|cpuid
index|]
expr_stmt|;
name|its_cmd_movi
argument_list|(
name|sc
argument_list|,
name|its_dev
argument_list|,
name|col
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_col_ids
index|[
name|irq
index|]
operator|=
name|cpuid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|lpi_unmask_irq
parameter_list|(
name|device_t
name|parent
parameter_list|,
name|uint32_t
name|irq
parameter_list|)
block|{
name|lpi_xmask_irq
argument_list|(
name|parent
argument_list|,
name|irq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|lpi_mask_irq
parameter_list|(
name|device_t
name|parent
parameter_list|,
name|uint32_t
name|irq
parameter_list|)
block|{
name|lpi_xmask_irq
argument_list|(
name|parent
argument_list|,
name|irq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Commands handling.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|cmd_format_command
parameter_list|(
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|,
name|uint8_t
name|cmd_type
parameter_list|)
block|{
comment|/* Command field: DW0 [7:0] */
name|cmd
operator|->
name|cmd_dword
index|[
literal|0
index|]
operator|&=
operator|~
name|CMD_COMMAND_MASK
expr_stmt|;
name|cmd
operator|->
name|cmd_dword
index|[
literal|0
index|]
operator||=
name|cmd_type
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|cmd_format_devid
parameter_list|(
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|,
name|uint32_t
name|devid
parameter_list|)
block|{
comment|/* Device ID field: DW0 [63:32] */
name|cmd
operator|->
name|cmd_dword
index|[
literal|0
index|]
operator|&=
operator|~
name|CMD_DEVID_MASK
expr_stmt|;
name|cmd
operator|->
name|cmd_dword
index|[
literal|0
index|]
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|devid
operator|<<
name|CMD_DEVID_SHIFT
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|cmd_format_size
parameter_list|(
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|,
name|uint16_t
name|size
parameter_list|)
block|{
comment|/* Size field: DW1 [4:0] */
name|cmd
operator|->
name|cmd_dword
index|[
literal|1
index|]
operator|&=
operator|~
name|CMD_SIZE_MASK
expr_stmt|;
name|cmd
operator|->
name|cmd_dword
index|[
literal|1
index|]
operator||=
operator|(
name|size
operator|&
name|CMD_SIZE_MASK
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|cmd_format_id
parameter_list|(
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|,
name|uint32_t
name|id
parameter_list|)
block|{
comment|/* ID field: DW1 [31:0] */
name|cmd
operator|->
name|cmd_dword
index|[
literal|1
index|]
operator|&=
operator|~
name|CMD_ID_MASK
expr_stmt|;
name|cmd
operator|->
name|cmd_dword
index|[
literal|1
index|]
operator||=
name|id
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|cmd_format_pid
parameter_list|(
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|,
name|uint32_t
name|pid
parameter_list|)
block|{
comment|/* Physical ID field: DW1 [63:32] */
name|cmd
operator|->
name|cmd_dword
index|[
literal|1
index|]
operator|&=
operator|~
name|CMD_PID_MASK
expr_stmt|;
name|cmd
operator|->
name|cmd_dword
index|[
literal|1
index|]
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|pid
operator|<<
name|CMD_PID_SHIFT
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|cmd_format_col
parameter_list|(
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|,
name|uint16_t
name|col_id
parameter_list|)
block|{
comment|/* Collection field: DW2 [16:0] */
name|cmd
operator|->
name|cmd_dword
index|[
literal|2
index|]
operator|&=
operator|~
name|CMD_COL_MASK
expr_stmt|;
name|cmd
operator|->
name|cmd_dword
index|[
literal|2
index|]
operator||=
name|col_id
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|cmd_format_target
parameter_list|(
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|,
name|uint64_t
name|target
parameter_list|)
block|{
comment|/* Target Address field: DW2 [47:16] */
name|cmd
operator|->
name|cmd_dword
index|[
literal|2
index|]
operator|&=
operator|~
name|CMD_TARGET_MASK
expr_stmt|;
name|cmd
operator|->
name|cmd_dword
index|[
literal|2
index|]
operator||=
operator|(
name|target
operator|&
name|CMD_TARGET_MASK
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|cmd_format_itt
parameter_list|(
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|,
name|uint64_t
name|itt
parameter_list|)
block|{
comment|/* ITT Address field: DW2 [47:8] */
name|cmd
operator|->
name|cmd_dword
index|[
literal|2
index|]
operator|&=
operator|~
name|CMD_ITT_MASK
expr_stmt|;
name|cmd
operator|->
name|cmd_dword
index|[
literal|2
index|]
operator||=
operator|(
name|itt
operator|&
name|CMD_ITT_MASK
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|cmd_format_valid
parameter_list|(
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|,
name|uint8_t
name|valid
parameter_list|)
block|{
comment|/* Valid field: DW2 [63] */
name|cmd
operator|->
name|cmd_dword
index|[
literal|2
index|]
operator|&=
operator|~
name|CMD_VALID_MASK
expr_stmt|;
name|cmd
operator|->
name|cmd_dword
index|[
literal|2
index|]
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|valid
operator|<<
name|CMD_VALID_SHIFT
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|cmd_fix_endian
parameter_list|(
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|cmd
operator|->
name|cmd_dword
argument_list|)
condition|;
name|i
operator|++
control|)
name|cmd
operator|->
name|cmd_dword
index|[
name|i
index|]
operator|=
name|htole64
argument_list|(
name|cmd
operator|->
name|cmd_dword
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|its_cmd_movi
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|its_dev
modifier|*
name|its_dev
parameter_list|,
name|struct
name|its_col
modifier|*
name|col
parameter_list|,
name|uint32_t
name|id
parameter_list|)
block|{
name|struct
name|its_cmd_desc
name|desc
decl_stmt|;
name|desc
operator|.
name|cmd_type
operator|=
name|ITS_CMD_MOVI
expr_stmt|;
name|desc
operator|.
name|cmd_desc_movi
operator|.
name|its_dev
operator|=
name|its_dev
expr_stmt|;
name|desc
operator|.
name|cmd_desc_movi
operator|.
name|col
operator|=
name|col
expr_stmt|;
name|desc
operator|.
name|cmd_desc_movi
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|its_cmd_send
argument_list|(
name|sc
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|its_cmd_mapc
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|its_col
modifier|*
name|col
parameter_list|,
name|uint8_t
name|valid
parameter_list|)
block|{
name|struct
name|its_cmd_desc
name|desc
decl_stmt|;
name|desc
operator|.
name|cmd_type
operator|=
name|ITS_CMD_MAPC
expr_stmt|;
name|desc
operator|.
name|cmd_desc_mapc
operator|.
name|col
operator|=
name|col
expr_stmt|;
comment|/* 	 * Valid bit set - map the collection. 	 * Valid bit cleared - unmap the collection. 	 */
name|desc
operator|.
name|cmd_desc_mapc
operator|.
name|valid
operator|=
name|valid
expr_stmt|;
name|its_cmd_send
argument_list|(
name|sc
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|its_cmd_mapvi
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|its_dev
modifier|*
name|its_dev
parameter_list|,
name|uint32_t
name|id
parameter_list|,
name|uint32_t
name|pid
parameter_list|)
block|{
name|struct
name|its_cmd_desc
name|desc
decl_stmt|;
name|struct
name|its_col
modifier|*
name|col
decl_stmt|;
name|u_int
name|col_id
decl_stmt|;
name|col_id
operator|=
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_col_ids
index|[
name|id
index|]
expr_stmt|;
name|col
operator|=
name|sc
operator|->
name|its_cols
index|[
name|col_id
index|]
expr_stmt|;
name|desc
operator|.
name|cmd_type
operator|=
name|ITS_CMD_MAPVI
expr_stmt|;
name|desc
operator|.
name|cmd_desc_mapvi
operator|.
name|its_dev
operator|=
name|its_dev
expr_stmt|;
name|desc
operator|.
name|cmd_desc_mapvi
operator|.
name|col
operator|=
name|col
expr_stmt|;
name|desc
operator|.
name|cmd_desc_mapvi
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|desc
operator|.
name|cmd_desc_mapvi
operator|.
name|pid
operator|=
name|pid
expr_stmt|;
name|its_cmd_send
argument_list|(
name|sc
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__unused
name|its_cmd_mapi
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|its_dev
modifier|*
name|its_dev
parameter_list|,
name|uint32_t
name|pid
parameter_list|)
block|{
name|struct
name|its_cmd_desc
name|desc
decl_stmt|;
name|struct
name|its_col
modifier|*
name|col
decl_stmt|;
name|u_int
name|col_id
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
name|KASSERT
argument_list|(
name|pid
operator|>=
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_base
argument_list|,
operator|(
literal|"%s: invalid pid: %d for the ITS device"
operator|,
name|__func__
operator|,
name|pid
operator|)
argument_list|)
expr_stmt|;
name|id
operator|=
name|pid
operator|-
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_base
expr_stmt|;
name|col_id
operator|=
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_col_ids
index|[
name|id
index|]
expr_stmt|;
name|col
operator|=
name|sc
operator|->
name|its_cols
index|[
name|col_id
index|]
expr_stmt|;
name|desc
operator|.
name|cmd_type
operator|=
name|ITS_CMD_MAPI
expr_stmt|;
name|desc
operator|.
name|cmd_desc_mapi
operator|.
name|its_dev
operator|=
name|its_dev
expr_stmt|;
name|desc
operator|.
name|cmd_desc_mapi
operator|.
name|col
operator|=
name|col
expr_stmt|;
name|desc
operator|.
name|cmd_desc_mapi
operator|.
name|pid
operator|=
name|pid
expr_stmt|;
name|its_cmd_send
argument_list|(
name|sc
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|its_cmd_mapd
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|its_dev
modifier|*
name|its_dev
parameter_list|,
name|uint8_t
name|valid
parameter_list|)
block|{
name|struct
name|its_cmd_desc
name|desc
decl_stmt|;
name|desc
operator|.
name|cmd_type
operator|=
name|ITS_CMD_MAPD
expr_stmt|;
name|desc
operator|.
name|cmd_desc_mapd
operator|.
name|its_dev
operator|=
name|its_dev
expr_stmt|;
name|desc
operator|.
name|cmd_desc_mapd
operator|.
name|valid
operator|=
name|valid
expr_stmt|;
name|its_cmd_send
argument_list|(
name|sc
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|its_cmd_inv
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|its_dev
modifier|*
name|its_dev
parameter_list|,
name|uint32_t
name|pid
parameter_list|)
block|{
name|struct
name|its_cmd_desc
name|desc
decl_stmt|;
name|struct
name|its_col
modifier|*
name|col
decl_stmt|;
name|u_int
name|col_id
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
name|KASSERT
argument_list|(
name|pid
operator|>=
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_base
argument_list|,
operator|(
literal|"%s: invalid pid: %d for the ITS device"
operator|,
name|__func__
operator|,
name|pid
operator|)
argument_list|)
expr_stmt|;
name|id
operator|=
name|pid
operator|-
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_base
expr_stmt|;
name|col_id
operator|=
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_col_ids
index|[
name|id
index|]
expr_stmt|;
name|col
operator|=
name|sc
operator|->
name|its_cols
index|[
name|col_id
index|]
expr_stmt|;
name|desc
operator|.
name|cmd_type
operator|=
name|ITS_CMD_INV
expr_stmt|;
name|desc
operator|.
name|cmd_desc_inv
operator|.
name|pid
operator|=
name|pid
operator|-
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_base
expr_stmt|;
name|desc
operator|.
name|cmd_desc_inv
operator|.
name|its_dev
operator|=
name|its_dev
expr_stmt|;
name|desc
operator|.
name|cmd_desc_inv
operator|.
name|col
operator|=
name|col
expr_stmt|;
name|its_cmd_send
argument_list|(
name|sc
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|its_cmd_invall
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|its_col
modifier|*
name|col
parameter_list|)
block|{
name|struct
name|its_cmd_desc
name|desc
decl_stmt|;
name|desc
operator|.
name|cmd_type
operator|=
name|ITS_CMD_INVALL
expr_stmt|;
name|desc
operator|.
name|cmd_desc_invall
operator|.
name|col
operator|=
name|col
expr_stmt|;
name|its_cmd_send
argument_list|(
name|sc
argument_list|,
operator|&
name|desc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Helper routines for commands processing.  */
end_comment

begin_function
specifier|static
name|__inline
name|boolean_t
name|its_cmd_queue_full
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|)
block|{
name|size_t
name|read_idx
decl_stmt|,
name|write_idx
decl_stmt|;
name|write_idx
operator|=
call|(
name|size_t
call|)
argument_list|(
name|sc
operator|->
name|its_cmdq_write
operator|-
name|sc
operator|->
name|its_cmdq_base
argument_list|)
expr_stmt|;
name|read_idx
operator|=
name|gic_its_read
argument_list|(
name|sc
argument_list|,
literal|4
argument_list|,
name|GITS_CREADR
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|its_cmd
argument_list|)
expr_stmt|;
comment|/* 	 * The queue is full when the write offset points 	 * at the command before the current read offset. 	 */
if|if
condition|(
operator|(
operator|(
name|write_idx
operator|+
literal|1
operator|)
operator|%
name|ITS_CMDQ_NENTRIES
operator|)
operator|==
name|read_idx
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|its_cmd_sync
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|)
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|its_flags
operator|&
name|ITS_FLAGS_CMDQ_FLUSH
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Clean D-cache under command. */
name|cpu_dcache_wb_range
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* DSB inner shareable, store */
name|dsb
argument_list|(
name|ishst
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|its_cmd
modifier|*
name|its_cmd_alloc_locked
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|its_cmd
modifier|*
name|cmd
decl_stmt|;
name|size_t
name|us_left
decl_stmt|;
comment|/* 	 * XXX ARM64TODO: This is obviously a significant delay. 	 * The reason for that is that currently the time frames for 	 * the command to complete (and therefore free the descriptor) 	 * are not known. 	 */
name|us_left
operator|=
literal|1000000
expr_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|its_cmd_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
while|while
condition|(
name|its_cmd_queue_full
argument_list|(
name|sc
argument_list|)
condition|)
block|{
if|if
condition|(
name|us_left
operator|--
operator|==
literal|0
condition|)
block|{
comment|/* Timeout while waiting for free command */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Timeout while waiting for free command\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cmd
operator|=
name|sc
operator|->
name|its_cmdq_write
expr_stmt|;
name|sc
operator|->
name|its_cmdq_write
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|its_cmdq_write
operator|==
operator|(
name|sc
operator|->
name|its_cmdq_base
operator|+
name|ITS_CMDQ_NENTRIES
operator|)
condition|)
block|{
comment|/* Wrap the queue */
name|sc
operator|->
name|its_cmdq_write
operator|=
name|sc
operator|->
name|its_cmdq_base
expr_stmt|;
block|}
return|return
operator|(
name|cmd
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|its_cmd_prepare
parameter_list|(
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|,
name|struct
name|its_cmd_desc
modifier|*
name|desc
parameter_list|)
block|{
name|uint64_t
name|target
decl_stmt|;
name|uint8_t
name|cmd_type
decl_stmt|;
name|u_int
name|size
decl_stmt|;
name|boolean_t
name|error
decl_stmt|;
name|error
operator|=
name|FALSE
expr_stmt|;
name|cmd_type
operator|=
name|desc
operator|->
name|cmd_type
expr_stmt|;
name|target
operator|=
name|ITS_TARGET_NONE
expr_stmt|;
switch|switch
condition|(
name|cmd_type
condition|)
block|{
case|case
name|ITS_CMD_MOVI
case|:
comment|/* Move interrupt ID to another collection */
name|target
operator|=
name|desc
operator|->
name|cmd_desc_movi
operator|.
name|col
operator|->
name|col_target
expr_stmt|;
name|cmd_format_command
argument_list|(
name|cmd
argument_list|,
name|ITS_CMD_MOVI
argument_list|)
expr_stmt|;
name|cmd_format_id
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_movi
operator|.
name|id
argument_list|)
expr_stmt|;
name|cmd_format_col
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_movi
operator|.
name|col
operator|->
name|col_id
argument_list|)
expr_stmt|;
name|cmd_format_devid
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_movi
operator|.
name|its_dev
operator|->
name|devid
argument_list|)
expr_stmt|;
break|break;
case|case
name|ITS_CMD_SYNC
case|:
comment|/* Wait for previous commands completion */
name|target
operator|=
name|desc
operator|->
name|cmd_desc_sync
operator|.
name|col
operator|->
name|col_target
expr_stmt|;
name|cmd_format_command
argument_list|(
name|cmd
argument_list|,
name|ITS_CMD_SYNC
argument_list|)
expr_stmt|;
name|cmd_format_target
argument_list|(
name|cmd
argument_list|,
name|target
argument_list|)
expr_stmt|;
break|break;
case|case
name|ITS_CMD_MAPD
case|:
comment|/* Assign ITT to device */
name|cmd_format_command
argument_list|(
name|cmd
argument_list|,
name|ITS_CMD_MAPD
argument_list|)
expr_stmt|;
name|cmd_format_itt
argument_list|(
name|cmd
argument_list|,
name|vtophys
argument_list|(
name|desc
operator|->
name|cmd_desc_mapd
operator|.
name|its_dev
operator|->
name|itt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Size describes number of bits to encode interrupt IDs 		 * supported by the device minus one. 		 * When V (valid) bit is zero, this field should be written 		 * as zero. 		 */
if|if
condition|(
name|desc
operator|->
name|cmd_desc_mapd
operator|.
name|valid
operator|!=
literal|0
condition|)
block|{
name|size
operator|=
name|fls
argument_list|(
name|desc
operator|->
name|cmd_desc_mapd
operator|.
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_num
argument_list|)
expr_stmt|;
name|size
operator|=
name|MAX
argument_list|(
literal|1
argument_list|,
name|size
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|size
operator|=
literal|0
expr_stmt|;
name|cmd_format_size
argument_list|(
name|cmd
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|cmd_format_devid
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_mapd
operator|.
name|its_dev
operator|->
name|devid
argument_list|)
expr_stmt|;
name|cmd_format_valid
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_mapd
operator|.
name|valid
argument_list|)
expr_stmt|;
break|break;
case|case
name|ITS_CMD_MAPC
case|:
comment|/* Map collection to Re-Distributor */
name|target
operator|=
name|desc
operator|->
name|cmd_desc_mapc
operator|.
name|col
operator|->
name|col_target
expr_stmt|;
name|cmd_format_command
argument_list|(
name|cmd
argument_list|,
name|ITS_CMD_MAPC
argument_list|)
expr_stmt|;
name|cmd_format_col
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_mapc
operator|.
name|col
operator|->
name|col_id
argument_list|)
expr_stmt|;
name|cmd_format_valid
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_mapc
operator|.
name|valid
argument_list|)
expr_stmt|;
name|cmd_format_target
argument_list|(
name|cmd
argument_list|,
name|target
argument_list|)
expr_stmt|;
break|break;
case|case
name|ITS_CMD_MAPVI
case|:
name|target
operator|=
name|desc
operator|->
name|cmd_desc_mapvi
operator|.
name|col
operator|->
name|col_target
expr_stmt|;
name|cmd_format_command
argument_list|(
name|cmd
argument_list|,
name|ITS_CMD_MAPVI
argument_list|)
expr_stmt|;
name|cmd_format_devid
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_mapvi
operator|.
name|its_dev
operator|->
name|devid
argument_list|)
expr_stmt|;
name|cmd_format_id
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_mapvi
operator|.
name|id
argument_list|)
expr_stmt|;
name|cmd_format_pid
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_mapvi
operator|.
name|pid
argument_list|)
expr_stmt|;
name|cmd_format_col
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_mapvi
operator|.
name|col
operator|->
name|col_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|ITS_CMD_MAPI
case|:
name|target
operator|=
name|desc
operator|->
name|cmd_desc_mapi
operator|.
name|col
operator|->
name|col_target
expr_stmt|;
name|cmd_format_command
argument_list|(
name|cmd
argument_list|,
name|ITS_CMD_MAPI
argument_list|)
expr_stmt|;
name|cmd_format_devid
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_mapi
operator|.
name|its_dev
operator|->
name|devid
argument_list|)
expr_stmt|;
name|cmd_format_id
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_mapi
operator|.
name|pid
argument_list|)
expr_stmt|;
name|cmd_format_col
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_mapi
operator|.
name|col
operator|->
name|col_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|ITS_CMD_INV
case|:
name|target
operator|=
name|desc
operator|->
name|cmd_desc_inv
operator|.
name|col
operator|->
name|col_target
expr_stmt|;
name|cmd_format_command
argument_list|(
name|cmd
argument_list|,
name|ITS_CMD_INV
argument_list|)
expr_stmt|;
name|cmd_format_devid
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_inv
operator|.
name|its_dev
operator|->
name|devid
argument_list|)
expr_stmt|;
name|cmd_format_id
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_inv
operator|.
name|pid
argument_list|)
expr_stmt|;
break|break;
case|case
name|ITS_CMD_INVALL
case|:
name|cmd_format_command
argument_list|(
name|cmd
argument_list|,
name|ITS_CMD_INVALL
argument_list|)
expr_stmt|;
name|cmd_format_col
argument_list|(
name|cmd
argument_list|,
name|desc
operator|->
name|cmd_desc_invall
operator|.
name|col
operator|->
name|col_id
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|error
condition|)
name|cmd_fix_endian
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
name|target
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint64_t
name|its_cmd_cwriter_offset
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|its_cmd
modifier|*
name|cmd
parameter_list|)
block|{
name|uint64_t
name|off
decl_stmt|;
name|off
operator|=
operator|(
name|cmd
operator|-
name|sc
operator|->
name|its_cmdq_base
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cmd
argument_list|)
expr_stmt|;
return|return
operator|(
name|off
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|its_cmd_wait_completion
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|its_cmd
modifier|*
name|cmd_first
parameter_list|,
name|struct
name|its_cmd
modifier|*
name|cmd_last
parameter_list|)
block|{
name|uint64_t
name|first
decl_stmt|,
name|last
decl_stmt|,
name|read
decl_stmt|;
name|size_t
name|us_left
decl_stmt|;
comment|/* 	 * XXX ARM64TODO: This is obviously a significant delay. 	 * The reason for that is that currently the time frames for 	 * the command to complete are not known. 	 */
name|us_left
operator|=
literal|1000000
expr_stmt|;
name|first
operator|=
name|its_cmd_cwriter_offset
argument_list|(
name|sc
argument_list|,
name|cmd_first
argument_list|)
expr_stmt|;
name|last
operator|=
name|its_cmd_cwriter_offset
argument_list|(
name|sc
argument_list|,
name|cmd_last
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|read
operator|=
name|gic_its_read
argument_list|(
name|sc
argument_list|,
literal|8
argument_list|,
name|GITS_CREADR
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
operator|<
name|first
operator|||
name|read
operator|>=
name|last
condition|)
break|break;
if|if
condition|(
name|us_left
operator|--
operator|==
literal|0
condition|)
block|{
comment|/* This means timeout */
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"Timeout while waiting for CMD completion.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|its_cmd_send
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|its_cmd_desc
modifier|*
name|desc
parameter_list|)
block|{
name|struct
name|its_cmd
modifier|*
name|cmd
decl_stmt|,
modifier|*
name|cmd_sync
decl_stmt|,
modifier|*
name|cmd_write
decl_stmt|;
name|struct
name|its_col
name|col_sync
decl_stmt|;
name|struct
name|its_cmd_desc
name|desc_sync
decl_stmt|;
name|uint64_t
name|target
decl_stmt|,
name|cwriter
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|its_cmd_lock
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|its_cmd_alloc_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|dev
argument_list|,
literal|"could not allocate ITS command\n"
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|its_cmd_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|target
operator|=
name|its_cmd_prepare
argument_list|(
name|cmd
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|its_cmd_sync
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|ITS_TARGET_NONE
condition|)
block|{
name|cmd_sync
operator|=
name|its_cmd_alloc_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd_sync
operator|==
name|NULL
condition|)
goto|goto
name|end
goto|;
name|desc_sync
operator|.
name|cmd_type
operator|=
name|ITS_CMD_SYNC
expr_stmt|;
name|col_sync
operator|.
name|col_target
operator|=
name|target
expr_stmt|;
name|desc_sync
operator|.
name|cmd_desc_sync
operator|.
name|col
operator|=
operator|&
name|col_sync
expr_stmt|;
name|its_cmd_prepare
argument_list|(
name|cmd_sync
argument_list|,
operator|&
name|desc_sync
argument_list|)
expr_stmt|;
name|its_cmd_sync
argument_list|(
name|sc
argument_list|,
name|cmd_sync
argument_list|)
expr_stmt|;
block|}
name|end
label|:
comment|/* Update GITS_CWRITER */
name|cwriter
operator|=
name|its_cmd_cwriter_offset
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|its_cmdq_write
argument_list|)
expr_stmt|;
name|gic_its_write
argument_list|(
name|sc
argument_list|,
literal|8
argument_list|,
name|GITS_CWRITER
argument_list|,
name|cwriter
argument_list|)
expr_stmt|;
name|cmd_write
operator|=
name|sc
operator|->
name|its_cmdq_write
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|its_cmd_lock
argument_list|)
expr_stmt|;
name|its_cmd_wait_completion
argument_list|(
name|sc
argument_list|,
name|cmd
argument_list|,
name|cmd_write
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find ITS device descriptor by pci_dev or irq number */
end_comment

begin_function
specifier|static
name|struct
name|its_dev
modifier|*
name|its_device_find_locked
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|pci_dev
parameter_list|,
name|uint32_t
name|irq
parameter_list|)
block|{
name|struct
name|its_dev
modifier|*
name|its_dev
decl_stmt|;
name|struct
name|lpi_chunk
modifier|*
name|lpis
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|its_dev_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|pci_dev
operator|==
name|NULL
operator|||
name|irq
operator|==
literal|0
operator|)
argument_list|,
operator|(
literal|"%s: Can't search by both pci_dev and irq number"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Find existing device if any */
name|TAILQ_FOREACH
argument_list|(
argument|its_dev
argument_list|,
argument|&sc->its_dev_list
argument_list|,
argument|entry
argument_list|)
block|{
if|if
condition|(
name|pci_dev
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|its_dev
operator|->
name|pci_dev
operator|==
name|pci_dev
condition|)
return|return
operator|(
name|its_dev
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|irq
operator|!=
literal|0
condition|)
block|{
name|lpis
operator|=
operator|&
name|its_dev
operator|->
name|lpis
expr_stmt|;
if|if
condition|(
operator|(
name|irq
operator|>=
name|lpis
operator|->
name|lpi_base
operator|)
operator|&&
operator|(
name|irq
operator|<
operator|(
name|lpis
operator|->
name|lpi_base
operator|+
name|lpis
operator|->
name|lpi_num
operator|)
operator|)
condition|)
return|return
operator|(
name|its_dev
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|its_dev
modifier|*
name|its_device_alloc
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|,
name|device_t
name|pci_dev
parameter_list|,
name|u_int
name|nvecs
parameter_list|)
block|{
name|struct
name|its_dev
modifier|*
name|newdev
decl_stmt|;
name|uint64_t
name|typer
decl_stmt|;
name|uint32_t
name|devid
decl_stmt|;
name|size_t
name|esize
decl_stmt|;
name|int
name|err
decl_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|its_dev_lock
argument_list|)
expr_stmt|;
comment|/* Find existing device if any */
name|newdev
operator|=
name|its_device_find_locked
argument_list|(
name|sc
argument_list|,
name|pci_dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|its_dev_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|newdev
operator|!=
name|NULL
condition|)
return|return
operator|(
name|newdev
operator|)
return|;
name|devid
operator|=
name|its_get_devid
argument_list|(
name|pci_dev
argument_list|)
expr_stmt|;
comment|/* There was no previously created device. Create one now */
name|newdev
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|newdev
argument_list|)
argument_list|,
name|M_GIC_V3_ITS
argument_list|,
operator|(
name|M_NOWAIT
operator||
name|M_ZERO
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newdev
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|newdev
operator|->
name|pci_dev
operator|=
name|pci_dev
expr_stmt|;
name|newdev
operator|->
name|devid
operator|=
name|devid
expr_stmt|;
name|err
operator|=
name|lpi_alloc_chunk
argument_list|(
name|sc
argument_list|,
operator|&
name|newdev
operator|->
name|lpis
argument_list|,
name|nvecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|newdev
argument_list|,
name|M_GIC_V3_ITS
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Get ITT entry size */
name|typer
operator|=
name|gic_its_read
argument_list|(
name|sc
argument_list|,
literal|8
argument_list|,
name|GITS_TYPER
argument_list|)
expr_stmt|;
name|esize
operator|=
name|GITS_TYPER_ITTES
argument_list|(
name|typer
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate ITT for this device. 	 * PA has to be 256 B aligned. At least two entries for device. 	 */
name|newdev
operator|->
name|itt
operator|=
operator|(
name|vm_offset_t
operator|)
name|contigmalloc
argument_list|(
name|roundup2
argument_list|(
name|roundup2
argument_list|(
name|nvecs
argument_list|,
literal|2
argument_list|)
operator|*
name|esize
argument_list|,
literal|0x100
argument_list|)
argument_list|,
name|M_GIC_V3_ITS
argument_list|,
operator|(
name|M_NOWAIT
operator||
name|M_ZERO
operator|)
argument_list|,
literal|0
argument_list|,
operator|~
literal|0UL
argument_list|,
literal|0x100
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|newdev
operator|->
name|itt
operator|==
literal|0
condition|)
block|{
name|lpi_free_chunk
argument_list|(
name|sc
argument_list|,
operator|&
name|newdev
operator|->
name|lpis
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newdev
argument_list|,
name|M_GIC_V3_ITS
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|its_dev_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sc
operator|->
name|its_dev_list
argument_list|,
name|newdev
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|its_dev_lock
argument_list|)
expr_stmt|;
comment|/* Map device to its ITT */
name|its_cmd_mapd
argument_list|(
name|sc
argument_list|,
name|newdev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|newdev
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|its_device_asign_lpi_locked
parameter_list|(
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|its_dev
modifier|*
name|its_dev
parameter_list|,
name|u_int
modifier|*
name|irq
parameter_list|)
block|{
name|mtx_assert
argument_list|(
operator|&
name|sc
operator|->
name|its_dev_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_free
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"Requesting more LPIs than allocated for this device. "
literal|"LPI num: %u, free %u"
argument_list|,
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_num
argument_list|,
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_free
argument_list|)
expr_stmt|;
block|}
operator|*
name|irq
operator|=
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_base
operator|+
operator|(
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_num
operator|-
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_free
operator|)
expr_stmt|;
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_free
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ITS quirks.  * Add vendor specific PCI devid function here.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|its_get_devid_thunder
parameter_list|(
name|device_t
name|pci_dev
parameter_list|)
block|{
name|int
name|bsf
decl_stmt|;
name|int
name|pem
decl_stmt|;
name|uint32_t
name|bus
decl_stmt|;
name|bus
operator|=
name|pci_get_bus
argument_list|(
name|pci_dev
argument_list|)
expr_stmt|;
name|bsf
operator|=
name|pci_get_rid
argument_list|(
name|pci_dev
argument_list|)
expr_stmt|;
comment|/* Check if accessing internal PCIe (low bus numbers) */
if|if
condition|(
name|bus
operator|<
name|GIC_V3_ITS_QUIRK_THUNDERX_PEM_BUS_OFFSET
condition|)
block|{
return|return
operator|(
operator|(
name|pci_get_domain
argument_list|(
name|pci_dev
argument_list|)
operator|<<
name|PCI_RID_DOMAIN_SHIFT
operator|)
operator||
name|bsf
operator|)
return|;
comment|/* PEM otherwise */
block|}
else|else
block|{
comment|/* PEM (PCIe MAC/root complex) number is equal to domain */
name|pem
operator|=
name|pci_get_domain
argument_list|(
name|pci_dev
argument_list|)
expr_stmt|;
comment|/* 		 * Set appropriate device ID (passed by the HW along with 		 * the transaction to memory) for different root complex 		 * numbers using hard-coded domain portion for each group. 		 */
if|if
condition|(
name|pem
operator|<
literal|3
condition|)
return|return
operator|(
operator|(
literal|0x1
operator|<<
name|PCI_RID_DOMAIN_SHIFT
operator|)
operator||
name|bsf
operator|)
return|;
if|if
condition|(
name|pem
operator|<
literal|6
condition|)
return|return
operator|(
operator|(
literal|0x3
operator|<<
name|PCI_RID_DOMAIN_SHIFT
operator|)
operator||
name|bsf
operator|)
return|;
if|if
condition|(
name|pem
operator|<
literal|9
condition|)
return|return
operator|(
operator|(
literal|0x9
operator|<<
name|PCI_RID_DOMAIN_SHIFT
operator|)
operator||
name|bsf
operator|)
return|;
if|if
condition|(
name|pem
operator|<
literal|12
condition|)
return|return
operator|(
operator|(
literal|0xB
operator|<<
name|PCI_RID_DOMAIN_SHIFT
operator|)
operator||
name|bsf
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|its_get_devbits_thunder
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|uint32_t
name|devid_bits
decl_stmt|;
comment|/* 	 * GITS_TYPER[17:13] of ThunderX reports that device IDs 	 * are to be 21 bits in length. 	 * The entry size of the ITS table can be read from GITS_BASERn[52:48] 	 * and on ThunderX is supposed to be 8 bytes in length (for device 	 * table). Finally the page size that is to be used by ITS to access 	 * this table will be set to 64KB. 	 * 	 * This gives 0x200000 entries of size 0x8 bytes covered by 256 pages 	 * each of which 64KB in size. The number of pages (minus 1) should 	 * then be written to GITS_BASERn[7:0]. In that case this value would 	 * be 0xFF but on ThunderX the maximum value that HW accepts is 0xFD. 	 * 	 * Set arbitrary number of device ID bits to 20 in order to limit 	 * the number of entries in ITS device table to 0x100000 and hence 	 * the table size to 8MB. 	 */
name|devid_bits
operator|=
literal|20
expr_stmt|;
if|if
condition|(
name|bootverbose
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"Limiting number of Device ID bits implemented to %d\n"
argument_list|,
name|devid_bits
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|devid_bits
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|its_get_devbits_default
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|uint64_t
name|gits_typer
decl_stmt|;
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|gits_typer
operator|=
name|gic_its_read
argument_list|(
name|sc
argument_list|,
literal|8
argument_list|,
name|GITS_TYPER
argument_list|)
expr_stmt|;
return|return
operator|(
name|GITS_TYPER_DEVB
argument_list|(
name|gits_typer
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|its_get_devbits
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|struct
name|its_quirks
modifier|*
name|quirk
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|its_quirks
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|quirk
operator|=
operator|&
name|its_quirks
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|CPU_MATCH_RAW
argument_list|(
name|quirk
operator|->
name|cpuid_mask
argument_list|,
name|quirk
operator|->
name|cpuid
argument_list|)
condition|)
block|{
if|if
condition|(
name|quirk
operator|->
name|devbits_func
operator|!=
name|NULL
condition|)
return|return
operator|(
call|(
modifier|*
name|quirk
operator|->
name|devbits_func
call|)
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
name|its_get_devbits_default
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint32_t
name|its_get_devid_default
parameter_list|(
name|device_t
name|pci_dev
parameter_list|)
block|{
return|return
operator|(
name|PCI_DEVID_GENERIC
argument_list|(
name|pci_dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|its_get_devid
parameter_list|(
name|device_t
name|pci_dev
parameter_list|)
block|{
specifier|const
name|struct
name|its_quirks
modifier|*
name|quirk
decl_stmt|;
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|its_quirks
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|quirk
operator|=
operator|&
name|its_quirks
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|CPU_MATCH_RAW
argument_list|(
name|quirk
operator|->
name|cpuid_mask
argument_list|,
name|quirk
operator|->
name|cpuid
argument_list|)
condition|)
block|{
if|if
condition|(
name|quirk
operator|->
name|devid_func
operator|!=
name|NULL
condition|)
return|return
operator|(
call|(
modifier|*
name|quirk
operator|->
name|devid_func
call|)
argument_list|(
name|pci_dev
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
name|its_get_devid_default
argument_list|(
name|pci_dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Message signalled interrupts handling.  */
end_comment

begin_comment
comment|/*  * XXX ARM64TODO: Watch out for "irq" type.  *  * In theory GIC can handle up to (2^32 - 1) interrupt IDs whereas  * we pass "irq" pointer of type integer. This is obviously wrong but  * is determined by the way as PCI layer wants it to be done.  */
end_comment

begin_function
name|int
name|gic_v3_its_alloc_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|pci_dev
parameter_list|,
name|int
modifier|*
name|irq
parameter_list|)
block|{
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|its_dev
modifier|*
name|its_dev
decl_stmt|;
name|u_int
name|nvecs
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|nvecs
operator|=
name|PCI_MSIX_NUM
argument_list|(
name|pci_dev
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate device as seen by ITS if not already available. 	 * Notice that MSI-X interrupts are allocated on one-by-one basis. 	 */
name|its_dev
operator|=
name|its_device_alloc
argument_list|(
name|sc
argument_list|,
name|pci_dev
argument_list|,
name|nvecs
argument_list|)
expr_stmt|;
if|if
condition|(
name|its_dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|its_dev_lock
argument_list|)
expr_stmt|;
name|its_device_asign_lpi_locked
argument_list|(
name|sc
argument_list|,
name|its_dev
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|its_dev_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|gic_v3_its_alloc_msi
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|pci_dev
parameter_list|,
name|int
name|count
parameter_list|,
name|int
modifier|*
name|irqs
parameter_list|)
block|{
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|its_dev
modifier|*
name|its_dev
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Allocate device as seen by ITS if not already available. */
name|its_dev
operator|=
name|its_device_alloc
argument_list|(
name|sc
argument_list|,
name|pci_dev
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|its_dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|its_dev_lock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|its_device_asign_lpi_locked
argument_list|(
name|sc
argument_list|,
name|its_dev
argument_list|,
name|irqs
argument_list|)
expr_stmt|;
name|irqs
operator|++
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|its_dev_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|gic_v3_its_map_msi
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|pci_dev
parameter_list|,
name|int
name|irq
parameter_list|,
name|uint64_t
modifier|*
name|addr
parameter_list|,
name|uint32_t
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|gic_v3_its_softc
modifier|*
name|sc
decl_stmt|;
name|bus_space_handle_t
name|its_bsh
decl_stmt|;
name|struct
name|its_dev
modifier|*
name|its_dev
decl_stmt|;
name|uint64_t
name|its_pa
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* Verify that this device is allocated and owns this LPI */
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|its_dev_lock
argument_list|)
expr_stmt|;
name|its_dev
operator|=
name|its_device_find_locked
argument_list|(
name|sc
argument_list|,
name|pci_dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|its_dev_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|its_dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|id
operator|=
name|irq
operator|-
name|its_dev
operator|->
name|lpis
operator|.
name|lpi_base
expr_stmt|;
name|lpi_map_to_device
argument_list|(
name|sc
argument_list|,
name|its_dev
argument_list|,
name|id
argument_list|,
name|irq
argument_list|)
expr_stmt|;
name|its_bsh
operator|=
name|rman_get_bushandle
argument_list|(
operator|&
name|sc
operator|->
name|its_res
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|its_pa
operator|=
name|vtophys
argument_list|(
name|its_bsh
argument_list|)
expr_stmt|;
operator|*
name|addr
operator|=
operator|(
name|its_pa
operator|+
name|GITS_TRANSLATER
operator|)
expr_stmt|;
operator|*
name|data
operator|=
name|id
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

