begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2007 Mellanox Technologies. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"mlx4_en.h"
end_include

begin_include
include|#
directive|include
file|<linux/mlx4/cq.h>
end_include

begin_include
include|#
directive|include
file|<linux/mlx4/qp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_enum
enum|enum
block|{
name|MIN_RX_ARM
init|=
literal|1024
block|, }
enum|;
end_enum

begin_function
specifier|static
name|int
name|mlx4_en_alloc_buf
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|,
name|struct
name|mlx4_en_rx_desc
modifier|*
name|rx_desc
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mb_list
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|struct
name|mlx4_en_dev
modifier|*
name|mdev
init|=
name|priv
operator|->
name|mdev
decl_stmt|;
name|struct
name|mlx4_en_frag_info
modifier|*
name|frag_info
init|=
operator|&
name|priv
operator|->
name|frag_info
index|[
name|i
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|dma_addr_t
name|dma
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|mb
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|frag_info
operator|->
name|frag_size
argument_list|)
expr_stmt|;
else|else
name|mb
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|0
argument_list|,
name|frag_info
operator|->
name|frag_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|==
name|NULL
condition|)
block|{
name|priv
operator|->
name|port_stats
operator|.
name|rx_alloc_failed
operator|++
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|dma
operator|=
name|pci_map_single
argument_list|(
name|mdev
operator|->
name|pdev
argument_list|,
name|mb
operator|->
name|m_data
argument_list|,
name|frag_info
operator|->
name|frag_size
argument_list|,
name|PCI_DMA_FROMDEVICE
argument_list|)
expr_stmt|;
name|rx_desc
operator|->
name|data
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|cpu_to_be64
argument_list|(
name|dma
argument_list|)
expr_stmt|;
name|mb_list
index|[
name|i
index|]
operator|=
name|mb
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_en_init_rx_desc
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|,
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|mlx4_en_rx_desc
modifier|*
name|rx_desc
init|=
name|ring
operator|->
name|buf
operator|+
name|ring
operator|->
name|stride
operator|*
name|index
decl_stmt|;
name|int
name|possible_frags
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Set size and memtype fields */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|priv
operator|->
name|num_frags
condition|;
name|i
operator|++
control|)
block|{
name|rx_desc
operator|->
name|data
index|[
name|i
index|]
operator|.
name|byte_count
operator|=
name|cpu_to_be32
argument_list|(
name|priv
operator|->
name|frag_info
index|[
name|i
index|]
operator|.
name|frag_size
argument_list|)
expr_stmt|;
name|rx_desc
operator|->
name|data
index|[
name|i
index|]
operator|.
name|lkey
operator|=
name|cpu_to_be32
argument_list|(
name|priv
operator|->
name|mdev
operator|->
name|mr
operator|.
name|key
argument_list|)
expr_stmt|;
block|}
comment|/* If the number of used fragments does not fill up the ring stride, 	 * remaining (unused) fragments must be padded with null address/size 	 * and a special memory key */
name|possible_frags
operator|=
operator|(
name|ring
operator|->
name|stride
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_en_rx_desc
argument_list|)
operator|)
operator|/
name|DS_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
name|priv
operator|->
name|num_frags
init|;
name|i
operator|<
name|possible_frags
condition|;
name|i
operator|++
control|)
block|{
name|rx_desc
operator|->
name|data
index|[
name|i
index|]
operator|.
name|byte_count
operator|=
literal|0
expr_stmt|;
name|rx_desc
operator|->
name|data
index|[
name|i
index|]
operator|.
name|lkey
operator|=
name|cpu_to_be32
argument_list|(
name|MLX4_EN_MEMTYPE_PAD
argument_list|)
expr_stmt|;
name|rx_desc
operator|->
name|data
index|[
name|i
index|]
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_en_prepare_rx_desc
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|,
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|mlx4_en_rx_desc
modifier|*
name|rx_desc
init|=
name|ring
operator|->
name|buf
operator|+
operator|(
name|index
operator|*
name|ring
operator|->
name|stride
operator|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mb_list
init|=
name|ring
operator|->
name|rx_info
operator|+
operator|(
name|index
operator|<<
name|priv
operator|->
name|log_rx_info
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|priv
operator|->
name|num_frags
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mlx4_en_alloc_buf
argument_list|(
name|priv
argument_list|,
name|rx_desc
argument_list|,
name|mb_list
argument_list|,
name|i
argument_list|)
condition|)
goto|goto
name|err
goto|;
return|return
literal|0
return|;
name|err
label|:
while|while
condition|(
name|i
operator|--
condition|)
name|m_free
argument_list|(
name|mb_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mlx4_en_update_rx_prod_db
parameter_list|(
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
operator|*
name|ring
operator|->
name|wqres
operator|.
name|db
operator|.
name|db
operator|=
name|cpu_to_be32
argument_list|(
name|ring
operator|->
name|prod
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_en_free_rx_desc
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|,
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|mlx4_en_frag_info
modifier|*
name|frag_info
decl_stmt|;
name|struct
name|mlx4_en_dev
modifier|*
name|mdev
init|=
name|priv
operator|->
name|mdev
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mb_list
decl_stmt|;
name|struct
name|mlx4_en_rx_desc
modifier|*
name|rx_desc
init|=
name|ring
operator|->
name|buf
operator|+
operator|(
name|index
operator|<<
name|ring
operator|->
name|log_stride
operator|)
decl_stmt|;
name|dma_addr_t
name|dma
decl_stmt|;
name|int
name|nr
decl_stmt|;
name|mb_list
operator|=
name|ring
operator|->
name|rx_info
operator|+
operator|(
name|index
operator|<<
name|priv
operator|->
name|log_rx_info
operator|)
expr_stmt|;
for|for
control|(
name|nr
operator|=
literal|0
init|;
name|nr
operator|<
name|priv
operator|->
name|num_frags
condition|;
name|nr
operator|++
control|)
block|{
name|en_dbg
argument_list|(
name|DRV
argument_list|,
name|priv
argument_list|,
literal|"Freeing fragment:%d\n"
argument_list|,
name|nr
argument_list|)
expr_stmt|;
name|frag_info
operator|=
operator|&
name|priv
operator|->
name|frag_info
index|[
name|nr
index|]
expr_stmt|;
name|dma
operator|=
name|be64_to_cpu
argument_list|(
name|rx_desc
operator|->
name|data
index|[
name|nr
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
name|en_dbg
argument_list|(
name|DRV
argument_list|,
name|priv
argument_list|,
literal|"Unmaping buffer at dma:0x%llx\n"
argument_list|,
operator|(
name|u64
operator|)
name|dma
argument_list|)
expr_stmt|;
name|pci_unmap_single
argument_list|(
name|mdev
operator|->
name|pdev
argument_list|,
name|dma
argument_list|,
name|frag_info
operator|->
name|frag_size
argument_list|,
name|PCI_DMA_FROMDEVICE
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|mb_list
index|[
name|nr
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_en_fill_rx_buffers
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
decl_stmt|;
name|int
name|ring_ind
decl_stmt|;
name|int
name|buf_ind
decl_stmt|;
name|int
name|new_size
decl_stmt|;
name|int
name|err
decl_stmt|;
for|for
control|(
name|buf_ind
operator|=
literal|0
init|;
name|buf_ind
operator|<
name|priv
operator|->
name|prof
operator|->
name|rx_ring_size
condition|;
name|buf_ind
operator|++
control|)
block|{
for|for
control|(
name|ring_ind
operator|=
literal|0
init|;
name|ring_ind
operator|<
name|priv
operator|->
name|rx_ring_num
condition|;
name|ring_ind
operator|++
control|)
block|{
name|ring
operator|=
operator|&
name|priv
operator|->
name|rx_ring
index|[
name|ring_ind
index|]
expr_stmt|;
name|err
operator|=
name|mlx4_en_prepare_rx_desc
argument_list|(
name|priv
argument_list|,
name|ring
argument_list|,
name|ring
operator|->
name|actual_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|ring
operator|->
name|actual_size
operator|==
literal|0
condition|)
block|{
name|en_err
argument_list|(
name|priv
argument_list|,
literal|"Failed to allocate "
literal|"enough rx buffers\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
else|else
block|{
name|new_size
operator|=
name|rounddown_pow_of_two
argument_list|(
name|ring
operator|->
name|actual_size
argument_list|)
expr_stmt|;
name|en_warn
argument_list|(
name|priv
argument_list|,
literal|"Only %d buffers allocated "
literal|"reducing ring size to %d\n"
argument_list|,
name|ring
operator|->
name|actual_size
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
goto|goto
name|reduce_rings
goto|;
block|}
block|}
name|ring
operator|->
name|actual_size
operator|++
expr_stmt|;
name|ring
operator|->
name|prod
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
name|reduce_rings
label|:
for|for
control|(
name|ring_ind
operator|=
literal|0
init|;
name|ring_ind
operator|<
name|priv
operator|->
name|rx_ring_num
condition|;
name|ring_ind
operator|++
control|)
block|{
name|ring
operator|=
operator|&
name|priv
operator|->
name|rx_ring
index|[
name|ring_ind
index|]
expr_stmt|;
while|while
condition|(
name|ring
operator|->
name|actual_size
operator|>
name|new_size
condition|)
block|{
name|ring
operator|->
name|actual_size
operator|--
expr_stmt|;
name|ring
operator|->
name|prod
operator|--
expr_stmt|;
name|mlx4_en_free_rx_desc
argument_list|(
name|priv
argument_list|,
name|ring
argument_list|,
name|ring
operator|->
name|actual_size
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_en_free_rx_buf
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|,
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|en_dbg
argument_list|(
name|DRV
argument_list|,
name|priv
argument_list|,
literal|"Freeing Rx buf - cons:%d prod:%d\n"
argument_list|,
name|ring
operator|->
name|cons
argument_list|,
name|ring
operator|->
name|prod
argument_list|)
expr_stmt|;
comment|/* Unmap and free Rx buffers */
name|BUG_ON
argument_list|(
call|(
name|u32
call|)
argument_list|(
name|ring
operator|->
name|prod
operator|-
name|ring
operator|->
name|cons
argument_list|)
operator|>
name|ring
operator|->
name|actual_size
argument_list|)
expr_stmt|;
while|while
condition|(
name|ring
operator|->
name|cons
operator|!=
name|ring
operator|->
name|prod
condition|)
block|{
name|index
operator|=
name|ring
operator|->
name|cons
operator|&
name|ring
operator|->
name|size_mask
expr_stmt|;
name|en_dbg
argument_list|(
name|DRV
argument_list|,
name|priv
argument_list|,
literal|"Processing descriptor:%d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|mlx4_en_free_rx_desc
argument_list|(
name|priv
argument_list|,
name|ring
argument_list|,
name|index
argument_list|)
expr_stmt|;
operator|++
name|ring
operator|->
name|cons
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|mlx4_en_create_rx_ring
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|,
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
parameter_list|,
name|u32
name|size
parameter_list|)
block|{
name|struct
name|mlx4_en_dev
modifier|*
name|mdev
init|=
name|priv
operator|->
name|mdev
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|ring
operator|->
name|prod
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|cons
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|ring
operator|->
name|size_mask
operator|=
name|size
operator|-
literal|1
expr_stmt|;
name|ring
operator|->
name|stride
operator|=
name|roundup_pow_of_two
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_en_rx_desc
argument_list|)
operator|+
name|DS_SIZE
operator|*
name|MLX4_EN_MAX_RX_FRAGS
argument_list|)
expr_stmt|;
name|ring
operator|->
name|log_stride
operator|=
name|ffs
argument_list|(
name|ring
operator|->
name|stride
argument_list|)
operator|-
literal|1
expr_stmt|;
name|ring
operator|->
name|buf_size
operator|=
name|ring
operator|->
name|size
operator|*
name|ring
operator|->
name|stride
operator|+
name|TXBB_SIZE
expr_stmt|;
name|tmp
operator|=
name|size
operator|*
name|roundup_pow_of_two
argument_list|(
name|MLX4_EN_MAX_RX_FRAGS
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mbuf
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ring
operator|->
name|rx_info
operator|=
name|kmalloc
argument_list|(
name|tmp
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ring
operator|->
name|rx_info
condition|)
block|{
name|en_err
argument_list|(
name|priv
argument_list|,
literal|"Failed allocating rx_info ring\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|en_dbg
argument_list|(
name|DRV
argument_list|,
name|priv
argument_list|,
literal|"Allocated rx_info ring at addr:%p size:%d stride:%d (%d)\n"
argument_list|,
name|ring
operator|->
name|rx_info
argument_list|,
name|tmp
argument_list|,
name|ring
operator|->
name|stride
argument_list|,
name|ring
operator|->
name|log_stride
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_alloc_hwq_res
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|ring
operator|->
name|wqres
argument_list|,
name|ring
operator|->
name|buf_size
argument_list|,
literal|2
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_ring
goto|;
name|err
operator|=
name|mlx4_en_map_buffer
argument_list|(
operator|&
name|ring
operator|->
name|wqres
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|en_err
argument_list|(
name|priv
argument_list|,
literal|"Failed to map RX buffer\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_hwq
goto|;
block|}
name|ring
operator|->
name|buf
operator|=
name|ring
operator|->
name|wqres
operator|.
name|buf
operator|.
name|direct
operator|.
name|buf
expr_stmt|;
return|return
literal|0
return|;
name|mlx4_en_unmap_buffer
argument_list|(
operator|&
name|ring
operator|->
name|wqres
operator|.
name|buf
argument_list|)
expr_stmt|;
name|err_hwq
label|:
name|mlx4_free_hwq_res
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|ring
operator|->
name|wqres
argument_list|,
name|ring
operator|->
name|buf_size
argument_list|)
expr_stmt|;
name|err_ring
label|:
name|kfree
argument_list|(
name|ring
operator|->
name|rx_info
argument_list|)
expr_stmt|;
name|ring
operator|->
name|rx_info
operator|=
name|NULL
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_en_activate_rx_rings
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ring_ind
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|stride
init|=
name|roundup_pow_of_two
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_en_rx_desc
argument_list|)
operator|+
name|DS_SIZE
operator|*
name|priv
operator|->
name|num_frags
argument_list|)
decl_stmt|;
for|for
control|(
name|ring_ind
operator|=
literal|0
init|;
name|ring_ind
operator|<
name|priv
operator|->
name|rx_ring_num
condition|;
name|ring_ind
operator|++
control|)
block|{
name|ring
operator|=
operator|&
name|priv
operator|->
name|rx_ring
index|[
name|ring_ind
index|]
expr_stmt|;
name|ring
operator|->
name|prod
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|cons
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|actual_size
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|cqn
operator|=
name|priv
operator|->
name|rx_cq
index|[
name|ring_ind
index|]
operator|.
name|mcq
operator|.
name|cqn
expr_stmt|;
name|ring
operator|->
name|stride
operator|=
name|stride
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|stride
operator|<=
name|TXBB_SIZE
condition|)
name|ring
operator|->
name|buf
operator|+=
name|TXBB_SIZE
expr_stmt|;
name|ring
operator|->
name|log_stride
operator|=
name|ffs
argument_list|(
name|ring
operator|->
name|stride
argument_list|)
operator|-
literal|1
expr_stmt|;
name|ring
operator|->
name|buf_size
operator|=
name|ring
operator|->
name|size
operator|*
name|ring
operator|->
name|stride
expr_stmt|;
name|memset
argument_list|(
name|ring
operator|->
name|buf
argument_list|,
literal|0
argument_list|,
name|ring
operator|->
name|buf_size
argument_list|)
expr_stmt|;
name|mlx4_en_update_rx_prod_db
argument_list|(
name|ring
argument_list|)
expr_stmt|;
comment|/* Initailize all descriptors */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ring
operator|->
name|size
condition|;
name|i
operator|++
control|)
name|mlx4_en_init_rx_desc
argument_list|(
name|priv
argument_list|,
name|ring
argument_list|,
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
comment|/* Configure lro mngr */
if|if
condition|(
name|priv
operator|->
name|dev
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
condition|)
block|{
if|if
condition|(
name|tcp_lro_init
argument_list|(
operator|&
name|ring
operator|->
name|lro
argument_list|)
condition|)
name|priv
operator|->
name|dev
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_LRO
expr_stmt|;
else|else
name|ring
operator|->
name|lro
operator|.
name|ifp
operator|=
name|priv
operator|->
name|dev
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|err
operator|=
name|mlx4_en_fill_rx_buffers
argument_list|(
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_buffers
goto|;
for|for
control|(
name|ring_ind
operator|=
literal|0
init|;
name|ring_ind
operator|<
name|priv
operator|->
name|rx_ring_num
condition|;
name|ring_ind
operator|++
control|)
block|{
name|ring
operator|=
operator|&
name|priv
operator|->
name|rx_ring
index|[
name|ring_ind
index|]
expr_stmt|;
name|ring
operator|->
name|size_mask
operator|=
name|ring
operator|->
name|actual_size
operator|-
literal|1
expr_stmt|;
name|mlx4_en_update_rx_prod_db
argument_list|(
name|ring
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|err_buffers
label|:
for|for
control|(
name|ring_ind
operator|=
literal|0
init|;
name|ring_ind
operator|<
name|priv
operator|->
name|rx_ring_num
condition|;
name|ring_ind
operator|++
control|)
name|mlx4_en_free_rx_buf
argument_list|(
name|priv
argument_list|,
operator|&
name|priv
operator|->
name|rx_ring
index|[
name|ring_ind
index|]
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|void
name|mlx4_en_destroy_rx_ring
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|,
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|struct
name|mlx4_en_dev
modifier|*
name|mdev
init|=
name|priv
operator|->
name|mdev
decl_stmt|;
name|mlx4_en_unmap_buffer
argument_list|(
operator|&
name|ring
operator|->
name|wqres
operator|.
name|buf
argument_list|)
expr_stmt|;
name|mlx4_free_hwq_res
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|ring
operator|->
name|wqres
argument_list|,
name|ring
operator|->
name|buf_size
operator|+
name|TXBB_SIZE
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|ring
operator|->
name|rx_info
argument_list|)
expr_stmt|;
name|ring
operator|->
name|rx_info
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mlx4_en_deactivate_rx_ring
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|,
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET
name|tcp_lro_free
argument_list|(
operator|&
name|ring
operator|->
name|lro
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mlx4_en_free_rx_buf
argument_list|(
name|priv
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|stride
operator|<=
name|TXBB_SIZE
condition|)
name|ring
operator|->
name|buf
operator|-=
name|TXBB_SIZE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Unmap a completed descriptor and free unused pages */
end_comment

begin_function
specifier|static
name|int
name|mlx4_en_complete_rx_desc
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|,
name|struct
name|mlx4_en_rx_desc
modifier|*
name|rx_desc
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mb_list
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|struct
name|mlx4_en_dev
modifier|*
name|mdev
init|=
name|priv
operator|->
name|mdev
decl_stmt|;
name|struct
name|mlx4_en_frag_info
modifier|*
name|frag_info
decl_stmt|;
name|dma_addr_t
name|dma
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|int
name|nr
decl_stmt|;
name|mb
operator|=
name|mb_list
index|[
literal|0
index|]
expr_stmt|;
name|mb
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|length
expr_stmt|;
comment|/* Collect used fragments while replacing them in the HW descirptors */
for|for
control|(
name|nr
operator|=
literal|0
init|;
name|nr
operator|<
name|priv
operator|->
name|num_frags
condition|;
name|nr
operator|++
control|)
block|{
name|frag_info
operator|=
operator|&
name|priv
operator|->
name|frag_info
index|[
name|nr
index|]
expr_stmt|;
if|if
condition|(
name|length
operator|<=
name|frag_info
operator|->
name|frag_prefix_size
condition|)
break|break;
if|if
condition|(
name|nr
condition|)
name|mb
operator|->
name|m_next
operator|=
name|mb_list
index|[
name|nr
index|]
expr_stmt|;
name|mb
operator|=
name|mb_list
index|[
name|nr
index|]
expr_stmt|;
name|mb
operator|->
name|m_len
operator|=
name|frag_info
index|[
name|nr
index|]
operator|.
name|frag_size
expr_stmt|;
name|dma
operator|=
name|be64_to_cpu
argument_list|(
name|rx_desc
operator|->
name|data
index|[
name|nr
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
comment|/* Allocate a replacement page */
if|if
condition|(
name|mlx4_en_alloc_buf
argument_list|(
name|priv
argument_list|,
name|rx_desc
argument_list|,
name|mb_list
argument_list|,
name|nr
argument_list|)
condition|)
goto|goto
name|fail
goto|;
comment|/* Unmap buffer */
name|pci_unmap_single
argument_list|(
name|mdev
operator|->
name|pdev
argument_list|,
name|dma
argument_list|,
name|frag_info
index|[
name|nr
index|]
operator|.
name|frag_size
argument_list|,
name|PCI_DMA_FROMDEVICE
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust size of last fragment to match actual length */
name|mb
operator|->
name|m_len
operator|=
name|length
operator|-
name|priv
operator|->
name|frag_info
index|[
name|nr
operator|-
literal|1
index|]
operator|.
name|frag_prefix_size
expr_stmt|;
name|mb
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
comment|/* Drop all accumulated fragments (which have already been replaced in 	 * the descriptor) of this packet; remaining fragments are reused... */
while|while
condition|(
name|nr
operator|>
literal|0
condition|)
block|{
name|nr
operator|--
expr_stmt|;
name|m_free
argument_list|(
name|mb_list
index|[
name|nr
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
name|ENOMEM
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|invalid_cqe
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|,
name|struct
name|mlx4_cqe
modifier|*
name|cqe
parameter_list|)
block|{
comment|/* Drop packet on bad receive or bad checksum */
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|cqe
operator|->
name|owner_sr_opcode
operator|&
name|MLX4_CQE_OPCODE_MASK
operator|)
operator|==
name|MLX4_CQE_OPCODE_ERROR
argument_list|)
condition|)
block|{
name|en_err
argument_list|(
name|priv
argument_list|,
literal|"CQE completed in error - vendor "
literal|"syndrom:%d syndrom:%d\n"
argument_list|,
operator|(
operator|(
expr|struct
name|mlx4_err_cqe
operator|*
operator|)
name|cqe
operator|)
operator|->
name|vendor_err_syndrome
argument_list|,
operator|(
operator|(
expr|struct
name|mlx4_err_cqe
operator|*
operator|)
name|cqe
operator|)
operator|->
name|syndrome
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|cqe
operator|->
name|badfcs_enc
operator|&
name|MLX4_CQE_BAD_FCS
argument_list|)
condition|)
block|{
name|en_dbg
argument_list|(
name|RX_ERR
argument_list|,
name|priv
argument_list|,
literal|"Accepted frame with bad FCS\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
empty_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|validate_loopback
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mb
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|offset
init|=
name|ETHER_HDR_LEN
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX4_LOOPBACK_TEST_PAYLOAD
condition|;
name|i
operator|++
operator|,
name|offset
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|mb
operator|->
name|m_data
operator|+
name|offset
operator|)
operator|!=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|i
operator|&
literal|0xff
argument_list|)
condition|)
goto|goto
name|out_loopback
goto|;
block|}
comment|/* Loopback found */
name|priv
operator|->
name|loopback_ok
operator|=
literal|1
expr_stmt|;
name|out_loopback
label|:
name|m_freem
argument_list|(
name|mb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|mlx4_en_rx_mb
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|,
name|struct
name|mlx4_en_rx_desc
modifier|*
name|rx_desc
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mb_list
parameter_list|,
name|unsigned
name|int
name|length
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|mb
operator|=
name|mb_list
index|[
literal|0
index|]
expr_stmt|;
comment|/* Move relevant fragments to mb */
if|if
condition|(
name|unlikely
argument_list|(
name|mlx4_en_complete_rx_desc
argument_list|(
name|priv
argument_list|,
name|rx_desc
argument_list|,
name|mb_list
argument_list|,
name|length
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
name|mb
return|;
block|}
end_function

begin_function
name|int
name|mlx4_en_process_rx_cq
parameter_list|(
name|struct
name|net_device
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_en_cq
modifier|*
name|cq
parameter_list|,
name|int
name|budget
parameter_list|)
block|{
name|struct
name|mlx4_en_priv
modifier|*
name|priv
init|=
name|netdev_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_cqe
modifier|*
name|cqe
decl_stmt|;
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
init|=
operator|&
name|priv
operator|->
name|rx_ring
index|[
name|cq
operator|->
name|ring
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
modifier|*
name|mb_list
decl_stmt|;
name|struct
name|mlx4_en_rx_desc
modifier|*
name|rx_desc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|lro_entry
modifier|*
name|queued
decl_stmt|;
endif|#
directive|endif
name|int
name|index
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|int
name|polled
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|port_up
condition|)
return|return
literal|0
return|;
comment|/* We assume a 1:1 mapping between CQEs and Rx descriptors, so Rx 	 * descriptor offset can be deduced from the CQE index instead of 	 * reading 'cqe->index' */
name|index
operator|=
name|cq
operator|->
name|mcq
operator|.
name|cons_index
operator|&
name|ring
operator|->
name|size_mask
expr_stmt|;
name|cqe
operator|=
operator|&
name|cq
operator|->
name|buf
index|[
name|index
index|]
expr_stmt|;
comment|/* Process all completed CQEs */
while|while
condition|(
name|XNOR
argument_list|(
name|cqe
operator|->
name|owner_sr_opcode
operator|&
name|MLX4_CQE_OWNER_MASK
argument_list|,
name|cq
operator|->
name|mcq
operator|.
name|cons_index
operator|&
name|cq
operator|->
name|size
argument_list|)
condition|)
block|{
name|mb_list
operator|=
name|ring
operator|->
name|rx_info
operator|+
operator|(
name|index
operator|<<
name|priv
operator|->
name|log_rx_info
operator|)
expr_stmt|;
name|rx_desc
operator|=
name|ring
operator|->
name|buf
operator|+
operator|(
name|index
operator|<<
name|ring
operator|->
name|log_stride
operator|)
expr_stmt|;
comment|/* 		 * make sure we read the CQE after we read the ownership bit 		 */
name|rmb
argument_list|()
expr_stmt|;
if|if
condition|(
name|invalid_cqe
argument_list|(
name|priv
argument_list|,
name|cqe
argument_list|)
condition|)
goto|goto
name|next
goto|;
comment|/* 		 * Packet is OK - process it. 		 */
name|length
operator|=
name|be32_to_cpu
argument_list|(
name|cqe
operator|->
name|byte_cnt
argument_list|)
expr_stmt|;
name|mb
operator|=
name|mlx4_en_rx_mb
argument_list|(
name|priv
argument_list|,
name|rx_desc
argument_list|,
name|mb_list
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mb
condition|)
block|{
name|ring
operator|->
name|errors
operator|++
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|ring
operator|->
name|bytes
operator|+=
name|length
expr_stmt|;
name|ring
operator|->
name|packets
operator|++
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|priv
operator|->
name|validate_loopback
argument_list|)
condition|)
block|{
name|validate_loopback
argument_list|(
name|priv
argument_list|,
name|mb
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|mb
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|cq
operator|->
name|ring
expr_stmt|;
name|mb
operator|->
name|m_flags
operator||=
name|M_FLOWID
expr_stmt|;
name|mb
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|cqe
operator|->
name|vlan_my_qpn
argument_list|)
operator|&
name|MLX4_CQE_VLAN_PRESENT_MASK
condition|)
block|{
name|mb
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|be16_to_cpu
argument_list|(
name|cqe
operator|->
name|sl_vid
argument_list|)
expr_stmt|;
name|mb
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
if|if
condition|(
name|likely
argument_list|(
name|priv
operator|->
name|rx_csum
argument_list|)
operator|&&
operator|(
name|cqe
operator|->
name|status
operator|&
name|cpu_to_be16
argument_list|(
name|MLX4_CQE_STATUS_IPOK
argument_list|)
operator|)
operator|&&
operator|(
name|cqe
operator|->
name|checksum
operator|==
name|cpu_to_be16
argument_list|(
literal|0xffff
argument_list|)
operator|)
condition|)
block|{
name|priv
operator|->
name|port_stats
operator|.
name|rx_chksum_good
operator|++
expr_stmt|;
name|mb
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
name|mb
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|htons
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* This packet is eligible for LRO if it is: 			 * - DIX Ethernet (type interpretation) 			 * - TCP/IP (v4) 			 * - without IP options 			 * - not an IP fragment 			 */
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|mlx4_en_can_lro
argument_list|(
name|cqe
operator|->
name|status
argument_list|)
operator|&&
operator|(
name|dev
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
operator|)
condition|)
block|{
if|if
condition|(
name|ring
operator|->
name|lro
operator|.
name|lro_cnt
operator|!=
literal|0
operator|&&
name|tcp_lro_rx
argument_list|(
operator|&
name|ring
operator|->
name|lro
argument_list|,
name|mb
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|next
goto|;
block|}
endif|#
directive|endif
comment|/* LRO not possible, complete processing here */
name|INC_PERF_COUNTER
argument_list|(
name|priv
operator|->
name|pstats
operator|.
name|lro_misses
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mb
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|port_stats
operator|.
name|rx_chksum_none
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|priv
operator|->
name|ip_reasm
operator|&&
name|cqe
operator|->
name|status
operator|&
name|cpu_to_be16
argument_list|(
name|MLX4_CQE_STATUS_IPV4
argument_list|)
operator|&&
operator|!
name|mlx4_en_rx_frags
argument_list|(
name|priv
argument_list|,
name|ring
argument_list|,
name|mb
argument_list|,
name|cqe
argument_list|)
condition|)
goto|goto
name|next
goto|;
endif|#
directive|endif
block|}
comment|/* Push it up the stack */
name|dev
operator|->
name|if_input
argument_list|(
name|dev
argument_list|,
name|mb
argument_list|)
expr_stmt|;
name|next
label|:
operator|++
name|cq
operator|->
name|mcq
operator|.
name|cons_index
expr_stmt|;
name|index
operator|=
operator|(
name|cq
operator|->
name|mcq
operator|.
name|cons_index
operator|)
operator|&
name|ring
operator|->
name|size_mask
expr_stmt|;
name|cqe
operator|=
operator|&
name|cq
operator|->
name|buf
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|polled
operator|==
name|budget
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* Flush all pending IP reassembly sessions */
name|out
label|:
ifdef|#
directive|ifdef
name|INET
name|mlx4_en_flush_frags
argument_list|(
name|priv
argument_list|,
name|ring
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|queued
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|ring
operator|->
name|lro
operator|.
name|lro_active
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|ring
operator|->
name|lro
operator|.
name|lro_active
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|tcp_lro_flush
argument_list|(
operator|&
name|ring
operator|->
name|lro
argument_list|,
name|queued
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|AVG_PERF_COUNTER
argument_list|(
name|priv
operator|->
name|pstats
operator|.
name|rx_coal_avg
argument_list|,
name|polled
argument_list|)
expr_stmt|;
name|mlx4_cq_set_ci
argument_list|(
operator|&
name|cq
operator|->
name|mcq
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
comment|/* ensure HW sees CQ consumer before we post new buffers */
name|ring
operator|->
name|cons
operator|=
name|cq
operator|->
name|mcq
operator|.
name|cons_index
expr_stmt|;
name|ring
operator|->
name|prod
operator|+=
name|polled
expr_stmt|;
comment|/* Polled descriptors were realocated in place */
name|mlx4_en_update_rx_prod_db
argument_list|(
name|ring
argument_list|)
expr_stmt|;
return|return
name|polled
return|;
block|}
end_function

begin_comment
comment|/* Rx CQ polling - called by NAPI */
end_comment

begin_function
specifier|static
name|int
name|mlx4_en_poll_rx_cq
parameter_list|(
name|struct
name|mlx4_en_cq
modifier|*
name|cq
parameter_list|,
name|int
name|budget
parameter_list|)
block|{
name|struct
name|net_device
modifier|*
name|dev
init|=
name|cq
operator|->
name|dev
decl_stmt|;
name|int
name|done
decl_stmt|;
name|done
operator|=
name|mlx4_en_process_rx_cq
argument_list|(
name|dev
argument_list|,
name|cq
argument_list|,
name|budget
argument_list|)
expr_stmt|;
name|cq
operator|->
name|tot_rx
operator|+=
name|done
expr_stmt|;
return|return
name|done
return|;
block|}
end_function

begin_function
name|void
name|mlx4_en_rx_que
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|mlx4_en_cq
modifier|*
name|cq
decl_stmt|;
name|cq
operator|=
name|context
expr_stmt|;
while|while
condition|(
name|mlx4_en_poll_rx_cq
argument_list|(
name|cq
argument_list|,
name|MLX4_EN_MAX_RX_POLL
argument_list|)
operator|==
name|MLX4_EN_MAX_RX_POLL
condition|)
empty_stmt|;
name|mlx4_en_arm_cq
argument_list|(
name|cq
operator|->
name|dev
operator|->
name|if_softc
argument_list|,
name|cq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mlx4_en_rx_irq
parameter_list|(
name|struct
name|mlx4_cq
modifier|*
name|mcq
parameter_list|)
block|{
name|struct
name|mlx4_en_cq
modifier|*
name|cq
init|=
name|container_of
argument_list|(
name|mcq
argument_list|,
expr|struct
name|mlx4_en_cq
argument_list|,
name|mcq
argument_list|)
decl_stmt|;
name|struct
name|mlx4_en_priv
modifier|*
name|priv
init|=
name|netdev_priv
argument_list|(
name|cq
operator|->
name|dev
argument_list|)
decl_stmt|;
name|int
name|done
decl_stmt|;
name|done
operator|=
name|mlx4_en_poll_rx_cq
argument_list|(
name|cq
argument_list|,
name|MLX4_EN_MAX_RX_POLL
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
operator|==
name|MLX4_EN_MAX_RX_POLL
condition|)
name|taskqueue_enqueue
argument_list|(
name|cq
operator|->
name|tq
argument_list|,
operator|&
name|cq
operator|->
name|cq_task
argument_list|)
expr_stmt|;
else|else
name|mlx4_en_arm_cq
argument_list|(
name|priv
argument_list|,
name|cq
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|MLX4_EN_MAX_RX_FRAGS
operator|==
literal|3
end_if

begin_decl_stmt
specifier|static
name|int
name|frag_sizes
index|[]
init|=
block|{
name|FRAG_SZ0
block|,
name|FRAG_SZ1
block|,
name|FRAG_SZ2
block|, }
decl_stmt|;
end_decl_stmt

begin_elif
elif|#
directive|elif
name|MLX4_EN_MAX_RX_FRAGS
operator|==
literal|2
end_elif

begin_decl_stmt
specifier|static
name|int
name|frag_sizes
index|[]
init|=
block|{
name|FRAG_SZ0
block|,
name|FRAG_SZ1
block|, }
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
literal|"Unknown MAX_RX_FRAGS"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|mlx4_en_calc_rx_buf
parameter_list|(
name|struct
name|net_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_en_priv
modifier|*
name|priv
init|=
name|netdev_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|eff_mtu
init|=
name|dev
operator|->
name|if_mtu
operator|+
name|ETHER_HDR_LEN
operator|+
name|ETHER_VLAN_ENCAP_LEN
operator|+
name|ETH_LLC_SNAP_SIZE
decl_stmt|;
name|int
name|buf_size
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|frag
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|frag
operator|=
literal|0
init|;
name|buf_size
operator|<
name|eff_mtu
condition|;
name|frag
operator|++
operator|,
name|i
operator|++
control|)
block|{
comment|/* 		 * Allocate small to large but only as much as is needed for 		 * the tail. 		 */
while|while
condition|(
name|i
operator|>
literal|0
operator|&&
name|eff_mtu
operator|-
name|buf_size
operator|<=
name|frag_sizes
index|[
name|i
operator|-
literal|1
index|]
condition|)
name|i
operator|--
expr_stmt|;
name|priv
operator|->
name|frag_info
index|[
name|frag
index|]
operator|.
name|frag_size
operator|=
name|frag_sizes
index|[
name|i
index|]
expr_stmt|;
name|priv
operator|->
name|frag_info
index|[
name|frag
index|]
operator|.
name|frag_prefix_size
operator|=
name|buf_size
expr_stmt|;
name|buf_size
operator|+=
name|priv
operator|->
name|frag_info
index|[
name|frag
index|]
operator|.
name|frag_size
expr_stmt|;
block|}
name|priv
operator|->
name|num_frags
operator|=
name|frag
expr_stmt|;
name|priv
operator|->
name|rx_mb_size
operator|=
name|eff_mtu
expr_stmt|;
name|priv
operator|->
name|log_rx_info
operator|=
name|ROUNDUP_LOG2
argument_list|(
name|priv
operator|->
name|num_frags
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mbuf
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|en_dbg
argument_list|(
name|DRV
argument_list|,
name|priv
argument_list|,
literal|"Rx buffer scatter-list (effective-mtu:%d "
literal|"num_frags:%d):\n"
argument_list|,
name|eff_mtu
argument_list|,
name|priv
operator|->
name|num_frags
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|priv
operator|->
name|num_frags
condition|;
name|i
operator|++
control|)
block|{
name|en_dbg
argument_list|(
argument|DRV
argument_list|,
argument|priv
argument_list|,
literal|"  frag:%d - size:%d prefix:%d\n"
argument_list|,
argument|i
argument_list|,
argument|priv->frag_info[i].frag_size
argument_list|,
argument|priv->frag_info[i].frag_prefix_size
argument_list|)
block|}
block|}
end_function

begin_comment
comment|/* RSS related functions */
end_comment

begin_function
specifier|static
name|int
name|mlx4_en_config_rss_qp
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|,
name|int
name|qpn
parameter_list|,
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
parameter_list|,
name|enum
name|mlx4_qp_state
modifier|*
name|state
parameter_list|,
name|struct
name|mlx4_qp
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|mlx4_en_dev
modifier|*
name|mdev
init|=
name|priv
operator|->
name|mdev
decl_stmt|;
name|struct
name|mlx4_qp_context
modifier|*
name|context
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|context
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|context
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
block|{
name|en_err
argument_list|(
name|priv
argument_list|,
literal|"Failed to allocate qp context\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|err
operator|=
name|mlx4_qp_alloc
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|qpn
argument_list|,
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|en_err
argument_list|(
name|priv
argument_list|,
literal|"Failed to allocate qp #%x\n"
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|qp
operator|->
name|event
operator|=
name|mlx4_en_sqp_event
expr_stmt|;
name|memset
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|context
argument_list|)
expr_stmt|;
name|mlx4_en_fill_qp_context
argument_list|(
name|priv
argument_list|,
name|ring
operator|->
name|actual_size
argument_list|,
name|ring
operator|->
name|stride
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|qpn
argument_list|,
name|ring
operator|->
name|cqn
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|context
operator|->
name|db_rec_addr
operator|=
name|cpu_to_be64
argument_list|(
name|ring
operator|->
name|wqres
operator|.
name|db
operator|.
name|dma
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_qp_to_ready
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|ring
operator|->
name|wqres
operator|.
name|mtt
argument_list|,
name|context
argument_list|,
name|qp
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_qp_remove
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|mlx4_qp_free
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|qp
argument_list|)
expr_stmt|;
block|}
name|mlx4_en_update_rx_prod_db
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|out
label|:
name|kfree
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Allocate rx qp's and configure them according to rss map */
end_comment

begin_function
name|int
name|mlx4_en_config_rss_steer
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|mlx4_en_dev
modifier|*
name|mdev
init|=
name|priv
operator|->
name|mdev
decl_stmt|;
name|struct
name|mlx4_en_rss_map
modifier|*
name|rss_map
init|=
operator|&
name|priv
operator|->
name|rss_map
decl_stmt|;
name|struct
name|mlx4_qp_context
name|context
decl_stmt|;
name|struct
name|mlx4_en_rss_context
modifier|*
name|rss_context
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|u8
name|rss_mask
decl_stmt|;
name|int
name|i
decl_stmt|,
name|qpn
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|good_qps
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mdev
operator|->
name|profile
operator|.
name|udp_rss
condition|)
name|rss_mask
operator|=
literal|0x3f
expr_stmt|;
else|else
name|rss_mask
operator|=
literal|0x14
expr_stmt|;
name|en_dbg
argument_list|(
name|DRV
argument_list|,
name|priv
argument_list|,
literal|"Configuring rss steering\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_qp_reserve_range
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|priv
operator|->
name|rx_ring_num
argument_list|,
name|roundup_pow_of_two
argument_list|(
name|priv
operator|->
name|rx_ring_num
argument_list|)
argument_list|,
operator|&
name|rss_map
operator|->
name|base_qpn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|en_err
argument_list|(
name|priv
argument_list|,
literal|"Failed reserving %d qps\n"
argument_list|,
name|priv
operator|->
name|rx_ring_num
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|priv
operator|->
name|rx_ring_num
condition|;
name|i
operator|++
control|)
block|{
name|qpn
operator|=
name|rss_map
operator|->
name|base_qpn
operator|+
name|i
expr_stmt|;
name|err
operator|=
name|mlx4_en_config_rss_qp
argument_list|(
name|priv
argument_list|,
name|qpn
argument_list|,
operator|&
name|priv
operator|->
name|rx_ring
index|[
name|i
index|]
argument_list|,
operator|&
name|rss_map
operator|->
name|state
index|[
name|i
index|]
argument_list|,
operator|&
name|rss_map
operator|->
name|qps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|rss_err
goto|;
operator|++
name|good_qps
expr_stmt|;
block|}
comment|/* Configure RSS indirection qp */
name|err
operator|=
name|mlx4_qp_reserve_range
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|priv
operator|->
name|base_qpn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|en_err
argument_list|(
name|priv
argument_list|,
literal|"Failed to reserve range for RSS "
literal|"indirection qp\n"
argument_list|)
expr_stmt|;
goto|goto
name|rss_err
goto|;
block|}
name|err
operator|=
name|mlx4_qp_alloc
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|priv
operator|->
name|base_qpn
argument_list|,
operator|&
name|rss_map
operator|->
name|indir_qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|en_err
argument_list|(
name|priv
argument_list|,
literal|"Failed to allocate RSS indirection QP\n"
argument_list|)
expr_stmt|;
goto|goto
name|reserve_err
goto|;
block|}
name|rss_map
operator|->
name|indir_qp
operator|.
name|event
operator|=
name|mlx4_en_sqp_event
expr_stmt|;
name|mlx4_en_fill_qp_context
argument_list|(
name|priv
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|priv
operator|->
name|base_qpn
argument_list|,
name|priv
operator|->
name|rx_ring
index|[
literal|0
index|]
operator|.
name|cqn
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
name|ptr
operator|=
operator|(
operator|(
name|void
operator|*
operator|)
operator|&
name|context
operator|)
operator|+
literal|0x3c
expr_stmt|;
name|rss_context
operator|=
operator|(
expr|struct
name|mlx4_en_rss_context
operator|*
operator|)
name|ptr
expr_stmt|;
name|rss_context
operator|->
name|base_qpn
operator|=
name|cpu_to_be32
argument_list|(
name|ilog2
argument_list|(
name|priv
operator|->
name|rx_ring_num
argument_list|)
operator|<<
literal|24
operator||
operator|(
name|rss_map
operator|->
name|base_qpn
operator|)
argument_list|)
expr_stmt|;
name|rss_context
operator|->
name|default_qpn
operator|=
name|cpu_to_be32
argument_list|(
name|rss_map
operator|->
name|base_qpn
argument_list|)
expr_stmt|;
name|rss_context
operator|->
name|flags
operator|=
name|rss_mask
expr_stmt|;
name|rss_context
operator|->
name|base_qpn_udp
operator|=
name|rss_context
operator|->
name|default_qpn
expr_stmt|;
name|err
operator|=
name|mlx4_qp_to_ready
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|res
operator|.
name|mtt
argument_list|,
operator|&
name|context
argument_list|,
operator|&
name|rss_map
operator|->
name|indir_qp
argument_list|,
operator|&
name|rss_map
operator|->
name|indir_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|indir_err
goto|;
return|return
literal|0
return|;
name|indir_err
label|:
name|mlx4_qp_modify
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|NULL
argument_list|,
name|rss_map
operator|->
name|indir_state
argument_list|,
name|MLX4_QP_STATE_RST
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|rss_map
operator|->
name|indir_qp
argument_list|)
expr_stmt|;
name|mlx4_qp_remove
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|rss_map
operator|->
name|indir_qp
argument_list|)
expr_stmt|;
name|mlx4_qp_free
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|rss_map
operator|->
name|indir_qp
argument_list|)
expr_stmt|;
name|reserve_err
label|:
name|mlx4_qp_release_range
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|priv
operator|->
name|base_qpn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rss_err
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|good_qps
condition|;
name|i
operator|++
control|)
block|{
name|mlx4_qp_modify
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|NULL
argument_list|,
name|rss_map
operator|->
name|state
index|[
name|i
index|]
argument_list|,
name|MLX4_QP_STATE_RST
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|rss_map
operator|->
name|qps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mlx4_qp_remove
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|rss_map
operator|->
name|qps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mlx4_qp_free
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|rss_map
operator|->
name|qps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|mlx4_qp_release_range
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|rss_map
operator|->
name|base_qpn
argument_list|,
name|priv
operator|->
name|rx_ring_num
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|void
name|mlx4_en_release_rss_steer
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|mlx4_en_dev
modifier|*
name|mdev
init|=
name|priv
operator|->
name|mdev
decl_stmt|;
name|struct
name|mlx4_en_rss_map
modifier|*
name|rss_map
init|=
operator|&
name|priv
operator|->
name|rss_map
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mlx4_qp_modify
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|NULL
argument_list|,
name|rss_map
operator|->
name|indir_state
argument_list|,
name|MLX4_QP_STATE_RST
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|rss_map
operator|->
name|indir_qp
argument_list|)
expr_stmt|;
name|mlx4_qp_remove
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|rss_map
operator|->
name|indir_qp
argument_list|)
expr_stmt|;
name|mlx4_qp_free
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|rss_map
operator|->
name|indir_qp
argument_list|)
expr_stmt|;
name|mlx4_qp_release_range
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|priv
operator|->
name|base_qpn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|priv
operator|->
name|rx_ring_num
condition|;
name|i
operator|++
control|)
block|{
name|mlx4_qp_modify
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|NULL
argument_list|,
name|rss_map
operator|->
name|state
index|[
name|i
index|]
argument_list|,
name|MLX4_QP_STATE_RST
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|rss_map
operator|->
name|qps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mlx4_qp_remove
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|rss_map
operator|->
name|qps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mlx4_qp_free
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|rss_map
operator|->
name|qps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|mlx4_qp_release_range
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|rss_map
operator|->
name|base_qpn
argument_list|,
name|priv
operator|->
name|rx_ring_num
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

