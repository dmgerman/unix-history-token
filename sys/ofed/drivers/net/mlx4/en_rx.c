begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2007, 2014 Mellanox Technologies. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<linux/mlx4/cq.h>
end_include

begin_include
include|#
directive|include
file|<linux/slab.h>
end_include

begin_include
include|#
directive|include
file|<linux/mlx4/qp.h>
end_include

begin_include
include|#
directive|include
file|<linux/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<linux/if_vlan.h>
end_include

begin_include
include|#
directive|include
file|<linux/vmalloc.h>
end_include

begin_include
include|#
directive|include
file|<linux/mlx4/driver.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_NET_RX_BUSY_POLL
end_ifdef

begin_include
include|#
directive|include
file|<net/busy_poll.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"mlx4_en.h"
end_include

begin_function
specifier|static
name|void
name|mlx4_en_init_rx_desc
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|,
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|mlx4_en_rx_desc
modifier|*
name|rx_desc
init|=
operator|(
expr|struct
name|mlx4_en_rx_desc
operator|*
operator|)
operator|(
name|ring
operator|->
name|buf
operator|+
operator|(
name|ring
operator|->
name|stride
operator|*
name|index
operator|)
operator|)
decl_stmt|;
name|int
name|possible_frags
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Set size and memtype fields */
name|rx_desc
operator|->
name|data
index|[
literal|0
index|]
operator|.
name|byte_count
operator|=
name|cpu_to_be32
argument_list|(
name|priv
operator|->
name|rx_mb_size
operator|-
name|MLX4_NET_IP_ALIGN
argument_list|)
expr_stmt|;
name|rx_desc
operator|->
name|data
index|[
literal|0
index|]
operator|.
name|lkey
operator|=
name|cpu_to_be32
argument_list|(
name|priv
operator|->
name|mdev
operator|->
name|mr
operator|.
name|key
argument_list|)
expr_stmt|;
comment|/* 	 * If the number of used fragments does not fill up the ring 	 * stride, remaining (unused) fragments must be padded with 	 * null address/size and a special memory key: 	 */
name|possible_frags
operator|=
operator|(
name|ring
operator|->
name|stride
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_en_rx_desc
argument_list|)
operator|)
operator|/
name|DS_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|possible_frags
condition|;
name|i
operator|++
control|)
block|{
name|rx_desc
operator|->
name|data
index|[
name|i
index|]
operator|.
name|byte_count
operator|=
literal|0
expr_stmt|;
name|rx_desc
operator|->
name|data
index|[
name|i
index|]
operator|.
name|lkey
operator|=
name|cpu_to_be32
argument_list|(
name|MLX4_EN_MEMTYPE_PAD
argument_list|)
expr_stmt|;
name|rx_desc
operator|->
name|data
index|[
name|i
index|]
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_en_alloc_buf
parameter_list|(
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
parameter_list|,
name|__be64
modifier|*
name|pdma
parameter_list|,
name|struct
name|mlx4_en_rx_mbuf
modifier|*
name|mb_list
parameter_list|)
block|{
name|bus_dma_segment_t
name|segs
index|[
literal|1
index|]
decl_stmt|;
name|bus_dmamap_t
name|map
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* try to allocate a new spare mbuf */
if|if
condition|(
name|unlikely
argument_list|(
name|ring
operator|->
name|spare
operator|.
name|mbuf
operator|==
name|NULL
argument_list|)
condition|)
block|{
name|mb
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|ring
operator|->
name|rx_mb_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|mb
operator|==
name|NULL
argument_list|)
condition|)
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
comment|/* setup correct length */
name|mb
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mb
operator|->
name|m_len
operator|=
name|ring
operator|->
name|rx_mb_size
expr_stmt|;
comment|/* make sure IP header gets aligned */
name|m_adj
argument_list|(
name|mb
argument_list|,
name|MLX4_NET_IP_ALIGN
argument_list|)
expr_stmt|;
comment|/* load spare mbuf into BUSDMA */
name|err
operator|=
operator|-
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ring
operator|->
name|dma_tag
argument_list|,
name|ring
operator|->
name|spare
operator|.
name|dma_map
argument_list|,
name|mb
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|err
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|mb
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* store spare info */
name|ring
operator|->
name|spare
operator|.
name|mbuf
operator|=
name|mb
expr_stmt|;
name|ring
operator|->
name|spare
operator|.
name|paddr_be
operator|=
name|cpu_to_be64
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|dma_tag
argument_list|,
name|ring
operator|->
name|spare
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
block|}
comment|/* synchronize and unload the current mbuf, if any */
if|if
condition|(
name|likely
argument_list|(
name|mb_list
operator|->
name|mbuf
operator|!=
name|NULL
argument_list|)
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|dma_tag
argument_list|,
name|mb_list
operator|->
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|dma_tag
argument_list|,
name|mb_list
operator|->
name|dma_map
argument_list|)
expr_stmt|;
block|}
name|mb
operator|=
name|m_getjcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|ring
operator|->
name|rx_mb_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|mb
operator|==
name|NULL
argument_list|)
condition|)
goto|goto
name|use_spare
goto|;
comment|/* setup correct length */
name|mb
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mb
operator|->
name|m_len
operator|=
name|ring
operator|->
name|rx_mb_size
expr_stmt|;
comment|/* make sure IP header gets aligned */
name|m_adj
argument_list|(
name|mb
argument_list|,
name|MLX4_NET_IP_ALIGN
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|bus_dmamap_load_mbuf_sg
argument_list|(
name|ring
operator|->
name|dma_tag
argument_list|,
name|mb_list
operator|->
name|dma_map
argument_list|,
name|mb
argument_list|,
name|segs
argument_list|,
operator|&
name|nsegs
argument_list|,
name|BUS_DMA_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|err
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|mb
argument_list|)
expr_stmt|;
goto|goto
name|use_spare
goto|;
block|}
operator|*
name|pdma
operator|=
name|cpu_to_be64
argument_list|(
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|mb_list
operator|->
name|mbuf
operator|=
name|mb
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|dma_tag
argument_list|,
name|mb_list
operator|->
name|dma_map
argument_list|,
name|BUS_DMASYNC_PREREAD
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|use_spare
label|:
comment|/* swap DMA maps */
name|map
operator|=
name|mb_list
operator|->
name|dma_map
expr_stmt|;
name|mb_list
operator|->
name|dma_map
operator|=
name|ring
operator|->
name|spare
operator|.
name|dma_map
expr_stmt|;
name|ring
operator|->
name|spare
operator|.
name|dma_map
operator|=
name|map
expr_stmt|;
comment|/* swap MBUFs */
name|mb_list
operator|->
name|mbuf
operator|=
name|ring
operator|->
name|spare
operator|.
name|mbuf
expr_stmt|;
name|ring
operator|->
name|spare
operator|.
name|mbuf
operator|=
name|NULL
expr_stmt|;
comment|/* store physical address */
operator|*
name|pdma
operator|=
name|ring
operator|->
name|spare
operator|.
name|paddr_be
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_en_free_buf
parameter_list|(
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
parameter_list|,
name|struct
name|mlx4_en_rx_mbuf
modifier|*
name|mb_list
parameter_list|)
block|{
name|bus_dmamap_t
name|map
init|=
name|mb_list
operator|->
name|dma_map
decl_stmt|;
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|dma_tag
argument_list|,
name|map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|dma_tag
argument_list|,
name|map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mb_list
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|mb_list
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
comment|/* safety clearing */
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_en_prepare_rx_desc
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|,
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|mlx4_en_rx_desc
modifier|*
name|rx_desc
init|=
operator|(
expr|struct
name|mlx4_en_rx_desc
operator|*
operator|)
operator|(
name|ring
operator|->
name|buf
operator|+
operator|(
name|index
operator|*
name|ring
operator|->
name|stride
operator|)
operator|)
decl_stmt|;
name|struct
name|mlx4_en_rx_mbuf
modifier|*
name|mb_list
init|=
name|ring
operator|->
name|mbuf
operator|+
name|index
decl_stmt|;
name|mb_list
operator|->
name|mbuf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mlx4_en_alloc_buf
argument_list|(
name|ring
argument_list|,
operator|&
name|rx_desc
operator|->
name|data
index|[
literal|0
index|]
operator|.
name|addr
argument_list|,
name|mb_list
argument_list|)
condition|)
block|{
name|priv
operator|->
name|port_stats
operator|.
name|rx_alloc_failed
operator|++
expr_stmt|;
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mlx4_en_update_rx_prod_db
parameter_list|(
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
operator|*
name|ring
operator|->
name|wqres
operator|.
name|db
operator|.
name|db
operator|=
name|cpu_to_be32
argument_list|(
name|ring
operator|->
name|prod
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_en_fill_rx_buffers
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
decl_stmt|;
name|int
name|ring_ind
decl_stmt|;
name|int
name|buf_ind
decl_stmt|;
name|int
name|new_size
decl_stmt|;
name|int
name|err
decl_stmt|;
for|for
control|(
name|buf_ind
operator|=
literal|0
init|;
name|buf_ind
operator|<
name|priv
operator|->
name|prof
operator|->
name|rx_ring_size
condition|;
name|buf_ind
operator|++
control|)
block|{
for|for
control|(
name|ring_ind
operator|=
literal|0
init|;
name|ring_ind
operator|<
name|priv
operator|->
name|rx_ring_num
condition|;
name|ring_ind
operator|++
control|)
block|{
name|ring
operator|=
name|priv
operator|->
name|rx_ring
index|[
name|ring_ind
index|]
expr_stmt|;
name|err
operator|=
name|mlx4_en_prepare_rx_desc
argument_list|(
name|priv
argument_list|,
name|ring
argument_list|,
name|ring
operator|->
name|actual_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|ring
operator|->
name|actual_size
operator|==
literal|0
condition|)
block|{
name|en_err
argument_list|(
name|priv
argument_list|,
literal|"Failed to allocate "
literal|"enough rx buffers\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
else|else
block|{
name|new_size
operator|=
name|rounddown_pow_of_two
argument_list|(
name|ring
operator|->
name|actual_size
argument_list|)
expr_stmt|;
name|en_warn
argument_list|(
name|priv
argument_list|,
literal|"Only %d buffers allocated "
literal|"reducing ring size to %d\n"
argument_list|,
name|ring
operator|->
name|actual_size
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
goto|goto
name|reduce_rings
goto|;
block|}
block|}
name|ring
operator|->
name|actual_size
operator|++
expr_stmt|;
name|ring
operator|->
name|prod
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
name|reduce_rings
label|:
for|for
control|(
name|ring_ind
operator|=
literal|0
init|;
name|ring_ind
operator|<
name|priv
operator|->
name|rx_ring_num
condition|;
name|ring_ind
operator|++
control|)
block|{
name|ring
operator|=
name|priv
operator|->
name|rx_ring
index|[
name|ring_ind
index|]
expr_stmt|;
while|while
condition|(
name|ring
operator|->
name|actual_size
operator|>
name|new_size
condition|)
block|{
name|ring
operator|->
name|actual_size
operator|--
expr_stmt|;
name|ring
operator|->
name|prod
operator|--
expr_stmt|;
name|mlx4_en_free_buf
argument_list|(
name|ring
argument_list|,
name|ring
operator|->
name|mbuf
operator|+
name|ring
operator|->
name|actual_size
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_en_free_rx_buf
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|,
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|en_dbg
argument_list|(
name|DRV
argument_list|,
name|priv
argument_list|,
literal|"Freeing Rx buf - cons:%d prod:%d\n"
argument_list|,
name|ring
operator|->
name|cons
argument_list|,
name|ring
operator|->
name|prod
argument_list|)
expr_stmt|;
comment|/* Unmap and free Rx buffers */
name|BUG_ON
argument_list|(
call|(
name|u32
call|)
argument_list|(
name|ring
operator|->
name|prod
operator|-
name|ring
operator|->
name|cons
argument_list|)
operator|>
name|ring
operator|->
name|actual_size
argument_list|)
expr_stmt|;
while|while
condition|(
name|ring
operator|->
name|cons
operator|!=
name|ring
operator|->
name|prod
condition|)
block|{
name|index
operator|=
name|ring
operator|->
name|cons
operator|&
name|ring
operator|->
name|size_mask
expr_stmt|;
name|en_dbg
argument_list|(
name|DRV
argument_list|,
name|priv
argument_list|,
literal|"Processing descriptor:%d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|mlx4_en_free_buf
argument_list|(
name|ring
argument_list|,
name|ring
operator|->
name|mbuf
operator|+
name|index
argument_list|)
expr_stmt|;
operator|++
name|ring
operator|->
name|cons
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|mlx4_en_calc_rx_buf
parameter_list|(
name|struct
name|net_device
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_en_priv
modifier|*
name|priv
init|=
name|netdev_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|eff_mtu
init|=
name|dev
operator|->
name|if_mtu
operator|+
name|ETH_HLEN
operator|+
name|VLAN_HLEN
operator|+
name|ETH_FCS_LEN
operator|+
name|MLX4_NET_IP_ALIGN
decl_stmt|;
if|if
condition|(
name|eff_mtu
operator|>
name|MJUM16BYTES
condition|)
block|{
name|en_err
argument_list|(
name|priv
argument_list|,
literal|"MTU(%d) is too big\n"
argument_list|,
operator|(
name|int
operator|)
name|dev
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
name|eff_mtu
operator|=
name|MJUM16BYTES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eff_mtu
operator|>
name|MJUM9BYTES
condition|)
block|{
name|eff_mtu
operator|=
name|MJUM16BYTES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eff_mtu
operator|>
name|MJUMPAGESIZE
condition|)
block|{
name|eff_mtu
operator|=
name|MJUM9BYTES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eff_mtu
operator|>
name|MCLBYTES
condition|)
block|{
name|eff_mtu
operator|=
name|MJUMPAGESIZE
expr_stmt|;
block|}
else|else
block|{
name|eff_mtu
operator|=
name|MCLBYTES
expr_stmt|;
block|}
name|priv
operator|->
name|rx_mb_size
operator|=
name|eff_mtu
expr_stmt|;
name|en_dbg
argument_list|(
name|DRV
argument_list|,
name|priv
argument_list|,
literal|"Effective RX MTU: %d bytes\n"
argument_list|,
name|eff_mtu
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mlx4_en_create_rx_ring
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|,
name|struct
name|mlx4_en_rx_ring
modifier|*
modifier|*
name|pring
parameter_list|,
name|u32
name|size
parameter_list|,
name|int
name|node
parameter_list|)
block|{
name|struct
name|mlx4_en_dev
modifier|*
name|mdev
init|=
name|priv
operator|->
name|mdev
decl_stmt|;
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|uint32_t
name|x
decl_stmt|;
name|ring
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_en_rx_ring
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ring
condition|)
block|{
name|en_err
argument_list|(
name|priv
argument_list|,
literal|"Failed to allocate RX ring structure\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
comment|/* Create DMA descriptor TAG */
if|if
condition|(
operator|(
name|err
operator|=
operator|-
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|mdev
operator|->
name|pdev
operator|->
name|dev
operator|.
name|bsddev
argument_list|)
argument_list|,
literal|1
argument_list|,
comment|/* any alignment */
literal|0
argument_list|,
comment|/* no boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MJUM16BYTES
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MJUM16BYTES
argument_list|,
comment|/* maxsegsize */
literal|0
argument_list|,
comment|/* flags */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* lockfunc, lockfuncarg */
operator|&
name|ring
operator|->
name|dma_tag
argument_list|)
operator|)
condition|)
block|{
name|en_err
argument_list|(
name|priv
argument_list|,
literal|"Failed to create DMA tag\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_ring
goto|;
block|}
name|ring
operator|->
name|prod
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|cons
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|ring
operator|->
name|size_mask
operator|=
name|size
operator|-
literal|1
expr_stmt|;
name|ring
operator|->
name|stride
operator|=
name|roundup_pow_of_two
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_en_rx_desc
argument_list|)
operator|+
name|DS_SIZE
argument_list|)
expr_stmt|;
name|ring
operator|->
name|log_stride
operator|=
name|ffs
argument_list|(
name|ring
operator|->
name|stride
argument_list|)
operator|-
literal|1
expr_stmt|;
name|ring
operator|->
name|buf_size
operator|=
name|ring
operator|->
name|size
operator|*
name|ring
operator|->
name|stride
operator|+
name|TXBB_SIZE
expr_stmt|;
name|tmp
operator|=
name|size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_en_rx_mbuf
argument_list|)
expr_stmt|;
name|ring
operator|->
name|mbuf
operator|=
name|kzalloc
argument_list|(
name|tmp
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|mbuf
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_dma_tag
goto|;
block|}
name|err
operator|=
operator|-
name|bus_dmamap_create
argument_list|(
name|ring
operator|->
name|dma_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|ring
operator|->
name|spare
operator|.
name|dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|err_info
goto|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|size
condition|;
name|x
operator|++
control|)
block|{
name|err
operator|=
operator|-
name|bus_dmamap_create
argument_list|(
name|ring
operator|->
name|dma_tag
argument_list|,
literal|0
argument_list|,
operator|&
name|ring
operator|->
name|mbuf
index|[
name|x
index|]
operator|.
name|dma_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|x
operator|--
condition|)
name|bus_dmamap_destroy
argument_list|(
name|ring
operator|->
name|dma_tag
argument_list|,
name|ring
operator|->
name|mbuf
index|[
name|x
index|]
operator|.
name|dma_map
argument_list|)
expr_stmt|;
goto|goto
name|err_info
goto|;
block|}
block|}
name|en_dbg
argument_list|(
name|DRV
argument_list|,
name|priv
argument_list|,
literal|"Allocated MBUF ring at addr:%p size:%d\n"
argument_list|,
name|ring
operator|->
name|mbuf
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_alloc_hwq_res
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|ring
operator|->
name|wqres
argument_list|,
name|ring
operator|->
name|buf_size
argument_list|,
literal|2
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_dma_map
goto|;
name|err
operator|=
name|mlx4_en_map_buffer
argument_list|(
operator|&
name|ring
operator|->
name|wqres
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|en_err
argument_list|(
name|priv
argument_list|,
literal|"Failed to map RX buffer\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_hwq
goto|;
block|}
name|ring
operator|->
name|buf
operator|=
name|ring
operator|->
name|wqres
operator|.
name|buf
operator|.
name|direct
operator|.
name|buf
expr_stmt|;
operator|*
name|pring
operator|=
name|ring
expr_stmt|;
return|return
literal|0
return|;
name|err_hwq
label|:
name|mlx4_free_hwq_res
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|ring
operator|->
name|wqres
argument_list|,
name|ring
operator|->
name|buf_size
argument_list|)
expr_stmt|;
name|err_dma_map
label|:
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|size
condition|;
name|x
operator|++
control|)
block|{
name|bus_dmamap_destroy
argument_list|(
name|ring
operator|->
name|dma_tag
argument_list|,
name|ring
operator|->
name|mbuf
index|[
name|x
index|]
operator|.
name|dma_map
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_destroy
argument_list|(
name|ring
operator|->
name|dma_tag
argument_list|,
name|ring
operator|->
name|spare
operator|.
name|dma_map
argument_list|)
expr_stmt|;
name|err_info
label|:
name|vfree
argument_list|(
name|ring
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|err_dma_tag
label|:
name|bus_dma_tag_destroy
argument_list|(
name|ring
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
name|err_ring
label|:
name|kfree
argument_list|(
name|ring
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_en_activate_rx_rings
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ring_ind
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|stride
init|=
name|roundup_pow_of_two
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_en_rx_desc
argument_list|)
operator|+
name|DS_SIZE
argument_list|)
decl_stmt|;
for|for
control|(
name|ring_ind
operator|=
literal|0
init|;
name|ring_ind
operator|<
name|priv
operator|->
name|rx_ring_num
condition|;
name|ring_ind
operator|++
control|)
block|{
name|ring
operator|=
name|priv
operator|->
name|rx_ring
index|[
name|ring_ind
index|]
expr_stmt|;
name|ring
operator|->
name|prod
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|cons
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|actual_size
operator|=
literal|0
expr_stmt|;
name|ring
operator|->
name|cqn
operator|=
name|priv
operator|->
name|rx_cq
index|[
name|ring_ind
index|]
operator|->
name|mcq
operator|.
name|cqn
expr_stmt|;
name|ring
operator|->
name|rx_mb_size
operator|=
name|priv
operator|->
name|rx_mb_size
expr_stmt|;
name|ring
operator|->
name|stride
operator|=
name|stride
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|stride
operator|<=
name|TXBB_SIZE
condition|)
block|{
comment|/* Stamp first unused send wqe */
name|__be32
modifier|*
name|ptr
init|=
operator|(
name|__be32
operator|*
operator|)
name|ring
operator|->
name|buf
decl_stmt|;
name|__be32
name|stamp
init|=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
name|STAMP_SHIFT
argument_list|)
decl_stmt|;
operator|*
name|ptr
operator|=
name|stamp
expr_stmt|;
comment|/* Move pointer to start of rx section */
name|ring
operator|->
name|buf
operator|+=
name|TXBB_SIZE
expr_stmt|;
block|}
name|ring
operator|->
name|log_stride
operator|=
name|ffs
argument_list|(
name|ring
operator|->
name|stride
argument_list|)
operator|-
literal|1
expr_stmt|;
name|ring
operator|->
name|buf_size
operator|=
name|ring
operator|->
name|size
operator|*
name|ring
operator|->
name|stride
expr_stmt|;
name|memset
argument_list|(
name|ring
operator|->
name|buf
argument_list|,
literal|0
argument_list|,
name|ring
operator|->
name|buf_size
argument_list|)
expr_stmt|;
name|mlx4_en_update_rx_prod_db
argument_list|(
name|ring
argument_list|)
expr_stmt|;
comment|/* Initialize all descriptors */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ring
operator|->
name|size
condition|;
name|i
operator|++
control|)
name|mlx4_en_init_rx_desc
argument_list|(
name|priv
argument_list|,
name|ring
argument_list|,
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
comment|/* Configure lro mngr */
if|if
condition|(
name|priv
operator|->
name|dev
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
condition|)
block|{
if|if
condition|(
name|tcp_lro_init
argument_list|(
operator|&
name|ring
operator|->
name|lro
argument_list|)
condition|)
name|priv
operator|->
name|dev
operator|->
name|if_capenable
operator|&=
operator|~
name|IFCAP_LRO
expr_stmt|;
else|else
name|ring
operator|->
name|lro
operator|.
name|ifp
operator|=
name|priv
operator|->
name|dev
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|err
operator|=
name|mlx4_en_fill_rx_buffers
argument_list|(
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_buffers
goto|;
for|for
control|(
name|ring_ind
operator|=
literal|0
init|;
name|ring_ind
operator|<
name|priv
operator|->
name|rx_ring_num
condition|;
name|ring_ind
operator|++
control|)
block|{
name|ring
operator|=
name|priv
operator|->
name|rx_ring
index|[
name|ring_ind
index|]
expr_stmt|;
name|ring
operator|->
name|size_mask
operator|=
name|ring
operator|->
name|actual_size
operator|-
literal|1
expr_stmt|;
name|mlx4_en_update_rx_prod_db
argument_list|(
name|ring
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|err_buffers
label|:
for|for
control|(
name|ring_ind
operator|=
literal|0
init|;
name|ring_ind
operator|<
name|priv
operator|->
name|rx_ring_num
condition|;
name|ring_ind
operator|++
control|)
name|mlx4_en_free_rx_buf
argument_list|(
name|priv
argument_list|,
name|priv
operator|->
name|rx_ring
index|[
name|ring_ind
index|]
argument_list|)
expr_stmt|;
name|ring_ind
operator|=
name|priv
operator|->
name|rx_ring_num
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|ring_ind
operator|>=
literal|0
condition|)
block|{
name|ring
operator|=
name|priv
operator|->
name|rx_ring
index|[
name|ring_ind
index|]
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|stride
operator|<=
name|TXBB_SIZE
condition|)
name|ring
operator|->
name|buf
operator|-=
name|TXBB_SIZE
expr_stmt|;
name|ring_ind
operator|--
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
name|void
name|mlx4_en_destroy_rx_ring
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|,
name|struct
name|mlx4_en_rx_ring
modifier|*
modifier|*
name|pring
parameter_list|,
name|u32
name|size
parameter_list|,
name|u16
name|stride
parameter_list|)
block|{
name|struct
name|mlx4_en_dev
modifier|*
name|mdev
init|=
name|priv
operator|->
name|mdev
decl_stmt|;
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
init|=
operator|*
name|pring
decl_stmt|;
name|uint32_t
name|x
decl_stmt|;
name|mlx4_en_unmap_buffer
argument_list|(
operator|&
name|ring
operator|->
name|wqres
operator|.
name|buf
argument_list|)
expr_stmt|;
name|mlx4_free_hwq_res
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|ring
operator|->
name|wqres
argument_list|,
name|size
operator|*
name|stride
operator|+
name|TXBB_SIZE
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|!=
name|size
condition|;
name|x
operator|++
control|)
name|bus_dmamap_destroy
argument_list|(
name|ring
operator|->
name|dma_tag
argument_list|,
name|ring
operator|->
name|mbuf
index|[
name|x
index|]
operator|.
name|dma_map
argument_list|)
expr_stmt|;
comment|/* free spare mbuf, if any */
if|if
condition|(
name|ring
operator|->
name|spare
operator|.
name|mbuf
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|ring
operator|->
name|dma_tag
argument_list|,
name|ring
operator|->
name|spare
operator|.
name|dma_map
argument_list|,
name|BUS_DMASYNC_POSTREAD
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|ring
operator|->
name|dma_tag
argument_list|,
name|ring
operator|->
name|spare
operator|.
name|dma_map
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|ring
operator|->
name|spare
operator|.
name|mbuf
argument_list|)
expr_stmt|;
block|}
name|bus_dmamap_destroy
argument_list|(
name|ring
operator|->
name|dma_tag
argument_list|,
name|ring
operator|->
name|spare
operator|.
name|dma_map
argument_list|)
expr_stmt|;
name|vfree
argument_list|(
name|ring
operator|->
name|mbuf
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|ring
operator|->
name|dma_tag
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|ring
argument_list|)
expr_stmt|;
operator|*
name|pring
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|CONFIG_RFS_ACCEL
name|mlx4_en_cleanup_filters
argument_list|(
name|priv
argument_list|,
name|ring
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|mlx4_en_deactivate_rx_ring
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|,
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET
name|tcp_lro_free
argument_list|(
operator|&
name|ring
operator|->
name|lro
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mlx4_en_free_rx_buf
argument_list|(
name|priv
argument_list|,
name|ring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ring
operator|->
name|stride
operator|<=
name|TXBB_SIZE
condition|)
name|ring
operator|->
name|buf
operator|-=
name|TXBB_SIZE
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|validate_loopback
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mb
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|offset
init|=
name|ETHER_HDR_LEN
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX4_LOOPBACK_TEST_PAYLOAD
condition|;
name|i
operator|++
operator|,
name|offset
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|(
name|mb
operator|->
name|m_data
operator|+
name|offset
operator|)
operator|!=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|i
operator|&
literal|0xff
argument_list|)
condition|)
goto|goto
name|out_loopback
goto|;
block|}
comment|/* Loopback found */
name|priv
operator|->
name|loopback_ok
operator|=
literal|1
expr_stmt|;
name|out_loopback
label|:
name|m_freem
argument_list|(
name|mb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|invalid_cqe
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|,
name|struct
name|mlx4_cqe
modifier|*
name|cqe
parameter_list|)
block|{
comment|/* Drop packet on bad receive or bad checksum */
if|if
condition|(
name|unlikely
argument_list|(
operator|(
name|cqe
operator|->
name|owner_sr_opcode
operator|&
name|MLX4_CQE_OPCODE_MASK
operator|)
operator|==
name|MLX4_CQE_OPCODE_ERROR
argument_list|)
condition|)
block|{
name|en_err
argument_list|(
name|priv
argument_list|,
literal|"CQE completed in error - vendor syndrom:%d syndrom:%d\n"
argument_list|,
operator|(
operator|(
expr|struct
name|mlx4_err_cqe
operator|*
operator|)
name|cqe
operator|)
operator|->
name|vendor_err_syndrome
argument_list|,
operator|(
operator|(
expr|struct
name|mlx4_err_cqe
operator|*
operator|)
name|cqe
operator|)
operator|->
name|syndrome
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|cqe
operator|->
name|badfcs_enc
operator|&
name|MLX4_CQE_BAD_FCS
argument_list|)
condition|)
block|{
name|en_dbg
argument_list|(
name|RX_ERR
argument_list|,
name|priv
argument_list|,
literal|"Accepted frame with bad FCS\n"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|mlx4_en_rx_mb
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|,
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
parameter_list|,
name|struct
name|mlx4_en_rx_desc
modifier|*
name|rx_desc
parameter_list|,
name|struct
name|mlx4_en_rx_mbuf
modifier|*
name|mb_list
parameter_list|,
name|int
name|length
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
comment|/* get mbuf */
name|mb
operator|=
name|mb_list
operator|->
name|mbuf
expr_stmt|;
comment|/* collect used fragment while atomically replacing it */
if|if
condition|(
name|mlx4_en_alloc_buf
argument_list|(
name|ring
argument_list|,
operator|&
name|rx_desc
operator|->
name|data
index|[
literal|0
index|]
operator|.
name|addr
argument_list|,
name|mb_list
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* range check hardware computed value */
if|if
condition|(
name|unlikely
argument_list|(
name|length
operator|>
name|mb
operator|->
name|m_len
argument_list|)
condition|)
name|length
operator|=
name|mb
operator|->
name|m_len
expr_stmt|;
comment|/* update total packet length in packet header */
name|mb
operator|->
name|m_len
operator|=
name|mb
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|mb
operator|)
return|;
block|}
end_function

begin_comment
comment|/* For cpu arch with cache line of 64B the performance is better when cqe size==64B  * To enlarge cqe size from 32B to 64B --> 32B of garbage (i.e. 0xccccccc)  * was added in the beginning of each cqe (the real data is in the corresponding 32B).  * The following calc ensures that when factor==1, it means we are alligned to 64B  * and we get the real cqe data*/
end_comment

begin_define
define|#
directive|define
name|CQE_FACTOR_INDEX
parameter_list|(
name|index
parameter_list|,
name|factor
parameter_list|)
value|((index<< factor) + factor)
end_define

begin_function
name|int
name|mlx4_en_process_rx_cq
parameter_list|(
name|struct
name|net_device
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_en_cq
modifier|*
name|cq
parameter_list|,
name|int
name|budget
parameter_list|)
block|{
name|struct
name|mlx4_en_priv
modifier|*
name|priv
init|=
name|netdev_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_cqe
modifier|*
name|cqe
decl_stmt|;
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
init|=
name|priv
operator|->
name|rx_ring
index|[
name|cq
operator|->
name|ring
index|]
decl_stmt|;
name|struct
name|mlx4_en_rx_mbuf
modifier|*
name|mb_list
decl_stmt|;
name|struct
name|mlx4_en_rx_desc
modifier|*
name|rx_desc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|struct
name|mlx4_cq
modifier|*
name|mcq
init|=
operator|&
name|cq
operator|->
name|mcq
decl_stmt|;
name|struct
name|mlx4_cqe
modifier|*
name|buf
init|=
name|cq
operator|->
name|buf
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|lro_entry
modifier|*
name|queued
decl_stmt|;
endif|#
directive|endif
name|int
name|index
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|int
name|polled
init|=
literal|0
decl_stmt|;
name|u32
name|cons_index
init|=
name|mcq
operator|->
name|cons_index
decl_stmt|;
name|u32
name|size_mask
init|=
name|ring
operator|->
name|size_mask
decl_stmt|;
name|int
name|size
init|=
name|cq
operator|->
name|size
decl_stmt|;
name|int
name|factor
init|=
name|priv
operator|->
name|cqe_factor
decl_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|port_up
condition|)
return|return
literal|0
return|;
comment|/* We assume a 1:1 mapping between CQEs and Rx descriptors, so Rx 	 * descriptor offset can be deducted from the CQE index instead of 	 * reading 'cqe->index' */
name|index
operator|=
name|cons_index
operator|&
name|size_mask
expr_stmt|;
name|cqe
operator|=
operator|&
name|buf
index|[
name|CQE_FACTOR_INDEX
argument_list|(
name|index
argument_list|,
name|factor
argument_list|)
index|]
expr_stmt|;
comment|/* Process all completed CQEs */
while|while
condition|(
name|XNOR
argument_list|(
name|cqe
operator|->
name|owner_sr_opcode
operator|&
name|MLX4_CQE_OWNER_MASK
argument_list|,
name|cons_index
operator|&
name|size
argument_list|)
condition|)
block|{
name|mb_list
operator|=
name|ring
operator|->
name|mbuf
operator|+
name|index
expr_stmt|;
name|rx_desc
operator|=
operator|(
expr|struct
name|mlx4_en_rx_desc
operator|*
operator|)
operator|(
name|ring
operator|->
name|buf
operator|+
operator|(
name|index
operator|<<
name|ring
operator|->
name|log_stride
operator|)
operator|)
expr_stmt|;
comment|/* 		 * make sure we read the CQE after we read the ownership bit 		 */
name|rmb
argument_list|()
expr_stmt|;
if|if
condition|(
name|invalid_cqe
argument_list|(
name|priv
argument_list|,
name|cqe
argument_list|)
condition|)
block|{
goto|goto
name|next
goto|;
block|}
comment|/* 		 * Packet is OK - process it. 		 */
name|length
operator|=
name|be32_to_cpu
argument_list|(
name|cqe
operator|->
name|byte_cnt
argument_list|)
expr_stmt|;
name|length
operator|-=
name|ring
operator|->
name|fcs_del
expr_stmt|;
name|mb
operator|=
name|mlx4_en_rx_mb
argument_list|(
name|priv
argument_list|,
name|ring
argument_list|,
name|rx_desc
argument_list|,
name|mb_list
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|mb
argument_list|)
condition|)
block|{
name|ring
operator|->
name|errors
operator|++
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|ring
operator|->
name|bytes
operator|+=
name|length
expr_stmt|;
name|ring
operator|->
name|packets
operator|++
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|priv
operator|->
name|validate_loopback
argument_list|)
condition|)
block|{
name|validate_loopback
argument_list|(
name|priv
argument_list|,
name|mb
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
comment|/* forward Toeplitz compatible hash value */
name|mb
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|be32_to_cpu
argument_list|(
name|cqe
operator|->
name|immed_rss_invalid
argument_list|)
expr_stmt|;
name|M_HASHTYPE_SET
argument_list|(
name|mb
argument_list|,
name|M_HASHTYPE_OPAQUE
argument_list|)
expr_stmt|;
name|mb
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|dev
expr_stmt|;
if|if
condition|(
name|be32_to_cpu
argument_list|(
name|cqe
operator|->
name|vlan_my_qpn
argument_list|)
operator|&
name|MLX4_CQE_VLAN_PRESENT_MASK
condition|)
block|{
name|mb
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
operator|=
name|be16_to_cpu
argument_list|(
name|cqe
operator|->
name|sl_vid
argument_list|)
expr_stmt|;
name|mb
operator|->
name|m_flags
operator||=
name|M_VLANTAG
expr_stmt|;
block|}
if|if
condition|(
name|likely
argument_list|(
name|dev
operator|->
name|if_capenable
operator|&
operator|(
name|IFCAP_RXCSUM
operator||
name|IFCAP_RXCSUM_IPV6
operator|)
argument_list|)
operator|&&
operator|(
name|cqe
operator|->
name|status
operator|&
name|cpu_to_be16
argument_list|(
name|MLX4_CQE_STATUS_IPOK
argument_list|)
operator|)
operator|&&
operator|(
name|cqe
operator|->
name|checksum
operator|==
name|cpu_to_be16
argument_list|(
literal|0xffff
argument_list|)
operator|)
condition|)
block|{
name|priv
operator|->
name|port_stats
operator|.
name|rx_chksum_good
operator|++
expr_stmt|;
name|mb
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_IP_CHECKED
operator||
name|CSUM_IP_VALID
operator||
name|CSUM_DATA_VALID
operator||
name|CSUM_PSEUDO_HDR
expr_stmt|;
name|mb
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|htons
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* This packet is eligible for LRO if it is: 			 * - DIX Ethernet (type interpretation) 			 * - TCP/IP (v4) 			 * - without IP options 			 * - not an IP fragment 			 */
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|mlx4_en_can_lro
argument_list|(
name|cqe
operator|->
name|status
argument_list|)
operator|&&
operator|(
name|dev
operator|->
name|if_capenable
operator|&
name|IFCAP_LRO
operator|)
condition|)
block|{
if|if
condition|(
name|ring
operator|->
name|lro
operator|.
name|lro_cnt
operator|!=
literal|0
operator|&&
name|tcp_lro_rx
argument_list|(
operator|&
name|ring
operator|->
name|lro
argument_list|,
name|mb
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|next
goto|;
block|}
endif|#
directive|endif
comment|/* LRO not possible, complete processing here */
name|INC_PERF_COUNTER
argument_list|(
name|priv
operator|->
name|pstats
operator|.
name|lro_misses
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mb
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|port_stats
operator|.
name|rx_chksum_none
operator|++
expr_stmt|;
block|}
comment|/* Push it up the stack */
name|dev
operator|->
name|if_input
argument_list|(
name|dev
argument_list|,
name|mb
argument_list|)
expr_stmt|;
name|next
label|:
operator|++
name|cons_index
expr_stmt|;
name|index
operator|=
name|cons_index
operator|&
name|size_mask
expr_stmt|;
name|cqe
operator|=
operator|&
name|buf
index|[
name|CQE_FACTOR_INDEX
argument_list|(
name|index
argument_list|,
name|factor
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|++
name|polled
operator|==
name|budget
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* Flush all pending IP reassembly sessions */
name|out
label|:
ifdef|#
directive|ifdef
name|INET
while|while
condition|(
operator|(
name|queued
operator|=
name|SLIST_FIRST
argument_list|(
operator|&
name|ring
operator|->
name|lro
operator|.
name|lro_active
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SLIST_REMOVE_HEAD
argument_list|(
operator|&
name|ring
operator|->
name|lro
operator|.
name|lro_active
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|tcp_lro_flush
argument_list|(
operator|&
name|ring
operator|->
name|lro
argument_list|,
name|queued
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|AVG_PERF_COUNTER
argument_list|(
name|priv
operator|->
name|pstats
operator|.
name|rx_coal_avg
argument_list|,
name|polled
argument_list|)
expr_stmt|;
name|mcq
operator|->
name|cons_index
operator|=
name|cons_index
expr_stmt|;
name|mlx4_cq_set_ci
argument_list|(
name|mcq
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
comment|/* ensure HW sees CQ consumer before we post new buffers */
name|ring
operator|->
name|cons
operator|=
name|mcq
operator|->
name|cons_index
expr_stmt|;
name|ring
operator|->
name|prod
operator|+=
name|polled
expr_stmt|;
comment|/* Polled descriptors were realocated in place */
name|mlx4_en_update_rx_prod_db
argument_list|(
name|ring
argument_list|)
expr_stmt|;
return|return
name|polled
return|;
block|}
end_function

begin_comment
comment|/* Rx CQ polling - called by NAPI */
end_comment

begin_function
specifier|static
name|int
name|mlx4_en_poll_rx_cq
parameter_list|(
name|struct
name|mlx4_en_cq
modifier|*
name|cq
parameter_list|,
name|int
name|budget
parameter_list|)
block|{
name|struct
name|net_device
modifier|*
name|dev
init|=
name|cq
operator|->
name|dev
decl_stmt|;
name|int
name|done
decl_stmt|;
name|done
operator|=
name|mlx4_en_process_rx_cq
argument_list|(
name|dev
argument_list|,
name|cq
argument_list|,
name|budget
argument_list|)
expr_stmt|;
name|cq
operator|->
name|tot_rx
operator|+=
name|done
expr_stmt|;
return|return
name|done
return|;
block|}
end_function

begin_function
name|void
name|mlx4_en_rx_irq
parameter_list|(
name|struct
name|mlx4_cq
modifier|*
name|mcq
parameter_list|)
block|{
name|struct
name|mlx4_en_cq
modifier|*
name|cq
init|=
name|container_of
argument_list|(
name|mcq
argument_list|,
expr|struct
name|mlx4_en_cq
argument_list|,
name|mcq
argument_list|)
decl_stmt|;
name|struct
name|mlx4_en_priv
modifier|*
name|priv
init|=
name|netdev_priv
argument_list|(
name|cq
operator|->
name|dev
argument_list|)
decl_stmt|;
name|int
name|done
decl_stmt|;
comment|// Shoot one within the irq context
comment|// Because there is no NAPI in freeBSD
name|done
operator|=
name|mlx4_en_poll_rx_cq
argument_list|(
name|cq
argument_list|,
name|MLX4_EN_RX_BUDGET
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|port_up
operator|&&
operator|(
name|done
operator|==
name|MLX4_EN_RX_BUDGET
operator|)
condition|)
block|{
name|cq
operator|->
name|curr_poll_rx_cpu_id
operator|=
name|curcpu
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|cq
operator|->
name|tq
argument_list|,
operator|&
name|cq
operator|->
name|cq_task
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mlx4_en_arm_cq
argument_list|(
name|priv
argument_list|,
name|cq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|mlx4_en_rx_que
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|mlx4_en_cq
modifier|*
name|cq
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|cq
operator|=
name|context
expr_stmt|;
name|td
operator|=
name|curthread
expr_stmt|;
name|thread_lock
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|sched_bind
argument_list|(
name|td
argument_list|,
name|cq
operator|->
name|curr_poll_rx_cpu_id
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|td
argument_list|)
expr_stmt|;
while|while
condition|(
name|mlx4_en_poll_rx_cq
argument_list|(
name|cq
argument_list|,
name|MLX4_EN_RX_BUDGET
argument_list|)
operator|==
name|MLX4_EN_RX_BUDGET
condition|)
empty_stmt|;
name|mlx4_en_arm_cq
argument_list|(
name|cq
operator|->
name|dev
operator|->
name|if_softc
argument_list|,
name|cq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* RSS related functions */
end_comment

begin_function
specifier|static
name|int
name|mlx4_en_config_rss_qp
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|,
name|int
name|qpn
parameter_list|,
name|struct
name|mlx4_en_rx_ring
modifier|*
name|ring
parameter_list|,
name|enum
name|mlx4_qp_state
modifier|*
name|state
parameter_list|,
name|struct
name|mlx4_qp
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|mlx4_en_dev
modifier|*
name|mdev
init|=
name|priv
operator|->
name|mdev
decl_stmt|;
name|struct
name|mlx4_qp_context
modifier|*
name|context
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|context
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|context
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
block|{
name|en_err
argument_list|(
name|priv
argument_list|,
literal|"Failed to allocate qp context\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|err
operator|=
name|mlx4_qp_alloc
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|qpn
argument_list|,
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|en_err
argument_list|(
name|priv
argument_list|,
literal|"Failed to allocate qp #%x\n"
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|qp
operator|->
name|event
operator|=
name|mlx4_en_sqp_event
expr_stmt|;
name|memset
argument_list|(
name|context
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|context
argument_list|)
expr_stmt|;
name|mlx4_en_fill_qp_context
argument_list|(
name|priv
argument_list|,
name|ring
operator|->
name|actual_size
argument_list|,
name|ring
operator|->
name|stride
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|qpn
argument_list|,
name|ring
operator|->
name|cqn
argument_list|,
operator|-
literal|1
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|context
operator|->
name|db_rec_addr
operator|=
name|cpu_to_be64
argument_list|(
name|ring
operator|->
name|wqres
operator|.
name|db
operator|.
name|dma
argument_list|)
expr_stmt|;
comment|/* Cancel FCS removal if FW allows */
if|if
condition|(
name|mdev
operator|->
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_FCS_KEEP
condition|)
block|{
name|context
operator|->
name|param3
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|29
argument_list|)
expr_stmt|;
name|ring
operator|->
name|fcs_del
operator|=
name|ETH_FCS_LEN
expr_stmt|;
block|}
else|else
name|ring
operator|->
name|fcs_del
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|mlx4_qp_to_ready
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|ring
operator|->
name|wqres
operator|.
name|mtt
argument_list|,
name|context
argument_list|,
name|qp
argument_list|,
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_qp_remove
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|mlx4_qp_free
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|qp
argument_list|)
expr_stmt|;
block|}
name|mlx4_en_update_rx_prod_db
argument_list|(
name|ring
argument_list|)
expr_stmt|;
name|out
label|:
name|kfree
argument_list|(
name|context
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_en_create_drop_qp
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|u32
name|qpn
decl_stmt|;
name|err
operator|=
name|mlx4_qp_reserve_range
argument_list|(
name|priv
operator|->
name|mdev
operator|->
name|dev
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|qpn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|en_err
argument_list|(
name|priv
argument_list|,
literal|"Failed reserving drop qpn\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|mlx4_qp_alloc
argument_list|(
name|priv
operator|->
name|mdev
operator|->
name|dev
argument_list|,
name|qpn
argument_list|,
operator|&
name|priv
operator|->
name|drop_qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|en_err
argument_list|(
name|priv
argument_list|,
literal|"Failed allocating drop qp\n"
argument_list|)
expr_stmt|;
name|mlx4_qp_release_range
argument_list|(
name|priv
operator|->
name|mdev
operator|->
name|dev
argument_list|,
name|qpn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|mlx4_en_destroy_drop_qp
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|)
block|{
name|u32
name|qpn
decl_stmt|;
name|qpn
operator|=
name|priv
operator|->
name|drop_qp
operator|.
name|qpn
expr_stmt|;
name|mlx4_qp_remove
argument_list|(
name|priv
operator|->
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|drop_qp
argument_list|)
expr_stmt|;
name|mlx4_qp_free
argument_list|(
name|priv
operator|->
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|drop_qp
argument_list|)
expr_stmt|;
name|mlx4_qp_release_range
argument_list|(
name|priv
operator|->
name|mdev
operator|->
name|dev
argument_list|,
name|qpn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate rx qp's and configure them according to rss map */
end_comment

begin_function
name|int
name|mlx4_en_config_rss_steer
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|mlx4_en_dev
modifier|*
name|mdev
init|=
name|priv
operator|->
name|mdev
decl_stmt|;
name|struct
name|mlx4_en_rss_map
modifier|*
name|rss_map
init|=
operator|&
name|priv
operator|->
name|rss_map
decl_stmt|;
name|struct
name|mlx4_qp_context
name|context
decl_stmt|;
name|struct
name|mlx4_rss_context
modifier|*
name|rss_context
decl_stmt|;
name|int
name|rss_rings
decl_stmt|;
name|void
modifier|*
name|ptr
decl_stmt|;
name|u8
name|rss_mask
init|=
operator|(
name|MLX4_RSS_IPV4
operator||
name|MLX4_RSS_TCP_IPV4
operator||
name|MLX4_RSS_IPV6
operator||
name|MLX4_RSS_TCP_IPV6
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|good_qps
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|u32
name|rsskey
index|[
literal|10
index|]
init|=
block|{
literal|0xD181C62C
block|,
literal|0xF7F4DB5B
block|,
literal|0x1983A2FC
block|,
literal|0x943E1ADB
block|,
literal|0xD9389E6B
block|,
literal|0xD1039C2C
block|,
literal|0xA74499AD
block|,
literal|0x593D56D9
block|,
literal|0xF3253C06
block|,
literal|0x2ADC1FFC
block|}
decl_stmt|;
name|en_dbg
argument_list|(
name|DRV
argument_list|,
name|priv
argument_list|,
literal|"Configuring rss steering\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_qp_reserve_range
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|priv
operator|->
name|rx_ring_num
argument_list|,
name|priv
operator|->
name|rx_ring_num
argument_list|,
operator|&
name|rss_map
operator|->
name|base_qpn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|en_err
argument_list|(
name|priv
argument_list|,
literal|"Failed reserving %d qps\n"
argument_list|,
name|priv
operator|->
name|rx_ring_num
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|priv
operator|->
name|rx_ring_num
condition|;
name|i
operator|++
control|)
block|{
name|priv
operator|->
name|rx_ring
index|[
name|i
index|]
operator|->
name|qpn
operator|=
name|rss_map
operator|->
name|base_qpn
operator|+
name|i
expr_stmt|;
name|err
operator|=
name|mlx4_en_config_rss_qp
argument_list|(
name|priv
argument_list|,
name|priv
operator|->
name|rx_ring
index|[
name|i
index|]
operator|->
name|qpn
argument_list|,
name|priv
operator|->
name|rx_ring
index|[
name|i
index|]
argument_list|,
operator|&
name|rss_map
operator|->
name|state
index|[
name|i
index|]
argument_list|,
operator|&
name|rss_map
operator|->
name|qps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|rss_err
goto|;
operator|++
name|good_qps
expr_stmt|;
block|}
comment|/* Configure RSS indirection qp */
name|err
operator|=
name|mlx4_qp_alloc
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|priv
operator|->
name|base_qpn
argument_list|,
operator|&
name|rss_map
operator|->
name|indir_qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|en_err
argument_list|(
name|priv
argument_list|,
literal|"Failed to allocate RSS indirection QP\n"
argument_list|)
expr_stmt|;
goto|goto
name|rss_err
goto|;
block|}
name|rss_map
operator|->
name|indir_qp
operator|.
name|event
operator|=
name|mlx4_en_sqp_event
expr_stmt|;
name|mlx4_en_fill_qp_context
argument_list|(
name|priv
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|priv
operator|->
name|base_qpn
argument_list|,
name|priv
operator|->
name|rx_ring
index|[
literal|0
index|]
operator|->
name|cqn
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|prof
operator|->
name|rss_rings
operator|||
name|priv
operator|->
name|prof
operator|->
name|rss_rings
operator|>
name|priv
operator|->
name|rx_ring_num
condition|)
name|rss_rings
operator|=
name|priv
operator|->
name|rx_ring_num
expr_stmt|;
else|else
name|rss_rings
operator|=
name|priv
operator|->
name|prof
operator|->
name|rss_rings
expr_stmt|;
name|ptr
operator|=
operator|(
operator|(
name|u8
operator|*
operator|)
operator|&
name|context
operator|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|mlx4_qp_context
argument_list|,
name|pri_path
argument_list|)
operator|+
name|MLX4_RSS_OFFSET_IN_QPC_PRI_PATH
expr_stmt|;
name|rss_context
operator|=
name|ptr
expr_stmt|;
name|rss_context
operator|->
name|base_qpn
operator|=
name|cpu_to_be32
argument_list|(
name|ilog2
argument_list|(
name|rss_rings
argument_list|)
operator|<<
literal|24
operator||
operator|(
name|rss_map
operator|->
name|base_qpn
operator|)
argument_list|)
expr_stmt|;
name|rss_context
operator|->
name|default_qpn
operator|=
name|cpu_to_be32
argument_list|(
name|rss_map
operator|->
name|base_qpn
argument_list|)
expr_stmt|;
if|if
condition|(
name|priv
operator|->
name|mdev
operator|->
name|profile
operator|.
name|udp_rss
condition|)
block|{
name|rss_mask
operator||=
name|MLX4_RSS_UDP_IPV4
operator||
name|MLX4_RSS_UDP_IPV6
expr_stmt|;
name|rss_context
operator|->
name|base_qpn_udp
operator|=
name|rss_context
operator|->
name|default_qpn
expr_stmt|;
block|}
name|rss_context
operator|->
name|flags
operator|=
name|rss_mask
expr_stmt|;
name|rss_context
operator|->
name|hash_fn
operator|=
name|MLX4_RSS_HASH_TOP
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|rss_context
operator|->
name|rss_key
index|[
name|i
index|]
operator|=
name|cpu_to_be32
argument_list|(
name|rsskey
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_qp_to_ready
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|res
operator|.
name|mtt
argument_list|,
operator|&
name|context
argument_list|,
operator|&
name|rss_map
operator|->
name|indir_qp
argument_list|,
operator|&
name|rss_map
operator|->
name|indir_state
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|indir_err
goto|;
return|return
literal|0
return|;
name|indir_err
label|:
name|mlx4_qp_modify
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|NULL
argument_list|,
name|rss_map
operator|->
name|indir_state
argument_list|,
name|MLX4_QP_STATE_RST
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|rss_map
operator|->
name|indir_qp
argument_list|)
expr_stmt|;
name|mlx4_qp_remove
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|rss_map
operator|->
name|indir_qp
argument_list|)
expr_stmt|;
name|mlx4_qp_free
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|rss_map
operator|->
name|indir_qp
argument_list|)
expr_stmt|;
name|rss_err
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|good_qps
condition|;
name|i
operator|++
control|)
block|{
name|mlx4_qp_modify
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|NULL
argument_list|,
name|rss_map
operator|->
name|state
index|[
name|i
index|]
argument_list|,
name|MLX4_QP_STATE_RST
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|rss_map
operator|->
name|qps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mlx4_qp_remove
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|rss_map
operator|->
name|qps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mlx4_qp_free
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|rss_map
operator|->
name|qps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|mlx4_qp_release_range
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|rss_map
operator|->
name|base_qpn
argument_list|,
name|priv
operator|->
name|rx_ring_num
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|void
name|mlx4_en_release_rss_steer
parameter_list|(
name|struct
name|mlx4_en_priv
modifier|*
name|priv
parameter_list|)
block|{
name|struct
name|mlx4_en_dev
modifier|*
name|mdev
init|=
name|priv
operator|->
name|mdev
decl_stmt|;
name|struct
name|mlx4_en_rss_map
modifier|*
name|rss_map
init|=
operator|&
name|priv
operator|->
name|rss_map
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mlx4_qp_modify
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|NULL
argument_list|,
name|rss_map
operator|->
name|indir_state
argument_list|,
name|MLX4_QP_STATE_RST
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|rss_map
operator|->
name|indir_qp
argument_list|)
expr_stmt|;
name|mlx4_qp_remove
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|rss_map
operator|->
name|indir_qp
argument_list|)
expr_stmt|;
name|mlx4_qp_free
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|rss_map
operator|->
name|indir_qp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|priv
operator|->
name|rx_ring_num
condition|;
name|i
operator|++
control|)
block|{
name|mlx4_qp_modify
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|NULL
argument_list|,
name|rss_map
operator|->
name|state
index|[
name|i
index|]
argument_list|,
name|MLX4_QP_STATE_RST
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|rss_map
operator|->
name|qps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mlx4_qp_remove
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|rss_map
operator|->
name|qps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mlx4_qp_free
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
operator|&
name|rss_map
operator|->
name|qps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|mlx4_qp_release_range
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|rss_map
operator|->
name|base_qpn
argument_list|,
name|priv
operator|->
name|rx_ring_num
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

