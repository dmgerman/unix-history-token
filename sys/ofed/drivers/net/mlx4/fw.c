begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.  * Copyright (c) 2005, 2006, 2007, 2008, 2014 Mellanox Technologies. All rights reserved.  * Copyright (c) 2005, 2006, 2007 Cisco Systems, Inc.  All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_define
define|#
directive|define
name|LINUXKPI_PARAM_PREFIX
value|mlx4_
end_define

begin_include
include|#
directive|include
file|<linux/etherdevice.h>
end_include

begin_include
include|#
directive|include
file|<linux/mlx4/cmd.h>
end_include

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/cache.h>
end_include

begin_include
include|#
directive|include
file|"fw.h"
end_include

begin_include
include|#
directive|include
file|"icm.h"
end_include

begin_enum
enum|enum
block|{
name|MLX4_COMMAND_INTERFACE_MIN_REV
init|=
literal|2
block|,
name|MLX4_COMMAND_INTERFACE_MAX_REV
init|=
literal|3
block|,
name|MLX4_COMMAND_INTERFACE_NEW_PORT_CMDS
init|=
literal|3
block|, }
enum|;
end_enum

begin_function_decl
specifier|extern
name|void
name|__buggy_use_of_MLX4_GET
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|__buggy_use_of_MLX4_PUT
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|enable_qos
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param
argument_list|(
name|enable_qos
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|enable_qos
argument_list|,
literal|"Enable Quality of Service support in the HCA (default: off)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|MLX4_GET
parameter_list|(
name|dest
parameter_list|,
name|source
parameter_list|,
name|offset
parameter_list|)
define|\
value|do {							      \ 		void *__p = (char *) (source) + (offset);	      \ 		switch (sizeof (dest)) {			      \ 		case 1: (dest) = *(u8 *) __p;	    break;	      \ 		case 2: (dest) = be16_to_cpup(__p); break;	      \ 		case 4: (dest) = be32_to_cpup(__p); break;	      \ 		case 8: (dest) = be64_to_cpup(__p); break;	      \ 		default: __buggy_use_of_MLX4_GET();		      \ 		}						      \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|MLX4_PUT
parameter_list|(
name|dest
parameter_list|,
name|source
parameter_list|,
name|offset
parameter_list|)
define|\
value|do {							      \ 		void *__d = ((char *) (dest) + (offset));	      \ 		switch (sizeof(source)) {			      \ 		case 1: *(u8 *) __d = (source);		       break; \ 		case 2:	*(__be16 *) __d = cpu_to_be16(source); break; \ 		case 4:	*(__be32 *) __d = cpu_to_be32(source); break; \ 		case 8:	*(__be64 *) __d = cpu_to_be64(source); break; \ 		default: __buggy_use_of_MLX4_PUT();		      \ 		}						      \ 	} while (0)
end_define

begin_function
specifier|static
name|void
name|dump_dev_cap_flags
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|flags
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|fname
index|[]
init|=
block|{
index|[
literal|0
index|]
operator|=
literal|"RC transport"
block|,
index|[
literal|1
index|]
operator|=
literal|"UC transport"
block|,
index|[
literal|2
index|]
operator|=
literal|"UD transport"
block|,
index|[
literal|3
index|]
operator|=
literal|"XRC transport"
block|,
index|[
literal|4
index|]
operator|=
literal|"reliable multicast"
block|,
index|[
literal|5
index|]
operator|=
literal|"FCoIB support"
block|,
index|[
literal|6
index|]
operator|=
literal|"SRQ support"
block|,
index|[
literal|7
index|]
operator|=
literal|"IPoIB checksum offload"
block|,
index|[
literal|8
index|]
operator|=
literal|"P_Key violation counter"
block|,
index|[
literal|9
index|]
operator|=
literal|"Q_Key violation counter"
block|,
index|[
literal|10
index|]
operator|=
literal|"VMM"
block|,
index|[
literal|12
index|]
operator|=
literal|"DPDP"
block|,
index|[
literal|15
index|]
operator|=
literal|"Big LSO headers"
block|,
index|[
literal|16
index|]
operator|=
literal|"MW support"
block|,
index|[
literal|17
index|]
operator|=
literal|"APM support"
block|,
index|[
literal|18
index|]
operator|=
literal|"Atomic ops support"
block|,
index|[
literal|19
index|]
operator|=
literal|"Raw multicast support"
block|,
index|[
literal|20
index|]
operator|=
literal|"Address vector port checking support"
block|,
index|[
literal|21
index|]
operator|=
literal|"UD multicast support"
block|,
index|[
literal|24
index|]
operator|=
literal|"Demand paging support"
block|,
index|[
literal|25
index|]
operator|=
literal|"Router support"
block|,
index|[
literal|30
index|]
operator|=
literal|"IBoE support"
block|,
index|[
literal|32
index|]
operator|=
literal|"Unicast loopback support"
block|,
index|[
literal|34
index|]
operator|=
literal|"FCS header control"
block|,
index|[
literal|38
index|]
operator|=
literal|"Wake On LAN support"
block|,
index|[
literal|40
index|]
operator|=
literal|"UDP RSS support"
block|,
index|[
literal|41
index|]
operator|=
literal|"Unicast VEP steering support"
block|,
index|[
literal|42
index|]
operator|=
literal|"Multicast VEP steering support"
block|,
index|[
literal|44
index|]
operator|=
literal|"Cross-channel (sync_qp) operations support"
block|,
index|[
literal|48
index|]
operator|=
literal|"Counters support"
block|,
index|[
literal|59
index|]
operator|=
literal|"Port management change event support"
block|,
index|[
literal|60
index|]
operator|=
literal|"eSwitch support"
block|,
index|[
literal|61
index|]
operator|=
literal|"64 byte EQE support"
block|,
index|[
literal|62
index|]
operator|=
literal|"64 byte CQE support"
block|, 	}
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"DEV_CAP flags:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|fname
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|fname
index|[
name|i
index|]
operator|&&
operator|(
name|flags
operator|&
operator|(
literal|1LL
operator|<<
name|i
operator|)
operator|)
condition|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"    %s\n"
argument_list|,
name|fname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_dev_cap_flags2
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|flags
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|fname
index|[]
init|=
block|{
index|[
literal|0
index|]
operator|=
literal|"RSS support"
block|,
index|[
literal|1
index|]
operator|=
literal|"RSS Toeplitz Hash Function support"
block|,
index|[
literal|2
index|]
operator|=
literal|"RSS XOR Hash Function support"
block|,
index|[
literal|3
index|]
operator|=
literal|"Device manage flow steering support"
block|,
index|[
literal|4
index|]
operator|=
literal|"FSM (MAC unti-spoofing) support"
block|,
index|[
literal|5
index|]
operator|=
literal|"VST (control vlan insertion/stripping) support"
block|,
index|[
literal|6
index|]
operator|=
literal|"Dynamic QP updates support"
block|,
index|[
literal|7
index|]
operator|=
literal|"Loopback source checks support"
block|,
index|[
literal|8
index|]
operator|=
literal|"Device managed flow steering IPoIB support"
block|,
index|[
literal|9
index|]
operator|=
literal|"ETS configuration support"
block|,
index|[
literal|10
index|]
operator|=
literal|"ETH backplane autoneg report"
block|,
index|[
literal|11
index|]
operator|=
literal|"Ethernet Flow control statistics support"
block|,
index|[
literal|12
index|]
operator|=
literal|"Recoverable error events support"
block|,
index|[
literal|13
index|]
operator|=
literal|"Time stamping support"
block|,
index|[
literal|14
index|]
operator|=
literal|"Report driver version to FW support"
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|fname
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|fname
index|[
name|i
index|]
operator|&&
operator|(
name|flags
operator|&
operator|(
literal|1LL
operator|<<
name|i
operator|)
operator|)
condition|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"    %s\n"
argument_list|,
name|fname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mlx4_MOD_STAT_CFG
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_mod_stat_cfg
modifier|*
name|cfg
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|inbox
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|MOD_STAT_CFG_IN_SIZE
value|0x100
define|#
directive|define
name|MOD_STAT_CFG_PG_SZ_M_OFFSET
value|0x002
define|#
directive|define
name|MOD_STAT_CFG_PG_SZ_OFFSET
value|0x003
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|inbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|memset
argument_list|(
name|inbox
argument_list|,
literal|0
argument_list|,
name|MOD_STAT_CFG_IN_SIZE
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|cfg
operator|->
name|log_pg_sz
argument_list|,
name|MOD_STAT_CFG_PG_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|cfg
operator|->
name|log_pg_sz_m
argument_list|,
name|MOD_STAT_CFG_PG_SZ_M_OFFSET
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_MOD_STAT_CFG
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_FUNC
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_func
modifier|*
name|func
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|outbox
decl_stmt|;
name|u8
name|in_modifier
decl_stmt|;
name|u8
name|field
decl_stmt|;
name|u16
name|field16
decl_stmt|;
name|int
name|err
decl_stmt|;
define|#
directive|define
name|QUERY_FUNC_BUS_OFFSET
value|0x00
define|#
directive|define
name|QUERY_FUNC_DEVICE_OFFSET
value|0x01
define|#
directive|define
name|QUERY_FUNC_FUNCTION_OFFSET
value|0x01
define|#
directive|define
name|QUERY_FUNC_PHYSICAL_FUNCTION_OFFSET
value|0x03
define|#
directive|define
name|QUERY_FUNC_RSVD_EQS_OFFSET
value|0x04
define|#
directive|define
name|QUERY_FUNC_MAX_EQ_OFFSET
value|0x06
define|#
directive|define
name|QUERY_FUNC_RSVD_UARS_OFFSET
value|0x0b
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|in_modifier
operator|=
name|slave
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|in_modifier
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_FUNC
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_BUS_OFFSET
argument_list|)
expr_stmt|;
name|func
operator|->
name|bus
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_DEVICE_OFFSET
argument_list|)
expr_stmt|;
name|func
operator|->
name|device
operator|=
name|field
operator|&
literal|0xf1
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_FUNCTION_OFFSET
argument_list|)
expr_stmt|;
name|func
operator|->
name|function
operator|=
name|field
operator|&
literal|0x7
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_PHYSICAL_FUNCTION_OFFSET
argument_list|)
expr_stmt|;
name|func
operator|->
name|physical_function
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field16
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_RSVD_EQS_OFFSET
argument_list|)
expr_stmt|;
name|func
operator|->
name|rsvd_eqs
operator|=
name|field16
operator|&
literal|0xffff
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field16
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_MAX_EQ_OFFSET
argument_list|)
expr_stmt|;
name|func
operator|->
name|max_eq
operator|=
name|field16
operator|&
literal|0xffff
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_RSVD_UARS_OFFSET
argument_list|)
expr_stmt|;
name|func
operator|->
name|rsvd_uars
operator|=
name|field
operator|&
literal|0x0f
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Bus: %d, Device: %d, Function: %d, Physical function: %d, Max EQs: %d, Reserved EQs: %d, Reserved UARs: %d\n"
argument_list|,
name|func
operator|->
name|bus
argument_list|,
name|func
operator|->
name|device
argument_list|,
name|func
operator|->
name|function
argument_list|,
name|func
operator|->
name|physical_function
argument_list|,
name|func
operator|->
name|max_eq
argument_list|,
name|func
operator|->
name|rsvd_eqs
argument_list|,
name|func
operator|->
name|rsvd_uars
argument_list|)
expr_stmt|;
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_FUNC_CAP_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u8
name|field
decl_stmt|,
name|port
decl_stmt|;
name|u32
name|size
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|mlx4_func
name|func
decl_stmt|;
define|#
directive|define
name|QUERY_FUNC_CAP_FLAGS_OFFSET
value|0x0
define|#
directive|define
name|QUERY_FUNC_CAP_NUM_PORTS_OFFSET
value|0x1
define|#
directive|define
name|QUERY_FUNC_CAP_PF_BHVR_OFFSET
value|0x4
define|#
directive|define
name|QUERY_FUNC_CAP_FMR_OFFSET
value|0x8
define|#
directive|define
name|QUERY_FUNC_CAP_QP_QUOTA_OFFSET_DEP
value|0x10
define|#
directive|define
name|QUERY_FUNC_CAP_CQ_QUOTA_OFFSET_DEP
value|0x14
define|#
directive|define
name|QUERY_FUNC_CAP_SRQ_QUOTA_OFFSET_DEP
value|0x18
define|#
directive|define
name|QUERY_FUNC_CAP_MPT_QUOTA_OFFSET_DEP
value|0x20
define|#
directive|define
name|QUERY_FUNC_CAP_MTT_QUOTA_OFFSET_DEP
value|0x24
define|#
directive|define
name|QUERY_FUNC_CAP_MCG_QUOTA_OFFSET_DEP
value|0x28
define|#
directive|define
name|QUERY_FUNC_CAP_MAX_EQ_OFFSET
value|0x2c
define|#
directive|define
name|QUERY_FUNC_CAP_RESERVED_EQ_OFFSET
value|0x30
define|#
directive|define
name|QUERY_FUNC_CAP_QP_QUOTA_OFFSET
value|0x50
define|#
directive|define
name|QUERY_FUNC_CAP_CQ_QUOTA_OFFSET
value|0x54
define|#
directive|define
name|QUERY_FUNC_CAP_SRQ_QUOTA_OFFSET
value|0x58
define|#
directive|define
name|QUERY_FUNC_CAP_MPT_QUOTA_OFFSET
value|0x60
define|#
directive|define
name|QUERY_FUNC_CAP_MTT_QUOTA_OFFSET
value|0x64
define|#
directive|define
name|QUERY_FUNC_CAP_MCG_QUOTA_OFFSET
value|0x68
define|#
directive|define
name|QUERY_FUNC_CAP_EXTRA_FLAGS_OFFSET
value|0x6c
define|#
directive|define
name|QUERY_FUNC_CAP_FMR_FLAG
value|0x80
define|#
directive|define
name|QUERY_FUNC_CAP_FLAG_RDMA
value|0x40
define|#
directive|define
name|QUERY_FUNC_CAP_FLAG_ETH
value|0x80
define|#
directive|define
name|QUERY_FUNC_CAP_FLAG_QUOTAS
value|0x10
define|#
directive|define
name|QUERY_FUNC_CAP_FLAG_VALID_MAILBOX
value|0x04
define|#
directive|define
name|QUERY_FUNC_CAP_EXTRA_FLAGS_BF_QP_ALLOC_FLAG
value|(1UL<< 31)
comment|/* when opcode modifier = 1 */
define|#
directive|define
name|QUERY_FUNC_CAP_PHYS_PORT_OFFSET
value|0x3
define|#
directive|define
name|QUERY_FUNC_CAP_FLAGS0_OFFSET
value|0x8
define|#
directive|define
name|QUERY_FUNC_CAP_FLAGS1_OFFSET
value|0xc
define|#
directive|define
name|QUERY_FUNC_CAP_COUNTER_INDEX_OFFSET
value|0xd
define|#
directive|define
name|QUERY_FUNC_CAP_QP0_TUNNEL
value|0x10
define|#
directive|define
name|QUERY_FUNC_CAP_QP0_PROXY
value|0x14
define|#
directive|define
name|QUERY_FUNC_CAP_QP1_TUNNEL
value|0x18
define|#
directive|define
name|QUERY_FUNC_CAP_QP1_PROXY
value|0x1c
define|#
directive|define
name|QUERY_FUNC_CAP_ETH_PROPS_FORCE_MAC
value|0x40
define|#
directive|define
name|QUERY_FUNC_CAP_ETH_PROPS_FORCE_VLAN
value|0x80
define|#
directive|define
name|QUERY_FUNC_CAP_PROPS_DEF_COUNTER
value|0x20
define|#
directive|define
name|QUERY_FUNC_CAP_RDMA_PROPS_FORCE_PHY_WQE_GID
value|0x80
define|#
directive|define
name|QUERY_FUNC_CAP_SUPPORTS_NON_POWER_OF_2_NUM_EQS
value|(1<< 31)
if|if
condition|(
name|vhcr
operator|->
name|op_modifier
operator|==
literal|1
condition|)
block|{
name|port
operator|=
name|vhcr
operator|->
name|in_modifier
expr_stmt|;
comment|/* phys-port = logical-port */
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|port
argument_list|,
name|QUERY_FUNC_CAP_PHYS_PORT_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|=
literal|0
expr_stmt|;
comment|/* ensure that phy_wqe_gid bit is not set */
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field
argument_list|,
name|QUERY_FUNC_CAP_FLAGS0_OFFSET
argument_list|)
expr_stmt|;
comment|/* ensure force vlan and force mac bits are not set 		 * and that default counter bit is set 		 */
name|field
operator|=
name|QUERY_FUNC_CAP_PROPS_DEF_COUNTER
expr_stmt|;
comment|/* def counter */
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field
argument_list|,
name|QUERY_FUNC_CAP_FLAGS1_OFFSET
argument_list|)
expr_stmt|;
comment|/* There is always default counter legal or sink counter */
name|field
operator|=
name|mlx4_get_default_counter_index
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|vhcr
operator|->
name|in_modifier
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field
argument_list|,
name|QUERY_FUNC_CAP_COUNTER_INDEX_OFFSET
argument_list|)
expr_stmt|;
comment|/* size is now the QP number */
name|size
operator|=
name|dev
operator|->
name|phys_caps
operator|.
name|base_tunnel_sqpn
operator|+
literal|8
operator|*
name|slave
operator|+
name|port
operator|-
literal|1
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_QP0_TUNNEL
argument_list|)
expr_stmt|;
name|size
operator|+=
literal|2
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_QP1_TUNNEL
argument_list|)
expr_stmt|;
name|size
operator|=
name|dev
operator|->
name|phys_caps
operator|.
name|base_proxy_sqpn
operator|+
literal|8
operator|*
name|slave
operator|+
name|port
operator|-
literal|1
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_QP0_PROXY
argument_list|)
expr_stmt|;
name|size
operator|+=
literal|2
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_QP1_PROXY
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vhcr
operator|->
name|op_modifier
operator|==
literal|0
condition|)
block|{
comment|/* enable rdma and ethernet interfaces, and new quota locations */
name|field
operator|=
operator|(
name|QUERY_FUNC_CAP_FLAG_ETH
operator||
name|QUERY_FUNC_CAP_FLAG_RDMA
operator||
name|QUERY_FUNC_CAP_FLAG_QUOTAS
operator||
name|QUERY_FUNC_CAP_FLAG_VALID_MAILBOX
operator|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field
argument_list|,
name|QUERY_FUNC_CAP_FLAGS_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|=
name|dev
operator|->
name|caps
operator|.
name|num_ports
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field
argument_list|,
name|QUERY_FUNC_CAP_NUM_PORTS_OFFSET
argument_list|)
expr_stmt|;
name|size
operator|=
name|dev
operator|->
name|caps
operator|.
name|function_caps
expr_stmt|;
comment|/* set PF behaviours */
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_PF_BHVR_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|=
literal|0
expr_stmt|;
comment|/* protected FMR support not available as yet */
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field
argument_list|,
name|QUERY_FUNC_CAP_FMR_OFFSET
argument_list|)
expr_stmt|;
name|size
operator|=
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|RES_QP
index|]
operator|.
name|quota
index|[
name|slave
index|]
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_QP_QUOTA_OFFSET
argument_list|)
expr_stmt|;
name|size
operator|=
name|dev
operator|->
name|caps
operator|.
name|num_qps
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_QP_QUOTA_OFFSET_DEP
argument_list|)
expr_stmt|;
name|size
operator|=
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|RES_SRQ
index|]
operator|.
name|quota
index|[
name|slave
index|]
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_SRQ_QUOTA_OFFSET
argument_list|)
expr_stmt|;
name|size
operator|=
name|dev
operator|->
name|caps
operator|.
name|num_srqs
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_SRQ_QUOTA_OFFSET_DEP
argument_list|)
expr_stmt|;
name|size
operator|=
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|RES_CQ
index|]
operator|.
name|quota
index|[
name|slave
index|]
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_CQ_QUOTA_OFFSET
argument_list|)
expr_stmt|;
name|size
operator|=
name|dev
operator|->
name|caps
operator|.
name|num_cqs
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_CQ_QUOTA_OFFSET_DEP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_SYS_EQS
operator|)
operator|||
name|mlx4_QUERY_FUNC
argument_list|(
name|dev
argument_list|,
operator|&
name|func
argument_list|,
name|slave
argument_list|)
condition|)
block|{
name|size
operator|=
name|vhcr
operator|->
name|in_modifier
operator|&
name|QUERY_FUNC_CAP_SUPPORTS_NON_POWER_OF_2_NUM_EQS
condition|?
name|dev
operator|->
name|caps
operator|.
name|num_eqs
else|:
name|rounddown_pow_of_two
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|num_eqs
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_MAX_EQ_OFFSET
argument_list|)
expr_stmt|;
name|size
operator|=
name|dev
operator|->
name|caps
operator|.
name|reserved_eqs
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_RESERVED_EQ_OFFSET
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|vhcr
operator|->
name|in_modifier
operator|&
name|QUERY_FUNC_CAP_SUPPORTS_NON_POWER_OF_2_NUM_EQS
condition|?
name|func
operator|.
name|max_eq
else|:
name|rounddown_pow_of_two
argument_list|(
name|func
operator|.
name|max_eq
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_MAX_EQ_OFFSET
argument_list|)
expr_stmt|;
name|size
operator|=
name|func
operator|.
name|rsvd_eqs
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_RESERVED_EQ_OFFSET
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|RES_MPT
index|]
operator|.
name|quota
index|[
name|slave
index|]
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_MPT_QUOTA_OFFSET
argument_list|)
expr_stmt|;
name|size
operator|=
name|dev
operator|->
name|caps
operator|.
name|num_mpts
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_MPT_QUOTA_OFFSET_DEP
argument_list|)
expr_stmt|;
name|size
operator|=
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|res_tracker
operator|.
name|res_alloc
index|[
name|RES_MTT
index|]
operator|.
name|quota
index|[
name|slave
index|]
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_MTT_QUOTA_OFFSET
argument_list|)
expr_stmt|;
name|size
operator|=
name|dev
operator|->
name|caps
operator|.
name|num_mtts
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_MTT_QUOTA_OFFSET_DEP
argument_list|)
expr_stmt|;
name|size
operator|=
name|dev
operator|->
name|caps
operator|.
name|num_mgms
operator|+
name|dev
operator|->
name|caps
operator|.
name|num_amgms
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_MCG_QUOTA_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_MCG_QUOTA_OFFSET_DEP
argument_list|)
expr_stmt|;
name|size
operator|=
name|QUERY_FUNC_CAP_EXTRA_FLAGS_BF_QP_ALLOC_FLAG
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|size
argument_list|,
name|QUERY_FUNC_CAP_EXTRA_FLAGS_OFFSET
argument_list|)
expr_stmt|;
block|}
else|else
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_FUNC_CAP
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|gen_or_port
parameter_list|,
name|struct
name|mlx4_func_cap
modifier|*
name|func_cap
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|outbox
decl_stmt|;
name|u8
name|field
decl_stmt|,
name|op_modifier
decl_stmt|;
name|u32
name|size
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|,
name|quotas
init|=
literal|0
decl_stmt|;
name|u32
name|in_modifier
decl_stmt|;
name|op_modifier
operator|=
operator|!
operator|!
name|gen_or_port
expr_stmt|;
comment|/* 0 = general, 1 = logical port */
name|in_modifier
operator|=
name|op_modifier
condition|?
name|gen_or_port
else|:
name|QUERY_FUNC_CAP_SUPPORTS_NON_POWER_OF_2_NUM_EQS
expr_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|in_modifier
argument_list|,
name|op_modifier
argument_list|,
name|MLX4_CMD_QUERY_FUNC_CAP
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
if|if
condition|(
operator|!
name|op_modifier
condition|)
block|{
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_FLAGS_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|field
operator|&
operator|(
name|QUERY_FUNC_CAP_FLAG_ETH
operator||
name|QUERY_FUNC_CAP_FLAG_RDMA
operator|)
operator|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"The host supports neither eth nor rdma interfaces\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EPROTONOSUPPORT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|func_cap
operator|->
name|flags
operator|=
name|field
expr_stmt|;
name|quotas
operator|=
operator|!
operator|!
operator|(
name|func_cap
operator|->
name|flags
operator|&
name|QUERY_FUNC_CAP_FLAG_QUOTAS
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_NUM_PORTS_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|num_ports
operator|=
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_PF_BHVR_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|pf_context_behaviour
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|quotas
condition|)
block|{
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_QP_QUOTA_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|qp_quota
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_SRQ_QUOTA_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|srq_quota
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_CQ_QUOTA_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|cq_quota
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_MPT_QUOTA_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|mpt_quota
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_MTT_QUOTA_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|mtt_quota
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_MCG_QUOTA_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|mcg_quota
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
block|}
else|else
block|{
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_QP_QUOTA_OFFSET_DEP
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|qp_quota
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_SRQ_QUOTA_OFFSET_DEP
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|srq_quota
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_CQ_QUOTA_OFFSET_DEP
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|cq_quota
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_MPT_QUOTA_OFFSET_DEP
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|mpt_quota
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_MTT_QUOTA_OFFSET_DEP
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|mtt_quota
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_MCG_QUOTA_OFFSET_DEP
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|mcg_quota
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
block|}
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_MAX_EQ_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|max_eq
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_RESERVED_EQ_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|reserved_eq
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|func_cap
operator|->
name|extra_flags
operator|=
literal|0
expr_stmt|;
comment|/* Mailbox data from 0x6c and onward should only be treated if 		 * QUERY_FUNC_CAP_FLAG_VALID_MAILBOX is set in func_cap->flags 		 */
if|if
condition|(
name|func_cap
operator|->
name|flags
operator|&
name|QUERY_FUNC_CAP_FLAG_VALID_MAILBOX
condition|)
block|{
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_EXTRA_FLAGS_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|&
name|QUERY_FUNC_CAP_EXTRA_FLAGS_BF_QP_ALLOC_FLAG
condition|)
name|func_cap
operator|->
name|extra_flags
operator||=
name|MLX4_QUERY_FUNC_FLAGS_BF_RES_QP
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
comment|/* logical port query */
if|if
condition|(
name|gen_or_port
operator|>
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|)
block|{
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|gen_or_port
index|]
operator|==
name|MLX4_PORT_TYPE_ETH
condition|)
block|{
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_FLAGS1_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
name|QUERY_FUNC_CAP_ETH_PROPS_FORCE_VLAN
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"VLAN is enforced on this port\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EPROTONOSUPPORT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|field
operator|&
name|QUERY_FUNC_CAP_ETH_PROPS_FORCE_MAC
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Force mac is enabled on this port\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EPROTONOSUPPORT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|gen_or_port
index|]
operator|==
name|MLX4_PORT_TYPE_IB
condition|)
block|{
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_FLAGS0_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
name|QUERY_FUNC_CAP_RDMA_PROPS_FORCE_PHY_WQE_GID
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"phy_wqe_gid is "
literal|"enforced on this ib port\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EPROTONOSUPPORT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_PHYS_PORT_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|physical_port
operator|=
name|field
expr_stmt|;
if|if
condition|(
name|func_cap
operator|->
name|physical_port
operator|!=
name|gen_or_port
condition|)
block|{
name|err
operator|=
operator|-
name|ENOSYS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_FLAGS1_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
name|QUERY_FUNC_CAP_PROPS_DEF_COUNTER
condition|)
block|{
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_COUNTER_INDEX_OFFSET
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|def_counter_index
operator|=
name|field
expr_stmt|;
block|}
else|else
block|{
name|func_cap
operator|->
name|def_counter_index
operator|=
name|MLX4_SINK_COUNTER_INDEX
expr_stmt|;
block|}
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_QP0_TUNNEL
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|qp0_tunnel_qpn
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_QP0_PROXY
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|qp0_proxy_qpn
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_QP1_TUNNEL
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|qp1_tunnel_qpn
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FUNC_CAP_QP1_PROXY
argument_list|)
expr_stmt|;
name|func_cap
operator|->
name|qp1_proxy_qpn
operator|=
name|size
operator|&
literal|0xFFFFFF
expr_stmt|;
comment|/* All other resources are allocated by the master, but we still report 	 * 'num' and 'reserved' capabilities as follows: 	 * - num remains the maximum resource index 	 * - 'num - reserved' is the total available objects of a resource, but 	 *   resource indices may be less than 'reserved' 	 * TODO: set per-resource quotas */
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_DEV_CAP
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|outbox
decl_stmt|;
name|u8
name|field
decl_stmt|;
name|u32
name|field32
decl_stmt|,
name|flags
decl_stmt|,
name|ext_flags
decl_stmt|;
name|u16
name|size
decl_stmt|;
name|u16
name|stat_rate
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
define|#
directive|define
name|QUERY_DEV_CAP_OUT_SIZE
value|0x100
define|#
directive|define
name|QUERY_DEV_CAP_MAX_SRQ_SZ_OFFSET
value|0x10
define|#
directive|define
name|QUERY_DEV_CAP_MAX_QP_SZ_OFFSET
value|0x11
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_QP_OFFSET
value|0x12
define|#
directive|define
name|QUERY_DEV_CAP_MAX_QP_OFFSET
value|0x13
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_SRQ_OFFSET
value|0x14
define|#
directive|define
name|QUERY_DEV_CAP_MAX_SRQ_OFFSET
value|0x15
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_EEC_OFFSET
value|0x16
define|#
directive|define
name|QUERY_DEV_CAP_MAX_EEC_OFFSET
value|0x17
define|#
directive|define
name|QUERY_DEV_CAP_MAX_CQ_SZ_OFFSET
value|0x19
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_CQ_OFFSET
value|0x1a
define|#
directive|define
name|QUERY_DEV_CAP_MAX_CQ_OFFSET
value|0x1b
define|#
directive|define
name|QUERY_DEV_CAP_MAX_MPT_OFFSET
value|0x1d
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_EQ_OFFSET
value|0x1e
define|#
directive|define
name|QUERY_DEV_CAP_MAX_EQ_OFFSET
value|0x1f
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_MTT_OFFSET
value|0x20
define|#
directive|define
name|QUERY_DEV_CAP_MAX_MRW_SZ_OFFSET
value|0x21
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_MRW_OFFSET
value|0x22
define|#
directive|define
name|QUERY_DEV_CAP_MAX_MTT_SEG_OFFSET
value|0x23
define|#
directive|define
name|QUERY_DEV_CAP_NUM_SYS_EQ_OFFSET
value|0x26
define|#
directive|define
name|QUERY_DEV_CAP_MAX_AV_OFFSET
value|0x27
define|#
directive|define
name|QUERY_DEV_CAP_MAX_REQ_QP_OFFSET
value|0x29
define|#
directive|define
name|QUERY_DEV_CAP_MAX_RES_QP_OFFSET
value|0x2b
define|#
directive|define
name|QUERY_DEV_CAP_MAX_GSO_OFFSET
value|0x2d
define|#
directive|define
name|QUERY_DEV_CAP_RSS_OFFSET
value|0x2e
define|#
directive|define
name|QUERY_DEV_CAP_MAX_RDMA_OFFSET
value|0x2f
define|#
directive|define
name|QUERY_DEV_CAP_RSZ_SRQ_OFFSET
value|0x33
define|#
directive|define
name|QUERY_DEV_CAP_ACK_DELAY_OFFSET
value|0x35
define|#
directive|define
name|QUERY_DEV_CAP_MTU_WIDTH_OFFSET
value|0x36
define|#
directive|define
name|QUERY_DEV_CAP_VL_PORT_OFFSET
value|0x37
define|#
directive|define
name|QUERY_DEV_CAP_MAX_MSG_SZ_OFFSET
value|0x38
define|#
directive|define
name|QUERY_DEV_CAP_MAX_GID_OFFSET
value|0x3b
define|#
directive|define
name|QUERY_DEV_CAP_RATE_SUPPORT_OFFSET
value|0x3c
define|#
directive|define
name|QUERY_DEV_CAP_CQ_TS_SUPPORT_OFFSET
value|0x3e
define|#
directive|define
name|QUERY_DEV_CAP_MAX_PKEY_OFFSET
value|0x3f
define|#
directive|define
name|QUERY_DEV_CAP_EXT_FLAGS_OFFSET
value|0x40
define|#
directive|define
name|QUERY_DEV_CAP_SYNC_QP_OFFSET
value|0x42
define|#
directive|define
name|QUERY_DEV_CAP_FLAGS_OFFSET
value|0x44
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_UAR_OFFSET
value|0x48
define|#
directive|define
name|QUERY_DEV_CAP_UAR_SZ_OFFSET
value|0x49
define|#
directive|define
name|QUERY_DEV_CAP_PAGE_SZ_OFFSET
value|0x4b
define|#
directive|define
name|QUERY_DEV_CAP_BF_OFFSET
value|0x4c
define|#
directive|define
name|QUERY_DEV_CAP_LOG_BF_REG_SZ_OFFSET
value|0x4d
define|#
directive|define
name|QUERY_DEV_CAP_LOG_MAX_BF_REGS_PER_PAGE_OFFSET
value|0x4e
define|#
directive|define
name|QUERY_DEV_CAP_LOG_MAX_BF_PAGES_OFFSET
value|0x4f
define|#
directive|define
name|QUERY_DEV_CAP_MAX_SG_SQ_OFFSET
value|0x51
define|#
directive|define
name|QUERY_DEV_CAP_MAX_DESC_SZ_SQ_OFFSET
value|0x52
define|#
directive|define
name|QUERY_DEV_CAP_MAX_SG_RQ_OFFSET
value|0x55
define|#
directive|define
name|QUERY_DEV_CAP_MAX_DESC_SZ_RQ_OFFSET
value|0x56
define|#
directive|define
name|QUERY_DEV_CAP_MAX_QP_MCG_OFFSET
value|0x61
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_MCG_OFFSET
value|0x62
define|#
directive|define
name|QUERY_DEV_CAP_MAX_MCG_OFFSET
value|0x63
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_PD_OFFSET
value|0x64
define|#
directive|define
name|QUERY_DEV_CAP_MAX_PD_OFFSET
value|0x65
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_XRC_OFFSET
value|0x66
define|#
directive|define
name|QUERY_DEV_CAP_MAX_XRC_OFFSET
value|0x67
define|#
directive|define
name|QUERY_DEV_CAP_MAX_BASIC_COUNTERS_OFFSET
value|0x68
define|#
directive|define
name|QUERY_DEV_CAP_MAX_EXTENDED_COUNTERS_OFFSET
value|0x6c
define|#
directive|define
name|QUERY_DEV_CAP_PORT_FLOWSTATS_COUNTERS_OFFSET
value|0x70
define|#
directive|define
name|QUERY_DEV_CAP_FLOW_STEERING_RANGE_EN_OFFSET
value|0x76
define|#
directive|define
name|QUERY_DEV_CAP_EXT_2_FLAGS_OFFSET
value|0x70
define|#
directive|define
name|QUERY_DEV_CAP_FLOW_STEERING_IPOIB_OFFSET
value|0x74
define|#
directive|define
name|QUERY_DEV_CAP_FLOW_STEERING_MAX_QP_OFFSET
value|0x77
define|#
directive|define
name|QUERY_DEV_CAP_RDMARC_ENTRY_SZ_OFFSET
value|0x80
define|#
directive|define
name|QUERY_DEV_CAP_QPC_ENTRY_SZ_OFFSET
value|0x82
define|#
directive|define
name|QUERY_DEV_CAP_AUX_ENTRY_SZ_OFFSET
value|0x84
define|#
directive|define
name|QUERY_DEV_CAP_ALTC_ENTRY_SZ_OFFSET
value|0x86
define|#
directive|define
name|QUERY_DEV_CAP_EQC_ENTRY_SZ_OFFSET
value|0x88
define|#
directive|define
name|QUERY_DEV_CAP_CQC_ENTRY_SZ_OFFSET
value|0x8a
define|#
directive|define
name|QUERY_DEV_CAP_SRQ_ENTRY_SZ_OFFSET
value|0x8c
define|#
directive|define
name|QUERY_DEV_CAP_C_MPT_ENTRY_SZ_OFFSET
value|0x8e
define|#
directive|define
name|QUERY_DEV_CAP_MTT_ENTRY_SZ_OFFSET
value|0x90
define|#
directive|define
name|QUERY_DEV_CAP_D_MPT_ENTRY_SZ_OFFSET
value|0x92
define|#
directive|define
name|QUERY_DEV_CAP_BMME_FLAGS_OFFSET
value|0x94
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_LKEY_OFFSET
value|0x98
define|#
directive|define
name|QUERY_DEV_CAP_ETS_CFG_OFFSET
value|0x9c
define|#
directive|define
name|QUERY_DEV_CAP_MAX_ICM_SZ_OFFSET
value|0xa0
name|dev_cap
operator|->
name|flags2
operator|=
literal|0
expr_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_DEV_CAP
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_QP_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_qps
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0xf
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_QP_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_qps
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_SRQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_srqs
operator|=
literal|1
operator|<<
operator|(
name|field
operator|>>
literal|4
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_SRQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_srqs
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_CQ_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_cq_sz
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_CQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_cqs
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0xf
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_CQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_cqs
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_MPT_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_mpts
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_EQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_eqs
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_EQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_eqs
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0xf
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_MTT_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_mtts
operator|=
literal|1
operator|<<
operator|(
name|field
operator|>>
literal|4
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_MRW_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_mrw_sz
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_MRW_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_mrws
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0xf
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_MTT_SEG_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_mtt_seg
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_NUM_SYS_EQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|num_sys_eqs
operator|=
name|size
operator|&
literal|0xfff
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_REQ_QP_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_requester_per_qp
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_RES_QP_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_responder_per_qp
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_GSO_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|&=
literal|0x1f
expr_stmt|;
if|if
condition|(
operator|!
name|field
condition|)
name|dev_cap
operator|->
name|max_gso_sz
operator|=
literal|0
expr_stmt|;
else|else
name|dev_cap
operator|->
name|max_gso_sz
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSS_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
literal|0x20
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_RSS_XOR
expr_stmt|;
if|if
condition|(
name|field
operator|&
literal|0x10
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_RSS_TOP
expr_stmt|;
name|field
operator|&=
literal|0xf
expr_stmt|;
if|if
condition|(
name|field
condition|)
block|{
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_RSS
expr_stmt|;
name|dev_cap
operator|->
name|max_rss_tbl_sz
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
block|}
else|else
name|dev_cap
operator|->
name|max_rss_tbl_sz
operator|=
literal|0
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_RDMA_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_rdma_global
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_ACK_DELAY_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|local_ca_ack_delay
operator|=
name|field
operator|&
literal|0x1f
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_VL_PORT_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|num_ports
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_MSG_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_msg_sz
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_PORT_FLOWSTATS_COUNTERS_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
literal|0x10
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_FLOWSTATS_EN
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_FLOW_STEERING_RANGE_EN_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
literal|0x80
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_FS_EN
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_FLOW_STEERING_IPOIB_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
literal|0x80
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_DMFS_IPOIB
expr_stmt|;
name|dev_cap
operator|->
name|fs_log_max_ucast_qp_range_size
operator|=
name|field
operator|&
literal|0x1f
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_FLOW_STEERING_MAX_QP_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|fs_max_num_qp_per_entry
operator|=
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|stat_rate
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RATE_SUPPORT_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|stat_rate_support
operator|=
name|stat_rate
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_CQ_TS_SUPPORT_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
literal|0x80
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_TS
expr_stmt|;
name|MLX4_GET
argument_list|(
name|ext_flags
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_EXT_FLAGS_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|flags
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_FLAGS_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|flags
operator|=
name|flags
operator||
operator|(
name|u64
operator|)
name|ext_flags
operator|<<
literal|32
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_SYNC_QP_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|sync_qp
operator|=
name|field
operator|&
literal|0x10
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_UAR_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_uars
operator|=
name|field
operator|>>
literal|4
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_UAR_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|uar_size
operator|=
literal|1
operator|<<
operator|(
operator|(
name|field
operator|&
literal|0x3f
operator|)
operator|+
literal|20
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_PAGE_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|min_page_sz
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_BF_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
literal|0x80
condition|)
block|{
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_LOG_BF_REG_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|bf_reg_size
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_LOG_MAX_BF_REGS_PER_PAGE_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x3f
operator|)
operator|)
operator|>
operator|(
name|PAGE_SIZE
operator|/
name|dev_cap
operator|->
name|bf_reg_size
operator|)
condition|)
name|field
operator|=
literal|3
expr_stmt|;
name|dev_cap
operator|->
name|bf_regs_per_page
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"BlueFlame available (reg size %d, regs/page %d)\n"
argument_list|,
name|dev_cap
operator|->
name|bf_reg_size
argument_list|,
name|dev_cap
operator|->
name|bf_regs_per_page
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dev_cap
operator|->
name|bf_reg_size
operator|=
literal|0
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"BlueFlame not available\n"
argument_list|)
expr_stmt|;
block|}
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_SG_SQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_sq_sg
operator|=
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_DESC_SZ_SQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_sq_desc_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_QP_MCG_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_qp_per_mcg
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_MCG_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_mgms
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_MCG_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_mcgs
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_PD_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_pds
operator|=
name|field
operator|>>
literal|4
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_PD_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_pds
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_XRC_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_xrcds
operator|=
name|field
operator|>>
literal|4
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_XRC_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_xrcds
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RDMARC_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|rdmarc_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_QPC_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|qpc_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_AUX_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|aux_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_ALTC_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|altc_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_EQC_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|eqc_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_CQC_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|cqc_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_SRQ_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|srq_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_C_MPT_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|cmpt_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MTT_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|mtt_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_D_MPT_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|dmpt_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_SRQ_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_srq_sz
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_QP_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_qp_sz
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSZ_SRQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|resize_srq
operator|=
name|field
operator|&
literal|1
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_SG_RQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_rq_sg
operator|=
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_DESC_SZ_RQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_rq_desc_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|dev_cap
operator|->
name|bmme_flags
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_BMME_FLAGS_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|dev_cap
operator|->
name|reserved_lkey
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_LKEY_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field32
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_ETS_CFG_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field32
operator|&
operator|(
literal|1
operator|<<
literal|0
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_ETH_BACKPL_AN_REP
expr_stmt|;
if|if
condition|(
name|field32
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_RECOVERABLE_ERROR_EVENT
expr_stmt|;
if|if
condition|(
name|field32
operator|&
operator|(
literal|1
operator|<<
literal|8
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_DRIVER_VERSION_TO_FW
expr_stmt|;
if|if
condition|(
name|field32
operator|&
operator|(
literal|1
operator|<<
literal|13
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_ETS_CFG
expr_stmt|;
name|MLX4_GET
argument_list|(
name|dev_cap
operator|->
name|max_icm_sz
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_ICM_SZ_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_cap
operator|->
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_COUNTERS
condition|)
name|MLX4_GET
argument_list|(
name|dev_cap
operator|->
name|max_basic_counters
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_BASIC_COUNTERS_OFFSET
argument_list|)
expr_stmt|;
comment|/* FW reports 256 however real value is 255 */
name|dev_cap
operator|->
name|max_basic_counters
operator|=
name|min_t
argument_list|(
name|u32
argument_list|,
name|dev_cap
operator|->
name|max_basic_counters
argument_list|,
literal|255
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_cap
operator|->
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_COUNTERS_EXT
condition|)
name|MLX4_GET
argument_list|(
name|dev_cap
operator|->
name|max_extended_counters
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_EXTENDED_COUNTERS_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field32
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_EXT_2_FLAGS_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field32
operator|&
operator|(
literal|1
operator|<<
literal|16
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_UPDATE_QP
expr_stmt|;
if|if
condition|(
name|field32
operator|&
operator|(
literal|1
operator|<<
literal|19
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_LB_SRC_CHK
expr_stmt|;
if|if
condition|(
name|field32
operator|&
operator|(
literal|1
operator|<<
literal|20
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_FSM
expr_stmt|;
if|if
condition|(
name|field32
operator|&
operator|(
literal|1
operator|<<
literal|26
operator|)
condition|)
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_VLAN_CONTROL
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_OLD_PORT_CMDS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev_cap
operator|->
name|num_ports
condition|;
operator|++
name|i
control|)
block|{
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_VL_PORT_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_vl
index|[
name|i
index|]
operator|=
name|field
operator|>>
literal|4
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MTU_WIDTH_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|ib_mtu
index|[
name|i
index|]
operator|=
name|field
operator|>>
literal|4
expr_stmt|;
name|dev_cap
operator|->
name|max_port_width
index|[
name|i
index|]
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_GID_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_gids
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0xf
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_PKEY_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_pkeys
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0xf
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
define|#
directive|define
name|QUERY_PORT_SUPPORTED_TYPE_OFFSET
value|0x00
define|#
directive|define
name|QUERY_PORT_MTU_OFFSET
value|0x01
define|#
directive|define
name|QUERY_PORT_ETH_MTU_OFFSET
value|0x02
define|#
directive|define
name|QUERY_PORT_WIDTH_OFFSET
value|0x06
define|#
directive|define
name|QUERY_PORT_MAX_GID_PKEY_OFFSET
value|0x07
define|#
directive|define
name|QUERY_PORT_MAX_MACVLAN_OFFSET
value|0x0a
define|#
directive|define
name|QUERY_PORT_MAX_VL_OFFSET
value|0x0b
define|#
directive|define
name|QUERY_PORT_MAC_OFFSET
value|0x10
define|#
directive|define
name|QUERY_PORT_TRANS_VENDOR_OFFSET
value|0x18
define|#
directive|define
name|QUERY_PORT_WAVELENGTH_OFFSET
value|0x1c
define|#
directive|define
name|QUERY_PORT_TRANS_CODE_OFFSET
value|0x20
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev_cap
operator|->
name|num_ports
condition|;
operator|++
name|i
control|)
block|{
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_SUPPORTED_TYPE_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|supported_port_types
index|[
name|i
index|]
operator|=
name|field
operator|&
literal|3
expr_stmt|;
name|dev_cap
operator|->
name|suggested_type
index|[
name|i
index|]
operator|=
operator|(
name|field
operator|>>
literal|3
operator|)
operator|&
literal|1
expr_stmt|;
name|dev_cap
operator|->
name|default_sense
index|[
name|i
index|]
operator|=
operator|(
name|field
operator|>>
literal|4
operator|)
operator|&
literal|1
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_MTU_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|ib_mtu
index|[
name|i
index|]
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_WIDTH_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_port_width
index|[
name|i
index|]
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_MAX_GID_PKEY_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_gids
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|field
operator|>>
literal|4
operator|)
expr_stmt|;
name|dev_cap
operator|->
name|max_pkeys
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0xf
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_MAX_VL_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_vl
index|[
name|i
index|]
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_MAX_MACVLAN_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|log_max_macs
index|[
name|i
index|]
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|dev_cap
operator|->
name|log_max_vlans
index|[
name|i
index|]
operator|=
name|field
operator|>>
literal|4
expr_stmt|;
name|MLX4_GET
argument_list|(
name|dev_cap
operator|->
name|eth_mtu
index|[
name|i
index|]
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_ETH_MTU_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|dev_cap
operator|->
name|def_mac
index|[
name|i
index|]
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_MAC_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field32
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_TRANS_VENDOR_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|trans_type
index|[
name|i
index|]
operator|=
name|field32
operator|>>
literal|24
expr_stmt|;
name|dev_cap
operator|->
name|vendor_oui
index|[
name|i
index|]
operator|=
name|field32
operator|&
literal|0xffffff
expr_stmt|;
name|MLX4_GET
argument_list|(
name|dev_cap
operator|->
name|wavelength
index|[
name|i
index|]
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_WAVELENGTH_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|dev_cap
operator|->
name|trans_code
index|[
name|i
index|]
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_TRANS_CODE_OFFSET
argument_list|)
expr_stmt|;
block|}
block|}
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Base MM extensions: flags %08x, rsvd L_Key %08x\n"
argument_list|,
name|dev_cap
operator|->
name|bmme_flags
argument_list|,
name|dev_cap
operator|->
name|reserved_lkey
argument_list|)
expr_stmt|;
comment|/* 	 * Each UAR has 4 EQ doorbells; so if a UAR is reserved, then 	 * we can't use any EQs whose doorbell falls on that page, 	 * even if the EQ itself isn't reserved. 	 */
if|if
condition|(
name|dev_cap
operator|->
name|num_sys_eqs
operator|==
literal|0
condition|)
name|dev_cap
operator|->
name|reserved_eqs
operator|=
name|max
argument_list|(
name|dev_cap
operator|->
name|reserved_uars
operator|*
literal|4
argument_list|,
name|dev_cap
operator|->
name|reserved_eqs
argument_list|)
expr_stmt|;
else|else
name|dev_cap
operator|->
name|flags2
operator||=
name|MLX4_DEV_CAP_FLAG2_SYS_EQS
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max ICM size %lld MB\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|dev_cap
operator|->
name|max_icm_sz
operator|>>
literal|20
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max QPs: %d, reserved QPs: %d, entry size: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_qps
argument_list|,
name|dev_cap
operator|->
name|reserved_qps
argument_list|,
name|dev_cap
operator|->
name|qpc_entry_sz
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max SRQs: %d, reserved SRQs: %d, entry size: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_srqs
argument_list|,
name|dev_cap
operator|->
name|reserved_srqs
argument_list|,
name|dev_cap
operator|->
name|srq_entry_sz
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max CQs: %d, reserved CQs: %d, entry size: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_cqs
argument_list|,
name|dev_cap
operator|->
name|reserved_cqs
argument_list|,
name|dev_cap
operator|->
name|cqc_entry_sz
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Num sys EQs: %d, max EQs: %d, reserved EQs: %d, entry size: %d\n"
argument_list|,
name|dev_cap
operator|->
name|num_sys_eqs
argument_list|,
name|dev_cap
operator|->
name|max_eqs
argument_list|,
name|dev_cap
operator|->
name|reserved_eqs
argument_list|,
name|dev_cap
operator|->
name|eqc_entry_sz
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"reserved MPTs: %d, reserved MTTs: %d\n"
argument_list|,
name|dev_cap
operator|->
name|reserved_mrws
argument_list|,
name|dev_cap
operator|->
name|reserved_mtts
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max PDs: %d, reserved PDs: %d, reserved UARs: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_pds
argument_list|,
name|dev_cap
operator|->
name|reserved_pds
argument_list|,
name|dev_cap
operator|->
name|reserved_uars
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max QP/MCG: %d, reserved MGMs: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_pds
argument_list|,
name|dev_cap
operator|->
name|reserved_mgms
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max CQEs: %d, max WQEs: %d, max SRQ WQEs: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_cq_sz
argument_list|,
name|dev_cap
operator|->
name|max_qp_sz
argument_list|,
name|dev_cap
operator|->
name|max_srq_sz
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Local CA ACK delay: %d, max MTU: %d, port width cap: %d\n"
argument_list|,
name|dev_cap
operator|->
name|local_ca_ack_delay
argument_list|,
literal|128
operator|<<
name|dev_cap
operator|->
name|ib_mtu
index|[
literal|1
index|]
argument_list|,
name|dev_cap
operator|->
name|max_port_width
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max SQ desc size: %d, max SQ S/G: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_sq_desc_sz
argument_list|,
name|dev_cap
operator|->
name|max_sq_sg
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max RQ desc size: %d, max RQ S/G: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_rq_desc_sz
argument_list|,
name|dev_cap
operator|->
name|max_rq_sg
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max GSO size: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_gso_sz
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max basic counters: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_basic_counters
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max extended counters: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_extended_counters
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max RSS Table size: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_rss_tbl_sz
argument_list|)
expr_stmt|;
name|dump_dev_cap_flags
argument_list|(
name|dev
argument_list|,
name|dev_cap
operator|->
name|flags
argument_list|)
expr_stmt|;
name|dump_dev_cap_flags2
argument_list|(
name|dev
argument_list|,
name|dev_cap
operator|->
name|flags2
argument_list|)
expr_stmt|;
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_DEV_CAP_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|u64
name|flags
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|u8
name|field
decl_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|outbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_DEV_CAP
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
comment|/* add port mng change event capability unconditionally to slaves */
name|MLX4_GET
argument_list|(
name|flags
argument_list|,
name|outbox
operator|->
name|buf
argument_list|,
name|QUERY_DEV_CAP_EXT_FLAGS_OFFSET
argument_list|)
expr_stmt|;
name|flags
operator||=
name|MLX4_DEV_CAP_FLAG_PORT_MNG_CHG_EV
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|flags
argument_list|,
name|QUERY_DEV_CAP_EXT_FLAGS_OFFSET
argument_list|)
expr_stmt|;
comment|/* For guests, report Blueflame disabled */
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
operator|->
name|buf
argument_list|,
name|QUERY_DEV_CAP_BF_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|&=
literal|0x7f
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field
argument_list|,
name|QUERY_DEV_CAP_BF_OFFSET
argument_list|)
expr_stmt|;
comment|/* turn off device-managed steering capability if not enabled */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|!=
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
block|{
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
operator|->
name|buf
argument_list|,
name|QUERY_DEV_CAP_FLOW_STEERING_RANGE_EN_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|&=
literal|0x7f
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|field
argument_list|,
name|QUERY_DEV_CAP_FLOW_STEERING_RANGE_EN_OFFSET
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_PORT_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u64
name|def_mac
decl_stmt|;
name|u8
name|port_type
decl_stmt|;
name|u16
name|short_field
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|admin_link_state
decl_stmt|;
define|#
directive|define
name|MLX4_VF_PORT_NO_LINK_SENSE_MASK
value|0xE0
define|#
directive|define
name|MLX4_PORT_LINK_UP_MASK
value|0x80
define|#
directive|define
name|QUERY_PORT_CUR_MAX_PKEY_OFFSET
value|0x0c
define|#
directive|define
name|QUERY_PORT_CUR_MAX_GID_OFFSET
value|0x0e
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|outbox
operator|->
name|dma
argument_list|,
name|vhcr
operator|->
name|in_modifier
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
name|dev
operator|->
name|caps
operator|.
name|function
operator|!=
name|slave
condition|)
block|{
comment|/* set slave default_mac address to be zero MAC */
name|def_mac
operator|=
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_oper
index|[
name|slave
index|]
operator|.
name|vport
index|[
name|vhcr
operator|->
name|in_modifier
index|]
operator|.
name|state
operator|.
name|mac
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|def_mac
argument_list|,
name|QUERY_PORT_MAC_OFFSET
argument_list|)
expr_stmt|;
comment|/* get port type - currently only eth is enabled */
name|MLX4_GET
argument_list|(
name|port_type
argument_list|,
name|outbox
operator|->
name|buf
argument_list|,
name|QUERY_PORT_SUPPORTED_TYPE_OFFSET
argument_list|)
expr_stmt|;
comment|/* No link sensing allowed */
name|port_type
operator|&=
name|MLX4_VF_PORT_NO_LINK_SENSE_MASK
expr_stmt|;
comment|/* set port type to currently operating port type */
name|port_type
operator||=
operator|(
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|vhcr
operator|->
name|in_modifier
index|]
operator|&
literal|0x3
operator|)
expr_stmt|;
name|admin_link_state
operator|=
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|vf_oper
index|[
name|slave
index|]
operator|.
name|vport
index|[
name|vhcr
operator|->
name|in_modifier
index|]
operator|.
name|state
operator|.
name|link_state
expr_stmt|;
if|if
condition|(
name|IFLA_VF_LINK_STATE_ENABLE
operator|==
name|admin_link_state
condition|)
name|port_type
operator||=
name|MLX4_PORT_LINK_UP_MASK
expr_stmt|;
elseif|else
if|if
condition|(
name|IFLA_VF_LINK_STATE_DISABLE
operator|==
name|admin_link_state
condition|)
name|port_type
operator|&=
operator|~
name|MLX4_PORT_LINK_UP_MASK
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|port_type
argument_list|,
name|QUERY_PORT_SUPPORTED_TYPE_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|vhcr
operator|->
name|in_modifier
index|]
operator|==
name|MLX4_PORT_TYPE_ETH
condition|)
name|short_field
operator|=
name|mlx4_get_slave_num_gids
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|)
expr_stmt|;
else|else
name|short_field
operator|=
literal|1
expr_stmt|;
comment|/* slave max gids */
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|short_field
argument_list|,
name|QUERY_PORT_CUR_MAX_GID_OFFSET
argument_list|)
expr_stmt|;
name|short_field
operator|=
name|dev
operator|->
name|caps
operator|.
name|pkey_table_len
index|[
name|vhcr
operator|->
name|in_modifier
index|]
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|outbox
operator|->
name|buf
argument_list|,
name|short_field
argument_list|,
name|QUERY_PORT_CUR_MAX_PKEY_OFFSET
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_get_slave_pkey_gid_tbl_len
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|int
modifier|*
name|gid_tbl_len
parameter_list|,
name|int
modifier|*
name|pkey_tbl_len
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|outbox
decl_stmt|;
name|u16
name|field
decl_stmt|;
name|int
name|err
decl_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_CUR_MAX_GID_OFFSET
argument_list|)
expr_stmt|;
operator|*
name|gid_tbl_len
operator|=
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_CUR_MAX_PKEY_OFFSET
argument_list|)
expr_stmt|;
operator|*
name|pkey_tbl_len
operator|=
name|field
expr_stmt|;
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|mlx4_get_slave_pkey_gid_tbl_len
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_map_cmd
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u16
name|op
parameter_list|,
name|struct
name|mlx4_icm
modifier|*
name|icm
parameter_list|,
name|u64
name|virt
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|struct
name|mlx4_icm_iter
name|iter
decl_stmt|;
name|__be64
modifier|*
name|pages
decl_stmt|;
name|int
name|lg
decl_stmt|;
name|int
name|nent
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|ts
init|=
literal|0
decl_stmt|,
name|tc
init|=
literal|0
decl_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|memset
argument_list|(
name|mailbox
operator|->
name|buf
argument_list|,
literal|0
argument_list|,
name|MLX4_MAILBOX_SIZE
argument_list|)
expr_stmt|;
name|pages
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
for|for
control|(
name|mlx4_icm_first
argument_list|(
name|icm
argument_list|,
operator|&
name|iter
argument_list|)
init|;
operator|!
name|mlx4_icm_last
argument_list|(
operator|&
name|iter
argument_list|)
condition|;
name|mlx4_icm_next
argument_list|(
operator|&
name|iter
argument_list|)
control|)
block|{
comment|/* 		 * We have to pass pages that are aligned to their 		 * size, so find the least significant 1 in the 		 * address or size and use that as our log2 size. 		 */
name|lg
operator|=
name|ffs
argument_list|(
name|mlx4_icm_addr
argument_list|(
operator|&
name|iter
argument_list|)
operator||
name|mlx4_icm_size
argument_list|(
operator|&
name|iter
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lg
operator|<
name|MLX4_ICM_PAGE_SHIFT
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Got FW area not aligned to %d (%llx/%lx).\n"
argument_list|,
name|MLX4_ICM_PAGE_SIZE
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|mlx4_icm_addr
argument_list|(
operator|&
name|iter
argument_list|)
argument_list|,
name|mlx4_icm_size
argument_list|(
operator|&
name|iter
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mlx4_icm_size
argument_list|(
operator|&
name|iter
argument_list|)
operator|>>
name|lg
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|virt
operator|!=
operator|-
literal|1
condition|)
block|{
name|pages
index|[
name|nent
operator|*
literal|2
index|]
operator|=
name|cpu_to_be64
argument_list|(
name|virt
argument_list|)
expr_stmt|;
name|virt
operator|+=
literal|1
operator|<<
name|lg
expr_stmt|;
block|}
name|pages
index|[
name|nent
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
name|cpu_to_be64
argument_list|(
operator|(
name|mlx4_icm_addr
argument_list|(
operator|&
name|iter
argument_list|)
operator|+
operator|(
name|i
operator|<<
name|lg
operator|)
operator|)
operator||
operator|(
name|lg
operator|-
name|MLX4_ICM_PAGE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|ts
operator|+=
literal|1
operator|<<
operator|(
name|lg
operator|-
literal|10
operator|)
expr_stmt|;
operator|++
name|tc
expr_stmt|;
if|if
condition|(
operator|++
name|nent
operator|==
name|MLX4_MAILBOX_SIZE
operator|/
literal|16
condition|)
block|{
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|nent
argument_list|,
literal|0
argument_list|,
name|op
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|nent
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|nent
condition|)
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|nent
argument_list|,
literal|0
argument_list|,
name|op
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|MLX4_CMD_MAP_FA
case|:
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Mapped %d chunks/%d KB for FW.\n"
argument_list|,
name|tc
argument_list|,
name|ts
argument_list|)
expr_stmt|;
break|break;
case|case
name|MLX4_CMD_MAP_ICM_AUX
case|:
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Mapped %d chunks/%d KB for ICM aux.\n"
argument_list|,
name|tc
argument_list|,
name|ts
argument_list|)
expr_stmt|;
break|break;
case|case
name|MLX4_CMD_MAP_ICM
case|:
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Mapped %d chunks/%d KB at %llx for ICM.\n"
argument_list|,
name|tc
argument_list|,
name|ts
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|virt
operator|-
operator|(
name|ts
operator|<<
literal|10
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_MAP_FA
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_icm
modifier|*
name|icm
parameter_list|)
block|{
return|return
name|mlx4_map_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_CMD_MAP_FA
argument_list|,
name|icm
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_UNMAP_FA
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
return|return
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_UNMAP_FA
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_RUN_FW
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
return|return
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_RUN_FW
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_FW
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_fw
modifier|*
name|fw
init|=
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|fw
decl_stmt|;
name|struct
name|mlx4_cmd
modifier|*
name|cmd
init|=
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|cmd
decl_stmt|;
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|outbox
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|u64
name|fw_ver
decl_stmt|;
name|u16
name|cmd_if_rev
decl_stmt|;
name|u8
name|lg
decl_stmt|;
define|#
directive|define
name|QUERY_FW_OUT_SIZE
value|0x100
define|#
directive|define
name|QUERY_FW_VER_OFFSET
value|0x00
define|#
directive|define
name|QUERY_FW_PPF_ID
value|0x09
define|#
directive|define
name|QUERY_FW_CMD_IF_REV_OFFSET
value|0x0a
define|#
directive|define
name|QUERY_FW_MAX_CMD_OFFSET
value|0x0f
define|#
directive|define
name|QUERY_FW_ERR_START_OFFSET
value|0x30
define|#
directive|define
name|QUERY_FW_ERR_SIZE_OFFSET
value|0x38
define|#
directive|define
name|QUERY_FW_ERR_BAR_OFFSET
value|0x3c
define|#
directive|define
name|QUERY_FW_SIZE_OFFSET
value|0x00
define|#
directive|define
name|QUERY_FW_CLR_INT_BASE_OFFSET
value|0x20
define|#
directive|define
name|QUERY_FW_CLR_INT_BAR_OFFSET
value|0x28
define|#
directive|define
name|QUERY_FW_COMM_BASE_OFFSET
value|0x40
define|#
directive|define
name|QUERY_FW_COMM_BAR_OFFSET
value|0x48
define|#
directive|define
name|QUERY_FW_CLOCK_OFFSET
value|0x50
define|#
directive|define
name|QUERY_FW_CLOCK_BAR
value|0x58
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_FW
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|MLX4_GET
argument_list|(
name|fw_ver
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_VER_OFFSET
argument_list|)
expr_stmt|;
comment|/* 	 * FW subminor version is at more significant bits than minor 	 * version, so swap here. 	 */
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|=
operator|(
name|fw_ver
operator|&
literal|0xffff00000000ull
operator|)
operator||
operator|(
operator|(
name|fw_ver
operator|&
literal|0xffff0000ull
operator|)
operator|>>
literal|16
operator|)
operator||
operator|(
operator|(
name|fw_ver
operator|&
literal|0x0000ffffull
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|lg
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_PPF_ID
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|function
operator|=
name|lg
expr_stmt|;
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|MLX4_GET
argument_list|(
name|cmd_if_rev
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_CMD_IF_REV_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd_if_rev
operator|<
name|MLX4_COMMAND_INTERFACE_MIN_REV
operator|||
name|cmd_if_rev
operator|>
name|MLX4_COMMAND_INTERFACE_MAX_REV
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Installed FW has unsupported "
literal|"command interface revision %d.\n"
argument_list|,
name|cmd_if_rev
argument_list|)
expr_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"(Installed FW version is %d.%d.%03d)\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|>>
literal|32
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|>>
literal|16
argument_list|)
operator|&
literal|0xffff
argument_list|,
operator|(
name|int
operator|)
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"This driver version supports only revisions %d to %d.\n"
argument_list|,
name|MLX4_COMMAND_INTERFACE_MIN_REV
argument_list|,
name|MLX4_COMMAND_INTERFACE_MAX_REV
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|cmd_if_rev
operator|<
name|MLX4_COMMAND_INTERFACE_NEW_PORT_CMDS
condition|)
name|dev
operator|->
name|flags
operator||=
name|MLX4_FLAG_OLD_PORT_CMDS
expr_stmt|;
name|MLX4_GET
argument_list|(
name|lg
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_MAX_CMD_OFFSET
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|max_cmds
operator|=
literal|1
operator|<<
name|lg
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"FW version %d.%d.%03d (cmd intf rev %d), max commands %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|>>
literal|32
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|>>
literal|16
argument_list|)
operator|&
literal|0xffff
argument_list|,
operator|(
name|int
operator|)
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|&
literal|0xffff
argument_list|,
name|cmd_if_rev
argument_list|,
name|cmd
operator|->
name|max_cmds
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|catas_offset
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_ERR_START_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|catas_size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_ERR_SIZE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|catas_bar
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_ERR_BAR_OFFSET
argument_list|)
expr_stmt|;
name|fw
operator|->
name|catas_bar
operator|=
operator|(
name|fw
operator|->
name|catas_bar
operator|>>
literal|6
operator|)
operator|*
literal|2
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Catastrophic error buffer at 0x%llx, size 0x%x, BAR %d\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|fw
operator|->
name|catas_offset
argument_list|,
name|fw
operator|->
name|catas_size
argument_list|,
name|fw
operator|->
name|catas_bar
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|fw_pages
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_SIZE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|clr_int_base
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_CLR_INT_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|clr_int_bar
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_CLR_INT_BAR_OFFSET
argument_list|)
expr_stmt|;
name|fw
operator|->
name|clr_int_bar
operator|=
operator|(
name|fw
operator|->
name|clr_int_bar
operator|>>
literal|6
operator|)
operator|*
literal|2
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|comm_base
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_COMM_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|comm_bar
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_COMM_BAR_OFFSET
argument_list|)
expr_stmt|;
name|fw
operator|->
name|comm_bar
operator|=
operator|(
name|fw
operator|->
name|comm_bar
operator|>>
literal|6
operator|)
operator|*
literal|2
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Communication vector bar:%d offset:0x%llx\n"
argument_list|,
name|fw
operator|->
name|comm_bar
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|fw
operator|->
name|comm_base
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"FW size %d KB\n"
argument_list|,
name|fw
operator|->
name|fw_pages
operator|>>
literal|2
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|clock_offset
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_CLOCK_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|clock_bar
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_CLOCK_BAR
argument_list|)
expr_stmt|;
name|fw
operator|->
name|clock_bar
operator|=
operator|(
name|fw
operator|->
name|clock_bar
operator|>>
literal|6
operator|)
operator|*
literal|2
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Internal clock bar:%d offset:0x%llx\n"
argument_list|,
name|fw
operator|->
name|comm_bar
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|fw
operator|->
name|comm_base
argument_list|)
expr_stmt|;
comment|/* 	 * Round up number of system pages needed in case 	 * MLX4_ICM_PAGE_SIZE< PAGE_SIZE. 	 */
name|fw
operator|->
name|fw_pages
operator|=
name|ALIGN
argument_list|(
name|fw
operator|->
name|fw_pages
argument_list|,
name|PAGE_SIZE
operator|/
name|MLX4_ICM_PAGE_SIZE
argument_list|)
operator|>>
operator|(
name|PAGE_SHIFT
operator|-
name|MLX4_ICM_PAGE_SHIFT
operator|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Clear int @ %llx, BAR %d\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|fw
operator|->
name|clr_int_base
argument_list|,
name|fw
operator|->
name|clr_int_bar
argument_list|)
expr_stmt|;
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_FW_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|u8
modifier|*
name|outbuf
decl_stmt|;
name|int
name|err
decl_stmt|;
name|outbuf
operator|=
name|outbox
operator|->
name|buf
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|outbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_FW
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
comment|/* for slaves, set pci PPF ID to invalid and zero out everything 	 * else except FW version */
name|outbuf
index|[
literal|0
index|]
operator|=
name|outbuf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|outbuf
index|[
literal|8
index|]
argument_list|,
literal|0
argument_list|,
name|QUERY_FW_OUT_SIZE
operator|-
literal|8
argument_list|)
expr_stmt|;
name|outbuf
index|[
name|QUERY_FW_PPF_ID
index|]
operator|=
name|MLX4_INVALID_SLAVE_ID
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_board_id
parameter_list|(
name|void
modifier|*
name|vsd
parameter_list|,
name|char
modifier|*
name|board_id
parameter_list|,
name|char
modifier|*
name|vsdstr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
define|#
directive|define
name|VSD_OFFSET_SIG1
value|0x00
define|#
directive|define
name|VSD_OFFSET_SIG2
value|0xde
define|#
directive|define
name|VSD_OFFSET_MLX_BOARD_ID
value|0xd0
define|#
directive|define
name|VSD_OFFSET_TS_BOARD_ID
value|0x20
define|#
directive|define
name|VSD_LEN
value|0xd0
define|#
directive|define
name|VSD_SIGNATURE_TOPSPIN
value|0x5ad
name|memset
argument_list|(
name|vsdstr
argument_list|,
literal|0
argument_list|,
name|MLX4_VSD_LEN
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|VSD_LEN
operator|/
literal|4
condition|;
name|i
operator|++
control|)
operator|(
operator|(
name|u32
operator|*
operator|)
name|vsdstr
operator|)
index|[
name|i
index|]
operator|=
name|swab32
argument_list|(
operator|*
operator|(
name|u32
operator|*
operator|)
operator|(
name|vsd
operator|+
name|i
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|board_id
argument_list|,
literal|0
argument_list|,
name|MLX4_BOARD_ID_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|be16_to_cpup
argument_list|(
name|vsd
operator|+
name|VSD_OFFSET_SIG1
argument_list|)
operator|==
name|VSD_SIGNATURE_TOPSPIN
operator|&&
name|be16_to_cpup
argument_list|(
name|vsd
operator|+
name|VSD_OFFSET_SIG2
argument_list|)
operator|==
name|VSD_SIGNATURE_TOPSPIN
condition|)
block|{
name|strlcpy
argument_list|(
name|board_id
argument_list|,
name|vsd
operator|+
name|VSD_OFFSET_TS_BOARD_ID
argument_list|,
name|MLX4_BOARD_ID_LEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The board ID is a string but the firmware byte 		 * swaps each 4-byte word before passing it back to 		 * us.  Therefore we need to swab it before printing. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
operator|(
operator|(
name|u32
operator|*
operator|)
name|board_id
operator|)
index|[
name|i
index|]
operator|=
name|swab32
argument_list|(
operator|*
operator|(
name|u32
operator|*
operator|)
operator|(
name|vsd
operator|+
name|VSD_OFFSET_MLX_BOARD_ID
operator|+
name|i
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_ADAPTER
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|outbox
decl_stmt|;
name|int
name|err
decl_stmt|;
define|#
directive|define
name|QUERY_ADAPTER_OUT_SIZE
value|0x100
define|#
directive|define
name|QUERY_ADAPTER_INTA_PIN_OFFSET
value|0x10
define|#
directive|define
name|QUERY_ADAPTER_VSD_OFFSET
value|0x20
define|#
directive|define
name|QUERY_ADAPTER_VSD_VENDOR_ID_OFFSET
value|0x1e
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_ADAPTER
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|MLX4_GET
argument_list|(
name|adapter
operator|->
name|inta_pin
argument_list|,
name|outbox
argument_list|,
name|QUERY_ADAPTER_INTA_PIN_OFFSET
argument_list|)
expr_stmt|;
name|adapter
operator|->
name|vsd_vendor_id
operator|=
name|be16_to_cpup
argument_list|(
operator|(
name|u16
operator|*
operator|)
name|outbox
operator|+
name|QUERY_ADAPTER_VSD_VENDOR_ID_OFFSET
operator|/
literal|2
argument_list|)
expr_stmt|;
name|get_board_id
argument_list|(
name|outbox
operator|+
name|QUERY_ADAPTER_VSD_OFFSET
operator|/
literal|4
argument_list|,
name|adapter
operator|->
name|board_id
argument_list|,
name|adapter
operator|->
name|vsd
argument_list|)
expr_stmt|;
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_INIT_HCA
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_init_hca_param
modifier|*
name|param
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|__be32
modifier|*
name|inbox
decl_stmt|;
name|u32
name|mw_enable
decl_stmt|;
name|int
name|err
decl_stmt|;
define|#
directive|define
name|INIT_HCA_IN_SIZE
value|0x200
define|#
directive|define
name|INIT_HCA_DRV_NAME_FOR_FW_MAX_SIZE
value|64
define|#
directive|define
name|INIT_HCA_VERSION_OFFSET
value|0x000
define|#
directive|define
name|INIT_HCA_VERSION
value|2
define|#
directive|define
name|INIT_HCA_CACHELINE_SZ_OFFSET
value|0x0e
define|#
directive|define
name|INIT_HCA_FLAGS_OFFSET
value|0x014
define|#
directive|define
name|INIT_HCA_RECOVERABLE_ERROR_EVENT_OFFSET
value|0x018
define|#
directive|define
name|INIT_HCA_QPC_OFFSET
value|0x020
define|#
directive|define
name|INIT_HCA_QPC_BASE_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x10)
define|#
directive|define
name|INIT_HCA_LOG_QP_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x17)
define|#
directive|define
name|INIT_HCA_SRQC_BASE_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x28)
define|#
directive|define
name|INIT_HCA_LOG_SRQ_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x2f)
define|#
directive|define
name|INIT_HCA_CQC_BASE_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x30)
define|#
directive|define
name|INIT_HCA_LOG_CQ_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x37)
define|#
directive|define
name|INIT_HCA_EQE_CQE_OFFSETS
value|(INIT_HCA_QPC_OFFSET + 0x38)
define|#
directive|define
name|INIT_HCA_ALTC_BASE_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x40)
define|#
directive|define
name|INIT_HCA_AUXC_BASE_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x50)
define|#
directive|define
name|INIT_HCA_EQC_BASE_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x60)
define|#
directive|define
name|INIT_HCA_LOG_EQ_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x67)
define|#
directive|define
name|INIT_HCA_NUM_SYS_EQS_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x6a)
define|#
directive|define
name|INIT_HCA_RDMARC_BASE_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x70)
define|#
directive|define
name|INIT_HCA_LOG_RD_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x77)
define|#
directive|define
name|INIT_HCA_MCAST_OFFSET
value|0x0c0
define|#
directive|define
name|INIT_HCA_MC_BASE_OFFSET
value|(INIT_HCA_MCAST_OFFSET + 0x00)
define|#
directive|define
name|INIT_HCA_LOG_MC_ENTRY_SZ_OFFSET
value|(INIT_HCA_MCAST_OFFSET + 0x12)
define|#
directive|define
name|INIT_HCA_LOG_MC_HASH_SZ_OFFSET
value|(INIT_HCA_MCAST_OFFSET + 0x16)
define|#
directive|define
name|INIT_HCA_UC_STEERING_OFFSET
value|(INIT_HCA_MCAST_OFFSET + 0x18)
define|#
directive|define
name|INIT_HCA_LOG_MC_TABLE_SZ_OFFSET
value|(INIT_HCA_MCAST_OFFSET + 0x1b)
define|#
directive|define
name|INIT_HCA_DEVICE_MANAGED_FLOW_STEERING_EN
value|0x6
define|#
directive|define
name|INIT_HCA_DRIVER_VERSION_OFFSET
value|0x140
define|#
directive|define
name|INIT_HCA_FS_PARAM_OFFSET
value|0x1d0
define|#
directive|define
name|INIT_HCA_FS_BASE_OFFSET
value|(INIT_HCA_FS_PARAM_OFFSET + 0x00)
define|#
directive|define
name|INIT_HCA_FS_LOG_ENTRY_SZ_OFFSET
value|(INIT_HCA_FS_PARAM_OFFSET + 0x12)
define|#
directive|define
name|INIT_HCA_FS_LOG_TABLE_SZ_OFFSET
value|(INIT_HCA_FS_PARAM_OFFSET + 0x1b)
define|#
directive|define
name|INIT_HCA_FS_ETH_BITS_OFFSET
value|(INIT_HCA_FS_PARAM_OFFSET + 0x21)
define|#
directive|define
name|INIT_HCA_FS_ETH_NUM_ADDRS_OFFSET
value|(INIT_HCA_FS_PARAM_OFFSET + 0x22)
define|#
directive|define
name|INIT_HCA_FS_IB_BITS_OFFSET
value|(INIT_HCA_FS_PARAM_OFFSET + 0x25)
define|#
directive|define
name|INIT_HCA_FS_IB_NUM_ADDRS_OFFSET
value|(INIT_HCA_FS_PARAM_OFFSET + 0x26)
define|#
directive|define
name|INIT_HCA_TPT_OFFSET
value|0x0f0
define|#
directive|define
name|INIT_HCA_DMPT_BASE_OFFSET
value|(INIT_HCA_TPT_OFFSET + 0x00)
define|#
directive|define
name|INIT_HCA_TPT_MW_OFFSET
value|(INIT_HCA_TPT_OFFSET + 0x08)
define|#
directive|define
name|INIT_HCA_TPT_MW_ENABLE
value|(1<< 31)
define|#
directive|define
name|INIT_HCA_LOG_MPT_SZ_OFFSET
value|(INIT_HCA_TPT_OFFSET + 0x0b)
define|#
directive|define
name|INIT_HCA_MTT_BASE_OFFSET
value|(INIT_HCA_TPT_OFFSET + 0x10)
define|#
directive|define
name|INIT_HCA_CMPT_BASE_OFFSET
value|(INIT_HCA_TPT_OFFSET + 0x18)
define|#
directive|define
name|INIT_HCA_UAR_OFFSET
value|0x120
define|#
directive|define
name|INIT_HCA_LOG_UAR_SZ_OFFSET
value|(INIT_HCA_UAR_OFFSET + 0x0a)
define|#
directive|define
name|INIT_HCA_UAR_PAGE_SZ_OFFSET
value|(INIT_HCA_UAR_OFFSET + 0x0b)
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|inbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|memset
argument_list|(
name|inbox
argument_list|,
literal|0
argument_list|,
name|INIT_HCA_IN_SIZE
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|u8
operator|*
operator|)
name|mailbox
operator|->
name|buf
operator|+
name|INIT_HCA_VERSION_OFFSET
operator|)
operator|=
name|INIT_HCA_VERSION
expr_stmt|;
operator|*
operator|(
operator|(
name|u8
operator|*
operator|)
name|mailbox
operator|->
name|buf
operator|+
name|INIT_HCA_CACHELINE_SZ_OFFSET
operator|)
operator|=
operator|(
operator|(
name|ilog2
argument_list|(
name|cache_line_size
argument_list|()
argument_list|)
operator|-
literal|4
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
literal|1
operator|<<
literal|4
operator|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__LITTLE_ENDIAN
argument_list|)
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_FLAGS_OFFSET
operator|/
literal|4
operator|)
operator|&=
operator|~
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|1
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__BIG_ENDIAN
argument_list|)
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_FLAGS_OFFSET
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
error|Host endianness not defined
endif|#
directive|endif
comment|/* Check port for UD address vector: */
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_FLAGS_OFFSET
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Enable IPoIB checksumming if we can: */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_IPOIB_CSUM
condition|)
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_FLAGS_OFFSET
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|3
argument_list|)
expr_stmt|;
comment|/* Enable QoS support if module parameter set */
if|if
condition|(
name|enable_qos
condition|)
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_FLAGS_OFFSET
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|2
argument_list|)
expr_stmt|;
comment|/* Enable fast drop performance optimization */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|fast_drop
condition|)
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_FLAGS_OFFSET
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|7
argument_list|)
expr_stmt|;
comment|/* enable counters */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_COUNTERS
condition|)
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_FLAGS_OFFSET
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|4
argument_list|)
expr_stmt|;
comment|/* CX3 is capable of extending CQEs\EQEs from 32 to 64 bytes */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_64B_EQE
condition|)
block|{
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_EQE_CQE_OFFSETS
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|29
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|eqe_size
operator|=
literal|64
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|eqe_factor
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|caps
operator|.
name|eqe_size
operator|=
literal|32
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|eqe_factor
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_64B_CQE
condition|)
block|{
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_EQE_CQE_OFFSETS
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|30
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|cqe_size
operator|=
literal|64
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|userspace_caps
operator||=
name|MLX4_USER_DEV_CAP_64B_CQE
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|caps
operator|.
name|cqe_size
operator|=
literal|32
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_RECOVERABLE_ERROR_EVENT
condition|)
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_RECOVERABLE_ERROR_EVENT_OFFSET
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|31
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_DRIVER_VERSION_TO_FW
condition|)
block|{
name|strncpy
argument_list|(
operator|(
name|u8
operator|*
operator|)
name|mailbox
operator|->
name|buf
operator|+
name|INIT_HCA_DRIVER_VERSION_OFFSET
argument_list|,
name|DRV_NAME_FOR_FW
argument_list|,
name|INIT_HCA_DRV_NAME_FOR_FW_MAX_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Reporting Driver Version to FW: %s\n"
argument_list|,
operator|(
name|u8
operator|*
operator|)
name|mailbox
operator|->
name|buf
operator|+
name|INIT_HCA_DRIVER_VERSION_OFFSET
argument_list|)
expr_stmt|;
block|}
comment|/* QPC/EEC/CQC/EQC/RDMARC attributes */
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|qpc_base
argument_list|,
name|INIT_HCA_QPC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_num_qps
argument_list|,
name|INIT_HCA_LOG_QP_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|srqc_base
argument_list|,
name|INIT_HCA_SRQC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_num_srqs
argument_list|,
name|INIT_HCA_LOG_SRQ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|cqc_base
argument_list|,
name|INIT_HCA_CQC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_num_cqs
argument_list|,
name|INIT_HCA_LOG_CQ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|altc_base
argument_list|,
name|INIT_HCA_ALTC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|auxc_base
argument_list|,
name|INIT_HCA_AUXC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|eqc_base
argument_list|,
name|INIT_HCA_EQC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_num_eqs
argument_list|,
name|INIT_HCA_LOG_EQ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|num_sys_eqs
argument_list|,
name|INIT_HCA_NUM_SYS_EQS_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|rdmarc_base
argument_list|,
name|INIT_HCA_RDMARC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_rd_per_qp
argument_list|,
name|INIT_HCA_LOG_RD_OFFSET
argument_list|)
expr_stmt|;
comment|/* steering attributes */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|==
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
block|{
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_FLAGS_OFFSET
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
name|INIT_HCA_DEVICE_MANAGED_FLOW_STEERING_EN
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|mc_base
argument_list|,
name|INIT_HCA_FS_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_mc_entry_sz
argument_list|,
name|INIT_HCA_FS_LOG_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_mc_table_sz
argument_list|,
name|INIT_HCA_FS_LOG_TABLE_SZ_OFFSET
argument_list|)
expr_stmt|;
comment|/* Enable Ethernet flow steering 		 * with udp unicast and tcp unicast 		 */
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
call|(
name|u8
call|)
argument_list|(
name|MLX4_FS_UDP_UC_EN
operator||
name|MLX4_FS_TCP_UC_EN
argument_list|)
argument_list|,
name|INIT_HCA_FS_ETH_BITS_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
operator|(
name|u16
operator|)
name|MLX4_FS_NUM_OF_L2_ADDR
argument_list|,
name|INIT_HCA_FS_ETH_NUM_ADDRS_OFFSET
argument_list|)
expr_stmt|;
comment|/* Enable IPoIB flow steering 		 * with udp unicast and tcp unicast 		 */
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
call|(
name|u8
call|)
argument_list|(
name|MLX4_FS_UDP_UC_EN
operator||
name|MLX4_FS_TCP_UC_EN
argument_list|)
argument_list|,
name|INIT_HCA_FS_IB_BITS_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
operator|(
name|u16
operator|)
name|MLX4_FS_NUM_OF_L2_ADDR
argument_list|,
name|INIT_HCA_FS_IB_NUM_ADDRS_OFFSET
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|mc_base
argument_list|,
name|INIT_HCA_MC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_mc_entry_sz
argument_list|,
name|INIT_HCA_LOG_MC_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_mc_hash_sz
argument_list|,
name|INIT_HCA_LOG_MC_HASH_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_mc_table_sz
argument_list|,
name|INIT_HCA_LOG_MC_TABLE_SZ_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|==
name|MLX4_STEERING_MODE_B0
condition|)
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
call|(
name|u8
call|)
argument_list|(
literal|1
operator|<<
literal|3
argument_list|)
argument_list|,
name|INIT_HCA_UC_STEERING_OFFSET
argument_list|)
expr_stmt|;
block|}
comment|/* TPT attributes */
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|dmpt_base
argument_list|,
name|INIT_HCA_DMPT_BASE_OFFSET
argument_list|)
expr_stmt|;
name|mw_enable
operator|=
name|param
operator|->
name|mw_enable
condition|?
name|INIT_HCA_TPT_MW_ENABLE
else|:
literal|0
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|mw_enable
argument_list|,
name|INIT_HCA_TPT_MW_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_mpt_sz
argument_list|,
name|INIT_HCA_LOG_MPT_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|mtt_base
argument_list|,
name|INIT_HCA_MTT_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|cmpt_base
argument_list|,
name|INIT_HCA_CMPT_BASE_OFFSET
argument_list|)
expr_stmt|;
comment|/* UAR attributes */
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|uar_page_sz
argument_list|,
name|INIT_HCA_UAR_PAGE_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_uar_sz
argument_list|,
name|INIT_HCA_LOG_UAR_SZ_OFFSET
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_INIT_HCA
argument_list|,
literal|10000
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"INIT_HCA returns %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_HCA
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_init_hca_param
modifier|*
name|param
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|__be32
modifier|*
name|outbox
decl_stmt|;
name|u32
name|dword_field
decl_stmt|;
name|u32
name|mw_enable
decl_stmt|;
name|int
name|err
decl_stmt|;
name|u8
name|byte_field
decl_stmt|;
define|#
directive|define
name|QUERY_HCA_GLOBAL_CAPS_OFFSET
value|0x04
define|#
directive|define
name|QUERY_HCA_CORE_CLOCK_OFFSET
value|0x0c
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_HCA
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|global_caps
argument_list|,
name|outbox
argument_list|,
name|QUERY_HCA_GLOBAL_CAPS_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|hca_core_clock
argument_list|,
name|outbox
argument_list|,
name|QUERY_HCA_CORE_CLOCK_OFFSET
argument_list|)
expr_stmt|;
comment|/* QPC/EEC/CQC/EQC/RDMARC attributes */
name|MLX4_GET
argument_list|(
name|param
operator|->
name|qpc_base
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_QPC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|log_num_qps
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_LOG_QP_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|srqc_base
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_SRQC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|log_num_srqs
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_LOG_SRQ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|cqc_base
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_CQC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|log_num_cqs
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_LOG_CQ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|altc_base
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_ALTC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|auxc_base
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_AUXC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|eqc_base
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_EQC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|log_num_eqs
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_LOG_EQ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|num_sys_eqs
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_NUM_SYS_EQS_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|rdmarc_base
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_RDMARC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|log_rd_per_qp
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_LOG_RD_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|dword_field
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_FLAGS_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|dword_field
operator|&
operator|(
literal|1
operator|<<
name|INIT_HCA_DEVICE_MANAGED_FLOW_STEERING_EN
operator|)
condition|)
block|{
name|param
operator|->
name|steering_mode
operator|=
name|MLX4_STEERING_MODE_DEVICE_MANAGED
expr_stmt|;
block|}
else|else
block|{
name|MLX4_GET
argument_list|(
name|byte_field
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_UC_STEERING_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte_field
operator|&
literal|0x8
condition|)
name|param
operator|->
name|steering_mode
operator|=
name|MLX4_STEERING_MODE_B0
expr_stmt|;
else|else
name|param
operator|->
name|steering_mode
operator|=
name|MLX4_STEERING_MODE_A0
expr_stmt|;
block|}
comment|/* steering attributes */
if|if
condition|(
name|param
operator|->
name|steering_mode
operator|==
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
block|{
name|MLX4_GET
argument_list|(
name|param
operator|->
name|mc_base
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_FS_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|log_mc_entry_sz
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_FS_LOG_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|log_mc_table_sz
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_FS_LOG_TABLE_SZ_OFFSET
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MLX4_GET
argument_list|(
name|param
operator|->
name|mc_base
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_MC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|log_mc_entry_sz
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_LOG_MC_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|log_mc_hash_sz
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_LOG_MC_HASH_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|log_mc_table_sz
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_LOG_MC_TABLE_SZ_OFFSET
argument_list|)
expr_stmt|;
block|}
comment|/* CX3 is capable of extending CQEs\EQEs from 32 to 64 bytes */
name|MLX4_GET
argument_list|(
name|byte_field
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_EQE_CQE_OFFSETS
argument_list|)
expr_stmt|;
if|if
condition|(
name|byte_field
operator|&
literal|0x20
condition|)
comment|/* 64-bytes eqe enabled */
name|param
operator|->
name|dev_cap_enabled
operator||=
name|MLX4_DEV_CAP_64B_EQE_ENABLED
expr_stmt|;
if|if
condition|(
name|byte_field
operator|&
literal|0x40
condition|)
comment|/* 64-bytes cqe enabled */
name|param
operator|->
name|dev_cap_enabled
operator||=
name|MLX4_DEV_CAP_64B_CQE_ENABLED
expr_stmt|;
comment|/* TPT attributes */
name|MLX4_GET
argument_list|(
name|param
operator|->
name|dmpt_base
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_DMPT_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|mw_enable
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_TPT_MW_OFFSET
argument_list|)
expr_stmt|;
name|param
operator|->
name|mw_enable
operator|=
operator|(
name|mw_enable
operator|&
name|INIT_HCA_TPT_MW_ENABLE
operator|)
operator|==
name|INIT_HCA_TPT_MW_ENABLE
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|log_mpt_sz
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_LOG_MPT_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|mtt_base
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_MTT_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|cmpt_base
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_CMPT_BASE_OFFSET
argument_list|)
expr_stmt|;
comment|/* UAR attributes */
name|MLX4_GET
argument_list|(
name|param
operator|->
name|uar_page_sz
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_UAR_PAGE_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|param
operator|->
name|log_uar_sz
argument_list|,
name|outbox
argument_list|,
name|INIT_HCA_LOG_UAR_SZ_OFFSET
argument_list|)
expr_stmt|;
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* for IB-type ports only in SRIOV mode. Checks that both proxy QP0  * and real QP0 are active, so that the paravirtualized QP0 is ready  * to operate */
end_comment

begin_function
specifier|static
name|int
name|check_qp0_state
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|function
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
comment|/* irrelevant if not infiniband */
if|if
condition|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|qp0_state
index|[
name|port
index|]
operator|.
name|proxy_qp0_active
operator|&&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|qp0_state
index|[
name|port
index|]
operator|.
name|qp0_active
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx4_INIT_PORT_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|port
init|=
name|vhcr
operator|->
name|in_modifier
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
operator|.
name|init_port_mask
operator|&
operator|(
literal|1
operator|<<
name|port
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|port_mask
index|[
name|port
index|]
operator|!=
name|MLX4_PORT_TYPE_IB
condition|)
block|{
comment|/* Enable port only if it was previously disabled */
if|if
condition|(
operator|!
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|init_port_ref
index|[
name|port
index|]
condition|)
block|{
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_INIT_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
block|}
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
operator|.
name|init_port_mask
operator||=
operator|(
literal|1
operator|<<
name|port
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|slave
operator|==
name|mlx4_master_func_num
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|check_qp0_state
argument_list|(
name|dev
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
operator|&&
operator|!
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|qp0_state
index|[
name|port
index|]
operator|.
name|port_active
condition|)
block|{
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_INIT_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|qp0_state
index|[
name|port
index|]
operator|.
name|port_active
operator|=
literal|1
expr_stmt|;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
operator|.
name|init_port_mask
operator||=
operator|(
literal|1
operator|<<
name|port
operator|)
expr_stmt|;
block|}
block|}
else|else
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
operator|.
name|init_port_mask
operator||=
operator|(
literal|1
operator|<<
name|port
operator|)
expr_stmt|;
block|}
operator|++
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|init_port_ref
index|[
name|port
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx4_INIT_PORT
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|inbox
decl_stmt|;
name|int
name|err
decl_stmt|;
name|u32
name|flags
decl_stmt|;
name|u16
name|field
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_OLD_PORT_CMDS
condition|)
block|{
define|#
directive|define
name|INIT_PORT_IN_SIZE
value|256
define|#
directive|define
name|INIT_PORT_FLAGS_OFFSET
value|0x00
define|#
directive|define
name|INIT_PORT_FLAG_SIG
value|(1<< 18)
define|#
directive|define
name|INIT_PORT_FLAG_NG
value|(1<< 17)
define|#
directive|define
name|INIT_PORT_FLAG_G0
value|(1<< 16)
define|#
directive|define
name|INIT_PORT_VL_SHIFT
value|4
define|#
directive|define
name|INIT_PORT_PORT_WIDTH_SHIFT
value|8
define|#
directive|define
name|INIT_PORT_MTU_OFFSET
value|0x04
define|#
directive|define
name|INIT_PORT_MAX_GID_OFFSET
value|0x06
define|#
directive|define
name|INIT_PORT_MAX_PKEY_OFFSET
value|0x0a
define|#
directive|define
name|INIT_PORT_GUID0_OFFSET
value|0x10
define|#
directive|define
name|INIT_PORT_NODE_GUID_OFFSET
value|0x18
define|#
directive|define
name|INIT_PORT_SI_GUID_OFFSET
value|0x20
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|inbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|memset
argument_list|(
name|inbox
argument_list|,
literal|0
argument_list|,
name|INIT_PORT_IN_SIZE
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|flags
operator||=
operator|(
name|dev
operator|->
name|caps
operator|.
name|vl_cap
index|[
name|port
index|]
operator|&
literal|0xf
operator|)
operator|<<
name|INIT_PORT_VL_SHIFT
expr_stmt|;
name|flags
operator||=
operator|(
name|dev
operator|->
name|caps
operator|.
name|port_width_cap
index|[
name|port
index|]
operator|&
literal|0xf
operator|)
operator|<<
name|INIT_PORT_PORT_WIDTH_SHIFT
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|flags
argument_list|,
name|INIT_PORT_FLAGS_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|=
literal|128
operator|<<
name|dev
operator|->
name|caps
operator|.
name|ib_mtu_cap
index|[
name|port
index|]
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|field
argument_list|,
name|INIT_PORT_MTU_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|=
name|dev
operator|->
name|caps
operator|.
name|gid_table_len
index|[
name|port
index|]
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|field
argument_list|,
name|INIT_PORT_MAX_GID_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|=
name|dev
operator|->
name|caps
operator|.
name|pkey_table_len
index|[
name|port
index|]
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|field
argument_list|,
name|INIT_PORT_MAX_PKEY_OFFSET
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_INIT_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
block|}
else|else
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_INIT_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_INIT_PORT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_CLOSE_PORT_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|port
init|=
name|vhcr
operator|->
name|in_modifier
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
operator|.
name|init_port_mask
operator|&
operator|(
literal|1
operator|<<
name|port
operator|)
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|port_mask
index|[
name|port
index|]
operator|!=
name|MLX4_PORT_TYPE_IB
condition|)
block|{
if|if
condition|(
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|init_port_ref
index|[
name|port
index|]
operator|==
literal|1
condition|)
block|{
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_CLOSE_PORT
argument_list|,
literal|1000
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
block|}
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
operator|.
name|init_port_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|port
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* infiniband port */
if|if
condition|(
name|slave
operator|==
name|mlx4_master_func_num
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|qp0_state
index|[
name|port
index|]
operator|.
name|qp0_active
operator|&&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|qp0_state
index|[
name|port
index|]
operator|.
name|port_active
condition|)
block|{
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_CLOSE_PORT
argument_list|,
literal|1000
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
operator|.
name|init_port_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|port
operator|)
expr_stmt|;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|qp0_state
index|[
name|port
index|]
operator|.
name|port_active
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
operator|.
name|init_port_mask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|port
operator|)
expr_stmt|;
block|}
operator|--
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|init_port_ref
index|[
name|port
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx4_CLOSE_PORT
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|)
block|{
return|return
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_CLOSE_PORT
argument_list|,
literal|1000
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_CLOSE_PORT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_CLOSE_HCA
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|panic
parameter_list|)
block|{
return|return
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|panic
argument_list|,
name|MLX4_CMD_CLOSE_HCA
argument_list|,
literal|1000
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_SET_ICM_SIZE
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|icm_size
parameter_list|,
name|u64
modifier|*
name|aux_pages
parameter_list|)
block|{
name|int
name|ret
init|=
name|mlx4_cmd_imm
argument_list|(
name|dev
argument_list|,
name|icm_size
argument_list|,
name|aux_pages
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_SET_ICM_SIZE
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/* 	 * Round up number of system pages needed in case 	 * MLX4_ICM_PAGE_SIZE< PAGE_SIZE. 	 */
operator|*
name|aux_pages
operator|=
name|ALIGN
argument_list|(
operator|*
name|aux_pages
argument_list|,
name|PAGE_SIZE
operator|/
name|MLX4_ICM_PAGE_SIZE
argument_list|)
operator|>>
operator|(
name|PAGE_SHIFT
operator|-
name|MLX4_ICM_PAGE_SHIFT
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx4_NOP
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
comment|/* Input modifier of 0x1f means "finish as soon as possible." */
return|return
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|0x1f
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_NOP
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_query_diag_counters
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|array_length
parameter_list|,
name|u8
name|op_modifier
parameter_list|,
name|u32
name|in_offset
index|[]
parameter_list|,
name|u32
name|counter_out
index|[]
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|outbox
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|ret
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
name|op_modifier
argument_list|,
name|MLX4_CMD_DIAG_RPRT
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|array_length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|in_offset
index|[
name|i
index|]
operator|>
name|MLX4_MAILBOX_SIZE
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|MLX4_GET
argument_list|(
name|counter_out
index|[
name|i
index|]
argument_list|,
name|outbox
argument_list|,
name|in_offset
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_query_diag_counters
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_MOD_STAT_CFG_wrapper
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|struct
name|mlx4_vhcr
modifier|*
name|vhcr
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|inbox
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|outbox
parameter_list|,
name|struct
name|mlx4_cmd_info
modifier|*
name|cmd
parameter_list|)
block|{
return|return
operator|-
name|EPERM
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MLX4_WOL_SETUP_MODE
value|(5<< 28)
end_define

begin_function
name|int
name|mlx4_wol_read
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
modifier|*
name|config
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|u32
name|in_mod
init|=
name|MLX4_WOL_SETUP_MODE
operator||
name|port
operator|<<
literal|8
decl_stmt|;
return|return
name|mlx4_cmd_imm
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|config
argument_list|,
name|in_mod
argument_list|,
literal|0x3
argument_list|,
name|MLX4_CMD_MOD_STAT_CFG
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_wol_read
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_wol_write
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|config
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|u32
name|in_mod
init|=
name|MLX4_WOL_SETUP_MODE
operator||
name|port
operator|<<
literal|8
decl_stmt|;
return|return
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|config
argument_list|,
name|in_mod
argument_list|,
literal|0x1
argument_list|,
name|MLX4_CMD_MOD_STAT_CFG
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_wol_write
argument_list|)
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
block|{
name|ADD_TO_MCG
init|=
literal|0x26
block|, }
enum|;
end_enum

begin_function
name|void
name|mlx4_opreq_action
parameter_list|(
name|struct
name|work_struct
modifier|*
name|work
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|container_of
argument_list|(
name|work
argument_list|,
expr|struct
name|mlx4_priv
argument_list|,
name|opreq_task
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
operator|&
name|priv
operator|->
name|dev
decl_stmt|;
name|int
name|num_tasks
init|=
name|atomic_read
argument_list|(
operator|&
name|priv
operator|->
name|opreq_count
argument_list|)
decl_stmt|;
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|struct
name|mlx4_mgm
modifier|*
name|mgm
decl_stmt|;
name|u32
modifier|*
name|outbox
decl_stmt|;
name|u32
name|modifier
decl_stmt|;
name|u16
name|token
decl_stmt|;
name|u16
name|type_m
decl_stmt|;
name|u16
name|type
decl_stmt|;
name|int
name|err
decl_stmt|;
name|u32
name|num_qps
decl_stmt|;
name|struct
name|mlx4_qp
name|qp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u8
name|rem_mcg
decl_stmt|;
name|u8
name|prot
decl_stmt|;
define|#
directive|define
name|GET_OP_REQ_MODIFIER_OFFSET
value|0x08
define|#
directive|define
name|GET_OP_REQ_TOKEN_OFFSET
value|0x14
define|#
directive|define
name|GET_OP_REQ_TYPE_OFFSET
value|0x1a
define|#
directive|define
name|GET_OP_REQ_DATA_OFFSET
value|0x20
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to allocate mailbox for GET_OP_REQ\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
while|while
condition|(
name|num_tasks
condition|)
block|{
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_GET_OP_REQ
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to retreive required operation: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return;
block|}
name|MLX4_GET
argument_list|(
name|modifier
argument_list|,
name|outbox
argument_list|,
name|GET_OP_REQ_MODIFIER_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|token
argument_list|,
name|outbox
argument_list|,
name|GET_OP_REQ_TOKEN_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|type
argument_list|,
name|outbox
argument_list|,
name|GET_OP_REQ_TYPE_OFFSET
argument_list|)
expr_stmt|;
name|type_m
operator|=
name|type
operator|>>
literal|12
expr_stmt|;
name|type
operator|&=
literal|0xfff
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ADD_TO_MCG
case|:
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|==
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"ADD MCG operation is not supported in "
literal|"DEVICE_MANAGED steerign mode\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|EPERM
expr_stmt|;
break|break;
block|}
name|mgm
operator|=
operator|(
expr|struct
name|mlx4_mgm
operator|*
operator|)
operator|(
operator|(
name|u8
operator|*
operator|)
operator|(
name|outbox
operator|)
operator|+
name|GET_OP_REQ_DATA_OFFSET
operator|)
expr_stmt|;
name|num_qps
operator|=
name|be32_to_cpu
argument_list|(
name|mgm
operator|->
name|members_count
argument_list|)
operator|&
name|MGM_QPN_MASK
expr_stmt|;
name|rem_mcg
operator|=
operator|(
operator|(
name|u8
operator|*
operator|)
operator|(
operator|&
name|mgm
operator|->
name|members_count
operator|)
operator|)
index|[
literal|0
index|]
operator|&
literal|1
expr_stmt|;
name|prot
operator|=
operator|(
operator|(
name|u8
operator|*
operator|)
operator|(
operator|&
name|mgm
operator|->
name|members_count
operator|)
operator|)
index|[
literal|0
index|]
operator|>>
literal|6
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_qps
condition|;
name|i
operator|++
control|)
block|{
name|qp
operator|.
name|qpn
operator|=
name|be32_to_cpu
argument_list|(
name|mgm
operator|->
name|qp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|rem_mcg
condition|)
name|err
operator|=
name|mlx4_multicast_detach
argument_list|(
name|dev
argument_list|,
operator|&
name|qp
argument_list|,
name|mgm
operator|->
name|gid
argument_list|,
name|prot
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|mlx4_multicast_attach
argument_list|(
name|dev
argument_list|,
operator|&
name|qp
argument_list|,
name|mgm
operator|->
name|gid
argument_list|,
name|mgm
operator|->
name|gid
index|[
literal|5
index|]
argument_list|,
literal|0
argument_list|,
name|prot
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
block|}
break|break;
default|default:
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Bad type for required operation\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
operator|(
operator|(
name|u32
operator|)
name|err
operator||
name|cpu_to_be32
argument_list|(
name|token
argument_list|)
operator|<<
literal|16
operator|)
argument_list|,
literal|1
argument_list|,
name|MLX4_CMD_GET_OP_REQ
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to acknowledge required request: %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|memset
argument_list|(
name|outbox
argument_list|,
literal|0
argument_list|,
literal|0xffc
argument_list|)
expr_stmt|;
name|num_tasks
operator|=
name|atomic_dec_return
argument_list|(
operator|&
name|priv
operator|->
name|opreq_count
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

