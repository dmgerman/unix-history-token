begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.  * Copyright (c) 2005, 2006, 2007, 2008 Mellanox Technologies. All rights reserved.  * Copyright (c) 2005, 2006, 2007 Cisco Systems, Inc.  All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<linux/mlx4/cmd.h>
end_include

begin_include
include|#
directive|include
file|"fw.h"
end_include

begin_include
include|#
directive|include
file|"icm.h"
end_include

begin_enum
enum|enum
block|{
name|MLX4_COMMAND_INTERFACE_MIN_REV
init|=
literal|2
block|,
name|MLX4_COMMAND_INTERFACE_MAX_REV
init|=
literal|3
block|,
name|MLX4_COMMAND_INTERFACE_NEW_PORT_CMDS
init|=
literal|3
block|, }
enum|;
end_enum

begin_function_decl
specifier|extern
name|void
name|__buggy_use_of_MLX4_GET
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|__buggy_use_of_MLX4_PUT
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|enable_qos
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param
argument_list|(
name|enable_qos
argument_list|,
name|bool
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|enable_qos
argument_list|,
literal|"Enable Quality of Service support in the HCA (default: off)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mlx4_pre_t11_mode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|enable_pre_t11_mode
argument_list|,
name|mlx4_pre_t11_mode
argument_list|,
name|int
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|enable_pre_t11_mode
argument_list|,
literal|"For FCoXX, enable pre-t11 mode if non-zero (default: 0)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|MLX4_GET
parameter_list|(
name|dest
parameter_list|,
name|source
parameter_list|,
name|offset
parameter_list|)
define|\
value|do {							      \ 		void *__p = (char *) (source) + (offset);	      \ 		switch (sizeof (dest)) {			      \ 		case 1: (dest) = *(u8 *) __p;	    break;	      \ 		case 2: (dest) = be16_to_cpup(__p); break;	      \ 		case 4: (dest) = be32_to_cpup(__p); break;	      \ 		case 8: (dest) = be64_to_cpup(__p); break;	      \ 		default: __buggy_use_of_MLX4_GET();		      \ 		}						      \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|MLX4_PUT
parameter_list|(
name|dest
parameter_list|,
name|source
parameter_list|,
name|offset
parameter_list|)
define|\
value|do {							      \ 		void *__d = ((char *) (dest) + (offset));	      \ 		switch (sizeof(source)) {			      \ 		case 1: *(u8 *) __d = (source);		       break; \ 		case 2:	*(__be16 *) __d = cpu_to_be16(source); break; \ 		case 4:	*(__be32 *) __d = cpu_to_be32(source); break; \ 		case 8:	*(__be64 *) __d = cpu_to_be64(source); break; \ 		default: __buggy_use_of_MLX4_PUT();		      \ 		}						      \ 	} while (0)
end_define

begin_function
specifier|static
name|void
name|dump_dev_cap_flags
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|flags
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|fname
index|[]
init|=
block|{
index|[
literal|0
index|]
operator|=
literal|"RC transport"
block|,
index|[
literal|1
index|]
operator|=
literal|"UC transport"
block|,
index|[
literal|2
index|]
operator|=
literal|"UD transport"
block|,
index|[
literal|3
index|]
operator|=
literal|"XRC transport"
block|,
index|[
literal|4
index|]
operator|=
literal|"reliable multicast"
block|,
index|[
literal|5
index|]
operator|=
literal|"FCoIB support"
block|,
index|[
literal|6
index|]
operator|=
literal|"SRQ support"
block|,
index|[
literal|7
index|]
operator|=
literal|"IPoIB checksum offload"
block|,
index|[
literal|8
index|]
operator|=
literal|"P_Key violation counter"
block|,
index|[
literal|9
index|]
operator|=
literal|"Q_Key violation counter"
block|,
index|[
literal|10
index|]
operator|=
literal|"VMM"
block|,
index|[
literal|12
index|]
operator|=
literal|"DPDP"
block|,
index|[
literal|16
index|]
operator|=
literal|"MW support"
block|,
index|[
literal|17
index|]
operator|=
literal|"APM support"
block|,
index|[
literal|18
index|]
operator|=
literal|"Atomic ops support"
block|,
index|[
literal|19
index|]
operator|=
literal|"Raw multicast support"
block|,
index|[
literal|20
index|]
operator|=
literal|"Address vector port checking support"
block|,
index|[
literal|21
index|]
operator|=
literal|"UD multicast support"
block|,
index|[
literal|24
index|]
operator|=
literal|"Demand paging support"
block|,
index|[
literal|25
index|]
operator|=
literal|"Router support"
block|,
index|[
literal|30
index|]
operator|=
literal|"IBoE support"
block|,
index|[
literal|48
index|]
operator|=
literal|"Basic counters support"
block|,
index|[
literal|49
index|]
operator|=
literal|"Extended counters support"
block|, 	}
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"DEV_CAP flags:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|fname
argument_list|)
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|fname
index|[
name|i
index|]
operator|&&
operator|(
name|flags
operator|&
operator|(
literal|1LL
operator|<<
name|i
operator|)
operator|)
condition|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"    %s\n"
argument_list|,
name|fname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mlx4_MOD_STAT_CFG
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_mod_stat_cfg
modifier|*
name|cfg
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|inbox
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|MOD_STAT_CFG_IN_SIZE
value|0x100
define|#
directive|define
name|MOD_STAT_CFG_PG_SZ_M_OFFSET
value|0x002
define|#
directive|define
name|MOD_STAT_CFG_PG_SZ_OFFSET
value|0x003
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|inbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|memset
argument_list|(
name|inbox
argument_list|,
literal|0
argument_list|,
name|MOD_STAT_CFG_IN_SIZE
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|cfg
operator|->
name|log_pg_sz
argument_list|,
name|MOD_STAT_CFG_PG_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|cfg
operator|->
name|log_pg_sz_m
argument_list|,
name|MOD_STAT_CFG_PG_SZ_M_OFFSET
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_MOD_STAT_CFG
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_DEV_CAP
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|outbox
decl_stmt|;
name|u8
name|field
decl_stmt|;
name|u32
name|field32
decl_stmt|;
name|u16
name|size
decl_stmt|;
name|u16
name|stat_rate
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u32
name|in_modifier
decl_stmt|;
name|u64
name|out_param
decl_stmt|;
name|u32
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
define|#
directive|define
name|QUERY_DEV_CAP_OUT_SIZE
value|0x100
define|#
directive|define
name|QUERY_DEV_CAP_MAX_SRQ_SZ_OFFSET
value|0x10
define|#
directive|define
name|QUERY_DEV_CAP_MAX_QP_SZ_OFFSET
value|0x11
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_QP_OFFSET
value|0x12
define|#
directive|define
name|QUERY_DEV_CAP_MAX_QP_OFFSET
value|0x13
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_SRQ_OFFSET
value|0x14
define|#
directive|define
name|QUERY_DEV_CAP_MAX_SRQ_OFFSET
value|0x15
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_EEC_OFFSET
value|0x16
define|#
directive|define
name|QUERY_DEV_CAP_MAX_EEC_OFFSET
value|0x17
define|#
directive|define
name|QUERY_DEV_CAP_MAX_CQ_SZ_OFFSET
value|0x19
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_CQ_OFFSET
value|0x1a
define|#
directive|define
name|QUERY_DEV_CAP_MAX_CQ_OFFSET
value|0x1b
define|#
directive|define
name|QUERY_DEV_CAP_MAX_MPT_OFFSET
value|0x1d
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_EQ_OFFSET
value|0x1e
define|#
directive|define
name|QUERY_DEV_CAP_MAX_EQ_OFFSET
value|0x1f
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_MTT_OFFSET
value|0x20
define|#
directive|define
name|QUERY_DEV_CAP_MAX_MRW_SZ_OFFSET
value|0x21
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_MRW_OFFSET
value|0x22
define|#
directive|define
name|QUERY_DEV_CAP_MAX_MTT_SEG_OFFSET
value|0x23
define|#
directive|define
name|QUERY_DEV_CAP_MAX_AV_OFFSET
value|0x27
define|#
directive|define
name|QUERY_DEV_CAP_MAX_REQ_QP_OFFSET
value|0x29
define|#
directive|define
name|QUERY_DEV_CAP_MAX_RES_QP_OFFSET
value|0x2b
define|#
directive|define
name|QUERY_DEV_CAP_MAX_GSO_OFFSET
value|0x2d
define|#
directive|define
name|QUERY_DEV_CAP_MAX_RDMA_OFFSET
value|0x2f
define|#
directive|define
name|QUERY_DEV_CAP_STAT_CFG_INL_OFFSET
value|0x31
define|#
directive|define
name|QUERY_DEV_CAP_RSZ_SRQ_OFFSET
value|0x33
define|#
directive|define
name|QUERY_DEV_CAP_ACK_DELAY_OFFSET
value|0x35
define|#
directive|define
name|QUERY_DEV_CAP_MTU_WIDTH_OFFSET
value|0x36
define|#
directive|define
name|QUERY_DEV_CAP_VL_PORT_OFFSET
value|0x37
define|#
directive|define
name|QUERY_DEV_CAP_MAX_MSG_SZ_OFFSET
value|0x38
define|#
directive|define
name|QUERY_DEV_CAP_MAX_GID_OFFSET
value|0x3b
define|#
directive|define
name|QUERY_DEV_CAP_RATE_SUPPORT_OFFSET
value|0x3c
define|#
directive|define
name|QUERY_DEV_CAP_MAX_PKEY_OFFSET
value|0x3f
define|#
directive|define
name|QUERY_DEV_CAP_EXT_FLAGS_OFFSET
value|0x40
define|#
directive|define
name|QUERY_DEV_CAP_UDP_RSS_OFFSET
value|0x42
define|#
directive|define
name|QUERY_DEV_CAP_ETH_UC_LOOPBACK_OFFSET
value|0x43
define|#
directive|define
name|QUERY_DEV_CAP_FLAGS_OFFSET
value|0x44
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_UAR_OFFSET
value|0x48
define|#
directive|define
name|QUERY_DEV_CAP_UAR_SZ_OFFSET
value|0x49
define|#
directive|define
name|QUERY_DEV_CAP_PAGE_SZ_OFFSET
value|0x4b
define|#
directive|define
name|QUERY_DEV_CAP_BF_OFFSET
value|0x4c
define|#
directive|define
name|QUERY_DEV_CAP_LOG_BF_REG_SZ_OFFSET
value|0x4d
define|#
directive|define
name|QUERY_DEV_CAP_LOG_MAX_BF_REGS_PER_PAGE_OFFSET
value|0x4e
define|#
directive|define
name|QUERY_DEV_CAP_LOG_MAX_BF_PAGES_OFFSET
value|0x4f
define|#
directive|define
name|QUERY_DEV_CAP_MAX_SG_SQ_OFFSET
value|0x51
define|#
directive|define
name|QUERY_DEV_CAP_MAX_DESC_SZ_SQ_OFFSET
value|0x52
define|#
directive|define
name|QUERY_DEV_CAP_MAX_SG_RQ_OFFSET
value|0x55
define|#
directive|define
name|QUERY_DEV_CAP_MAX_DESC_SZ_RQ_OFFSET
value|0x56
define|#
directive|define
name|QUERY_DEV_CAP_MAX_QP_MCG_OFFSET
value|0x61
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_MCG_OFFSET
value|0x62
define|#
directive|define
name|QUERY_DEV_CAP_MAX_MCG_OFFSET
value|0x63
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_PD_OFFSET
value|0x64
define|#
directive|define
name|QUERY_DEV_CAP_MAX_PD_OFFSET
value|0x65
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_XRC_OFFSET
value|0x66
define|#
directive|define
name|QUERY_DEV_CAP_MAX_XRC_OFFSET
value|0x67
define|#
directive|define
name|QUERY_DEV_CAP_RDMARC_ENTRY_SZ_OFFSET
value|0x80
define|#
directive|define
name|QUERY_DEV_CAP_QPC_ENTRY_SZ_OFFSET
value|0x82
define|#
directive|define
name|QUERY_DEV_CAP_AUX_ENTRY_SZ_OFFSET
value|0x84
define|#
directive|define
name|QUERY_DEV_CAP_ALTC_ENTRY_SZ_OFFSET
value|0x86
define|#
directive|define
name|QUERY_DEV_CAP_EQC_ENTRY_SZ_OFFSET
value|0x88
define|#
directive|define
name|QUERY_DEV_CAP_CQC_ENTRY_SZ_OFFSET
value|0x8a
define|#
directive|define
name|QUERY_DEV_CAP_SRQ_ENTRY_SZ_OFFSET
value|0x8c
define|#
directive|define
name|QUERY_DEV_CAP_C_MPT_ENTRY_SZ_OFFSET
value|0x8e
define|#
directive|define
name|QUERY_DEV_CAP_MTT_ENTRY_SZ_OFFSET
value|0x90
define|#
directive|define
name|QUERY_DEV_CAP_D_MPT_ENTRY_SZ_OFFSET
value|0x92
define|#
directive|define
name|QUERY_DEV_CAP_BMME_FLAGS_OFFSET
value|0x94
define|#
directive|define
name|QUERY_DEV_CAP_RSVD_LKEY_OFFSET
value|0x98
define|#
directive|define
name|QUERY_DEV_CAP_MAX_ICM_SZ_OFFSET
value|0xa0
define|#
directive|define
name|QUERY_DEV_CAP_MAX_BASIC_CNT_OFFSET
value|0x68
define|#
directive|define
name|QUERY_DEV_CAP_MAX_EXT_CNT_OFFSET
value|0x6c
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_DEV_CAP
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_QP_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_qps
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0xf
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_QP_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_qps
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_SRQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_srqs
operator|=
literal|1
operator|<<
operator|(
name|field
operator|>>
literal|4
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_SRQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_srqs
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_CQ_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_cq_sz
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_CQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_cqs
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0xf
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_CQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_cqs
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_MPT_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_mpts
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_EQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_eqs
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0xf
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_EQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_eqs
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0xf
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_MTT_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_mtts
operator|=
literal|1
operator|<<
operator|(
name|field
operator|>>
literal|4
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_MRW_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_mrw_sz
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_MRW_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_mrws
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0xf
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_MTT_SEG_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_mtt_seg
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_REQ_QP_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_requester_per_qp
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_RES_QP_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_responder_per_qp
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_GSO_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|&=
literal|0x1f
expr_stmt|;
if|if
condition|(
operator|!
name|field
condition|)
name|dev_cap
operator|->
name|max_gso_sz
operator|=
literal|0
expr_stmt|;
else|else
name|dev_cap
operator|->
name|max_gso_sz
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_RDMA_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_rdma_global
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_ACK_DELAY_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|local_ca_ack_delay
operator|=
name|field
operator|&
literal|0x1f
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_VL_PORT_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|num_ports
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_MSG_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_msg_sz
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|stat_rate
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RATE_SUPPORT_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|stat_rate_support
operator|=
name|stat_rate
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_UDP_RSS_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|udp_rss
operator|=
name|field
operator|&
literal|0x1
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_ETH_UC_LOOPBACK_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|loopback_support
operator|=
name|field
operator|&
literal|0x1
expr_stmt|;
name|MLX4_GET
argument_list|(
name|tmp1
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_EXT_FLAGS_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|tmp2
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_FLAGS_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|flags
operator|=
name|tmp2
operator||
operator|(
name|u64
operator|)
name|tmp1
operator|<<
literal|32
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_UAR_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_uars
operator|=
name|field
operator|>>
literal|4
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_UAR_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|uar_size
operator|=
literal|1
operator|<<
operator|(
operator|(
name|field
operator|&
literal|0x3f
operator|)
operator|+
literal|20
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_PAGE_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|min_page_sz
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_BF_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|&
literal|0x80
condition|)
block|{
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_LOG_BF_REG_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|bf_reg_size
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_LOG_MAX_BF_REGS_PER_PAGE_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x3f
operator|)
operator|)
operator|>
operator|(
name|PAGE_SIZE
operator|/
name|dev_cap
operator|->
name|bf_reg_size
operator|)
condition|)
block|{
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"log blue flame is invalid (%d), forcing 3\n"
argument_list|,
name|field
operator|&
literal|0x1f
argument_list|)
expr_stmt|;
name|field
operator|=
literal|3
expr_stmt|;
block|}
name|dev_cap
operator|->
name|bf_regs_per_page
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"BlueFlame available (reg size %d, regs/page %d)\n"
argument_list|,
name|dev_cap
operator|->
name|bf_reg_size
argument_list|,
name|dev_cap
operator|->
name|bf_regs_per_page
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dev_cap
operator|->
name|bf_reg_size
operator|=
literal|0
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"BlueFlame not available\n"
argument_list|)
expr_stmt|;
block|}
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_SG_SQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_sq_sg
operator|=
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_DESC_SZ_SQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_sq_desc_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_QP_MCG_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_qp_per_mcg
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_MCG_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_mgms
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_MCG_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_mcgs
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_PD_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_pds
operator|=
name|field
operator|>>
literal|4
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_PD_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_pds
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_XRC_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|reserved_xrcds
operator|=
name|field
operator|>>
literal|4
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_XRC_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_xrcds
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RDMARC_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|rdmarc_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_QPC_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|qpc_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_AUX_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|aux_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_ALTC_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|altc_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_EQC_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|eqc_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_CQC_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|cqc_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_SRQ_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|srq_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_C_MPT_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|cmpt_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MTT_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|mtt_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_D_MPT_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|dmpt_entry_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_SRQ_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_srq_sz
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_QP_SZ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_qp_sz
operator|=
literal|1
operator|<<
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_STAT_CFG_INL_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|inline_cfg
operator|=
name|field
operator|&
literal|1
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSZ_SRQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|resize_srq
operator|=
name|field
operator|&
literal|1
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_SG_RQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_rq_sg
operator|=
name|field
expr_stmt|;
name|MLX4_GET
argument_list|(
name|size
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_DESC_SZ_RQ_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_rq_desc_sz
operator|=
name|size
expr_stmt|;
name|MLX4_GET
argument_list|(
name|dev_cap
operator|->
name|bmme_flags
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_BMME_FLAGS_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|dev_cap
operator|->
name|reserved_lkey
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_RSVD_LKEY_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|dev_cap
operator|->
name|max_icm_sz
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_ICM_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|dev_cap
operator|->
name|max_basic_counters
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_BASIC_CNT_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|dev_cap
operator|->
name|max_ext_counters
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_EXT_CNT_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_OLD_PORT_CMDS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev_cap
operator|->
name|num_ports
condition|;
operator|++
name|i
control|)
block|{
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_VL_PORT_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_vl
index|[
name|i
index|]
operator|=
name|field
operator|>>
literal|4
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MTU_WIDTH_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|ib_mtu
index|[
name|i
index|]
operator|=
name|field
operator|>>
literal|4
expr_stmt|;
name|dev_cap
operator|->
name|max_port_width
index|[
name|i
index|]
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_GID_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_gids
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0xf
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_DEV_CAP_MAX_PKEY_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_pkeys
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0xf
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
define|#
directive|define
name|QUERY_PORT_SUPPORTED_TYPE_OFFSET
value|0x00
define|#
directive|define
name|QUERY_PORT_MTU_OFFSET
value|0x01
define|#
directive|define
name|QUERY_PORT_ETH_MTU_OFFSET
value|0x02
define|#
directive|define
name|QUERY_PORT_WIDTH_OFFSET
value|0x06
define|#
directive|define
name|QUERY_PORT_MAX_GID_PKEY_OFFSET
value|0x07
define|#
directive|define
name|QUERY_PORT_MAX_MACVLAN_OFFSET
value|0x0a
define|#
directive|define
name|QUERY_PORT_MAX_VL_OFFSET
value|0x0b
define|#
directive|define
name|QUERY_PORT_MAC_OFFSET
value|0x10
define|#
directive|define
name|QUERY_PORT_TRANS_VENDOR_OFFSET
value|0x18
define|#
directive|define
name|QUERY_PORT_WAVELENGTH_OFFSET
value|0x1c
define|#
directive|define
name|QUERY_PORT_TRANS_CODE_OFFSET
value|0x20
define|#
directive|define
name|STAT_CFG_PORT_MODE
value|(1<< 28)
define|#
directive|define
name|STAT_CFG_PORT_OFFSET
value|0x8
define|#
directive|define
name|STAT_CFG_PORT_MASK
value|(1<< 20)
define|#
directive|define
name|STAT_CFG_MOD_INLINE
value|0x3
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev_cap
operator|->
name|num_ports
condition|;
operator|++
name|i
control|)
block|{
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_SUPPORTED_TYPE_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|supported_port_types
index|[
name|i
index|]
operator|=
name|field
operator|&
literal|3
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_MTU_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|ib_mtu
index|[
name|i
index|]
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_WIDTH_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_port_width
index|[
name|i
index|]
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_MAX_GID_PKEY_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_gids
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|field
operator|>>
literal|4
operator|)
expr_stmt|;
name|dev_cap
operator|->
name|max_pkeys
index|[
name|i
index|]
operator|=
literal|1
operator|<<
operator|(
name|field
operator|&
literal|0xf
operator|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_MAX_VL_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|max_vl
index|[
name|i
index|]
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_MAX_MACVLAN_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|log_max_macs
index|[
name|i
index|]
operator|=
name|field
operator|&
literal|0xf
expr_stmt|;
name|dev_cap
operator|->
name|log_max_vlans
index|[
name|i
index|]
operator|=
name|field
operator|>>
literal|4
expr_stmt|;
name|MLX4_GET
argument_list|(
name|dev_cap
operator|->
name|eth_mtu
index|[
name|i
index|]
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_ETH_MTU_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|dev_cap
operator|->
name|def_mac
index|[
name|i
index|]
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_MAC_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|field32
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_TRANS_VENDOR_OFFSET
argument_list|)
expr_stmt|;
name|dev_cap
operator|->
name|trans_type
index|[
name|i
index|]
operator|=
name|field32
operator|>>
literal|24
expr_stmt|;
name|dev_cap
operator|->
name|vendor_oui
index|[
name|i
index|]
operator|=
name|field32
operator|&
literal|0xffffff
expr_stmt|;
name|MLX4_GET
argument_list|(
name|dev_cap
operator|->
name|wavelength
index|[
name|i
index|]
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_WAVELENGTH_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|dev_cap
operator|->
name|trans_code
index|[
name|i
index|]
argument_list|,
name|outbox
argument_list|,
name|QUERY_PORT_TRANS_CODE_OFFSET
argument_list|)
expr_stmt|;
comment|/* Query stat cfg for port enablement */
if|if
condition|(
name|dev_cap
operator|->
name|inline_cfg
condition|)
block|{
name|in_modifier
operator|=
name|STAT_CFG_PORT_MODE
operator||
name|i
operator|<<
literal|8
operator||
name|STAT_CFG_PORT_OFFSET
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_imm
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
operator|&
name|out_param
argument_list|,
name|in_modifier
argument_list|,
name|STAT_CFG_MOD_INLINE
argument_list|,
name|MLX4_CMD_MOD_STAT_CFG
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
if|if
condition|(
operator|!
operator|(
name|out_param
operator|&
name|STAT_CFG_PORT_MASK
operator|)
condition|)
name|dev_cap
operator|->
name|supported_port_types
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Base MM extensions: flags %08x, rsvd L_Key %08x\n"
argument_list|,
name|dev_cap
operator|->
name|bmme_flags
argument_list|,
name|dev_cap
operator|->
name|reserved_lkey
argument_list|)
expr_stmt|;
comment|/* 	 * Each UAR has 4 EQ doorbells; so if a UAR is reserved, then 	 * we can't use any EQs whose doorbell falls on that page, 	 * even if the EQ itself isn't reserved. 	 */
name|dev_cap
operator|->
name|reserved_eqs
operator|=
name|max
argument_list|(
name|dev_cap
operator|->
name|reserved_uars
operator|*
literal|4
argument_list|,
name|dev_cap
operator|->
name|reserved_eqs
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max ICM size %lld MB\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|dev_cap
operator|->
name|max_icm_sz
operator|>>
literal|20
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max QPs: %d, reserved QPs: %d, entry size: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_qps
argument_list|,
name|dev_cap
operator|->
name|reserved_qps
argument_list|,
name|dev_cap
operator|->
name|qpc_entry_sz
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max SRQs: %d, reserved SRQs: %d, entry size: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_srqs
argument_list|,
name|dev_cap
operator|->
name|reserved_srqs
argument_list|,
name|dev_cap
operator|->
name|srq_entry_sz
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max CQs: %d, reserved CQs: %d, entry size: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_cqs
argument_list|,
name|dev_cap
operator|->
name|reserved_cqs
argument_list|,
name|dev_cap
operator|->
name|cqc_entry_sz
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max EQs: %d, reserved EQs: %d, entry size: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_eqs
argument_list|,
name|dev_cap
operator|->
name|reserved_eqs
argument_list|,
name|dev_cap
operator|->
name|eqc_entry_sz
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"reserved MPTs: %d, reserved MTTs: %d\n"
argument_list|,
name|dev_cap
operator|->
name|reserved_mrws
argument_list|,
name|dev_cap
operator|->
name|reserved_mtts
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max PDs: %d, reserved PDs: %d, reserved UARs: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_pds
argument_list|,
name|dev_cap
operator|->
name|reserved_pds
argument_list|,
name|dev_cap
operator|->
name|reserved_uars
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max QP/MCG: %d, reserved MGMs: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_pds
argument_list|,
name|dev_cap
operator|->
name|reserved_mgms
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max CQEs: %d, max WQEs: %d, max SRQ WQEs: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_cq_sz
argument_list|,
name|dev_cap
operator|->
name|max_qp_sz
argument_list|,
name|dev_cap
operator|->
name|max_srq_sz
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Local CA ACK delay: %d, max MTU: %d, port width cap: %d\n"
argument_list|,
name|dev_cap
operator|->
name|local_ca_ack_delay
argument_list|,
literal|128
operator|<<
name|dev_cap
operator|->
name|ib_mtu
index|[
literal|1
index|]
argument_list|,
name|dev_cap
operator|->
name|max_port_width
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max SQ desc size: %d, max SQ S/G: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_sq_desc_sz
argument_list|,
name|dev_cap
operator|->
name|max_sq_sg
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max RQ desc size: %d, max RQ S/G: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_rq_desc_sz
argument_list|,
name|dev_cap
operator|->
name|max_rq_sg
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max GSO size: %d\n"
argument_list|,
name|dev_cap
operator|->
name|max_gso_sz
argument_list|)
expr_stmt|;
name|dump_dev_cap_flags
argument_list|(
name|dev
argument_list|,
name|dev_cap
operator|->
name|flags
argument_list|)
expr_stmt|;
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_map_cmd
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u16
name|op
parameter_list|,
name|struct
name|mlx4_icm
modifier|*
name|icm
parameter_list|,
name|u64
name|virt
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|struct
name|mlx4_icm_iter
name|iter
decl_stmt|;
name|__be64
modifier|*
name|pages
decl_stmt|;
name|int
name|lg
decl_stmt|;
name|int
name|nent
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|ts
init|=
literal|0
decl_stmt|,
name|tc
init|=
literal|0
decl_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|memset
argument_list|(
name|mailbox
operator|->
name|buf
argument_list|,
literal|0
argument_list|,
name|MLX4_MAILBOX_SIZE
argument_list|)
expr_stmt|;
name|pages
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
for|for
control|(
name|mlx4_icm_first
argument_list|(
name|icm
argument_list|,
operator|&
name|iter
argument_list|)
init|;
operator|!
name|mlx4_icm_last
argument_list|(
operator|&
name|iter
argument_list|)
condition|;
name|mlx4_icm_next
argument_list|(
operator|&
name|iter
argument_list|)
control|)
block|{
comment|/* 		 * We have to pass pages that are aligned to their 		 * size, so find the least significant 1 in the 		 * address or size and use that as our log2 size. 		 */
name|lg
operator|=
name|ffs
argument_list|(
name|mlx4_icm_addr
argument_list|(
operator|&
name|iter
argument_list|)
operator||
name|mlx4_icm_size
argument_list|(
operator|&
name|iter
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|lg
operator|<
name|MLX4_ICM_PAGE_SHIFT
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Got FW area not aligned to %d (%llx/%lx).\n"
argument_list|,
name|MLX4_ICM_PAGE_SIZE
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|mlx4_icm_addr
argument_list|(
operator|&
name|iter
argument_list|)
argument_list|,
name|mlx4_icm_size
argument_list|(
operator|&
name|iter
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mlx4_icm_size
argument_list|(
operator|&
name|iter
argument_list|)
operator|>>
name|lg
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|virt
operator|!=
operator|-
literal|1
condition|)
block|{
name|pages
index|[
name|nent
operator|*
literal|2
index|]
operator|=
name|cpu_to_be64
argument_list|(
name|virt
argument_list|)
expr_stmt|;
name|virt
operator|+=
literal|1
operator|<<
name|lg
expr_stmt|;
block|}
name|pages
index|[
name|nent
operator|*
literal|2
operator|+
literal|1
index|]
operator|=
name|cpu_to_be64
argument_list|(
operator|(
name|mlx4_icm_addr
argument_list|(
operator|&
name|iter
argument_list|)
operator|+
operator|(
name|i
operator|<<
name|lg
operator|)
operator|)
operator||
operator|(
name|lg
operator|-
name|MLX4_ICM_PAGE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|ts
operator|+=
literal|1
operator|<<
operator|(
name|lg
operator|-
literal|10
operator|)
expr_stmt|;
operator|++
name|tc
expr_stmt|;
if|if
condition|(
operator|++
name|nent
operator|==
name|MLX4_MAILBOX_SIZE
operator|/
literal|16
condition|)
block|{
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|nent
argument_list|,
literal|0
argument_list|,
name|op
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|nent
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|nent
condition|)
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|nent
argument_list|,
literal|0
argument_list|,
name|op
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|MLX4_CMD_MAP_FA
case|:
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Mapped %d chunks/%d KB for FW.\n"
argument_list|,
name|tc
argument_list|,
name|ts
argument_list|)
expr_stmt|;
break|break;
case|case
name|MLX4_CMD_MAP_ICM_AUX
case|:
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Mapped %d chunks/%d KB for ICM aux.\n"
argument_list|,
name|tc
argument_list|,
name|ts
argument_list|)
expr_stmt|;
break|break;
case|case
name|MLX4_CMD_MAP_ICM
case|:
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Mapped %d chunks/%d KB at %llx for ICM.\n"
argument_list|,
name|tc
argument_list|,
name|ts
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|virt
operator|-
operator|(
name|ts
operator|<<
literal|10
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_MAP_FA
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_icm
modifier|*
name|icm
parameter_list|)
block|{
return|return
name|mlx4_map_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_CMD_MAP_FA
argument_list|,
name|icm
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_UNMAP_FA
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
return|return
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_UNMAP_FA
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_RUN_FW
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
return|return
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_RUN_FW
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_FW
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_fw
modifier|*
name|fw
init|=
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|fw
decl_stmt|;
name|struct
name|mlx4_cmd
modifier|*
name|cmd
init|=
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|cmd
decl_stmt|;
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|outbox
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|u64
name|fw_ver
decl_stmt|;
name|u16
name|cmd_if_rev
decl_stmt|;
name|u8
name|lg
decl_stmt|;
define|#
directive|define
name|QUERY_FW_OUT_SIZE
value|0x100
define|#
directive|define
name|QUERY_FW_VER_OFFSET
value|0x00
define|#
directive|define
name|MC_PROMISC_VER
value|0x2000702bcull
define|#
directive|define
name|QUERY_FW_CMD_IF_REV_OFFSET
value|0x0a
define|#
directive|define
name|QUERY_FW_MAX_CMD_OFFSET
value|0x0f
define|#
directive|define
name|QUERY_FW_ERR_START_OFFSET
value|0x30
define|#
directive|define
name|QUERY_FW_ERR_SIZE_OFFSET
value|0x38
define|#
directive|define
name|QUERY_FW_ERR_BAR_OFFSET
value|0x3c
define|#
directive|define
name|QUERY_FW_SIZE_OFFSET
value|0x00
define|#
directive|define
name|QUERY_FW_CLR_INT_BASE_OFFSET
value|0x20
define|#
directive|define
name|QUERY_FW_CLR_INT_BAR_OFFSET
value|0x28
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_FW
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|MLX4_GET
argument_list|(
name|fw_ver
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_VER_OFFSET
argument_list|)
expr_stmt|;
comment|/* 	 * FW subminor version is at more significant bits than minor 	 * version, so swap here. 	 */
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|=
operator|(
name|fw_ver
operator|&
literal|0xffff00000000ull
operator|)
operator||
operator|(
operator|(
name|fw_ver
operator|&
literal|0xffff0000ull
operator|)
operator|>>
literal|16
operator|)
operator||
operator|(
operator|(
name|fw_ver
operator|&
literal|0x0000ffffull
operator|)
operator|<<
literal|16
operator|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|<
name|MC_PROMISC_VER
condition|)
name|dev
operator|->
name|caps
operator|.
name|mc_promisc_mode
operator|=
literal|2
expr_stmt|;
else|else
name|dev
operator|->
name|caps
operator|.
name|mc_promisc_mode
operator|=
literal|1
expr_stmt|;
name|MLX4_GET
argument_list|(
name|cmd_if_rev
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_CMD_IF_REV_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd_if_rev
operator|<
name|MLX4_COMMAND_INTERFACE_MIN_REV
operator|||
name|cmd_if_rev
operator|>
name|MLX4_COMMAND_INTERFACE_MAX_REV
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Installed FW has unsupported "
literal|"command interface revision %d.\n"
argument_list|,
name|cmd_if_rev
argument_list|)
expr_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"(Installed FW version is %d.%d.%03d)\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|>>
literal|32
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|>>
literal|16
argument_list|)
operator|&
literal|0xffff
argument_list|,
operator|(
name|int
operator|)
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"This driver version supports only revisions %d to %d.\n"
argument_list|,
name|MLX4_COMMAND_INTERFACE_MIN_REV
argument_list|,
name|MLX4_COMMAND_INTERFACE_MAX_REV
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|cmd_if_rev
operator|<
name|MLX4_COMMAND_INTERFACE_NEW_PORT_CMDS
condition|)
name|dev
operator|->
name|flags
operator||=
name|MLX4_FLAG_OLD_PORT_CMDS
expr_stmt|;
name|MLX4_GET
argument_list|(
name|lg
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_MAX_CMD_OFFSET
argument_list|)
expr_stmt|;
name|cmd
operator|->
name|max_cmds
operator|=
literal|1
operator|<<
name|lg
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"FW version %d.%d.%03d (cmd intf rev %d), max commands %d\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|>>
literal|32
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|>>
literal|16
argument_list|)
operator|&
literal|0xffff
argument_list|,
operator|(
name|int
operator|)
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|&
literal|0xffff
argument_list|,
name|cmd_if_rev
argument_list|,
name|cmd
operator|->
name|max_cmds
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|catas_offset
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_ERR_START_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|catas_size
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_ERR_SIZE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|catas_bar
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_ERR_BAR_OFFSET
argument_list|)
expr_stmt|;
name|fw
operator|->
name|catas_bar
operator|=
operator|(
name|fw
operator|->
name|catas_bar
operator|>>
literal|6
operator|)
operator|*
literal|2
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Catastrophic error buffer at 0x%llx, size 0x%x, BAR %d\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|fw
operator|->
name|catas_offset
argument_list|,
name|fw
operator|->
name|catas_size
argument_list|,
name|fw
operator|->
name|catas_bar
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|fw_pages
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_SIZE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|clr_int_base
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_CLR_INT_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_GET
argument_list|(
name|fw
operator|->
name|clr_int_bar
argument_list|,
name|outbox
argument_list|,
name|QUERY_FW_CLR_INT_BAR_OFFSET
argument_list|)
expr_stmt|;
name|fw
operator|->
name|clr_int_bar
operator|=
operator|(
name|fw
operator|->
name|clr_int_bar
operator|>>
literal|6
operator|)
operator|*
literal|2
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"FW size %d KB\n"
argument_list|,
name|fw
operator|->
name|fw_pages
operator|>>
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * Round up number of system pages needed in case 	 * MLX4_ICM_PAGE_SIZE< PAGE_SIZE. 	 */
name|fw
operator|->
name|fw_pages
operator|=
name|ALIGN
argument_list|(
name|fw
operator|->
name|fw_pages
argument_list|,
name|PAGE_SIZE
operator|/
name|MLX4_ICM_PAGE_SIZE
argument_list|)
operator|>>
operator|(
name|PAGE_SHIFT
operator|-
name|MLX4_ICM_PAGE_SHIFT
operator|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Clear int @ %llx, BAR %d\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|fw
operator|->
name|clr_int_base
argument_list|,
name|fw
operator|->
name|clr_int_bar
argument_list|)
expr_stmt|;
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_board_id
parameter_list|(
name|void
modifier|*
name|vsd
parameter_list|,
name|char
modifier|*
name|board_id
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
define|#
directive|define
name|VSD_OFFSET_SIG1
value|0x00
define|#
directive|define
name|VSD_OFFSET_SIG2
value|0xde
define|#
directive|define
name|VSD_OFFSET_MLX_BOARD_ID
value|0xd0
define|#
directive|define
name|VSD_OFFSET_TS_BOARD_ID
value|0x20
define|#
directive|define
name|VSD_SIGNATURE_TOPSPIN
value|0x5ad
name|memset
argument_list|(
name|board_id
argument_list|,
literal|0
argument_list|,
name|MLX4_BOARD_ID_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|be16_to_cpup
argument_list|(
name|vsd
operator|+
name|VSD_OFFSET_SIG1
argument_list|)
operator|==
name|VSD_SIGNATURE_TOPSPIN
operator|&&
name|be16_to_cpup
argument_list|(
name|vsd
operator|+
name|VSD_OFFSET_SIG2
argument_list|)
operator|==
name|VSD_SIGNATURE_TOPSPIN
condition|)
block|{
name|strlcpy
argument_list|(
name|board_id
argument_list|,
name|vsd
operator|+
name|VSD_OFFSET_TS_BOARD_ID
argument_list|,
name|MLX4_BOARD_ID_LEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The board ID is a string but the firmware byte 		 * swaps each 4-byte word before passing it back to 		 * us.  Therefore we need to swab it before printing. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
operator|++
name|i
control|)
operator|(
operator|(
name|u32
operator|*
operator|)
name|board_id
operator|)
index|[
name|i
index|]
operator|=
name|swab32
argument_list|(
operator|*
operator|(
name|u32
operator|*
operator|)
operator|(
name|vsd
operator|+
name|VSD_OFFSET_MLX_BOARD_ID
operator|+
name|i
operator|*
literal|4
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|mlx4_QUERY_ADAPTER
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_adapter
modifier|*
name|adapter
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|outbox
decl_stmt|;
name|int
name|err
decl_stmt|;
define|#
directive|define
name|QUERY_ADAPTER_OUT_SIZE
value|0x100
define|#
directive|define
name|QUERY_ADAPTER_INTA_PIN_OFFSET
value|0x10
define|#
directive|define
name|QUERY_ADAPTER_VSD_OFFSET
value|0x20
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_ADAPTER
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|MLX4_GET
argument_list|(
name|adapter
operator|->
name|inta_pin
argument_list|,
name|outbox
argument_list|,
name|QUERY_ADAPTER_INTA_PIN_OFFSET
argument_list|)
expr_stmt|;
name|get_board_id
argument_list|(
name|outbox
operator|+
name|QUERY_ADAPTER_VSD_OFFSET
operator|/
literal|4
argument_list|,
name|adapter
operator|->
name|board_id
argument_list|)
expr_stmt|;
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_INIT_HCA
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_init_hca_param
modifier|*
name|param
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|__be32
modifier|*
name|inbox
decl_stmt|;
name|int
name|err
decl_stmt|;
define|#
directive|define
name|INIT_HCA_IN_SIZE
value|0x200
define|#
directive|define
name|INIT_HCA_VERSION_OFFSET
value|0x000
define|#
directive|define
name|INIT_HCA_VERSION
value|2
define|#
directive|define
name|INIT_HCA_CACHELINE_SZ_OFFSET
value|0x0e
define|#
directive|define
name|INIT_HCA_X86_64_BYTE_CACHELINE_SZ
value|0x40
define|#
directive|define
name|INIT_HCA_FLAGS_OFFSET
value|0x014
define|#
directive|define
name|INIT_HCA_QPC_OFFSET
value|0x020
define|#
directive|define
name|INIT_HCA_QPC_BASE_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x10)
define|#
directive|define
name|INIT_HCA_LOG_QP_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x17)
define|#
directive|define
name|INIT_HCA_SRQC_BASE_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x28)
define|#
directive|define
name|INIT_HCA_LOG_SRQ_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x2f)
define|#
directive|define
name|INIT_HCA_CQC_BASE_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x30)
define|#
directive|define
name|INIT_HCA_LOG_CQ_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x37)
define|#
directive|define
name|INIT_HCA_ALTC_BASE_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x40)
define|#
directive|define
name|INIT_HCA_AUXC_BASE_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x50)
define|#
directive|define
name|INIT_HCA_EQC_BASE_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x60)
define|#
directive|define
name|INIT_HCA_LOG_EQ_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x67)
define|#
directive|define
name|INIT_HCA_RDMARC_BASE_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x70)
define|#
directive|define
name|INIT_HCA_LOG_RD_OFFSET
value|(INIT_HCA_QPC_OFFSET + 0x77)
define|#
directive|define
name|INIT_HCA_MCAST_OFFSET
value|0x0c0
define|#
directive|define
name|INIT_HCA_MC_BASE_OFFSET
value|(INIT_HCA_MCAST_OFFSET + 0x00)
define|#
directive|define
name|INIT_HCA_LOG_MC_ENTRY_SZ_OFFSET
value|(INIT_HCA_MCAST_OFFSET + 0x12)
define|#
directive|define
name|INIT_HCA_LOG_MC_HASH_SZ_OFFSET
value|(INIT_HCA_MCAST_OFFSET + 0x16)
define|#
directive|define
name|INIT_HCA_LOG_MC_TABLE_SZ_OFFSET
value|(INIT_HCA_MCAST_OFFSET + 0x1b)
define|#
directive|define
name|INIT_HCA_TPT_OFFSET
value|0x0f0
define|#
directive|define
name|INIT_HCA_DMPT_BASE_OFFSET
value|(INIT_HCA_TPT_OFFSET + 0x00)
define|#
directive|define
name|INIT_HCA_LOG_MPT_SZ_OFFSET
value|(INIT_HCA_TPT_OFFSET + 0x0b)
define|#
directive|define
name|INIT_HCA_MTT_BASE_OFFSET
value|(INIT_HCA_TPT_OFFSET + 0x10)
define|#
directive|define
name|INIT_HCA_CMPT_BASE_OFFSET
value|(INIT_HCA_TPT_OFFSET + 0x18)
define|#
directive|define
name|INIT_HCA_UAR_OFFSET
value|0x120
define|#
directive|define
name|INIT_HCA_LOG_UAR_SZ_OFFSET
value|(INIT_HCA_UAR_OFFSET + 0x0a)
define|#
directive|define
name|INIT_HCA_UAR_PAGE_SZ_OFFSET
value|(INIT_HCA_UAR_OFFSET + 0x0b)
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|inbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|memset
argument_list|(
name|inbox
argument_list|,
literal|0
argument_list|,
name|INIT_HCA_IN_SIZE
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|u8
operator|*
operator|)
name|mailbox
operator|->
name|buf
operator|+
name|INIT_HCA_VERSION_OFFSET
operator|)
operator|=
name|INIT_HCA_VERSION
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__PPC64__
argument_list|)
operator|*
operator|(
operator|(
name|u8
operator|*
operator|)
name|mailbox
operator|->
name|buf
operator|+
name|INIT_HCA_CACHELINE_SZ_OFFSET
operator|)
operator|=
name|INIT_HCA_X86_64_BYTE_CACHELINE_SZ
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__LITTLE_ENDIAN
argument_list|)
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_FLAGS_OFFSET
operator|/
literal|4
operator|)
operator|&=
operator|~
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|1
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|__BIG_ENDIAN
argument_list|)
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_FLAGS_OFFSET
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|1
argument_list|)
expr_stmt|;
else|#
directive|else
error|#
directive|error
error|Host endianness not defined
endif|#
directive|endif
comment|/* Check port for UD address vector: */
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_FLAGS_OFFSET
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Enable IPoIB checksumming if we can: */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_IPOIB_CSUM
condition|)
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_FLAGS_OFFSET
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|3
argument_list|)
expr_stmt|;
comment|/* Enable QoS support if module parameter set */
if|if
condition|(
name|enable_qos
condition|)
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_FLAGS_OFFSET
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|2
argument_list|)
expr_stmt|;
comment|/* counters mode */
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_FLAGS_OFFSET
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|counters_mode
operator|<<
literal|4
argument_list|)
expr_stmt|;
comment|/* QPC/EEC/CQC/EQC/RDMARC attributes */
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|qpc_base
argument_list|,
name|INIT_HCA_QPC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_num_qps
argument_list|,
name|INIT_HCA_LOG_QP_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|srqc_base
argument_list|,
name|INIT_HCA_SRQC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_num_srqs
argument_list|,
name|INIT_HCA_LOG_SRQ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|cqc_base
argument_list|,
name|INIT_HCA_CQC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_num_cqs
argument_list|,
name|INIT_HCA_LOG_CQ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|altc_base
argument_list|,
name|INIT_HCA_ALTC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|auxc_base
argument_list|,
name|INIT_HCA_AUXC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|eqc_base
argument_list|,
name|INIT_HCA_EQC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_num_eqs
argument_list|,
name|INIT_HCA_LOG_EQ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|rdmarc_base
argument_list|,
name|INIT_HCA_RDMARC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_rd_per_qp
argument_list|,
name|INIT_HCA_LOG_RD_OFFSET
argument_list|)
expr_stmt|;
comment|/* multicast attributes */
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|mc_base
argument_list|,
name|INIT_HCA_MC_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_mc_entry_sz
argument_list|,
name|INIT_HCA_LOG_MC_ENTRY_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_mc_hash_sz
argument_list|,
name|INIT_HCA_LOG_MC_HASH_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_mc_table_sz
argument_list|,
name|INIT_HCA_LOG_MC_TABLE_SZ_OFFSET
argument_list|)
expr_stmt|;
comment|/* TPT attributes */
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|dmpt_base
argument_list|,
name|INIT_HCA_DMPT_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_mpt_sz
argument_list|,
name|INIT_HCA_LOG_MPT_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|mtt_base
argument_list|,
name|INIT_HCA_MTT_BASE_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|cmpt_base
argument_list|,
name|INIT_HCA_CMPT_BASE_OFFSET
argument_list|)
expr_stmt|;
comment|/* UAR attributes */
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
call|(
name|u8
call|)
argument_list|(
name|PAGE_SHIFT
operator|-
literal|12
argument_list|)
argument_list|,
name|INIT_HCA_UAR_PAGE_SZ_OFFSET
argument_list|)
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|param
operator|->
name|log_uar_sz
argument_list|,
name|INIT_HCA_LOG_UAR_SZ_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_pre_t11_mode
operator|&&
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
operator|(
name|u32
operator|)
name|MLX4_DEV_CAP_FLAG_FC_T11
condition|)
operator|*
operator|(
name|inbox
operator|+
name|INIT_HCA_FLAGS_OFFSET
operator|/
literal|4
operator|)
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|10
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_INIT_HCA
argument_list|,
literal|10000
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"INIT_HCA returns %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_INIT_PORT
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|inbox
decl_stmt|;
name|int
name|err
decl_stmt|;
name|u32
name|flags
decl_stmt|;
name|u16
name|field
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_OLD_PORT_CMDS
condition|)
block|{
define|#
directive|define
name|INIT_PORT_IN_SIZE
value|256
define|#
directive|define
name|INIT_PORT_FLAGS_OFFSET
value|0x00
define|#
directive|define
name|INIT_PORT_FLAG_SIG
value|(1<< 18)
define|#
directive|define
name|INIT_PORT_FLAG_NG
value|(1<< 17)
define|#
directive|define
name|INIT_PORT_FLAG_G0
value|(1<< 16)
define|#
directive|define
name|INIT_PORT_VL_SHIFT
value|4
define|#
directive|define
name|INIT_PORT_PORT_WIDTH_SHIFT
value|8
define|#
directive|define
name|INIT_PORT_MTU_OFFSET
value|0x04
define|#
directive|define
name|INIT_PORT_MAX_GID_OFFSET
value|0x06
define|#
directive|define
name|INIT_PORT_MAX_PKEY_OFFSET
value|0x0a
define|#
directive|define
name|INIT_PORT_GUID0_OFFSET
value|0x10
define|#
directive|define
name|INIT_PORT_NODE_GUID_OFFSET
value|0x18
define|#
directive|define
name|INIT_PORT_SI_GUID_OFFSET
value|0x20
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|inbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|memset
argument_list|(
name|inbox
argument_list|,
literal|0
argument_list|,
name|INIT_PORT_IN_SIZE
argument_list|)
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
name|flags
operator||=
operator|(
name|dev
operator|->
name|caps
operator|.
name|vl_cap
index|[
name|port
index|]
operator|&
literal|0xf
operator|)
operator|<<
name|INIT_PORT_VL_SHIFT
expr_stmt|;
name|flags
operator||=
operator|(
name|dev
operator|->
name|caps
operator|.
name|port_width_cap
index|[
name|port
index|]
operator|&
literal|0xf
operator|)
operator|<<
name|INIT_PORT_PORT_WIDTH_SHIFT
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|flags
argument_list|,
name|INIT_PORT_FLAGS_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|=
literal|128
operator|<<
name|dev
operator|->
name|caps
operator|.
name|ib_mtu_cap
index|[
name|port
index|]
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|field
argument_list|,
name|INIT_PORT_MTU_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|=
name|dev
operator|->
name|caps
operator|.
name|gid_table_len
index|[
name|port
index|]
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|field
argument_list|,
name|INIT_PORT_MAX_GID_OFFSET
argument_list|)
expr_stmt|;
name|field
operator|=
name|dev
operator|->
name|caps
operator|.
name|pkey_table_len
index|[
name|port
index|]
expr_stmt|;
name|MLX4_PUT
argument_list|(
name|inbox
argument_list|,
name|field
argument_list|,
name|INIT_PORT_MAX_PKEY_OFFSET
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_INIT_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
block|}
else|else
name|err
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_INIT_PORT
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_INIT_PORT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_CLOSE_PORT
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|)
block|{
return|return
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_CLOSE_PORT
argument_list|,
literal|1000
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_CLOSE_PORT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_CLOSE_HCA
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|panic
parameter_list|)
block|{
return|return
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|panic
argument_list|,
name|MLX4_CMD_CLOSE_HCA
argument_list|,
literal|1000
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_SET_ICM_SIZE
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|icm_size
parameter_list|,
name|u64
modifier|*
name|aux_pages
parameter_list|)
block|{
name|int
name|ret
init|=
name|mlx4_cmd_imm
argument_list|(
name|dev
argument_list|,
name|icm_size
argument_list|,
name|aux_pages
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_SET_ICM_SIZE
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
comment|/* 	 * Round up number of system pages needed in case 	 * MLX4_ICM_PAGE_SIZE< PAGE_SIZE. 	 */
operator|*
name|aux_pages
operator|=
name|ALIGN
argument_list|(
operator|*
name|aux_pages
argument_list|,
name|PAGE_SIZE
operator|/
name|MLX4_ICM_PAGE_SIZE
argument_list|)
operator|>>
operator|(
name|PAGE_SHIFT
operator|-
name|MLX4_ICM_PAGE_SHIFT
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx4_NOP
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
comment|/* Input modifier of 0x1f means "finish as soon as possible." */
return|return
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|0x1f
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_NOP
argument_list|,
literal|100
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_query_diag_counters
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|array_length
parameter_list|,
name|u8
name|op_modifier
parameter_list|,
name|u32
name|in_offset
index|[]
parameter_list|,
name|u32
name|counter_out
index|[]
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u32
modifier|*
name|outbox
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|outbox
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|ret
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|,
literal|0
argument_list|,
name|op_modifier
argument_list|,
name|MLX4_CMD_DIAG_RPRT
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|array_length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|in_offset
index|[
name|i
index|]
operator|>
name|MLX4_MAILBOX_SIZE
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|MLX4_GET
argument_list|(
name|counter_out
index|[
name|i
index|]
argument_list|,
name|outbox
argument_list|,
name|in_offset
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_query_diag_counters
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|mlx4_get_fc_t11_settings
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
modifier|*
name|enable_pre_t11
parameter_list|,
name|int
modifier|*
name|t11_supported
parameter_list|)
block|{
operator|*
name|enable_pre_t11
operator|=
operator|!
operator|!
name|mlx4_pre_t11_mode
expr_stmt|;
operator|*
name|t11_supported
operator|=
operator|!
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_FC_T11
operator|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_get_fc_t11_settings
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

