begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.  * Copyright (c) 2005, 2006, 2007, 2008 Mellanox Technologies. All rights reserved.  * Copyright (c) 2005, 2006, 2007 Cisco Systems, Inc.  All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<linux/sched.h>
end_include

begin_include
include|#
directive|include
file|<linux/pci.h>
end_include

begin_include
include|#
directive|include
file|<linux/errno.h>
end_include

begin_include
include|#
directive|include
file|<linux/mlx4/cmd.h>
end_include

begin_include
include|#
directive|include
file|<asm/io.h>
end_include

begin_include
include|#
directive|include
file|"mlx4.h"
end_include

begin_define
define|#
directive|define
name|CMD_POLL_TOKEN
value|0xffff
end_define

begin_enum
enum|enum
block|{
comment|/* command completed successfully: */
name|CMD_STAT_OK
init|=
literal|0x00
block|,
comment|/* Internal error (such as a bus error) occurred while processing command: */
name|CMD_STAT_INTERNAL_ERR
init|=
literal|0x01
block|,
comment|/* Operation/command not supported or opcode modifier not supported: */
name|CMD_STAT_BAD_OP
init|=
literal|0x02
block|,
comment|/* Parameter not supported or parameter out of range: */
name|CMD_STAT_BAD_PARAM
init|=
literal|0x03
block|,
comment|/* System not enabled or bad system state: */
name|CMD_STAT_BAD_SYS_STATE
init|=
literal|0x04
block|,
comment|/* Attempt to access reserved or unallocaterd resource: */
name|CMD_STAT_BAD_RESOURCE
init|=
literal|0x05
block|,
comment|/* Requested resource is currently executing a command, or is otherwise busy: */
name|CMD_STAT_RESOURCE_BUSY
init|=
literal|0x06
block|,
comment|/* Required capability exceeds device limits: */
name|CMD_STAT_EXCEED_LIM
init|=
literal|0x08
block|,
comment|/* Resource is not in the appropriate state or ownership: */
name|CMD_STAT_BAD_RES_STATE
init|=
literal|0x09
block|,
comment|/* Index out of range: */
name|CMD_STAT_BAD_INDEX
init|=
literal|0x0a
block|,
comment|/* FW image corrupted: */
name|CMD_STAT_BAD_NVMEM
init|=
literal|0x0b
block|,
comment|/* Error in ICM mapping (e.g. not enough auxiliary ICM pages to execute command): */
name|CMD_STAT_ICM_ERROR
init|=
literal|0x0c
block|,
comment|/* Attempt to modify a QP/EE which is not in the presumed state: */
name|CMD_STAT_BAD_QP_STATE
init|=
literal|0x10
block|,
comment|/* Bad segment parameters (Address/Size): */
name|CMD_STAT_BAD_SEG_PARAM
init|=
literal|0x20
block|,
comment|/* Memory Region has Memory Windows bound to: */
name|CMD_STAT_REG_BOUND
init|=
literal|0x21
block|,
comment|/* HCA local attached memory not present: */
name|CMD_STAT_LAM_NOT_PRE
init|=
literal|0x22
block|,
comment|/* Bad management packet (silently discarded): */
name|CMD_STAT_BAD_PKT
init|=
literal|0x30
block|,
comment|/* More outstanding CQEs in CQ than new CQ size: */
name|CMD_STAT_BAD_SIZE
init|=
literal|0x40
block|,
comment|/* Multi Function device support required: */
name|CMD_STAT_MULTI_FUNC_REQ
init|=
literal|0x50
block|, }
enum|;
end_enum

begin_enum
enum|enum
block|{
name|HCR_IN_PARAM_OFFSET
init|=
literal|0x00
block|,
name|HCR_IN_MODIFIER_OFFSET
init|=
literal|0x08
block|,
name|HCR_OUT_PARAM_OFFSET
init|=
literal|0x0c
block|,
name|HCR_TOKEN_OFFSET
init|=
literal|0x14
block|,
name|HCR_STATUS_OFFSET
init|=
literal|0x18
block|,
name|HCR_OPMOD_SHIFT
init|=
literal|12
block|,
name|HCR_T_BIT
init|=
literal|21
block|,
name|HCR_E_BIT
init|=
literal|22
block|,
name|HCR_GO_BIT
init|=
literal|23
block|}
enum|;
end_enum

begin_enum
enum|enum
block|{
name|GO_BIT_TIMEOUT_MSECS
init|=
literal|10000
block|}
enum|;
end_enum

begin_struct
struct|struct
name|mlx4_cmd_context
block|{
name|struct
name|completion
name|done
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|next
decl_stmt|;
name|u64
name|out_param
decl_stmt|;
name|u16
name|token
decl_stmt|;
name|u8
name|fw_status
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|mlx4_status_to_errno
parameter_list|(
name|u8
name|status
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|trans_table
index|[]
init|=
block|{
index|[
name|CMD_STAT_INTERNAL_ERR
index|]
operator|=
operator|-
name|EIO
block|,
index|[
name|CMD_STAT_BAD_OP
index|]
operator|=
operator|-
name|EPERM
block|,
index|[
name|CMD_STAT_BAD_PARAM
index|]
operator|=
operator|-
name|EINVAL
block|,
index|[
name|CMD_STAT_BAD_SYS_STATE
index|]
operator|=
operator|-
name|ENXIO
block|,
index|[
name|CMD_STAT_BAD_RESOURCE
index|]
operator|=
operator|-
name|EBADF
block|,
index|[
name|CMD_STAT_RESOURCE_BUSY
index|]
operator|=
operator|-
name|EBUSY
block|,
index|[
name|CMD_STAT_EXCEED_LIM
index|]
operator|=
operator|-
name|ENOMEM
block|,
index|[
name|CMD_STAT_BAD_RES_STATE
index|]
operator|=
operator|-
name|EBADF
block|,
index|[
name|CMD_STAT_BAD_INDEX
index|]
operator|=
operator|-
name|EBADF
block|,
index|[
name|CMD_STAT_BAD_NVMEM
index|]
operator|=
operator|-
name|EFAULT
block|,
index|[
name|CMD_STAT_ICM_ERROR
index|]
operator|=
operator|-
name|ENFILE
block|,
index|[
name|CMD_STAT_BAD_QP_STATE
index|]
operator|=
operator|-
name|EINVAL
block|,
index|[
name|CMD_STAT_BAD_SEG_PARAM
index|]
operator|=
operator|-
name|EFAULT
block|,
index|[
name|CMD_STAT_REG_BOUND
index|]
operator|=
operator|-
name|EBUSY
block|,
index|[
name|CMD_STAT_LAM_NOT_PRE
index|]
operator|=
operator|-
name|EAGAIN
block|,
index|[
name|CMD_STAT_BAD_PKT
index|]
operator|=
operator|-
name|EINVAL
block|,
index|[
name|CMD_STAT_BAD_SIZE
index|]
operator|=
operator|-
name|ENOMEM
block|,
index|[
name|CMD_STAT_MULTI_FUNC_REQ
index|]
operator|=
operator|-
name|EACCES
block|, 	}
decl_stmt|;
if|if
condition|(
name|status
operator|>=
name|ARRAY_SIZE
argument_list|(
name|trans_table
argument_list|)
operator|||
operator|(
name|status
operator|!=
name|CMD_STAT_OK
operator|&&
name|trans_table
index|[
name|status
index|]
operator|==
literal|0
operator|)
condition|)
return|return
operator|-
name|EIO
return|;
return|return
name|trans_table
index|[
name|status
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cmd_pending
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|u32
name|status
init|=
name|readl
argument_list|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|cmd
operator|.
name|hcr
operator|+
name|HCR_STATUS_OFFSET
argument_list|)
decl_stmt|;
return|return
operator|(
name|status
operator|&
name|swab32
argument_list|(
literal|1
operator|<<
name|HCR_GO_BIT
argument_list|)
operator|)
operator|||
operator|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|cmd
operator|.
name|toggle
operator|==
operator|!
operator|!
operator|(
name|status
operator|&
name|swab32
argument_list|(
literal|1
operator|<<
name|HCR_T_BIT
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_cmd_post
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
name|out_param
parameter_list|,
name|u32
name|in_modifier
parameter_list|,
name|u8
name|op_modifier
parameter_list|,
name|u16
name|op
parameter_list|,
name|u16
name|token
parameter_list|,
name|int
name|event
parameter_list|)
block|{
name|struct
name|mlx4_cmd
modifier|*
name|cmd
init|=
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|cmd
decl_stmt|;
name|u32
name|__iomem
modifier|*
name|hcr
init|=
name|cmd
operator|->
name|hcr
decl_stmt|;
name|int
name|ret
init|=
operator|-
name|EAGAIN
decl_stmt|;
name|unsigned
name|long
name|end
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|cmd
operator|->
name|hcr_mutex
argument_list|)
expr_stmt|;
name|end
operator|=
name|jiffies
expr_stmt|;
if|if
condition|(
name|event
condition|)
name|end
operator|+=
name|msecs_to_jiffies
argument_list|(
name|GO_BIT_TIMEOUT_MSECS
argument_list|)
expr_stmt|;
while|while
condition|(
name|cmd_pending
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|time_after_eq
argument_list|(
name|jiffies
argument_list|,
name|end
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|cond_resched
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * We use writel (instead of something like memcpy_toio) 	 * because writes of less than 32 bits to the HCR don't work 	 * (and some architectures such as ia64 implement memcpy_toio 	 * in terms of writeb). 	 */
name|__raw_writel
argument_list|(
operator|(
name|__force
name|u32
operator|)
name|cpu_to_be32
argument_list|(
name|in_param
operator|>>
literal|32
argument_list|)
argument_list|,
name|hcr
operator|+
literal|0
argument_list|)
expr_stmt|;
name|__raw_writel
argument_list|(
operator|(
name|__force
name|u32
operator|)
name|cpu_to_be32
argument_list|(
name|in_param
operator|&
literal|0xfffffffful
argument_list|)
argument_list|,
name|hcr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|__raw_writel
argument_list|(
operator|(
name|__force
name|u32
operator|)
name|cpu_to_be32
argument_list|(
name|in_modifier
argument_list|)
argument_list|,
name|hcr
operator|+
literal|2
argument_list|)
expr_stmt|;
name|__raw_writel
argument_list|(
operator|(
name|__force
name|u32
operator|)
name|cpu_to_be32
argument_list|(
name|out_param
operator|>>
literal|32
argument_list|)
argument_list|,
name|hcr
operator|+
literal|3
argument_list|)
expr_stmt|;
name|__raw_writel
argument_list|(
operator|(
name|__force
name|u32
operator|)
name|cpu_to_be32
argument_list|(
name|out_param
operator|&
literal|0xfffffffful
argument_list|)
argument_list|,
name|hcr
operator|+
literal|4
argument_list|)
expr_stmt|;
name|__raw_writel
argument_list|(
operator|(
name|__force
name|u32
operator|)
name|cpu_to_be32
argument_list|(
name|token
operator|<<
literal|16
argument_list|)
argument_list|,
name|hcr
operator|+
literal|5
argument_list|)
expr_stmt|;
comment|/* __raw_writel may not order writes. */
name|wmb
argument_list|()
expr_stmt|;
name|__raw_writel
argument_list|(
operator|(
name|__force
name|u32
operator|)
name|cpu_to_be32
argument_list|(
operator|(
literal|1
operator|<<
name|HCR_GO_BIT
operator|)
operator||
operator|(
name|cmd
operator|->
name|toggle
operator|<<
name|HCR_T_BIT
operator|)
operator||
operator|(
name|event
condition|?
operator|(
literal|1
operator|<<
name|HCR_E_BIT
operator|)
else|:
literal|0
operator|)
operator||
operator|(
name|op_modifier
operator|<<
name|HCR_OPMOD_SHIFT
operator|)
operator||
name|op
argument_list|)
argument_list|,
name|hcr
operator|+
literal|6
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure that our HCR writes don't get mixed in with 	 * writes from another CPU starting a FW command. 	 */
name|mmiowb
argument_list|()
expr_stmt|;
name|cmd
operator|->
name|toggle
operator|=
name|cmd
operator|->
name|toggle
operator|^
literal|1
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|mutex_unlock
argument_list|(
operator|&
name|cmd
operator|->
name|hcr_mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_cmd_poll
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
modifier|*
name|out_param
parameter_list|,
name|int
name|out_is_imm
parameter_list|,
name|u32
name|in_modifier
parameter_list|,
name|u8
name|op_modifier
parameter_list|,
name|u16
name|op
parameter_list|,
name|unsigned
name|long
name|timeout
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|void
name|__iomem
modifier|*
name|hcr
init|=
name|priv
operator|->
name|cmd
operator|.
name|hcr
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|unsigned
name|long
name|end
decl_stmt|;
name|u32
name|stat
decl_stmt|;
name|down
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|poll_sem
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_post
argument_list|(
name|dev
argument_list|,
name|in_param
argument_list|,
name|out_param
condition|?
operator|*
name|out_param
else|:
literal|0
argument_list|,
name|in_modifier
argument_list|,
name|op_modifier
argument_list|,
name|op
argument_list|,
name|CMD_POLL_TOKEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|end
operator|=
name|msecs_to_jiffies
argument_list|(
name|timeout
argument_list|)
operator|+
name|jiffies
expr_stmt|;
while|while
condition|(
name|cmd_pending
argument_list|(
name|dev
argument_list|)
operator|&&
name|time_before
argument_list|(
name|jiffies
argument_list|,
name|end
argument_list|)
condition|)
name|cond_resched
argument_list|()
expr_stmt|;
if|if
condition|(
name|cmd_pending
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|err
operator|=
operator|-
name|ETIMEDOUT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|out_is_imm
condition|)
operator|*
name|out_param
operator|=
operator|(
name|u64
operator|)
name|be32_to_cpu
argument_list|(
operator|(
name|__force
name|__be32
operator|)
name|__raw_readl
argument_list|(
name|hcr
operator|+
name|HCR_OUT_PARAM_OFFSET
argument_list|)
argument_list|)
operator|<<
literal|32
operator||
operator|(
name|u64
operator|)
name|be32_to_cpu
argument_list|(
operator|(
name|__force
name|__be32
operator|)
name|__raw_readl
argument_list|(
name|hcr
operator|+
name|HCR_OUT_PARAM_OFFSET
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|stat
operator|=
name|be32_to_cpu
argument_list|(
operator|(
name|__force
name|__be32
operator|)
name|__raw_readl
argument_list|(
name|hcr
operator|+
name|HCR_STATUS_OFFSET
argument_list|)
argument_list|)
operator|>>
literal|24
expr_stmt|;
name|err
operator|=
name|mlx4_status_to_errno
argument_list|(
name|stat
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|op
operator|!=
name|MLX4_CMD_SET_NODE
operator|||
name|stat
operator|!=
name|CMD_STAT_BAD_OP
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"command 0x%x failed: fw status = 0x%x\n"
argument_list|,
name|op
argument_list|,
name|stat
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|up
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|poll_sem
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|void
name|mlx4_cmd_event
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u16
name|token
parameter_list|,
name|u8
name|status
parameter_list|,
name|u64
name|out_param
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_cmd_context
modifier|*
name|context
init|=
operator|&
name|priv
operator|->
name|cmd
operator|.
name|context
index|[
name|token
operator|&
name|priv
operator|->
name|cmd
operator|.
name|token_mask
index|]
decl_stmt|;
comment|/* previously timed out command completing at long last */
if|if
condition|(
name|token
operator|!=
name|context
operator|->
name|token
condition|)
return|return;
name|context
operator|->
name|fw_status
operator|=
name|status
expr_stmt|;
name|context
operator|->
name|result
operator|=
name|mlx4_status_to_errno
argument_list|(
name|status
argument_list|)
expr_stmt|;
name|context
operator|->
name|out_param
operator|=
name|out_param
expr_stmt|;
name|complete
argument_list|(
operator|&
name|context
operator|->
name|done
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_cmd_wait
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
modifier|*
name|out_param
parameter_list|,
name|int
name|out_is_imm
parameter_list|,
name|u32
name|in_modifier
parameter_list|,
name|u8
name|op_modifier
parameter_list|,
name|u16
name|op
parameter_list|,
name|unsigned
name|long
name|timeout
parameter_list|)
block|{
name|struct
name|mlx4_cmd
modifier|*
name|cmd
init|=
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|cmd
decl_stmt|;
name|struct
name|mlx4_cmd_context
modifier|*
name|context
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|down
argument_list|(
operator|&
name|cmd
operator|->
name|event_sem
argument_list|)
expr_stmt|;
name|spin_lock
argument_list|(
operator|&
name|cmd
operator|->
name|context_lock
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|cmd
operator|->
name|free_head
operator|<
literal|0
argument_list|)
expr_stmt|;
name|context
operator|=
operator|&
name|cmd
operator|->
name|context
index|[
name|cmd
operator|->
name|free_head
index|]
expr_stmt|;
name|context
operator|->
name|token
operator|+=
name|cmd
operator|->
name|token_mask
operator|+
literal|1
expr_stmt|;
name|cmd
operator|->
name|free_head
operator|=
name|context
operator|->
name|next
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|cmd
operator|->
name|context_lock
argument_list|)
expr_stmt|;
name|init_completion
argument_list|(
operator|&
name|context
operator|->
name|done
argument_list|)
expr_stmt|;
name|mlx4_cmd_post
argument_list|(
name|dev
argument_list|,
name|in_param
argument_list|,
name|out_param
condition|?
operator|*
name|out_param
else|:
literal|0
argument_list|,
name|in_modifier
argument_list|,
name|op_modifier
argument_list|,
name|op
argument_list|,
name|context
operator|->
name|token
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wait_for_completion_timeout
argument_list|(
operator|&
name|context
operator|->
name|done
argument_list|,
name|msecs_to_jiffies
argument_list|(
name|timeout
argument_list|)
argument_list|)
condition|)
block|{
name|err
operator|=
operator|-
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|err
operator|=
name|context
operator|->
name|result
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|op
operator|!=
name|MLX4_CMD_SET_NODE
operator|||
name|context
operator|->
name|fw_status
operator|!=
name|CMD_STAT_BAD_OP
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"command 0x%x failed: fw status = 0x%x\n"
argument_list|,
name|op
argument_list|,
name|context
operator|->
name|fw_status
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|out_is_imm
condition|)
operator|*
name|out_param
operator|=
name|context
operator|->
name|out_param
expr_stmt|;
name|out
label|:
name|spin_lock
argument_list|(
operator|&
name|cmd
operator|->
name|context_lock
argument_list|)
expr_stmt|;
name|context
operator|->
name|next
operator|=
name|cmd
operator|->
name|free_head
expr_stmt|;
name|cmd
operator|->
name|free_head
operator|=
name|context
operator|-
name|cmd
operator|->
name|context
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|cmd
operator|->
name|context_lock
argument_list|)
expr_stmt|;
name|up
argument_list|(
operator|&
name|cmd
operator|->
name|event_sem
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|__mlx4_cmd
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|in_param
parameter_list|,
name|u64
modifier|*
name|out_param
parameter_list|,
name|int
name|out_is_imm
parameter_list|,
name|u32
name|in_modifier
parameter_list|,
name|u8
name|op_modifier
parameter_list|,
name|u16
name|op
parameter_list|,
name|unsigned
name|long
name|timeout
parameter_list|)
block|{
if|if
condition|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|cmd
operator|.
name|use_events
operator|&&
operator|!
name|cold
condition|)
return|return
name|mlx4_cmd_wait
argument_list|(
name|dev
argument_list|,
name|in_param
argument_list|,
name|out_param
argument_list|,
name|out_is_imm
argument_list|,
name|in_modifier
argument_list|,
name|op_modifier
argument_list|,
name|op
argument_list|,
name|timeout
argument_list|)
return|;
else|else
return|return
name|mlx4_cmd_poll
argument_list|(
name|dev
argument_list|,
name|in_param
argument_list|,
name|out_param
argument_list|,
name|out_is_imm
argument_list|,
name|in_modifier
argument_list|,
name|op_modifier
argument_list|,
name|op
argument_list|,
name|timeout
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|__mlx4_cmd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_cmd_init
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mutex_init
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|hcr_mutex
argument_list|)
expr_stmt|;
name|sema_init
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|poll_sem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|priv
operator|->
name|cmd
operator|.
name|use_events
operator|=
literal|0
expr_stmt|;
name|priv
operator|->
name|cmd
operator|.
name|toggle
operator|=
literal|1
expr_stmt|;
name|priv
operator|->
name|cmd
operator|.
name|hcr
operator|=
name|ioremap
argument_list|(
name|pci_resource_start
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|0
argument_list|)
operator|+
name|MLX4_HCR_BASE
argument_list|,
name|MLX4_HCR_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|cmd
operator|.
name|hcr
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Couldn't map command register."
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|priv
operator|->
name|cmd
operator|.
name|pool
operator|=
name|pci_pool_create
argument_list|(
literal|"mlx4_cmd"
argument_list|,
name|dev
operator|->
name|pdev
argument_list|,
name|MLX4_MAILBOX_SIZE
argument_list|,
name|MLX4_MAILBOX_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|cmd
operator|.
name|pool
condition|)
block|{
name|iounmap
argument_list|(
name|priv
operator|->
name|cmd
operator|.
name|hcr
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|mlx4_cmd_cleanup
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|pci_pool_destroy
argument_list|(
name|priv
operator|->
name|cmd
operator|.
name|pool
argument_list|)
expr_stmt|;
name|iounmap
argument_list|(
name|priv
operator|->
name|cmd
operator|.
name|hcr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Switch to using events to issue FW commands (can only be called  * after event queue for command events has been initialized).  */
end_comment

begin_function
name|int
name|mlx4_cmd_use_events
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|priv
operator|->
name|cmd
operator|.
name|context
operator|=
name|kmalloc
argument_list|(
name|priv
operator|->
name|cmd
operator|.
name|max_cmds
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_cmd_context
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|cmd
operator|.
name|context
condition|)
return|return
operator|-
name|ENOMEM
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|priv
operator|->
name|cmd
operator|.
name|max_cmds
condition|;
operator|++
name|i
control|)
block|{
name|priv
operator|->
name|cmd
operator|.
name|context
index|[
name|i
index|]
operator|.
name|token
operator|=
name|i
expr_stmt|;
name|priv
operator|->
name|cmd
operator|.
name|context
index|[
name|i
index|]
operator|.
name|next
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
name|priv
operator|->
name|cmd
operator|.
name|context
index|[
name|priv
operator|->
name|cmd
operator|.
name|max_cmds
operator|-
literal|1
index|]
operator|.
name|next
operator|=
operator|-
literal|1
expr_stmt|;
name|priv
operator|->
name|cmd
operator|.
name|free_head
operator|=
literal|0
expr_stmt|;
name|sema_init
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|event_sem
argument_list|,
name|priv
operator|->
name|cmd
operator|.
name|max_cmds
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|context_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|priv
operator|->
name|cmd
operator|.
name|token_mask
operator|=
literal|1
init|;
name|priv
operator|->
name|cmd
operator|.
name|token_mask
operator|<
name|priv
operator|->
name|cmd
operator|.
name|max_cmds
condition|;
name|priv
operator|->
name|cmd
operator|.
name|token_mask
operator|<<=
literal|1
control|)
empty_stmt|;
comment|/* nothing */
operator|--
name|priv
operator|->
name|cmd
operator|.
name|token_mask
expr_stmt|;
name|priv
operator|->
name|cmd
operator|.
name|use_events
operator|=
literal|1
expr_stmt|;
name|down
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|poll_sem
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Switch back to polling (used when shutting down the device)  */
end_comment

begin_function
name|void
name|mlx4_cmd_use_polling
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|priv
operator|->
name|cmd
operator|.
name|use_events
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|priv
operator|->
name|cmd
operator|.
name|max_cmds
condition|;
operator|++
name|i
control|)
name|down
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|event_sem
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|priv
operator|->
name|cmd
operator|.
name|context
argument_list|)
expr_stmt|;
name|up
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|poll_sem
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mlx4_alloc_cmd_mailbox
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|mailbox
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|mailbox
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mailbox
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|mailbox
operator|->
name|buf
operator|=
name|pci_pool_alloc
argument_list|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|cmd
operator|.
name|pool
argument_list|,
name|GFP_KERNEL
argument_list|,
operator|&
name|mailbox
operator|->
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mailbox
operator|->
name|buf
condition|)
block|{
name|kfree
argument_list|(
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
block|}
return|return
name|mailbox
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_alloc_cmd_mailbox
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|mlx4_free_cmd_mailbox
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|mailbox
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mailbox
condition|)
return|return;
name|pci_pool_free
argument_list|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|cmd
operator|.
name|pool
argument_list|,
name|mailbox
operator|->
name|buf
argument_list|,
name|mailbox
operator|->
name|dma
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mailbox
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_free_cmd_mailbox
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

