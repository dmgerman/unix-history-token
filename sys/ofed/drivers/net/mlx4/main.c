begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.  * Copyright (c) 2005 Sun Microsystems, Inc. All rights reserved.  * Copyright (c) 2005, 2006, 2007, 2008 Mellanox Technologies. All rights reserved.  * Copyright (c) 2006, 2007 Cisco Systems, Inc. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/init.h>
end_include

begin_include
include|#
directive|include
file|<linux/errno.h>
end_include

begin_include
include|#
directive|include
file|<linux/pci.h>
end_include

begin_include
include|#
directive|include
file|<linux/dma-mapping.h>
end_include

begin_include
include|#
directive|include
file|<linux/io-mapping.h>
end_include

begin_include
include|#
directive|include
file|<linux/mlx4/device.h>
end_include

begin_include
include|#
directive|include
file|<linux/mlx4/doorbell.h>
end_include

begin_include
include|#
directive|include
file|"mlx4.h"
end_include

begin_include
include|#
directive|include
file|"fw.h"
end_include

begin_include
include|#
directive|include
file|"icm.h"
end_include

begin_expr_stmt
name|MODULE_AUTHOR
argument_list|(
literal|"Roland Dreier"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DESCRIPTION
argument_list|(
literal|"Mellanox ConnectX HCA low-level driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_LICENSE
argument_list|(
literal|"Dual BSD/GPL"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|DRV_VERSION
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|workqueue_struct
modifier|*
name|mlx4_wq
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_MLX4_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|mlx4_debug_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|debug_level
argument_list|,
name|mlx4_debug_level
argument_list|,
name|int
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|debug_level
argument_list|,
literal|"Enable debug tracing if> 0"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_MLX4_DEBUG */
end_comment

begin_decl_stmt
name|int
name|mlx4_blck_lb
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|block_loopback
argument_list|,
name|mlx4_blck_lb
argument_list|,
name|int
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|block_loopback
argument_list|,
literal|"Block multicast loopback packets if> 0"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_PCI_MSI
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|msi_x
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param
argument_list|(
name|msi_x
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|msi_x
argument_list|,
literal|"attempt to use MSI-X if nonzero"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* CONFIG_PCI_MSI */
end_comment

begin_define
define|#
directive|define
name|msi_x
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_PCI_MSI */
end_comment

begin_decl_stmt
specifier|static
name|char
name|mlx4_version
index|[]
name|__devinitdata
init|=
name|DRV_NAME
literal|": Mellanox ConnectX core driver v"
name|DRV_VERSION
literal|" ("
name|DRV_RELDATE
literal|")\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mutex
name|drv_mutex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mlx4_profile
name|default_profile
init|=
block|{
operator|.
name|num_qp
operator|=
literal|1
operator|<<
literal|18
block|,
operator|.
name|num_srq
operator|=
literal|1
operator|<<
literal|16
block|,
operator|.
name|rdmarc_per_qp
operator|=
literal|1
operator|<<
literal|4
block|,
operator|.
name|num_cq
operator|=
literal|1
operator|<<
literal|16
block|,
operator|.
name|num_mcg
operator|=
literal|1
operator|<<
literal|13
block|,
operator|.
name|num_mpt
operator|=
literal|1
operator|<<
literal|19
block|,
operator|.
name|num_mtt
operator|=
literal|1
operator|<<
literal|20
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|log_num_mac
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_mac
argument_list|,
name|log_num_mac
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_mac
argument_list|,
literal|"Log2 max number of MACs per ETH port (1-7)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|use_prio
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|use_prio
argument_list|,
name|use_prio
argument_list|,
name|bool
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|use_prio
argument_list|,
literal|"Enable steering by VLAN priority on ETH ports "
literal|"(0/1, default 0)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mlx4_profile
name|mod_param_profile
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_qp
argument_list|,
name|mod_param_profile
operator|.
name|num_qp
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_qp
argument_list|,
literal|"log maximum number of QPs per HCA"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_srq
argument_list|,
name|mod_param_profile
operator|.
name|num_srq
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_srq
argument_list|,
literal|"log maximum number of SRQs per HCA"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_rdmarc_per_qp
argument_list|,
name|mod_param_profile
operator|.
name|rdmarc_per_qp
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_rdmarc_per_qp
argument_list|,
literal|"log number of RDMARC buffers per QP"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_cq
argument_list|,
name|mod_param_profile
operator|.
name|num_cq
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_cq
argument_list|,
literal|"log maximum number of CQs per HCA"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_mcg
argument_list|,
name|mod_param_profile
operator|.
name|num_mcg
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_mcg
argument_list|,
literal|"log maximum number of multicast groups per HCA"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_mpt
argument_list|,
name|mod_param_profile
operator|.
name|num_mpt
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_mpt
argument_list|,
literal|"log maximum number of memory protection table entries per HCA"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_mtt
argument_list|,
name|mod_param_profile
operator|.
name|num_mtt
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_mtt
argument_list|,
literal|"log maximum number of memory translation table segments per HCA"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|log_mtts_per_seg
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_mtts_per_seg
argument_list|,
name|log_mtts_per_seg
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_mtts_per_seg
argument_list|,
literal|"Log2 number of MTT entries per segment (1-7)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|process_mod_param_profile
parameter_list|(
name|void
parameter_list|)
block|{
name|default_profile
operator|.
name|num_qp
operator|=
operator|(
name|mod_param_profile
operator|.
name|num_qp
condition|?
literal|1
operator|<<
name|mod_param_profile
operator|.
name|num_qp
else|:
name|default_profile
operator|.
name|num_qp
operator|)
expr_stmt|;
name|default_profile
operator|.
name|num_srq
operator|=
operator|(
name|mod_param_profile
operator|.
name|num_srq
condition|?
literal|1
operator|<<
name|mod_param_profile
operator|.
name|num_srq
else|:
name|default_profile
operator|.
name|num_srq
operator|)
expr_stmt|;
name|default_profile
operator|.
name|rdmarc_per_qp
operator|=
operator|(
name|mod_param_profile
operator|.
name|rdmarc_per_qp
condition|?
literal|1
operator|<<
name|mod_param_profile
operator|.
name|rdmarc_per_qp
else|:
name|default_profile
operator|.
name|rdmarc_per_qp
operator|)
expr_stmt|;
name|default_profile
operator|.
name|num_cq
operator|=
operator|(
name|mod_param_profile
operator|.
name|num_cq
condition|?
literal|1
operator|<<
name|mod_param_profile
operator|.
name|num_cq
else|:
name|default_profile
operator|.
name|num_cq
operator|)
expr_stmt|;
name|default_profile
operator|.
name|num_mcg
operator|=
operator|(
name|mod_param_profile
operator|.
name|num_mcg
condition|?
literal|1
operator|<<
name|mod_param_profile
operator|.
name|num_mcg
else|:
name|default_profile
operator|.
name|num_mcg
operator|)
expr_stmt|;
name|default_profile
operator|.
name|num_mpt
operator|=
operator|(
name|mod_param_profile
operator|.
name|num_mpt
condition|?
literal|1
operator|<<
name|mod_param_profile
operator|.
name|num_mpt
else|:
name|default_profile
operator|.
name|num_mpt
operator|)
expr_stmt|;
name|default_profile
operator|.
name|num_mtt
operator|=
operator|(
name|mod_param_profile
operator|.
name|num_mtt
condition|?
literal|1
operator|<<
name|mod_param_profile
operator|.
name|num_mtt
else|:
name|default_profile
operator|.
name|num_mtt
operator|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|mlx4_port_config
block|{
name|struct
name|list_head
name|list
decl_stmt|;
name|enum
name|mlx4_port_type
name|port_type
index|[
name|MLX4_MAX_PORTS
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|pci_dev
modifier|*
name|pdev
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
name|config_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|mlx4_config_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mlx4_port_config
modifier|*
name|config
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|config
argument_list|,
argument|tmp
argument_list|,
argument|&config_list
argument_list|,
argument|list
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|config
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|config
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
modifier|*
name|mlx4_get_prot_dev
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|enum
name|mlx4_prot
name|proto
parameter_list|,
name|int
name|port
parameter_list|)
block|{
return|return
name|mlx4_find_get_prot_dev
argument_list|(
name|dev
argument_list|,
name|proto
argument_list|,
name|port
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|mlx4_get_prot_dev
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|mlx4_set_iboe_counter
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|index
parameter_list|,
name|u8
name|port
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|priv
operator|->
name|iboe_counter_index
index|[
name|port
operator|-
literal|1
index|]
operator|=
name|index
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|mlx4_set_iboe_counter
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_get_iboe_counter
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
name|priv
operator|->
name|iboe_counter_index
index|[
name|port
operator|-
literal|1
index|]
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|mlx4_get_iboe_counter
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_check_port_params
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|enum
name|mlx4_port_type
modifier|*
name|port_type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|port_type
index|[
name|i
index|]
operator|!=
name|port_type
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_DPDP
operator|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Only same port types supported "
literal|"on this HCA, aborting.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|port_type
index|[
name|i
index|]
operator|&
name|dev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|i
operator|+
literal|1
index|]
operator|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Requested port type for port %d is not "
literal|"supported on this HCA\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_set_port_mask
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
operator|++
name|i
control|)
name|dev
operator|->
name|caps
operator|.
name|port_mask
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u8
name|get_counters_mode
parameter_list|(
name|u64
name|flags
parameter_list|)
block|{
switch|switch
condition|(
name|flags
operator|>>
literal|48
operator|&
literal|3
condition|)
block|{
case|case
literal|2
case|:
case|case
literal|3
case|:
return|return
name|MLX4_CUNTERS_EXT
return|;
case|case
literal|1
case|:
return|return
name|MLX4_CUNTERS_BASIC
return|;
default|default:
return|return
name|MLX4_CUNTERS_DISABLED
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_dev_cap
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|err
operator|=
name|mlx4_QUERY_DEV_CAP
argument_list|(
name|dev
argument_list|,
name|dev_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_DEV_CAP command failed, aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|dev_cap
operator|->
name|min_page_sz
operator|>
name|PAGE_SIZE
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"HCA minimum page size of %d bigger than "
literal|"kernel PAGE_SIZE of %d, aborting.\n"
argument_list|,
name|dev_cap
operator|->
name|min_page_sz
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
if|if
condition|(
name|dev_cap
operator|->
name|num_ports
operator|>
name|MLX4_MAX_PORTS
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"HCA has %d ports, but we only support %d, "
literal|"aborting.\n"
argument_list|,
name|dev_cap
operator|->
name|num_ports
argument_list|,
name|MLX4_MAX_PORTS
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
if|if
condition|(
name|dev_cap
operator|->
name|uar_size
operator|>
name|pci_resource_len
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"HCA reported UAR size of 0x%x bigger than "
literal|"PCI resource 2 size of 0x%llx, aborting.\n"
argument_list|,
name|dev_cap
operator|->
name|uar_size
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|pci_resource_len
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
name|dev
operator|->
name|caps
operator|.
name|num_ports
operator|=
name|dev_cap
operator|->
name|num_ports
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
operator|++
name|i
control|)
block|{
name|dev
operator|->
name|caps
operator|.
name|vl_cap
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|max_vl
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|ib_mtu_cap
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|ib_mtu
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|gid_table_len
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|max_gids
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|pkey_table_len
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|max_pkeys
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|port_width_cap
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|max_port_width
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|eth_mtu_cap
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|eth_mtu
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|def_mac
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|def_mac
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|supported_port_types
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|trans_type
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|trans_type
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|vendor_oui
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|vendor_oui
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|wavelength
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|wavelength
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|trans_code
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|trans_code
index|[
name|i
index|]
expr_stmt|;
block|}
name|dev
operator|->
name|caps
operator|.
name|num_uars
operator|=
name|dev_cap
operator|->
name|uar_size
operator|/
name|PAGE_SIZE
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|local_ca_ack_delay
operator|=
name|dev_cap
operator|->
name|local_ca_ack_delay
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|bf_reg_size
operator|=
name|dev_cap
operator|->
name|bf_reg_size
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|bf_regs_per_page
operator|=
name|dev_cap
operator|->
name|bf_regs_per_page
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_sq_sg
operator|=
name|dev_cap
operator|->
name|max_sq_sg
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_rq_sg
operator|=
name|dev_cap
operator|->
name|max_rq_sg
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_wqes
operator|=
name|dev_cap
operator|->
name|max_qp_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_qp_init_rdma
operator|=
name|dev_cap
operator|->
name|max_requester_per_qp
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_srq_wqes
operator|=
name|dev_cap
operator|->
name|max_srq_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_srq_sge
operator|=
name|dev_cap
operator|->
name|max_rq_sg
operator|-
literal|1
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_srqs
operator|=
name|dev_cap
operator|->
name|reserved_srqs
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_sq_desc_sz
operator|=
name|dev_cap
operator|->
name|max_sq_desc_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_rq_desc_sz
operator|=
name|dev_cap
operator|->
name|max_rq_desc_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_qp_per_mgm
operator|=
name|MLX4_QP_PER_MGM
expr_stmt|;
comment|/* 	 * Subtract 1 from the limit because we need to allocate a 	 * spare CQE so the HCA HW can tell the difference between an 	 * empty CQ and a full CQ. 	 */
name|dev
operator|->
name|caps
operator|.
name|max_cqes
operator|=
name|dev_cap
operator|->
name|max_cq_sz
operator|-
literal|1
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_cqs
operator|=
name|dev_cap
operator|->
name|reserved_cqs
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_eqs
operator|=
name|dev_cap
operator|->
name|reserved_eqs
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|mtts_per_seg
operator|=
literal|1
operator|<<
name|log_mtts_per_seg
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_mtts
operator|=
name|DIV_ROUND_UP
argument_list|(
name|dev_cap
operator|->
name|reserved_mtts
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|mtts_per_seg
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_mrws
operator|=
name|dev_cap
operator|->
name|reserved_mrws
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_uars
operator|=
name|dev_cap
operator|->
name|reserved_uars
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_pds
operator|=
name|dev_cap
operator|->
name|reserved_pds
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|mtt_entry_sz
operator|=
name|dev
operator|->
name|caps
operator|.
name|mtts_per_seg
operator|*
name|dev_cap
operator|->
name|mtt_entry_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_msg_sz
operator|=
name|dev_cap
operator|->
name|max_msg_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|page_size_cap
operator|=
operator|~
call|(
name|u32
call|)
argument_list|(
name|dev_cap
operator|->
name|min_page_sz
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|flags
operator|=
name|dev_cap
operator|->
name|flags
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|bmme_flags
operator|=
name|dev_cap
operator|->
name|bmme_flags
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_lkey
operator|=
name|dev_cap
operator|->
name|reserved_lkey
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|stat_rate_support
operator|=
name|dev_cap
operator|->
name|stat_rate_support
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|udp_rss
operator|=
name|dev_cap
operator|->
name|udp_rss
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|loopback_support
operator|=
name|dev_cap
operator|->
name|loopback_support
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|wol
operator|=
name|dev_cap
operator|->
name|wol
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_gso_sz
operator|=
name|dev_cap
operator|->
name|max_gso_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_xrcds
operator|=
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_XRC
operator|)
condition|?
name|dev_cap
operator|->
name|reserved_xrcds
else|:
literal|0
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_xrcds
operator|=
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_XRC
operator|)
condition|?
name|dev_cap
operator|->
name|max_xrcds
else|:
literal|0
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|log_num_macs
operator|=
name|log_num_mac
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|log_num_prios
operator|=
name|use_prio
condition|?
literal|3
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
operator|++
name|i
control|)
block|{
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|=
name|MLX4_PORT_TYPE_NONE
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|i
index|]
operator|!=
name|MLX4_PORT_TYPE_ETH
condition|)
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|=
name|MLX4_PORT_TYPE_IB
expr_stmt|;
else|else
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|=
name|MLX4_PORT_TYPE_ETH
expr_stmt|;
block|}
name|dev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
expr_stmt|;
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|sense
operator|.
name|sense_allowed
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|i
index|]
operator|==
name|MLX4_PORT_TYPE_AUTO
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|log_num_macs
operator|>
name|dev_cap
operator|->
name|log_max_macs
index|[
name|i
index|]
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|log_num_macs
operator|=
name|dev_cap
operator|->
name|log_max_macs
index|[
name|i
index|]
expr_stmt|;
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Requested number of MACs is too much "
literal|"for port %d, reducing to %d.\n"
argument_list|,
name|i
argument_list|,
literal|1
operator|<<
name|dev
operator|->
name|caps
operator|.
name|log_num_macs
argument_list|)
expr_stmt|;
block|}
name|dev
operator|->
name|caps
operator|.
name|log_num_vlans
operator|=
name|dev_cap
operator|->
name|log_max_vlans
index|[
name|i
index|]
expr_stmt|;
block|}
name|dev
operator|->
name|caps
operator|.
name|counters_mode
operator|=
name|get_counters_mode
argument_list|(
name|dev_cap
operator|->
name|flags
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_basic_counters
operator|=
literal|1
operator|<<
name|ilog2
argument_list|(
name|dev_cap
operator|->
name|max_basic_counters
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_ext_counters
operator|=
literal|1
operator|<<
name|ilog2
argument_list|(
name|dev_cap
operator|->
name|max_ext_counters
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
operator|=
name|dev_cap
operator|->
name|reserved_qps
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_ETH_ADDR
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FC_ADDR
index|]
operator|=
operator|(
literal|1
operator|<<
name|dev
operator|->
name|caps
operator|.
name|log_num_macs
operator|)
operator|*
operator|(
literal|1
operator|<<
name|dev
operator|->
name|caps
operator|.
name|log_num_vlans
operator|)
operator|*
operator|(
literal|1
operator|<<
name|dev
operator|->
name|caps
operator|.
name|log_num_prios
operator|)
operator|*
name|dev
operator|->
name|caps
operator|.
name|num_ports
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_qps
operator|=
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
operator|+
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_ETH_ADDR
index|]
operator|+
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FC_ADDR
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_save_config
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_port_config
modifier|*
name|config
decl_stmt|;
name|int
name|i
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|config
argument_list|,
argument|&config_list
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|config
operator|->
name|pdev
operator|==
name|dev
operator|->
name|pdev
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
name|config
operator|->
name|port_type
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|config
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_port_config
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|config
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|config
operator|->
name|pdev
operator|=
name|dev
operator|->
name|pdev
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
name|config
operator|->
name|port_type
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
index|]
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|config
operator|->
name|list
argument_list|,
operator|&
name|config_list
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Change the port configuration of the device.  * Every user of this function must hold the port mutex.  */
end_comment

begin_function
name|int
name|mlx4_change_port_types
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|enum
name|mlx4_port_type
modifier|*
name|port_types
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|change
init|=
literal|0
decl_stmt|;
name|int
name|port
decl_stmt|;
for|for
control|(
name|port
operator|=
literal|0
init|;
name|port
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
comment|/* Change the port type only if the new type is different 		 * from the current, and not set to Auto */
if|if
condition|(
name|port_types
index|[
name|port
index|]
operator|!=
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|port
operator|+
literal|1
index|]
condition|)
block|{
name|change
operator|=
literal|1
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|port
operator|+
literal|1
index|]
operator|=
name|port_types
index|[
name|port
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|change
condition|)
block|{
name|mlx4_unregister_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
name|mlx4_CLOSE_PORT
argument_list|(
name|dev
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_SET_PORT
argument_list|(
name|dev
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to set port %d, "
literal|"aborting\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|mlx4_set_port_mask
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_save_config
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_register_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|show_port_type
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|mlx4_port_info
modifier|*
name|info
init|=
name|container_of
argument_list|(
name|attr
argument_list|,
expr|struct
name|mlx4_port_info
argument_list|,
name|port_attr
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|mdev
init|=
name|info
operator|->
name|dev
decl_stmt|;
name|char
name|type
index|[
literal|8
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|type
argument_list|,
literal|"%s"
argument_list|,
operator|(
name|mdev
operator|->
name|caps
operator|.
name|port_type
index|[
name|info
operator|->
name|port
index|]
operator|==
name|MLX4_PORT_TYPE_IB
operator|)
condition|?
literal|"ib"
else|:
literal|"eth"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|info
operator|->
name|port
index|]
operator|==
name|MLX4_PORT_TYPE_AUTO
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"auto (%s)\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|set_port_type
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|struct
name|mlx4_port_info
modifier|*
name|info
init|=
name|container_of
argument_list|(
name|attr
argument_list|,
expr|struct
name|mlx4_port_info
argument_list|,
name|port_attr
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|mdev
init|=
name|info
operator|->
name|dev
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|mdev
argument_list|)
decl_stmt|;
name|enum
name|mlx4_port_type
name|types
index|[
name|MLX4_MAX_PORTS
index|]
decl_stmt|;
name|enum
name|mlx4_port_type
name|new_types
index|[
name|MLX4_MAX_PORTS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"ib\n"
argument_list|)
condition|)
name|info
operator|->
name|tmp_type
operator|=
name|MLX4_PORT_TYPE_IB
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"eth\n"
argument_list|)
condition|)
name|info
operator|->
name|tmp_type
operator|=
name|MLX4_PORT_TYPE_ETH
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"auto\n"
argument_list|)
condition|)
name|info
operator|->
name|tmp_type
operator|=
name|MLX4_PORT_TYPE_AUTO
expr_stmt|;
else|else
block|{
name|mlx4_err
argument_list|(
name|mdev
argument_list|,
literal|"%s is not supported port type\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|mlx4_stop_sense
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|port_mutex
argument_list|)
expr_stmt|;
comment|/* Possible type is always the one that was delivered */
name|mdev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|info
operator|->
name|port
index|]
operator|=
name|info
operator|->
name|tmp_type
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mdev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|types
index|[
name|i
index|]
operator|=
name|priv
operator|->
name|port
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|tmp_type
condition|?
name|priv
operator|->
name|port
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|tmp_type
else|:
name|mdev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|types
index|[
name|i
index|]
operator|==
name|MLX4_PORT_TYPE_AUTO
condition|)
name|types
index|[
name|i
index|]
operator|=
name|mdev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|priv
operator|->
name|trig
condition|)
block|{
if|if
condition|(
operator|++
name|priv
operator|->
name|changed_ports
operator|<
name|mdev
operator|->
name|caps
operator|.
name|num_ports
condition|)
goto|goto
name|out
goto|;
else|else
name|priv
operator|->
name|trig
operator|=
name|priv
operator|->
name|changed_ports
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|mdev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_DPDP
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|mdev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mdev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
index|]
operator|==
name|MLX4_PORT_TYPE_AUTO
condition|)
block|{
name|mdev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
index|]
operator|=
name|mdev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|mdev
argument_list|,
literal|"Auto sensing is not supported on this HCA. "
literal|"Set only 'eth' or 'ib' for both ports "
literal|"(should be the same)\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mlx4_do_sense_ports
argument_list|(
name|mdev
argument_list|,
name|new_types
argument_list|,
name|types
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_check_port_params
argument_list|(
name|mdev
argument_list|,
name|new_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
comment|/* We are about to apply the changes after the configuration 	 * was verified, no need to remember the temporary types 	 * any more */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mdev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
name|priv
operator|->
name|port
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|tmp_type
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|mlx4_change_port_types
argument_list|(
name|mdev
argument_list|,
name|new_types
argument_list|)
expr_stmt|;
name|out
label|:
name|mlx4_start_sense
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|port_mutex
argument_list|)
expr_stmt|;
return|return
name|err
condition|?
name|err
else|:
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|trigger_port
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|struct
name|pci_dev
modifier|*
name|pdev
init|=
name|to_pci_dev
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|mdev
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|container_of
argument_list|(
name|mdev
argument_list|,
expr|struct
name|mlx4_priv
argument_list|,
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|priv
condition|)
return|return
operator|-
name|ENODEV
return|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|port_mutex
argument_list|)
expr_stmt|;
name|priv
operator|->
name|trig
operator|=
literal|1
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|port_mutex
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_expr_stmt
name|DEVICE_ATTR
argument_list|(
name|port_trigger
argument_list|,
name|S_IWUGO
argument_list|,
name|NULL
argument_list|,
name|trigger_port
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|mlx4_load_fw
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|priv
operator|->
name|fw
operator|.
name|fw_icm
operator|=
name|mlx4_alloc_icm
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|fw_pages
argument_list|,
name|GFP_HIGHUSER
operator||
name|__GFP_NOWARN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|fw
operator|.
name|fw_icm
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Couldn't allocate FW area, aborting.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|err
operator|=
name|mlx4_MAP_FA
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|fw_icm
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"MAP_FA command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free
goto|;
block|}
name|err
operator|=
name|mlx4_RUN_FW
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"RUN_FW command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_fa
goto|;
block|}
return|return
literal|0
return|;
name|err_unmap_fa
label|:
name|mlx4_UNMAP_FA
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_free
label|:
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|fw_icm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_cmpt_table
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|cmpt_base
parameter_list|,
name|int
name|cmpt_entry_sz
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|cmpt_table
argument_list|,
name|cmpt_base
operator|+
operator|(
call|(
name|u64
call|)
argument_list|(
name|MLX4_CMPT_TYPE_QP
operator|*
name|cmpt_entry_sz
argument_list|)
operator|<<
name|MLX4_CMPT_SHIFT
operator|)
argument_list|,
name|cmpt_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_qps
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err
goto|;
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|cmpt_table
argument_list|,
name|cmpt_base
operator|+
operator|(
call|(
name|u64
call|)
argument_list|(
name|MLX4_CMPT_TYPE_SRQ
operator|*
name|cmpt_entry_sz
argument_list|)
operator|<<
name|MLX4_CMPT_SHIFT
operator|)
argument_list|,
name|cmpt_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_srqs
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_srqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_qp
goto|;
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|cmpt_table
argument_list|,
name|cmpt_base
operator|+
operator|(
call|(
name|u64
call|)
argument_list|(
name|MLX4_CMPT_TYPE_CQ
operator|*
name|cmpt_entry_sz
argument_list|)
operator|<<
name|MLX4_CMPT_SHIFT
operator|)
argument_list|,
name|cmpt_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_cqs
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_cqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_srq
goto|;
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|cmpt_table
argument_list|,
name|cmpt_base
operator|+
operator|(
call|(
name|u64
call|)
argument_list|(
name|MLX4_CMPT_TYPE_EQ
operator|*
name|cmpt_entry_sz
argument_list|)
operator|<<
name|MLX4_CMPT_SHIFT
operator|)
argument_list|,
name|cmpt_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_eqs
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_eqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_cq
goto|;
return|return
literal|0
return|;
name|err_cq
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|err_srq
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|err_qp
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|err
label|:
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_icm
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
parameter_list|,
name|struct
name|mlx4_init_hca_param
modifier|*
name|init_hca
parameter_list|,
name|u64
name|icm_size
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u64
name|aux_pages
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|mlx4_SET_ICM_SIZE
argument_list|(
name|dev
argument_list|,
name|icm_size
argument_list|,
operator|&
name|aux_pages
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"SET_ICM_SIZE command failed, aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%lld KB of HCA context requires %lld KB aux memory.\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|icm_size
operator|>>
literal|10
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|aux_pages
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|priv
operator|->
name|fw
operator|.
name|aux_icm
operator|=
name|mlx4_alloc_icm
argument_list|(
name|dev
argument_list|,
name|aux_pages
argument_list|,
name|GFP_HIGHUSER
operator||
name|__GFP_NOWARN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|fw
operator|.
name|aux_icm
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Couldn't allocate aux memory, aborting.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|err
operator|=
name|mlx4_MAP_ICM_AUX
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|aux_icm
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"MAP_ICM_AUX command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free_aux
goto|;
block|}
name|err
operator|=
name|mlx4_init_cmpt_table
argument_list|(
name|dev
argument_list|,
name|init_hca
operator|->
name|cmpt_base
argument_list|,
name|dev_cap
operator|->
name|cmpt_entry_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map cMPT context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_aux
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|table
argument_list|,
name|init_hca
operator|->
name|eqc_base
argument_list|,
name|dev_cap
operator|->
name|eqc_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_eqs
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_eqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map EQ context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_cmpt
goto|;
block|}
comment|/* 	 * Reserved MTT entries must be aligned up to a cacheline 	 * boundary, since the FW will write to them, while the driver 	 * writes to all other MTT entries. (The variable 	 * dev->caps.mtt_entry_sz below is really the MTT segment 	 * size, not the raw entry size) 	 */
name|dev
operator|->
name|caps
operator|.
name|reserved_mtts
operator|=
name|ALIGN
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|reserved_mtts
operator|*
name|dev
operator|->
name|caps
operator|.
name|mtt_entry_sz
argument_list|,
name|dma_get_cache_alignment
argument_list|()
argument_list|)
operator|/
name|dev
operator|->
name|caps
operator|.
name|mtt_entry_sz
expr_stmt|;
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mr_table
operator|.
name|mtt_table
argument_list|,
name|init_hca
operator|->
name|mtt_base
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|mtt_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_mtt_segs
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_mtts
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map MTT context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_eq
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mr_table
operator|.
name|dmpt_table
argument_list|,
name|init_hca
operator|->
name|dmpt_base
argument_list|,
name|dev_cap
operator|->
name|dmpt_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_mpts
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_mrws
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map dMPT context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_mtt
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|qp_table
argument_list|,
name|init_hca
operator|->
name|qpc_base
argument_list|,
name|dev_cap
operator|->
name|qpc_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_qps
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map QP context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_dmpt
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|auxc_table
argument_list|,
name|init_hca
operator|->
name|auxc_base
argument_list|,
name|dev_cap
operator|->
name|aux_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_qps
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map AUXC context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_qp
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|altc_table
argument_list|,
name|init_hca
operator|->
name|altc_base
argument_list|,
name|dev_cap
operator|->
name|altc_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_qps
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map ALTC context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_auxc
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|rdmarc_table
argument_list|,
name|init_hca
operator|->
name|rdmarc_base
argument_list|,
name|dev_cap
operator|->
name|rdmarc_entry_sz
operator|<<
name|priv
operator|->
name|qp_table
operator|.
name|rdmarc_shift
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_qps
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map RDMARC context memory, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_altc
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|table
argument_list|,
name|init_hca
operator|->
name|cqc_base
argument_list|,
name|dev_cap
operator|->
name|cqc_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_cqs
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_cqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map CQ context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_rdmarc
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|table
argument_list|,
name|init_hca
operator|->
name|srqc_base
argument_list|,
name|dev_cap
operator|->
name|srq_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_srqs
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_srqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map SRQ context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_cq
goto|;
block|}
comment|/* 	 * It's not strictly required, but for simplicity just map the 	 * whole multicast group table now.  The table isn't very big 	 * and it's a lot easier than trying to track ref counts. 	 */
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mcg_table
operator|.
name|table
argument_list|,
name|init_hca
operator|->
name|mc_base
argument_list|,
name|MLX4_MGM_ENTRY_SIZE
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_mgms
operator|+
name|dev
operator|->
name|caps
operator|.
name|num_amgms
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_mgms
operator|+
name|dev
operator|->
name|caps
operator|.
name|num_amgms
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map MCG context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_srq
goto|;
block|}
return|return
literal|0
return|;
name|err_unmap_srq
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|err_unmap_cq
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|err_unmap_rdmarc
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|rdmarc_table
argument_list|)
expr_stmt|;
name|err_unmap_altc
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|altc_table
argument_list|)
expr_stmt|;
name|err_unmap_auxc
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|auxc_table
argument_list|)
expr_stmt|;
name|err_unmap_qp
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|qp_table
argument_list|)
expr_stmt|;
name|err_unmap_dmpt
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mr_table
operator|.
name|dmpt_table
argument_list|)
expr_stmt|;
name|err_unmap_mtt
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mr_table
operator|.
name|mtt_table
argument_list|)
expr_stmt|;
name|err_unmap_eq
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|err_unmap_cmpt
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|err_unmap_aux
label|:
name|mlx4_UNMAP_ICM_AUX
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_free_aux
label|:
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|aux_icm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_free_icms
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mcg_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|rdmarc_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|altc_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|auxc_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|qp_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mr_table
operator|.
name|dmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mr_table
operator|.
name|mtt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_UNMAP_ICM_AUX
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|aux_icm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|map_bf_area
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|resource_size_t
name|bf_start
decl_stmt|;
name|resource_size_t
name|bf_len
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|bf_start
operator|=
name|pci_resource_start
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
operator|+
operator|(
name|dev
operator|->
name|caps
operator|.
name|num_uars
operator|<<
name|PAGE_SHIFT
operator|)
expr_stmt|;
name|bf_len
operator|=
name|pci_resource_len
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
operator|-
operator|(
name|dev
operator|->
name|caps
operator|.
name|num_uars
operator|<<
name|PAGE_SHIFT
operator|)
expr_stmt|;
name|priv
operator|->
name|bf_mapping
operator|=
name|io_mapping_create_wc
argument_list|(
name|bf_start
argument_list|,
name|bf_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|bf_mapping
condition|)
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unmap_bf_area
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|bf_mapping
condition|)
name|io_mapping_free
argument_list|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|bf_mapping
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_close_hca
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|unmap_bf_area
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_CLOSE_HCA
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mlx4_free_icms
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_UNMAP_FA
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|fw
operator|.
name|fw_icm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_hca
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_adapter
name|adapter
decl_stmt|;
name|struct
name|mlx4_dev_cap
name|dev_cap
decl_stmt|;
name|struct
name|mlx4_mod_stat_cfg
name|mlx4_cfg
decl_stmt|;
name|struct
name|mlx4_profile
name|profile
decl_stmt|;
name|struct
name|mlx4_init_hca_param
name|init_hca
decl_stmt|;
name|struct
name|mlx4_port_config
modifier|*
name|config
decl_stmt|;
name|u64
name|icm_size
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|err
operator|=
name|mlx4_QUERY_FW
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|==
operator|-
name|EACCES
condition|)
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"non-primary physical function, skipping.\n"
argument_list|)
expr_stmt|;
else|else
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_FW command failed, aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|mlx4_load_fw
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to start FW, aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|mlx4_cfg
operator|.
name|log_pg_sz_m
operator|=
literal|1
expr_stmt|;
name|mlx4_cfg
operator|.
name|log_pg_sz
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|mlx4_MOD_STAT_CFG
argument_list|(
name|dev
argument_list|,
operator|&
name|mlx4_cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Failed to override log_pg_sz parameter\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_dev_cap
argument_list|(
name|dev
argument_list|,
operator|&
name|dev_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_DEV_CAP command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_stop_fw
goto|;
block|}
name|process_mod_param_profile
argument_list|()
expr_stmt|;
name|profile
operator|=
name|default_profile
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|config
argument_list|,
argument|&config_list
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|config
operator|->
name|pdev
operator|==
name|dev
operator|->
name|pdev
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|dev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
index|]
operator|=
name|config
operator|->
name|port_type
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|config
operator|->
name|port_type
index|[
name|i
index|]
operator|!=
name|MLX4_PORT_TYPE_AUTO
condition|)
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|=
name|config
operator|->
name|port_type
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
name|mlx4_set_port_mask
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|icm_size
operator|=
name|mlx4_make_profile
argument_list|(
name|dev
argument_list|,
operator|&
name|profile
argument_list|,
operator|&
name|dev_cap
argument_list|,
operator|&
name|init_hca
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|long
name|long
operator|)
name|icm_size
operator|<
literal|0
condition|)
block|{
name|err
operator|=
name|icm_size
expr_stmt|;
goto|goto
name|err_stop_fw
goto|;
block|}
if|if
condition|(
name|map_bf_area
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Kernel support for blue flame is not available for kernels< 2.6.28\n"
argument_list|)
expr_stmt|;
name|init_hca
operator|.
name|log_uar_sz
operator|=
name|ilog2
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|num_uars
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_init_icm
argument_list|(
name|dev
argument_list|,
operator|&
name|dev_cap
argument_list|,
operator|&
name|init_hca
argument_list|,
name|icm_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_stop_fw
goto|;
name|err
operator|=
name|mlx4_INIT_HCA
argument_list|(
name|dev
argument_list|,
operator|&
name|init_hca
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"INIT_HCA command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free_icm
goto|;
block|}
name|err
operator|=
name|mlx4_QUERY_ADAPTER
argument_list|(
name|dev
argument_list|,
operator|&
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_ADAPTER command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_close
goto|;
block|}
name|priv
operator|->
name|eq_table
operator|.
name|inta_pin
operator|=
name|adapter
operator|.
name|inta_pin
expr_stmt|;
name|memcpy
argument_list|(
name|dev
operator|->
name|board_id
argument_list|,
name|adapter
operator|.
name|board_id
argument_list|,
sizeof|sizeof
name|dev
operator|->
name|board_id
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_close
label|:
name|mlx4_CLOSE_HCA
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err_free_icm
label|:
name|mlx4_free_icms
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_stop_fw
label|:
name|unmap_bf_area
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_UNMAP_FA
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|fw_icm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_counters_table
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|nent
decl_stmt|;
switch|switch
condition|(
name|dev
operator|->
name|caps
operator|.
name|counters_mode
condition|)
block|{
case|case
name|MLX4_CUNTERS_BASIC
case|:
name|nent
operator|=
name|dev
operator|->
name|caps
operator|.
name|max_basic_counters
expr_stmt|;
break|break;
case|case
name|MLX4_CUNTERS_EXT
case|:
name|nent
operator|=
name|dev
operator|->
name|caps
operator|.
name|max_ext_counters
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|ENOENT
return|;
block|}
name|err
operator|=
name|mlx4_bitmap_init
argument_list|(
operator|&
name|priv
operator|->
name|counters_bitmap
argument_list|,
name|nent
argument_list|,
name|nent
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_cleanup_counters_table
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
switch|switch
condition|(
name|dev
operator|->
name|caps
operator|.
name|counters_mode
condition|)
block|{
case|case
name|MLX4_CUNTERS_BASIC
case|:
case|case
name|MLX4_CUNTERS_EXT
case|:
name|mlx4_bitmap_cleanup
argument_list|(
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|counters_bitmap
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_function
name|int
name|mlx4_counter_alloc
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u32
modifier|*
name|idx
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|dev
operator|->
name|caps
operator|.
name|counters_mode
condition|)
block|{
case|case
name|MLX4_CUNTERS_BASIC
case|:
case|case
name|MLX4_CUNTERS_EXT
case|:
operator|*
name|idx
operator|=
name|mlx4_bitmap_alloc
argument_list|(
operator|&
name|priv
operator|->
name|counters_bitmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|idx
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
name|ENOMEM
return|;
return|return
literal|0
return|;
default|default:
return|return
operator|-
name|ENOMEM
return|;
block|}
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_counter_alloc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|mlx4_counter_free
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|idx
parameter_list|)
block|{
switch|switch
condition|(
name|dev
operator|->
name|caps
operator|.
name|counters_mode
condition|)
block|{
case|case
name|MLX4_CUNTERS_BASIC
case|:
case|case
name|MLX4_CUNTERS_EXT
case|:
name|mlx4_bitmap_free
argument_list|(
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|counters_bitmap
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return;
default|default:
return|return;
block|}
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_counter_free
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|mlx4_setup_hca
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|port
decl_stmt|;
name|__be32
name|ib_port_default_caps
decl_stmt|;
name|err
operator|=
name|mlx4_init_uar_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"user access region table, aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|mlx4_uar_alloc
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|driver_uar
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to allocate driver access region, "
literal|"aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_uar_table_free
goto|;
block|}
name|priv
operator|->
name|kar
operator|=
name|ioremap
argument_list|(
name|priv
operator|->
name|driver_uar
operator|.
name|pfn
operator|<<
name|PAGE_SHIFT
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|kar
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Couldn't map kernel access region, "
literal|"aborting.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_uar_free
goto|;
block|}
name|err
operator|=
name|mlx4_init_pd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"protection domain table, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_kar_unmap
goto|;
block|}
name|err
operator|=
name|mlx4_init_xrcd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize extended "
literal|"reliably connected domain table, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_pd_table_free
goto|;
block|}
name|err
operator|=
name|mlx4_init_mr_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"memory region table, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_xrcd_table_free
goto|;
block|}
name|err
operator|=
name|mlx4_init_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"event queue table, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_mr_table_free
goto|;
block|}
name|err
operator|=
name|mlx4_cmd_use_events
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to switch to event-driven "
literal|"firmware commands, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_eq_table_free
goto|;
block|}
name|err
operator|=
name|mlx4_NOP
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_MSI_X
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"NOP command failed to generate MSI-X "
literal|"interrupt IRQ %d).\n"
argument_list|,
name|priv
operator|->
name|eq_table
operator|.
name|eq
index|[
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
index|]
operator|.
name|irq
argument_list|)
expr_stmt|;
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Trying again without MSI-X.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"NOP command failed to generate interrupt "
literal|"(IRQ %d), aborting.\n"
argument_list|,
name|priv
operator|->
name|eq_table
operator|.
name|eq
index|[
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
index|]
operator|.
name|irq
argument_list|)
expr_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"BIOS or ACPI interrupt routing problem?\n"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|err_cmd_poll
goto|;
block|}
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"NOP command IRQ test passed\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_init_cq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"completion queue table, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_cmd_poll
goto|;
block|}
name|err
operator|=
name|mlx4_init_srq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"shared receive queue table, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_cq_table_free
goto|;
block|}
name|err
operator|=
name|mlx4_init_qp_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"queue pair table, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_srq_table_free
goto|;
block|}
name|err
operator|=
name|mlx4_init_mcg_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"multicast group table, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_qp_table_free
goto|;
block|}
name|err
operator|=
name|mlx4_init_counters_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|!=
operator|-
name|ENOENT
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize counters table, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_mcg_table_free
goto|;
block|}
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
name|ib_port_default_caps
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|mlx4_get_port_ib_caps
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
operator|&
name|ib_port_default_caps
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"failed to get port %d default "
literal|"ib capabilities (%d). Continuing with "
literal|"caps = 0\n"
argument_list|,
name|port
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|ib_port_def_cap
index|[
name|port
index|]
operator|=
name|ib_port_default_caps
expr_stmt|;
name|err
operator|=
name|mlx4_SET_PORT
argument_list|(
name|dev
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to set port %d, aborting\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
goto|goto
name|err_counters_table_free
goto|;
block|}
block|}
return|return
literal|0
return|;
name|err_counters_table_free
label|:
name|mlx4_cleanup_counters_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_mcg_table_free
label|:
name|mlx4_cleanup_mcg_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_qp_table_free
label|:
name|mlx4_cleanup_qp_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_srq_table_free
label|:
name|mlx4_cleanup_srq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_cq_table_free
label|:
name|mlx4_cleanup_cq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_cmd_poll
label|:
name|mlx4_cmd_use_polling
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_eq_table_free
label|:
name|mlx4_cleanup_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_mr_table_free
label|:
name|mlx4_cleanup_mr_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_xrcd_table_free
label|:
name|mlx4_cleanup_xrcd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_pd_table_free
label|:
name|mlx4_cleanup_pd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_kar_unmap
label|:
name|iounmap
argument_list|(
name|priv
operator|->
name|kar
argument_list|)
expr_stmt|;
name|err_uar_free
label|:
name|mlx4_uar_free
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|driver_uar
argument_list|)
expr_stmt|;
name|err_uar_table_free
label|:
name|mlx4_cleanup_uar_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_enable_msi_x
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|msix_entry
modifier|*
name|entries
decl_stmt|;
name|int
name|nreq
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|msi_x
condition|)
block|{
name|nreq
operator|=
name|min_t
argument_list|(
name|int
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_eqs
operator|-
name|dev
operator|->
name|caps
operator|.
name|reserved_eqs
argument_list|,
name|num_possible_cpus
argument_list|()
operator|+
literal|1
argument_list|)
expr_stmt|;
name|entries
operator|=
name|kcalloc
argument_list|(
name|nreq
argument_list|,
sizeof|sizeof
expr|*
name|entries
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entries
condition|)
goto|goto
name|no_msi
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nreq
condition|;
operator|++
name|i
control|)
name|entries
index|[
name|i
index|]
operator|.
name|entry
operator|=
name|i
expr_stmt|;
name|retry
label|:
name|err
operator|=
name|pci_enable_msix
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|entries
argument_list|,
name|nreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* Try again if at least 2 vectors are available */
if|if
condition|(
name|err
operator|>
literal|1
condition|)
block|{
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"Requested %d vectors, "
literal|"but only %d MSI-X vectors available, "
literal|"trying again\n"
argument_list|,
name|nreq
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|nreq
operator|=
name|err
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|kfree
argument_list|(
name|entries
argument_list|)
expr_stmt|;
goto|goto
name|no_msi
goto|;
block|}
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
operator|=
name|nreq
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nreq
condition|;
operator|++
name|i
control|)
name|priv
operator|->
name|eq_table
operator|.
name|eq
index|[
name|i
index|]
operator|.
name|irq
operator|=
name|entries
index|[
name|i
index|]
operator|.
name|vector
expr_stmt|;
name|dev
operator|->
name|flags
operator||=
name|MLX4_FLAG_MSI_X
expr_stmt|;
name|kfree
argument_list|(
name|entries
argument_list|)
expr_stmt|;
return|return;
block|}
name|no_msi
label|:
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
name|priv
operator|->
name|eq_table
operator|.
name|eq
index|[
name|i
index|]
operator|.
name|irq
operator|=
name|dev
operator|->
name|pdev
operator|->
name|irq
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_port_info
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_port_info
modifier|*
name|info
init|=
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|port
index|[
name|port
index|]
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|info
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|info
operator|->
name|port
operator|=
name|port
expr_stmt|;
name|mlx4_init_mac_table
argument_list|(
name|dev
argument_list|,
operator|&
name|info
operator|->
name|mac_table
argument_list|)
expr_stmt|;
name|mlx4_init_vlan_table
argument_list|(
name|dev
argument_list|,
operator|&
name|info
operator|->
name|vlan_table
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|info
operator|->
name|dev_name
argument_list|,
literal|"mlx4_port%d"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|info
operator|->
name|port_attr
operator|.
name|attr
operator|.
name|name
operator|=
name|info
operator|->
name|dev_name
expr_stmt|;
name|info
operator|->
name|port_attr
operator|.
name|attr
operator|.
name|mode
operator|=
name|S_IRUGO
operator||
name|S_IWUSR
expr_stmt|;
name|info
operator|->
name|port_attr
operator|.
name|show
operator|=
name|show_port_type
expr_stmt|;
name|info
operator|->
name|port_attr
operator|.
name|store
operator|=
name|set_port_type
expr_stmt|;
name|err
operator|=
name|device_create_file
argument_list|(
operator|&
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
operator|&
name|info
operator|->
name|port_attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to create file for port %d\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|info
operator|->
name|port
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_cleanup_port_info
parameter_list|(
name|struct
name|mlx4_port_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|info
operator|->
name|port
operator|<
literal|0
condition|)
return|return;
name|device_remove_file
argument_list|(
operator|&
name|info
operator|->
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
operator|&
name|info
operator|->
name|port_attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_trigger
parameter_list|(
name|struct
name|mlx4_priv
modifier|*
name|priv
parameter_list|)
block|{
name|memcpy
argument_list|(
operator|&
name|priv
operator|->
name|trigger_attr
argument_list|,
operator|&
name|dev_attr_port_trigger
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|device_attribute
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|device_create_file
argument_list|(
operator|&
name|priv
operator|->
name|dev
operator|.
name|pdev
operator|->
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|trigger_attr
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__mlx4_init_one
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
specifier|const
name|struct
name|pci_device_id
modifier|*
name|id
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|dev
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|port
decl_stmt|;
name|int
name|i
decl_stmt|;
name|printk
argument_list|(
argument|KERN_INFO PFX
literal|"Initializing %s\n"
argument_list|,
argument|pci_name(pdev)
argument_list|)
empty_stmt|;
name|err
operator|=
name|pci_enable_device
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Cannot enable PCI device, "
literal|"aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* 	 * Check for BARs.  We expect 0: 1MB 	 */
if|if
condition|(
operator|!
operator|(
name|pci_resource_flags
argument_list|(
name|pdev
argument_list|,
literal|0
argument_list|)
operator|&
name|IORESOURCE_MEM
operator|)
operator|||
name|pci_resource_len
argument_list|(
name|pdev
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
operator|<<
literal|20
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Missing DCS, aborting.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|err_disable_pdev
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|pci_resource_flags
argument_list|(
name|pdev
argument_list|,
literal|2
argument_list|)
operator|&
name|IORESOURCE_MEM
operator|)
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Missing UAR, aborting.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|err_disable_pdev
goto|;
block|}
name|err
operator|=
name|pci_request_region
argument_list|(
name|pdev
argument_list|,
literal|0
argument_list|,
name|DRV_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Cannot request control region, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_disable_pdev
goto|;
block|}
name|err
operator|=
name|pci_request_region
argument_list|(
name|pdev
argument_list|,
literal|2
argument_list|,
name|DRV_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Cannot request UAR region, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_release_bar0
goto|;
block|}
name|pci_set_master
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|err
operator|=
name|pci_set_dma_mask
argument_list|(
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|64
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_warn
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Warning: couldn't set 64-bit PCI DMA mask.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|pci_set_dma_mask
argument_list|(
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Can't set PCI DMA mask, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_release_bar2
goto|;
block|}
block|}
name|err
operator|=
name|pci_set_consistent_dma_mask
argument_list|(
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|64
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_warn
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Warning: couldn't set 64-bit "
literal|"consistent PCI DMA mask.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|pci_set_consistent_dma_mask
argument_list|(
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Can't set consistent PCI DMA mask, "
literal|"aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_release_bar2
goto|;
block|}
block|}
name|priv
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|priv
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Device struct alloc failed, "
literal|"aborting.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_release_bar2
goto|;
block|}
name|dev
operator|=
operator|&
name|priv
operator|->
name|dev
expr_stmt|;
name|dev
operator|->
name|pdev
operator|=
name|pdev
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|ctx_list
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|priv
operator|->
name|ctx_lock
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|priv
operator|->
name|port_mutex
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|pgdir_list
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|priv
operator|->
name|pgdir_mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MLX4_MAX_PORTS
condition|;
operator|++
name|i
control|)
name|priv
operator|->
name|iboe_counter_index
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|bf_list
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|priv
operator|->
name|bf_mutex
argument_list|)
expr_stmt|;
comment|/* 	 * Now reset the HCA before we touch the PCI capabilities or 	 * attempt a firmware command, since a boot ROM may have left 	 * the HCA in an undefined state. 	 */
name|err
operator|=
name|mlx4_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to reset HCA, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free_dev
goto|;
block|}
if|if
condition|(
name|mlx4_cmd_init
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to init command interface, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free_dev
goto|;
block|}
name|err
operator|=
name|mlx4_init_hca
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_cmd
goto|;
name|err
operator|=
name|mlx4_alloc_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_close
goto|;
name|mlx4_enable_msi_x
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_setup_hca
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
operator|-
name|EBUSY
operator|&&
operator|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_MSI_X
operator|)
condition|)
block|{
name|dev
operator|->
name|flags
operator|&=
operator|~
name|MLX4_FLAG_MSI_X
expr_stmt|;
name|pci_disable_msix
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_setup_hca
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
goto|goto
name|err_free_eq
goto|;
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
name|err
operator|=
name|mlx4_init_port_info
argument_list|(
name|dev
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_port
goto|;
block|}
name|err
operator|=
name|mlx4_register_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_port
goto|;
name|err
operator|=
name|mlx4_init_trigger
argument_list|(
name|priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_register
goto|;
name|err
operator|=
name|mlx4_sense_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_trigger
goto|;
name|mlx4_start_sense
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pci_set_drvdata
argument_list|(
name|pdev
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_trigger
label|:
name|device_remove_file
argument_list|(
operator|&
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|trigger_attr
argument_list|)
expr_stmt|;
name|err_register
label|:
name|mlx4_unregister_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_port
label|:
for|for
control|(
operator|--
name|port
init|;
name|port
operator|>=
literal|1
condition|;
operator|--
name|port
control|)
name|mlx4_cleanup_port_info
argument_list|(
operator|&
name|priv
operator|->
name|port
index|[
name|port
index|]
argument_list|)
expr_stmt|;
name|mlx4_cleanup_counters_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_mcg_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_qp_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_srq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_cq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cmd_use_polling
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_mr_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_xrcd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_pd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_uar_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_free_eq
label|:
name|mlx4_free_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_close
label|:
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_MSI_X
condition|)
name|pci_disable_msix
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|mlx4_close_hca
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_cmd
label|:
name|mlx4_cmd_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_free_dev
label|:
name|kfree
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|err_release_bar2
label|:
name|pci_release_region
argument_list|(
name|pdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|err_release_bar0
label|:
name|pci_release_region
argument_list|(
name|pdev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err_disable_pdev
label|:
name|pci_disable_device
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|pci_set_drvdata
argument_list|(
name|pdev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__devinit
name|mlx4_init_one
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
specifier|const
name|struct
name|pci_device_id
modifier|*
name|id
parameter_list|)
block|{
specifier|static
name|int
name|mlx4_version_printed
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_version_printed
condition|)
block|{
name|printk
argument_list|(
name|KERN_INFO
literal|"%s"
argument_list|,
name|mlx4_version
argument_list|)
expr_stmt|;
operator|++
name|mlx4_version_printed
expr_stmt|;
block|}
return|return
name|__mlx4_init_one
argument_list|(
name|pdev
argument_list|,
name|id
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_remove_one
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|p
decl_stmt|;
if|if
condition|(
name|dev
condition|)
block|{
name|mlx4_sense_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_unregister_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|device_remove_file
argument_list|(
operator|&
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|trigger_attr
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|1
init|;
name|p
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|p
operator|++
control|)
block|{
name|mlx4_cleanup_port_info
argument_list|(
operator|&
name|priv
operator|->
name|port
index|[
name|p
index|]
argument_list|)
expr_stmt|;
name|mlx4_CLOSE_PORT
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|mlx4_cleanup_counters_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_mcg_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_qp_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_srq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_cq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cmd_use_polling
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_mr_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_xrcd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_pd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|iounmap
argument_list|(
name|priv
operator|->
name|kar
argument_list|)
expr_stmt|;
name|mlx4_uar_free
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|driver_uar
argument_list|)
expr_stmt|;
name|mlx4_cleanup_uar_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_free_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_close_hca
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cmd_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_MSI_X
condition|)
name|pci_disable_msix
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|pci_release_region
argument_list|(
name|pdev
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pci_release_region
argument_list|(
name|pdev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pci_disable_device
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|pci_set_drvdata
argument_list|(
name|pdev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|mlx4_restart_one
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|mlx4_remove_one
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
return|return
name|__mlx4_init_one
argument_list|(
name|pdev
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|pci_device_id
name|mlx4_pci_table
index|[]
init|=
block|{
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x6340
argument_list|)
block|}
block|,
comment|/* MT25408 "Hermon" SDR */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x634a
argument_list|)
block|}
block|,
comment|/* MT25408 "Hermon" DDR */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x6354
argument_list|)
block|}
block|,
comment|/* MT25408 "Hermon" QDR */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x6732
argument_list|)
block|}
block|,
comment|/* MT25408 "Hermon" DDR PCIe gen2 */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x673c
argument_list|)
block|}
block|,
comment|/* MT25408 "Hermon" QDR PCIe gen2 */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x6368
argument_list|)
block|}
block|,
comment|/* MT25408 "Hermon" EN 10GigE */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x6750
argument_list|)
block|}
block|,
comment|/* MT25408 "Hermon" EN 10GigE PCIe gen2 */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x6372
argument_list|)
block|}
block|,
comment|/* MT25458 ConnectX EN 10GBASE-T 10GigE */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x675a
argument_list|)
block|}
block|,
comment|/* MT25458 ConnectX EN 10GBASE-T+Gen2 10GigE */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x6764
argument_list|)
block|}
block|,
comment|/* MT26468 ConnectX EN 10GigE PCIe gen2 */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x6746
argument_list|)
block|}
block|,
comment|/* MT26438 ConnectX VPI PCIe 2.0 5GT/s - IB QDR / 10GigE Virt+ */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x676e
argument_list|)
block|}
block|,
comment|/* MT26478 ConnectX EN 40GigE PCIe 2.0 5GT/s */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x6778
argument_list|)
block|}
block|,
comment|/* MT26488 ConnectX VPI PCIe 2.0 5GT/s - IB DDR / 10GigE Virt+ */
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x1000
argument_list|)
block|}
block|,
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x1001
argument_list|)
block|}
block|,
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x1002
argument_list|)
block|}
block|,
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x1003
argument_list|)
block|}
block|,
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x1004
argument_list|)
block|}
block|,
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x1005
argument_list|)
block|}
block|,
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x1006
argument_list|)
block|}
block|,
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x1007
argument_list|)
block|}
block|,
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x1008
argument_list|)
block|}
block|,
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x1009
argument_list|)
block|}
block|,
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x100a
argument_list|)
block|}
block|,
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x100b
argument_list|)
block|}
block|,
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x100c
argument_list|)
block|}
block|,
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x100d
argument_list|)
block|}
block|,
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x100e
argument_list|)
block|}
block|,
block|{
name|PCI_VDEVICE
argument_list|(
argument|MELLANOX
argument_list|,
literal|0x100f
argument_list|)
block|}
block|,
block|{
literal|0
block|, }
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_DEVICE_TABLE
argument_list|(
name|pci
argument_list|,
name|mlx4_pci_table
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|pci_driver
name|mlx4_driver
init|=
block|{
operator|.
name|name
operator|=
name|DRV_NAME
block|,
operator|.
name|id_table
operator|=
name|mlx4_pci_table
block|,
operator|.
name|probe
operator|=
name|mlx4_init_one
block|,
operator|.
name|remove
operator|=
name|__devexit_p
argument_list|(
argument|mlx4_remove_one
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|__init
name|mlx4_verify_params
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|(
name|log_num_mac
operator|<
literal|0
operator|)
operator|||
operator|(
name|log_num_mac
operator|>
literal|7
operator|)
condition|)
block|{
name|printk
argument_list|(
name|KERN_WARNING
literal|"mlx4_core: bad num_mac: %d\n"
argument_list|,
name|log_num_mac
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|log_mtts_per_seg
operator|==
literal|0
condition|)
name|log_mtts_per_seg
operator|=
name|ilog2
argument_list|(
name|MLX4_MTT_ENTRY_PER_SEG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|log_mtts_per_seg
operator|<
literal|1
operator|)
operator|||
operator|(
name|log_mtts_per_seg
operator|>
literal|7
operator|)
condition|)
block|{
name|printk
argument_list|(
name|KERN_WARNING
literal|"mlx4_core: bad log_mtts_per_seg: %d\n"
argument_list|,
name|log_mtts_per_seg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__init
name|mlx4_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|mutex_init
argument_list|(
operator|&
name|drv_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_verify_params
argument_list|()
condition|)
return|return
operator|-
name|EINVAL
return|;
name|mlx4_catas_init
argument_list|()
expr_stmt|;
name|mlx4_wq
operator|=
name|create_singlethread_workqueue
argument_list|(
literal|"mlx4"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_wq
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|ret
operator|=
name|pci_register_driver
argument_list|(
operator|&
name|mlx4_driver
argument_list|)
expr_stmt|;
return|return
name|ret
operator|<
literal|0
condition|?
name|ret
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__exit
name|mlx4_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|mutex_lock
argument_list|(
operator|&
name|drv_mutex
argument_list|)
expr_stmt|;
name|mlx4_config_cleanup
argument_list|()
expr_stmt|;
name|pci_unregister_driver
argument_list|(
operator|&
name|mlx4_driver
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|drv_mutex
argument_list|)
expr_stmt|;
name|destroy_workqueue
argument_list|(
name|mlx4_wq
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|module_init_order
argument_list|(
name|mlx4_init
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_exit
argument_list|(
name|mlx4_cleanup
argument_list|)
expr_stmt|;
end_expr_stmt

begin_undef
undef|#
directive|undef
name|MODULE_VERSION
end_undef

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_function
specifier|static
name|int
name|mlx4_evhand
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|mlx4_mod
init|=
block|{
operator|.
name|name
operator|=
literal|"mlx4"
block|,
operator|.
name|evhand
operator|=
name|mlx4_evhand
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|mlx4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|mlx4
argument_list|,
name|mlx4_mod
argument_list|,
name|SI_SUB_SMP
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

