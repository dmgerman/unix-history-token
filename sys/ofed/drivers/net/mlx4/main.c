begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.  * Copyright (c) 2005 Sun Microsystems, Inc. All rights reserved.  * Copyright (c) 2005, 2006, 2007, 2008 Mellanox Technologies. All rights reserved.  * Copyright (c) 2006, 2007 Cisco Systems, Inc. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/errno.h>
end_include

begin_include
include|#
directive|include
file|<linux/pci.h>
end_include

begin_include
include|#
directive|include
file|<linux/dma-mapping.h>
end_include

begin_include
include|#
directive|include
file|<linux/slab.h>
end_include

begin_include
include|#
directive|include
file|<linux/io-mapping.h>
end_include

begin_include
include|#
directive|include
file|<linux/delay.h>
end_include

begin_include
include|#
directive|include
file|<linux/netdevice.h>
end_include

begin_include
include|#
directive|include
file|<linux/fs.h>
end_include

begin_include
include|#
directive|include
file|<linux/mlx4/device.h>
end_include

begin_include
include|#
directive|include
file|<linux/mlx4/doorbell.h>
end_include

begin_include
include|#
directive|include
file|"mlx4.h"
end_include

begin_include
include|#
directive|include
file|"fw.h"
end_include

begin_include
include|#
directive|include
file|"icm.h"
end_include

begin_expr_stmt
name|MODULE_AUTHOR
argument_list|(
literal|"Roland Dreier"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DESCRIPTION
argument_list|(
literal|"Mellanox ConnectX HCA low-level driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_LICENSE
argument_list|(
literal|"Dual BSD/GPL"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|DRV_VERSION
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|workqueue_struct
modifier|*
name|mlx4_wq
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_MLX4_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|mlx4_debug_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|debug_level
argument_list|,
name|mlx4_debug_level
argument_list|,
name|int
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|debug_level
argument_list|,
literal|"Enable debug tracing if> 0"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_MLX4_DEBUG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_PCI_MSI
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|msi_x
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param
argument_list|(
name|msi_x
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|msi_x
argument_list|,
literal|"attempt to use MSI-X if nonzero"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* CONFIG_PCI_MSI */
end_comment

begin_define
define|#
directive|define
name|msi_x
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_PCI_MSI */
end_comment

begin_decl_stmt
specifier|static
name|int
name|enable_sys_tune
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param
argument_list|(
name|enable_sys_tune
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|enable_sys_tune
argument_list|,
literal|"Tune the cpu's for better performance (default 0)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|mlx4_blck_lb
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|block_loopback
argument_list|,
name|mlx4_blck_lb
argument_list|,
name|int
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|block_loopback
argument_list|,
literal|"Block multicast loopback packets if> 0 "
literal|"(default: 1)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|num_vfs
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param
argument_list|(
name|num_vfs
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|num_vfs
argument_list|,
literal|"enable #num_vfs functions if num_vfs> 0"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|probe_vf
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param
argument_list|(
name|probe_vf
argument_list|,
name|int
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|probe_vf
argument_list|,
literal|"number of vfs to probe by pf driver (num_vfs> 0)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|mlx4_log_num_mgm_entry_size
init|=
name|MLX4_DEFAULT_MGM_LOG_ENTRY_SIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_mgm_entry_size
argument_list|,
name|mlx4_log_num_mgm_entry_size
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_mgm_entry_size
argument_list|,
literal|"log mgm size, that defines the num"
literal|" of qp per mcg, for example:"
literal|" 10 gives 248.range: 7<="
literal|" log_num_mgm_entry_size<= 12."
literal|" To activate device managed"
literal|" flow steering when available, set to -1"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|high_rate_steer
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param
argument_list|(
name|high_rate_steer
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|high_rate_steer
argument_list|,
literal|"Enable steering mode for higher packet rate"
literal|" (default off)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|fast_drop
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|fast_drop
argument_list|,
name|fast_drop
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|fast_drop
argument_list|,
literal|"Enable fast packet drop when no recieve WQEs are posted"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|mlx4_enable_64b_cqe_eqe
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|enable_64b_cqe_eqe
argument_list|,
name|mlx4_enable_64b_cqe_eqe
argument_list|,
name|int
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|enable_64b_cqe_eqe
argument_list|,
literal|"Enable 64 byte CQEs/EQEs when the the FW supports this, if nonzero"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|HCA_GLOBAL_CAP_MASK
value|0
end_define

begin_define
define|#
directive|define
name|PF_CONTEXT_BEHAVIOUR_MASK
value|MLX4_FUNC_CAP_64B_EQE_CQE
end_define

begin_decl_stmt
specifier|static
name|char
name|mlx4_version
index|[]
name|__devinitdata
init|=
name|DRV_NAME
literal|": Mellanox ConnectX core driver v"
name|DRV_VERSION
literal|" ("
name|DRV_RELDATE
literal|")\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|log_num_mac
init|=
literal|7
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_mac
argument_list|,
name|log_num_mac
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_mac
argument_list|,
literal|"Log2 max number of MACs per ETH port (1-7)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|log_num_vlan
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_vlan
argument_list|,
name|log_num_vlan
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_vlan
argument_list|,
literal|"(Obsolete) Log2 max number of VLANs per ETH port (0-7)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Log2 max number of VLANs per ETH port (0-7) */
end_comment

begin_define
define|#
directive|define
name|MLX4_LOG_NUM_VLANS
value|7
end_define

begin_decl_stmt
name|int
name|log_mtts_per_seg
init|=
name|ilog2
argument_list|(
literal|1
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_mtts_per_seg
argument_list|,
name|log_mtts_per_seg
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_mtts_per_seg
argument_list|,
literal|"Log2 number of MTT entries per segment "
literal|"(0-7) (default: 0)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|port_type_array
index|[
literal|2
index|]
init|=
block|{
name|MLX4_PORT_TYPE_NONE
block|,
name|MLX4_PORT_TYPE_NONE
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static int arr_argc = 2; module_param_array(port_type_array, int,&arr_argc, 0444); MODULE_PARM_DESC(port_type_array, "Array of port types: HW_DEFAULT (0) is default " 				"1 for IB, 2 for Ethernet");
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|mlx4_port_config
block|{
name|struct
name|list_head
name|list
decl_stmt|;
name|enum
name|mlx4_port_type
name|port_type
index|[
name|MLX4_MAX_PORTS
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|pci_dev
modifier|*
name|pdev
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MLX4_LOG_NUM_MTT
value|20
end_define

begin_comment
comment|/* We limit to 30 as of a bit map issue which uses int and not uint.      see mlx4_buddy_init -> bitmap_zero which gets int. */
end_comment

begin_define
define|#
directive|define
name|MLX4_MAX_LOG_NUM_MTT
value|30
end_define

begin_decl_stmt
specifier|static
name|struct
name|mlx4_profile
name|mod_param_profile
init|=
block|{
operator|.
name|num_qp
operator|=
literal|19
block|,
operator|.
name|num_srq
operator|=
literal|16
block|,
operator|.
name|rdmarc_per_qp
operator|=
literal|4
block|,
operator|.
name|num_cq
operator|=
literal|16
block|,
operator|.
name|num_mcg
operator|=
literal|13
block|,
operator|.
name|num_mpt
operator|=
literal|19
block|,
operator|.
name|num_mtt
operator|=
literal|0
block|,
comment|/* max(20, 2*MTTs for host memory)) */
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_qp
argument_list|,
name|mod_param_profile
operator|.
name|num_qp
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_qp
argument_list|,
literal|"log maximum number of QPs per HCA (default: 19)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_srq
argument_list|,
name|mod_param_profile
operator|.
name|num_srq
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_srq
argument_list|,
literal|"log maximum number of SRQs per HCA "
literal|"(default: 16)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_rdmarc_per_qp
argument_list|,
name|mod_param_profile
operator|.
name|rdmarc_per_qp
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_rdmarc_per_qp
argument_list|,
literal|"log number of RDMARC buffers per QP "
literal|"(default: 4)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_cq
argument_list|,
name|mod_param_profile
operator|.
name|num_cq
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_cq
argument_list|,
literal|"log maximum number of CQs per HCA (default: 16)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_mcg
argument_list|,
name|mod_param_profile
operator|.
name|num_mcg
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_mcg
argument_list|,
literal|"log maximum number of multicast groups per HCA "
literal|"(default: 13)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_mpt
argument_list|,
name|mod_param_profile
operator|.
name|num_mpt
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_mpt
argument_list|,
literal|"log maximum number of memory protection table entries per "
literal|"HCA (default: 19)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_mtt
argument_list|,
name|mod_param_profile
operator|.
name|num_mtt
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_mtt
argument_list|,
literal|"log maximum number of memory translation table segments per "
literal|"HCA (default: max(20, 2*MTTs for register all of the host memory limited to 30))"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
block|{
name|MLX4_IF_STATE_BASIC
block|,
name|MLX4_IF_STATE_EXTENDED
block|}
enum|;
end_enum

begin_function
specifier|static
name|void
name|process_mod_param_profile
parameter_list|(
name|struct
name|mlx4_profile
modifier|*
name|profile
parameter_list|)
block|{
name|vm_size_t
name|hwphyssz
decl_stmt|;
name|hwphyssz
operator|=
literal|0
expr_stmt|;
name|TUNABLE_ULONG_FETCH
argument_list|(
literal|"hw.realmem"
argument_list|,
operator|(
name|u_long
operator|*
operator|)
operator|&
name|hwphyssz
argument_list|)
expr_stmt|;
name|profile
operator|->
name|num_qp
operator|=
literal|1
operator|<<
name|mod_param_profile
operator|.
name|num_qp
expr_stmt|;
name|profile
operator|->
name|num_srq
operator|=
literal|1
operator|<<
name|mod_param_profile
operator|.
name|num_srq
expr_stmt|;
name|profile
operator|->
name|rdmarc_per_qp
operator|=
literal|1
operator|<<
name|mod_param_profile
operator|.
name|rdmarc_per_qp
expr_stmt|;
name|profile
operator|->
name|num_cq
operator|=
literal|1
operator|<<
name|mod_param_profile
operator|.
name|num_cq
expr_stmt|;
name|profile
operator|->
name|num_mcg
operator|=
literal|1
operator|<<
name|mod_param_profile
operator|.
name|num_mcg
expr_stmt|;
name|profile
operator|->
name|num_mpt
operator|=
literal|1
operator|<<
name|mod_param_profile
operator|.
name|num_mpt
expr_stmt|;
comment|/* 	 * We want to scale the number of MTTs with the size of the 	 * system memory, since it makes sense to register a lot of 	 * memory on a system with a lot of memory.  As a heuristic, 	 * make sure we have enough MTTs to register twice the system 	 * memory (with PAGE_SIZE entries). 	 * 	 * This number has to be a power of two and fit into 32 bits 	 * due to device limitations. We cap this at 2^30 as of bit map 	 * limitation to work with int instead of uint (mlx4_buddy_init -> bitmap_zero) 	 * That limits us to 4TB of memory registration per HCA with 	 * 4KB pages, which is probably OK for the next few months. 	 */
if|if
condition|(
name|mod_param_profile
operator|.
name|num_mtt
condition|)
name|profile
operator|->
name|num_mtt
operator|=
literal|1
operator|<<
name|mod_param_profile
operator|.
name|num_mtt
expr_stmt|;
else|else
block|{
name|profile
operator|->
name|num_mtt
operator|=
name|roundup_pow_of_two
argument_list|(
name|max_t
argument_list|(
name|unsigned
argument_list|,
literal|1
operator|<<
operator|(
name|MLX4_LOG_NUM_MTT
operator|-
name|log_mtts_per_seg
operator|)
argument_list|,
name|min
argument_list|(
literal|1UL
operator|<<
operator|(
name|MLX4_MAX_LOG_NUM_MTT
operator|-
name|log_mtts_per_seg
operator|)
argument_list|,
operator|(
name|hwphyssz
operator|<<
literal|1
operator|)
operator|>>
name|log_mtts_per_seg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set the actual value, so it will be reflected to the user 		   using the sysfs */
name|mod_param_profile
operator|.
name|num_mtt
operator|=
name|ilog2
argument_list|(
name|profile
operator|->
name|num_mtt
operator|*
operator|(
literal|1
operator|<<
name|log_mtts_per_seg
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|mlx4_check_port_params
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|enum
name|mlx4_port_type
modifier|*
name|port_type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|port_type
index|[
name|i
index|]
operator|!=
name|port_type
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_DPDP
operator|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Only same port types supported "
literal|"on this HCA, aborting.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|port_type
index|[
name|i
index|]
operator|&
name|dev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|i
operator|+
literal|1
index|]
operator|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Requested port type for port %d is not "
literal|"supported on this HCA\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_set_port_mask
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
operator|++
name|i
control|)
name|dev
operator|->
name|caps
operator|.
name|port_mask
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_dev_cap
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|err
operator|=
name|mlx4_QUERY_DEV_CAP
argument_list|(
name|dev
argument_list|,
name|dev_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_DEV_CAP command failed, aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|dev_cap
operator|->
name|min_page_sz
operator|>
name|PAGE_SIZE
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"HCA minimum page size of %d bigger than "
literal|"kernel PAGE_SIZE of %d, aborting.\n"
argument_list|,
name|dev_cap
operator|->
name|min_page_sz
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
if|if
condition|(
name|dev_cap
operator|->
name|num_ports
operator|>
name|MLX4_MAX_PORTS
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"HCA has %d ports, but we only support %d, "
literal|"aborting.\n"
argument_list|,
name|dev_cap
operator|->
name|num_ports
argument_list|,
name|MLX4_MAX_PORTS
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
if|if
condition|(
name|dev_cap
operator|->
name|uar_size
operator|>
name|pci_resource_len
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"HCA reported UAR size of 0x%x bigger than "
literal|"PCI resource 2 size of 0x%llx, aborting.\n"
argument_list|,
name|dev_cap
operator|->
name|uar_size
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|pci_resource_len
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
name|dev
operator|->
name|caps
operator|.
name|num_ports
operator|=
name|dev_cap
operator|->
name|num_ports
expr_stmt|;
name|dev
operator|->
name|phys_caps
operator|.
name|num_phys_eqs
operator|=
name|MLX4_MAX_EQ_NUM
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
operator|++
name|i
control|)
block|{
name|dev
operator|->
name|caps
operator|.
name|vl_cap
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|max_vl
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|ib_mtu_cap
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|ib_mtu
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|phys_caps
operator|.
name|gid_phys_table_len
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|max_gids
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|phys_caps
operator|.
name|pkey_phys_table_len
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|max_pkeys
index|[
name|i
index|]
expr_stmt|;
comment|/* set gid and pkey table operating lengths by default 		 * to non-sriov values */
name|dev
operator|->
name|caps
operator|.
name|gid_table_len
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|max_gids
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|pkey_table_len
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|max_pkeys
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|port_width_cap
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|max_port_width
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|eth_mtu_cap
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|eth_mtu
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|def_mac
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|def_mac
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|supported_port_types
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|suggested_type
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|suggested_type
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|default_sense
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|default_sense
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|trans_type
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|trans_type
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|vendor_oui
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|vendor_oui
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|wavelength
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|wavelength
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|trans_code
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|trans_code
index|[
name|i
index|]
expr_stmt|;
block|}
name|dev
operator|->
name|caps
operator|.
name|uar_page_size
operator|=
name|PAGE_SIZE
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_uars
operator|=
name|dev_cap
operator|->
name|uar_size
operator|/
name|PAGE_SIZE
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|local_ca_ack_delay
operator|=
name|dev_cap
operator|->
name|local_ca_ack_delay
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|bf_reg_size
operator|=
name|dev_cap
operator|->
name|bf_reg_size
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|bf_regs_per_page
operator|=
name|dev_cap
operator|->
name|bf_regs_per_page
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_sq_sg
operator|=
name|dev_cap
operator|->
name|max_sq_sg
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_rq_sg
operator|=
name|dev_cap
operator|->
name|max_rq_sg
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_wqes
operator|=
name|dev_cap
operator|->
name|max_qp_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_qp_init_rdma
operator|=
name|dev_cap
operator|->
name|max_requester_per_qp
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_srq_wqes
operator|=
name|dev_cap
operator|->
name|max_srq_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_srq_sge
operator|=
name|dev_cap
operator|->
name|max_rq_sg
operator|-
literal|1
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_srqs
operator|=
name|dev_cap
operator|->
name|reserved_srqs
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_sq_desc_sz
operator|=
name|dev_cap
operator|->
name|max_sq_desc_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_rq_desc_sz
operator|=
name|dev_cap
operator|->
name|max_rq_desc_sz
expr_stmt|;
comment|/* 	 * Subtract 1 from the limit because we need to allocate a 	 * spare CQE to enable resizing the CQ 	 */
name|dev
operator|->
name|caps
operator|.
name|max_cqes
operator|=
name|dev_cap
operator|->
name|max_cq_sz
operator|-
literal|1
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_cqs
operator|=
name|dev_cap
operator|->
name|reserved_cqs
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_eqs
operator|=
name|dev_cap
operator|->
name|reserved_eqs
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_mtts
operator|=
name|dev_cap
operator|->
name|reserved_mtts
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_mrws
operator|=
name|dev_cap
operator|->
name|reserved_mrws
expr_stmt|;
comment|/* The first 128 UARs are used for EQ doorbells */
name|dev
operator|->
name|caps
operator|.
name|reserved_uars
operator|=
name|max_t
argument_list|(
name|int
argument_list|,
literal|128
argument_list|,
name|dev_cap
operator|->
name|reserved_uars
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_pds
operator|=
name|dev_cap
operator|->
name|reserved_pds
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_xrcds
operator|=
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_XRC
operator|)
condition|?
name|dev_cap
operator|->
name|reserved_xrcds
else|:
literal|0
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_xrcds
operator|=
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_XRC
operator|)
condition|?
name|dev_cap
operator|->
name|max_xrcds
else|:
literal|0
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|mtt_entry_sz
operator|=
name|dev_cap
operator|->
name|mtt_entry_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_msg_sz
operator|=
name|dev_cap
operator|->
name|max_msg_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|page_size_cap
operator|=
operator|~
call|(
name|u32
call|)
argument_list|(
name|dev_cap
operator|->
name|min_page_sz
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|flags
operator|=
name|dev_cap
operator|->
name|flags
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|=
name|dev_cap
operator|->
name|flags2
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|bmme_flags
operator|=
name|dev_cap
operator|->
name|bmme_flags
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_lkey
operator|=
name|dev_cap
operator|->
name|reserved_lkey
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|stat_rate_support
operator|=
name|dev_cap
operator|->
name|stat_rate_support
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|cq_timestamp
operator|=
name|dev_cap
operator|->
name|timestamp_support
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_gso_sz
operator|=
name|dev_cap
operator|->
name|max_gso_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_rss_tbl_sz
operator|=
name|dev_cap
operator|->
name|max_rss_tbl_sz
expr_stmt|;
comment|/* Sense port always allowed on supported devices for ConnectX-1 and -2 */
if|if
condition|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|pci_dev_data
operator|&
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
condition|)
name|dev
operator|->
name|caps
operator|.
name|flags
operator||=
name|MLX4_DEV_CAP_FLAG_SENSE_SUPPORT
expr_stmt|;
comment|/* Don't do sense port on multifunction devices (for now at least) */
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG_SENSE_SUPPORT
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|log_num_macs
operator|=
name|log_num_mac
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|log_num_vlans
operator|=
name|MLX4_LOG_NUM_VLANS
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|fast_drop
operator|=
name|fast_drop
condition|?
operator|!
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_FAST_DROP
operator|)
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
operator|++
name|i
control|)
block|{
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|=
name|MLX4_PORT_TYPE_NONE
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|i
index|]
condition|)
block|{
comment|/* if only ETH is supported - assign ETH */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|i
index|]
operator|==
name|MLX4_PORT_TYPE_ETH
condition|)
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|=
name|MLX4_PORT_TYPE_ETH
expr_stmt|;
comment|/* if only IB is supported, assign IB */
elseif|else
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|i
index|]
operator|==
name|MLX4_PORT_TYPE_IB
condition|)
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|=
name|MLX4_PORT_TYPE_IB
expr_stmt|;
else|else
block|{
comment|/* if IB and ETH are supported, we set the port 				 * type according to user selection of port type; 				 * if user selected none, take the FW hint */
if|if
condition|(
name|port_type_array
index|[
name|i
operator|-
literal|1
index|]
operator|==
name|MLX4_PORT_TYPE_NONE
condition|)
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|suggested_type
index|[
name|i
index|]
condition|?
name|MLX4_PORT_TYPE_ETH
else|:
name|MLX4_PORT_TYPE_IB
expr_stmt|;
else|else
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|=
name|port_type_array
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
block|}
comment|/* 		 * Link sensing is allowed on the port if 3 conditions are true: 		 * 1. Both protocols are supported on the port. 		 * 2. Different types are supported on the port 		 * 3. FW declared that it supports link sensing 		 */
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|sense
operator|.
name|sense_allowed
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|dev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|i
index|]
operator|==
name|MLX4_PORT_TYPE_AUTO
operator|)
operator|&&
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_DPDP
operator|)
operator|&&
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_SENSE_SUPPORT
operator|)
operator|)
expr_stmt|;
comment|/* 		 * If "default_sense" bit is set, we move the port to "AUTO" mode 		 * and perform sense_port FW command to try and set the correct 		 * port type from beginning 		 */
if|if
condition|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|sense
operator|.
name|sense_allowed
index|[
name|i
index|]
operator|&&
name|dev
operator|->
name|caps
operator|.
name|default_sense
index|[
name|i
index|]
condition|)
block|{
name|enum
name|mlx4_port_type
name|sensed_port
init|=
name|MLX4_PORT_TYPE_NONE
decl_stmt|;
name|dev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
index|]
operator|=
name|MLX4_PORT_TYPE_AUTO
expr_stmt|;
name|mlx4_SENSE_PORT
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
operator|&
name|sensed_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|sensed_port
operator|!=
name|MLX4_PORT_TYPE_NONE
condition|)
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|=
name|sensed_port
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|log_num_macs
operator|>
name|dev_cap
operator|->
name|log_max_macs
index|[
name|i
index|]
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|log_num_macs
operator|=
name|dev_cap
operator|->
name|log_max_macs
index|[
name|i
index|]
expr_stmt|;
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Requested number of MACs is too much "
literal|"for port %d, reducing to %d.\n"
argument_list|,
name|i
argument_list|,
literal|1
operator|<<
name|dev
operator|->
name|caps
operator|.
name|log_num_macs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|log_num_vlans
operator|>
name|dev_cap
operator|->
name|log_max_vlans
index|[
name|i
index|]
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|log_num_vlans
operator|=
name|dev_cap
operator|->
name|log_max_vlans
index|[
name|i
index|]
expr_stmt|;
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Requested number of VLANs is too much "
literal|"for port %d, reducing to %d.\n"
argument_list|,
name|i
argument_list|,
literal|1
operator|<<
name|dev
operator|->
name|caps
operator|.
name|log_num_vlans
argument_list|)
expr_stmt|;
block|}
block|}
name|dev
operator|->
name|caps
operator|.
name|max_basic_counters
operator|=
name|dev_cap
operator|->
name|max_basic_counters
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_extended_counters
operator|=
name|dev_cap
operator|->
name|max_extended_counters
expr_stmt|;
comment|/* support extended counters if available */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_COUNTERS_EXT
condition|)
name|dev
operator|->
name|caps
operator|.
name|max_counters
operator|=
name|dev
operator|->
name|caps
operator|.
name|max_extended_counters
expr_stmt|;
else|else
name|dev
operator|->
name|caps
operator|.
name|max_counters
operator|=
name|dev
operator|->
name|caps
operator|.
name|max_basic_counters
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
operator|=
name|dev_cap
operator|->
name|reserved_qps
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_ETH_ADDR
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FC_ADDR
index|]
operator|=
operator|(
literal|1
operator|<<
name|dev
operator|->
name|caps
operator|.
name|log_num_macs
operator|)
operator|*
operator|(
literal|1
operator|<<
name|dev
operator|->
name|caps
operator|.
name|log_num_vlans
operator|)
operator|*
name|dev
operator|->
name|caps
operator|.
name|num_ports
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FC_EXCH
index|]
operator|=
name|MLX4_NUM_FEXCH
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_qps
operator|=
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
operator|+
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_ETH_ADDR
index|]
operator|+
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FC_ADDR
index|]
operator|+
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FC_EXCH
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|sync_qp
operator|=
name|dev_cap
operator|->
name|sync_qp
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|sqp_demux
operator|=
operator|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
operator|)
condition|?
name|MLX4_MAX_NUM_SLAVES
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_enable_64b_cqe_eqe
condition|)
block|{
if|if
condition|(
name|dev_cap
operator|->
name|flags
operator|&
operator|(
name|MLX4_DEV_CAP_FLAG_64B_CQE
operator||
name|MLX4_DEV_CAP_FLAG_64B_EQE
operator|)
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"64B EQEs/CQEs supported by the device but not enabled\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG_64B_CQE
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG_64B_EQE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
operator|(
name|MLX4_DEV_CAP_FLAG_64B_CQE
operator||
name|MLX4_DEV_CAP_FLAG_64B_EQE
operator|)
operator|)
operator|&&
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
name|dev
operator|->
name|caps
operator|.
name|function_caps
operator||=
name|MLX4_FUNC_CAP_64B_EQE_CQE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*The function checks if there are live vf, return the num of them*/
end_comment

begin_function
specifier|static
name|int
name|mlx4_how_many_lives_vf
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_slave_state
modifier|*
name|s_state
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
comment|/*the ppf is 0*/
init|;
name|i
operator|<
name|dev
operator|->
name|num_slaves
condition|;
operator|++
name|i
control|)
block|{
name|s_state
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s_state
operator|->
name|active
operator|&&
name|s_state
operator|->
name|last_cmd
operator|!=
name|MLX4_COMM_CMD_RESET
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"%s: slave: %d is still active\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ret
operator|++
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|mlx4_get_parav_qkey
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|qpn
parameter_list|,
name|u32
modifier|*
name|qkey
parameter_list|)
block|{
name|u32
name|qk
init|=
name|MLX4_RESERVED_QKEY_BASE
decl_stmt|;
if|if
condition|(
name|qpn
operator|>=
name|dev
operator|->
name|phys_caps
operator|.
name|base_tunnel_sqpn
operator|+
literal|8
operator|*
name|MLX4_MFUNC_MAX
operator|||
name|qpn
operator|<
name|dev
operator|->
name|phys_caps
operator|.
name|base_proxy_sqpn
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|qpn
operator|>=
name|dev
operator|->
name|phys_caps
operator|.
name|base_tunnel_sqpn
condition|)
comment|/* tunnel qp */
name|qk
operator|+=
name|qpn
operator|-
name|dev
operator|->
name|phys_caps
operator|.
name|base_tunnel_sqpn
expr_stmt|;
else|else
name|qk
operator|+=
name|qpn
operator|-
name|dev
operator|->
name|phys_caps
operator|.
name|base_proxy_sqpn
expr_stmt|;
operator|*
name|qkey
operator|=
name|qk
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|mlx4_get_parav_qkey
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|mlx4_sync_pkey_table
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|container_of
argument_list|(
name|dev
argument_list|,
expr|struct
name|mlx4_priv
argument_list|,
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
name|priv
operator|->
name|virt2phys_pkey
index|[
name|slave
index|]
index|[
name|port
operator|-
literal|1
index|]
index|[
name|i
index|]
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|mlx4_sync_pkey_table
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|mlx4_put_slave_node_guid
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|__be64
name|guid
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|container_of
argument_list|(
name|dev
argument_list|,
expr|struct
name|mlx4_priv
argument_list|,
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
name|priv
operator|->
name|slave_node_guids
index|[
name|slave
index|]
operator|=
name|guid
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|mlx4_put_slave_node_guid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|__be64
name|mlx4_get_slave_node_guid
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|container_of
argument_list|(
name|dev
argument_list|,
expr|struct
name|mlx4_priv
argument_list|,
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|priv
operator|->
name|slave_node_guids
index|[
name|slave
index|]
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|mlx4_get_slave_node_guid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_is_slave_active
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_slave_state
modifier|*
name|s_slave
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
return|return
literal|0
return|;
name|s_slave
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
expr_stmt|;
return|return
operator|!
operator|!
name|s_slave
operator|->
name|active
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|mlx4_is_slave_active
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|slave_adjust_steering_mode
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
parameter_list|,
name|struct
name|mlx4_init_hca_param
modifier|*
name|hca_param
parameter_list|)
block|{
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|=
name|hca_param
operator|->
name|steering_mode
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|==
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
name|dev
operator|->
name|caps
operator|.
name|num_qp_per_mgm
operator|=
name|dev_cap
operator|->
name|fs_max_num_qp_per_entry
expr_stmt|;
else|else
name|dev
operator|->
name|caps
operator|.
name|num_qp_per_mgm
operator|=
literal|4
operator|*
operator|(
operator|(
literal|1
operator|<<
name|hca_param
operator|->
name|log_mc_entry_sz
operator|)
operator|/
literal|16
operator|-
literal|2
operator|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Steering mode is: %s\n"
argument_list|,
name|mlx4_steering_mode_str
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_slave_cap
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|u32
name|page_size
decl_stmt|;
name|struct
name|mlx4_dev_cap
name|dev_cap
decl_stmt|;
name|struct
name|mlx4_func_cap
name|func_cap
decl_stmt|;
name|struct
name|mlx4_init_hca_param
name|hca_param
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hca_param
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hca_param
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_QUERY_HCA
argument_list|(
name|dev
argument_list|,
operator|&
name|hca_param
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_HCA command failed, aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/*fail if the hca has an unknown capability */
if|if
condition|(
operator|(
name|hca_param
operator|.
name|global_caps
operator||
name|HCA_GLOBAL_CAP_MASK
operator|)
operator|!=
name|HCA_GLOBAL_CAP_MASK
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Unknown hca global capabilities\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOSYS
return|;
block|}
name|mlx4_log_num_mgm_entry_size
operator|=
name|hca_param
operator|.
name|log_mc_entry_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|hca_core_clock
operator|=
name|hca_param
operator|.
name|hca_core_clock
expr_stmt|;
name|memset
argument_list|(
operator|&
name|dev_cap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_cap
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_qp_dest_rdma
operator|=
literal|1
operator|<<
name|hca_param
operator|.
name|log_rd_per_qp
expr_stmt|;
name|err
operator|=
name|mlx4_dev_cap
argument_list|(
name|dev
argument_list|,
operator|&
name|dev_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_DEV_CAP command failed, aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|mlx4_QUERY_FW
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_FW command failed: could not get FW version.\n"
argument_list|)
expr_stmt|;
name|page_size
operator|=
operator|~
name|dev
operator|->
name|caps
operator|.
name|page_size_cap
operator|+
literal|1
expr_stmt|;
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"HCA minimum page size:%d\n"
argument_list|,
name|page_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|page_size
operator|>
name|PAGE_SIZE
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"HCA minimum page size of %d bigger than "
literal|"kernel PAGE_SIZE of %d, aborting.\n"
argument_list|,
name|page_size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
comment|/* slave gets uar page size from QUERY_HCA fw command */
name|dev
operator|->
name|caps
operator|.
name|uar_page_size
operator|=
literal|1
operator|<<
operator|(
name|hca_param
operator|.
name|uar_page_sz
operator|+
literal|12
operator|)
expr_stmt|;
comment|/* TODO: relax this assumption */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|uar_page_size
operator|!=
name|PAGE_SIZE
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"UAR size:%d != kernel PAGE_SIZE of %d\n"
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|uar_page_size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
name|memset
argument_list|(
operator|&
name|func_cap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|func_cap
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_QUERY_FUNC_CAP
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
operator|&
name|func_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_FUNC_CAP general command failed, aborting (%d).\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
operator|(
name|func_cap
operator|.
name|pf_context_behaviour
operator||
name|PF_CONTEXT_BEHAVIOUR_MASK
operator|)
operator|!=
name|PF_CONTEXT_BEHAVIOUR_MASK
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Unknown pf context behaviour\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOSYS
return|;
block|}
name|dev
operator|->
name|caps
operator|.
name|num_ports
operator|=
name|func_cap
operator|.
name|num_ports
expr_stmt|;
name|dev
operator|->
name|quotas
operator|.
name|qp
operator|=
name|func_cap
operator|.
name|qp_quota
expr_stmt|;
name|dev
operator|->
name|quotas
operator|.
name|srq
operator|=
name|func_cap
operator|.
name|srq_quota
expr_stmt|;
name|dev
operator|->
name|quotas
operator|.
name|cq
operator|=
name|func_cap
operator|.
name|cq_quota
expr_stmt|;
name|dev
operator|->
name|quotas
operator|.
name|mpt
operator|=
name|func_cap
operator|.
name|mpt_quota
expr_stmt|;
name|dev
operator|->
name|quotas
operator|.
name|mtt
operator|=
name|func_cap
operator|.
name|mtt_quota
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_qps
operator|=
literal|1
operator|<<
name|hca_param
operator|.
name|log_num_qps
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_srqs
operator|=
literal|1
operator|<<
name|hca_param
operator|.
name|log_num_srqs
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_cqs
operator|=
literal|1
operator|<<
name|hca_param
operator|.
name|log_num_cqs
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_mpts
operator|=
literal|1
operator|<<
name|hca_param
operator|.
name|log_mpt_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_eqs
operator|=
name|func_cap
operator|.
name|max_eq
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_eqs
operator|=
name|func_cap
operator|.
name|reserved_eq
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_pds
operator|=
name|MLX4_NUM_PDS
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_mgms
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_amgms
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|num_ports
operator|>
name|MLX4_MAX_PORTS
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"HCA has %d ports, but we only support %d, "
literal|"aborting.\n"
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|,
name|MLX4_MAX_PORTS
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
operator|=
name|kcalloc
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
operator|=
name|kcalloc
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
operator|=
name|kcalloc
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
operator|=
name|kcalloc
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
operator|||
operator|!
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
operator|||
operator|!
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
operator|||
operator|!
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_mem
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
operator|++
name|i
control|)
block|{
name|err
operator|=
name|mlx4_QUERY_FUNC_CAP
argument_list|(
name|dev
argument_list|,
operator|(
name|u32
operator|)
name|i
argument_list|,
operator|&
name|func_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_FUNC_CAP port command failed for"
literal|" port %d, aborting (%d).\n"
argument_list|,
name|i
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_mem
goto|;
block|}
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|func_cap
operator|.
name|qp0_tunnel_qpn
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|func_cap
operator|.
name|qp0_proxy_qpn
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|func_cap
operator|.
name|qp1_tunnel_qpn
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|func_cap
operator|.
name|qp1_proxy_qpn
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|port_mask
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
expr_stmt|;
name|err
operator|=
name|mlx4_get_slave_pkey_gid_tbl_len
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
operator|&
name|dev
operator|->
name|caps
operator|.
name|gid_table_len
index|[
name|i
index|]
argument_list|,
operator|&
name|dev
operator|->
name|caps
operator|.
name|pkey_table_len
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_mem
goto|;
block|}
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|uar_page_size
operator|*
operator|(
name|dev
operator|->
name|caps
operator|.
name|num_uars
operator|-
name|dev
operator|->
name|caps
operator|.
name|reserved_uars
operator|)
operator|>
name|pci_resource_len
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"HCA reported UAR region size of 0x%x bigger than "
literal|"PCI resource 2 size of 0x%llx, aborting.\n"
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|uar_page_size
operator|*
name|dev
operator|->
name|caps
operator|.
name|num_uars
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|pci_resource_len
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_mem
goto|;
block|}
if|if
condition|(
name|hca_param
operator|.
name|dev_cap_enabled
operator|&
name|MLX4_DEV_CAP_64B_EQE_ENABLED
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|eqe_size
operator|=
literal|64
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|eqe_factor
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|caps
operator|.
name|eqe_size
operator|=
literal|32
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|eqe_factor
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|hca_param
operator|.
name|dev_cap_enabled
operator|&
name|MLX4_DEV_CAP_64B_CQE_ENABLED
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|cqe_size
operator|=
literal|64
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|userspace_caps
operator||=
name|MLX4_USER_DEV_CAP_64B_CQE
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|caps
operator|.
name|cqe_size
operator|=
literal|32
expr_stmt|;
block|}
name|slave_adjust_steering_mode
argument_list|(
name|dev
argument_list|,
operator|&
name|dev_cap
argument_list|,
operator|&
name|hca_param
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_mem
label|:
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
operator|=
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
operator|=
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
operator|=
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
operator|=
name|NULL
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/*  * Change the port configuration of the device.  * Every user of this function must hold the port mutex.  */
end_comment

begin_function
name|int
name|mlx4_change_port_types
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|enum
name|mlx4_port_type
modifier|*
name|port_types
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|change
init|=
literal|0
decl_stmt|;
name|int
name|port
decl_stmt|;
for|for
control|(
name|port
operator|=
literal|0
init|;
name|port
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
comment|/* Change the port type only if the new type is different 		 * from the current, and not set to Auto */
if|if
condition|(
name|port_types
index|[
name|port
index|]
operator|!=
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|port
operator|+
literal|1
index|]
condition|)
name|change
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|change
condition|)
block|{
name|mlx4_unregister_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
name|mlx4_CLOSE_PORT
argument_list|(
name|dev
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|port
index|]
operator|=
name|port_types
index|[
name|port
operator|-
literal|1
index|]
expr_stmt|;
name|err
operator|=
name|mlx4_SET_PORT
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to set port %d, "
literal|"aborting\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|mlx4_set_port_mask
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_register_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|show_port_type
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|mlx4_port_info
modifier|*
name|info
init|=
name|container_of
argument_list|(
name|attr
argument_list|,
expr|struct
name|mlx4_port_info
argument_list|,
name|port_attr
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|mdev
init|=
name|info
operator|->
name|dev
decl_stmt|;
name|char
name|type
index|[
literal|8
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|type
argument_list|,
literal|"%s"
argument_list|,
operator|(
name|mdev
operator|->
name|caps
operator|.
name|port_type
index|[
name|info
operator|->
name|port
index|]
operator|==
name|MLX4_PORT_TYPE_IB
operator|)
condition|?
literal|"ib"
else|:
literal|"eth"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|info
operator|->
name|port
index|]
operator|==
name|MLX4_PORT_TYPE_AUTO
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"auto (%s)\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|set_port_type
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|struct
name|mlx4_port_info
modifier|*
name|info
init|=
name|container_of
argument_list|(
name|attr
argument_list|,
expr|struct
name|mlx4_port_info
argument_list|,
name|port_attr
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|mdev
init|=
name|info
operator|->
name|dev
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|mdev
argument_list|)
decl_stmt|;
name|enum
name|mlx4_port_type
name|types
index|[
name|MLX4_MAX_PORTS
index|]
decl_stmt|;
name|enum
name|mlx4_port_type
name|new_types
index|[
name|MLX4_MAX_PORTS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"ib\n"
argument_list|)
condition|)
name|info
operator|->
name|tmp_type
operator|=
name|MLX4_PORT_TYPE_IB
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"eth\n"
argument_list|)
condition|)
name|info
operator|->
name|tmp_type
operator|=
name|MLX4_PORT_TYPE_ETH
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"auto\n"
argument_list|)
condition|)
name|info
operator|->
name|tmp_type
operator|=
name|MLX4_PORT_TYPE_AUTO
expr_stmt|;
else|else
block|{
name|mlx4_err
argument_list|(
name|mdev
argument_list|,
literal|"%s is not supported port type\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|mlx4_stop_sense
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|port_mutex
argument_list|)
expr_stmt|;
comment|/* Possible type is always the one that was delivered */
name|mdev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|info
operator|->
name|port
index|]
operator|=
name|info
operator|->
name|tmp_type
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mdev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|types
index|[
name|i
index|]
operator|=
name|priv
operator|->
name|port
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|tmp_type
condition|?
name|priv
operator|->
name|port
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|tmp_type
else|:
name|mdev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|types
index|[
name|i
index|]
operator|==
name|MLX4_PORT_TYPE_AUTO
condition|)
name|types
index|[
name|i
index|]
operator|=
name|mdev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|mdev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_DPDP
operator|)
operator|&&
operator|!
operator|(
name|mdev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_SENSE_SUPPORT
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|mdev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mdev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
index|]
operator|==
name|MLX4_PORT_TYPE_AUTO
condition|)
block|{
name|mdev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
index|]
operator|=
name|mdev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|mdev
argument_list|,
literal|"Auto sensing is not supported on this HCA. "
literal|"Set only 'eth' or 'ib' for both ports "
literal|"(should be the same)\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mlx4_do_sense_ports
argument_list|(
name|mdev
argument_list|,
name|new_types
argument_list|,
name|types
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_check_port_params
argument_list|(
name|mdev
argument_list|,
name|new_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
comment|/* We are about to apply the changes after the configuration 	 * was verified, no need to remember the temporary types 	 * any more */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mdev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
name|priv
operator|->
name|port
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|tmp_type
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|mlx4_change_port_types
argument_list|(
name|mdev
argument_list|,
name|new_types
argument_list|)
expr_stmt|;
name|out
label|:
name|mlx4_start_sense
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|port_mutex
argument_list|)
expr_stmt|;
return|return
name|err
condition|?
name|err
else|:
name|count
return|;
block|}
end_function

begin_enum
enum|enum
name|ibta_mtu
block|{
name|IB_MTU_256
init|=
literal|1
block|,
name|IB_MTU_512
init|=
literal|2
block|,
name|IB_MTU_1024
init|=
literal|3
block|,
name|IB_MTU_2048
init|=
literal|4
block|,
name|IB_MTU_4096
init|=
literal|5
block|}
enum|;
end_enum

begin_function
specifier|static
specifier|inline
name|int
name|int_to_ibta_mtu
parameter_list|(
name|int
name|mtu
parameter_list|)
block|{
switch|switch
condition|(
name|mtu
condition|)
block|{
case|case
literal|256
case|:
return|return
name|IB_MTU_256
return|;
case|case
literal|512
case|:
return|return
name|IB_MTU_512
return|;
case|case
literal|1024
case|:
return|return
name|IB_MTU_1024
return|;
case|case
literal|2048
case|:
return|return
name|IB_MTU_2048
return|;
case|case
literal|4096
case|:
return|return
name|IB_MTU_4096
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ibta_mtu_to_int
parameter_list|(
name|enum
name|ibta_mtu
name|mtu
parameter_list|)
block|{
switch|switch
condition|(
name|mtu
condition|)
block|{
case|case
name|IB_MTU_256
case|:
return|return
literal|256
return|;
case|case
name|IB_MTU_512
case|:
return|return
literal|512
return|;
case|case
name|IB_MTU_1024
case|:
return|return
literal|1024
return|;
case|case
name|IB_MTU_2048
case|:
return|return
literal|2048
return|;
case|case
name|IB_MTU_4096
case|:
return|return
literal|4096
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|show_port_ib_mtu
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|mlx4_port_info
modifier|*
name|info
init|=
name|container_of
argument_list|(
name|attr
argument_list|,
expr|struct
name|mlx4_port_info
argument_list|,
name|port_mtu_attr
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|mdev
init|=
name|info
operator|->
name|dev
decl_stmt|;
if|if
condition|(
name|mdev
operator|->
name|caps
operator|.
name|port_type
index|[
name|info
operator|->
name|port
index|]
operator|==
name|MLX4_PORT_TYPE_ETH
condition|)
name|mlx4_warn
argument_list|(
name|mdev
argument_list|,
literal|"port level mtu is only used for IB ports\n"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d\n"
argument_list|,
name|ibta_mtu_to_int
argument_list|(
name|mdev
operator|->
name|caps
operator|.
name|port_ib_mtu
index|[
name|info
operator|->
name|port
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|set_port_ib_mtu
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|struct
name|mlx4_port_info
modifier|*
name|info
init|=
name|container_of
argument_list|(
name|attr
argument_list|,
expr|struct
name|mlx4_port_info
argument_list|,
name|port_mtu_attr
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|mdev
init|=
name|info
operator|->
name|dev
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|mdev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|,
name|port
decl_stmt|,
name|mtu
decl_stmt|,
name|ibta_mtu
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|mdev
operator|->
name|caps
operator|.
name|port_type
index|[
name|info
operator|->
name|port
index|]
operator|==
name|MLX4_PORT_TYPE_ETH
condition|)
block|{
name|mlx4_warn
argument_list|(
name|mdev
argument_list|,
literal|"port level mtu is only used for IB ports\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|mtu
operator|=
operator|(
name|int
operator|)
name|simple_strtol
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ibta_mtu
operator|=
name|int_to_ibta_mtu
argument_list|(
name|mtu
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibta_mtu
operator|<
literal|0
condition|)
block|{
name|mlx4_err
argument_list|(
name|mdev
argument_list|,
literal|"%s is invalid IBTA mtu\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|mdev
operator|->
name|caps
operator|.
name|port_ib_mtu
index|[
name|info
operator|->
name|port
index|]
operator|=
name|ibta_mtu
expr_stmt|;
name|mlx4_stop_sense
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|port_mutex
argument_list|)
expr_stmt|;
name|mlx4_unregister_device
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<=
name|mdev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
name|mlx4_CLOSE_PORT
argument_list|(
name|mdev
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_SET_PORT
argument_list|(
name|mdev
argument_list|,
name|port
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|mdev
argument_list|,
literal|"Failed to set port %d, "
literal|"aborting\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
goto|goto
name|err_set_port
goto|;
block|}
block|}
name|err
operator|=
name|mlx4_register_device
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|err_set_port
label|:
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|port_mutex
argument_list|)
expr_stmt|;
name|mlx4_start_sense
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
return|return
name|err
condition|?
name|err
else|:
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_load_fw
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|priv
operator|->
name|fw
operator|.
name|fw_icm
operator|=
name|mlx4_alloc_icm
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|fw_pages
argument_list|,
name|GFP_HIGHUSER
operator||
name|__GFP_NOWARN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|fw
operator|.
name|fw_icm
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Couldn't allocate FW area, aborting.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|err
operator|=
name|mlx4_MAP_FA
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|fw_icm
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"MAP_FA command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free
goto|;
block|}
name|err
operator|=
name|mlx4_RUN_FW
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"RUN_FW command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_fa
goto|;
block|}
return|return
literal|0
return|;
name|err_unmap_fa
label|:
name|mlx4_UNMAP_FA
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_free
label|:
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|fw_icm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_cmpt_table
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|cmpt_base
parameter_list|,
name|int
name|cmpt_entry_sz
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|num_eqs
decl_stmt|;
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|cmpt_table
argument_list|,
name|cmpt_base
operator|+
operator|(
call|(
name|u64
call|)
argument_list|(
name|MLX4_CMPT_TYPE_QP
operator|*
name|cmpt_entry_sz
argument_list|)
operator|<<
name|MLX4_CMPT_SHIFT
operator|)
argument_list|,
name|cmpt_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_qps
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err
goto|;
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|cmpt_table
argument_list|,
name|cmpt_base
operator|+
operator|(
call|(
name|u64
call|)
argument_list|(
name|MLX4_CMPT_TYPE_SRQ
operator|*
name|cmpt_entry_sz
argument_list|)
operator|<<
name|MLX4_CMPT_SHIFT
operator|)
argument_list|,
name|cmpt_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_srqs
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_srqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_qp
goto|;
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|cmpt_table
argument_list|,
name|cmpt_base
operator|+
operator|(
call|(
name|u64
call|)
argument_list|(
name|MLX4_CMPT_TYPE_CQ
operator|*
name|cmpt_entry_sz
argument_list|)
operator|<<
name|MLX4_CMPT_SHIFT
operator|)
argument_list|,
name|cmpt_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_cqs
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_cqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_srq
goto|;
name|num_eqs
operator|=
operator|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
operator|)
condition|?
name|dev
operator|->
name|phys_caps
operator|.
name|num_phys_eqs
else|:
name|dev
operator|->
name|caps
operator|.
name|num_eqs
expr_stmt|;
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|cmpt_table
argument_list|,
name|cmpt_base
operator|+
operator|(
call|(
name|u64
call|)
argument_list|(
name|MLX4_CMPT_TYPE_EQ
operator|*
name|cmpt_entry_sz
argument_list|)
operator|<<
name|MLX4_CMPT_SHIFT
operator|)
argument_list|,
name|cmpt_entry_sz
argument_list|,
name|num_eqs
argument_list|,
name|num_eqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_cq
goto|;
return|return
literal|0
return|;
name|err_cq
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|err_srq
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|err_qp
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|err
label|:
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_icm
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
parameter_list|,
name|struct
name|mlx4_init_hca_param
modifier|*
name|init_hca
parameter_list|,
name|u64
name|icm_size
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u64
name|aux_pages
decl_stmt|;
name|int
name|num_eqs
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|mlx4_SET_ICM_SIZE
argument_list|(
name|dev
argument_list|,
name|icm_size
argument_list|,
operator|&
name|aux_pages
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"SET_ICM_SIZE command failed, aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%lld KB of HCA context requires %lld KB aux memory.\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|icm_size
operator|>>
literal|10
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|aux_pages
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|priv
operator|->
name|fw
operator|.
name|aux_icm
operator|=
name|mlx4_alloc_icm
argument_list|(
name|dev
argument_list|,
name|aux_pages
argument_list|,
name|GFP_HIGHUSER
operator||
name|__GFP_NOWARN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|fw
operator|.
name|aux_icm
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Couldn't allocate aux memory, aborting.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|err
operator|=
name|mlx4_MAP_ICM_AUX
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|aux_icm
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"MAP_ICM_AUX command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free_aux
goto|;
block|}
name|err
operator|=
name|mlx4_init_cmpt_table
argument_list|(
name|dev
argument_list|,
name|init_hca
operator|->
name|cmpt_base
argument_list|,
name|dev_cap
operator|->
name|cmpt_entry_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map cMPT context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_aux
goto|;
block|}
name|num_eqs
operator|=
operator|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
operator|)
condition|?
name|dev
operator|->
name|phys_caps
operator|.
name|num_phys_eqs
else|:
name|dev
operator|->
name|caps
operator|.
name|num_eqs
expr_stmt|;
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|table
argument_list|,
name|init_hca
operator|->
name|eqc_base
argument_list|,
name|dev_cap
operator|->
name|eqc_entry_sz
argument_list|,
name|num_eqs
argument_list|,
name|num_eqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map EQ context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_cmpt
goto|;
block|}
comment|/* 	 * Reserved MTT entries must be aligned up to a cacheline 	 * boundary, since the FW will write to them, while the driver 	 * writes to all other MTT entries. (The variable 	 * dev->caps.mtt_entry_sz below is really the MTT segment 	 * size, not the raw entry size) 	 */
name|dev
operator|->
name|caps
operator|.
name|reserved_mtts
operator|=
name|ALIGN
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|reserved_mtts
operator|*
name|dev
operator|->
name|caps
operator|.
name|mtt_entry_sz
argument_list|,
name|dma_get_cache_alignment
argument_list|()
argument_list|)
operator|/
name|dev
operator|->
name|caps
operator|.
name|mtt_entry_sz
expr_stmt|;
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mr_table
operator|.
name|mtt_table
argument_list|,
name|init_hca
operator|->
name|mtt_base
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|mtt_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_mtts
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_mtts
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map MTT context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_eq
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mr_table
operator|.
name|dmpt_table
argument_list|,
name|init_hca
operator|->
name|dmpt_base
argument_list|,
name|dev_cap
operator|->
name|dmpt_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_mpts
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_mrws
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map dMPT context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_mtt
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|qp_table
argument_list|,
name|init_hca
operator|->
name|qpc_base
argument_list|,
name|dev_cap
operator|->
name|qpc_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_qps
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map QP context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_dmpt
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|auxc_table
argument_list|,
name|init_hca
operator|->
name|auxc_base
argument_list|,
name|dev_cap
operator|->
name|aux_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_qps
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map AUXC context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_qp
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|altc_table
argument_list|,
name|init_hca
operator|->
name|altc_base
argument_list|,
name|dev_cap
operator|->
name|altc_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_qps
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map ALTC context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_auxc
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|rdmarc_table
argument_list|,
name|init_hca
operator|->
name|rdmarc_base
argument_list|,
name|dev_cap
operator|->
name|rdmarc_entry_sz
operator|<<
name|priv
operator|->
name|qp_table
operator|.
name|rdmarc_shift
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_qps
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map RDMARC context memory, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_altc
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|table
argument_list|,
name|init_hca
operator|->
name|cqc_base
argument_list|,
name|dev_cap
operator|->
name|cqc_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_cqs
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_cqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map CQ context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_rdmarc
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|table
argument_list|,
name|init_hca
operator|->
name|srqc_base
argument_list|,
name|dev_cap
operator|->
name|srq_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_srqs
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_srqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map SRQ context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_cq
goto|;
block|}
comment|/* 	 * For flow steering device managed mode it is required to use 	 * mlx4_init_icm_table. For B0 steering mode it's not strictly 	 * required, but for simplicity just map the whole multicast 	 * group table now.  The table isn't very big and it's a lot 	 * easier than trying to track ref counts. 	 */
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mcg_table
operator|.
name|table
argument_list|,
name|init_hca
operator|->
name|mc_base
argument_list|,
name|mlx4_get_mgm_entry_size
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_mgms
operator|+
name|dev
operator|->
name|caps
operator|.
name|num_amgms
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_mgms
operator|+
name|dev
operator|->
name|caps
operator|.
name|num_amgms
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map MCG context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_srq
goto|;
block|}
return|return
literal|0
return|;
name|err_unmap_srq
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|err_unmap_cq
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|err_unmap_rdmarc
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|rdmarc_table
argument_list|)
expr_stmt|;
name|err_unmap_altc
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|altc_table
argument_list|)
expr_stmt|;
name|err_unmap_auxc
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|auxc_table
argument_list|)
expr_stmt|;
name|err_unmap_qp
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|qp_table
argument_list|)
expr_stmt|;
name|err_unmap_dmpt
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mr_table
operator|.
name|dmpt_table
argument_list|)
expr_stmt|;
name|err_unmap_mtt
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mr_table
operator|.
name|mtt_table
argument_list|)
expr_stmt|;
name|err_unmap_eq
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|err_unmap_cmpt
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|err_unmap_aux
label|:
name|mlx4_UNMAP_ICM_AUX
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_free_aux
label|:
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|aux_icm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_free_icms
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mcg_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|rdmarc_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|altc_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|auxc_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|qp_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mr_table
operator|.
name|dmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mr_table
operator|.
name|mtt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_UNMAP_ICM_AUX
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|aux_icm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_slave_exit
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|slave_cmd_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_comm_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_COMM_CMD_RESET
argument_list|,
literal|0
argument_list|,
name|MLX4_COMM_TIME
argument_list|)
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Failed to close slave function.\n"
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|slave_cmd_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|map_bf_area
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|resource_size_t
name|bf_start
decl_stmt|;
name|resource_size_t
name|bf_len
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|caps
operator|.
name|bf_reg_size
condition|)
return|return
operator|-
name|ENXIO
return|;
name|bf_start
operator|=
name|pci_resource_start
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
operator|+
operator|(
name|dev
operator|->
name|caps
operator|.
name|num_uars
operator|<<
name|PAGE_SHIFT
operator|)
expr_stmt|;
name|bf_len
operator|=
name|pci_resource_len
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
operator|-
operator|(
name|dev
operator|->
name|caps
operator|.
name|num_uars
operator|<<
name|PAGE_SHIFT
operator|)
expr_stmt|;
name|priv
operator|->
name|bf_mapping
operator|=
name|io_mapping_create_wc
argument_list|(
name|bf_start
argument_list|,
name|bf_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|bf_mapping
condition|)
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unmap_bf_area
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|bf_mapping
condition|)
name|io_mapping_free
argument_list|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|bf_mapping
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|cycle_t
name|mlx4_read_clock
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|u32
name|clockhi
decl_stmt|,
name|clocklo
decl_stmt|,
name|clockhi1
decl_stmt|;
name|cycle_t
name|cycles
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|clockhi
operator|=
name|swab32
argument_list|(
name|readl
argument_list|(
name|priv
operator|->
name|clock_mapping
argument_list|)
argument_list|)
expr_stmt|;
name|clocklo
operator|=
name|swab32
argument_list|(
name|readl
argument_list|(
name|priv
operator|->
name|clock_mapping
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|clockhi1
operator|=
name|swab32
argument_list|(
name|readl
argument_list|(
name|priv
operator|->
name|clock_mapping
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clockhi
operator|==
name|clockhi1
condition|)
break|break;
block|}
name|cycles
operator|=
operator|(
name|u64
operator|)
name|clockhi
operator|<<
literal|32
operator||
operator|(
name|u64
operator|)
name|clocklo
expr_stmt|;
return|return
name|cycles
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_read_clock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|map_internal_clock
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|priv
operator|->
name|clock_mapping
operator|=
name|ioremap
argument_list|(
name|pci_resource_start
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|clock_bar
argument_list|)
operator|+
name|priv
operator|->
name|fw
operator|.
name|clock_offset
argument_list|,
name|MLX4_CLOCK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|clock_mapping
condition|)
return|return
operator|-
name|ENOMEM
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unmap_internal_clock
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|clock_mapping
condition|)
name|iounmap
argument_list|(
name|priv
operator|->
name|clock_mapping
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_close_hca
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|unmap_internal_clock
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unmap_bf_area
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_slave_exit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
else|else
block|{
name|mlx4_CLOSE_HCA
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mlx4_free_icms
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_UNMAP_FA
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|fw
operator|.
name|fw_icm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_slave
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u64
name|dma
init|=
operator|(
name|u64
operator|)
name|priv
operator|->
name|mfunc
operator|.
name|vhcr_dma
decl_stmt|;
name|int
name|num_of_reset_retries
init|=
name|NUM_OF_RESET_RETRIES
decl_stmt|;
name|int
name|ret_from_reset
init|=
literal|0
decl_stmt|;
name|u32
name|slave_read
decl_stmt|;
name|u32
name|cmd_channel_ver
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|slave_cmd_mutex
argument_list|)
expr_stmt|;
name|priv
operator|->
name|cmd
operator|.
name|max_cmds
operator|=
literal|1
expr_stmt|;
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Sending reset\n"
argument_list|)
expr_stmt|;
name|ret_from_reset
operator|=
name|mlx4_comm_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_COMM_CMD_RESET
argument_list|,
literal|0
argument_list|,
name|MLX4_COMM_TIME
argument_list|)
expr_stmt|;
comment|/* if we are in the middle of flr the slave will try 	 * NUM_OF_RESET_RETRIES times before leaving.*/
if|if
condition|(
name|ret_from_reset
condition|)
block|{
if|if
condition|(
name|MLX4_DELAY_RESET_SLAVE
operator|==
name|ret_from_reset
condition|)
block|{
name|msleep
argument_list|(
name|SLEEP_TIME_IN_RESET
argument_list|)
expr_stmt|;
while|while
condition|(
name|ret_from_reset
operator|&&
name|num_of_reset_retries
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"slave is currently in the"
literal|"middle of FLR. retrying..."
literal|"(try num:%d)\n"
argument_list|,
operator|(
name|NUM_OF_RESET_RETRIES
operator|-
name|num_of_reset_retries
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|ret_from_reset
operator|=
name|mlx4_comm_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_COMM_CMD_RESET
argument_list|,
literal|0
argument_list|,
name|MLX4_COMM_TIME
argument_list|)
expr_stmt|;
name|num_of_reset_retries
operator|=
name|num_of_reset_retries
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
goto|goto
name|err
goto|;
block|}
comment|/* check the driver version - the slave I/F revision 	 * must match the master's */
name|slave_read
operator|=
name|swab32
argument_list|(
name|readl
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|comm
operator|->
name|slave_read
argument_list|)
argument_list|)
expr_stmt|;
name|cmd_channel_ver
operator|=
name|mlx4_comm_get_version
argument_list|()
expr_stmt|;
if|if
condition|(
name|MLX4_COMM_GET_IF_REV
argument_list|(
name|cmd_channel_ver
argument_list|)
operator|!=
name|MLX4_COMM_GET_IF_REV
argument_list|(
name|slave_read
argument_list|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"slave driver version is not supported"
literal|" by the master\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Sending vhcr0\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_comm_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_COMM_CMD_VHCR0
argument_list|,
name|dma
operator|>>
literal|48
argument_list|,
name|MLX4_COMM_TIME
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|mlx4_comm_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_COMM_CMD_VHCR1
argument_list|,
name|dma
operator|>>
literal|32
argument_list|,
name|MLX4_COMM_TIME
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|mlx4_comm_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_COMM_CMD_VHCR2
argument_list|,
name|dma
operator|>>
literal|16
argument_list|,
name|MLX4_COMM_TIME
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|mlx4_comm_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_COMM_CMD_VHCR_EN
argument_list|,
name|dma
argument_list|,
name|MLX4_COMM_TIME
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|slave_cmd_mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err
label|:
name|mlx4_comm_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_COMM_CMD_RESET
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|slave_cmd_mutex
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_parav_master_pf_caps
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|==
name|MLX4_PORT_TYPE_ETH
condition|)
name|dev
operator|->
name|caps
operator|.
name|gid_table_len
index|[
name|i
index|]
operator|=
name|mlx4_get_slave_num_gids
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|dev
operator|->
name|caps
operator|.
name|gid_table_len
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|pkey_table_len
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|phys_caps
operator|.
name|pkey_phys_table_len
index|[
name|i
index|]
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|choose_log_fs_mgm_entry_size
parameter_list|(
name|int
name|qp_per_entry
parameter_list|)
block|{
name|int
name|i
init|=
name|MLX4_MIN_MGM_LOG_ENTRY_SIZE
decl_stmt|;
for|for
control|(
name|i
operator|=
name|MLX4_MIN_MGM_LOG_ENTRY_SIZE
init|;
name|i
operator|<=
name|MLX4_MAX_MGM_LOG_ENTRY_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qp_per_entry
operator|<=
literal|4
operator|*
operator|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|/
literal|16
operator|-
literal|2
operator|)
condition|)
break|break;
block|}
return|return
operator|(
name|i
operator|<=
name|MLX4_MAX_MGM_LOG_ENTRY_SIZE
operator|)
condition|?
name|i
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|choose_steering_mode
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
parameter_list|)
block|{
comment|// This is only valid to the integrated driver.
comment|// The new ported mlx4_core driver is in B0 steering mode by default
comment|// and the old mlx4_en driver is in A0 steering mode by default.
comment|// If high_rate_steer == TRUE it means that A0 steering mode is on.
comment|// The integration fix is to hard code high_rate_steer to TRUE.
name|high_rate_steer
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|high_rate_steer
operator|&&
operator|!
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&=
operator|~
operator|(
name|MLX4_DEV_CAP_FLAG_VEP_MC_STEER
operator||
name|MLX4_DEV_CAP_FLAG_VEP_UC_STEER
operator|)
expr_stmt|;
name|dev_cap
operator|->
name|flags2
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG2_FS_EN
expr_stmt|;
block|}
if|if
condition|(
name|mlx4_log_num_mgm_entry_size
operator|==
operator|-
literal|1
operator|&&
name|dev_cap
operator|->
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_FS_EN
operator|&&
name|dev_cap
operator|->
name|fs_log_max_ucast_qp_range_size
operator|==
literal|0
operator|&&
operator|(
operator|!
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
operator|||
operator|(
name|dev_cap
operator|->
name|fs_max_num_qp_per_entry
operator|>=
operator|(
name|num_vfs
operator|+
literal|1
operator|)
operator|)
operator|)
operator|&&
name|choose_log_fs_mgm_entry_size
argument_list|(
name|dev_cap
operator|->
name|fs_max_num_qp_per_entry
argument_list|)
operator|>=
name|MLX4_MIN_MGM_LOG_ENTRY_SIZE
condition|)
block|{
name|dev
operator|->
name|oper_log_mgm_entry_size
operator|=
name|choose_log_fs_mgm_entry_size
argument_list|(
name|dev_cap
operator|->
name|fs_max_num_qp_per_entry
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|=
name|MLX4_STEERING_MODE_DEVICE_MANAGED
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_qp_per_mgm
operator|=
name|dev_cap
operator|->
name|fs_max_num_qp_per_entry
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_VEP_UC_STEER
operator|&&
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_VEP_MC_STEER
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|=
name|MLX4_STEERING_MODE_B0
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|=
name|MLX4_STEERING_MODE_A0
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_VEP_UC_STEER
operator|||
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_VEP_MC_STEER
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Must have both UC_STEER and MC_STEER flags "
literal|"set to use B0 steering. Falling back to A0 steering mode.\n"
argument_list|)
expr_stmt|;
block|}
name|dev
operator|->
name|oper_log_mgm_entry_size
operator|=
name|mlx4_log_num_mgm_entry_size
operator|>
literal|0
condition|?
name|mlx4_log_num_mgm_entry_size
else|:
name|MLX4_DEFAULT_MGM_LOG_ENTRY_SIZE
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_qp_per_mgm
operator|=
name|mlx4_get_qp_per_mgm
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Steering mode is: %s, oper_log_mgm_entry_size = %d, "
literal|"log_num_mgm_entry_size = %d\n"
argument_list|,
name|mlx4_steering_mode_str
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
argument_list|)
argument_list|,
name|dev
operator|->
name|oper_log_mgm_entry_size
argument_list|,
name|mlx4_log_num_mgm_entry_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_hca
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
init|=
name|NULL
decl_stmt|;
name|struct
name|mlx4_adapter
name|adapter
decl_stmt|;
name|struct
name|mlx4_mod_stat_cfg
name|mlx4_cfg
decl_stmt|;
name|struct
name|mlx4_profile
name|profile
decl_stmt|;
name|struct
name|mlx4_init_hca_param
name|init_hca
decl_stmt|;
name|u64
name|icm_size
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|err
operator|=
name|mlx4_QUERY_FW
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|==
operator|-
name|EACCES
condition|)
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"non-primary physical function, skipping.\n"
argument_list|)
expr_stmt|;
else|else
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_FW command failed, aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|mlx4_load_fw
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to start FW, aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|mlx4_cfg
operator|.
name|log_pg_sz_m
operator|=
literal|1
expr_stmt|;
name|mlx4_cfg
operator|.
name|log_pg_sz
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|mlx4_MOD_STAT_CFG
argument_list|(
name|dev
argument_list|,
operator|&
name|mlx4_cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Failed to override log_pg_sz parameter\n"
argument_list|)
expr_stmt|;
name|dev_cap
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|dev_cap
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_cap
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to allocate memory for dev_cap\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_stop_fw
goto|;
block|}
name|err
operator|=
name|mlx4_dev_cap
argument_list|(
name|dev
argument_list|,
name|dev_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_DEV_CAP command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_stop_fw
goto|;
block|}
name|choose_steering_mode
argument_list|(
name|dev
argument_list|,
name|dev_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_parav_master_pf_caps
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|process_mod_param_profile
argument_list|(
operator|&
name|profile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|==
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
name|profile
operator|.
name|num_mcg
operator|=
name|MLX4_FS_NUM_MCG
expr_stmt|;
name|icm_size
operator|=
name|mlx4_make_profile
argument_list|(
name|dev
argument_list|,
operator|&
name|profile
argument_list|,
name|dev_cap
argument_list|,
operator|&
name|init_hca
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|long
name|long
operator|)
name|icm_size
operator|<
literal|0
condition|)
block|{
name|err
operator|=
name|icm_size
expr_stmt|;
goto|goto
name|err_stop_fw
goto|;
block|}
name|dev
operator|->
name|caps
operator|.
name|max_fmr_maps
operator|=
operator|(
literal|1
operator|<<
operator|(
literal|32
operator|-
name|ilog2
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|num_mpts
argument_list|)
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|init_hca
operator|.
name|log_uar_sz
operator|=
name|ilog2
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|num_uars
argument_list|)
expr_stmt|;
name|init_hca
operator|.
name|uar_page_sz
operator|=
name|PAGE_SHIFT
operator|-
literal|12
expr_stmt|;
name|err
operator|=
name|mlx4_init_icm
argument_list|(
name|dev
argument_list|,
name|dev_cap
argument_list|,
operator|&
name|init_hca
argument_list|,
name|icm_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_stop_fw
goto|;
name|err
operator|=
name|mlx4_INIT_HCA
argument_list|(
name|dev
argument_list|,
operator|&
name|init_hca
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"INIT_HCA command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free_icm
goto|;
block|}
block|}
else|else
block|{
name|err
operator|=
name|mlx4_init_slave
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize slave\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|mlx4_slave_cap
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to obtain slave caps\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_close
goto|;
block|}
block|}
if|if
condition|(
name|map_bf_area
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Failed to map blue flame area\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Read HCA frequency by QUERY_HCA command 	 */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|cq_timestamp
condition|)
block|{
name|memset
argument_list|(
operator|&
name|init_hca
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|init_hca
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_QUERY_HCA
argument_list|(
name|dev
argument_list|,
operator|&
name|init_hca
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_HCA command failed, disable timestamp.\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|cq_timestamp
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|dev
operator|->
name|caps
operator|.
name|hca_core_clock
operator|=
name|init_hca
operator|.
name|hca_core_clock
expr_stmt|;
comment|/* 		 * In case we got HCA frequency 0 - disable timestamping 		 * to avoid dividing by zero 		 */
if|if
condition|(
operator|!
name|dev
operator|->
name|caps
operator|.
name|hca_core_clock
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|cq_timestamp
operator|=
literal|0
expr_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"HCA frequency is 0. "
literal|"Timestamping is not supported."
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Map internal clock, in case of failure disable timestamping 		 */
if|if
condition|(
name|map_internal_clock
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|cq_timestamp
operator|=
literal|0
expr_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map internal clock. "
literal|"Timestamping is not supported.\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*Only the master set the ports, all the rest got it from it.*/
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_set_port_mask
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_QUERY_ADAPTER
argument_list|(
name|dev
argument_list|,
operator|&
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_ADAPTER command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|unmap_bf
goto|;
block|}
name|priv
operator|->
name|eq_table
operator|.
name|inta_pin
operator|=
name|adapter
operator|.
name|inta_pin
expr_stmt|;
name|memcpy
argument_list|(
name|dev
operator|->
name|board_id
argument_list|,
name|adapter
operator|.
name|board_id
argument_list|,
sizeof|sizeof
name|dev
operator|->
name|board_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|kfree
argument_list|(
name|dev_cap
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|unmap_bf
label|:
name|unmap_internal_clock
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unmap_bf_area
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
argument_list|)
expr_stmt|;
block|}
name|err_close
label|:
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_slave_exit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
else|else
name|mlx4_CLOSE_HCA
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err_free_icm
label|:
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_free_icms
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_stop_fw
label|:
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|mlx4_UNMAP_FA
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|fw_icm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev_cap
condition|)
name|kfree
argument_list|(
name|dev_cap
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_counters_table
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|res
decl_stmt|;
name|int
name|nent_pow2
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_COUNTERS
operator|)
condition|)
return|return
operator|-
name|ENOENT
return|;
name|nent_pow2
operator|=
name|roundup_pow_of_two
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|max_counters
argument_list|)
expr_stmt|;
name|res
operator|=
name|mlx4_bitmap_init
argument_list|(
operator|&
name|priv
operator|->
name|counters_bitmap
argument_list|,
name|nent_pow2
argument_list|,
name|nent_pow2
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
name|nent_pow2
operator|-
name|dev
operator|->
name|caps
operator|.
name|max_counters
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
return|return
name|res
return|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|max_counters
operator|==
name|dev
operator|->
name|caps
operator|.
name|max_basic_counters
condition|)
return|return
literal|0
return|;
name|res
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_IF_STATE_EXTENDED
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_SET_IF_STAT
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to set extended counters (err=%d)\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_cleanup_counters_table
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_COUNTERS
operator|)
condition|)
name|mlx4_bitmap_cleanup
argument_list|(
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|counters_bitmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|__mlx4_counter_alloc
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u32
modifier|*
name|idx
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_COUNTERS
operator|)
condition|)
return|return
operator|-
name|ENOENT
return|;
operator|*
name|idx
operator|=
name|mlx4_bitmap_alloc
argument_list|(
operator|&
name|priv
operator|->
name|counters_bitmap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|idx
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
name|ENOMEM
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx4_counter_alloc
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u32
modifier|*
name|idx
parameter_list|)
block|{
name|u64
name|out_param
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|err
operator|=
name|mlx4_cmd_imm
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
operator|&
name|out_param
argument_list|,
name|RES_COUNTER
argument_list|,
name|RES_OP_RESERVE
argument_list|,
name|MLX4_CMD_ALLOC_RES
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
operator|*
name|idx
operator|=
name|get_param_l
argument_list|(
operator|&
name|out_param
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
return|return
name|__mlx4_counter_alloc
argument_list|(
name|dev
argument_list|,
name|idx
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_counter_alloc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|__mlx4_counter_free
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|idx
parameter_list|)
block|{
name|mlx4_bitmap_free
argument_list|(
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|counters_bitmap
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|mlx4_counter_free
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|idx
parameter_list|)
block|{
name|u64
name|in_param
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|set_param_l
argument_list|(
operator|&
name|in_param
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|in_param
argument_list|,
name|RES_COUNTER
argument_list|,
name|RES_OP_RESERVE
argument_list|,
name|MLX4_CMD_FREE_RES
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
expr_stmt|;
return|return;
block|}
name|__mlx4_counter_free
argument_list|(
name|dev
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_counter_free
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|mlx4_setup_hca
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|port
decl_stmt|;
name|__be32
name|ib_port_default_caps
decl_stmt|;
name|err
operator|=
name|mlx4_init_uar_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"user access region table (err=%d), aborting.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|mlx4_uar_alloc
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|driver_uar
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to allocate driver access region "
literal|"(err=%d), aborting.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_uar_table_free
goto|;
block|}
name|priv
operator|->
name|kar
operator|=
name|ioremap
argument_list|(
operator|(
name|phys_addr_t
operator|)
name|priv
operator|->
name|driver_uar
operator|.
name|pfn
operator|<<
name|PAGE_SHIFT
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|kar
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Couldn't map kernel access region, "
literal|"aborting.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_uar_free
goto|;
block|}
name|err
operator|=
name|mlx4_init_pd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"protection domain table (err=%d), aborting.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_kar_unmap
goto|;
block|}
name|err
operator|=
name|mlx4_init_xrcd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"reliable connection domain table (err=%d), "
literal|"aborting.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_pd_table_free
goto|;
block|}
name|err
operator|=
name|mlx4_init_mr_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"memory region table (err=%d), aborting.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_xrcd_table_free
goto|;
block|}
name|err
operator|=
name|mlx4_init_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"event queue table (err=%d), aborting.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_mr_table_free
goto|;
block|}
name|err
operator|=
name|mlx4_cmd_use_events
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to switch to event-driven "
literal|"firmware commands (err=%d), aborting.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_eq_table_free
goto|;
block|}
name|err
operator|=
name|mlx4_NOP
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_MSI_X
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"NOP command failed to generate MSI-X "
literal|"interrupt IRQ %d).\n"
argument_list|,
name|priv
operator|->
name|eq_table
operator|.
name|eq
index|[
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
index|]
operator|.
name|irq
argument_list|)
expr_stmt|;
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Trying again without MSI-X.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"NOP command failed to generate interrupt "
literal|"(IRQ %d), aborting.\n"
argument_list|,
name|priv
operator|->
name|eq_table
operator|.
name|eq
index|[
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
index|]
operator|.
name|irq
argument_list|)
expr_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"BIOS or ACPI interrupt routing problem?\n"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|err_cmd_poll
goto|;
block|}
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"NOP command IRQ test passed\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_init_cq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"completion queue table (err=%d), aborting.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_cmd_poll
goto|;
block|}
name|err
operator|=
name|mlx4_init_srq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"shared receive queue table (err=%d), aborting.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_cq_table_free
goto|;
block|}
name|err
operator|=
name|mlx4_init_qp_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"queue pair table (err=%d), aborting.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_srq_table_free
goto|;
block|}
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|err
operator|=
name|mlx4_init_mcg_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"multicast group table (err=%d), aborting.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_qp_table_free
goto|;
block|}
name|err
operator|=
name|mlx4_init_counters_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|!=
operator|-
name|ENOENT
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize counters table (err=%d), "
literal|"aborting.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_mcg_table_free
goto|;
block|}
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
name|ib_port_default_caps
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|mlx4_get_port_ib_caps
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
operator|&
name|ib_port_default_caps
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"failed to get port %d default "
literal|"ib capabilities (%d). Continuing "
literal|"with caps = 0\n"
argument_list|,
name|port
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|ib_port_def_cap
index|[
name|port
index|]
operator|=
name|ib_port_default_caps
expr_stmt|;
comment|/* initialize per-slave default ib port capabilities */
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|num_slaves
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|mlx4_master_func_num
argument_list|(
name|dev
argument_list|)
condition|)
continue|continue;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|i
index|]
operator|.
name|ib_cap_mask
index|[
name|port
index|]
operator|=
name|ib_port_default_caps
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
name|dev
operator|->
name|caps
operator|.
name|port_ib_mtu
index|[
name|port
index|]
operator|=
name|IB_MTU_2048
expr_stmt|;
else|else
name|dev
operator|->
name|caps
operator|.
name|port_ib_mtu
index|[
name|port
index|]
operator|=
name|IB_MTU_4096
expr_stmt|;
name|err
operator|=
name|mlx4_SET_PORT
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|?
name|dev
operator|->
name|caps
operator|.
name|pkey_table_len
index|[
name|port
index|]
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to set port %d (err=%d), "
literal|"aborting\n"
argument_list|,
name|port
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_counters_table_free
goto|;
block|}
block|}
block|}
return|return
literal|0
return|;
name|err_counters_table_free
label|:
name|mlx4_cleanup_counters_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_mcg_table_free
label|:
name|mlx4_cleanup_mcg_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_qp_table_free
label|:
name|mlx4_cleanup_qp_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_srq_table_free
label|:
name|mlx4_cleanup_srq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_cq_table_free
label|:
name|mlx4_cleanup_cq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_cmd_poll
label|:
name|mlx4_cmd_use_polling
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_eq_table_free
label|:
name|mlx4_cleanup_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_mr_table_free
label|:
name|mlx4_cleanup_mr_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_xrcd_table_free
label|:
name|mlx4_cleanup_xrcd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_pd_table_free
label|:
name|mlx4_cleanup_pd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_kar_unmap
label|:
name|iounmap
argument_list|(
name|priv
operator|->
name|kar
argument_list|)
expr_stmt|;
name|err_uar_free
label|:
name|mlx4_uar_free
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|driver_uar
argument_list|)
expr_stmt|;
name|err_uar_table_free
label|:
name|mlx4_cleanup_uar_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_enable_msi_x
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|msix_entry
modifier|*
name|entries
decl_stmt|;
name|int
name|nreq
init|=
name|min_t
argument_list|(
name|int
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
operator|*
name|min_t
argument_list|(
name|int
argument_list|,
name|num_possible_cpus
argument_list|()
operator|+
literal|1
argument_list|,
name|MAX_MSIX_P_PORT
argument_list|)
operator|+
name|MSIX_LEGACY_SZ
argument_list|,
name|MAX_MSIX
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|msi_x
condition|)
block|{
name|nreq
operator|=
name|min_t
argument_list|(
name|int
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_eqs
operator|-
name|dev
operator|->
name|caps
operator|.
name|reserved_eqs
argument_list|,
name|nreq
argument_list|)
expr_stmt|;
name|entries
operator|=
name|kcalloc
argument_list|(
name|nreq
argument_list|,
sizeof|sizeof
expr|*
name|entries
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entries
condition|)
goto|goto
name|no_msi
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nreq
condition|;
operator|++
name|i
control|)
name|entries
index|[
name|i
index|]
operator|.
name|entry
operator|=
name|i
expr_stmt|;
name|retry
label|:
name|err
operator|=
name|pci_enable_msix
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|entries
argument_list|,
name|nreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* Try again if at least 2 vectors are available */
if|if
condition|(
name|err
operator|>
literal|1
condition|)
block|{
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"Requested %d vectors, "
literal|"but only %d MSI-X vectors available, "
literal|"trying again\n"
argument_list|,
name|nreq
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|nreq
operator|=
name|err
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|kfree
argument_list|(
name|entries
argument_list|)
expr_stmt|;
goto|goto
name|no_msi
goto|;
block|}
if|if
condition|(
name|nreq
operator|<
name|MSIX_LEGACY_SZ
operator|+
name|dev
operator|->
name|caps
operator|.
name|num_ports
operator|*
name|MIN_MSIX_P_PORT
condition|)
block|{
comment|/*Working in legacy mode , all EQ's shared*/
name|dev
operator|->
name|caps
operator|.
name|comp_pool
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
operator|=
name|nreq
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|caps
operator|.
name|comp_pool
operator|=
name|nreq
operator|-
name|MSIX_LEGACY_SZ
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
operator|=
name|MSIX_LEGACY_SZ
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nreq
condition|;
operator|++
name|i
control|)
name|priv
operator|->
name|eq_table
operator|.
name|eq
index|[
name|i
index|]
operator|.
name|irq
operator|=
name|entries
index|[
name|i
index|]
operator|.
name|vector
expr_stmt|;
name|dev
operator|->
name|flags
operator||=
name|MLX4_FLAG_MSI_X
expr_stmt|;
name|kfree
argument_list|(
name|entries
argument_list|)
expr_stmt|;
return|return;
block|}
name|no_msi
label|:
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
operator|=
literal|1
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|comp_pool
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
name|priv
operator|->
name|eq_table
operator|.
name|eq
index|[
name|i
index|]
operator|.
name|irq
operator|=
name|dev
operator|->
name|pdev
operator|->
name|irq
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_port_info
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_port_info
modifier|*
name|info
init|=
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|port
index|[
name|port
index|]
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|info
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|info
operator|->
name|port
operator|=
name|port
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|mlx4_init_mac_table
argument_list|(
name|dev
argument_list|,
operator|&
name|info
operator|->
name|mac_table
argument_list|)
expr_stmt|;
name|mlx4_init_vlan_table
argument_list|(
name|dev
argument_list|,
operator|&
name|info
operator|->
name|vlan_table
argument_list|)
expr_stmt|;
name|info
operator|->
name|base_qpn
operator|=
name|mlx4_get_base_qpn
argument_list|(
name|dev
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|info
operator|->
name|dev_name
argument_list|,
literal|"mlx4_port%d"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|info
operator|->
name|port_attr
operator|.
name|attr
operator|.
name|name
operator|=
name|info
operator|->
name|dev_name
expr_stmt|;
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
name|info
operator|->
name|port_attr
operator|.
name|attr
operator|.
name|mode
operator|=
name|S_IRUGO
expr_stmt|;
else|else
block|{
name|info
operator|->
name|port_attr
operator|.
name|attr
operator|.
name|mode
operator|=
name|S_IRUGO
operator||
name|S_IWUSR
expr_stmt|;
name|info
operator|->
name|port_attr
operator|.
name|store
operator|=
name|set_port_type
expr_stmt|;
block|}
name|info
operator|->
name|port_attr
operator|.
name|show
operator|=
name|show_port_type
expr_stmt|;
name|sysfs_attr_init
argument_list|(
operator|&
name|info
operator|->
name|port_attr
operator|.
name|attr
argument_list|)
expr_stmt|;
name|err
operator|=
name|device_create_file
argument_list|(
operator|&
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
operator|&
name|info
operator|->
name|port_attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to create file for port %d\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|info
operator|->
name|port
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|info
operator|->
name|dev_mtu_name
argument_list|,
literal|"mlx4_port%d_mtu"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|info
operator|->
name|port_mtu_attr
operator|.
name|attr
operator|.
name|name
operator|=
name|info
operator|->
name|dev_mtu_name
expr_stmt|;
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
name|info
operator|->
name|port_mtu_attr
operator|.
name|attr
operator|.
name|mode
operator|=
name|S_IRUGO
expr_stmt|;
else|else
block|{
name|info
operator|->
name|port_mtu_attr
operator|.
name|attr
operator|.
name|mode
operator|=
name|S_IRUGO
operator||
name|S_IWUSR
expr_stmt|;
name|info
operator|->
name|port_mtu_attr
operator|.
name|store
operator|=
name|set_port_ib_mtu
expr_stmt|;
block|}
name|info
operator|->
name|port_mtu_attr
operator|.
name|show
operator|=
name|show_port_ib_mtu
expr_stmt|;
name|sysfs_attr_init
argument_list|(
operator|&
name|info
operator|->
name|port_mtu_attr
operator|.
name|attr
argument_list|)
expr_stmt|;
name|err
operator|=
name|device_create_file
argument_list|(
operator|&
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
operator|&
name|info
operator|->
name|port_mtu_attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to create mtu file for port %d\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|device_remove_file
argument_list|(
operator|&
name|info
operator|->
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
operator|&
name|info
operator|->
name|port_attr
argument_list|)
expr_stmt|;
name|info
operator|->
name|port
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_cleanup_port_info
parameter_list|(
name|struct
name|mlx4_port_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|info
operator|->
name|port
operator|<
literal|0
condition|)
return|return;
name|device_remove_file
argument_list|(
operator|&
name|info
operator|->
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
operator|&
name|info
operator|->
name|port_attr
argument_list|)
expr_stmt|;
name|device_remove_file
argument_list|(
operator|&
name|info
operator|->
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
operator|&
name|info
operator|->
name|port_mtu_attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_steering
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|num_entries
init|=
name|dev
operator|->
name|caps
operator|.
name|num_ports
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|priv
operator|->
name|steer
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_steer
argument_list|)
operator|*
name|num_entries
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|steer
condition|)
return|return
operator|-
name|ENOMEM
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MLX4_NUM_STEERS
condition|;
name|j
operator|++
control|)
block|{
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|steer
index|[
name|i
index|]
operator|.
name|promisc_qps
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|steer
index|[
name|i
index|]
operator|.
name|steer_entries
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_clear_steering
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_steer_index
modifier|*
name|entry
decl_stmt|,
modifier|*
name|tmp_entry
decl_stmt|;
name|struct
name|mlx4_promisc_qp
modifier|*
name|pqp
decl_stmt|,
modifier|*
name|tmp_pqp
decl_stmt|;
name|int
name|num_entries
init|=
name|dev
operator|->
name|caps
operator|.
name|num_ports
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MLX4_NUM_STEERS
condition|;
name|j
operator|++
control|)
block|{
name|list_for_each_entry_safe
argument_list|(
argument|pqp
argument_list|,
argument|tmp_pqp
argument_list|,
argument|&priv->steer[i].promisc_qps[j]
argument_list|,
argument|list
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|pqp
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|pqp
argument_list|)
expr_stmt|;
block|}
name|list_for_each_entry_safe
argument_list|(
argument|entry
argument_list|,
argument|tmp_entry
argument_list|,
argument|&priv->steer[i].steer_entries[j]
argument_list|,
argument|list
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|entry
operator|->
name|list
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|pqp
argument_list|,
argument|tmp_pqp
argument_list|,
argument|&entry->duplicates
argument_list|,
argument|list
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|pqp
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|pqp
argument_list|)
expr_stmt|;
block|}
name|kfree
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|kfree
argument_list|(
name|priv
operator|->
name|steer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|extended_func_num
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
return|return
name|PCI_SLOT
argument_list|(
name|pdev
operator|->
name|devfn
argument_list|)
operator|*
literal|8
operator|+
name|PCI_FUNC
argument_list|(
name|pdev
operator|->
name|devfn
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MLX4_OWNER_BASE
value|0x8069c
end_define

begin_define
define|#
directive|define
name|MLX4_OWNER_SIZE
value|4
end_define

begin_function
specifier|static
name|int
name|mlx4_get_ownership
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|void
name|__iomem
modifier|*
name|owner
decl_stmt|;
name|u32
name|ret
decl_stmt|;
if|if
condition|(
name|pci_channel_offline
argument_list|(
name|dev
operator|->
name|pdev
argument_list|)
condition|)
return|return
operator|-
name|EIO
return|;
name|owner
operator|=
name|ioremap
argument_list|(
name|pci_resource_start
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|0
argument_list|)
operator|+
name|MLX4_OWNER_BASE
argument_list|,
name|MLX4_OWNER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|owner
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to obtain ownership bit\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|ret
operator|=
name|readl
argument_list|(
name|owner
argument_list|)
expr_stmt|;
name|iounmap
argument_list|(
name|owner
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
operator|!
operator|!
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_free_ownership
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|void
name|__iomem
modifier|*
name|owner
decl_stmt|;
if|if
condition|(
name|pci_channel_offline
argument_list|(
name|dev
operator|->
name|pdev
argument_list|)
condition|)
return|return;
name|owner
operator|=
name|ioremap
argument_list|(
name|pci_resource_start
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|0
argument_list|)
operator|+
name|MLX4_OWNER_BASE
argument_list|,
name|MLX4_OWNER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|owner
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to obtain ownership bit\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|writel
argument_list|(
literal|0
argument_list|,
name|owner
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|iounmap
argument_list|(
name|owner
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|__mlx4_init_one
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|int
name|pci_dev_data
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|dev
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|port
decl_stmt|;
name|pr_info
argument_list|(
name|DRV_NAME
literal|": Initializing %s\n"
argument_list|,
name|pci_name
argument_list|(
name|pdev
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|pci_enable_device
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Cannot enable PCI device, "
literal|"aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|num_vfs
operator|>
name|MLX4_MAX_NUM_VF
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"There are more VF's (%d) than allowed(%d)\n"
argument_list|,
name|num_vfs
argument_list|,
name|MLX4_MAX_NUM_VF
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|num_vfs
operator|<
literal|0
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"num_vfs module parameter cannot be negative\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* 	 * Check for BARs. 	 */
if|if
condition|(
operator|!
operator|(
name|pci_dev_data
operator|&
name|MLX4_PCI_DEV_IS_VF
operator|)
operator|&&
operator|!
operator|(
name|pci_resource_flags
argument_list|(
name|pdev
argument_list|,
literal|0
argument_list|)
operator|&
name|IORESOURCE_MEM
operator|)
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Missing DCS, aborting."
literal|"(driver_data: 0x%x, pci_resource_flags(pdev, 0):0x%x)\n"
argument_list|,
name|pci_dev_data
argument_list|,
name|pci_resource_flags
argument_list|(
name|pdev
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|err_disable_pdev
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|pci_resource_flags
argument_list|(
name|pdev
argument_list|,
literal|2
argument_list|)
operator|&
name|IORESOURCE_MEM
operator|)
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Missing UAR, aborting.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|err_disable_pdev
goto|;
block|}
name|err
operator|=
name|pci_request_regions
argument_list|(
name|pdev
argument_list|,
name|DRV_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Couldn't get PCI resources, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_disable_pdev
goto|;
block|}
name|pci_set_master
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|err
operator|=
name|pci_set_dma_mask
argument_list|(
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|64
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_warn
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Warning: couldn't set 64-bit PCI DMA mask.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|pci_set_dma_mask
argument_list|(
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Can't set PCI DMA mask, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_release_regions
goto|;
block|}
block|}
name|err
operator|=
name|pci_set_consistent_dma_mask
argument_list|(
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|64
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_warn
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Warning: couldn't set 64-bit "
literal|"consistent PCI DMA mask.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|pci_set_consistent_dma_mask
argument_list|(
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Can't set consistent PCI DMA mask, "
literal|"aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_release_regions
goto|;
block|}
block|}
comment|/* Allow large DMA segments, up to the firmware limit of 1 GB */
name|dma_set_max_seg_size
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|1024
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|priv
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|priv
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Device struct alloc failed, "
literal|"aborting.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_release_regions
goto|;
block|}
name|dev
operator|=
operator|&
name|priv
operator|->
name|dev
expr_stmt|;
name|dev
operator|->
name|pdev
operator|=
name|pdev
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|ctx_list
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|priv
operator|->
name|ctx_lock
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|priv
operator|->
name|port_mutex
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|pgdir_list
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|priv
operator|->
name|pgdir_mutex
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|bf_list
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|priv
operator|->
name|bf_mutex
argument_list|)
expr_stmt|;
name|dev
operator|->
name|rev_id
operator|=
name|pdev
operator|->
name|revision
expr_stmt|;
name|dev
operator|->
name|numa_node
operator|=
name|dev_to_node
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|)
expr_stmt|;
comment|/* Detect if this device is a virtual function */
if|if
condition|(
name|pci_dev_data
operator|&
name|MLX4_PCI_DEV_IS_VF
condition|)
block|{
comment|/* When acting as pf, we normally skip vfs unless explicitly 		 * requested to probe them. */
if|if
condition|(
name|num_vfs
operator|&&
name|extended_func_num
argument_list|(
name|pdev
argument_list|)
operator|>
name|probe_vf
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Skipping virtual function:%d\n"
argument_list|,
name|extended_func_num
argument_list|(
name|pdev
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|err_free_dev
goto|;
block|}
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Detected virtual function - running in slave mode\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator||=
name|MLX4_FLAG_SLAVE
expr_stmt|;
block|}
else|else
block|{
comment|/* We reset the device and enable SRIOV only for physical 		 * devices.  Try to claim ownership on the device; 		 * if already taken, skip -- do not allow multiple PFs */
name|err
operator|=
name|mlx4_get_ownership
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|<
literal|0
condition|)
goto|goto
name|err_free_dev
goto|;
else|else
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Multiple PFs not yet supported."
literal|" Skipping PF.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_free_dev
goto|;
block|}
block|}
if|if
condition|(
name|num_vfs
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Enabling SR-IOV with %d VFs\n"
argument_list|,
name|num_vfs
argument_list|)
expr_stmt|;
name|err
operator|=
name|pci_enable_sriov
argument_list|(
name|pdev
argument_list|,
name|num_vfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to enable SR-IOV, continuing without SR-IOV (err = %d).\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Running in master mode\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator||=
name|MLX4_FLAG_SRIOV
operator||
name|MLX4_FLAG_MASTER
expr_stmt|;
name|dev
operator|->
name|num_vfs
operator|=
name|num_vfs
expr_stmt|;
block|}
block|}
name|atomic_set
argument_list|(
operator|&
name|priv
operator|->
name|opreq_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INIT_WORK
argument_list|(
operator|&
name|priv
operator|->
name|opreq_task
argument_list|,
name|mlx4_opreq_action
argument_list|)
expr_stmt|;
comment|/* 		 * Now reset the HCA before we touch the PCI capabilities or 		 * attempt a firmware command, since a boot ROM may have left 		 * the HCA in an undefined state. 		 */
name|err
operator|=
name|mlx4_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to reset HCA, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_sriov
goto|;
block|}
block|}
name|slave_start
label|:
name|err
operator|=
name|mlx4_cmd_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to init command interface, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_sriov
goto|;
block|}
comment|/* In slave functions, the communication channel must be initialized 	 * before posting commands. Also, init num_slaves before calling 	 * mlx4_init_hca */
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
name|dev
operator|->
name|num_slaves
operator|=
name|MLX4_MAX_NUM_SLAVES
expr_stmt|;
else|else
block|{
name|dev
operator|->
name|num_slaves
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|mlx4_multi_func_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to init slave mfunc"
literal|" interface, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_cmd
goto|;
block|}
block|}
block|}
name|err
operator|=
name|mlx4_init_hca
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|==
operator|-
name|EACCES
condition|)
block|{
comment|/* Not primary Physical function 			 * Running in slave mode */
name|mlx4_cmd_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator||=
name|MLX4_FLAG_SLAVE
expr_stmt|;
name|dev
operator|->
name|flags
operator|&=
operator|~
name|MLX4_FLAG_MASTER
expr_stmt|;
goto|goto
name|slave_start
goto|;
block|}
else|else
goto|goto
name|err_mfunc
goto|;
block|}
comment|/* In master functions, the communication channel must be initialized 	 * after obtaining its address from fw */
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|err
operator|=
name|mlx4_multi_func_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to init master mfunc"
literal|"interface, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_close
goto|;
block|}
block|}
name|err
operator|=
name|mlx4_alloc_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_master_mfunc
goto|;
name|priv
operator|->
name|msix_ctl
operator|.
name|pool_bm
operator|=
literal|0
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|priv
operator|->
name|msix_ctl
operator|.
name|pool_lock
argument_list|)
expr_stmt|;
name|mlx4_enable_msi_x
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_MSI_X
operator|)
condition|)
block|{
name|err
operator|=
operator|-
name|ENOSYS
expr_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"INTx is not supported in multi-function mode."
literal|" aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free_eq
goto|;
block|}
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|err
operator|=
name|mlx4_init_steering
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_free_eq
goto|;
block|}
name|err
operator|=
name|mlx4_setup_hca
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
operator|-
name|EBUSY
operator|&&
operator|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_MSI_X
operator|)
operator|&&
operator|!
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev
operator|->
name|flags
operator|&=
operator|~
name|MLX4_FLAG_MSI_X
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
operator|=
literal|1
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|comp_pool
operator|=
literal|0
expr_stmt|;
name|pci_disable_msix
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_setup_hca
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
goto|goto
name|err_steer
goto|;
name|mlx4_init_quotas
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
name|err
operator|=
name|mlx4_init_port_info
argument_list|(
name|dev
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_port
goto|;
block|}
name|err
operator|=
name|mlx4_register_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_port
goto|;
name|err
operator|=
name|mlx4_sense_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_port
goto|;
name|mlx4_start_sense
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|priv
operator|->
name|pci_dev_data
operator|=
name|pci_dev_data
expr_stmt|;
name|pci_set_drvdata
argument_list|(
name|pdev
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_port
label|:
for|for
control|(
operator|--
name|port
init|;
name|port
operator|>=
literal|1
condition|;
operator|--
name|port
control|)
name|mlx4_cleanup_port_info
argument_list|(
operator|&
name|priv
operator|->
name|port
index|[
name|port
index|]
argument_list|)
expr_stmt|;
name|mlx4_cleanup_counters_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_mcg_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_qp_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_srq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_cq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cmd_use_polling
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_mr_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_xrcd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_pd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_uar_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_steer
label|:
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_clear_steering
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_free_eq
label|:
name|mlx4_free_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_master_mfunc
label|:
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_multi_func_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
argument_list|)
expr_stmt|;
block|}
name|err_close
label|:
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_MSI_X
condition|)
name|pci_disable_msix
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|mlx4_close_hca
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_mfunc
label|:
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_multi_func_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_cmd
label|:
name|mlx4_cmd_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_sriov
label|:
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_SRIOV
condition|)
name|pci_disable_sriov
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_free_ownership
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_free_dev
label|:
name|kfree
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|err_release_regions
label|:
name|pci_release_regions
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|err_disable_pdev
label|:
name|pci_disable_device
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|pci_set_drvdata
argument_list|(
name|pdev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__devinit
name|mlx4_init_one
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
specifier|const
name|struct
name|pci_device_id
modifier|*
name|id
parameter_list|)
block|{
name|printk_once
argument_list|(
name|KERN_INFO
literal|"%s"
argument_list|,
name|mlx4_version
argument_list|)
expr_stmt|;
return|return
name|__mlx4_init_one
argument_list|(
name|pdev
argument_list|,
name|id
operator|->
name|driver_data
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_remove_one
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|p
decl_stmt|;
if|if
condition|(
name|dev
condition|)
block|{
comment|/* in SRIOV it is not allowed to unload the pf's 		 * driver while there are alive vf's */
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|mlx4_how_many_lives_vf
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Removing PF when there are assigned VF's !!!\n"
argument_list|)
expr_stmt|;
block|}
name|mlx4_sense_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_unregister_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|1
init|;
name|p
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|p
operator|++
control|)
block|{
name|mlx4_cleanup_port_info
argument_list|(
operator|&
name|priv
operator|->
name|port
index|[
name|p
index|]
argument_list|)
expr_stmt|;
name|mlx4_CLOSE_PORT
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_free_resource_tracker
argument_list|(
name|dev
argument_list|,
name|RES_TR_FREE_SLAVES_ONLY
argument_list|)
expr_stmt|;
name|mlx4_cleanup_counters_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_mcg_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_qp_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_srq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_cq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cmd_use_polling
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_mr_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_xrcd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_pd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_free_resource_tracker
argument_list|(
name|dev
argument_list|,
name|RES_TR_FREE_STRUCTS_ONLY
argument_list|)
expr_stmt|;
name|iounmap
argument_list|(
name|priv
operator|->
name|kar
argument_list|)
expr_stmt|;
name|mlx4_uar_free
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|driver_uar
argument_list|)
expr_stmt|;
name|mlx4_cleanup_uar_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_clear_steering
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_free_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_multi_func_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_close_hca
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_multi_func_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cmd_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_MSI_X
condition|)
name|pci_disable_msix
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_SRIOV
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Disabling SR-IOV\n"
argument_list|)
expr_stmt|;
name|pci_disable_sriov
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_free_ownership
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|pci_release_regions
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|pci_disable_device
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|pci_set_drvdata
argument_list|(
name|pdev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|mlx4_restart_one
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|pci_dev_data
decl_stmt|;
name|pci_dev_data
operator|=
name|priv
operator|->
name|pci_dev_data
expr_stmt|;
name|mlx4_remove_one
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
return|return
name|__mlx4_init_one
argument_list|(
name|pdev
argument_list|,
name|pci_dev_data
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|DEFINE_PCI_DEVICE_TABLE
argument_list|(
name|mlx4_pci_table
argument_list|)
operator|=
block|{
comment|/* MT25408 "Hermon" SDR */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x6340
argument_list|)
block|,
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25408 "Hermon" DDR */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x634a
argument_list|)
block|,
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25408 "Hermon" QDR */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x6354
argument_list|)
block|,
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25408 "Hermon" DDR PCIe gen2 */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x6732
argument_list|)
block|,
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25408 "Hermon" QDR PCIe gen2 */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x673c
argument_list|)
block|,
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25408 "Hermon" EN 10GigE */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x6368
argument_list|)
block|,
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25408 "Hermon" EN 10GigE PCIe gen2 */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x6750
argument_list|)
block|,
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25458 ConnectX EN 10GBASE-T 10GigE */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x6372
argument_list|)
block|,
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25458 ConnectX EN 10GBASE-T+Gen2 10GigE */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x675a
argument_list|)
block|,
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT26468 ConnectX EN 10GigE PCIe gen2*/
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x6764
argument_list|)
block|,
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT26438 ConnectX EN 40GigE PCIe gen2 5GT/s */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x6746
argument_list|)
block|,
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT26478 ConnectX2 40GigE PCIe gen2 */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x676e
argument_list|)
block|,
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25400 Family [ConnectX-2 Virtual Function] */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x1002
argument_list|)
block|,
name|MLX4_PCI_DEV_IS_VF
block|}
block|,
comment|/* MT27500 Family [ConnectX-3] */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x1003
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27500 Family [ConnectX-3 Virtual Function] */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x1004
argument_list|)
block|,
name|MLX4_PCI_DEV_IS_VF
block|}
block|,
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x1005
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27510 Family */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x1006
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27511 Family */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x1007
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27520 Family */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x1008
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27521 Family */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x1009
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27530 Family */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x100a
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27531 Family */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x100b
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27540 Family */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x100c
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27541 Family */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x100d
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27550 Family */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x100e
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27551 Family */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x100f
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27560 Family */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x1010
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27561 Family */
block|{
literal|0
block|, }
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEVICE_TABLE
argument_list|(
name|pci
argument_list|,
name|mlx4_pci_table
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|pci_ers_result_t
name|mlx4_pci_err_detected
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|pci_channel_state_t
name|state
parameter_list|)
block|{
name|mlx4_remove_one
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
return|return
name|state
operator|==
name|pci_channel_io_perm_failure
condition|?
name|PCI_ERS_RESULT_DISCONNECT
else|:
name|PCI_ERS_RESULT_NEED_RESET
return|;
block|}
end_function

begin_function
specifier|static
name|pci_ers_result_t
name|mlx4_pci_slot_reset
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|int
name|ret
init|=
name|__mlx4_init_one
argument_list|(
name|pdev
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|ret
condition|?
name|PCI_ERS_RESULT_DISCONNECT
else|:
name|PCI_ERS_RESULT_RECOVERED
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pci_error_handlers
name|mlx4_err_handler
init|=
block|{
operator|.
name|error_detected
operator|=
name|mlx4_pci_err_detected
block|,
operator|.
name|slot_reset
operator|=
name|mlx4_pci_slot_reset
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|suspend
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|pm_message_t
name|state
parameter_list|)
block|{
name|mlx4_remove_one
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_log_num_mgm_entry_size
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|mlx4_log_num_mgm_entry_size
operator|<
name|MLX4_MIN_MGM_LOG_ENTRY_SIZE
operator|||
name|mlx4_log_num_mgm_entry_size
operator|>
name|MLX4_MAX_MGM_LOG_ENTRY_SIZE
operator|)
condition|)
block|{
name|pr_warning
argument_list|(
literal|"mlx4_core: mlx4_log_num_mgm_entry_size (%d) not "
literal|"in legal range (-1 or %d..%d)\n"
argument_list|,
name|mlx4_log_num_mgm_entry_size
argument_list|,
name|MLX4_MIN_MGM_LOG_ENTRY_SIZE
argument_list|,
name|MLX4_MAX_MGM_LOG_ENTRY_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|resume
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
return|return
name|__mlx4_init_one
argument_list|(
name|pdev
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|pci_driver
name|mlx4_driver
init|=
block|{
operator|.
name|name
operator|=
name|DRV_NAME
block|,
operator|.
name|id_table
operator|=
operator|(
expr|struct
name|pci_device_id
operator|*
operator|)
name|mlx4_pci_table
block|,
operator|.
name|probe
operator|=
name|mlx4_init_one
block|,
operator|.
name|remove
operator|=
name|__devexit_p
argument_list|(
name|mlx4_remove_one
argument_list|)
block|,
operator|.
name|suspend
operator|=
name|suspend
block|,
operator|.
name|resume
operator|=
name|resume
block|,
operator|.
name|err_handler
operator|=
operator|(
expr|struct
name|pci_error_handlers
operator|*
operator|)
operator|&
name|mlx4_err_handler
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|__init
name|mlx4_verify_params
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|(
name|log_num_mac
operator|<
literal|0
operator|)
operator|||
operator|(
name|log_num_mac
operator|>
literal|7
operator|)
condition|)
block|{
name|pr_warning
argument_list|(
literal|"mlx4_core: bad num_mac: %d\n"
argument_list|,
name|log_num_mac
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|log_num_vlan
operator|!=
literal|0
condition|)
name|pr_warning
argument_list|(
literal|"mlx4_core: log_num_vlan - obsolete module param, using %d\n"
argument_list|,
name|MLX4_LOG_NUM_VLANS
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_set_4k_mtu
operator|!=
operator|-
literal|1
condition|)
name|pr_warning
argument_list|(
literal|"mlx4_core: set_4k_mtu - obsolete module param\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|log_mtts_per_seg
operator|<
literal|0
operator|)
operator|||
operator|(
name|log_mtts_per_seg
operator|>
literal|7
operator|)
condition|)
block|{
name|pr_warning
argument_list|(
literal|"mlx4_core: bad log_mtts_per_seg: %d\n"
argument_list|,
name|log_mtts_per_seg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check if module param for ports type has legal combination */
if|if
condition|(
name|port_type_array
index|[
literal|0
index|]
operator|==
name|false
operator|&&
name|port_type_array
index|[
literal|1
index|]
operator|==
name|true
condition|)
block|{
name|pr_warning
argument_list|(
literal|"mlx4_core: module parameter configuration ETH/IB is not supported. Switching to default configuration IB/IB\n"
argument_list|)
expr_stmt|;
name|port_type_array
index|[
literal|0
index|]
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|mlx4_log_num_mgm_entry_size
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|mlx4_log_num_mgm_entry_size
operator|<
name|MLX4_MIN_MGM_LOG_ENTRY_SIZE
operator|||
name|mlx4_log_num_mgm_entry_size
operator|>
name|MLX4_MAX_MGM_LOG_ENTRY_SIZE
operator|)
condition|)
block|{
name|pr_warning
argument_list|(
literal|"mlx4_core: mlx4_log_num_mgm_entry_size (%d) not "
literal|"in legal range (-1 or %d..%d)\n"
argument_list|,
name|mlx4_log_num_mgm_entry_size
argument_list|,
name|MLX4_MIN_MGM_LOG_ENTRY_SIZE
argument_list|,
name|MLX4_MAX_MGM_LOG_ENTRY_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|mod_param_profile
operator|.
name|num_qp
operator|<
literal|18
operator|||
name|mod_param_profile
operator|.
name|num_qp
operator|>
literal|23
condition|)
block|{
name|pr_warning
argument_list|(
literal|"mlx4_core: bad log_num_qp: %d\n"
argument_list|,
name|mod_param_profile
operator|.
name|num_qp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|mod_param_profile
operator|.
name|num_srq
operator|<
literal|10
condition|)
block|{
name|pr_warning
argument_list|(
literal|"mlx4_core: too low log_num_srq: %d\n"
argument_list|,
name|mod_param_profile
operator|.
name|num_srq
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|mod_param_profile
operator|.
name|num_cq
operator|<
literal|10
condition|)
block|{
name|pr_warning
argument_list|(
literal|"mlx4_core: too low log_num_cq: %d\n"
argument_list|,
name|mod_param_profile
operator|.
name|num_cq
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|mod_param_profile
operator|.
name|num_mpt
operator|<
literal|10
condition|)
block|{
name|pr_warning
argument_list|(
literal|"mlx4_core: too low log_num_mpt: %d\n"
argument_list|,
name|mod_param_profile
operator|.
name|num_mpt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|mod_param_profile
operator|.
name|num_mtt
operator|&&
name|mod_param_profile
operator|.
name|num_mtt
operator|<
literal|15
condition|)
block|{
name|pr_warning
argument_list|(
literal|"mlx4_core: too low log_num_mtt: %d\n"
argument_list|,
name|mod_param_profile
operator|.
name|num_mtt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|mod_param_profile
operator|.
name|num_mtt
operator|>
name|MLX4_MAX_LOG_NUM_MTT
condition|)
block|{
name|pr_warning
argument_list|(
literal|"mlx4_core: too high log_num_mtt: %d\n"
argument_list|,
name|mod_param_profile
operator|.
name|num_mtt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__init
name|mlx4_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|mlx4_verify_params
argument_list|()
condition|)
return|return
operator|-
name|EINVAL
return|;
name|mlx4_catas_init
argument_list|()
expr_stmt|;
name|mlx4_wq
operator|=
name|create_singlethread_workqueue
argument_list|(
literal|"mlx4"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_wq
condition|)
return|return
operator|-
name|ENOMEM
return|;
if|if
condition|(
name|enable_sys_tune
condition|)
name|sys_tune_init
argument_list|()
expr_stmt|;
name|ret
operator|=
name|pci_register_driver
argument_list|(
operator|&
name|mlx4_driver
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|&&
name|enable_sys_tune
condition|)
name|sys_tune_fini
argument_list|()
expr_stmt|;
return|return
name|ret
operator|<
literal|0
condition|?
name|ret
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__exit
name|mlx4_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|enable_sys_tune
condition|)
name|sys_tune_fini
argument_list|()
expr_stmt|;
name|pci_unregister_driver
argument_list|(
operator|&
name|mlx4_driver
argument_list|)
expr_stmt|;
name|destroy_workqueue
argument_list|(
name|mlx4_wq
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|module_init_order
argument_list|(
name|mlx4_init
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_exit
argument_list|(
name|mlx4_cleanup
argument_list|)
expr_stmt|;
end_expr_stmt

begin_undef
undef|#
directive|undef
name|MODULE_VERSION
end_undef

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_function
specifier|static
name|int
name|mlx4_evhand
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|mlx4_mod
init|=
block|{
operator|.
name|name
operator|=
literal|"mlx4"
block|,
operator|.
name|evhand
operator|=
name|mlx4_evhand
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|mlx4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|mlx4
argument_list|,
name|mlx4_mod
argument_list|,
name|SI_SUB_OFED_PREINIT
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

