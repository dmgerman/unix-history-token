begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.  * Copyright (c) 2005 Sun Microsystems, Inc. All rights reserved.  * Copyright (c) 2005, 2006, 2007, 2008, 2014 Mellanox Technologies. All rights reserved.  * Copyright (c) 2006, 2007 Cisco Systems, Inc. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<linux/kmod.h>
end_include

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/errno.h>
end_include

begin_include
include|#
directive|include
file|<linux/pci.h>
end_include

begin_include
include|#
directive|include
file|<linux/dma-mapping.h>
end_include

begin_include
include|#
directive|include
file|<linux/slab.h>
end_include

begin_include
include|#
directive|include
file|<linux/io-mapping.h>
end_include

begin_include
include|#
directive|include
file|<linux/delay.h>
end_include

begin_include
include|#
directive|include
file|<linux/netdevice.h>
end_include

begin_include
include|#
directive|include
file|<linux/string.h>
end_include

begin_include
include|#
directive|include
file|<linux/fs.h>
end_include

begin_include
include|#
directive|include
file|<linux/mlx4/device.h>
end_include

begin_include
include|#
directive|include
file|<linux/mlx4/doorbell.h>
end_include

begin_include
include|#
directive|include
file|"mlx4.h"
end_include

begin_include
include|#
directive|include
file|"fw.h"
end_include

begin_include
include|#
directive|include
file|"icm.h"
end_include

begin_include
include|#
directive|include
file|"mlx4_stats.h"
end_include

begin_expr_stmt
name|MODULE_AUTHOR
argument_list|(
literal|"Roland Dreier"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DESCRIPTION
argument_list|(
literal|"Mellanox ConnectX HCA low-level driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_LICENSE
argument_list|(
literal|"Dual BSD/GPL"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|workqueue_struct
modifier|*
name|mlx4_wq
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_MLX4_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|mlx4_debug_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|debug_level
argument_list|,
name|mlx4_debug_level
argument_list|,
name|int
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|debug_level
argument_list|,
literal|"Enable debug tracing if> 0"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_MLX4_DEBUG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_PCI_MSI
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|msi_x
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param
argument_list|(
name|msi_x
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|msi_x
argument_list|,
literal|"0 - don't use MSI-X, 1 - use MSI-X,>1 - limit number of MSI-X irqs to msi_x (non-SRIOV only)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* CONFIG_PCI_MSI */
end_comment

begin_define
define|#
directive|define
name|msi_x
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_PCI_MSI */
end_comment

begin_decl_stmt
specifier|static
name|int
name|enable_sys_tune
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param
argument_list|(
name|enable_sys_tune
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|enable_sys_tune
argument_list|,
literal|"Tune the cpu's for better performance (default 0)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|mlx4_blck_lb
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|block_loopback
argument_list|,
name|mlx4_blck_lb
argument_list|,
name|int
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|block_loopback
argument_list|,
literal|"Block multicast loopback packets if> 0 "
literal|"(default: 1)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
block|{
name|DEFAULT_DOMAIN
init|=
literal|0
block|,
name|BDF_STR_SIZE
init|=
literal|8
block|,
comment|/* bb:dd.f- */
name|DBDF_STR_SIZE
init|=
literal|13
comment|/* mmmm:bb:dd.f- */
block|}
enum|;
end_enum

begin_enum
enum|enum
block|{
name|NUM_VFS
block|,
name|PROBE_VF
block|,
name|PORT_TYPE_ARRAY
block|}
enum|;
end_enum

begin_enum
enum|enum
block|{
name|VALID_DATA
block|,
name|INVALID_DATA
block|,
name|INVALID_STR
block|}
enum|;
end_enum

begin_struct
struct|struct
name|param_data
block|{
name|int
name|id
decl_stmt|;
name|struct
name|mlx4_dbdf2val_lst
name|dbdf2val
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|param_data
name|num_vfs
init|=
block|{
operator|.
name|id
operator|=
name|NUM_VFS
block|,
operator|.
name|dbdf2val
operator|=
block|{
operator|.
name|name
operator|=
literal|"num_vfs param"
block|,
operator|.
name|num_vals
operator|=
literal|1
block|,
operator|.
name|def_val
operator|=
block|{
literal|0
block|}
block|,
operator|.
name|range
operator|=
block|{
literal|0
block|,
name|MLX4_MAX_NUM_VF
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_string
argument_list|(
name|num_vfs
argument_list|,
name|num_vfs
operator|.
name|dbdf2val
operator|.
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|num_vfs
operator|.
name|dbdf2val
operator|.
name|str
argument_list|)
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|num_vfs
argument_list|,
literal|"Either single value (e.g. '5') to define uniform num_vfs value for all devices functions\n"
literal|"\t\tor a string to map device function numbers to their num_vfs values (e.g. '0000:04:00.0-5,002b:1c:0b.a-15').\n"
literal|"\t\tHexadecimal digits for the device function (e.g. 002b:1c:0b.a) and decimal for num_vfs value (e.g. 15)."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|param_data
name|probe_vf
init|=
block|{
operator|.
name|id
operator|=
name|PROBE_VF
block|,
operator|.
name|dbdf2val
operator|=
block|{
operator|.
name|name
operator|=
literal|"probe_vf param"
block|,
operator|.
name|num_vals
operator|=
literal|1
block|,
operator|.
name|def_val
operator|=
block|{
literal|0
block|}
block|,
operator|.
name|range
operator|=
block|{
literal|0
block|,
name|MLX4_MAX_NUM_VF
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_string
argument_list|(
name|probe_vf
argument_list|,
name|probe_vf
operator|.
name|dbdf2val
operator|.
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|probe_vf
operator|.
name|dbdf2val
operator|.
name|str
argument_list|)
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|probe_vf
argument_list|,
literal|"Either single value (e.g. '3') to define uniform number of VFs to probe by the pf driver for all devices functions\n"
literal|"\t\tor a string to map device function numbers to their probe_vf values (e.g. '0000:04:00.0-3,002b:1c:0b.a-13').\n"
literal|"\t\tHexadecimal digits for the device function (e.g. 002b:1c:0b.a) and decimal for probe_vf value (e.g. 13)."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|mlx4_log_num_mgm_entry_size
init|=
name|MLX4_DEFAULT_MGM_LOG_ENTRY_SIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_mgm_entry_size
argument_list|,
name|mlx4_log_num_mgm_entry_size
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_mgm_entry_size
argument_list|,
literal|"log mgm size, that defines the num"
literal|" of qp per mcg, for example:"
literal|" 10 gives 248.range: 7<="
literal|" log_num_mgm_entry_size<= 12."
literal|" To activate device managed"
literal|" flow steering when available, set to -1"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|high_rate_steer
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param
argument_list|(
name|high_rate_steer
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|high_rate_steer
argument_list|,
literal|"Enable steering mode for higher packet rate"
literal|" (default off)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|fast_drop
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|fast_drop
argument_list|,
name|fast_drop
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|fast_drop
argument_list|,
literal|"Enable fast packet drop when no recieve WQEs are posted"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|mlx4_enable_64b_cqe_eqe
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|enable_64b_cqe_eqe
argument_list|,
name|mlx4_enable_64b_cqe_eqe
argument_list|,
name|int
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|enable_64b_cqe_eqe
argument_list|,
literal|"Enable 64 byte CQEs/EQEs when the the FW supports this if non-zero (default: 1)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|HCA_GLOBAL_CAP_MASK
value|0
end_define

begin_define
define|#
directive|define
name|PF_CONTEXT_BEHAVIOUR_MASK
value|MLX4_FUNC_CAP_64B_EQE_CQE
end_define

begin_decl_stmt
specifier|static
name|char
name|mlx4_version
index|[]
name|__devinitdata
init|=
name|DRV_NAME
literal|": Mellanox ConnectX core driver v"
name|DRV_VERSION
literal|" ("
name|DRV_RELDATE
literal|")\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|log_num_mac
init|=
literal|7
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_mac
argument_list|,
name|log_num_mac
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_mac
argument_list|,
literal|"Log2 max number of MACs per ETH port (1-7)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|log_num_vlan
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_vlan
argument_list|,
name|log_num_vlan
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_vlan
argument_list|,
literal|"(Obsolete) Log2 max number of VLANs per ETH port (0-7)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Log2 max number of VLANs per ETH port (0-7) */
end_comment

begin_define
define|#
directive|define
name|MLX4_LOG_NUM_VLANS
value|7
end_define

begin_decl_stmt
name|int
name|log_mtts_per_seg
init|=
name|ilog2
argument_list|(
literal|1
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_mtts_per_seg
argument_list|,
name|log_mtts_per_seg
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_mtts_per_seg
argument_list|,
literal|"Log2 number of MTT entries per segment "
literal|"(0-7) (default: 0)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|param_data
name|port_type_array
init|=
block|{
operator|.
name|id
operator|=
name|PORT_TYPE_ARRAY
block|,
operator|.
name|dbdf2val
operator|=
block|{
operator|.
name|name
operator|=
literal|"port_type_array param"
block|,
operator|.
name|num_vals
operator|=
literal|2
block|,
operator|.
name|def_val
operator|=
block|{
name|MLX4_PORT_TYPE_ETH
block|,
name|MLX4_PORT_TYPE_ETH
block|}
block|,
operator|.
name|range
operator|=
block|{
name|MLX4_PORT_TYPE_IB
block|,
name|MLX4_PORT_TYPE_NA
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_string
argument_list|(
name|port_type_array
argument_list|,
name|port_type_array
operator|.
name|dbdf2val
operator|.
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|port_type_array
operator|.
name|dbdf2val
operator|.
name|str
argument_list|)
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|port_type_array
argument_list|,
literal|"Either pair of values (e.g. '1,2') to define uniform port1/port2 types configuration for all devices functions\n"
literal|"\t\tor a string to map device function numbers to their pair of port types values (e.g. '0000:04:00.0-1;2,002b:1c:0b.a-1;1').\n"
literal|"\t\tValid port types: 1-ib, 2-eth, 3-auto, 4-N/A\n"
literal|"\t\tIn case that only one port is available use the N/A port type for port2 (e.g '1,4')."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|mlx4_port_config
block|{
name|struct
name|list_head
name|list
decl_stmt|;
name|enum
name|mlx4_port_type
name|port_type
index|[
name|MLX4_MAX_PORTS
operator|+
literal|1
index|]
decl_stmt|;
name|struct
name|pci_dev
modifier|*
name|pdev
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MLX4_LOG_NUM_MTT
value|20
end_define

begin_comment
comment|/* We limit to 30 as of a bit map issue which uses int and not uint.      see mlx4_buddy_init -> bitmap_zero which gets int. */
end_comment

begin_define
define|#
directive|define
name|MLX4_MAX_LOG_NUM_MTT
value|30
end_define

begin_decl_stmt
specifier|static
name|struct
name|mlx4_profile
name|mod_param_profile
init|=
block|{
operator|.
name|num_qp
operator|=
literal|19
block|,
operator|.
name|num_srq
operator|=
literal|16
block|,
operator|.
name|rdmarc_per_qp
operator|=
literal|4
block|,
operator|.
name|num_cq
operator|=
literal|16
block|,
operator|.
name|num_mcg
operator|=
literal|13
block|,
operator|.
name|num_mpt
operator|=
literal|19
block|,
operator|.
name|num_mtt_segs
operator|=
literal|0
block|,
comment|/* max(20, 2*MTTs for host memory)) */
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_qp
argument_list|,
name|mod_param_profile
operator|.
name|num_qp
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_qp
argument_list|,
literal|"log maximum number of QPs per HCA (default: 19)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_srq
argument_list|,
name|mod_param_profile
operator|.
name|num_srq
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_srq
argument_list|,
literal|"log maximum number of SRQs per HCA "
literal|"(default: 16)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_rdmarc_per_qp
argument_list|,
name|mod_param_profile
operator|.
name|rdmarc_per_qp
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_rdmarc_per_qp
argument_list|,
literal|"log number of RDMARC buffers per QP "
literal|"(default: 4)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_cq
argument_list|,
name|mod_param_profile
operator|.
name|num_cq
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_cq
argument_list|,
literal|"log maximum number of CQs per HCA (default: 16)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_mcg
argument_list|,
name|mod_param_profile
operator|.
name|num_mcg
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_mcg
argument_list|,
literal|"log maximum number of multicast groups per HCA "
literal|"(default: 13)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_mpt
argument_list|,
name|mod_param_profile
operator|.
name|num_mpt
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_mpt
argument_list|,
literal|"log maximum number of memory protection table entries per "
literal|"HCA (default: 19)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_num_mtt
argument_list|,
name|mod_param_profile
operator|.
name|num_mtt_segs
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_num_mtt
argument_list|,
literal|"log maximum number of memory translation table segments per "
literal|"HCA (default: max(20, 2*MTTs for register all of the host memory limited to 30))"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
block|{
name|MLX4_IF_STATE_BASIC
block|,
name|MLX4_IF_STATE_EXTENDED
block|}
enum|;
end_enum

begin_function
specifier|static
specifier|inline
name|u64
name|dbdf_to_u64
parameter_list|(
name|int
name|domain
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|fn
parameter_list|)
block|{
return|return
operator|(
name|domain
operator|<<
literal|20
operator|)
operator||
operator|(
name|bus
operator|<<
literal|12
operator|)
operator||
operator|(
name|dev
operator|<<
literal|4
operator|)
operator||
name|fn
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|pr_bdf_err
parameter_list|(
specifier|const
name|char
modifier|*
name|dbdf
parameter_list|,
specifier|const
name|char
modifier|*
name|pname
parameter_list|)
block|{
name|pr_warn
argument_list|(
literal|"mlx4_core: '%s' is not valid bdf in '%s'\n"
argument_list|,
name|dbdf
argument_list|,
name|pname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|pr_val_err
parameter_list|(
specifier|const
name|char
modifier|*
name|dbdf
parameter_list|,
specifier|const
name|char
modifier|*
name|pname
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
name|pr_warn
argument_list|(
literal|"mlx4_core: value '%s' of bdf '%s' in '%s' is not valid\n"
argument_list|,
name|val
argument_list|,
name|dbdf
argument_list|,
name|pname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|pr_out_of_range_bdf
parameter_list|(
specifier|const
name|char
modifier|*
name|dbdf
parameter_list|,
name|int
name|val
parameter_list|,
name|struct
name|mlx4_dbdf2val_lst
modifier|*
name|dbdf2val
parameter_list|)
block|{
name|pr_warn
argument_list|(
literal|"mlx4_core: value %d in bdf '%s' of '%s' is out of its valid range (%d,%d)\n"
argument_list|,
name|val
argument_list|,
name|dbdf
argument_list|,
name|dbdf2val
operator|->
name|name
argument_list|,
name|dbdf2val
operator|->
name|range
operator|.
name|min
argument_list|,
name|dbdf2val
operator|->
name|range
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|pr_out_of_range
parameter_list|(
name|struct
name|mlx4_dbdf2val_lst
modifier|*
name|dbdf2val
parameter_list|)
block|{
name|pr_warn
argument_list|(
literal|"mlx4_core: value of '%s' is out of its valid range (%d,%d)\n"
argument_list|,
name|dbdf2val
operator|->
name|name
argument_list|,
name|dbdf2val
operator|->
name|range
operator|.
name|min
argument_list|,
name|dbdf2val
operator|->
name|range
operator|.
name|max
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|is_in_range
parameter_list|(
name|int
name|val
parameter_list|,
name|struct
name|mlx4_range
modifier|*
name|r
parameter_list|)
block|{
return|return
operator|(
name|val
operator|>=
name|r
operator|->
name|min
operator|&&
name|val
operator|<=
name|r
operator|->
name|max
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|update_defaults
parameter_list|(
name|struct
name|param_data
modifier|*
name|pdata
parameter_list|)
block|{
name|long
name|int
name|val
index|[
name|MLX4_MAX_BDF_VALS
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|p
init|=
name|pdata
operator|->
name|dbdf2val
operator|.
name|str
decl_stmt|;
name|char
name|sval
index|[
literal|32
index|]
decl_stmt|;
name|int
name|val_len
decl_stmt|;
if|if
condition|(
operator|!
name|strlen
argument_list|(
name|p
argument_list|)
operator|||
name|strchr
argument_list|(
name|p
argument_list|,
literal|':'
argument_list|)
operator|||
name|strchr
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
operator|||
name|strchr
argument_list|(
name|p
argument_list|,
literal|';'
argument_list|)
condition|)
return|return
name|INVALID_STR
return|;
switch|switch
condition|(
name|pdata
operator|->
name|id
condition|)
block|{
case|case
name|PORT_TYPE_ARRAY
case|:
name|t
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t
operator|||
name|t
operator|==
name|p
operator|||
operator|(
name|t
operator|-
name|p
operator|)
operator|>
sizeof|sizeof
argument_list|(
name|sval
argument_list|)
condition|)
return|return
name|INVALID_STR
return|;
name|val_len
operator|=
name|t
operator|-
name|p
expr_stmt|;
name|strncpy
argument_list|(
name|sval
argument_list|,
name|p
argument_list|,
name|val_len
argument_list|)
expr_stmt|;
name|sval
index|[
name|val_len
index|]
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|kstrtol
argument_list|(
name|sval
argument_list|,
literal|0
argument_list|,
operator|&
name|val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
name|EINVAL
condition|)
return|return
name|INVALID_STR
return|;
if|if
condition|(
name|ret
operator|||
operator|!
name|is_in_range
argument_list|(
name|val
index|[
literal|0
index|]
argument_list|,
operator|&
name|pdata
operator|->
name|dbdf2val
operator|.
name|range
argument_list|)
condition|)
block|{
name|pr_out_of_range
argument_list|(
operator|&
name|pdata
operator|->
name|dbdf2val
argument_list|)
expr_stmt|;
return|return
name|INVALID_DATA
return|;
block|}
name|ret
operator|=
name|kstrtol
argument_list|(
name|t
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
operator|&
name|val
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
name|EINVAL
condition|)
return|return
name|INVALID_STR
return|;
if|if
condition|(
name|ret
operator|||
operator|!
name|is_in_range
argument_list|(
name|val
index|[
literal|1
index|]
argument_list|,
operator|&
name|pdata
operator|->
name|dbdf2val
operator|.
name|range
argument_list|)
condition|)
block|{
name|pr_out_of_range
argument_list|(
operator|&
name|pdata
operator|->
name|dbdf2val
argument_list|)
expr_stmt|;
return|return
name|INVALID_DATA
return|;
block|}
name|pdata
operator|->
name|dbdf2val
operator|.
name|tbl
index|[
literal|0
index|]
operator|.
name|val
index|[
literal|0
index|]
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
name|pdata
operator|->
name|dbdf2val
operator|.
name|tbl
index|[
literal|0
index|]
operator|.
name|val
index|[
literal|1
index|]
operator|=
name|val
index|[
literal|1
index|]
expr_stmt|;
break|break;
case|case
name|NUM_VFS
case|:
case|case
name|PROBE_VF
case|:
name|ret
operator|=
name|kstrtol
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
operator|&
name|val
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
name|EINVAL
condition|)
return|return
name|INVALID_STR
return|;
if|if
condition|(
name|ret
operator|||
operator|!
name|is_in_range
argument_list|(
name|val
index|[
literal|0
index|]
argument_list|,
operator|&
name|pdata
operator|->
name|dbdf2val
operator|.
name|range
argument_list|)
condition|)
block|{
name|pr_out_of_range
argument_list|(
operator|&
name|pdata
operator|->
name|dbdf2val
argument_list|)
expr_stmt|;
return|return
name|INVALID_DATA
return|;
block|}
name|pdata
operator|->
name|dbdf2val
operator|.
name|tbl
index|[
literal|0
index|]
operator|.
name|val
index|[
literal|0
index|]
operator|=
name|val
index|[
literal|0
index|]
expr_stmt|;
break|break;
block|}
name|pdata
operator|->
name|dbdf2val
operator|.
name|tbl
index|[
literal|1
index|]
operator|.
name|dbdf
operator|=
name|MLX4_ENDOF_TBL
expr_stmt|;
return|return
name|VALID_DATA
return|;
block|}
end_function

begin_function
name|int
name|mlx4_fill_dbdf2val_tbl
parameter_list|(
name|struct
name|mlx4_dbdf2val_lst
modifier|*
name|dbdf2val_lst
parameter_list|)
block|{
name|int
name|domain
decl_stmt|,
name|bus
decl_stmt|,
name|dev
decl_stmt|,
name|fn
decl_stmt|;
name|u64
name|dbdf
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|,
modifier|*
name|v
decl_stmt|;
name|char
name|tmp
index|[
literal|32
index|]
decl_stmt|;
name|char
name|sbdf
index|[
literal|32
index|]
decl_stmt|;
name|char
name|sep
init|=
literal|','
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|,
name|str_size
decl_stmt|,
name|i
init|=
literal|1
decl_stmt|;
name|int
name|prfx_size
decl_stmt|;
name|p
operator|=
name|dbdf2val_lst
operator|->
name|str
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dbdf2val_lst
operator|->
name|num_vals
condition|;
name|j
operator|++
control|)
name|dbdf2val_lst
operator|->
name|tbl
index|[
literal|0
index|]
operator|.
name|val
index|[
name|j
index|]
operator|=
name|dbdf2val_lst
operator|->
name|def_val
index|[
name|j
index|]
expr_stmt|;
name|dbdf2val_lst
operator|->
name|tbl
index|[
literal|1
index|]
operator|.
name|dbdf
operator|=
name|MLX4_ENDOF_TBL
expr_stmt|;
name|str_size
operator|=
name|strlen
argument_list|(
name|dbdf2val_lst
operator|->
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str_size
operator|==
literal|0
condition|)
return|return
literal|0
return|;
while|while
condition|(
name|strlen
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|prfx_size
operator|=
name|BDF_STR_SIZE
expr_stmt|;
name|sbdf
index|[
name|prfx_size
index|]
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|sbdf
argument_list|,
name|p
argument_list|,
name|prfx_size
argument_list|)
expr_stmt|;
name|domain
operator|=
name|DEFAULT_DOMAIN
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|sbdf
argument_list|,
literal|"%02x:%02x.%x-"
argument_list|,
operator|&
name|bus
argument_list|,
operator|&
name|dev
argument_list|,
operator|&
name|fn
argument_list|)
operator|!=
literal|3
condition|)
block|{
name|prfx_size
operator|=
name|DBDF_STR_SIZE
expr_stmt|;
name|sbdf
index|[
name|prfx_size
index|]
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|sbdf
argument_list|,
name|p
argument_list|,
name|prfx_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
name|sbdf
argument_list|,
literal|"%04x:%02x:%02x.%x-"
argument_list|,
operator|&
name|domain
argument_list|,
operator|&
name|bus
argument_list|,
operator|&
name|dev
argument_list|,
operator|&
name|fn
argument_list|)
operator|!=
literal|4
condition|)
block|{
name|pr_bdf_err
argument_list|(
name|sbdf
argument_list|,
name|dbdf2val_lst
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%04x:%02x:%02x.%x-"
argument_list|,
name|domain
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"%02x:%02x.%x-"
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strnicmp
argument_list|(
name|sbdf
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
condition|)
block|{
name|pr_bdf_err
argument_list|(
name|sbdf
argument_list|,
name|dbdf2val_lst
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|dbdf
operator|=
name|dbdf_to_u64
argument_list|(
name|domain
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|fn
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|dbdf2val_lst
operator|->
name|tbl
index|[
name|j
index|]
operator|.
name|dbdf
operator|==
name|dbdf
condition|)
block|{
name|pr_warn
argument_list|(
literal|"mlx4_core: in '%s', %s appears multiple times\n"
argument_list|,
name|dbdf2val_lst
operator|->
name|name
argument_list|,
name|sbdf
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|i
operator|>=
name|MLX4_DEVS_TBL_SIZE
condition|)
block|{
name|pr_warn
argument_list|(
literal|"mlx4_core: Too many devices in '%s'\n"
argument_list|,
name|dbdf2val_lst
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|p
operator|+=
name|prfx_size
expr_stmt|;
name|t
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|t
operator|=
name|t
condition|?
name|t
else|:
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|t
condition|)
block|{
name|pr_val_err
argument_list|(
name|sbdf
argument_list|,
name|dbdf2val_lst
operator|->
name|name
argument_list|,
literal|""
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|dbdf2val_lst
operator|->
name|num_vals
condition|;
name|k
operator|++
control|)
block|{
name|char
name|sval
index|[
literal|32
index|]
decl_stmt|;
name|long
name|int
name|val
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|val_len
decl_stmt|;
name|char
name|vsep
init|=
literal|';'
decl_stmt|;
name|v
operator|=
operator|(
name|k
operator|==
name|dbdf2val_lst
operator|->
name|num_vals
operator|-
literal|1
operator|)
condition|?
name|t
else|:
name|strchr
argument_list|(
name|p
argument_list|,
name|vsep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|v
operator|||
name|v
operator|>
name|t
operator|||
name|v
operator|==
name|p
operator|||
operator|(
name|v
operator|-
name|p
operator|)
operator|>
sizeof|sizeof
argument_list|(
name|sval
argument_list|)
condition|)
block|{
name|pr_val_err
argument_list|(
name|sbdf
argument_list|,
name|dbdf2val_lst
operator|->
name|name
argument_list|,
name|p
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|val_len
operator|=
name|v
operator|-
name|p
expr_stmt|;
name|strncpy
argument_list|(
name|sval
argument_list|,
name|p
argument_list|,
name|val_len
argument_list|)
expr_stmt|;
name|sval
index|[
name|val_len
index|]
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|kstrtol
argument_list|(
name|sval
argument_list|,
literal|0
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
name|p
argument_list|,
name|vsep
argument_list|)
condition|)
name|pr_warn
argument_list|(
literal|"mlx4_core: too many vals in bdf '%s' of '%s'\n"
argument_list|,
name|sbdf
argument_list|,
name|dbdf2val_lst
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|pr_val_err
argument_list|(
name|sbdf
argument_list|,
name|dbdf2val_lst
operator|->
name|name
argument_list|,
name|sval
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|is_in_range
argument_list|(
name|val
argument_list|,
operator|&
name|dbdf2val_lst
operator|->
name|range
argument_list|)
condition|)
block|{
name|pr_out_of_range_bdf
argument_list|(
name|sbdf
argument_list|,
name|val
argument_list|,
name|dbdf2val_lst
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|dbdf2val_lst
operator|->
name|tbl
index|[
name|i
index|]
operator|.
name|val
index|[
name|k
index|]
operator|=
name|val
expr_stmt|;
name|p
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
name|vsep
condition|)
name|p
operator|++
expr_stmt|;
block|}
name|dbdf2val_lst
operator|->
name|tbl
index|[
name|i
index|]
operator|.
name|dbdf
operator|=
name|dbdf
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|p
argument_list|)
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
name|sep
condition|)
block|{
name|pr_warn
argument_list|(
literal|"mlx4_core: expect separator '%c' before '%s' in '%s'\n"
argument_list|,
name|sep
argument_list|,
name|p
argument_list|,
name|dbdf2val_lst
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|p
operator|++
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|MLX4_DEVS_TBL_SIZE
condition|)
name|dbdf2val_lst
operator|->
name|tbl
index|[
name|i
index|]
operator|.
name|dbdf
operator|=
name|MLX4_ENDOF_TBL
expr_stmt|;
block|}
return|return
literal|0
return|;
name|err
label|:
name|dbdf2val_lst
operator|->
name|tbl
index|[
literal|1
index|]
operator|.
name|dbdf
operator|=
name|MLX4_ENDOF_TBL
expr_stmt|;
name|pr_warn
argument_list|(
literal|"mlx4_core: The value of '%s' is incorrect. The value is discarded!\n"
argument_list|,
name|dbdf2val_lst
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|mlx4_fill_dbdf2val_tbl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_get_val
parameter_list|(
name|struct
name|mlx4_dbdf2val
modifier|*
name|tbl
parameter_list|,
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|int
name|idx
parameter_list|,
name|int
modifier|*
name|val
parameter_list|)
block|{
name|u64
name|dbdf
decl_stmt|;
name|int
name|i
init|=
literal|1
decl_stmt|;
operator|*
name|val
operator|=
name|tbl
index|[
literal|0
index|]
operator|.
name|val
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|pdev
condition|)
return|return
operator|-
name|EINVAL
return|;
name|dbdf
operator|=
name|dbdf_to_u64
argument_list|(
name|pci_get_domain
argument_list|(
name|pdev
operator|->
name|dev
operator|.
name|bsddev
argument_list|)
argument_list|,
name|pci_get_bus
argument_list|(
name|pdev
operator|->
name|dev
operator|.
name|bsddev
argument_list|)
argument_list|,
name|PCI_SLOT
argument_list|(
name|pdev
operator|->
name|devfn
argument_list|)
argument_list|,
name|PCI_FUNC
argument_list|(
name|pdev
operator|->
name|devfn
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|<
name|MLX4_DEVS_TBL_SIZE
operator|)
operator|&&
operator|(
name|tbl
index|[
name|i
index|]
operator|.
name|dbdf
operator|!=
name|MLX4_ENDOF_TBL
operator|)
condition|)
block|{
if|if
condition|(
name|tbl
index|[
name|i
index|]
operator|.
name|dbdf
operator|==
name|dbdf
condition|)
block|{
operator|*
name|val
operator|=
name|tbl
index|[
name|i
index|]
operator|.
name|val
index|[
name|idx
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
name|i
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|mlx4_get_val
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|process_mod_param_profile
parameter_list|(
name|struct
name|mlx4_profile
modifier|*
name|profile
parameter_list|)
block|{
name|vm_size_t
name|hwphyssz
decl_stmt|;
name|hwphyssz
operator|=
literal|0
expr_stmt|;
name|TUNABLE_ULONG_FETCH
argument_list|(
literal|"hw.realmem"
argument_list|,
operator|(
name|u_long
operator|*
operator|)
operator|&
name|hwphyssz
argument_list|)
expr_stmt|;
name|profile
operator|->
name|num_qp
operator|=
literal|1
operator|<<
name|mod_param_profile
operator|.
name|num_qp
expr_stmt|;
name|profile
operator|->
name|num_srq
operator|=
literal|1
operator|<<
name|mod_param_profile
operator|.
name|num_srq
expr_stmt|;
name|profile
operator|->
name|rdmarc_per_qp
operator|=
literal|1
operator|<<
name|mod_param_profile
operator|.
name|rdmarc_per_qp
expr_stmt|;
name|profile
operator|->
name|num_cq
operator|=
literal|1
operator|<<
name|mod_param_profile
operator|.
name|num_cq
expr_stmt|;
name|profile
operator|->
name|num_mcg
operator|=
literal|1
operator|<<
name|mod_param_profile
operator|.
name|num_mcg
expr_stmt|;
name|profile
operator|->
name|num_mpt
operator|=
literal|1
operator|<<
name|mod_param_profile
operator|.
name|num_mpt
expr_stmt|;
comment|/* 	 * We want to scale the number of MTTs with the size of the 	 * system memory, since it makes sense to register a lot of 	 * memory on a system with a lot of memory.  As a heuristic, 	 * make sure we have enough MTTs to register twice the system 	 * memory (with PAGE_SIZE entries). 	 * 	 * This number has to be a power of two and fit into 32 bits 	 * due to device limitations. We cap this at 2^30 as of bit map 	 * limitation to work with int instead of uint (mlx4_buddy_init -> bitmap_zero) 	 * That limits us to 4TB of memory registration per HCA with 	 * 4KB pages, which is probably OK for the next few months. 	 */
if|if
condition|(
name|mod_param_profile
operator|.
name|num_mtt_segs
condition|)
name|profile
operator|->
name|num_mtt_segs
operator|=
literal|1
operator|<<
name|mod_param_profile
operator|.
name|num_mtt_segs
expr_stmt|;
else|else
block|{
name|profile
operator|->
name|num_mtt_segs
operator|=
name|roundup_pow_of_two
argument_list|(
name|max_t
argument_list|(
name|unsigned
argument_list|,
literal|1
operator|<<
operator|(
name|MLX4_LOG_NUM_MTT
operator|-
name|log_mtts_per_seg
operator|)
argument_list|,
name|min
argument_list|(
literal|1UL
operator|<<
operator|(
name|MLX4_MAX_LOG_NUM_MTT
operator|-
name|log_mtts_per_seg
operator|)
argument_list|,
operator|(
name|hwphyssz
operator|<<
literal|1
operator|)
operator|>>
name|log_mtts_per_seg
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set the actual value, so it will be reflected to the user 		   using the sysfs */
name|mod_param_profile
operator|.
name|num_mtt_segs
operator|=
name|ilog2
argument_list|(
name|profile
operator|->
name|num_mtt_segs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|mlx4_check_port_params
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|enum
name|mlx4_port_type
modifier|*
name|port_type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|port_type
index|[
name|i
index|]
operator|!=
name|port_type
index|[
name|i
operator|+
literal|1
index|]
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_DPDP
operator|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Only same port types supported "
literal|"on this HCA, aborting.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|port_type
index|[
name|i
index|]
operator|&
name|dev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|i
operator|+
literal|1
index|]
operator|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Requested port type for port %d is not "
literal|"supported on this HCA\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_set_port_mask
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
operator|++
name|i
control|)
name|dev
operator|->
name|caps
operator|.
name|port_mask
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_dev_cap
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|err
operator|=
name|mlx4_QUERY_DEV_CAP
argument_list|(
name|dev
argument_list|,
name|dev_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_DEV_CAP command failed, aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|dev_cap
operator|->
name|min_page_sz
operator|>
name|PAGE_SIZE
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"HCA minimum page size of %d bigger than "
literal|"kernel PAGE_SIZE of %d, aborting.\n"
argument_list|,
name|dev_cap
operator|->
name|min_page_sz
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
if|if
condition|(
name|dev_cap
operator|->
name|num_ports
operator|>
name|MLX4_MAX_PORTS
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"HCA has %d ports, but we only support %d, "
literal|"aborting.\n"
argument_list|,
name|dev_cap
operator|->
name|num_ports
argument_list|,
name|MLX4_MAX_PORTS
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
if|if
condition|(
name|dev_cap
operator|->
name|uar_size
operator|>
name|pci_resource_len
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"HCA reported UAR size of 0x%x bigger than "
literal|"PCI resource 2 size of 0x%llx, aborting.\n"
argument_list|,
name|dev_cap
operator|->
name|uar_size
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|pci_resource_len
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
name|dev
operator|->
name|caps
operator|.
name|num_ports
operator|=
name|dev_cap
operator|->
name|num_ports
expr_stmt|;
name|dev
operator|->
name|phys_caps
operator|.
name|num_phys_eqs
operator|=
name|MLX4_MAX_EQ_NUM
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
operator|++
name|i
control|)
block|{
name|dev
operator|->
name|caps
operator|.
name|vl_cap
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|max_vl
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|ib_mtu_cap
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|ib_mtu
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|phys_caps
operator|.
name|gid_phys_table_len
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|max_gids
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|phys_caps
operator|.
name|pkey_phys_table_len
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|max_pkeys
index|[
name|i
index|]
expr_stmt|;
comment|/* set gid and pkey table operating lengths by default 		 * to non-sriov values */
name|dev
operator|->
name|caps
operator|.
name|gid_table_len
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|max_gids
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|pkey_table_len
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|max_pkeys
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|port_width_cap
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|max_port_width
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|eth_mtu_cap
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|eth_mtu
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|def_mac
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|def_mac
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|supported_port_types
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|suggested_type
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|suggested_type
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|default_sense
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|default_sense
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|trans_type
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|trans_type
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|vendor_oui
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|vendor_oui
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|wavelength
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|wavelength
index|[
name|i
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|trans_code
index|[
name|i
index|]
operator|=
name|dev_cap
operator|->
name|trans_code
index|[
name|i
index|]
expr_stmt|;
block|}
name|dev
operator|->
name|caps
operator|.
name|uar_page_size
operator|=
name|PAGE_SIZE
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_uars
operator|=
name|dev_cap
operator|->
name|uar_size
operator|/
name|PAGE_SIZE
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|local_ca_ack_delay
operator|=
name|dev_cap
operator|->
name|local_ca_ack_delay
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|bf_reg_size
operator|=
name|dev_cap
operator|->
name|bf_reg_size
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|bf_regs_per_page
operator|=
name|dev_cap
operator|->
name|bf_regs_per_page
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_sq_sg
operator|=
name|dev_cap
operator|->
name|max_sq_sg
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_rq_sg
operator|=
name|dev_cap
operator|->
name|max_rq_sg
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_wqes
operator|=
name|dev_cap
operator|->
name|max_qp_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_qp_init_rdma
operator|=
name|dev_cap
operator|->
name|max_requester_per_qp
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_srq_wqes
operator|=
name|dev_cap
operator|->
name|max_srq_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_srq_sge
operator|=
name|dev_cap
operator|->
name|max_rq_sg
operator|-
literal|1
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_srqs
operator|=
name|dev_cap
operator|->
name|reserved_srqs
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_sq_desc_sz
operator|=
name|dev_cap
operator|->
name|max_sq_desc_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_rq_desc_sz
operator|=
name|dev_cap
operator|->
name|max_rq_desc_sz
expr_stmt|;
comment|/* 	 * Subtract 1 from the limit because we need to allocate a 	 * spare CQE to enable resizing the CQ 	 */
name|dev
operator|->
name|caps
operator|.
name|max_cqes
operator|=
name|dev_cap
operator|->
name|max_cq_sz
operator|-
literal|1
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_cqs
operator|=
name|dev_cap
operator|->
name|reserved_cqs
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_eqs
operator|=
name|dev_cap
operator|->
name|reserved_eqs
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_mtts
operator|=
name|dev_cap
operator|->
name|reserved_mtts
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_mrws
operator|=
name|dev_cap
operator|->
name|reserved_mrws
expr_stmt|;
comment|/* The first 128 UARs are used for EQ doorbells */
name|dev
operator|->
name|caps
operator|.
name|reserved_uars
operator|=
name|max_t
argument_list|(
name|int
argument_list|,
literal|128
argument_list|,
name|dev_cap
operator|->
name|reserved_uars
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_pds
operator|=
name|dev_cap
operator|->
name|reserved_pds
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_xrcds
operator|=
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_XRC
operator|)
condition|?
name|dev_cap
operator|->
name|reserved_xrcds
else|:
literal|0
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_xrcds
operator|=
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_XRC
operator|)
condition|?
name|dev_cap
operator|->
name|max_xrcds
else|:
literal|0
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|mtt_entry_sz
operator|=
name|dev_cap
operator|->
name|mtt_entry_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_msg_sz
operator|=
name|dev_cap
operator|->
name|max_msg_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|page_size_cap
operator|=
operator|~
call|(
name|u32
call|)
argument_list|(
name|dev_cap
operator|->
name|min_page_sz
operator|-
literal|1
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|flags
operator|=
name|dev_cap
operator|->
name|flags
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|=
name|dev_cap
operator|->
name|flags2
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|bmme_flags
operator|=
name|dev_cap
operator|->
name|bmme_flags
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_lkey
operator|=
name|dev_cap
operator|->
name|reserved_lkey
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|stat_rate_support
operator|=
name|dev_cap
operator|->
name|stat_rate_support
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|cq_timestamp
operator|=
name|dev_cap
operator|->
name|timestamp_support
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_gso_sz
operator|=
name|dev_cap
operator|->
name|max_gso_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_rss_tbl_sz
operator|=
name|dev_cap
operator|->
name|max_rss_tbl_sz
expr_stmt|;
comment|/* Sense port always allowed on supported devices for ConnectX-1 and -2 */
if|if
condition|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|pci_dev_data
operator|&
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
condition|)
name|dev
operator|->
name|caps
operator|.
name|flags
operator||=
name|MLX4_DEV_CAP_FLAG_SENSE_SUPPORT
expr_stmt|;
comment|/* Don't do sense port on multifunction devices (for now at least) */
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG_SENSE_SUPPORT
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|log_num_macs
operator|=
name|log_num_mac
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|log_num_vlans
operator|=
name|MLX4_LOG_NUM_VLANS
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|fast_drop
operator|=
name|fast_drop
condition|?
operator|!
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_FAST_DROP
operator|)
else|:
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
operator|++
name|i
control|)
block|{
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|=
name|MLX4_PORT_TYPE_NONE
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|i
index|]
condition|)
block|{
comment|/* if only ETH is supported - assign ETH */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|i
index|]
operator|==
name|MLX4_PORT_TYPE_ETH
condition|)
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|=
name|MLX4_PORT_TYPE_ETH
expr_stmt|;
comment|/* if only IB is supported, assign IB */
elseif|else
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|i
index|]
operator|==
name|MLX4_PORT_TYPE_IB
condition|)
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|=
name|MLX4_PORT_TYPE_IB
expr_stmt|;
else|else
block|{
comment|/* 				 * if IB and ETH are supported, we set the port 				 * type according to user selection of port type; 				 * if there is no user selection, take the FW hint 				 */
name|int
name|pta
decl_stmt|;
name|mlx4_get_val
argument_list|(
name|port_type_array
operator|.
name|dbdf2val
operator|.
name|tbl
argument_list|,
name|pci_physfn
argument_list|(
name|dev
operator|->
name|pdev
argument_list|)
argument_list|,
name|i
operator|-
literal|1
argument_list|,
operator|&
name|pta
argument_list|)
expr_stmt|;
if|if
condition|(
name|pta
operator|==
name|MLX4_PORT_TYPE_NONE
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|suggested_type
index|[
name|i
index|]
condition|?
name|MLX4_PORT_TYPE_ETH
else|:
name|MLX4_PORT_TYPE_IB
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pta
operator|==
name|MLX4_PORT_TYPE_NA
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Port %d is valid port. "
literal|"It is not allowed to configure its type to N/A(%d)\n"
argument_list|,
name|i
argument_list|,
name|MLX4_PORT_TYPE_NA
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
else|else
block|{
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|=
name|pta
expr_stmt|;
block|}
block|}
block|}
comment|/* 		 * Link sensing is allowed on the port if 3 conditions are true: 		 * 1. Both protocols are supported on the port. 		 * 2. Different types are supported on the port 		 * 3. FW declared that it supports link sensing 		 */
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|sense
operator|.
name|sense_allowed
index|[
name|i
index|]
operator|=
operator|(
operator|(
name|dev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|i
index|]
operator|==
name|MLX4_PORT_TYPE_AUTO
operator|)
operator|&&
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_DPDP
operator|)
operator|&&
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_SENSE_SUPPORT
operator|)
operator|)
expr_stmt|;
comment|/* Disablling auto sense for default Eth ports support */
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|sense
operator|.
name|sense_allowed
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If "default_sense" bit is set, we move the port to "AUTO" mode 		 * and perform sense_port FW command to try and set the correct 		 * port type from beginning 		 */
if|if
condition|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|sense
operator|.
name|sense_allowed
index|[
name|i
index|]
operator|&&
name|dev
operator|->
name|caps
operator|.
name|default_sense
index|[
name|i
index|]
condition|)
block|{
name|enum
name|mlx4_port_type
name|sensed_port
init|=
name|MLX4_PORT_TYPE_NONE
decl_stmt|;
name|dev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
index|]
operator|=
name|MLX4_PORT_TYPE_AUTO
expr_stmt|;
name|mlx4_SENSE_PORT
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
operator|&
name|sensed_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|sensed_port
operator|!=
name|MLX4_PORT_TYPE_NONE
condition|)
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|=
name|sensed_port
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|log_num_macs
operator|>
name|dev_cap
operator|->
name|log_max_macs
index|[
name|i
index|]
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|log_num_macs
operator|=
name|dev_cap
operator|->
name|log_max_macs
index|[
name|i
index|]
expr_stmt|;
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Requested number of MACs is too much "
literal|"for port %d, reducing to %d.\n"
argument_list|,
name|i
argument_list|,
literal|1
operator|<<
name|dev
operator|->
name|caps
operator|.
name|log_num_macs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|log_num_vlans
operator|>
name|dev_cap
operator|->
name|log_max_vlans
index|[
name|i
index|]
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|log_num_vlans
operator|=
name|dev_cap
operator|->
name|log_max_vlans
index|[
name|i
index|]
expr_stmt|;
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Requested number of VLANs is too much "
literal|"for port %d, reducing to %d.\n"
argument_list|,
name|i
argument_list|,
literal|1
operator|<<
name|dev
operator|->
name|caps
operator|.
name|log_num_vlans
argument_list|)
expr_stmt|;
block|}
block|}
name|dev
operator|->
name|caps
operator|.
name|max_basic_counters
operator|=
name|dev_cap
operator|->
name|max_basic_counters
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_extended_counters
operator|=
name|dev_cap
operator|->
name|max_extended_counters
expr_stmt|;
comment|/* support extended counters if available */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_COUNTERS_EXT
condition|)
name|dev
operator|->
name|caps
operator|.
name|max_counters
operator|=
name|dev
operator|->
name|caps
operator|.
name|max_extended_counters
expr_stmt|;
else|else
name|dev
operator|->
name|caps
operator|.
name|max_counters
operator|=
name|dev
operator|->
name|caps
operator|.
name|max_basic_counters
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
operator|=
name|dev_cap
operator|->
name|reserved_qps
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_ETH_ADDR
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FC_ADDR
index|]
operator|=
operator|(
literal|1
operator|<<
name|dev
operator|->
name|caps
operator|.
name|log_num_macs
operator|)
operator|*
operator|(
literal|1
operator|<<
name|dev
operator|->
name|caps
operator|.
name|log_num_vlans
operator|)
operator|*
name|dev
operator|->
name|caps
operator|.
name|num_ports
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FC_EXCH
index|]
operator|=
name|MLX4_NUM_FEXCH
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_qps
operator|=
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
operator|+
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_ETH_ADDR
index|]
operator|+
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FC_ADDR
index|]
operator|+
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FC_EXCH
index|]
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|sync_qp
operator|=
name|dev_cap
operator|->
name|sync_qp
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|pdev
operator|->
name|device
operator|==
literal|0x1003
condition|)
name|dev
operator|->
name|caps
operator|.
name|cq_flags
operator||=
name|MLX4_DEV_CAP_CQ_FLAG_IO
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|sqp_demux
operator|=
operator|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
operator|)
condition|?
name|MLX4_MAX_NUM_SLAVES
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_enable_64b_cqe_eqe
operator|&&
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|dev_cap
operator|->
name|flags
operator|&
operator|(
name|MLX4_DEV_CAP_FLAG_64B_CQE
operator||
name|MLX4_DEV_CAP_FLAG_64B_EQE
operator|)
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"64B EQEs/CQEs supported by the device but not enabled\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG_64B_CQE
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG_64B_EQE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
operator|(
name|MLX4_DEV_CAP_FLAG_64B_CQE
operator||
name|MLX4_DEV_CAP_FLAG_64B_EQE
operator|)
operator|)
operator|&&
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
name|dev
operator|->
name|caps
operator|.
name|function_caps
operator||=
name|MLX4_FUNC_CAP_64B_EQE_CQE
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
operator|++
name|i
control|)
name|dev
operator|->
name|caps
operator|.
name|def_counter_index
index|[
name|i
index|]
operator|=
name|i
operator|<<
literal|1
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*The function checks if there are live vf, return the num of them*/
end_comment

begin_function
specifier|static
name|int
name|mlx4_how_many_lives_vf
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_slave_state
modifier|*
name|s_state
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
comment|/*the ppf is 0*/
init|;
name|i
operator|<
name|dev
operator|->
name|num_slaves
condition|;
operator|++
name|i
control|)
block|{
name|s_state
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|s_state
operator|->
name|active
operator|&&
name|s_state
operator|->
name|last_cmd
operator|!=
name|MLX4_COMM_CMD_RESET
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"%s: slave: %d is still active\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ret
operator|++
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|mlx4_get_parav_qkey
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|qpn
parameter_list|,
name|u32
modifier|*
name|qkey
parameter_list|)
block|{
name|u32
name|qk
init|=
name|MLX4_RESERVED_QKEY_BASE
decl_stmt|;
if|if
condition|(
name|qpn
operator|>=
name|dev
operator|->
name|phys_caps
operator|.
name|base_tunnel_sqpn
operator|+
literal|8
operator|*
name|MLX4_MFUNC_MAX
operator|||
name|qpn
operator|<
name|dev
operator|->
name|phys_caps
operator|.
name|base_proxy_sqpn
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|qpn
operator|>=
name|dev
operator|->
name|phys_caps
operator|.
name|base_tunnel_sqpn
condition|)
comment|/* tunnel qp */
name|qk
operator|+=
name|qpn
operator|-
name|dev
operator|->
name|phys_caps
operator|.
name|base_tunnel_sqpn
expr_stmt|;
else|else
name|qk
operator|+=
name|qpn
operator|-
name|dev
operator|->
name|phys_caps
operator|.
name|base_proxy_sqpn
expr_stmt|;
operator|*
name|qkey
operator|=
name|qk
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|mlx4_get_parav_qkey
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|mlx4_sync_pkey_table
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|val
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|container_of
argument_list|(
name|dev
argument_list|,
expr|struct
name|mlx4_priv
argument_list|,
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
name|priv
operator|->
name|virt2phys_pkey
index|[
name|slave
index|]
index|[
name|port
operator|-
literal|1
index|]
index|[
name|i
index|]
operator|=
name|val
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|mlx4_sync_pkey_table
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|mlx4_put_slave_node_guid
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|__be64
name|guid
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|container_of
argument_list|(
name|dev
argument_list|,
expr|struct
name|mlx4_priv
argument_list|,
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
name|priv
operator|->
name|slave_node_guids
index|[
name|slave
index|]
operator|=
name|guid
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|mlx4_put_slave_node_guid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|__be64
name|mlx4_get_slave_node_guid
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|container_of
argument_list|(
name|dev
argument_list|,
expr|struct
name|mlx4_priv
argument_list|,
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|priv
operator|->
name|slave_node_guids
index|[
name|slave
index|]
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|mlx4_get_slave_node_guid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|mlx4_is_slave_active
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_slave_state
modifier|*
name|s_slave
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
return|return
literal|0
return|;
name|s_slave
operator|=
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|slave
index|]
expr_stmt|;
return|return
operator|!
operator|!
name|s_slave
operator|->
name|active
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|mlx4_is_slave_active
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|slave_adjust_steering_mode
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
parameter_list|,
name|struct
name|mlx4_init_hca_param
modifier|*
name|hca_param
parameter_list|)
block|{
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|=
name|hca_param
operator|->
name|steering_mode
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|==
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
name|dev
operator|->
name|caps
operator|.
name|num_qp_per_mgm
operator|=
name|dev_cap
operator|->
name|fs_max_num_qp_per_entry
expr_stmt|;
else|else
name|dev
operator|->
name|caps
operator|.
name|num_qp_per_mgm
operator|=
literal|4
operator|*
operator|(
operator|(
literal|1
operator|<<
name|hca_param
operator|->
name|log_mc_entry_sz
operator|)
operator|/
literal|16
operator|-
literal|2
operator|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Steering mode is: %s\n"
argument_list|,
name|mlx4_steering_mode_str
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_slave_cap
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|u32
name|page_size
decl_stmt|;
name|struct
name|mlx4_dev_cap
name|dev_cap
decl_stmt|;
name|struct
name|mlx4_func_cap
name|func_cap
decl_stmt|;
name|struct
name|mlx4_init_hca_param
name|hca_param
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|hca_param
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hca_param
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_QUERY_HCA
argument_list|(
name|dev
argument_list|,
operator|&
name|hca_param
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_HCA command failed, aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/*fail if the hca has an unknown capability */
if|if
condition|(
operator|(
name|hca_param
operator|.
name|global_caps
operator||
name|HCA_GLOBAL_CAP_MASK
operator|)
operator|!=
name|HCA_GLOBAL_CAP_MASK
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Unknown hca global capabilities\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOSYS
return|;
block|}
name|mlx4_log_num_mgm_entry_size
operator|=
name|hca_param
operator|.
name|log_mc_entry_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|hca_core_clock
operator|=
name|hca_param
operator|.
name|hca_core_clock
expr_stmt|;
name|memset
argument_list|(
operator|&
name|dev_cap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dev_cap
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|max_qp_dest_rdma
operator|=
literal|1
operator|<<
name|hca_param
operator|.
name|log_rd_per_qp
expr_stmt|;
name|err
operator|=
name|mlx4_dev_cap
argument_list|(
name|dev
argument_list|,
operator|&
name|dev_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_DEV_CAP command failed, aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|mlx4_QUERY_FW
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_FW command failed: could not get FW version.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hca_param
operator|.
name|mw_enable
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG_MEM_WINDOW
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|bmme_flags
operator|&=
operator|~
name|MLX4_BMME_FLAG_TYPE_2_WIN
expr_stmt|;
block|}
name|page_size
operator|=
operator|~
name|dev
operator|->
name|caps
operator|.
name|page_size_cap
operator|+
literal|1
expr_stmt|;
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"HCA minimum page size:%d\n"
argument_list|,
name|page_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|page_size
operator|>
name|PAGE_SIZE
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"HCA minimum page size of %d bigger than "
literal|"kernel PAGE_SIZE of %d, aborting.\n"
argument_list|,
name|page_size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
comment|/* slave gets uar page size from QUERY_HCA fw command */
name|dev
operator|->
name|caps
operator|.
name|uar_page_size
operator|=
literal|1
operator|<<
operator|(
name|hca_param
operator|.
name|uar_page_sz
operator|+
literal|12
operator|)
expr_stmt|;
comment|/* TODO: relax this assumption */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|uar_page_size
operator|!=
name|PAGE_SIZE
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"UAR size:%d != kernel PAGE_SIZE of %d\n"
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|uar_page_size
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
name|memset
argument_list|(
operator|&
name|func_cap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|func_cap
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_QUERY_FUNC_CAP
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
operator|&
name|func_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_FUNC_CAP general command failed, aborting (%d).\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
operator|(
name|func_cap
operator|.
name|pf_context_behaviour
operator||
name|PF_CONTEXT_BEHAVIOUR_MASK
operator|)
operator|!=
name|PF_CONTEXT_BEHAVIOUR_MASK
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Unknown pf context behaviour\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOSYS
return|;
block|}
name|dev
operator|->
name|caps
operator|.
name|num_ports
operator|=
name|func_cap
operator|.
name|num_ports
expr_stmt|;
name|dev
operator|->
name|quotas
operator|.
name|qp
operator|=
name|func_cap
operator|.
name|qp_quota
expr_stmt|;
name|dev
operator|->
name|quotas
operator|.
name|srq
operator|=
name|func_cap
operator|.
name|srq_quota
expr_stmt|;
name|dev
operator|->
name|quotas
operator|.
name|cq
operator|=
name|func_cap
operator|.
name|cq_quota
expr_stmt|;
name|dev
operator|->
name|quotas
operator|.
name|mpt
operator|=
name|func_cap
operator|.
name|mpt_quota
expr_stmt|;
name|dev
operator|->
name|quotas
operator|.
name|mtt
operator|=
name|func_cap
operator|.
name|mtt_quota
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_qps
operator|=
literal|1
operator|<<
name|hca_param
operator|.
name|log_num_qps
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_srqs
operator|=
literal|1
operator|<<
name|hca_param
operator|.
name|log_num_srqs
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_cqs
operator|=
literal|1
operator|<<
name|hca_param
operator|.
name|log_num_cqs
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_mpts
operator|=
literal|1
operator|<<
name|hca_param
operator|.
name|log_mpt_sz
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_eqs
operator|=
name|func_cap
operator|.
name|max_eq
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|reserved_eqs
operator|=
name|func_cap
operator|.
name|reserved_eq
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_pds
operator|=
name|MLX4_NUM_PDS
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_mgms
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_amgms
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|num_ports
operator|>
name|MLX4_MAX_PORTS
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"HCA has %d ports, but we only support %d, "
literal|"aborting.\n"
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|,
name|MLX4_MAX_PORTS
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
operator|=
name|kcalloc
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
operator|=
name|kcalloc
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
operator|=
name|kcalloc
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
operator|=
name|kcalloc
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|,
sizeof|sizeof
argument_list|(
name|u32
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
operator|||
operator|!
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
operator|||
operator|!
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
operator|||
operator|!
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_mem
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
operator|++
name|i
control|)
block|{
name|err
operator|=
name|mlx4_QUERY_FUNC_CAP
argument_list|(
name|dev
argument_list|,
operator|(
name|u32
operator|)
name|i
argument_list|,
operator|&
name|func_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_FUNC_CAP port command failed for"
literal|" port %d, aborting (%d).\n"
argument_list|,
name|i
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_mem
goto|;
block|}
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|func_cap
operator|.
name|qp0_tunnel_qpn
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|func_cap
operator|.
name|qp0_proxy_qpn
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|func_cap
operator|.
name|qp1_tunnel_qpn
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|func_cap
operator|.
name|qp1_proxy_qpn
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|def_counter_index
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|func_cap
operator|.
name|def_counter_index
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|port_mask
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
expr_stmt|;
name|err
operator|=
name|mlx4_get_slave_pkey_gid_tbl_len
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
operator|&
name|dev
operator|->
name|caps
operator|.
name|gid_table_len
index|[
name|i
index|]
argument_list|,
operator|&
name|dev
operator|->
name|caps
operator|.
name|pkey_table_len
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_mem
goto|;
block|}
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|uar_page_size
operator|*
operator|(
name|dev
operator|->
name|caps
operator|.
name|num_uars
operator|-
name|dev
operator|->
name|caps
operator|.
name|reserved_uars
operator|)
operator|>
name|pci_resource_len
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"HCA reported UAR region size of 0x%x bigger than "
literal|"PCI resource 2 size of 0x%llx, aborting.\n"
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|uar_page_size
operator|*
name|dev
operator|->
name|caps
operator|.
name|num_uars
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|pci_resource_len
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_mem
goto|;
block|}
if|if
condition|(
name|hca_param
operator|.
name|dev_cap_enabled
operator|&
name|MLX4_DEV_CAP_64B_EQE_ENABLED
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|eqe_size
operator|=
literal|64
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|eqe_factor
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|caps
operator|.
name|eqe_size
operator|=
literal|32
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|eqe_factor
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|hca_param
operator|.
name|dev_cap_enabled
operator|&
name|MLX4_DEV_CAP_64B_CQE_ENABLED
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|cqe_size
operator|=
literal|64
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|userspace_caps
operator||=
name|MLX4_USER_DEV_CAP_64B_CQE
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|caps
operator|.
name|cqe_size
operator|=
literal|32
expr_stmt|;
block|}
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG2_TS
expr_stmt|;
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Timestamping is not supported in slave mode.\n"
argument_list|)
expr_stmt|;
name|slave_adjust_steering_mode
argument_list|(
name|dev
argument_list|,
operator|&
name|dev_cap
argument_list|,
operator|&
name|hca_param
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_mem
label|:
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
operator|=
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
operator|=
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
operator|=
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
operator|=
name|NULL
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_request_modules
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|port
decl_stmt|;
name|int
name|has_ib_port
init|=
name|false
decl_stmt|;
name|int
name|has_eth_port
init|=
name|false
decl_stmt|;
define|#
directive|define
name|EN_DRV_NAME
value|"mlx4_en"
define|#
directive|define
name|IB_DRV_NAME
value|"mlx4_ib"
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|port
index|]
operator|==
name|MLX4_PORT_TYPE_IB
condition|)
name|has_ib_port
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|port
index|]
operator|==
name|MLX4_PORT_TYPE_ETH
condition|)
name|has_eth_port
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|has_ib_port
condition|)
name|request_module_nowait
argument_list|(
name|IB_DRV_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_eth_port
condition|)
name|request_module_nowait
argument_list|(
name|EN_DRV_NAME
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change the port configuration of the device.  * Every user of this function must hold the port mutex.  */
end_comment

begin_function
name|int
name|mlx4_change_port_types
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|enum
name|mlx4_port_type
modifier|*
name|port_types
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|change
init|=
literal|0
decl_stmt|;
name|int
name|port
decl_stmt|;
for|for
control|(
name|port
operator|=
literal|0
init|;
name|port
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
comment|/* Change the port type only if the new type is different 		 * from the current, and not set to Auto */
if|if
condition|(
name|port_types
index|[
name|port
index|]
operator|!=
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|port
operator|+
literal|1
index|]
condition|)
name|change
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|change
condition|)
block|{
name|mlx4_unregister_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
name|mlx4_CLOSE_PORT
argument_list|(
name|dev
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|port
index|]
operator|=
name|port_types
index|[
name|port
operator|-
literal|1
index|]
expr_stmt|;
name|err
operator|=
name|mlx4_SET_PORT
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to set port %d, "
literal|"aborting\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|mlx4_set_port_mask
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_register_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to register device\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mlx4_request_modules
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|show_port_type
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|mlx4_port_info
modifier|*
name|info
init|=
name|container_of
argument_list|(
name|attr
argument_list|,
expr|struct
name|mlx4_port_info
argument_list|,
name|port_attr
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|mdev
init|=
name|info
operator|->
name|dev
decl_stmt|;
name|char
name|type
index|[
literal|8
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|type
argument_list|,
literal|"%s"
argument_list|,
operator|(
name|mdev
operator|->
name|caps
operator|.
name|port_type
index|[
name|info
operator|->
name|port
index|]
operator|==
name|MLX4_PORT_TYPE_IB
operator|)
condition|?
literal|"ib"
else|:
literal|"eth"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|info
operator|->
name|port
index|]
operator|==
name|MLX4_PORT_TYPE_AUTO
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"auto (%s)\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|set_port_type
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|struct
name|mlx4_port_info
modifier|*
name|info
init|=
name|container_of
argument_list|(
name|attr
argument_list|,
expr|struct
name|mlx4_port_info
argument_list|,
name|port_attr
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|mdev
init|=
name|info
operator|->
name|dev
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|mdev
argument_list|)
decl_stmt|;
name|enum
name|mlx4_port_type
name|types
index|[
name|MLX4_MAX_PORTS
index|]
decl_stmt|;
name|enum
name|mlx4_port_type
name|new_types
index|[
name|MLX4_MAX_PORTS
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"ib\n"
argument_list|)
condition|)
name|info
operator|->
name|tmp_type
operator|=
name|MLX4_PORT_TYPE_IB
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"eth\n"
argument_list|)
condition|)
name|info
operator|->
name|tmp_type
operator|=
name|MLX4_PORT_TYPE_ETH
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|buf
argument_list|,
literal|"auto\n"
argument_list|)
condition|)
name|info
operator|->
name|tmp_type
operator|=
name|MLX4_PORT_TYPE_AUTO
expr_stmt|;
else|else
block|{
name|mlx4_err
argument_list|(
name|mdev
argument_list|,
literal|"%s is not supported port type\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
operator|(
name|info
operator|->
name|tmp_type
operator|&
name|mdev
operator|->
name|caps
operator|.
name|supported_type
index|[
name|info
operator|->
name|port
index|]
operator|)
operator|!=
name|info
operator|->
name|tmp_type
condition|)
block|{
name|mlx4_err
argument_list|(
name|mdev
argument_list|,
literal|"Requested port type for port %d is not supported on this HCA\n"
argument_list|,
name|info
operator|->
name|port
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|mlx4_stop_sense
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|port_mutex
argument_list|)
expr_stmt|;
comment|/* Possible type is always the one that was delivered */
name|mdev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|info
operator|->
name|port
index|]
operator|=
name|info
operator|->
name|tmp_type
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mdev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|types
index|[
name|i
index|]
operator|=
name|priv
operator|->
name|port
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|tmp_type
condition|?
name|priv
operator|->
name|port
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|tmp_type
else|:
name|mdev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|types
index|[
name|i
index|]
operator|==
name|MLX4_PORT_TYPE_AUTO
condition|)
name|types
index|[
name|i
index|]
operator|=
name|mdev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|mdev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_DPDP
operator|)
operator|&&
operator|!
operator|(
name|mdev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_SENSE_SUPPORT
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|mdev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mdev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
index|]
operator|==
name|MLX4_PORT_TYPE_AUTO
condition|)
block|{
name|mdev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
index|]
operator|=
name|mdev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|mdev
argument_list|,
literal|"Auto sensing is not supported on this HCA. "
literal|"Set only 'eth' or 'ib' for both ports "
literal|"(should be the same)\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mlx4_do_sense_ports
argument_list|(
name|mdev
argument_list|,
name|new_types
argument_list|,
name|types
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_check_port_params
argument_list|(
name|mdev
argument_list|,
name|new_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
comment|/* We are about to apply the changes after the configuration 	 * was verified, no need to remember the temporary types 	 * any more */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mdev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
name|priv
operator|->
name|port
index|[
name|i
operator|+
literal|1
index|]
operator|.
name|tmp_type
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|mlx4_change_port_types
argument_list|(
name|mdev
argument_list|,
name|new_types
argument_list|)
expr_stmt|;
name|out
label|:
name|mlx4_start_sense
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|port_mutex
argument_list|)
expr_stmt|;
return|return
name|err
condition|?
name|err
else|:
name|count
return|;
block|}
end_function

begin_enum
enum|enum
name|ibta_mtu
block|{
name|IB_MTU_256
init|=
literal|1
block|,
name|IB_MTU_512
init|=
literal|2
block|,
name|IB_MTU_1024
init|=
literal|3
block|,
name|IB_MTU_2048
init|=
literal|4
block|,
name|IB_MTU_4096
init|=
literal|5
block|}
enum|;
end_enum

begin_function
specifier|static
specifier|inline
name|int
name|int_to_ibta_mtu
parameter_list|(
name|int
name|mtu
parameter_list|)
block|{
switch|switch
condition|(
name|mtu
condition|)
block|{
case|case
literal|256
case|:
return|return
name|IB_MTU_256
return|;
case|case
literal|512
case|:
return|return
name|IB_MTU_512
return|;
case|case
literal|1024
case|:
return|return
name|IB_MTU_1024
return|;
case|case
literal|2048
case|:
return|return
name|IB_MTU_2048
return|;
case|case
literal|4096
case|:
return|return
name|IB_MTU_4096
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|ibta_mtu_to_int
parameter_list|(
name|enum
name|ibta_mtu
name|mtu
parameter_list|)
block|{
switch|switch
condition|(
name|mtu
condition|)
block|{
case|case
name|IB_MTU_256
case|:
return|return
literal|256
return|;
case|case
name|IB_MTU_512
case|:
return|return
literal|512
return|;
case|case
name|IB_MTU_1024
case|:
return|return
literal|1024
return|;
case|case
name|IB_MTU_2048
case|:
return|return
literal|2048
return|;
case|case
name|IB_MTU_4096
case|:
return|return
literal|4096
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|show_port_ib_mtu
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|mlx4_port_info
modifier|*
name|info
init|=
name|container_of
argument_list|(
name|attr
argument_list|,
expr|struct
name|mlx4_port_info
argument_list|,
name|port_mtu_attr
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|mdev
init|=
name|info
operator|->
name|dev
decl_stmt|;
comment|/* When port type is eth, port mtu value isn't used. */
if|if
condition|(
name|mdev
operator|->
name|caps
operator|.
name|port_type
index|[
name|info
operator|->
name|port
index|]
operator|==
name|MLX4_PORT_TYPE_ETH
condition|)
return|return
operator|-
name|EINVAL
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d\n"
argument_list|,
name|ibta_mtu_to_int
argument_list|(
name|mdev
operator|->
name|caps
operator|.
name|port_ib_mtu
index|[
name|info
operator|->
name|port
index|]
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|strlen
argument_list|(
name|buf
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|set_port_ib_mtu
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|count
parameter_list|)
block|{
name|struct
name|mlx4_port_info
modifier|*
name|info
init|=
name|container_of
argument_list|(
name|attr
argument_list|,
expr|struct
name|mlx4_port_info
argument_list|,
name|port_mtu_attr
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|mdev
init|=
name|info
operator|->
name|dev
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|mdev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|,
name|port
decl_stmt|,
name|mtu
decl_stmt|,
name|ibta_mtu
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|mdev
operator|->
name|caps
operator|.
name|port_type
index|[
name|info
operator|->
name|port
index|]
operator|==
name|MLX4_PORT_TYPE_ETH
condition|)
block|{
name|mlx4_warn
argument_list|(
name|mdev
argument_list|,
literal|"port level mtu is only used for IB ports\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|mtu
operator|=
operator|(
name|int
operator|)
name|simple_strtol
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ibta_mtu
operator|=
name|int_to_ibta_mtu
argument_list|(
name|mtu
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibta_mtu
operator|<
literal|0
condition|)
block|{
name|mlx4_err
argument_list|(
name|mdev
argument_list|,
literal|"%s is invalid IBTA mtu\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|mdev
operator|->
name|caps
operator|.
name|port_ib_mtu
index|[
name|info
operator|->
name|port
index|]
operator|=
name|ibta_mtu
expr_stmt|;
name|mlx4_stop_sense
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|port_mutex
argument_list|)
expr_stmt|;
name|mlx4_unregister_device
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<=
name|mdev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
name|mlx4_CLOSE_PORT
argument_list|(
name|mdev
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_SET_PORT
argument_list|(
name|mdev
argument_list|,
name|port
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|mdev
argument_list|,
literal|"Failed to set port %d, "
literal|"aborting\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
goto|goto
name|err_set_port
goto|;
block|}
block|}
name|err
operator|=
name|mlx4_register_device
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|err_set_port
label|:
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|port_mutex
argument_list|)
expr_stmt|;
name|mlx4_start_sense
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
return|return
name|err
condition|?
name|err
else|:
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_load_fw
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|,
name|unmap_flag
init|=
literal|0
decl_stmt|;
name|priv
operator|->
name|fw
operator|.
name|fw_icm
operator|=
name|mlx4_alloc_icm
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|fw_pages
argument_list|,
name|GFP_HIGHUSER
operator||
name|__GFP_NOWARN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|fw
operator|.
name|fw_icm
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Couldn't allocate FW area, aborting.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|err
operator|=
name|mlx4_MAP_FA
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|fw_icm
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"MAP_FA command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free
goto|;
block|}
name|err
operator|=
name|mlx4_RUN_FW
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"RUN_FW command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_fa
goto|;
block|}
return|return
literal|0
return|;
name|err_unmap_fa
label|:
name|unmap_flag
operator|=
name|mlx4_UNMAP_FA
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unmap_flag
condition|)
name|pr_warn
argument_list|(
literal|"mlx4_core: mlx4_UNMAP_FA failed.\n"
argument_list|)
expr_stmt|;
name|err_free
label|:
if|if
condition|(
operator|!
name|unmap_flag
condition|)
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|fw_icm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_cmpt_table
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|cmpt_base
parameter_list|,
name|int
name|cmpt_entry_sz
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|num_eqs
decl_stmt|;
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|cmpt_table
argument_list|,
name|cmpt_base
operator|+
operator|(
call|(
name|u64
call|)
argument_list|(
name|MLX4_CMPT_TYPE_QP
operator|*
name|cmpt_entry_sz
argument_list|)
operator|<<
name|MLX4_CMPT_SHIFT
operator|)
argument_list|,
name|cmpt_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_qps
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err
goto|;
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|cmpt_table
argument_list|,
name|cmpt_base
operator|+
operator|(
call|(
name|u64
call|)
argument_list|(
name|MLX4_CMPT_TYPE_SRQ
operator|*
name|cmpt_entry_sz
argument_list|)
operator|<<
name|MLX4_CMPT_SHIFT
operator|)
argument_list|,
name|cmpt_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_srqs
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_srqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_qp
goto|;
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|cmpt_table
argument_list|,
name|cmpt_base
operator|+
operator|(
call|(
name|u64
call|)
argument_list|(
name|MLX4_CMPT_TYPE_CQ
operator|*
name|cmpt_entry_sz
argument_list|)
operator|<<
name|MLX4_CMPT_SHIFT
operator|)
argument_list|,
name|cmpt_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_cqs
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_cqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_srq
goto|;
name|num_eqs
operator|=
operator|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
operator|)
condition|?
name|dev
operator|->
name|phys_caps
operator|.
name|num_phys_eqs
else|:
name|dev
operator|->
name|caps
operator|.
name|num_eqs
expr_stmt|;
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|cmpt_table
argument_list|,
name|cmpt_base
operator|+
operator|(
call|(
name|u64
call|)
argument_list|(
name|MLX4_CMPT_TYPE_EQ
operator|*
name|cmpt_entry_sz
argument_list|)
operator|<<
name|MLX4_CMPT_SHIFT
operator|)
argument_list|,
name|cmpt_entry_sz
argument_list|,
name|num_eqs
argument_list|,
name|num_eqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_cq
goto|;
return|return
literal|0
return|;
name|err_cq
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|err_srq
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|err_qp
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|err
label|:
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_icm
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
parameter_list|,
name|struct
name|mlx4_init_hca_param
modifier|*
name|init_hca
parameter_list|,
name|u64
name|icm_size
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u64
name|aux_pages
decl_stmt|;
name|int
name|num_eqs
decl_stmt|;
name|int
name|err
decl_stmt|,
name|unmap_flag
init|=
literal|0
decl_stmt|;
name|err
operator|=
name|mlx4_SET_ICM_SIZE
argument_list|(
name|dev
argument_list|,
name|icm_size
argument_list|,
operator|&
name|aux_pages
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"SET_ICM_SIZE command failed, aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%lld KB of HCA context requires %lld KB aux memory.\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|icm_size
operator|>>
literal|10
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|aux_pages
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|priv
operator|->
name|fw
operator|.
name|aux_icm
operator|=
name|mlx4_alloc_icm
argument_list|(
name|dev
argument_list|,
name|aux_pages
argument_list|,
name|GFP_HIGHUSER
operator||
name|__GFP_NOWARN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|fw
operator|.
name|aux_icm
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Couldn't allocate aux memory, aborting.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|err
operator|=
name|mlx4_MAP_ICM_AUX
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|aux_icm
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"MAP_ICM_AUX command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free_aux
goto|;
block|}
name|err
operator|=
name|mlx4_init_cmpt_table
argument_list|(
name|dev
argument_list|,
name|init_hca
operator|->
name|cmpt_base
argument_list|,
name|dev_cap
operator|->
name|cmpt_entry_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map cMPT context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_aux
goto|;
block|}
name|num_eqs
operator|=
operator|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
operator|)
condition|?
name|dev
operator|->
name|phys_caps
operator|.
name|num_phys_eqs
else|:
name|dev
operator|->
name|caps
operator|.
name|num_eqs
expr_stmt|;
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|table
argument_list|,
name|init_hca
operator|->
name|eqc_base
argument_list|,
name|dev_cap
operator|->
name|eqc_entry_sz
argument_list|,
name|num_eqs
argument_list|,
name|num_eqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map EQ context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_cmpt
goto|;
block|}
comment|/* 	 * Reserved MTT entries must be aligned up to a cacheline 	 * boundary, since the FW will write to them, while the driver 	 * writes to all other MTT entries. (The variable 	 * dev->caps.mtt_entry_sz below is really the MTT segment 	 * size, not the raw entry size) 	 */
name|dev
operator|->
name|caps
operator|.
name|reserved_mtts
operator|=
name|ALIGN
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|reserved_mtts
operator|*
name|dev
operator|->
name|caps
operator|.
name|mtt_entry_sz
argument_list|,
name|dma_get_cache_alignment
argument_list|()
argument_list|)
operator|/
name|dev
operator|->
name|caps
operator|.
name|mtt_entry_sz
expr_stmt|;
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mr_table
operator|.
name|mtt_table
argument_list|,
name|init_hca
operator|->
name|mtt_base
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|mtt_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_mtts
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_mtts
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map MTT context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_eq
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mr_table
operator|.
name|dmpt_table
argument_list|,
name|init_hca
operator|->
name|dmpt_base
argument_list|,
name|dev_cap
operator|->
name|dmpt_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_mpts
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_mrws
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map dMPT context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_mtt
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|qp_table
argument_list|,
name|init_hca
operator|->
name|qpc_base
argument_list|,
name|dev_cap
operator|->
name|qpc_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_qps
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map QP context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_dmpt
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|auxc_table
argument_list|,
name|init_hca
operator|->
name|auxc_base
argument_list|,
name|dev_cap
operator|->
name|aux_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_qps
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map AUXC context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_qp
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|altc_table
argument_list|,
name|init_hca
operator|->
name|altc_base
argument_list|,
name|dev_cap
operator|->
name|altc_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_qps
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map ALTC context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_auxc
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|rdmarc_table
argument_list|,
name|init_hca
operator|->
name|rdmarc_base
argument_list|,
name|dev_cap
operator|->
name|rdmarc_entry_sz
operator|<<
name|priv
operator|->
name|qp_table
operator|.
name|rdmarc_shift
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_qps
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_qps_cnt
index|[
name|MLX4_QP_REGION_FW
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map RDMARC context memory, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_altc
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|table
argument_list|,
name|init_hca
operator|->
name|cqc_base
argument_list|,
name|dev_cap
operator|->
name|cqc_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_cqs
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_cqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map CQ context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_rdmarc
goto|;
block|}
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|table
argument_list|,
name|init_hca
operator|->
name|srqc_base
argument_list|,
name|dev_cap
operator|->
name|srq_entry_sz
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_srqs
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|reserved_srqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map SRQ context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_cq
goto|;
block|}
comment|/* 	 * For flow steering device managed mode it is required to use 	 * mlx4_init_icm_table. For B0 steering mode it's not strictly 	 * required, but for simplicity just map the whole multicast 	 * group table now.  The table isn't very big and it's a lot 	 * easier than trying to track ref counts. 	 */
name|err
operator|=
name|mlx4_init_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mcg_table
operator|.
name|table
argument_list|,
name|init_hca
operator|->
name|mc_base
argument_list|,
name|mlx4_get_mgm_entry_size
argument_list|(
name|dev
argument_list|)
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_mgms
operator|+
name|dev
operator|->
name|caps
operator|.
name|num_amgms
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_mgms
operator|+
name|dev
operator|->
name|caps
operator|.
name|num_amgms
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map MCG context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_srq
goto|;
block|}
return|return
literal|0
return|;
name|err_unmap_srq
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|err_unmap_cq
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|err_unmap_rdmarc
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|rdmarc_table
argument_list|)
expr_stmt|;
name|err_unmap_altc
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|altc_table
argument_list|)
expr_stmt|;
name|err_unmap_auxc
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|auxc_table
argument_list|)
expr_stmt|;
name|err_unmap_qp
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|qp_table
argument_list|)
expr_stmt|;
name|err_unmap_dmpt
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mr_table
operator|.
name|dmpt_table
argument_list|)
expr_stmt|;
name|err_unmap_mtt
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mr_table
operator|.
name|mtt_table
argument_list|)
expr_stmt|;
name|err_unmap_eq
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|err_unmap_cmpt
label|:
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|err_unmap_aux
label|:
name|unmap_flag
operator|=
name|mlx4_UNMAP_ICM_AUX
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unmap_flag
condition|)
name|pr_warn
argument_list|(
literal|"mlx4_core: mlx4_UNMAP_ICM_AUX failed.\n"
argument_list|)
expr_stmt|;
name|err_free_aux
label|:
if|if
condition|(
operator|!
name|unmap_flag
condition|)
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|aux_icm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_free_icms
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mcg_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|rdmarc_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|altc_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|auxc_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|qp_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mr_table
operator|.
name|dmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|mr_table
operator|.
name|mtt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|eq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|cq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|srq_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
name|mlx4_cleanup_icm_table
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|qp_table
operator|.
name|cmpt_table
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_UNMAP_ICM_AUX
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|aux_icm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|pr_warn
argument_list|(
literal|"mlx4_core: mlx4_UNMAP_ICM_AUX failed.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_slave_exit
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|slave_cmd_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_comm_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_COMM_CMD_RESET
argument_list|,
literal|0
argument_list|,
name|MLX4_COMM_TIME
argument_list|)
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Failed to close slave function.\n"
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|slave_cmd_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|map_bf_area
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|resource_size_t
name|bf_start
decl_stmt|;
name|resource_size_t
name|bf_len
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|caps
operator|.
name|bf_reg_size
condition|)
return|return
operator|-
name|ENXIO
return|;
name|bf_start
operator|=
name|pci_resource_start
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
operator|+
operator|(
name|dev
operator|->
name|caps
operator|.
name|num_uars
operator|<<
name|PAGE_SHIFT
operator|)
expr_stmt|;
name|bf_len
operator|=
name|pci_resource_len
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
operator|-
operator|(
name|dev
operator|->
name|caps
operator|.
name|num_uars
operator|<<
name|PAGE_SHIFT
operator|)
expr_stmt|;
name|priv
operator|->
name|bf_mapping
operator|=
name|io_mapping_create_wc
argument_list|(
name|bf_start
argument_list|,
name|bf_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|bf_mapping
condition|)
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|unmap_bf_area
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|bf_mapping
condition|)
name|io_mapping_free
argument_list|(
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|bf_mapping
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mlx4_read_clock
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|u32
name|clockhi
decl_stmt|,
name|clocklo
decl_stmt|,
name|clockhi1
decl_stmt|;
name|cycle_t
name|cycles
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|clock_mapping
condition|)
return|return
operator|-
name|ENOTSUPP
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
block|{
name|clockhi
operator|=
name|swab32
argument_list|(
name|readl
argument_list|(
name|priv
operator|->
name|clock_mapping
argument_list|)
argument_list|)
expr_stmt|;
name|clocklo
operator|=
name|swab32
argument_list|(
name|readl
argument_list|(
name|priv
operator|->
name|clock_mapping
operator|+
literal|4
argument_list|)
argument_list|)
expr_stmt|;
name|clockhi1
operator|=
name|swab32
argument_list|(
name|readl
argument_list|(
name|priv
operator|->
name|clock_mapping
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clockhi
operator|==
name|clockhi1
condition|)
break|break;
block|}
name|cycles
operator|=
operator|(
name|u64
operator|)
name|clockhi
operator|<<
literal|32
operator||
operator|(
name|u64
operator|)
name|clocklo
expr_stmt|;
return|return
name|cycles
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_read_clock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|map_internal_clock
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|priv
operator|->
name|clock_mapping
operator|=
name|ioremap
argument_list|(
name|pci_resource_start
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|clock_bar
argument_list|)
operator|+
name|priv
operator|->
name|fw
operator|.
name|clock_offset
argument_list|,
name|MLX4_CLOCK_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|clock_mapping
condition|)
return|return
operator|-
name|ENOMEM
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx4_get_internal_clock_params
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_clock_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|-
name|ENOTSUPP
return|;
if|if
condition|(
operator|!
name|params
condition|)
return|return
operator|-
name|EINVAL
return|;
name|params
operator|->
name|bar
operator|=
name|priv
operator|->
name|fw
operator|.
name|clock_bar
expr_stmt|;
name|params
operator|->
name|offset
operator|=
name|priv
operator|->
name|fw
operator|.
name|clock_offset
expr_stmt|;
name|params
operator|->
name|size
operator|=
name|MLX4_CLOCK_SIZE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_get_internal_clock_params
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|unmap_internal_clock
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
if|if
condition|(
name|priv
operator|->
name|clock_mapping
condition|)
name|iounmap
argument_list|(
name|priv
operator|->
name|clock_mapping
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_close_hca
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|unmap_internal_clock
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unmap_bf_area
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|mlx4_slave_exit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mlx4_CLOSE_HCA
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mlx4_free_icms
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_UNMAP_FA
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|fw
operator|.
name|fw_icm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|pr_warn
argument_list|(
literal|"mlx4_core: mlx4_UNMAP_FA failed.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_slave
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|u64
name|dma
init|=
operator|(
name|u64
operator|)
name|priv
operator|->
name|mfunc
operator|.
name|vhcr_dma
decl_stmt|;
name|int
name|num_of_reset_retries
init|=
name|NUM_OF_RESET_RETRIES
decl_stmt|;
name|int
name|ret_from_reset
init|=
literal|0
decl_stmt|;
name|u32
name|slave_read
decl_stmt|;
name|u32
name|cmd_channel_ver
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|slave_cmd_mutex
argument_list|)
expr_stmt|;
name|priv
operator|->
name|cmd
operator|.
name|max_cmds
operator|=
literal|1
expr_stmt|;
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Sending reset\n"
argument_list|)
expr_stmt|;
name|ret_from_reset
operator|=
name|mlx4_comm_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_COMM_CMD_RESET
argument_list|,
literal|0
argument_list|,
name|MLX4_COMM_TIME
argument_list|)
expr_stmt|;
comment|/* if we are in the middle of flr the slave will try 	 * NUM_OF_RESET_RETRIES times before leaving.*/
if|if
condition|(
name|ret_from_reset
condition|)
block|{
if|if
condition|(
name|MLX4_DELAY_RESET_SLAVE
operator|==
name|ret_from_reset
condition|)
block|{
name|msleep
argument_list|(
name|SLEEP_TIME_IN_RESET
argument_list|)
expr_stmt|;
while|while
condition|(
name|ret_from_reset
operator|&&
name|num_of_reset_retries
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"slave is currently in the"
literal|"middle of FLR. retrying..."
literal|"(try num:%d)\n"
argument_list|,
operator|(
name|NUM_OF_RESET_RETRIES
operator|-
name|num_of_reset_retries
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|ret_from_reset
operator|=
name|mlx4_comm_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_COMM_CMD_RESET
argument_list|,
literal|0
argument_list|,
name|MLX4_COMM_TIME
argument_list|)
expr_stmt|;
name|num_of_reset_retries
operator|=
name|num_of_reset_retries
operator|-
literal|1
expr_stmt|;
block|}
block|}
else|else
goto|goto
name|err
goto|;
block|}
comment|/* check the driver version - the slave I/F revision 	 * must match the master's */
name|slave_read
operator|=
name|swab32
argument_list|(
name|readl
argument_list|(
operator|&
name|priv
operator|->
name|mfunc
operator|.
name|comm
operator|->
name|slave_read
argument_list|)
argument_list|)
expr_stmt|;
name|cmd_channel_ver
operator|=
name|mlx4_comm_get_version
argument_list|()
expr_stmt|;
if|if
condition|(
name|MLX4_COMM_GET_IF_REV
argument_list|(
name|cmd_channel_ver
argument_list|)
operator|!=
name|MLX4_COMM_GET_IF_REV
argument_list|(
name|slave_read
argument_list|)
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"slave driver version is not supported"
literal|" by the master\n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Sending vhcr0\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_comm_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_COMM_CMD_VHCR0
argument_list|,
name|dma
operator|>>
literal|48
argument_list|,
name|MLX4_COMM_TIME
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|mlx4_comm_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_COMM_CMD_VHCR1
argument_list|,
name|dma
operator|>>
literal|32
argument_list|,
name|MLX4_COMM_TIME
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|mlx4_comm_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_COMM_CMD_VHCR2
argument_list|,
name|dma
operator|>>
literal|16
argument_list|,
name|MLX4_COMM_TIME
argument_list|)
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|mlx4_comm_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_COMM_CMD_VHCR_EN
argument_list|,
name|dma
argument_list|,
name|MLX4_COMM_TIME
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|slave_cmd_mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err
label|:
name|mlx4_comm_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_COMM_CMD_RESET
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|cmd
operator|.
name|slave_cmd_mutex
argument_list|)
expr_stmt|;
return|return
operator|-
name|EIO
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_parav_master_pf_caps
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
index|]
operator|==
name|MLX4_PORT_TYPE_ETH
condition|)
name|dev
operator|->
name|caps
operator|.
name|gid_table_len
index|[
name|i
index|]
operator|=
name|mlx4_get_slave_num_gids
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|dev
operator|->
name|caps
operator|.
name|gid_table_len
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|pkey_table_len
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|phys_caps
operator|.
name|pkey_phys_table_len
index|[
name|i
index|]
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|choose_log_fs_mgm_entry_size
parameter_list|(
name|int
name|qp_per_entry
parameter_list|)
block|{
name|int
name|i
init|=
name|MLX4_MIN_MGM_LOG_ENTRY_SIZE
decl_stmt|;
for|for
control|(
name|i
operator|=
name|MLX4_MIN_MGM_LOG_ENTRY_SIZE
init|;
name|i
operator|<=
name|MLX4_MAX_MGM_LOG_ENTRY_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qp_per_entry
operator|<=
literal|4
operator|*
operator|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|/
literal|16
operator|-
literal|2
operator|)
condition|)
break|break;
block|}
return|return
operator|(
name|i
operator|<=
name|MLX4_MAX_MGM_LOG_ENTRY_SIZE
operator|)
condition|?
name|i
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|choose_steering_mode
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
parameter_list|)
block|{
name|int
name|nvfs
decl_stmt|;
name|mlx4_get_val
argument_list|(
name|num_vfs
operator|.
name|dbdf2val
operator|.
name|tbl
argument_list|,
name|pci_physfn
argument_list|(
name|dev
operator|->
name|pdev
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|nvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|high_rate_steer
operator|&&
operator|!
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&=
operator|~
operator|(
name|MLX4_DEV_CAP_FLAG_VEP_MC_STEER
operator||
name|MLX4_DEV_CAP_FLAG_VEP_UC_STEER
operator|)
expr_stmt|;
name|dev_cap
operator|->
name|flags2
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG2_FS_EN
expr_stmt|;
block|}
if|if
condition|(
name|mlx4_log_num_mgm_entry_size
operator|==
operator|-
literal|1
operator|&&
name|dev_cap
operator|->
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_FS_EN
operator|&&
operator|(
operator|!
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
operator|||
operator|(
name|dev_cap
operator|->
name|fs_max_num_qp_per_entry
operator|>=
operator|(
name|nvfs
operator|+
literal|1
operator|)
operator|)
operator|)
operator|&&
name|choose_log_fs_mgm_entry_size
argument_list|(
name|dev_cap
operator|->
name|fs_max_num_qp_per_entry
argument_list|)
operator|>=
name|MLX4_MIN_MGM_LOG_ENTRY_SIZE
condition|)
block|{
name|dev
operator|->
name|oper_log_mgm_entry_size
operator|=
name|choose_log_fs_mgm_entry_size
argument_list|(
name|dev_cap
operator|->
name|fs_max_num_qp_per_entry
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|=
name|MLX4_STEERING_MODE_DEVICE_MANAGED
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_qp_per_mgm
operator|=
name|dev_cap
operator|->
name|fs_max_num_qp_per_entry
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_VEP_UC_STEER
operator|&&
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_VEP_MC_STEER
condition|)
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|=
name|MLX4_STEERING_MODE_B0
expr_stmt|;
else|else
block|{
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|=
name|MLX4_STEERING_MODE_A0
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_VEP_UC_STEER
operator|||
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_VEP_MC_STEER
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Must have both UC_STEER and MC_STEER flags "
literal|"set to use B0 steering. Falling back to A0 steering mode.\n"
argument_list|)
expr_stmt|;
block|}
name|dev
operator|->
name|oper_log_mgm_entry_size
operator|=
name|mlx4_log_num_mgm_entry_size
operator|>
literal|0
condition|?
name|mlx4_log_num_mgm_entry_size
else|:
name|MLX4_DEFAULT_MGM_LOG_ENTRY_SIZE
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_qp_per_mgm
operator|=
name|mlx4_get_qp_per_mgm
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Steering mode is: %s, oper_log_mgm_entry_size = %d, "
literal|"log_num_mgm_entry_size = %d\n"
argument_list|,
name|mlx4_steering_mode_str
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
argument_list|)
argument_list|,
name|dev
operator|->
name|oper_log_mgm_entry_size
argument_list|,
name|mlx4_log_num_mgm_entry_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_hca
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_dev_cap
modifier|*
name|dev_cap
init|=
name|NULL
decl_stmt|;
name|struct
name|mlx4_adapter
name|adapter
decl_stmt|;
name|struct
name|mlx4_mod_stat_cfg
name|mlx4_cfg
decl_stmt|;
name|struct
name|mlx4_profile
name|profile
decl_stmt|;
name|struct
name|mlx4_init_hca_param
name|init_hca
decl_stmt|;
name|u64
name|icm_size
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|err
operator|=
name|mlx4_QUERY_FW
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|==
operator|-
name|EACCES
condition|)
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"non-primary physical function, skipping.\n"
argument_list|)
expr_stmt|;
else|else
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_FW command failed, aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|mlx4_load_fw
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to start FW, aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|mlx4_cfg
operator|.
name|log_pg_sz_m
operator|=
literal|1
expr_stmt|;
name|mlx4_cfg
operator|.
name|log_pg_sz
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|mlx4_MOD_STAT_CFG
argument_list|(
name|dev
argument_list|,
operator|&
name|mlx4_cfg
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Failed to override log_pg_sz parameter\n"
argument_list|)
expr_stmt|;
name|dev_cap
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|dev_cap
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev_cap
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to allocate memory for dev_cap\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_stop_fw
goto|;
block|}
name|err
operator|=
name|mlx4_dev_cap
argument_list|(
name|dev
argument_list|,
name|dev_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_DEV_CAP command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_stop_fw
goto|;
block|}
name|choose_steering_mode
argument_list|(
name|dev
argument_list|,
name|dev_cap
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_parav_master_pf_caps
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|process_mod_param_profile
argument_list|(
operator|&
name|profile
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|==
name|MLX4_STEERING_MODE_DEVICE_MANAGED
condition|)
name|profile
operator|.
name|num_mcg
operator|=
name|MLX4_FS_NUM_MCG
expr_stmt|;
name|icm_size
operator|=
name|mlx4_make_profile
argument_list|(
name|dev
argument_list|,
operator|&
name|profile
argument_list|,
name|dev_cap
argument_list|,
operator|&
name|init_hca
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|long
name|long
operator|)
name|icm_size
operator|<
literal|0
condition|)
block|{
name|err
operator|=
name|icm_size
expr_stmt|;
goto|goto
name|err_stop_fw
goto|;
block|}
name|dev
operator|->
name|caps
operator|.
name|max_fmr_maps
operator|=
operator|(
literal|1
operator|<<
operator|(
literal|32
operator|-
name|ilog2
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|num_mpts
argument_list|)
operator|)
operator|)
operator|-
literal|1
expr_stmt|;
name|init_hca
operator|.
name|log_uar_sz
operator|=
name|ilog2
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|num_uars
argument_list|)
expr_stmt|;
name|init_hca
operator|.
name|uar_page_sz
operator|=
name|PAGE_SHIFT
operator|-
literal|12
expr_stmt|;
name|err
operator|=
name|mlx4_init_icm
argument_list|(
name|dev
argument_list|,
name|dev_cap
argument_list|,
operator|&
name|init_hca
argument_list|,
name|icm_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_stop_fw
goto|;
name|init_hca
operator|.
name|mw_enable
operator|=
literal|1
expr_stmt|;
name|err
operator|=
name|mlx4_INIT_HCA
argument_list|(
name|dev
argument_list|,
operator|&
name|init_hca
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"INIT_HCA command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free_icm
goto|;
block|}
comment|/* 		 * Read HCA frequency by QUERY_HCA command 		 */
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_TS
condition|)
block|{
name|memset
argument_list|(
operator|&
name|init_hca
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|init_hca
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_QUERY_HCA
argument_list|(
name|dev
argument_list|,
operator|&
name|init_hca
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_HCA command failed, disable timestamp.\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG2_TS
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|caps
operator|.
name|hca_core_clock
operator|=
name|init_hca
operator|.
name|hca_core_clock
expr_stmt|;
block|}
comment|/* In case we got HCA frequency 0 - disable timestamping 			 * to avoid dividing by zero 			 */
if|if
condition|(
operator|!
name|dev
operator|->
name|caps
operator|.
name|hca_core_clock
condition|)
block|{
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG2_TS
expr_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"HCA frequency is 0. Timestamping is not supported."
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|map_internal_clock
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* Map internal clock, 				 * in case of failure disable timestamping 				 */
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&=
operator|~
name|MLX4_DEV_CAP_FLAG2_TS
expr_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to map internal clock. Timestamping is not supported.\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|err
operator|=
name|mlx4_init_slave
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize slave\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|mlx4_slave_cap
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to obtain slave caps\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_close
goto|;
block|}
block|}
if|if
condition|(
name|map_bf_area
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"Failed to map blue flame area\n"
argument_list|)
expr_stmt|;
comment|/* Only the master set the ports, all the rest got it from it.*/
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_set_port_mask
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_QUERY_ADAPTER
argument_list|(
name|dev
argument_list|,
operator|&
name|adapter
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"QUERY_ADAPTER command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|unmap_bf
goto|;
block|}
name|priv
operator|->
name|eq_table
operator|.
name|inta_pin
operator|=
name|adapter
operator|.
name|inta_pin
expr_stmt|;
name|memcpy
argument_list|(
name|dev
operator|->
name|board_id
argument_list|,
name|adapter
operator|.
name|board_id
argument_list|,
sizeof|sizeof
name|dev
operator|->
name|board_id
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dev
operator|->
name|vsd
argument_list|,
name|adapter
operator|.
name|vsd
argument_list|,
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|vsd
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|vsd_vendor_id
operator|=
name|adapter
operator|.
name|vsd_vendor_id
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|kfree
argument_list|(
name|dev_cap
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|unmap_bf
label|:
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|unmap_internal_clock
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|unmap_bf_area
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
argument_list|)
expr_stmt|;
block|}
name|err_close
label|:
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_slave_exit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
else|else
name|mlx4_CLOSE_HCA
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err_free_icm
label|:
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_free_icms
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_stop_fw
label|:
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|mlx4_UNMAP_FA
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|priv
operator|->
name|fw
operator|.
name|fw_icm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|pr_warn
argument_list|(
literal|"mlx4_core: mlx4_UNMAP_FA failed.\n"
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev_cap
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_counters_table
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|nent_pow2
decl_stmt|,
name|port_indx
decl_stmt|,
name|vf_index
decl_stmt|,
name|num_counters
decl_stmt|;
name|int
name|res
decl_stmt|,
name|index
init|=
literal|0
decl_stmt|;
name|struct
name|counter_index
modifier|*
name|new_counter_index
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_COUNTERS
operator|)
condition|)
return|return
operator|-
name|ENOENT
return|;
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
operator|&&
name|dev
operator|->
name|caps
operator|.
name|max_counters
operator|==
name|dev
operator|->
name|caps
operator|.
name|max_extended_counters
condition|)
block|{
name|res
operator|=
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_IF_STATE_EXTENDED
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_SET_IF_STAT
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to set extended counters (err=%d)\n"
argument_list|,
name|res
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
block|}
name|mutex_init
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
for|for
control|(
name|port_indx
operator|=
literal|0
init|;
name|port_indx
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port_indx
operator|++
control|)
block|{
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|global_port_list
index|[
name|port_indx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|def_counter_index
index|[
name|port_indx
index|]
operator|!=
literal|0xFF
condition|)
block|{
name|new_counter_index
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|counter_index
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_counter_index
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|new_counter_index
operator|->
name|index
operator|=
name|dev
operator|->
name|caps
operator|.
name|def_counter_index
index|[
name|port_indx
index|]
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|new_counter_index
operator|->
name|list
argument_list|,
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|global_port_list
index|[
name|port_indx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: slave allocated %d counters for %d ports\n"
argument_list|,
name|__func__
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|nent_pow2
operator|=
name|roundup_pow_of_two
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|max_counters
argument_list|)
expr_stmt|;
for|for
control|(
name|port_indx
operator|=
literal|0
init|;
name|port_indx
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port_indx
operator|++
control|)
block|{
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|global_port_list
index|[
name|port_indx
index|]
argument_list|)
expr_stmt|;
comment|/* allocating 2 counters per port for PFs */
comment|/* For the PF, the ETH default counters are 0,2; */
comment|/* and the RoCE default counters are 1,3 */
for|for
control|(
name|num_counters
operator|=
literal|0
init|;
name|num_counters
operator|<
literal|2
condition|;
name|num_counters
operator|++
operator|,
name|index
operator|++
control|)
block|{
name|new_counter_index
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|counter_index
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_counter_index
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|new_counter_index
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|new_counter_index
operator|->
name|list
argument_list|,
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|global_port_list
index|[
name|port_indx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
block|{
for|for
control|(
name|vf_index
operator|=
literal|0
init|;
name|vf_index
operator|<
name|dev
operator|->
name|num_vfs
condition|;
name|vf_index
operator|++
control|)
block|{
for|for
control|(
name|port_indx
operator|=
literal|0
init|;
name|port_indx
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port_indx
operator|++
control|)
block|{
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|vf_list
index|[
name|vf_index
index|]
index|[
name|port_indx
index|]
argument_list|)
expr_stmt|;
name|new_counter_index
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|counter_index
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_counter_index
condition|)
return|return
operator|-
name|ENOMEM
return|;
if|if
condition|(
name|index
operator|<
name|nent_pow2
operator|-
literal|2
condition|)
block|{
name|new_counter_index
operator|->
name|index
operator|=
name|index
expr_stmt|;
name|index
operator|++
expr_stmt|;
block|}
else|else
block|{
name|new_counter_index
operator|->
name|index
operator|=
name|MLX4_SINK_COUNTER_INDEX
expr_stmt|;
block|}
name|list_add_tail
argument_list|(
operator|&
name|new_counter_index
operator|->
name|list
argument_list|,
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|vf_list
index|[
name|vf_index
index|]
index|[
name|port_indx
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|res
operator|=
name|mlx4_bitmap_init
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|bitmap
argument_list|,
name|nent_pow2
argument_list|,
name|nent_pow2
operator|-
literal|1
argument_list|,
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: master allocated %d counters for %d VFs\n"
argument_list|,
name|__func__
argument_list|,
name|index
argument_list|,
name|dev
operator|->
name|num_vfs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|=
name|mlx4_bitmap_init
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|bitmap
argument_list|,
name|nent_pow2
argument_list|,
name|nent_pow2
operator|-
literal|1
argument_list|,
name|index
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: native allocated %d counters for %d ports\n"
argument_list|,
name|__func__
argument_list|,
name|index
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_cleanup_counters_table
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|counter_index
modifier|*
name|port
decl_stmt|,
modifier|*
name|tmp_port
decl_stmt|;
name|struct
name|counter_index
modifier|*
name|vf
decl_stmt|,
modifier|*
name|tmp_vf
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_COUNTERS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|list_for_each_entry_safe
argument_list|(
argument|port
argument_list|,
argument|tmp_port
argument_list|,
argument|&priv->counters_table.global_port_list[i]
argument_list|,
argument|list
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|port
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|num_vfs
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|j
operator|++
control|)
block|{
name|list_for_each_entry_safe
argument_list|(
argument|vf
argument_list|,
argument|tmp_vf
argument_list|,
argument|&priv->counters_table.vf_list[i][j]
argument_list|,
argument|list
argument_list|)
block|{
comment|/* clear the counter statistic */
if|if
condition|(
name|__mlx4_clear_if_stat
argument_list|(
name|dev
argument_list|,
name|vf
operator|->
name|index
argument_list|)
condition|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: reset counter %d failed\n"
argument_list|,
name|__func__
argument_list|,
name|vf
operator|->
name|index
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|vf
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|vf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mlx4_bitmap_cleanup
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|bitmap
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|__mlx4_slave_counters_free
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|first
decl_stmt|;
name|struct
name|counter_index
modifier|*
name|vf
decl_stmt|,
modifier|*
name|tmp_vf
decl_stmt|;
comment|/* clean VF's counters for the next useg */
if|if
condition|(
name|slave
operator|>
literal|0
operator|&&
name|slave
operator|<=
name|dev
operator|->
name|num_vfs
condition|)
block|{
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: free counters of slave(%d)\n"
argument_list|,
name|__func__
argument_list|,
name|slave
argument_list|)
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|vf
argument_list|,
argument|tmp_vf
argument_list|,
argument|&priv->counters_table.vf_list[slave -
literal|1
argument|][i]
argument_list|,
argument|list
argument_list|)
block|{
comment|/* clear the counter statistic */
if|if
condition|(
name|__mlx4_clear_if_stat
argument_list|(
name|dev
argument_list|,
name|vf
operator|->
name|index
argument_list|)
condition|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: reset counter %d failed\n"
argument_list|,
name|__func__
argument_list|,
name|vf
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
operator|++
operator|&&
name|vf
operator|->
name|index
operator|!=
name|MLX4_SINK_COUNTER_INDEX
condition|)
block|{
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: delete counter index %d for slave %d and port %d\n"
argument_list|,
name|__func__
argument_list|,
name|vf
operator|->
name|index
argument_list|,
name|slave
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mlx4_bitmap_free
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|bitmap
argument_list|,
name|vf
operator|->
name|index
argument_list|,
name|MLX4_USE_RR
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|vf
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|vf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: can't delete default counter index %d for slave %d and port %d\n"
argument_list|,
name|__func__
argument_list|,
name|vf
operator|->
name|index
argument_list|,
name|slave
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|__mlx4_counter_alloc
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|port
parameter_list|,
name|u32
modifier|*
name|idx
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|counter_index
modifier|*
name|new_counter_index
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_COUNTERS
operator|)
condition|)
return|return
operator|-
name|ENOENT
return|;
if|if
condition|(
operator|(
name|slave
operator|>
name|MLX4_MAX_NUM_VF
operator|)
operator|||
operator|(
name|slave
operator|<
literal|0
operator|)
operator|||
operator|(
name|port
operator|<
literal|0
operator|)
operator|||
operator|(
name|port
operator|>
name|MLX4_MAX_PORTS
operator|)
condition|)
block|{
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: invalid slave(%d) or port(%d) index\n"
argument_list|,
name|__func__
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* handle old guest request does not support request by port index */
if|if
condition|(
name|port
operator|==
literal|0
condition|)
block|{
operator|*
name|idx
operator|=
name|MLX4_SINK_COUNTER_INDEX
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: allocated default counter index %d for slave %d port %d\n"
argument_list|,
name|__func__
argument_list|,
operator|*
name|idx
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
operator|*
name|idx
operator|=
name|mlx4_bitmap_alloc
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|bitmap
argument_list|)
expr_stmt|;
comment|/* if no resources return the default counter of the slave and port */
if|if
condition|(
operator|*
name|idx
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|slave
operator|==
literal|0
condition|)
block|{
comment|/* its the ethernet counter ?????? */
name|new_counter_index
operator|=
name|list_entry
argument_list|(
name|priv
operator|->
name|counters_table
operator|.
name|global_port_list
index|[
name|port
operator|-
literal|1
index|]
operator|.
name|next
argument_list|,
expr|struct
name|counter_index
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_counter_index
operator|=
name|list_entry
argument_list|(
name|priv
operator|->
name|counters_table
operator|.
name|vf_list
index|[
name|slave
operator|-
literal|1
index|]
index|[
name|port
operator|-
literal|1
index|]
operator|.
name|next
argument_list|,
expr|struct
name|counter_index
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
operator|*
name|idx
operator|=
name|new_counter_index
operator|->
name|index
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: allocated defualt counter index %d for slave %d port %d\n"
argument_list|,
name|__func__
argument_list|,
operator|*
name|idx
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|slave
operator|==
literal|0
condition|)
block|{
comment|/* native or master */
name|new_counter_index
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|counter_index
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_counter_index
condition|)
goto|goto
name|no_mem
goto|;
name|new_counter_index
operator|->
name|index
operator|=
operator|*
name|idx
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|new_counter_index
operator|->
name|list
argument_list|,
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|global_port_list
index|[
name|port
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_counter_index
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|counter_index
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_counter_index
condition|)
goto|goto
name|no_mem
goto|;
name|new_counter_index
operator|->
name|index
operator|=
operator|*
name|idx
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|new_counter_index
operator|->
name|list
argument_list|,
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|vf_list
index|[
name|slave
operator|-
literal|1
index|]
index|[
name|port
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: allocated counter index %d for slave %d port %d\n"
argument_list|,
name|__func__
argument_list|,
operator|*
name|idx
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|out
label|:
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|no_mem
label|:
name|mlx4_bitmap_free
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|bitmap
argument_list|,
operator|*
name|idx
argument_list|,
name|MLX4_USE_RR
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
operator|*
name|idx
operator|=
name|MLX4_SINK_COUNTER_INDEX
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: failed err (%d)\n"
argument_list|,
name|__func__
argument_list|,
operator|-
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
end_function

begin_function
name|int
name|mlx4_counter_alloc
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|u32
modifier|*
name|idx
parameter_list|)
block|{
name|u64
name|out_param
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|counter_index
modifier|*
name|new_counter_index
decl_stmt|,
modifier|*
name|c_index
decl_stmt|;
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|err
operator|=
name|mlx4_cmd_imm
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
operator|&
name|out_param
argument_list|,
operator|(
operator|(
name|u32
operator|)
name|port
operator|)
operator|<<
literal|8
operator||
operator|(
name|u32
operator|)
name|RES_COUNTER
argument_list|,
name|RES_OP_RESERVE
argument_list|,
name|MLX4_CMD_ALLOC_RES
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
operator|*
name|idx
operator|=
name|get_param_l
argument_list|(
operator|&
name|out_param
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|idx
operator|==
name|MLX4_SINK_COUNTER_INDEX
condition|)
return|return
operator|-
name|ENOSPC
return|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|c_index
operator|=
name|list_entry
argument_list|(
name|priv
operator|->
name|counters_table
operator|.
name|global_port_list
index|[
name|port
operator|-
literal|1
index|]
operator|.
name|next
argument_list|,
expr|struct
name|counter_index
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|c_index
operator|->
name|index
operator|==
operator|*
name|idx
condition|)
return|return
operator|-
name|EEXIST
return|;
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|new_counter_index
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|counter_index
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_counter_index
condition|)
block|{
name|mlx4_counter_free
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
operator|*
name|idx
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|new_counter_index
operator|->
name|index
operator|=
operator|*
name|idx
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|new_counter_index
operator|->
name|list
argument_list|,
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|global_port_list
index|[
name|port
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: allocated counter index %d for port %d\n"
argument_list|,
name|__func__
argument_list|,
operator|*
name|idx
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|err
return|;
block|}
return|return
name|__mlx4_counter_alloc
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|port
argument_list|,
name|idx
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_counter_alloc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|__mlx4_counter_free
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|port
parameter_list|,
name|u32
name|idx
parameter_list|)
block|{
comment|/* check if native or slave and deletes acordingly */
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|counter_index
modifier|*
name|pf
decl_stmt|,
modifier|*
name|tmp_pf
decl_stmt|;
name|struct
name|counter_index
modifier|*
name|vf
decl_stmt|,
modifier|*
name|tmp_vf
decl_stmt|;
name|int
name|first
decl_stmt|;
if|if
condition|(
name|idx
operator|==
name|MLX4_SINK_COUNTER_INDEX
condition|)
block|{
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: try to delete default counter index %d for port %d\n"
argument_list|,
name|__func__
argument_list|,
name|idx
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|slave
operator|>
name|MLX4_MAX_NUM_VF
operator|)
operator|||
operator|(
name|slave
operator|<
literal|0
operator|)
operator|||
operator|(
name|port
operator|<
literal|0
operator|)
operator|||
operator|(
name|port
operator|>
name|MLX4_MAX_PORTS
operator|)
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"%s: deletion failed due to invalid slave(%d) or port(%d) index\n"
argument_list|,
name|__func__
argument_list|,
name|slave
argument_list|,
name|idx
argument_list|)
expr_stmt|;
return|return;
block|}
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|slave
operator|==
literal|0
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|pf
argument_list|,
argument|tmp_pf
argument_list|,
argument|&priv->counters_table.global_port_list[port -
literal|1
argument|]
argument_list|,
argument|list
argument_list|)
block|{
comment|/* the first 2 counters are reserved */
if|if
condition|(
name|pf
operator|->
name|index
operator|==
name|idx
condition|)
block|{
comment|/* clear the counter statistic */
if|if
condition|(
name|__mlx4_clear_if_stat
argument_list|(
name|dev
argument_list|,
name|pf
operator|->
name|index
argument_list|)
condition|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: reset counter %d failed\n"
argument_list|,
name|__func__
argument_list|,
name|pf
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
literal|1
operator|<
name|first
operator|&&
name|idx
operator|!=
name|MLX4_SINK_COUNTER_INDEX
condition|)
block|{
name|list_del
argument_list|(
operator|&
name|pf
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|pf
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: delete counter index %d for native device (%d) port %d\n"
argument_list|,
name|__func__
argument_list|,
name|idx
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|mlx4_bitmap_free
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|bitmap
argument_list|,
name|idx
argument_list|,
name|MLX4_USE_RR
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
block|{
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: can't delete default counter index %d for native device (%d) port %d\n"
argument_list|,
name|__func__
argument_list|,
name|idx
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|first
operator|++
expr_stmt|;
block|}
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: can't delete counter index %d for native device (%d) port %d\n"
argument_list|,
name|__func__
argument_list|,
name|idx
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|first
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|vf
argument_list|,
argument|tmp_vf
argument_list|,
argument|&priv->counters_table.vf_list[slave -
literal|1
argument|][port -
literal|1
argument|]
argument_list|,
argument|list
argument_list|)
block|{
comment|/* the first element is reserved */
if|if
condition|(
name|vf
operator|->
name|index
operator|==
name|idx
condition|)
block|{
comment|/* clear the counter statistic */
if|if
condition|(
name|__mlx4_clear_if_stat
argument_list|(
name|dev
argument_list|,
name|vf
operator|->
name|index
argument_list|)
condition|)
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: reset counter %d failed\n"
argument_list|,
name|__func__
argument_list|,
name|vf
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|list_del
argument_list|(
operator|&
name|vf
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|vf
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: delete counter index %d for slave %d port %d\n"
argument_list|,
name|__func__
argument_list|,
name|idx
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|mlx4_bitmap_free
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|bitmap
argument_list|,
name|idx
argument_list|,
name|MLX4_USE_RR
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
block|{
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: can't delete default slave (%d) counter index %d for port %d\n"
argument_list|,
name|__func__
argument_list|,
name|slave
argument_list|,
name|idx
argument_list|,
name|port
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|first
operator|++
expr_stmt|;
block|}
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: can't delete slave (%d) counter index %d for port %d\n"
argument_list|,
name|__func__
argument_list|,
name|slave
argument_list|,
name|idx
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mlx4_counter_free
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|u32
name|idx
parameter_list|)
block|{
name|u64
name|in_param
init|=
literal|0
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|counter_index
modifier|*
name|counter
decl_stmt|,
modifier|*
name|tmp_counter
decl_stmt|;
name|int
name|first
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|set_param_l
argument_list|(
operator|&
name|in_param
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|in_param
argument_list|,
operator|(
operator|(
name|u32
operator|)
name|port
operator|)
operator|<<
literal|8
operator||
operator|(
name|u32
operator|)
name|RES_COUNTER
argument_list|,
name|RES_OP_RESERVE
argument_list|,
name|MLX4_CMD_FREE_RES
argument_list|,
name|MLX4_CMD_TIME_CLASS_A
argument_list|,
name|MLX4_CMD_WRAPPED
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
operator|&&
name|idx
operator|!=
name|MLX4_SINK_COUNTER_INDEX
condition|)
block|{
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|counter
argument_list|,
argument|tmp_counter
argument_list|,
argument|&priv->counters_table.global_port_list[port -
literal|1
argument|]
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|counter
operator|->
name|index
operator|==
name|idx
operator|&&
name|first
operator|++
condition|)
block|{
name|list_del
argument_list|(
operator|&
name|counter
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|counter
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: delete counter index %d for port %d\n"
argument_list|,
name|__func__
argument_list|,
name|idx
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|__mlx4_counter_free
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|port
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_counter_free
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|__mlx4_clear_if_stat
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|counter_index
parameter_list|)
block|{
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|if_stat_mailbox
init|=
name|NULL
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|u32
name|if_stat_in_mod
init|=
operator|(
name|counter_index
operator|&
literal|0xff
operator|)
operator||
operator|(
literal|1
operator|<<
literal|31
operator|)
decl_stmt|;
if|if
condition|(
name|counter_index
operator|==
name|MLX4_SINK_COUNTER_INDEX
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
return|return
literal|0
return|;
name|if_stat_mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|if_stat_mailbox
argument_list|)
condition|)
block|{
name|err
operator|=
name|PTR_ERR
argument_list|(
name|if_stat_mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|if_stat_mailbox
operator|->
name|dma
argument_list|,
name|if_stat_in_mod
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_IF_STAT
argument_list|,
name|MLX4_CMD_TIME_CLASS_C
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|if_stat_mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|u8
name|mlx4_get_default_counter_index
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|slave
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|counter_index
modifier|*
name|new_counter_index
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|port
index|]
operator|==
name|MLX4_PORT_TYPE_IB
condition|)
block|{
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: return counter index %d for slave %d port (MLX4_PORT_TYPE_IB) %d\n"
argument_list|,
name|__func__
argument_list|,
name|MLX4_SINK_COUNTER_INDEX
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|u8
operator|)
name|MLX4_SINK_COUNTER_INDEX
return|;
block|}
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|slave
operator|==
literal|0
condition|)
block|{
name|new_counter_index
operator|=
name|list_entry
argument_list|(
name|priv
operator|->
name|counters_table
operator|.
name|global_port_list
index|[
name|port
operator|-
literal|1
index|]
operator|.
name|next
argument_list|,
expr|struct
name|counter_index
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_counter_index
operator|=
name|list_entry
argument_list|(
name|priv
operator|->
name|counters_table
operator|.
name|vf_list
index|[
name|slave
operator|-
literal|1
index|]
index|[
name|port
operator|-
literal|1
index|]
operator|.
name|next
argument_list|,
expr|struct
name|counter_index
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: return counter index %d for slave %d port %d\n"
argument_list|,
name|__func__
argument_list|,
name|new_counter_index
operator|->
name|index
argument_list|,
name|slave
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|u8
operator|)
name|new_counter_index
operator|->
name|index
return|;
block|}
end_function

begin_function
name|int
name|mlx4_get_vport_ethtool_stats
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|,
name|struct
name|mlx4_en_vport_stats
modifier|*
name|vport_stats
parameter_list|,
name|int
name|reset
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_cmd_mailbox
modifier|*
name|if_stat_mailbox
init|=
name|NULL
decl_stmt|;
name|union
name|mlx4_counter
modifier|*
name|counter
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|u32
name|if_stat_in_mod
decl_stmt|;
name|struct
name|counter_index
modifier|*
name|vport
decl_stmt|,
modifier|*
name|tmp_vport
decl_stmt|;
if|if
condition|(
operator|!
name|vport_stats
condition|)
return|return
operator|-
name|EINVAL
return|;
name|if_stat_mailbox
operator|=
name|mlx4_alloc_cmd_mailbox
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|if_stat_mailbox
argument_list|)
condition|)
block|{
name|err
operator|=
name|PTR_ERR
argument_list|(
name|if_stat_mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|vport
argument_list|,
argument|tmp_vport
argument_list|,
argument|&priv->counters_table.global_port_list[port -
literal|1
argument|]
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|vport
operator|->
name|index
operator|==
name|MLX4_SINK_COUNTER_INDEX
condition|)
continue|continue;
name|memset
argument_list|(
name|if_stat_mailbox
operator|->
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|mlx4_counter
argument_list|)
argument_list|)
expr_stmt|;
name|if_stat_in_mod
operator|=
operator|(
name|vport
operator|->
name|index
operator|&
literal|0xff
operator|)
operator||
operator|(
operator|(
name|reset
operator|&
literal|1
operator|)
operator|<<
literal|31
operator|)
expr_stmt|;
name|err
operator|=
name|mlx4_cmd_box
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
name|if_stat_mailbox
operator|->
name|dma
argument_list|,
name|if_stat_in_mod
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_QUERY_IF_STAT
argument_list|,
name|MLX4_CMD_TIME_CLASS_C
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"%s: failed to read statistics for counter index %d\n"
argument_list|,
name|__func__
argument_list|,
name|vport
operator|->
name|index
argument_list|)
expr_stmt|;
goto|goto
name|if_stat_out
goto|;
block|}
name|counter
operator|=
operator|(
expr|union
name|mlx4_counter
operator|*
operator|)
name|if_stat_mailbox
operator|->
name|buf
expr_stmt|;
if|if
condition|(
operator|(
name|counter
operator|->
name|control
operator|.
name|cnt_mode
operator|&
literal|0xf
operator|)
operator|==
literal|1
condition|)
block|{
name|vport_stats
operator|->
name|rx_broadcast_packets
operator|+=
name|be64_to_cpu
argument_list|(
name|counter
operator|->
name|ext
operator|.
name|counters
index|[
literal|0
index|]
operator|.
name|IfRxBroadcastFrames
argument_list|)
expr_stmt|;
name|vport_stats
operator|->
name|rx_unicast_packets
operator|+=
name|be64_to_cpu
argument_list|(
name|counter
operator|->
name|ext
operator|.
name|counters
index|[
literal|0
index|]
operator|.
name|IfRxUnicastFrames
argument_list|)
expr_stmt|;
name|vport_stats
operator|->
name|rx_multicast_packets
operator|+=
name|be64_to_cpu
argument_list|(
name|counter
operator|->
name|ext
operator|.
name|counters
index|[
literal|0
index|]
operator|.
name|IfRxMulticastFrames
argument_list|)
expr_stmt|;
name|vport_stats
operator|->
name|tx_broadcast_packets
operator|+=
name|be64_to_cpu
argument_list|(
name|counter
operator|->
name|ext
operator|.
name|counters
index|[
literal|0
index|]
operator|.
name|IfTxBroadcastFrames
argument_list|)
expr_stmt|;
name|vport_stats
operator|->
name|tx_unicast_packets
operator|+=
name|be64_to_cpu
argument_list|(
name|counter
operator|->
name|ext
operator|.
name|counters
index|[
literal|0
index|]
operator|.
name|IfTxUnicastFrames
argument_list|)
expr_stmt|;
name|vport_stats
operator|->
name|tx_multicast_packets
operator|+=
name|be64_to_cpu
argument_list|(
name|counter
operator|->
name|ext
operator|.
name|counters
index|[
literal|0
index|]
operator|.
name|IfTxMulticastFrames
argument_list|)
expr_stmt|;
name|vport_stats
operator|->
name|rx_broadcast_bytes
operator|+=
name|be64_to_cpu
argument_list|(
name|counter
operator|->
name|ext
operator|.
name|counters
index|[
literal|0
index|]
operator|.
name|IfRxBroadcastOctets
argument_list|)
expr_stmt|;
name|vport_stats
operator|->
name|rx_unicast_bytes
operator|+=
name|be64_to_cpu
argument_list|(
name|counter
operator|->
name|ext
operator|.
name|counters
index|[
literal|0
index|]
operator|.
name|IfRxUnicastOctets
argument_list|)
expr_stmt|;
name|vport_stats
operator|->
name|rx_multicast_bytes
operator|+=
name|be64_to_cpu
argument_list|(
name|counter
operator|->
name|ext
operator|.
name|counters
index|[
literal|0
index|]
operator|.
name|IfRxMulticastOctets
argument_list|)
expr_stmt|;
name|vport_stats
operator|->
name|tx_broadcast_bytes
operator|+=
name|be64_to_cpu
argument_list|(
name|counter
operator|->
name|ext
operator|.
name|counters
index|[
literal|0
index|]
operator|.
name|IfTxBroadcastOctets
argument_list|)
expr_stmt|;
name|vport_stats
operator|->
name|tx_unicast_bytes
operator|+=
name|be64_to_cpu
argument_list|(
name|counter
operator|->
name|ext
operator|.
name|counters
index|[
literal|0
index|]
operator|.
name|IfTxUnicastOctets
argument_list|)
expr_stmt|;
name|vport_stats
operator|->
name|tx_multicast_bytes
operator|+=
name|be64_to_cpu
argument_list|(
name|counter
operator|->
name|ext
operator|.
name|counters
index|[
literal|0
index|]
operator|.
name|IfTxMulticastOctets
argument_list|)
expr_stmt|;
name|vport_stats
operator|->
name|rx_errors
operator|+=
name|be64_to_cpu
argument_list|(
name|counter
operator|->
name|ext
operator|.
name|counters
index|[
literal|0
index|]
operator|.
name|IfRxErrorFrames
argument_list|)
expr_stmt|;
name|vport_stats
operator|->
name|rx_dropped
operator|+=
name|be64_to_cpu
argument_list|(
name|counter
operator|->
name|ext
operator|.
name|counters
index|[
literal|0
index|]
operator|.
name|IfRxNoBufferFrames
argument_list|)
expr_stmt|;
name|vport_stats
operator|->
name|tx_errors
operator|+=
name|be64_to_cpu
argument_list|(
name|counter
operator|->
name|ext
operator|.
name|counters
index|[
literal|0
index|]
operator|.
name|IfTxDroppedFrames
argument_list|)
expr_stmt|;
block|}
block|}
name|if_stat_out
label|:
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|counters_table
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|mlx4_free_cmd_mailbox
argument_list|(
name|dev
argument_list|,
name|if_stat_mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|mlx4_get_vport_ethtool_stats
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|mlx4_setup_hca
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|port
decl_stmt|;
name|__be32
name|ib_port_default_caps
decl_stmt|;
name|err
operator|=
name|mlx4_init_uar_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"user access region table (err=%d), aborting.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|mlx4_uar_alloc
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|driver_uar
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to allocate driver access region "
literal|"(err=%d), aborting.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_uar_table_free
goto|;
block|}
name|priv
operator|->
name|kar
operator|=
name|ioremap
argument_list|(
operator|(
name|phys_addr_t
operator|)
name|priv
operator|->
name|driver_uar
operator|.
name|pfn
operator|<<
name|PAGE_SHIFT
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|kar
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Couldn't map kernel access region, "
literal|"aborting.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_uar_free
goto|;
block|}
name|err
operator|=
name|mlx4_init_pd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"protection domain table (err=%d), aborting.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_kar_unmap
goto|;
block|}
name|err
operator|=
name|mlx4_init_xrcd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"reliable connection domain table (err=%d), "
literal|"aborting.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_pd_table_free
goto|;
block|}
name|err
operator|=
name|mlx4_init_mr_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"memory region table (err=%d), aborting.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_xrcd_table_free
goto|;
block|}
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|err
operator|=
name|mlx4_init_mcg_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"multicast group table (err=%d), aborting.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_mr_table_free
goto|;
block|}
block|}
name|err
operator|=
name|mlx4_init_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"event queue table (err=%d), aborting.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_mcg_table_free
goto|;
block|}
name|err
operator|=
name|mlx4_cmd_use_events
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to switch to event-driven "
literal|"firmware commands (err=%d), aborting.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_eq_table_free
goto|;
block|}
name|err
operator|=
name|mlx4_NOP
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_MSI_X
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"NOP command failed to generate MSI-X "
literal|"interrupt IRQ %d).\n"
argument_list|,
name|priv
operator|->
name|eq_table
operator|.
name|eq
index|[
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
index|]
operator|.
name|irq
argument_list|)
expr_stmt|;
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Trying again without MSI-X.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"NOP command failed to generate interrupt "
literal|"(IRQ %d), aborting.\n"
argument_list|,
name|priv
operator|->
name|eq_table
operator|.
name|eq
index|[
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
index|]
operator|.
name|irq
argument_list|)
expr_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"BIOS or ACPI interrupt routing problem?\n"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|err_cmd_poll
goto|;
block|}
name|mlx4_dbg
argument_list|(
name|dev
argument_list|,
literal|"NOP command IRQ test passed\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_init_cq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"completion queue table (err=%d), aborting.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_cmd_poll
goto|;
block|}
name|err
operator|=
name|mlx4_init_srq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"shared receive queue table (err=%d), aborting.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_cq_table_free
goto|;
block|}
name|err
operator|=
name|mlx4_init_qp_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"queue pair table (err=%d), aborting.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_srq_table_free
goto|;
block|}
name|err
operator|=
name|mlx4_init_counters_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|!=
operator|-
name|ENOENT
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize counters table (err=%d), "
literal|"aborting.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_qp_table_free
goto|;
block|}
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
name|ib_port_default_caps
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|mlx4_get_port_ib_caps
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
operator|&
name|ib_port_default_caps
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"failed to get port %d default "
literal|"ib capabilities (%d). Continuing "
literal|"with caps = 0\n"
argument_list|,
name|port
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|ib_port_def_cap
index|[
name|port
index|]
operator|=
name|ib_port_default_caps
expr_stmt|;
comment|/* initialize per-slave default ib port capabilities */
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|num_slaves
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|mlx4_master_func_num
argument_list|(
name|dev
argument_list|)
condition|)
continue|continue;
name|priv
operator|->
name|mfunc
operator|.
name|master
operator|.
name|slave_state
index|[
name|i
index|]
operator|.
name|ib_cap_mask
index|[
name|port
index|]
operator|=
name|ib_port_default_caps
expr_stmt|;
block|}
block|}
name|dev
operator|->
name|caps
operator|.
name|port_ib_mtu
index|[
name|port
index|]
operator|=
name|IB_MTU_4096
expr_stmt|;
name|err
operator|=
name|mlx4_SET_PORT
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|?
name|dev
operator|->
name|caps
operator|.
name|pkey_table_len
index|[
name|port
index|]
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to set port %d (err=%d), "
literal|"aborting\n"
argument_list|,
name|port
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_counters_table_free
goto|;
block|}
block|}
block|}
return|return
literal|0
return|;
name|err_counters_table_free
label|:
name|mlx4_cleanup_counters_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_qp_table_free
label|:
name|mlx4_cleanup_qp_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_srq_table_free
label|:
name|mlx4_cleanup_srq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_cq_table_free
label|:
name|mlx4_cleanup_cq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_cmd_poll
label|:
name|mlx4_cmd_use_polling
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_eq_table_free
label|:
name|mlx4_cleanup_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_mcg_table_free
label|:
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_cleanup_mcg_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_mr_table_free
label|:
name|mlx4_cleanup_mr_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_xrcd_table_free
label|:
name|mlx4_cleanup_xrcd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_pd_table_free
label|:
name|mlx4_cleanup_pd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_kar_unmap
label|:
name|iounmap
argument_list|(
name|priv
operator|->
name|kar
argument_list|)
expr_stmt|;
name|err_uar_free
label|:
name|mlx4_uar_free
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|driver_uar
argument_list|)
expr_stmt|;
name|err_uar_table_free
label|:
name|mlx4_cleanup_uar_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_enable_msi_x
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|msix_entry
modifier|*
name|entries
decl_stmt|;
name|int
name|nreq
init|=
name|min_t
argument_list|(
name|int
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_ports
operator|*
name|min_t
argument_list|(
name|int
argument_list|,
name|num_possible_cpus
argument_list|()
operator|+
literal|1
argument_list|,
name|MAX_MSIX_P_PORT
argument_list|)
operator|+
name|MSIX_LEGACY_SZ
argument_list|,
name|MAX_MSIX
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|msi_x
condition|)
block|{
name|nreq
operator|=
name|min_t
argument_list|(
name|int
argument_list|,
name|dev
operator|->
name|caps
operator|.
name|num_eqs
operator|-
name|dev
operator|->
name|caps
operator|.
name|reserved_eqs
argument_list|,
name|nreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|msi_x
operator|>
literal|1
operator|&&
operator|!
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
name|nreq
operator|=
name|min_t
argument_list|(
name|int
argument_list|,
name|nreq
argument_list|,
name|msi_x
argument_list|)
expr_stmt|;
name|entries
operator|=
name|kcalloc
argument_list|(
name|nreq
argument_list|,
sizeof|sizeof
expr|*
name|entries
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entries
condition|)
goto|goto
name|no_msi
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nreq
condition|;
operator|++
name|i
control|)
name|entries
index|[
name|i
index|]
operator|.
name|entry
operator|=
name|i
expr_stmt|;
name|retry
label|:
name|err
operator|=
name|pci_enable_msix
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|entries
argument_list|,
name|nreq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* Try again if at least 2 vectors are available */
if|if
condition|(
name|err
operator|>
literal|1
condition|)
block|{
name|mlx4_info
argument_list|(
name|dev
argument_list|,
literal|"Requested %d vectors, "
literal|"but only %d MSI-X vectors available, "
literal|"trying again\n"
argument_list|,
name|nreq
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|nreq
operator|=
name|err
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|kfree
argument_list|(
name|entries
argument_list|)
expr_stmt|;
comment|/* if error, or can't alloc even 1 IRQ */
if|if
condition|(
name|err
operator|<
literal|0
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"No IRQs left, device can't "
literal|"be started.\n"
argument_list|)
expr_stmt|;
goto|goto
name|no_irq
goto|;
block|}
goto|goto
name|no_msi
goto|;
block|}
if|if
condition|(
name|nreq
operator|<
name|MSIX_LEGACY_SZ
operator|+
name|dev
operator|->
name|caps
operator|.
name|num_ports
operator|*
name|MIN_MSIX_P_PORT
condition|)
block|{
comment|/*Working in legacy mode , all EQ's shared*/
name|dev
operator|->
name|caps
operator|.
name|comp_pool
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
operator|=
name|nreq
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dev
operator|->
name|caps
operator|.
name|comp_pool
operator|=
name|nreq
operator|-
name|MSIX_LEGACY_SZ
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
operator|=
name|MSIX_LEGACY_SZ
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nreq
condition|;
operator|++
name|i
control|)
name|priv
operator|->
name|eq_table
operator|.
name|eq
index|[
name|i
index|]
operator|.
name|irq
operator|=
name|entries
index|[
name|i
index|]
operator|.
name|vector
expr_stmt|;
name|dev
operator|->
name|flags
operator||=
name|MLX4_FLAG_MSI_X
expr_stmt|;
name|kfree
argument_list|(
name|entries
argument_list|)
expr_stmt|;
return|return;
block|}
name|no_msi
label|:
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
operator|=
literal|1
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|comp_pool
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
name|priv
operator|->
name|eq_table
operator|.
name|eq
index|[
name|i
index|]
operator|.
name|irq
operator|=
name|dev
operator|->
name|pdev
operator|->
name|irq
expr_stmt|;
return|return;
name|no_irq
label|:
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|comp_pool
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_port_info
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|mlx4_port_info
modifier|*
name|info
init|=
operator|&
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
operator|->
name|port
index|[
name|port
index|]
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|info
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|info
operator|->
name|port
operator|=
name|port
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|mlx4_init_mac_table
argument_list|(
name|dev
argument_list|,
operator|&
name|info
operator|->
name|mac_table
argument_list|)
expr_stmt|;
name|mlx4_init_vlan_table
argument_list|(
name|dev
argument_list|,
operator|&
name|info
operator|->
name|vlan_table
argument_list|)
expr_stmt|;
name|info
operator|->
name|base_qpn
operator|=
name|mlx4_get_base_qpn
argument_list|(
name|dev
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|info
operator|->
name|dev_name
argument_list|,
literal|"mlx4_port%d"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|info
operator|->
name|port_attr
operator|.
name|attr
operator|.
name|name
operator|=
name|info
operator|->
name|dev_name
expr_stmt|;
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
name|info
operator|->
name|port_attr
operator|.
name|attr
operator|.
name|mode
operator|=
name|S_IRUGO
expr_stmt|;
else|else
block|{
name|info
operator|->
name|port_attr
operator|.
name|attr
operator|.
name|mode
operator|=
name|S_IRUGO
operator||
name|S_IWUSR
expr_stmt|;
name|info
operator|->
name|port_attr
operator|.
name|store
operator|=
name|set_port_type
expr_stmt|;
block|}
name|info
operator|->
name|port_attr
operator|.
name|show
operator|=
name|show_port_type
expr_stmt|;
name|sysfs_attr_init
argument_list|(
operator|&
name|info
operator|->
name|port_attr
operator|.
name|attr
argument_list|)
expr_stmt|;
name|err
operator|=
name|device_create_file
argument_list|(
operator|&
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
operator|&
name|info
operator|->
name|port_attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to create file for port %d\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|info
operator|->
name|port
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|sprintf
argument_list|(
name|info
operator|->
name|dev_mtu_name
argument_list|,
literal|"mlx4_port%d_mtu"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|info
operator|->
name|port_mtu_attr
operator|.
name|attr
operator|.
name|name
operator|=
name|info
operator|->
name|dev_mtu_name
expr_stmt|;
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
name|info
operator|->
name|port_mtu_attr
operator|.
name|attr
operator|.
name|mode
operator|=
name|S_IRUGO
expr_stmt|;
else|else
block|{
name|info
operator|->
name|port_mtu_attr
operator|.
name|attr
operator|.
name|mode
operator|=
name|S_IRUGO
operator||
name|S_IWUSR
expr_stmt|;
name|info
operator|->
name|port_mtu_attr
operator|.
name|store
operator|=
name|set_port_ib_mtu
expr_stmt|;
block|}
name|info
operator|->
name|port_mtu_attr
operator|.
name|show
operator|=
name|show_port_ib_mtu
expr_stmt|;
name|sysfs_attr_init
argument_list|(
operator|&
name|info
operator|->
name|port_mtu_attr
operator|.
name|attr
argument_list|)
expr_stmt|;
name|err
operator|=
name|device_create_file
argument_list|(
operator|&
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
operator|&
name|info
operator|->
name|port_mtu_attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to create mtu file for port %d\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|device_remove_file
argument_list|(
operator|&
name|info
operator|->
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
operator|&
name|info
operator|->
name|port_attr
argument_list|)
expr_stmt|;
name|info
operator|->
name|port
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_cleanup_port_info
parameter_list|(
name|struct
name|mlx4_port_info
modifier|*
name|info
parameter_list|)
block|{
if|if
condition|(
name|info
operator|->
name|port
operator|<
literal|0
condition|)
return|return;
name|device_remove_file
argument_list|(
operator|&
name|info
operator|->
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
operator|&
name|info
operator|->
name|port_attr
argument_list|)
expr_stmt|;
name|device_remove_file
argument_list|(
operator|&
name|info
operator|->
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
operator|&
name|info
operator|->
name|port_mtu_attr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_init_steering
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|num_entries
init|=
name|dev
operator|->
name|caps
operator|.
name|num_ports
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|priv
operator|->
name|steer
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_steer
argument_list|)
operator|*
name|num_entries
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
operator|->
name|steer
condition|)
return|return
operator|-
name|ENOMEM
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MLX4_NUM_STEERS
condition|;
name|j
operator|++
control|)
block|{
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|steer
index|[
name|i
index|]
operator|.
name|promisc_qps
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|steer
index|[
name|i
index|]
operator|.
name|steer_entries
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_clear_steering
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_steer_index
modifier|*
name|entry
decl_stmt|,
modifier|*
name|tmp_entry
decl_stmt|;
name|struct
name|mlx4_promisc_qp
modifier|*
name|pqp
decl_stmt|,
modifier|*
name|tmp_pqp
decl_stmt|;
name|int
name|num_entries
init|=
name|dev
operator|->
name|caps
operator|.
name|num_ports
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_entries
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MLX4_NUM_STEERS
condition|;
name|j
operator|++
control|)
block|{
name|list_for_each_entry_safe
argument_list|(
argument|pqp
argument_list|,
argument|tmp_pqp
argument_list|,
argument|&priv->steer[i].promisc_qps[j]
argument_list|,
argument|list
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|pqp
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|pqp
argument_list|)
expr_stmt|;
block|}
name|list_for_each_entry_safe
argument_list|(
argument|entry
argument_list|,
argument|tmp_entry
argument_list|,
argument|&priv->steer[i].steer_entries[j]
argument_list|,
argument|list
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|entry
operator|->
name|list
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|pqp
argument_list|,
argument|tmp_pqp
argument_list|,
argument|&entry->duplicates
argument_list|,
argument|list
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|pqp
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|pqp
argument_list|)
expr_stmt|;
block|}
name|kfree
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|kfree
argument_list|(
name|priv
operator|->
name|steer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|extended_func_num
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
return|return
name|PCI_SLOT
argument_list|(
name|pdev
operator|->
name|devfn
argument_list|)
operator|*
literal|8
operator|+
name|PCI_FUNC
argument_list|(
name|pdev
operator|->
name|devfn
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MLX4_OWNER_BASE
value|0x8069c
end_define

begin_define
define|#
directive|define
name|MLX4_OWNER_SIZE
value|4
end_define

begin_function
specifier|static
name|int
name|mlx4_get_ownership
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|void
name|__iomem
modifier|*
name|owner
decl_stmt|;
name|u32
name|ret
decl_stmt|;
if|if
condition|(
name|pci_channel_offline
argument_list|(
name|dev
operator|->
name|pdev
argument_list|)
condition|)
return|return
operator|-
name|EIO
return|;
name|owner
operator|=
name|ioremap
argument_list|(
name|pci_resource_start
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|0
argument_list|)
operator|+
name|MLX4_OWNER_BASE
argument_list|,
name|MLX4_OWNER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|owner
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to obtain ownership bit\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|ret
operator|=
name|readl
argument_list|(
name|owner
argument_list|)
expr_stmt|;
name|iounmap
argument_list|(
name|owner
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
operator|!
operator|!
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_free_ownership
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
name|void
name|__iomem
modifier|*
name|owner
decl_stmt|;
if|if
condition|(
name|pci_channel_offline
argument_list|(
name|dev
operator|->
name|pdev
argument_list|)
condition|)
return|return;
name|owner
operator|=
name|ioremap
argument_list|(
name|pci_resource_start
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|0
argument_list|)
operator|+
name|MLX4_OWNER_BASE
argument_list|,
name|MLX4_OWNER_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|owner
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to obtain ownership bit\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|writel
argument_list|(
literal|0
argument_list|,
name|owner
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
name|iounmap
argument_list|(
name|owner
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|__mlx4_init_one
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|int
name|pci_dev_data
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|dev
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|port
decl_stmt|;
name|int
name|nvfs
decl_stmt|,
name|prb_vf
decl_stmt|;
name|pr_info
argument_list|(
name|DRV_NAME
literal|": Initializing %s\n"
argument_list|,
name|pci_name
argument_list|(
name|pdev
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|pci_enable_device
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Cannot enable PCI device, "
literal|"aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|mlx4_get_val
argument_list|(
name|num_vfs
operator|.
name|dbdf2val
operator|.
name|tbl
argument_list|,
name|pci_physfn
argument_list|(
name|pdev
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|nvfs
argument_list|)
expr_stmt|;
name|mlx4_get_val
argument_list|(
name|probe_vf
operator|.
name|dbdf2val
operator|.
name|tbl
argument_list|,
name|pci_physfn
argument_list|(
name|pdev
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|prb_vf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvfs
operator|>
name|MLX4_MAX_NUM_VF
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"There are more VF's (%d) than allowed(%d)\n"
argument_list|,
name|nvfs
argument_list|,
name|MLX4_MAX_NUM_VF
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|nvfs
operator|<
literal|0
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"num_vfs module parameter cannot be negative\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* 	 * Check for BARs. 	 */
if|if
condition|(
operator|!
operator|(
name|pci_dev_data
operator|&
name|MLX4_PCI_DEV_IS_VF
operator|)
operator|&&
operator|!
operator|(
name|pci_resource_flags
argument_list|(
name|pdev
argument_list|,
literal|0
argument_list|)
operator|&
name|IORESOURCE_MEM
operator|)
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Missing DCS, aborting."
literal|"(driver_data: 0x%x, pci_resource_flags(pdev, 0):0x%x)\n"
argument_list|,
name|pci_dev_data
argument_list|,
name|pci_resource_flags
argument_list|(
name|pdev
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|err_disable_pdev
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|pci_resource_flags
argument_list|(
name|pdev
argument_list|,
literal|2
argument_list|)
operator|&
name|IORESOURCE_MEM
operator|)
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Missing UAR, aborting.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|err_disable_pdev
goto|;
block|}
name|err
operator|=
name|pci_request_regions
argument_list|(
name|pdev
argument_list|,
name|DRV_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Couldn't get PCI resources, aborting\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_disable_pdev
goto|;
block|}
name|pci_set_master
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|err
operator|=
name|pci_set_dma_mask
argument_list|(
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|64
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_warn
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Warning: couldn't set 64-bit PCI DMA mask.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|pci_set_dma_mask
argument_list|(
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Can't set PCI DMA mask, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_release_regions
goto|;
block|}
block|}
name|err
operator|=
name|pci_set_consistent_dma_mask
argument_list|(
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|64
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_warn
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Warning: couldn't set 64-bit "
literal|"consistent PCI DMA mask.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|pci_set_consistent_dma_mask
argument_list|(
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Can't set consistent PCI DMA mask, "
literal|"aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_release_regions
goto|;
block|}
block|}
comment|/* Allow large DMA segments, up to the firmware limit of 1 GB */
name|dma_set_max_seg_size
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|1024
operator|*
literal|1024
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|priv
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|priv
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Device struct alloc failed, "
literal|"aborting.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_release_regions
goto|;
block|}
name|dev
operator|=
operator|&
name|priv
operator|->
name|dev
expr_stmt|;
name|dev
operator|->
name|pdev
operator|=
name|pdev
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|dev_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|ctx_list
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|priv
operator|->
name|ctx_lock
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|priv
operator|->
name|port_mutex
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|pgdir_list
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|priv
operator|->
name|pgdir_mutex
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|priv
operator|->
name|bf_list
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|priv
operator|->
name|bf_mutex
argument_list|)
expr_stmt|;
name|dev
operator|->
name|rev_id
operator|=
name|pdev
operator|->
name|revision
expr_stmt|;
name|dev
operator|->
name|numa_node
operator|=
name|dev_to_node
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|)
expr_stmt|;
comment|/* Detect if this device is a virtual function */
if|if
condition|(
name|pci_dev_data
operator|&
name|MLX4_PCI_DEV_IS_VF
condition|)
block|{
comment|/* When acting as pf, we normally skip vfs unless explicitly 		 * requested to probe them. */
if|if
condition|(
name|nvfs
operator|&&
name|extended_func_num
argument_list|(
name|pdev
argument_list|)
operator|>
name|prb_vf
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Skipping virtual function:%d\n"
argument_list|,
name|extended_func_num
argument_list|(
name|pdev
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|err_free_dev
goto|;
block|}
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Detected virtual function - running in slave mode\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator||=
name|MLX4_FLAG_SLAVE
expr_stmt|;
block|}
else|else
block|{
comment|/* We reset the device and enable SRIOV only for physical 		 * devices.  Try to claim ownership on the device; 		 * if already taken, skip -- do not allow multiple PFs */
name|err
operator|=
name|mlx4_get_ownership
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|<
literal|0
condition|)
goto|goto
name|err_free_dev
goto|;
else|else
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Multiple PFs not yet supported."
literal|" Skipping PF.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_free_dev
goto|;
block|}
block|}
if|if
condition|(
name|nvfs
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Enabling SR-IOV with %d VFs\n"
argument_list|,
name|nvfs
argument_list|)
expr_stmt|;
name|err
operator|=
name|pci_enable_sriov
argument_list|(
name|pdev
argument_list|,
name|nvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to enable SR-IOV, continuing without SR-IOV (err = %d).\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Running in master mode\n"
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator||=
name|MLX4_FLAG_SRIOV
operator||
name|MLX4_FLAG_MASTER
expr_stmt|;
name|dev
operator|->
name|num_vfs
operator|=
name|nvfs
expr_stmt|;
block|}
block|}
name|atomic_set
argument_list|(
operator|&
name|priv
operator|->
name|opreq_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INIT_WORK
argument_list|(
operator|&
name|priv
operator|->
name|opreq_task
argument_list|,
name|mlx4_opreq_action
argument_list|)
expr_stmt|;
comment|/* 		 * Now reset the HCA before we touch the PCI capabilities or 		 * attempt a firmware command, since a boot ROM may have left 		 * the HCA in an undefined state. 		 */
name|err
operator|=
name|mlx4_reset
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to reset HCA, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_sriov
goto|;
block|}
block|}
name|slave_start
label|:
name|err
operator|=
name|mlx4_cmd_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to init command interface, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_sriov
goto|;
block|}
comment|/* In slave functions, the communication channel must be initialized 	 * before posting commands. Also, init num_slaves before calling 	 * mlx4_init_hca */
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
name|dev
operator|->
name|num_slaves
operator|=
name|MLX4_MAX_NUM_SLAVES
expr_stmt|;
else|else
block|{
name|dev
operator|->
name|num_slaves
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|mlx4_multi_func_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to init slave mfunc"
literal|" interface, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_cmd
goto|;
block|}
block|}
block|}
name|err
operator|=
name|mlx4_init_hca
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|==
operator|-
name|EACCES
condition|)
block|{
comment|/* Not primary Physical function 			 * Running in slave mode */
name|mlx4_cmd_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dev
operator|->
name|flags
operator||=
name|MLX4_FLAG_SLAVE
expr_stmt|;
name|dev
operator|->
name|flags
operator|&=
operator|~
name|MLX4_FLAG_MASTER
expr_stmt|;
goto|goto
name|slave_start
goto|;
block|}
else|else
goto|goto
name|err_mfunc
goto|;
block|}
comment|/* In master functions, the communication channel must be initialized 	 * after obtaining its address from fw */
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|err
operator|=
name|mlx4_multi_func_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to init master mfunc"
literal|"interface, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_close
goto|;
block|}
block|}
name|err
operator|=
name|mlx4_alloc_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_master_mfunc
goto|;
name|priv
operator|->
name|msix_ctl
operator|.
name|pool_bm
operator|=
literal|0
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|priv
operator|->
name|msix_ctl
operator|.
name|pool_lock
argument_list|)
expr_stmt|;
name|mlx4_enable_msi_x
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* no MSIX and no shared IRQ */
if|if
condition|(
operator|!
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
operator|&&
operator|!
name|dev
operator|->
name|caps
operator|.
name|comp_pool
condition|)
block|{
name|err
operator|=
operator|-
name|ENOSPC
expr_stmt|;
goto|goto
name|err_free_eq
goto|;
block|}
if|if
condition|(
operator|(
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_MSI_X
operator|)
condition|)
block|{
name|err
operator|=
operator|-
name|ENOSYS
expr_stmt|;
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"INTx is not supported in multi-function mode."
literal|" aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free_eq
goto|;
block|}
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|err
operator|=
name|mlx4_init_steering
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_free_eq
goto|;
block|}
name|err
operator|=
name|mlx4_setup_hca
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
operator|-
name|EBUSY
operator|&&
operator|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_MSI_X
operator|)
operator|&&
operator|!
name|mlx4_is_mfunc
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|dev
operator|->
name|flags
operator|&=
operator|~
name|MLX4_FLAG_MSI_X
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|num_comp_vectors
operator|=
literal|1
expr_stmt|;
name|dev
operator|->
name|caps
operator|.
name|comp_pool
operator|=
literal|0
expr_stmt|;
name|pci_disable_msix
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_setup_hca
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
goto|goto
name|err_steer
goto|;
name|mlx4_init_quotas
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|port
operator|=
literal|1
init|;
name|port
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
name|err
operator|=
name|mlx4_init_port_info
argument_list|(
name|dev
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_port
goto|;
block|}
name|err
operator|=
name|mlx4_register_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_port
goto|;
name|mlx4_request_modules
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_sense_init
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_start_sense
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|priv
operator|->
name|pci_dev_data
operator|=
name|pci_dev_data
expr_stmt|;
name|pci_set_drvdata
argument_list|(
name|pdev
argument_list|,
name|dev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_port
label|:
for|for
control|(
operator|--
name|port
init|;
name|port
operator|>=
literal|1
condition|;
operator|--
name|port
control|)
name|mlx4_cleanup_port_info
argument_list|(
operator|&
name|priv
operator|->
name|port
index|[
name|port
index|]
argument_list|)
expr_stmt|;
name|mlx4_cleanup_counters_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_qp_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_srq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_cq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cmd_use_polling
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_mcg_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_mr_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_xrcd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_pd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_uar_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_steer
label|:
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_clear_steering
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_free_eq
label|:
name|mlx4_free_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_master_mfunc
label|:
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|mlx4_free_resource_tracker
argument_list|(
name|dev
argument_list|,
name|RES_TR_FREE_STRUCTS_ONLY
argument_list|)
expr_stmt|;
name|mlx4_multi_func_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
argument_list|)
expr_stmt|;
block|}
name|err_close
label|:
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_MSI_X
condition|)
name|pci_disable_msix
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|mlx4_close_hca
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_mfunc
label|:
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_multi_func_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_cmd
label|:
name|mlx4_cmd_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_sriov
label|:
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_SRIOV
condition|)
name|pci_disable_sriov
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_free_ownership
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_free_dev
label|:
name|kfree
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|err_release_regions
label|:
name|pci_release_regions
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|err_disable_pdev
label|:
name|pci_disable_device
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|pci_set_drvdata
argument_list|(
name|pdev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__devinit
name|mlx4_init_one
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
specifier|const
name|struct
name|pci_device_id
modifier|*
name|id
parameter_list|)
block|{
name|printk_once
argument_list|(
name|KERN_INFO
literal|"%s"
argument_list|,
name|mlx4_version
argument_list|)
expr_stmt|;
return|return
name|__mlx4_init_one
argument_list|(
name|pdev
argument_list|,
name|id
operator|->
name|driver_data
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_remove_one
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|p
decl_stmt|;
if|if
condition|(
name|dev
condition|)
block|{
comment|/* in SRIOV it is not allowed to unload the pf's 		 * driver while there are alive vf's */
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|mlx4_how_many_lives_vf
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"Removing PF when there are assigned VF's !!!\n"
argument_list|)
expr_stmt|;
block|}
name|mlx4_stop_sense
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_unregister_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|1
init|;
name|p
operator|<=
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|p
operator|++
control|)
block|{
name|mlx4_cleanup_port_info
argument_list|(
operator|&
name|priv
operator|->
name|port
index|[
name|p
index|]
argument_list|)
expr_stmt|;
name|mlx4_CLOSE_PORT
argument_list|(
name|dev
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_free_resource_tracker
argument_list|(
name|dev
argument_list|,
name|RES_TR_FREE_SLAVES_ONLY
argument_list|)
expr_stmt|;
name|mlx4_cleanup_counters_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_qp_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_srq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_cq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cmd_use_polling
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_mcg_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_mr_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_xrcd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cleanup_pd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_free_resource_tracker
argument_list|(
name|dev
argument_list|,
name|RES_TR_FREE_STRUCTS_ONLY
argument_list|)
expr_stmt|;
name|iounmap
argument_list|(
name|priv
operator|->
name|kar
argument_list|)
expr_stmt|;
name|mlx4_uar_free
argument_list|(
name|dev
argument_list|,
operator|&
name|priv
operator|->
name|driver_uar
argument_list|)
expr_stmt|;
name|mlx4_cleanup_uar_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_clear_steering
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_free_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_multi_func_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_close_hca
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_multi_func_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mlx4_cmd_cleanup
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_MSI_X
condition|)
name|pci_disable_msix
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|flags
operator|&
name|MLX4_FLAG_SRIOV
condition|)
block|{
name|mlx4_warn
argument_list|(
name|dev
argument_list|,
literal|"Disabling SR-IOV\n"
argument_list|)
expr_stmt|;
name|pci_disable_sriov
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mlx4_is_slave
argument_list|(
name|dev
argument_list|)
condition|)
name|mlx4_free_ownership
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|priv
argument_list|)
expr_stmt|;
name|pci_release_regions
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|pci_disable_device
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|pci_set_drvdata
argument_list|(
name|pdev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|restore_current_port_types
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|enum
name|mlx4_port_type
modifier|*
name|types
parameter_list|,
name|enum
name|mlx4_port_type
modifier|*
name|poss_types
parameter_list|)
block|{
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|,
name|i
decl_stmt|;
name|mlx4_stop_sense
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|priv
operator|->
name|port_mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
name|dev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|poss_types
index|[
name|i
index|]
expr_stmt|;
name|err
operator|=
name|mlx4_change_port_types
argument_list|(
name|dev
argument_list|,
name|types
argument_list|)
expr_stmt|;
name|mlx4_start_sense
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|priv
operator|->
name|port_mutex
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_restart_one
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_priv
modifier|*
name|priv
init|=
name|mlx4_priv
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|enum
name|mlx4_port_type
name|curr_type
index|[
name|MLX4_MAX_PORTS
index|]
decl_stmt|;
name|enum
name|mlx4_port_type
name|poss_type
index|[
name|MLX4_MAX_PORTS
index|]
decl_stmt|;
name|int
name|pci_dev_data
decl_stmt|,
name|err
decl_stmt|,
name|i
decl_stmt|;
name|pci_dev_data
operator|=
name|priv
operator|->
name|pci_dev_data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|curr_type
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|port_type
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|poss_type
index|[
name|i
index|]
operator|=
name|dev
operator|->
name|caps
operator|.
name|possible_type
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
name|mlx4_remove_one
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|err
operator|=
name|__mlx4_init_one
argument_list|(
name|pdev
argument_list|,
name|pci_dev_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|dev
operator|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|err
operator|=
name|restore_current_port_types
argument_list|(
name|dev
argument_list|,
name|curr_type
argument_list|,
name|poss_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mlx4_err
argument_list|(
name|dev
argument_list|,
literal|"mlx4_restart_one: could not restore original port types (%d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|DEFINE_PCI_DEVICE_TABLE
argument_list|(
name|mlx4_pci_table
argument_list|)
operator|=
block|{
comment|/* MT25408 "Hermon" SDR */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x6340
argument_list|)
block|,
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25408 "Hermon" DDR */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x634a
argument_list|)
block|,
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25408 "Hermon" QDR */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x6354
argument_list|)
block|,
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25408 "Hermon" DDR PCIe gen2 */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x6732
argument_list|)
block|,
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25408 "Hermon" QDR PCIe gen2 */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x673c
argument_list|)
block|,
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25408 "Hermon" EN 10GigE */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x6368
argument_list|)
block|,
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25408 "Hermon" EN 10GigE PCIe gen2 */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x6750
argument_list|)
block|,
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25458 ConnectX EN 10GBASE-T 10GigE */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x6372
argument_list|)
block|,
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25458 ConnectX EN 10GBASE-T+Gen2 10GigE */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x675a
argument_list|)
block|,
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT26468 ConnectX EN 10GigE PCIe gen2*/
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x6764
argument_list|)
block|,
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT26438 ConnectX EN 40GigE PCIe gen2 5GT/s */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x6746
argument_list|)
block|,
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT26478 ConnectX2 40GigE PCIe gen2 */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x676e
argument_list|)
block|,
name|MLX4_PCI_DEV_FORCE_SENSE_PORT
block|}
block|,
comment|/* MT25400 Family [ConnectX-2 Virtual Function] */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x1002
argument_list|)
block|,
name|MLX4_PCI_DEV_IS_VF
block|}
block|,
comment|/* MT27500 Family [ConnectX-3] */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x1003
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27500 Family [ConnectX-3 Virtual Function] */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x1004
argument_list|)
block|,
name|MLX4_PCI_DEV_IS_VF
block|}
block|,
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x1005
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27510 Family */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x1006
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27511 Family */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x1007
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27520 Family */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x1008
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27521 Family */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x1009
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27530 Family */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x100a
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27531 Family */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x100b
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27540 Family */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x100c
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27541 Family */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x100d
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27550 Family */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x100e
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27551 Family */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x100f
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27560 Family */
block|{
name|PCI_VDEVICE
argument_list|(
name|MELLANOX
argument_list|,
literal|0x1010
argument_list|)
block|,
literal|0
block|}
block|,
comment|/* MT27561 Family */
block|{
literal|0
block|, }
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEVICE_TABLE
argument_list|(
name|pci
argument_list|,
name|mlx4_pci_table
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|pci_ers_result_t
name|mlx4_pci_err_detected
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|pci_channel_state_t
name|state
parameter_list|)
block|{
name|mlx4_remove_one
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
return|return
name|state
operator|==
name|pci_channel_io_perm_failure
condition|?
name|PCI_ERS_RESULT_DISCONNECT
else|:
name|PCI_ERS_RESULT_NEED_RESET
return|;
block|}
end_function

begin_function
specifier|static
name|pci_ers_result_t
name|mlx4_pci_slot_reset
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|int
name|ret
init|=
name|__mlx4_init_one
argument_list|(
name|pdev
argument_list|,
literal|0
argument_list|)
decl_stmt|;
return|return
name|ret
condition|?
name|PCI_ERS_RESULT_DISCONNECT
else|:
name|PCI_ERS_RESULT_RECOVERED
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|pci_error_handlers
name|mlx4_err_handler
init|=
block|{
operator|.
name|error_detected
operator|=
name|mlx4_pci_err_detected
block|,
operator|.
name|slot_reset
operator|=
name|mlx4_pci_slot_reset
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|suspend
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|pm_message_t
name|state
parameter_list|)
block|{
name|mlx4_remove_one
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|resume
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
return|return
name|__mlx4_init_one
argument_list|(
name|pdev
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|pci_driver
name|mlx4_driver
init|=
block|{
operator|.
name|name
operator|=
name|DRV_NAME
block|,
operator|.
name|id_table
operator|=
name|mlx4_pci_table
block|,
operator|.
name|probe
operator|=
name|mlx4_init_one
block|,
operator|.
name|remove
operator|=
name|__devexit_p
argument_list|(
name|mlx4_remove_one
argument_list|)
block|,
operator|.
name|suspend
operator|=
name|suspend
block|,
operator|.
name|resume
operator|=
name|resume
block|,
operator|.
name|err_handler
operator|=
operator|&
name|mlx4_err_handler
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|__init
name|mlx4_verify_params
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|update_defaults
argument_list|(
operator|&
name|port_type_array
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|INVALID_STR
condition|)
block|{
if|if
condition|(
name|mlx4_fill_dbdf2val_tbl
argument_list|(
operator|&
name|port_type_array
operator|.
name|dbdf2val
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|INVALID_DATA
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|status
operator|=
name|update_defaults
argument_list|(
operator|&
name|num_vfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|INVALID_STR
condition|)
block|{
if|if
condition|(
name|mlx4_fill_dbdf2val_tbl
argument_list|(
operator|&
name|num_vfs
operator|.
name|dbdf2val
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|INVALID_DATA
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|status
operator|=
name|update_defaults
argument_list|(
operator|&
name|probe_vf
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|INVALID_STR
condition|)
block|{
if|if
condition|(
name|mlx4_fill_dbdf2val_tbl
argument_list|(
operator|&
name|probe_vf
operator|.
name|dbdf2val
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|INVALID_DATA
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|msi_x
operator|<
literal|0
condition|)
block|{
name|pr_warn
argument_list|(
literal|"mlx4_core: bad msi_x: %d\n"
argument_list|,
name|msi_x
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|log_num_mac
operator|<
literal|0
operator|)
operator|||
operator|(
name|log_num_mac
operator|>
literal|7
operator|)
condition|)
block|{
name|pr_warning
argument_list|(
literal|"mlx4_core: bad num_mac: %d\n"
argument_list|,
name|log_num_mac
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|log_num_vlan
operator|!=
literal|0
condition|)
name|pr_warning
argument_list|(
literal|"mlx4_core: log_num_vlan - obsolete module param, using %d\n"
argument_list|,
name|MLX4_LOG_NUM_VLANS
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_set_4k_mtu
operator|!=
operator|-
literal|1
condition|)
name|pr_warning
argument_list|(
literal|"mlx4_core: set_4k_mtu - obsolete module param\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|log_mtts_per_seg
operator|<
literal|0
operator|)
operator|||
operator|(
name|log_mtts_per_seg
operator|>
literal|7
operator|)
condition|)
block|{
name|pr_warning
argument_list|(
literal|"mlx4_core: bad log_mtts_per_seg: %d\n"
argument_list|,
name|log_mtts_per_seg
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|mlx4_log_num_mgm_entry_size
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|mlx4_log_num_mgm_entry_size
operator|<
name|MLX4_MIN_MGM_LOG_ENTRY_SIZE
operator|||
name|mlx4_log_num_mgm_entry_size
operator|>
name|MLX4_MAX_MGM_LOG_ENTRY_SIZE
operator|)
condition|)
block|{
name|pr_warning
argument_list|(
literal|"mlx4_core: mlx4_log_num_mgm_entry_size (%d) not "
literal|"in legal range (-1 or %d..%d)\n"
argument_list|,
name|mlx4_log_num_mgm_entry_size
argument_list|,
name|MLX4_MIN_MGM_LOG_ENTRY_SIZE
argument_list|,
name|MLX4_MAX_MGM_LOG_ENTRY_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|mod_param_profile
operator|.
name|num_qp
operator|<
literal|18
operator|||
name|mod_param_profile
operator|.
name|num_qp
operator|>
literal|23
condition|)
block|{
name|pr_warning
argument_list|(
literal|"mlx4_core: bad log_num_qp: %d\n"
argument_list|,
name|mod_param_profile
operator|.
name|num_qp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|mod_param_profile
operator|.
name|num_srq
operator|<
literal|10
condition|)
block|{
name|pr_warning
argument_list|(
literal|"mlx4_core: too low log_num_srq: %d\n"
argument_list|,
name|mod_param_profile
operator|.
name|num_srq
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|mod_param_profile
operator|.
name|num_cq
operator|<
literal|10
condition|)
block|{
name|pr_warning
argument_list|(
literal|"mlx4_core: too low log_num_cq: %d\n"
argument_list|,
name|mod_param_profile
operator|.
name|num_cq
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|mod_param_profile
operator|.
name|num_mpt
operator|<
literal|10
condition|)
block|{
name|pr_warning
argument_list|(
literal|"mlx4_core: too low log_num_mpt: %d\n"
argument_list|,
name|mod_param_profile
operator|.
name|num_mpt
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|mod_param_profile
operator|.
name|num_mtt_segs
operator|&&
name|mod_param_profile
operator|.
name|num_mtt_segs
operator|<
literal|15
condition|)
block|{
name|pr_warning
argument_list|(
literal|"mlx4_core: too low log_num_mtt: %d\n"
argument_list|,
name|mod_param_profile
operator|.
name|num_mtt_segs
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|mod_param_profile
operator|.
name|num_mtt_segs
operator|>
name|MLX4_MAX_LOG_NUM_MTT
condition|)
block|{
name|pr_warning
argument_list|(
literal|"mlx4_core: too high log_num_mtt: %d\n"
argument_list|,
name|mod_param_profile
operator|.
name|num_mtt_segs
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__init
name|mlx4_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|mlx4_verify_params
argument_list|()
condition|)
return|return
operator|-
name|EINVAL
return|;
name|mlx4_catas_init
argument_list|()
expr_stmt|;
name|mlx4_wq
operator|=
name|create_singlethread_workqueue
argument_list|(
literal|"mlx4"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_wq
condition|)
return|return
operator|-
name|ENOMEM
return|;
if|if
condition|(
name|enable_sys_tune
condition|)
name|sys_tune_init
argument_list|()
expr_stmt|;
name|ret
operator|=
name|pci_register_driver
argument_list|(
operator|&
name|mlx4_driver
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
return|return
literal|0
return|;
name|err
label|:
if|if
condition|(
name|enable_sys_tune
condition|)
name|sys_tune_fini
argument_list|()
expr_stmt|;
name|destroy_workqueue
argument_list|(
name|mlx4_wq
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__exit
name|mlx4_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|enable_sys_tune
condition|)
name|sys_tune_fini
argument_list|()
expr_stmt|;
name|pci_unregister_driver
argument_list|(
operator|&
name|mlx4_driver
argument_list|)
expr_stmt|;
name|destroy_workqueue
argument_list|(
name|mlx4_wq
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|module_init_order
argument_list|(
name|mlx4_init
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_exit
argument_list|(
name|mlx4_cleanup
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|mlx4_evhand
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|event
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|mlx4_mod
init|=
block|{
operator|.
name|name
operator|=
literal|"mlx4"
block|,
operator|.
name|evhand
operator|=
name|mlx4_evhand
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|mlx4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|mlx4
argument_list|,
name|mlx4_mod
argument_list|,
name|SI_SUB_OFED_PREINIT
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|mlx4
argument_list|,
name|linuxkpi
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

