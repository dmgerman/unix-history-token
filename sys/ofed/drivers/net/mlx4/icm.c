begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2005, 2006, 2007, 2008, 2014 Mellanox Technologies. All rights reserved.  * Copyright (c) 2006, 2007 Cisco Systems, Inc.  All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<linux/errno.h>
end_include

begin_include
include|#
directive|include
file|<linux/mm.h>
end_include

begin_include
include|#
directive|include
file|<linux/scatterlist.h>
end_include

begin_include
include|#
directive|include
file|<linux/slab.h>
end_include

begin_include
include|#
directive|include
file|<linux/math64.h>
end_include

begin_include
include|#
directive|include
file|<linux/mlx4/cmd.h>
end_include

begin_include
include|#
directive|include
file|"mlx4.h"
end_include

begin_include
include|#
directive|include
file|"icm.h"
end_include

begin_include
include|#
directive|include
file|"fw.h"
end_include

begin_comment
comment|/*  * We allocate in as big chunks as we can, up to a maximum of 256 KB  * per chunk.  */
end_comment

begin_enum
enum|enum
block|{
name|MLX4_ICM_ALLOC_SIZE
init|=
literal|1
operator|<<
literal|18
block|,
name|MLX4_TABLE_CHUNK_SIZE
init|=
literal|1
operator|<<
literal|18
block|}
enum|;
end_enum

begin_function
specifier|static
name|void
name|mlx4_free_icm_pages
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_icm_chunk
modifier|*
name|chunk
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|chunk
operator|->
name|nsg
operator|>
literal|0
condition|)
name|pci_unmap_sg
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|chunk
operator|->
name|mem
argument_list|,
name|chunk
operator|->
name|npages
argument_list|,
name|PCI_DMA_BIDIRECTIONAL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chunk
operator|->
name|npages
condition|;
operator|++
name|i
control|)
name|__free_pages
argument_list|(
name|sg_page
argument_list|(
operator|&
name|chunk
operator|->
name|mem
index|[
name|i
index|]
argument_list|)
argument_list|,
name|get_order
argument_list|(
name|chunk
operator|->
name|mem
index|[
name|i
index|]
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_free_icm_coherent
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_icm_chunk
modifier|*
name|chunk
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chunk
operator|->
name|npages
condition|;
operator|++
name|i
control|)
name|dma_free_coherent
argument_list|(
operator|&
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|chunk
operator|->
name|mem
index|[
name|i
index|]
operator|.
name|length
argument_list|,
name|lowmem_page_address
argument_list|(
name|sg_page
argument_list|(
operator|&
name|chunk
operator|->
name|mem
index|[
name|i
index|]
argument_list|)
argument_list|)
argument_list|,
name|sg_dma_address
argument_list|(
operator|&
name|chunk
operator|->
name|mem
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mlx4_free_icm
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_icm
modifier|*
name|icm
parameter_list|,
name|int
name|coherent
parameter_list|)
block|{
name|struct
name|mlx4_icm_chunk
modifier|*
name|chunk
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
operator|!
name|icm
condition|)
return|return;
name|list_for_each_entry_safe
argument_list|(
argument|chunk
argument_list|,
argument|tmp
argument_list|,
argument|&icm->chunk_list
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|coherent
condition|)
name|mlx4_free_icm_coherent
argument_list|(
name|dev
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
else|else
name|mlx4_free_icm_pages
argument_list|(
name|dev
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|chunk
argument_list|)
expr_stmt|;
block|}
name|kfree
argument_list|(
name|icm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_alloc_icm_pages
parameter_list|(
name|struct
name|scatterlist
modifier|*
name|mem
parameter_list|,
name|int
name|order
parameter_list|,
name|gfp_t
name|gfp_mask
parameter_list|,
name|int
name|node
parameter_list|)
block|{
name|struct
name|page
modifier|*
name|page
decl_stmt|;
name|page
operator|=
name|alloc_pages_node
argument_list|(
name|node
argument_list|,
name|gfp_mask
argument_list|,
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|page
condition|)
block|{
name|page
operator|=
name|alloc_pages
argument_list|(
name|gfp_mask
argument_list|,
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|page
condition|)
return|return
operator|-
name|ENOMEM
return|;
block|}
name|sg_set_page
argument_list|(
name|mem
argument_list|,
name|page
argument_list|,
name|PAGE_SIZE
operator|<<
name|order
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_alloc_icm_coherent
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|mem
parameter_list|,
name|int
name|order
parameter_list|,
name|gfp_t
name|gfp_mask
parameter_list|)
block|{
name|void
modifier|*
name|buf
init|=
name|dma_alloc_coherent
argument_list|(
name|dev
argument_list|,
name|PAGE_SIZE
operator|<<
name|order
argument_list|,
operator|&
name|sg_dma_address
argument_list|(
name|mem
argument_list|)
argument_list|,
name|gfp_mask
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|sg_set_buf
argument_list|(
name|mem
argument_list|,
name|buf
argument_list|,
name|PAGE_SIZE
operator|<<
name|order
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|mem
operator|->
name|offset
argument_list|)
expr_stmt|;
name|sg_dma_len
argument_list|(
name|mem
argument_list|)
operator|=
name|PAGE_SIZE
operator|<<
name|order
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|mlx4_icm
modifier|*
name|mlx4_alloc_icm
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|int
name|npages
parameter_list|,
name|gfp_t
name|gfp_mask
parameter_list|,
name|int
name|coherent
parameter_list|)
block|{
name|struct
name|mlx4_icm
modifier|*
name|icm
decl_stmt|;
name|struct
name|mlx4_icm_chunk
modifier|*
name|chunk
init|=
name|NULL
decl_stmt|;
name|int
name|cur_order
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* We use sg_set_buf for coherent allocs, which assumes low memory */
name|BUG_ON
argument_list|(
name|coherent
operator|&&
operator|(
name|gfp_mask
operator|&
name|__GFP_HIGHMEM
operator|)
argument_list|)
expr_stmt|;
name|icm
operator|=
name|kmalloc_node
argument_list|(
sizeof|sizeof
expr|*
name|icm
argument_list|,
name|gfp_mask
operator|&
operator|~
operator|(
name|__GFP_HIGHMEM
operator||
name|__GFP_NOWARN
operator|)
argument_list|,
name|dev
operator|->
name|numa_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|icm
condition|)
block|{
name|icm
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|icm
argument_list|,
name|gfp_mask
operator|&
operator|~
operator|(
name|__GFP_HIGHMEM
operator||
name|__GFP_NOWARN
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|icm
condition|)
return|return
name|NULL
return|;
block|}
name|icm
operator|->
name|refcount
operator|=
literal|0
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|icm
operator|->
name|chunk_list
argument_list|)
expr_stmt|;
name|cur_order
operator|=
name|get_order
argument_list|(
name|MLX4_ICM_ALLOC_SIZE
argument_list|)
expr_stmt|;
while|while
condition|(
name|npages
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|chunk
condition|)
block|{
name|chunk
operator|=
name|kmalloc_node
argument_list|(
sizeof|sizeof
expr|*
name|chunk
argument_list|,
name|gfp_mask
operator|&
operator|~
operator|(
name|__GFP_HIGHMEM
operator||
name|__GFP_NOWARN
operator|)
argument_list|,
name|dev
operator|->
name|numa_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chunk
condition|)
block|{
name|chunk
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|chunk
argument_list|,
name|gfp_mask
operator|&
operator|~
operator|(
name|__GFP_HIGHMEM
operator||
name|__GFP_NOWARN
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chunk
condition|)
goto|goto
name|fail
goto|;
block|}
name|sg_init_table
argument_list|(
name|chunk
operator|->
name|mem
argument_list|,
name|MLX4_ICM_CHUNK_LEN
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|npages
operator|=
literal|0
expr_stmt|;
name|chunk
operator|->
name|nsg
operator|=
literal|0
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|chunk
operator|->
name|list
argument_list|,
operator|&
name|icm
operator|->
name|chunk_list
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
operator|<<
name|cur_order
operator|>
name|npages
condition|)
operator|--
name|cur_order
expr_stmt|;
if|if
condition|(
name|coherent
condition|)
name|ret
operator|=
name|mlx4_alloc_icm_coherent
argument_list|(
operator|&
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
operator|&
name|chunk
operator|->
name|mem
index|[
name|chunk
operator|->
name|npages
index|]
argument_list|,
name|cur_order
argument_list|,
name|gfp_mask
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|mlx4_alloc_icm_pages
argument_list|(
operator|&
name|chunk
operator|->
name|mem
index|[
name|chunk
operator|->
name|npages
index|]
argument_list|,
name|cur_order
argument_list|,
name|gfp_mask
argument_list|,
name|dev
operator|->
name|numa_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
operator|--
name|cur_order
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
else|else
continue|continue;
block|}
operator|++
name|chunk
operator|->
name|npages
expr_stmt|;
if|if
condition|(
name|coherent
condition|)
operator|++
name|chunk
operator|->
name|nsg
expr_stmt|;
elseif|else
if|if
condition|(
name|chunk
operator|->
name|npages
operator|==
name|MLX4_ICM_CHUNK_LEN
condition|)
block|{
name|chunk
operator|->
name|nsg
operator|=
name|pci_map_sg
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|chunk
operator|->
name|mem
argument_list|,
name|chunk
operator|->
name|npages
argument_list|,
name|PCI_DMA_BIDIRECTIONAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|->
name|nsg
operator|<=
literal|0
condition|)
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|chunk
operator|->
name|npages
operator|==
name|MLX4_ICM_CHUNK_LEN
condition|)
name|chunk
operator|=
name|NULL
expr_stmt|;
name|npages
operator|-=
literal|1
operator|<<
name|cur_order
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|coherent
operator|&&
name|chunk
condition|)
block|{
name|chunk
operator|->
name|nsg
operator|=
name|pci_map_sg
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|chunk
operator|->
name|mem
argument_list|,
name|chunk
operator|->
name|npages
argument_list|,
name|PCI_DMA_BIDIRECTIONAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|->
name|nsg
operator|<=
literal|0
condition|)
goto|goto
name|fail
goto|;
block|}
return|return
name|icm
return|;
name|fail
label|:
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|icm
argument_list|,
name|coherent
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_MAP_ICM
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_icm
modifier|*
name|icm
parameter_list|,
name|u64
name|virt
parameter_list|)
block|{
return|return
name|mlx4_map_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_CMD_MAP_ICM
argument_list|,
name|icm
argument_list|,
name|virt
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_UNMAP_ICM
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|virt
parameter_list|,
name|u32
name|page_count
parameter_list|)
block|{
return|return
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
name|virt
argument_list|,
name|page_count
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_UNMAP_ICM
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_MAP_ICM_AUX
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_icm
modifier|*
name|icm
parameter_list|)
block|{
return|return
name|mlx4_map_cmd
argument_list|(
name|dev
argument_list|,
name|MLX4_CMD_MAP_ICM_AUX
argument_list|,
name|icm
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_UNMAP_ICM_AUX
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|)
block|{
return|return
name|mlx4_cmd
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|MLX4_CMD_UNMAP_ICM_AUX
argument_list|,
name|MLX4_CMD_TIME_CLASS_B
argument_list|,
name|MLX4_CMD_NATIVE
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_table_get
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_icm_table
modifier|*
name|table
parameter_list|,
name|u32
name|obj
parameter_list|)
block|{
name|u32
name|i
init|=
operator|(
name|obj
operator|&
operator|(
name|table
operator|->
name|num_obj
operator|-
literal|1
operator|)
operator|)
operator|/
operator|(
name|MLX4_TABLE_CHUNK_SIZE
operator|/
name|table
operator|->
name|obj_size
operator|)
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|table
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|icm
index|[
name|i
index|]
condition|)
block|{
operator|++
name|table
operator|->
name|icm
index|[
name|i
index|]
operator|->
name|refcount
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|table
operator|->
name|icm
index|[
name|i
index|]
operator|=
name|mlx4_alloc_icm
argument_list|(
name|dev
argument_list|,
name|MLX4_TABLE_CHUNK_SIZE
operator|>>
name|PAGE_SHIFT
argument_list|,
operator|(
name|table
operator|->
name|lowmem
condition|?
name|GFP_KERNEL
else|:
name|GFP_HIGHUSER
operator|)
operator||
name|__GFP_NOWARN
argument_list|,
name|table
operator|->
name|coherent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|->
name|icm
index|[
name|i
index|]
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|mlx4_MAP_ICM
argument_list|(
name|dev
argument_list|,
name|table
operator|->
name|icm
index|[
name|i
index|]
argument_list|,
name|table
operator|->
name|virt
operator|+
operator|(
name|u64
operator|)
name|i
operator|*
name|MLX4_TABLE_CHUNK_SIZE
argument_list|)
condition|)
block|{
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|table
operator|->
name|icm
index|[
name|i
index|]
argument_list|,
name|table
operator|->
name|coherent
argument_list|)
expr_stmt|;
name|table
operator|->
name|icm
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|++
name|table
operator|->
name|icm
index|[
name|i
index|]
operator|->
name|refcount
expr_stmt|;
name|out
label|:
name|mutex_unlock
argument_list|(
operator|&
name|table
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|mlx4_table_put
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_icm_table
modifier|*
name|table
parameter_list|,
name|u32
name|obj
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
name|u64
name|offset
decl_stmt|;
name|i
operator|=
operator|(
name|obj
operator|&
operator|(
name|table
operator|->
name|num_obj
operator|-
literal|1
operator|)
operator|)
operator|/
operator|(
name|MLX4_TABLE_CHUNK_SIZE
operator|/
name|table
operator|->
name|obj_size
operator|)
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|table
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|table
operator|->
name|icm
index|[
name|i
index|]
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
name|offset
operator|=
operator|(
name|u64
operator|)
name|i
operator|*
name|MLX4_TABLE_CHUNK_SIZE
expr_stmt|;
if|if
condition|(
operator|!
name|mlx4_UNMAP_ICM
argument_list|(
name|dev
argument_list|,
name|table
operator|->
name|virt
operator|+
name|offset
argument_list|,
name|MLX4_TABLE_CHUNK_SIZE
operator|/
name|MLX4_ICM_PAGE_SIZE
argument_list|)
condition|)
block|{
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|table
operator|->
name|icm
index|[
name|i
index|]
argument_list|,
name|table
operator|->
name|coherent
argument_list|)
expr_stmt|;
name|table
operator|->
name|icm
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|pr_warn
argument_list|(
literal|"mlx4_core: mlx4_UNMAP_ICM failed.\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_unlock
argument_list|(
operator|&
name|table
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|mlx4_table_find
parameter_list|(
name|struct
name|mlx4_icm_table
modifier|*
name|table
parameter_list|,
name|u32
name|obj
parameter_list|,
name|dma_addr_t
modifier|*
name|dma_handle
parameter_list|)
block|{
name|int
name|offset
decl_stmt|,
name|dma_offset
decl_stmt|,
name|i
decl_stmt|;
name|u64
name|idx
decl_stmt|;
name|struct
name|mlx4_icm_chunk
modifier|*
name|chunk
decl_stmt|;
name|struct
name|mlx4_icm
modifier|*
name|icm
decl_stmt|;
name|struct
name|page
modifier|*
name|page
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|table
operator|->
name|lowmem
condition|)
return|return
name|NULL
return|;
name|mutex_lock
argument_list|(
operator|&
name|table
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|idx
operator|=
call|(
name|u64
call|)
argument_list|(
name|obj
operator|&
operator|(
name|table
operator|->
name|num_obj
operator|-
literal|1
operator|)
argument_list|)
operator|*
name|table
operator|->
name|obj_size
expr_stmt|;
name|icm
operator|=
name|table
operator|->
name|icm
index|[
name|idx
operator|/
name|MLX4_TABLE_CHUNK_SIZE
index|]
expr_stmt|;
name|dma_offset
operator|=
name|offset
operator|=
name|idx
operator|%
name|MLX4_TABLE_CHUNK_SIZE
expr_stmt|;
if|if
condition|(
operator|!
name|icm
condition|)
goto|goto
name|out
goto|;
name|list_for_each_entry
argument_list|(
argument|chunk
argument_list|,
argument|&icm->chunk_list
argument_list|,
argument|list
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chunk
operator|->
name|npages
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|dma_handle
operator|&&
name|dma_offset
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|sg_dma_len
argument_list|(
operator|&
name|chunk
operator|->
name|mem
index|[
name|i
index|]
argument_list|)
operator|>
name|dma_offset
condition|)
operator|*
name|dma_handle
operator|=
name|sg_dma_address
argument_list|(
operator|&
name|chunk
operator|->
name|mem
index|[
name|i
index|]
argument_list|)
operator|+
name|dma_offset
expr_stmt|;
name|dma_offset
operator|-=
name|sg_dma_len
argument_list|(
operator|&
name|chunk
operator|->
name|mem
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * DMA mapping can merge pages but not split them, 			 * so if we found the page, dma_handle has already 			 * been assigned to. 			 */
if|if
condition|(
name|chunk
operator|->
name|mem
index|[
name|i
index|]
operator|.
name|length
operator|>
name|offset
condition|)
block|{
name|page
operator|=
name|sg_page
argument_list|(
operator|&
name|chunk
operator|->
name|mem
index|[
name|i
index|]
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|offset
operator|-=
name|chunk
operator|->
name|mem
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
block|}
block|}
name|out
label|:
name|mutex_unlock
argument_list|(
operator|&
name|table
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
name|page
condition|?
name|lowmem_page_address
argument_list|(
name|page
argument_list|)
operator|+
name|offset
else|:
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|mlx4_table_get_range
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_icm_table
modifier|*
name|table
parameter_list|,
name|u32
name|start
parameter_list|,
name|u32
name|end
parameter_list|)
block|{
name|int
name|inc
init|=
name|MLX4_TABLE_CHUNK_SIZE
operator|/
name|table
operator|->
name|obj_size
decl_stmt|;
name|int
name|err
decl_stmt|;
name|u32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<=
name|end
condition|;
name|i
operator|+=
name|inc
control|)
block|{
name|err
operator|=
name|mlx4_table_get
argument_list|(
name|dev
argument_list|,
name|table
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|fail
goto|;
block|}
return|return
literal|0
return|;
name|fail
label|:
while|while
condition|(
name|i
operator|>
name|start
condition|)
block|{
name|i
operator|-=
name|inc
expr_stmt|;
name|mlx4_table_put
argument_list|(
name|dev
argument_list|,
name|table
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
name|void
name|mlx4_table_put_range
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_icm_table
modifier|*
name|table
parameter_list|,
name|u32
name|start
parameter_list|,
name|u32
name|end
parameter_list|)
block|{
name|u32
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<=
name|end
condition|;
name|i
operator|+=
name|MLX4_TABLE_CHUNK_SIZE
operator|/
name|table
operator|->
name|obj_size
control|)
name|mlx4_table_put
argument_list|(
name|dev
argument_list|,
name|table
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mlx4_init_icm_table
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_icm_table
modifier|*
name|table
parameter_list|,
name|u64
name|virt
parameter_list|,
name|int
name|obj_size
parameter_list|,
name|u64
name|nobj
parameter_list|,
name|int
name|reserved
parameter_list|,
name|int
name|use_lowmem
parameter_list|,
name|int
name|use_coherent
parameter_list|)
block|{
name|int
name|obj_per_chunk
decl_stmt|;
name|int
name|num_icm
decl_stmt|;
name|unsigned
name|chunk_size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u64
name|size
decl_stmt|;
name|obj_per_chunk
operator|=
name|MLX4_TABLE_CHUNK_SIZE
operator|/
name|obj_size
expr_stmt|;
name|num_icm
operator|=
name|div_u64
argument_list|(
operator|(
name|nobj
operator|+
name|obj_per_chunk
operator|-
literal|1
operator|)
argument_list|,
name|obj_per_chunk
argument_list|)
expr_stmt|;
name|table
operator|->
name|icm
operator|=
name|kcalloc
argument_list|(
name|num_icm
argument_list|,
sizeof|sizeof
expr|*
name|table
operator|->
name|icm
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|->
name|icm
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|table
operator|->
name|virt
operator|=
name|virt
expr_stmt|;
name|table
operator|->
name|num_icm
operator|=
name|num_icm
expr_stmt|;
name|table
operator|->
name|num_obj
operator|=
name|nobj
expr_stmt|;
name|table
operator|->
name|obj_size
operator|=
name|obj_size
expr_stmt|;
name|table
operator|->
name|lowmem
operator|=
name|use_lowmem
expr_stmt|;
name|table
operator|->
name|coherent
operator|=
name|use_coherent
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|table
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|u64
operator|)
name|nobj
operator|*
name|obj_size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|*
name|MLX4_TABLE_CHUNK_SIZE
operator|<
name|reserved
operator|*
name|obj_size
condition|;
operator|++
name|i
control|)
block|{
name|chunk_size
operator|=
name|MLX4_TABLE_CHUNK_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|MLX4_TABLE_CHUNK_SIZE
operator|>
name|size
condition|)
name|chunk_size
operator|=
name|PAGE_ALIGN
argument_list|(
name|size
operator|-
name|i
operator|*
name|MLX4_TABLE_CHUNK_SIZE
argument_list|)
expr_stmt|;
name|table
operator|->
name|icm
index|[
name|i
index|]
operator|=
name|mlx4_alloc_icm
argument_list|(
name|dev
argument_list|,
name|chunk_size
operator|>>
name|PAGE_SHIFT
argument_list|,
operator|(
name|use_lowmem
condition|?
name|GFP_KERNEL
else|:
name|GFP_HIGHUSER
operator|)
operator||
name|__GFP_NOWARN
argument_list|,
name|use_coherent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|->
name|icm
index|[
name|i
index|]
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|mlx4_MAP_ICM
argument_list|(
name|dev
argument_list|,
name|table
operator|->
name|icm
index|[
name|i
index|]
argument_list|,
name|virt
operator|+
name|i
operator|*
name|MLX4_TABLE_CHUNK_SIZE
argument_list|)
condition|)
block|{
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|table
operator|->
name|icm
index|[
name|i
index|]
argument_list|,
name|use_coherent
argument_list|)
expr_stmt|;
name|table
operator|->
name|icm
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 		 * Add a reference to this ICM chunk so that it never 		 * gets freed (since it contains reserved firmware objects). 		 */
operator|++
name|table
operator|->
name|icm
index|[
name|i
index|]
operator|->
name|refcount
expr_stmt|;
block|}
return|return
literal|0
return|;
name|err
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_icm
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|table
operator|->
name|icm
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|mlx4_UNMAP_ICM
argument_list|(
name|dev
argument_list|,
name|virt
operator|+
name|i
operator|*
name|MLX4_TABLE_CHUNK_SIZE
argument_list|,
name|MLX4_TABLE_CHUNK_SIZE
operator|/
name|MLX4_ICM_PAGE_SIZE
argument_list|)
condition|)
block|{
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|table
operator|->
name|icm
index|[
name|i
index|]
argument_list|,
name|use_coherent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pr_warn
argument_list|(
literal|"mlx4_core: mlx4_UNMAP_ICM failed.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
block|}
name|kfree
argument_list|(
name|table
operator|->
name|icm
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
end_function

begin_function
name|void
name|mlx4_cleanup_icm_table
parameter_list|(
name|struct
name|mlx4_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_icm_table
modifier|*
name|table
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|num_icm
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|table
operator|->
name|icm
index|[
name|i
index|]
condition|)
block|{
name|err
operator|=
name|mlx4_UNMAP_ICM
argument_list|(
name|dev
argument_list|,
name|table
operator|->
name|virt
operator|+
name|i
operator|*
name|MLX4_TABLE_CHUNK_SIZE
argument_list|,
name|MLX4_TABLE_CHUNK_SIZE
operator|/
name|MLX4_ICM_PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|mlx4_free_icm
argument_list|(
name|dev
argument_list|,
name|table
operator|->
name|icm
index|[
name|i
index|]
argument_list|,
name|table
operator|->
name|coherent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pr_warn
argument_list|(
literal|"mlx4_core: mlx4_UNMAP_ICM failed.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|err
condition|)
name|kfree
argument_list|(
name|table
operator|->
name|icm
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

