begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1988, 1990, 1993, 1995  *      The Regents of the University of California.  All rights reserved.  * Copyright (c) 2004 The FreeBSD Foundation.  All rights reserved.  * Copyright (c) 2004-2008 Robert N. M. Watson.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Excerpts taken from tcp_subr.c, tcp_usrreq.c, uipc_socket.c  */
end_comment

begin_comment
comment|/*  *  * Copyright (c) 2010 Isilon Systems, Inc.  * Copyright (c) 2010 iX Systems, Inc.  * Copyright (c) 2010 Panasas, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|"sdp.h"
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_decl_stmt
name|uma_zone_t
name|sdp_zone
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rwlock
name|sdp_lock
decl_stmt|;
end_decl_stmt

begin_macro
name|LIST_HEAD
argument_list|(
argument_list|,
argument|sdp_sock
argument_list|)
end_macro

begin_expr_stmt
name|sdp_list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|workqueue_struct
modifier|*
name|rx_comp_wq
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|RW_SYSINIT
argument_list|(
name|sdplockinit
argument_list|,
operator|&
name|sdp_lock
argument_list|,
literal|"SDP lock"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|SDP_LIST_WLOCK
parameter_list|()
value|rw_wlock(&sdp_lock)
end_define

begin_define
define|#
directive|define
name|SDP_LIST_RLOCK
parameter_list|()
value|rw_rlock(&sdp_lock)
end_define

begin_define
define|#
directive|define
name|SDP_LIST_WUNLOCK
parameter_list|()
value|rw_wunlock(&sdp_lock)
end_define

begin_define
define|#
directive|define
name|SDP_LIST_RUNLOCK
parameter_list|()
value|rw_runlock(&sdp_lock)
end_define

begin_define
define|#
directive|define
name|SDP_LIST_WLOCK_ASSERT
parameter_list|()
value|rw_assert(&sdp_lock, RW_WLOCKED)
end_define

begin_define
define|#
directive|define
name|SDP_LIST_RLOCK_ASSERT
parameter_list|()
value|rw_assert(&sdp_lock, RW_RLOCKED)
end_define

begin_define
define|#
directive|define
name|SDP_LIST_LOCK_ASSERT
parameter_list|()
value|rw_assert(&sdp_lock, RW_LOCKED)
end_define

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_SDP
argument_list|,
literal|"sdp"
argument_list|,
literal|"Sockets Direct Protocol"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|sdp_stop_keepalive_timer
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * SDP protocol interface to socket abstraction.  */
end_comment

begin_comment
comment|/*  * sdp_sendspace and sdp_recvspace are the default send and receive window  * sizes, respectively.  */
end_comment

begin_decl_stmt
name|u_long
name|sdp_sendspace
init|=
literal|1024
operator|*
literal|32
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|sdp_recvspace
init|=
literal|1024
operator|*
literal|64
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sdp_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Disable async. CMA events for sockets which are being torn down.  */
end_comment

begin_function
specifier|static
name|void
name|sdp_destroy_cma
parameter_list|(
name|struct
name|sdp_sock
modifier|*
name|ssk
parameter_list|)
block|{
if|if
condition|(
name|ssk
operator|->
name|id
operator|==
name|NULL
condition|)
return|return;
name|rdma_destroy_id
argument_list|(
name|ssk
operator|->
name|id
argument_list|)
expr_stmt|;
name|ssk
operator|->
name|id
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sdp_pcbbind
parameter_list|(
name|struct
name|sdp_sock
modifier|*
name|ssk
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|ucred
modifier|*
name|cred
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|sockaddr_in
name|null
decl_stmt|;
name|int
name|error
decl_stmt|;
name|SDP_WLOCK_ASSERT
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssk
operator|->
name|lport
operator|!=
literal|0
operator|||
name|ssk
operator|->
name|laddr
operator|!=
name|INADDR_ANY
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* rdma_bind_addr handles bind races.  */
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssk
operator|->
name|id
operator|==
name|NULL
condition|)
name|ssk
operator|->
name|id
operator|=
name|rdma_create_id
argument_list|(
name|sdp_cma_handler
argument_list|,
name|ssk
argument_list|,
name|RDMA_PS_SDP
argument_list|,
name|IB_QPT_RC
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssk
operator|->
name|id
operator|==
name|NULL
condition|)
block|{
name|SDP_WLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|nam
operator|==
name|NULL
condition|)
block|{
name|null
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|null
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|null
argument_list|)
expr_stmt|;
name|null
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|null
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|null
operator|.
name|sin_zero
argument_list|,
sizeof|sizeof
argument_list|(
name|null
operator|.
name|sin_zero
argument_list|)
argument_list|)
expr_stmt|;
name|nam
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|null
expr_stmt|;
block|}
name|error
operator|=
operator|-
name|rdma_bind_addr
argument_list|(
name|ssk
operator|->
name|id
argument_list|,
name|nam
argument_list|)
expr_stmt|;
name|SDP_WLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ssk
operator|->
name|id
operator|->
name|route
operator|.
name|addr
operator|.
name|src_addr
expr_stmt|;
name|ssk
operator|->
name|laddr
operator|=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|ssk
operator|->
name|lport
operator|=
name|sin
operator|->
name|sin_port
expr_stmt|;
block|}
else|else
name|sdp_destroy_cma
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdp_pcbfree
parameter_list|(
name|struct
name|sdp_sock
modifier|*
name|ssk
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|ssk
operator|->
name|socket
operator|==
name|NULL
argument_list|,
operator|(
literal|"ssk %p socket still attached"
operator|,
name|ssk
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ssk
operator|->
name|flags
operator|&
name|SDP_DESTROY
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"ssk %p already destroyed"
operator|,
name|ssk
operator|)
argument_list|)
expr_stmt|;
name|sdp_dbg
argument_list|(
name|ssk
operator|->
name|socket
argument_list|,
literal|"Freeing pcb"
argument_list|)
expr_stmt|;
name|SDP_WLOCK_ASSERT
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|ssk
operator|->
name|flags
operator||=
name|SDP_DESTROY
expr_stmt|;
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|SDP_LIST_WLOCK
argument_list|()
expr_stmt|;
name|sdp_count
operator|--
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|ssk
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|SDP_LIST_WUNLOCK
argument_list|()
expr_stmt|;
name|crfree
argument_list|(
name|ssk
operator|->
name|cred
argument_list|)
expr_stmt|;
name|ssk
operator|->
name|qp_active
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ssk
operator|->
name|qp
condition|)
block|{
name|ib_destroy_qp
argument_list|(
name|ssk
operator|->
name|qp
argument_list|)
expr_stmt|;
name|ssk
operator|->
name|qp
operator|=
name|NULL
expr_stmt|;
block|}
name|sdp_tx_ring_destroy
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|sdp_rx_ring_destroy
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|sdp_destroy_cma
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|ssk
operator|->
name|rx_ring
operator|.
name|destroyed_lock
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|ssk
operator|->
name|lock
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|sdp_zone
argument_list|,
name|ssk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Common routines to return a socket address.  */
end_comment

begin_function
specifier|static
name|struct
name|sockaddr
modifier|*
name|sdp_sockaddr
parameter_list|(
name|in_port_t
name|port
parameter_list|,
name|struct
name|in_addr
modifier|*
name|addr_p
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|sin
argument_list|,
name|M_SONAME
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
operator|*
name|addr_p
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
return|return
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sdp_getsockaddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|;
name|struct
name|in_addr
name|addr
decl_stmt|;
name|in_port_t
name|port
decl_stmt|;
name|ssk
operator|=
name|sdp_sk
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SDP_RLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|port
operator|=
name|ssk
operator|->
name|lport
expr_stmt|;
name|addr
operator|.
name|s_addr
operator|=
name|ssk
operator|->
name|laddr
expr_stmt|;
name|SDP_RUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
operator|*
name|nam
operator|=
name|sdp_sockaddr
argument_list|(
name|port
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sdp_getpeeraddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|;
name|struct
name|in_addr
name|addr
decl_stmt|;
name|in_port_t
name|port
decl_stmt|;
name|ssk
operator|=
name|sdp_sk
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SDP_RLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|port
operator|=
name|ssk
operator|->
name|fport
expr_stmt|;
name|addr
operator|.
name|s_addr
operator|=
name|ssk
operator|->
name|faddr
expr_stmt|;
name|SDP_RUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
operator|*
name|nam
operator|=
name|sdp_sockaddr
argument_list|(
name|port
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|void
name|sdp_pcbnotifyall
argument_list|(
expr|struct
name|in_addr
name|faddr
argument_list|,
name|int
name|errno
argument_list|,
expr|struct
name|sdp_sock
operator|*
call|(
modifier|*
name|notify
call|)
argument_list|(
expr|struct
name|sdp_sock
operator|*
argument_list|,
name|int
argument_list|)
argument_list|)
block|{
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|,
modifier|*
name|ssk_temp
decl_stmt|;
name|SDP_LIST_WLOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|ssk
argument_list|,
argument|&sdp_list
argument_list|,
argument|list
argument_list|,
argument|ssk_temp
argument_list|)
block|{
name|SDP_WLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssk
operator|->
name|faddr
operator|!=
name|faddr
operator|.
name|s_addr
operator|||
name|ssk
operator|->
name|socket
operator|==
name|NULL
condition|)
block|{
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ssk
operator|->
name|flags
operator|&
name|SDP_DESTROY
operator|)
operator|==
literal|0
condition|)
if|if
condition|(
call|(
modifier|*
name|notify
call|)
argument_list|(
name|ssk
argument_list|,
name|errno
argument_list|)
condition|)
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
block|}
name|SDP_LIST_WUNLOCK
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void sdp_apply_all(void (*func)(struct sdp_sock *, void *), void *arg) { 	struct sdp_sock *ssk;  	SDP_LIST_RLOCK(); 	LIST_FOREACH(ssk,&sdp_list, list) { 		SDP_WLOCK(ssk); 		func(ssk, arg); 		SDP_WUNLOCK(ssk); 	} 	SDP_LIST_RUNLOCK(); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|sdp_output_reset
parameter_list|(
name|struct
name|sdp_sock
modifier|*
name|ssk
parameter_list|)
block|{
name|struct
name|rdma_cm_id
modifier|*
name|id
decl_stmt|;
name|SDP_WLOCK_ASSERT
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssk
operator|->
name|id
condition|)
block|{
name|id
operator|=
name|ssk
operator|->
name|id
expr_stmt|;
name|ssk
operator|->
name|qp_active
operator|=
literal|0
expr_stmt|;
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|rdma_disconnect
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|SDP_WLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
block|}
name|ssk
operator|->
name|state
operator|=
name|TCPS_CLOSED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Attempt to close a SDP socket, marking it as dropped, and freeing  * the socket if we hold the only reference.  */
end_comment

begin_function
specifier|static
name|struct
name|sdp_sock
modifier|*
name|sdp_closed
parameter_list|(
name|struct
name|sdp_sock
modifier|*
name|ssk
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|SDP_WLOCK_ASSERT
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|ssk
operator|->
name|flags
operator||=
name|SDP_DROPPED
expr_stmt|;
name|so
operator|=
name|ssk
operator|->
name|socket
expr_stmt|;
name|soisdisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssk
operator|->
name|flags
operator|&
name|SDP_SOCKREF
condition|)
block|{
name|KASSERT
argument_list|(
name|so
operator|->
name|so_state
operator|&
name|SS_PROTOREF
argument_list|,
operator|(
literal|"sdp_closed: !SS_PROTOREF"
operator|)
argument_list|)
expr_stmt|;
name|ssk
operator|->
name|flags
operator|&=
operator|~
name|SDP_SOCKREF
expr_stmt|;
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_state
operator|&=
operator|~
name|SS_PROTOREF
expr_stmt|;
name|sofree
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|ssk
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform timer based shutdowns which can not operate in  * callout context.  */
end_comment

begin_function
specifier|static
name|void
name|sdp_shutdown_task
parameter_list|(
name|void
modifier|*
name|data
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|;
name|ssk
operator|=
name|data
expr_stmt|;
name|SDP_WLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
comment|/* 	 * I don't think this can race with another call to pcbfree() 	 * because SDP_TIMEWAIT protects it.  SDP_DESTROY may be redundant. 	 */
if|if
condition|(
name|ssk
operator|->
name|flags
operator|&
name|SDP_DESTROY
condition|)
name|panic
argument_list|(
literal|"sdp_shutdown_task: Racing with pcbfree for ssk %p"
argument_list|,
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssk
operator|->
name|flags
operator|&
name|SDP_DISCON
condition|)
name|sdp_output_reset
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
comment|/* We have to clear this so sdp_detach() will call pcbfree(). */
name|ssk
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SDP_TIMEWAIT
operator||
name|SDP_DREQWAIT
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ssk
operator|->
name|flags
operator|&
name|SDP_DROPPED
operator|)
operator|==
literal|0
operator|&&
name|sdp_closed
argument_list|(
name|ssk
argument_list|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|ssk
operator|->
name|socket
operator|==
name|NULL
condition|)
block|{
name|sdp_pcbfree
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
return|return;
block|}
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * 2msl has expired, schedule the shutdown task.  */
end_comment

begin_function
specifier|static
name|void
name|sdp_2msl_timeout
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|;
name|ssk
operator|=
name|data
expr_stmt|;
comment|/* Callout canceled. */
if|if
condition|(
operator|!
name|callout_active
argument_list|(
operator|&
name|ssk
operator|->
name|keep2msl
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|callout_deactivate
argument_list|(
operator|&
name|ssk
operator|->
name|keep2msl
argument_list|)
expr_stmt|;
comment|/* Should be impossible, defensive programming. */
if|if
condition|(
operator|(
name|ssk
operator|->
name|flags
operator|&
name|SDP_TIMEWAIT
operator|)
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|ssk
operator|->
name|shutdown_task
argument_list|)
expr_stmt|;
name|out
label|:
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Schedule the 2msl wait timer.  */
end_comment

begin_function
specifier|static
name|void
name|sdp_2msl_wait
parameter_list|(
name|struct
name|sdp_sock
modifier|*
name|ssk
parameter_list|)
block|{
name|SDP_WLOCK_ASSERT
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|ssk
operator|->
name|flags
operator||=
name|SDP_TIMEWAIT
expr_stmt|;
name|ssk
operator|->
name|state
operator|=
name|TCPS_TIME_WAIT
expr_stmt|;
name|soisdisconnected
argument_list|(
name|ssk
operator|->
name|socket
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|ssk
operator|->
name|keep2msl
argument_list|,
name|TCPTV_MSL
argument_list|,
name|sdp_2msl_timeout
argument_list|,
name|ssk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Timed out waiting for the final fin/ack from rdma_disconnect().  */
end_comment

begin_function
specifier|static
name|void
name|sdp_dreq_timeout
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|;
name|ssk
operator|=
name|data
expr_stmt|;
comment|/* Callout canceled. */
if|if
condition|(
operator|!
name|callout_active
argument_list|(
operator|&
name|ssk
operator|->
name|keep2msl
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* Callout rescheduled, probably as a different timer. */
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|ssk
operator|->
name|keep2msl
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|callout_deactivate
argument_list|(
operator|&
name|ssk
operator|->
name|keep2msl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssk
operator|->
name|state
operator|!=
name|TCPS_FIN_WAIT_1
operator|&&
name|ssk
operator|->
name|state
operator|!=
name|TCPS_LAST_ACK
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|(
name|ssk
operator|->
name|flags
operator|&
name|SDP_DREQWAIT
operator|)
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|ssk
operator|->
name|flags
operator|&=
operator|~
name|SDP_DREQWAIT
expr_stmt|;
name|ssk
operator|->
name|flags
operator||=
name|SDP_DISCON
expr_stmt|;
name|sdp_2msl_wait
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|ssk
operator|->
name|qp_active
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Received the final fin/ack.  Cancel the 2msl.  */
end_comment

begin_function
name|void
name|sdp_cancel_dreq_wait_timeout
parameter_list|(
name|struct
name|sdp_sock
modifier|*
name|ssk
parameter_list|)
block|{
name|sdp_dbg
argument_list|(
name|ssk
operator|->
name|socket
argument_list|,
literal|"cancelling dreq wait timeout\n"
argument_list|)
expr_stmt|;
name|ssk
operator|->
name|flags
operator|&=
operator|~
name|SDP_DREQWAIT
expr_stmt|;
name|sdp_2msl_wait
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sdp_init_sock
parameter_list|(
name|struct
name|socket
modifier|*
name|sk
parameter_list|)
block|{
name|struct
name|sdp_sock
modifier|*
name|ssk
init|=
name|sdp_sk
argument_list|(
name|sk
argument_list|)
decl_stmt|;
name|sdp_dbg
argument_list|(
name|sk
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|callout_init_rw
argument_list|(
operator|&
name|ssk
operator|->
name|keep2msl
argument_list|,
operator|&
name|ssk
operator|->
name|lock
argument_list|,
name|CALLOUT_RETURNUNLOCKED
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|ssk
operator|->
name|shutdown_task
argument_list|,
literal|0
argument_list|,
name|sdp_shutdown_task
argument_list|,
name|ssk
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SDP_ZCOPY
name|INIT_DELAYED_WORK
argument_list|(
operator|&
name|ssk
operator|->
name|srcavail_cancel_work
argument_list|,
name|srcavail_cancel_timeout
argument_list|)
expr_stmt|;
name|ssk
operator|->
name|zcopy_thresh
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* use global sdp_zcopy_thresh */
name|ssk
operator|->
name|tx_ring
operator|.
name|rdma_inflight
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|atomic_set
argument_list|(
operator|&
name|ssk
operator|->
name|mseq_ack
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sdp_rx_ring_init
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|ssk
operator|->
name|tx_ring
operator|.
name|buffer
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate an sdp_sock for the socket and reserve socket buffer space.  */
end_comment

begin_function
specifier|static
name|int
name|sdp_attach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ssk
operator|=
name|sdp_sk
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ssk
operator|==
name|NULL
argument_list|,
operator|(
literal|"sdp_attach: ssk already set on so %p"
operator|,
name|so
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|==
literal|0
operator|||
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|sdp_sendspace
argument_list|,
name|sdp_recvspace
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|so
operator|->
name|so_rcv
operator|.
name|sb_flags
operator||=
name|SB_AUTOSIZE
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
operator||=
name|SB_AUTOSIZE
expr_stmt|;
name|ssk
operator|=
name|uma_zalloc
argument_list|(
name|sdp_zone
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssk
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|rw_init
argument_list|(
operator|&
name|ssk
operator|->
name|lock
argument_list|,
literal|"sdpsock"
argument_list|)
expr_stmt|;
name|ssk
operator|->
name|socket
operator|=
name|so
expr_stmt|;
name|ssk
operator|->
name|cred
operator|=
name|crhold
argument_list|(
name|so
operator|->
name|so_cred
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_pcb
operator|=
operator|(
name|caddr_t
operator|)
name|ssk
expr_stmt|;
name|sdp_init_sock
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|ssk
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ssk
operator|->
name|qp_active
operator|=
literal|0
expr_stmt|;
name|ssk
operator|->
name|state
operator|=
name|TCPS_CLOSED
expr_stmt|;
name|mbufq_init
argument_list|(
operator|&
name|ssk
operator|->
name|rxctlq
argument_list|,
name|INT_MAX
argument_list|)
expr_stmt|;
name|SDP_LIST_WLOCK
argument_list|()
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sdp_list
argument_list|,
name|ssk
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|sdp_count
operator|++
expr_stmt|;
name|SDP_LIST_WUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_LINGER
operator|)
operator|&&
name|so
operator|->
name|so_linger
operator|==
literal|0
condition|)
name|so
operator|->
name|so_linger
operator|=
name|TCP_LINGERTIME
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detach SDP from the socket, potentially leaving it around for the  * timewait to expire.  */
end_comment

begin_function
specifier|static
name|void
name|sdp_detach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|;
name|ssk
operator|=
name|sdp_sk
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SDP_WLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ssk
operator|->
name|socket
operator|!=
name|NULL
argument_list|,
operator|(
literal|"sdp_detach: socket is NULL"
operator|)
argument_list|)
expr_stmt|;
name|ssk
operator|->
name|socket
operator|->
name|so_pcb
operator|=
name|NULL
expr_stmt|;
name|ssk
operator|->
name|socket
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ssk
operator|->
name|flags
operator|&
operator|(
name|SDP_TIMEWAIT
operator||
name|SDP_DREQWAIT
operator|)
condition|)
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ssk
operator|->
name|flags
operator|&
name|SDP_DROPPED
operator|||
name|ssk
operator|->
name|state
operator|<
name|TCPS_SYN_SENT
condition|)
name|sdp_pcbfree
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"sdp_detach: Unexpected state, ssk %p.\n"
argument_list|,
name|ssk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a local address for the socket.  */
end_comment

begin_function
specifier|static
name|int
name|sdp_bind
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|nam
expr_stmt|;
if|if
condition|(
name|nam
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sin
operator|->
name|sin_family
operator|!=
name|AF_INET
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
name|ssk
operator|=
name|sdp_sk
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SDP_WLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssk
operator|->
name|flags
operator|&
operator|(
name|SDP_TIMEWAIT
operator||
name|SDP_DROPPED
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|sdp_pcbbind
argument_list|(
name|ssk
argument_list|,
name|nam
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
name|out
label|:
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prepare to accept connections.  */
end_comment

begin_function
specifier|static
name|int
name|sdp_listen
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|backlog
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|;
name|ssk
operator|=
name|sdp_sk
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SDP_WLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssk
operator|->
name|flags
operator|&
operator|(
name|SDP_TIMEWAIT
operator||
name|SDP_DROPPED
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|ssk
operator|->
name|lport
operator|==
literal|0
condition|)
name|error
operator|=
name|sdp_pcbbind
argument_list|(
name|ssk
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|solisten_proto_check
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|solisten_proto
argument_list|(
name|so
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
name|ssk
operator|->
name|state
operator|=
name|TCPS_LISTEN
expr_stmt|;
block|}
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|out
label|:
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
operator|-
name|rdma_listen
argument_list|(
name|ssk
operator|->
name|id
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initiate a SDP connection to nam.  */
end_comment

begin_function
specifier|static
name|int
name|sdp_start_connect
parameter_list|(
name|struct
name|sdp_sock
modifier|*
name|ssk
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|src
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|error
decl_stmt|;
name|so
operator|=
name|ssk
operator|->
name|socket
expr_stmt|;
name|SDP_WLOCK_ASSERT
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssk
operator|->
name|lport
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|sdp_pcbbind
argument_list|(
name|ssk
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
name|src
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|src
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|src
operator|.
name|sin_zero
argument_list|,
sizeof|sizeof
argument_list|(
name|src
operator|.
name|sin_zero
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|.
name|sin_port
operator|=
name|ssk
operator|->
name|lport
expr_stmt|;
name|src
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|ssk
operator|->
name|laddr
expr_stmt|;
name|soisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|error
operator|=
operator|-
name|rdma_resolve_addr
argument_list|(
name|ssk
operator|->
name|id
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|src
argument_list|,
name|nam
argument_list|,
name|SDP_RESOLVE_TIMEOUT
argument_list|)
expr_stmt|;
name|SDP_WLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|ssk
operator|->
name|state
operator|=
name|TCPS_SYN_SENT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Initiate SDP connection.  */
end_comment

begin_function
specifier|static
name|int
name|sdp_connect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|nam
expr_stmt|;
if|if
condition|(
name|nam
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sin
operator|->
name|sin_family
operator|!=
name|AF_INET
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|prison_remote_ip4
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ssk
operator|=
name|sdp_sk
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SDP_WLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssk
operator|->
name|flags
operator|&
operator|(
name|SDP_TIMEWAIT
operator||
name|SDP_DROPPED
operator|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|error
operator|=
name|sdp_start_connect
argument_list|(
name|ssk
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Drop a SDP socket, reporting  * the specified error.  If connection is synchronized,  * then send a RST to peer.  */
end_comment

begin_function
specifier|static
name|struct
name|sdp_sock
modifier|*
name|sdp_drop
parameter_list|(
name|struct
name|sdp_sock
modifier|*
name|ssk
parameter_list|,
name|int
name|errno
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|SDP_WLOCK_ASSERT
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|so
operator|=
name|ssk
operator|->
name|socket
expr_stmt|;
if|if
condition|(
name|TCPS_HAVERCVDSYN
argument_list|(
name|ssk
operator|->
name|state
argument_list|)
condition|)
name|sdp_output_reset
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ETIMEDOUT
operator|&&
name|ssk
operator|->
name|softerror
condition|)
name|errno
operator|=
name|ssk
operator|->
name|softerror
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
name|errno
expr_stmt|;
return|return
operator|(
name|sdp_closed
argument_list|(
name|ssk
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * User issued close, and wish to trail through shutdown states:  * if never received SYN, just forget it.  If got a SYN from peer,  * but haven't sent FIN, then go to FIN_WAIT_1 state to send peer a FIN.  * If already got a FIN from peer, then almost done; go to LAST_ACK  * state.  In all other cases, have already sent FIN to peer (e.g.  * after PRU_SHUTDOWN), and just have to play tedious game waiting  * for peer to send FIN or not respond to keep-alives, etc.  * We can let the user exit from the close as soon as the FIN is acked.  */
end_comment

begin_function
specifier|static
name|void
name|sdp_usrclosed
parameter_list|(
name|struct
name|sdp_sock
modifier|*
name|ssk
parameter_list|)
block|{
name|SDP_WLOCK_ASSERT
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ssk
operator|->
name|state
condition|)
block|{
case|case
name|TCPS_LISTEN
case|:
name|ssk
operator|->
name|state
operator|=
name|TCPS_CLOSED
expr_stmt|;
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|sdp_destroy_cma
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|SDP_WLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|TCPS_CLOSED
case|:
name|ssk
operator|=
name|sdp_closed
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
comment|/* 		 * sdp_closed() should never return NULL here as the socket is 		 * still open. 		 */
name|KASSERT
argument_list|(
name|ssk
operator|!=
name|NULL
argument_list|,
operator|(
literal|"sdp_usrclosed: sdp_closed() returned NULL"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TCPS_SYN_SENT
case|:
comment|/* FALLTHROUGH */
case|case
name|TCPS_SYN_RECEIVED
case|:
name|ssk
operator|->
name|flags
operator||=
name|SDP_NEEDFIN
expr_stmt|;
break|break;
case|case
name|TCPS_ESTABLISHED
case|:
name|ssk
operator|->
name|flags
operator||=
name|SDP_NEEDFIN
expr_stmt|;
name|ssk
operator|->
name|state
operator|=
name|TCPS_FIN_WAIT_1
expr_stmt|;
break|break;
case|case
name|TCPS_CLOSE_WAIT
case|:
name|ssk
operator|->
name|state
operator|=
name|TCPS_LAST_ACK
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ssk
operator|->
name|state
operator|>=
name|TCPS_FIN_WAIT_2
condition|)
block|{
comment|/* Prevent the connection hanging in FIN_WAIT_2 forever. */
if|if
condition|(
name|ssk
operator|->
name|state
operator|==
name|TCPS_FIN_WAIT_2
condition|)
name|sdp_2msl_wait
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
else|else
name|soisdisconnected
argument_list|(
name|ssk
operator|->
name|socket
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sdp_output_disconnect
parameter_list|(
name|struct
name|sdp_sock
modifier|*
name|ssk
parameter_list|)
block|{
name|SDP_WLOCK_ASSERT
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|ssk
operator|->
name|keep2msl
argument_list|,
name|SDP_FIN_WAIT_TIMEOUT
argument_list|,
name|sdp_dreq_timeout
argument_list|,
name|ssk
argument_list|)
expr_stmt|;
name|ssk
operator|->
name|flags
operator||=
name|SDP_NEEDFIN
operator||
name|SDP_DREQWAIT
expr_stmt|;
name|sdp_post_sends
argument_list|(
name|ssk
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initiate or continue a disconnect.  * If embryonic state, just send reset (once).  * If in ``let data drain'' option and linger null, just drop.  * Otherwise (hard), mark socket disconnecting and drop  * current input data; switch states based on user close, and  * send segment to peer (with FIN).  */
end_comment

begin_function
specifier|static
name|void
name|sdp_start_disconnect
parameter_list|(
name|struct
name|sdp_sock
modifier|*
name|ssk
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|unread
decl_stmt|;
name|so
operator|=
name|ssk
operator|->
name|socket
expr_stmt|;
name|SDP_WLOCK_ASSERT
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|sdp_stop_keepalive_timer
argument_list|(
name|so
argument_list|)
expr_stmt|;
comment|/* 	 * Neither sdp_closed() nor sdp_drop() should return NULL, as the 	 * socket is still open. 	 */
if|if
condition|(
name|ssk
operator|->
name|state
operator|<
name|TCPS_ESTABLISHED
condition|)
block|{
name|ssk
operator|=
name|sdp_closed
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ssk
operator|!=
name|NULL
argument_list|,
operator|(
literal|"sdp_start_disconnect: sdp_close() returned NULL"
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_LINGER
operator|)
operator|&&
name|so
operator|->
name|so_linger
operator|==
literal|0
condition|)
block|{
name|ssk
operator|=
name|sdp_drop
argument_list|(
name|ssk
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ssk
operator|!=
name|NULL
argument_list|,
operator|(
literal|"sdp_start_disconnect: sdp_drop() returned NULL"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|soisdisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|unread
operator|=
name|sbused
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|sbflush
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|sdp_usrclosed
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ssk
operator|->
name|flags
operator|&
name|SDP_DROPPED
operator|)
condition|)
block|{
if|if
condition|(
name|unread
condition|)
name|sdp_output_reset
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
else|else
name|sdp_output_disconnect
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * User initiated disconnect.  */
end_comment

begin_function
specifier|static
name|int
name|sdp_disconnect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ssk
operator|=
name|sdp_sk
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SDP_WLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssk
operator|->
name|flags
operator|&
operator|(
name|SDP_TIMEWAIT
operator||
name|SDP_DROPPED
operator|)
condition|)
block|{
name|error
operator|=
name|ECONNRESET
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sdp_start_disconnect
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|out
label|:
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Accept a connection.  Essentially all the work is done at higher levels;  * just return the address of the peer, storing through addr.  *  *  * XXX This is broken XXX  *   * The rationale for acquiring the sdp lock here is somewhat complicated,  * and is described in detail in the commit log entry for r175612.  Acquiring  * it delays an accept(2) racing with sonewconn(), which inserts the socket  * before the address/port fields are initialized.  A better fix would  * prevent the socket from being placed in the listen queue until all fields  * are fully initialized.  */
end_comment

begin_function
specifier|static
name|int
name|sdp_accept
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
name|struct
name|sdp_sock
modifier|*
name|ssk
init|=
name|NULL
decl_stmt|;
name|struct
name|in_addr
name|addr
decl_stmt|;
name|in_port_t
name|port
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISDISCONNECTED
condition|)
return|return
operator|(
name|ECONNABORTED
operator|)
return|;
name|port
operator|=
literal|0
expr_stmt|;
name|addr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ssk
operator|=
name|sdp_sk
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SDP_WLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssk
operator|->
name|flags
operator|&
operator|(
name|SDP_TIMEWAIT
operator||
name|SDP_DROPPED
operator|)
condition|)
block|{
name|error
operator|=
name|ECONNABORTED
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|port
operator|=
name|ssk
operator|->
name|fport
expr_stmt|;
name|addr
operator|.
name|s_addr
operator|=
name|ssk
operator|->
name|faddr
expr_stmt|;
name|out
label|:
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
name|nam
operator|=
name|sdp_sockaddr
argument_list|(
name|port
argument_list|,
operator|&
name|addr
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Mark the connection as being incapable of further output.  */
end_comment

begin_function
specifier|static
name|int
name|sdp_shutdown
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|;
name|ssk
operator|=
name|sdp_sk
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SDP_WLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssk
operator|->
name|flags
operator|&
operator|(
name|SDP_TIMEWAIT
operator||
name|SDP_DROPPED
operator|)
condition|)
block|{
name|error
operator|=
name|ECONNRESET
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|socantsendmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sdp_usrclosed
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ssk
operator|->
name|flags
operator|&
name|SDP_DROPPED
operator|)
condition|)
name|sdp_output_disconnect
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|out
label|:
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdp_append
parameter_list|(
name|struct
name|sdp_sock
modifier|*
name|ssk
parameter_list|,
name|struct
name|sockbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mb
parameter_list|,
name|int
name|cnt
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|int
name|ncnt
decl_stmt|;
name|SOCKBUF_LOCK_ASSERT
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|SBLASTRECORDCHK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|mb
operator|->
name|m_flags
operator|&
name|M_PKTHDR
argument_list|,
operator|(
literal|"sdp_append: %p Missing packet header.\n"
operator|,
name|mb
operator|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|sb
operator|->
name|sb_lastrecord
expr_stmt|;
comment|/* 	 * If the queue is empty just set all pointers and proceed. 	 */
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|sb
operator|->
name|sb_lastrecord
operator|=
name|sb
operator|->
name|sb_mb
operator|=
name|sb
operator|->
name|sb_sndptr
operator|=
name|mb
expr_stmt|;
for|for
control|(
init|;
name|mb
condition|;
name|mb
operator|=
name|mb
operator|->
name|m_next
control|)
block|{
name|sb
operator|->
name|sb_mbtail
operator|=
name|mb
expr_stmt|;
name|sballoc
argument_list|(
name|sb
argument_list|,
name|mb
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* 	 * Count the number of mbufs in the current tail. 	 */
for|for
control|(
name|ncnt
operator|=
literal|0
init|;
name|n
operator|->
name|m_next
condition|;
name|n
operator|=
name|n
operator|->
name|m_next
control|)
name|ncnt
operator|++
expr_stmt|;
name|n
operator|=
name|sb
operator|->
name|sb_lastrecord
expr_stmt|;
comment|/* 	 * If the two chains can fit in a single sdp packet and 	 * the last record has not been sent yet (WRITABLE) coalesce 	 * them.  The lastrecord remains the same but we must strip the 	 * packet header and then let sbcompress do the hard part. 	 */
if|if
condition|(
name|M_WRITABLE
argument_list|(
name|n
argument_list|)
operator|&&
name|ncnt
operator|+
name|cnt
operator|<
name|SDP_MAX_SEND_SGES
operator|&&
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
name|mb
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|SDP_HEAD_SIZE
operator|<
name|ssk
operator|->
name|xmit_size_goal
condition|)
block|{
name|m_adj
argument_list|(
name|mb
argument_list|,
name|SDP_HEAD_SIZE
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|mb
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|n
operator|->
name|m_flags
operator||=
name|mb
operator|->
name|m_flags
operator|&
operator|(
name|M_PUSH
operator||
name|M_URG
operator|)
expr_stmt|;
name|m_demote
argument_list|(
name|mb
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sbcompress
argument_list|(
name|sb
argument_list|,
name|mb
argument_list|,
name|sb
operator|->
name|sb_mbtail
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Not compressible, just append to the end and adjust counters. 	 */
name|sb
operator|->
name|sb_lastrecord
operator|->
name|m_flags
operator||=
name|M_PUSH
expr_stmt|;
name|sb
operator|->
name|sb_lastrecord
operator|->
name|m_nextpkt
operator|=
name|mb
expr_stmt|;
name|sb
operator|->
name|sb_lastrecord
operator|=
name|mb
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|sb_sndptr
operator|==
name|NULL
condition|)
name|sb
operator|->
name|sb_sndptr
operator|=
name|mb
expr_stmt|;
for|for
control|(
init|;
name|mb
condition|;
name|mb
operator|=
name|mb
operator|->
name|m_next
control|)
block|{
name|sb
operator|->
name|sb_mbtail
operator|=
name|mb
expr_stmt|;
name|sballoc
argument_list|(
name|sb
argument_list|,
name|mb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Do a send by putting data in output queue and updating urgent  * marker if URG set.  Possibly send more data.  Unlike the other  * pru_*() routines, the mbuf chains are our responsibility.  We  * must either enqueue them or free them.  The other pru_* routines  * generally are caller-frees.  *  * This comes from sendfile, normal sends will come from sdp_sosend().  */
end_comment

begin_function
specifier|static
name|int
name|sdp_send
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ssk
operator|=
name|sdp_sk
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
argument_list|,
operator|(
literal|"sdp_send: %p no packet header"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|SDP_HEAD_SIZE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sdp_bsdh
operator|*
argument_list|)
operator|->
name|mid
operator|=
name|SDP_MID_DATA
expr_stmt|;
for|for
control|(
name|n
operator|=
name|m
operator|,
name|cnt
operator|=
literal|0
init|;
name|n
operator|->
name|m_next
condition|;
name|n
operator|=
name|n
operator|->
name|m_next
control|)
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
name|SDP_MAX_SEND_SGES
condition|)
block|{
name|n
operator|=
name|m_collapse
argument_list|(
name|m
argument_list|,
name|M_WAITOK
argument_list|,
name|SDP_MAX_SEND_SGES
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
block|}
name|m
operator|=
name|n
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|n
operator|->
name|m_next
condition|;
name|n
operator|=
name|n
operator|->
name|m_next
control|)
name|cnt
operator|++
expr_stmt|;
block|}
name|SDP_WLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssk
operator|->
name|flags
operator|&
operator|(
name|SDP_TIMEWAIT
operator||
name|SDP_DROPPED
operator|)
condition|)
block|{
if|if
condition|(
name|control
condition|)
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|ECONNRESET
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|control
condition|)
block|{
comment|/* SDP doesn't support control messages. */
if|if
condition|(
name|control
operator|->
name|m_len
condition|)
block|{
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
comment|/* empty control, just free it */
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|PRUS_OOB
operator|)
condition|)
block|{
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|sdp_append
argument_list|(
name|ssk
argument_list|,
operator|&
name|so
operator|->
name|so_snd
argument_list|,
name|m
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|nam
operator|&&
name|ssk
operator|->
name|state
operator|<
name|TCPS_SYN_SENT
condition|)
block|{
comment|/* 			 * Do implied connect if not yet connected. 			 */
name|error
operator|=
name|sdp_start_connect
argument_list|(
name|ssk
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|flags
operator|&
name|PRUS_EOF
condition|)
block|{
comment|/* 			 * Close the send side of the connection after 			 * the data is sent. 			 */
name|socantsendmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sdp_usrclosed
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ssk
operator|->
name|flags
operator|&
name|SDP_DROPPED
operator|)
condition|)
name|sdp_output_disconnect
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|ssk
operator|->
name|flags
operator|&
name|SDP_DROPPED
operator|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|PRUS_MORETOCOME
operator|)
condition|)
name|sdp_post_sends
argument_list|(
name|ssk
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
operator|<
operator|-
literal|512
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * According to RFC961 (Assigned Protocols), 		 * the urgent pointer points to the last octet 		 * of urgent data.  We continue, however, 		 * to consider it to indicate the first octet 		 * of data past the urgent section. 		 * Otherwise, snd_up should be one lower. 		 */
name|m
operator|->
name|m_flags
operator||=
name|M_URG
operator||
name|M_PUSH
expr_stmt|;
name|sdp_append
argument_list|(
name|ssk
argument_list|,
operator|&
name|so
operator|->
name|so_snd
argument_list|,
name|m
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|nam
operator|&&
name|ssk
operator|->
name|state
operator|<
name|TCPS_SYN_SENT
condition|)
block|{
comment|/* 			 * Do implied connect if not yet connected. 			 */
name|error
operator|=
name|sdp_start_connect
argument_list|(
name|ssk
argument_list|,
name|nam
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
name|sdp_post_sends
argument_list|(
name|ssk
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|out
label|:
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SBLOCKWAIT
parameter_list|(
name|f
parameter_list|)
value|(((f)& MSG_DONTWAIT) ? 0 : SBL_WAIT)
end_define

begin_comment
comment|/*  * Send on a socket.  If send must go all at once and message is larger than  * send buffering, then hard error.  Lock against other senders.  If must go  * all at once and not enough room now, then inform user that this would  * block and do nothing.  Otherwise, if nonblocking, send as much as  * possible.  The data to be sent is described by "uio" if nonzero, otherwise  * by the mbuf chain "top" (which must be null if uio is not).  Data provided  * in mbuf chain must be small enough to send all at once.  *  * Returns nonzero on error, timeout or signal; callers must check for short  * counts if EINTR/ERESTART are returned.  Data and control buffers are freed  * on return.  */
end_comment

begin_function
specifier|static
name|int
name|sdp_sosend
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
name|top
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|;
name|long
name|space
decl_stmt|,
name|resid
decl_stmt|;
name|int
name|atomic
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|copy
decl_stmt|;
if|if
condition|(
name|uio
operator|!=
name|NULL
condition|)
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
else|else
name|resid
operator|=
name|top
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|atomic
operator|=
name|top
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|control
operator|->
name|m_len
condition|)
block|{
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
condition|)
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|control
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * In theory resid should be unsigned.  However, space must be 	 * signed, as it might be less than 0 if we over-committed, and we 	 * must use a signed comparison of space and resid.  On the other 	 * hand, a negative resid causes us to loop sending 0-length 	 * segments to the protocol. 	 * 	 * Also check to make sure that MSG_EOR isn't used on SOCK_STREAM 	 * type sockets since that's an error. 	 */
if|if
condition|(
name|resid
operator|<
literal|0
operator|||
operator|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_STREAM
operator|&&
operator|(
name|flags
operator|&
name|MSG_EOR
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|td
operator|!=
name|NULL
condition|)
name|td
operator|->
name|td_ru
operator|.
name|ru_msgsnd
operator|++
expr_stmt|;
name|ssk
operator|=
name|sdp_sk
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|error
operator|=
name|sblock
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|,
name|SBLOCKWAIT
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|restart
label|:
do|do
block|{
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_state
operator|&
name|SBS_CANTSENDMORE
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPIPE
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISCONNECTED
operator|)
operator|==
literal|0
operator|&&
name|addr
operator|==
name|NULL
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|release
goto|;
block|}
name|space
operator|=
name|sbspace
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MSG_OOB
condition|)
name|space
operator|+=
literal|1024
expr_stmt|;
if|if
condition|(
name|atomic
operator|&&
name|resid
operator|>
name|ssk
operator|->
name|xmit_size_goal
operator|-
name|SDP_HEAD_SIZE
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|space
operator|<
name|resid
operator|&&
operator|(
name|atomic
operator|||
name|space
operator|<
name|so
operator|->
name|so_snd
operator|.
name|sb_lowat
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
operator|)
operator|||
operator|(
name|flags
operator|&
name|MSG_NBIO
operator|)
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
goto|goto
name|release
goto|;
block|}
name|error
operator|=
name|sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|release
goto|;
goto|goto
name|restart
goto|;
block|}
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
name|uio
operator|==
name|NULL
condition|)
block|{
name|resid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MSG_EOR
condition|)
name|top
operator|->
name|m_flags
operator||=
name|M_EOR
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Copy the data from userland into a mbuf 				 * chain.  If no data is to be copied in, 				 * a single empty mbuf is returned. 				 */
name|copy
operator|=
name|min
argument_list|(
name|space
argument_list|,
name|ssk
operator|->
name|xmit_size_goal
operator|-
name|SDP_HEAD_SIZE
argument_list|)
expr_stmt|;
name|top
operator|=
name|m_uiotombuf
argument_list|(
name|uio
argument_list|,
name|M_WAITOK
argument_list|,
name|copy
argument_list|,
literal|0
argument_list|,
name|M_PKTHDR
operator||
operator|(
operator|(
name|flags
operator|&
name|MSG_EOR
operator|)
condition|?
name|M_EOR
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
block|{
comment|/* only possible error */
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|release
goto|;
block|}
name|space
operator|-=
name|resid
operator|-
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|resid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
block|}
comment|/* 			 * XXX all the SBS_CANTSENDMORE checks previously 			 * done could be out of date after dropping the 			 * socket lock. 			 */
name|error
operator|=
name|sdp_send
argument_list|(
name|so
argument_list|,
operator|(
name|flags
operator|&
name|MSG_OOB
operator|)
condition|?
name|PRUS_OOB
else|:
comment|/* 			 * Set EOF on the last send if the user specified 			 * MSG_EOF. 			 */
operator|(
operator|(
name|flags
operator|&
name|MSG_EOF
operator|)
operator|&&
operator|(
name|resid
operator|<=
literal|0
operator|)
operator|)
condition|?
name|PRUS_EOF
else|:
comment|/* If there is more to send set PRUS_MORETOCOME. */
operator|(
name|resid
operator|>
literal|0
operator|&&
name|space
operator|>
literal|0
operator|)
condition|?
name|PRUS_MORETOCOME
else|:
literal|0
argument_list|,
name|top
argument_list|,
name|addr
argument_list|,
name|NULL
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|top
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|release
goto|;
block|}
do|while
condition|(
name|resid
operator|&&
name|space
operator|>
literal|0
condition|)
do|;
block|}
do|while
condition|(
name|resid
condition|)
do|;
name|release
label|:
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|top
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The part of soreceive() that implements reading non-inline out-of-band  * data from a socket.  For more complete comments, see soreceive(), from  * which this code originated.  *  * Note that soreceive_rcvoob(), unlike the remainder of soreceive(), is  * unable to return an mbuf chain to the caller.  */
end_comment

begin_function
specifier|static
name|int
name|soreceive_rcvoob
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|protosw
modifier|*
name|pr
init|=
name|so
operator|->
name|so_proto
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|flags
operator|&
name|MSG_OOB
argument_list|,
operator|(
literal|"soreceive_rcvoob: (flags& MSG_OOB) == 0"
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_get
argument_list|(
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|pr
operator|->
name|pr_usrreqs
operator|->
name|pru_rcvoob
call|)
argument_list|(
name|so
argument_list|,
name|m
argument_list|,
name|flags
operator|&
name|MSG_PEEK
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
do|do
block|{
name|error
operator|=
name|uiomove
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|min
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|uio
operator|->
name|uio_resid
operator|&&
name|error
operator|==
literal|0
operator|&&
name|m
condition|)
do|;
name|bad
label|:
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Optimized version of soreceive() for stream (TCP) sockets.  */
end_comment

begin_function
specifier|static
name|int
name|sdp_sorecv
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|psa
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp0
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|controlp
parameter_list|,
name|int
modifier|*
name|flagsp
parameter_list|)
block|{
name|int
name|len
init|=
literal|0
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|,
name|flags
decl_stmt|,
name|oresid
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|n
init|=
name|NULL
decl_stmt|;
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|;
comment|/* We only do stream sockets. */
if|if
condition|(
name|so
operator|->
name|so_type
operator|!=
name|SOCK_STREAM
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|psa
operator|!=
name|NULL
condition|)
operator|*
name|psa
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|controlp
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|flagsp
operator|!=
name|NULL
condition|)
name|flags
operator|=
operator|*
name|flagsp
operator|&
operator|~
name|MSG_EOR
expr_stmt|;
else|else
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MSG_OOB
condition|)
return|return
operator|(
name|soreceive_rcvoob
argument_list|(
name|so
argument_list|,
name|uio
argument_list|,
name|flags
argument_list|)
operator|)
return|;
if|if
condition|(
name|mp0
operator|!=
name|NULL
condition|)
operator|*
name|mp0
operator|=
name|NULL
expr_stmt|;
name|sb
operator|=
operator|&
name|so
operator|->
name|so_rcv
expr_stmt|;
name|ssk
operator|=
name|sdp_sk
argument_list|(
name|so
argument_list|)
expr_stmt|;
comment|/* Prevent other readers from entering the socket. */
name|error
operator|=
name|sblock
argument_list|(
name|sb
argument_list|,
name|SBLOCKWAIT
argument_list|(
name|flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
comment|/* Easy one, no space to copyout anything. */
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|oresid
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
comment|/* We will never ever get anything unless we are connected. */
if|if
condition|(
operator|!
operator|(
name|so
operator|->
name|so_state
operator|&
operator|(
name|SS_ISCONNECTED
operator||
name|SS_ISDISCONNECTED
operator|)
operator|)
condition|)
block|{
comment|/* When disconnecting there may be still some data left. */
if|if
condition|(
name|sbavail
argument_list|(
name|sb
argument_list|)
condition|)
goto|goto
name|deliver
goto|;
if|if
condition|(
operator|!
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISDISCONNECTED
operator|)
condition|)
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Socket buffer is empty and we shall not block. */
if|if
condition|(
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
operator|)
operator|||
operator|(
name|flags
operator|&
operator|(
name|MSG_DONTWAIT
operator||
name|MSG_NBIO
operator|)
operator|)
operator|)
condition|)
block|{
name|error
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|restart
label|:
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* Abort if socket has reported problems. */
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
if|if
condition|(
name|sbavail
argument_list|(
name|sb
argument_list|)
condition|)
goto|goto
name|deliver
goto|;
if|if
condition|(
name|oresid
operator|>
name|uio
operator|->
name|uio_resid
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
condition|)
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Door is closed.  Deliver what is left, if any. */
if|if
condition|(
name|sb
operator|->
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
block|{
if|if
condition|(
name|sbavail
argument_list|(
name|sb
argument_list|)
condition|)
goto|goto
name|deliver
goto|;
else|else
goto|goto
name|out
goto|;
block|}
comment|/* Socket buffer got some data that we shall deliver now. */
if|if
condition|(
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|&&
operator|!
operator|(
name|flags
operator|&
name|MSG_WAITALL
operator|)
operator|&&
operator|(
operator|(
name|so
operator|->
name|so_state
operator|&
name|SS_NBIO
operator|)
operator|||
operator|(
name|flags
operator|&
operator|(
name|MSG_DONTWAIT
operator||
name|MSG_NBIO
operator|)
operator|)
operator|||
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|>=
name|sb
operator|->
name|sb_lowat
operator|||
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|>=
name|uio
operator|->
name|uio_resid
operator|||
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|>=
name|sb
operator|->
name|sb_hiwat
operator|)
condition|)
block|{
goto|goto
name|deliver
goto|;
block|}
comment|/* On MSG_WAITALL we must wait until all data or error arrives. */
if|if
condition|(
operator|(
name|flags
operator|&
name|MSG_WAITALL
operator|)
operator|&&
operator|(
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|>=
name|uio
operator|->
name|uio_resid
operator|||
name|sbavail
argument_list|(
name|sb
argument_list|)
operator|>=
name|sb
operator|->
name|sb_lowat
operator|)
condition|)
goto|goto
name|deliver
goto|;
comment|/* 	 * Wait and block until (more) data comes in. 	 * NB: Drops the sockbuf lock during wait. 	 */
name|error
operator|=
name|sbwait
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
goto|goto
name|restart
goto|;
name|deliver
label|:
name|SOCKBUF_LOCK_ASSERT
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sbavail
argument_list|(
name|sb
argument_list|)
argument_list|,
operator|(
literal|"%s: sockbuf empty"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sb
operator|->
name|sb_mb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: sb_mb == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* Statistics. */
if|if
condition|(
name|uio
operator|->
name|uio_td
condition|)
name|uio
operator|->
name|uio_td
operator|->
name|td_ru
operator|.
name|ru_msgrcv
operator|++
expr_stmt|;
comment|/* Fill uio until full or current end of socket buffer is reached. */
name|len
operator|=
name|min
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|sbavail
argument_list|(
name|sb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp0
operator|!=
name|NULL
condition|)
block|{
comment|/* Dequeue as many mbufs as possible. */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
operator|&&
name|len
operator|>=
name|sb
operator|->
name|sb_mb
operator|->
name|m_len
condition|)
block|{
for|for
control|(
operator|*
name|mp0
operator|=
name|m
operator|=
name|sb
operator|->
name|sb_mb
init|;
name|m
operator|!=
name|NULL
operator|&&
name|m
operator|->
name|m_len
operator|<=
name|len
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|len
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
name|sbfree
argument_list|(
name|sb
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|n
operator|=
name|m
expr_stmt|;
block|}
name|sb
operator|->
name|sb_mb
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|sb_mb
operator|==
name|NULL
condition|)
name|SB_EMPTY_FIXUP
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Copy the remainder. */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|sb
operator|->
name|sb_mb
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: len> 0&& sb->sb_mb empty"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_copym
argument_list|(
name|sb
operator|->
name|sb_mb
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|len
operator|=
literal|0
expr_stmt|;
comment|/* Don't flush data from sockbuf. */
else|else
name|uio
operator|->
name|uio_resid
operator|-=
name|m
operator|->
name|m_len
expr_stmt|;
if|if
condition|(
operator|*
name|mp0
operator|!=
name|NULL
condition|)
name|n
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
else|else
operator|*
name|mp0
operator|=
name|m
expr_stmt|;
if|if
condition|(
operator|*
name|mp0
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
else|else
block|{
comment|/* NB: Must unlock socket buffer as uiomove may sleep. */
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|error
operator|=
name|m_mbuftouio
argument_list|(
name|uio
argument_list|,
name|sb
operator|->
name|sb_mb
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
name|SBLASTRECORDCHK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|SBLASTMBUFCHK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
comment|/* 	 * Remove the delivered data from the socket buffer unless we 	 * were only peeking. 	 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
condition|)
block|{
if|if
condition|(
name|len
operator|>
literal|0
condition|)
name|sbdrop_locked
argument_list|(
name|sb
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* Notify protocol that we drained some data. */
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|SDP_WLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|sdp_do_posts
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * For MSG_WAITALL we may have to loop again and wait for 	 * more data to come in. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|MSG_WAITALL
operator|)
operator|&&
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
goto|goto
name|restart
goto|;
name|out
label|:
name|SOCKBUF_LOCK_ASSERT
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|SBLASTRECORDCHK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|SBLASTMBUFCHK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbunlock
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Abort is used to teardown a connection typically while sitting in  * the accept queue.  */
end_comment

begin_function
name|void
name|sdp_abort
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|;
name|ssk
operator|=
name|sdp_sk
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SDP_WLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
comment|/* 	 * If we have not yet dropped, do it now. 	 */
if|if
condition|(
operator|!
operator|(
name|ssk
operator|->
name|flags
operator|&
name|SDP_TIMEWAIT
operator|)
operator|&&
operator|!
operator|(
name|ssk
operator|->
name|flags
operator|&
name|SDP_DROPPED
operator|)
condition|)
name|sdp_drop
argument_list|(
name|ssk
argument_list|,
name|ECONNABORTED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ssk
operator|->
name|flags
operator|&
name|SDP_DROPPED
argument_list|,
operator|(
literal|"sdp_abort: %p not dropped 0x%X"
operator|,
name|ssk
operator|,
name|ssk
operator|->
name|flags
operator|)
argument_list|)
expr_stmt|;
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Close a SDP socket and initiate a friendly disconnect.  */
end_comment

begin_function
specifier|static
name|void
name|sdp_close
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|;
name|ssk
operator|=
name|sdp_sk
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SDP_WLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
comment|/* 	 * If we have not yet dropped, do it now. 	 */
if|if
condition|(
operator|!
operator|(
name|ssk
operator|->
name|flags
operator|&
name|SDP_TIMEWAIT
operator|)
operator|&&
operator|!
operator|(
name|ssk
operator|->
name|flags
operator|&
name|SDP_DROPPED
operator|)
condition|)
name|sdp_start_disconnect
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
comment|/* 	 * If we've still not dropped let the socket layer know we're 	 * holding on to the socket and pcb for a while. 	 */
if|if
condition|(
operator|!
operator|(
name|ssk
operator|->
name|flags
operator|&
name|SDP_DROPPED
operator|)
condition|)
block|{
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_state
operator||=
name|SS_PROTOREF
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|ssk
operator|->
name|flags
operator||=
name|SDP_SOCKREF
expr_stmt|;
block|}
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * User requests out-of-band data.  */
end_comment

begin_function
specifier|static
name|int
name|sdp_rcvoob
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|;
name|ssk
operator|=
name|sdp_sk
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SDP_WLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rx_ring_trylock
argument_list|(
operator|&
name|ssk
operator|->
name|rx_ring
argument_list|)
condition|)
block|{
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
return|return
operator|(
name|ECONNRESET
operator|)
return|;
block|}
if|if
condition|(
name|ssk
operator|->
name|flags
operator|&
operator|(
name|SDP_TIMEWAIT
operator||
name|SDP_DROPPED
operator|)
condition|)
block|{
name|error
operator|=
name|ECONNRESET
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|so
operator|->
name|so_oobmark
operator|==
literal|0
operator|&&
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_RCVATMARK
operator|)
operator|==
literal|0
operator|)
operator|||
name|so
operator|->
name|so_options
operator|&
name|SO_OOBINLINE
operator|||
name|ssk
operator|->
name|oobflags
operator|&
name|SDP_HADOOB
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|ssk
operator|->
name|oobflags
operator|&
name|SDP_HAVEOOB
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|m
operator|->
name|m_len
operator|=
literal|1
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|=
name|ssk
operator|->
name|iobc
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
name|ssk
operator|->
name|oobflags
operator|^=
operator|(
name|SDP_HAVEOOB
operator||
name|SDP_HADOOB
operator|)
expr_stmt|;
name|out
label|:
name|rx_ring_unlock
argument_list|(
operator|&
name|ssk
operator|->
name|rx_ring
argument_list|)
expr_stmt|;
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sdp_urg
parameter_list|(
name|struct
name|sdp_sock
modifier|*
name|ssk
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mb
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|ssk
operator|->
name|socket
expr_stmt|;
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
return|return;
name|so
operator|->
name|so_oobmark
operator|=
name|sbused
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
operator|+
name|mb
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
literal|1
expr_stmt|;
name|sohasoutofband
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|ssk
operator|->
name|oobflags
operator|&=
operator|~
operator|(
name|SDP_HAVEOOB
operator||
name|SDP_HADOOB
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_OOBINLINE
operator|)
condition|)
block|{
for|for
control|(
name|m
operator|=
name|mb
init|;
name|m
operator|->
name|m_next
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
empty_stmt|;
name|ssk
operator|->
name|iobc
operator|=
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
operator|+
name|m
operator|->
name|m_len
operator|-
literal|1
operator|)
expr_stmt|;
name|ssk
operator|->
name|oobflags
operator||=
name|SDP_HAVEOOB
expr_stmt|;
name|m
operator|->
name|m_len
operator|--
expr_stmt|;
name|mb
operator|->
name|m_pkthdr
operator|.
name|len
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Notify a sdp socket of an asynchronous error.  *  * Do not wake up user since there currently is no mechanism for  * reporting soft errors (yet - a kqueue filter may be added).  */
end_comment

begin_function
name|struct
name|sdp_sock
modifier|*
name|sdp_notify
parameter_list|(
name|struct
name|sdp_sock
modifier|*
name|ssk
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|SDP_WLOCK_ASSERT
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ssk
operator|->
name|flags
operator|&
name|SDP_TIMEWAIT
operator|)
operator|||
operator|(
name|ssk
operator|->
name|flags
operator|&
name|SDP_DROPPED
operator|)
condition|)
return|return
operator|(
name|ssk
operator|)
return|;
comment|/* 	 * Ignore some errors if we are hooked up. 	 */
if|if
condition|(
name|ssk
operator|->
name|state
operator|==
name|TCPS_ESTABLISHED
operator|&&
operator|(
name|error
operator|==
name|EHOSTUNREACH
operator|||
name|error
operator|==
name|ENETUNREACH
operator|||
name|error
operator|==
name|EHOSTDOWN
operator|)
condition|)
return|return
operator|(
name|ssk
operator|)
return|;
name|ssk
operator|->
name|softerror
operator|=
name|error
expr_stmt|;
return|return
name|sdp_drop
argument_list|(
name|ssk
argument_list|,
name|error
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdp_ctlinput
parameter_list|(
name|int
name|cmd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|void
modifier|*
name|vip
parameter_list|)
block|{
name|struct
name|in_addr
name|faddr
decl_stmt|;
name|faddr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin_addr
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|!=
name|AF_INET
operator|||
name|faddr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
return|return;
name|sdp_pcbnotifyall
argument_list|(
name|faddr
argument_list|,
name|inetctlerrmap
index|[
name|cmd
index|]
argument_list|,
name|sdp_notify
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sdp_control
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdp_keepalive_timeout
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|;
name|ssk
operator|=
name|data
expr_stmt|;
comment|/* Callout canceled. */
if|if
condition|(
operator|!
name|callout_active
argument_list|(
operator|&
name|ssk
operator|->
name|keep2msl
argument_list|)
condition|)
return|return;
comment|/* Callout rescheduled as a different kind of timer. */
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|ssk
operator|->
name|keep2msl
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|callout_deactivate
argument_list|(
operator|&
name|ssk
operator|->
name|keep2msl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssk
operator|->
name|flags
operator|&
name|SDP_DROPPED
operator|||
operator|(
name|ssk
operator|->
name|socket
operator|->
name|so_options
operator|&
name|SO_KEEPALIVE
operator|)
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|sdp_post_keepalive
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|ssk
operator|->
name|keep2msl
argument_list|,
name|SDP_KEEPALIVE_TIME
argument_list|,
name|sdp_keepalive_timeout
argument_list|,
name|ssk
argument_list|)
expr_stmt|;
name|out
label|:
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sdp_start_keepalive_timer
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|;
name|ssk
operator|=
name|sdp_sk
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|callout_pending
argument_list|(
operator|&
name|ssk
operator|->
name|keep2msl
argument_list|)
condition|)
name|callout_reset
argument_list|(
operator|&
name|ssk
operator|->
name|keep2msl
argument_list|,
name|SDP_KEEPALIVE_TIME
argument_list|,
name|sdp_keepalive_timeout
argument_list|,
name|ssk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdp_stop_keepalive_timer
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|;
name|ssk
operator|=
name|sdp_sk
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|ssk
operator|->
name|keep2msl
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sdp_ctloutput() must drop the inpcb lock before performing copyin on  * socket option arguments.  When it re-acquires the lock after the copy, it  * has to revalidate that the connection is still valid for the socket  * option.  */
end_comment

begin_define
define|#
directive|define
name|SDP_WLOCK_RECHECK
parameter_list|(
name|inp
parameter_list|)
value|do {					\ 	SDP_WLOCK(ssk);							\ 	if (ssk->flags& (SDP_TIMEWAIT | SDP_DROPPED)) {		\ 		SDP_WUNLOCK(ssk);					\ 		return (ECONNRESET);					\ 	}								\ } while(0)
end_define

begin_function
specifier|static
name|int
name|sdp_ctloutput
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|opt
decl_stmt|,
name|optval
decl_stmt|;
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ssk
operator|=
name|sdp_sk
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_level
operator|==
name|SOL_SOCKET
operator|&&
name|sopt
operator|->
name|sopt_name
operator|==
name|SO_KEEPALIVE
condition|)
block|{
name|SDP_WLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_KEEPALIVE
condition|)
name|sdp_start_keepalive_timer
argument_list|(
name|so
argument_list|)
expr_stmt|;
else|else
name|sdp_stop_keepalive_timer
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sopt
operator|->
name|sopt_level
operator|!=
name|IPPROTO_TCP
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|SDP_WLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssk
operator|->
name|flags
operator|&
operator|(
name|SDP_TIMEWAIT
operator||
name|SDP_DROPPED
operator|)
condition|)
block|{
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
return|return
operator|(
name|ECONNRESET
operator|)
return|;
block|}
switch|switch
condition|(
name|sopt
operator|->
name|sopt_dir
condition|)
block|{
case|case
name|SOPT_SET
case|:
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|TCP_NODELAY
case|:
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|SDP_WLOCK_RECHECK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|opt
operator|=
name|SDP_NODELAY
expr_stmt|;
if|if
condition|(
name|optval
condition|)
name|ssk
operator|->
name|flags
operator||=
name|opt
expr_stmt|;
else|else
name|ssk
operator|->
name|flags
operator|&=
operator|~
name|opt
expr_stmt|;
name|sdp_do_posts
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
break|break;
default|default:
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SOPT_GET
case|:
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|TCP_NODELAY
case|:
name|optval
operator|=
name|ssk
operator|->
name|flags
operator|&
name|SDP_NODELAY
expr_stmt|;
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
break|break;
default|default:
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|SDP_WLOCK_RECHECK
end_undef

begin_decl_stmt
name|int
name|sdp_mod_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sdp_mod_usec
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|sdp_set_default_moderation
parameter_list|(
name|struct
name|sdp_sock
modifier|*
name|ssk
parameter_list|)
block|{
name|struct
name|ib_cq_attr
name|attr
decl_stmt|;
if|if
condition|(
name|sdp_mod_count
operator|<=
literal|0
operator|||
name|sdp_mod_usec
operator|<=
literal|0
condition|)
return|return;
name|memset
argument_list|(
operator|&
name|attr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|attr
argument_list|)
argument_list|)
expr_stmt|;
name|attr
operator|.
name|moderation
operator|.
name|cq_count
operator|=
name|sdp_mod_count
expr_stmt|;
name|attr
operator|.
name|moderation
operator|.
name|cq_period
operator|=
name|sdp_mod_usec
expr_stmt|;
name|ib_modify_cq
argument_list|(
name|ssk
operator|->
name|rx_ring
operator|.
name|cq
argument_list|,
operator|&
name|attr
argument_list|,
name|IB_CQ_MODERATION
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdp_dev_add
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|)
block|{
name|struct
name|ib_fmr_pool_param
name|param
decl_stmt|;
name|struct
name|sdp_device
modifier|*
name|sdp_dev
decl_stmt|;
name|sdp_dev
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sdp_dev
argument_list|)
argument_list|,
name|M_SDP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sdp_dev
operator|->
name|pd
operator|=
name|ib_alloc_pd
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|sdp_dev
operator|->
name|pd
argument_list|)
condition|)
goto|goto
name|out_pd
goto|;
name|sdp_dev
operator|->
name|mr
operator|=
name|ib_get_dma_mr
argument_list|(
name|sdp_dev
operator|->
name|pd
argument_list|,
name|IB_ACCESS_LOCAL_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|sdp_dev
operator|->
name|mr
argument_list|)
condition|)
goto|goto
name|out_mr
goto|;
name|memset
argument_list|(
operator|&
name|param
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|param
argument_list|)
expr_stmt|;
name|param
operator|.
name|max_pages_per_fmr
operator|=
name|SDP_FMR_SIZE
expr_stmt|;
name|param
operator|.
name|page_shift
operator|=
name|PAGE_SHIFT
expr_stmt|;
name|param
operator|.
name|access
operator|=
operator|(
name|IB_ACCESS_LOCAL_WRITE
operator||
name|IB_ACCESS_REMOTE_READ
operator|)
expr_stmt|;
name|param
operator|.
name|pool_size
operator|=
name|SDP_FMR_POOL_SIZE
expr_stmt|;
name|param
operator|.
name|dirty_watermark
operator|=
name|SDP_FMR_DIRTY_SIZE
expr_stmt|;
name|param
operator|.
name|cache
operator|=
literal|1
expr_stmt|;
name|sdp_dev
operator|->
name|fmr_pool
operator|=
name|ib_create_fmr_pool
argument_list|(
name|sdp_dev
operator|->
name|pd
argument_list|,
operator|&
name|param
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|sdp_dev
operator|->
name|fmr_pool
argument_list|)
condition|)
goto|goto
name|out_fmr
goto|;
name|ib_set_client_data
argument_list|(
name|device
argument_list|,
operator|&
name|sdp_client
argument_list|,
name|sdp_dev
argument_list|)
expr_stmt|;
return|return;
name|out_fmr
label|:
name|ib_dereg_mr
argument_list|(
name|sdp_dev
operator|->
name|mr
argument_list|)
expr_stmt|;
name|out_mr
label|:
name|ib_dealloc_pd
argument_list|(
name|sdp_dev
operator|->
name|pd
argument_list|)
expr_stmt|;
name|out_pd
label|:
name|free
argument_list|(
name|sdp_dev
argument_list|,
name|M_SDP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdp_dev_rem
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|)
block|{
name|struct
name|sdp_device
modifier|*
name|sdp_dev
decl_stmt|;
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|;
name|SDP_LIST_WLOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ssk
argument_list|,
argument|&sdp_list
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|ssk
operator|->
name|ib_device
operator|!=
name|device
condition|)
continue|continue;
name|SDP_WLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ssk
operator|->
name|flags
operator|&
name|SDP_DESTROY
operator|)
operator|==
literal|0
condition|)
name|ssk
operator|=
name|sdp_notify
argument_list|(
name|ssk
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssk
condition|)
name|SDP_WUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
block|}
name|SDP_LIST_WUNLOCK
argument_list|()
expr_stmt|;
comment|/* 	 * XXX Do I need to wait between these two? 	 */
name|sdp_dev
operator|=
name|ib_get_client_data
argument_list|(
name|device
argument_list|,
operator|&
name|sdp_client
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sdp_dev
condition|)
return|return;
name|ib_flush_fmr_pool
argument_list|(
name|sdp_dev
operator|->
name|fmr_pool
argument_list|)
expr_stmt|;
name|ib_destroy_fmr_pool
argument_list|(
name|sdp_dev
operator|->
name|fmr_pool
argument_list|)
expr_stmt|;
name|ib_dereg_mr
argument_list|(
name|sdp_dev
operator|->
name|mr
argument_list|)
expr_stmt|;
name|ib_dealloc_pd
argument_list|(
name|sdp_dev
operator|->
name|pd
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sdp_dev
argument_list|,
name|M_SDP
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|ib_client
name|sdp_client
init|=
block|{
operator|.
name|name
operator|=
literal|"sdp"
block|,
operator|.
name|add
operator|=
name|sdp_dev_add
block|,
operator|.
name|remove
operator|=
name|sdp_dev_rem
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|sdp_pcblist
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|n
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|sdp_sock
modifier|*
name|ssk
decl_stmt|;
name|struct
name|xinpgen
name|xig
decl_stmt|;
comment|/* 	 * The process of preparing the TCB list is too time-consuming and 	 * resource-intensive to repeat twice on every request. 	 */
if|if
condition|(
name|req
operator|->
name|oldptr
operator|==
name|NULL
condition|)
block|{
name|n
operator|=
name|sdp_count
expr_stmt|;
name|n
operator|+=
name|imax
argument_list|(
name|n
operator|/
literal|8
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|req
operator|->
name|oldidx
operator|=
literal|2
operator|*
operator|(
sizeof|sizeof
name|xig
operator|)
operator|+
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|xtcpcb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* 	 * OK, now we're committed to doing something. 	 */
name|SDP_LIST_RLOCK
argument_list|()
expr_stmt|;
name|n
operator|=
name|sdp_count
expr_stmt|;
name|SDP_LIST_RUNLOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|2
operator|*
operator|(
sizeof|sizeof
name|xig
operator|)
operator|+
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|xtcpcb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|xig
operator|.
name|xig_len
operator|=
sizeof|sizeof
name|xig
expr_stmt|;
name|xig
operator|.
name|xig_count
operator|=
name|n
expr_stmt|;
name|xig
operator|.
name|xig_gen
operator|=
literal|0
expr_stmt|;
name|xig
operator|.
name|xig_sogen
operator|=
name|so_gencnt
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|xig
argument_list|,
sizeof|sizeof
name|xig
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|SDP_LIST_RLOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|ssk
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sdp_list
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|ssk
operator|!=
name|NULL
operator|&&
name|i
operator|<
name|n
condition|;
name|ssk
operator|=
name|LIST_NEXT
argument_list|(
name|ssk
argument_list|,
name|list
argument_list|)
control|)
block|{
name|struct
name|xtcpcb
name|xt
decl_stmt|;
name|SDP_RLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
if|if
condition|(
name|ssk
operator|->
name|flags
operator|&
name|SDP_TIMEWAIT
condition|)
block|{
if|if
condition|(
name|ssk
operator|->
name|cred
operator|!=
name|NULL
condition|)
name|error
operator|=
name|cr_cansee
argument_list|(
name|req
operator|->
name|td
operator|->
name|td_ucred
argument_list|,
name|ssk
operator|->
name|cred
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* Skip this inp. */
block|}
elseif|else
if|if
condition|(
name|ssk
operator|->
name|socket
condition|)
name|error
operator|=
name|cr_canseesocket
argument_list|(
name|req
operator|->
name|td
operator|->
name|td_ucred
argument_list|,
name|ssk
operator|->
name|socket
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|bzero
argument_list|(
operator|&
name|xt
argument_list|,
sizeof|sizeof
argument_list|(
name|xt
argument_list|)
argument_list|)
expr_stmt|;
name|xt
operator|.
name|xt_len
operator|=
sizeof|sizeof
name|xt
expr_stmt|;
name|xt
operator|.
name|xt_inp
operator|.
name|inp_gencnt
operator|=
literal|0
expr_stmt|;
name|xt
operator|.
name|xt_inp
operator|.
name|inp_vflag
operator|=
name|INP_IPV4
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|xt
operator|.
name|xt_inp
operator|.
name|inp_laddr
argument_list|,
operator|&
name|ssk
operator|->
name|laddr
argument_list|,
sizeof|sizeof
argument_list|(
name|ssk
operator|->
name|laddr
argument_list|)
argument_list|)
expr_stmt|;
name|xt
operator|.
name|xt_inp
operator|.
name|inp_lport
operator|=
name|ssk
operator|->
name|lport
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|xt
operator|.
name|xt_inp
operator|.
name|inp_faddr
argument_list|,
operator|&
name|ssk
operator|->
name|faddr
argument_list|,
sizeof|sizeof
argument_list|(
name|ssk
operator|->
name|faddr
argument_list|)
argument_list|)
expr_stmt|;
name|xt
operator|.
name|xt_inp
operator|.
name|inp_fport
operator|=
name|ssk
operator|->
name|fport
expr_stmt|;
name|xt
operator|.
name|t_state
operator|=
name|ssk
operator|->
name|state
expr_stmt|;
if|if
condition|(
name|ssk
operator|->
name|socket
operator|!=
name|NULL
condition|)
name|sotoxsocket
argument_list|(
name|ssk
operator|->
name|socket
argument_list|,
operator|&
name|xt
operator|.
name|xt_inp
operator|.
name|xi_socket
argument_list|)
expr_stmt|;
name|xt
operator|.
name|xt_inp
operator|.
name|xi_socket
operator|.
name|xso_protocol
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|SDP_RUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|xt
argument_list|,
sizeof|sizeof
name|xt
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|i
operator|++
expr_stmt|;
continue|continue;
name|next
label|:
name|SDP_RUNLOCK
argument_list|(
name|ssk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* 		 * Give the user an updated idea of our state. 		 * If the generation differs from what we told 		 * her before, she knows that something happened 		 * while we were processing this request, and it 		 * might be necessary to retry. 		 */
name|xig
operator|.
name|xig_gen
operator|=
literal|0
expr_stmt|;
name|xig
operator|.
name|xig_sogen
operator|=
name|so_gencnt
expr_stmt|;
name|xig
operator|.
name|xig_count
operator|=
name|sdp_count
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|xig
argument_list|,
sizeof|sizeof
name|xig
argument_list|)
expr_stmt|;
block|}
name|SDP_LIST_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_net_inet
argument_list|,
operator|-
literal|1
argument_list|,
name|sdp
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"SDP"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_sdp
argument_list|,
name|TCPCTL_PCBLIST
argument_list|,
name|pcblist
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_STRUCT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sdp_pcblist
argument_list|,
literal|"S,xtcpcb"
argument_list|,
literal|"List of active SDP connections"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|sdp_zone_change
parameter_list|(
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|uma_zone_set_max
argument_list|(
name|sdp_zone
argument_list|,
name|maxsockets
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdp_init
parameter_list|(
name|void
parameter_list|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|sdp_list
argument_list|)
expr_stmt|;
name|sdp_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"sdp_sock"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sdp_sock
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
name|UMA_ZONE_NOFREE
argument_list|)
expr_stmt|;
name|uma_zone_set_max
argument_list|(
name|sdp_zone
argument_list|,
name|maxsockets
argument_list|)
expr_stmt|;
name|EVENTHANDLER_REGISTER
argument_list|(
name|maxsockets_change
argument_list|,
name|sdp_zone_change
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|rx_comp_wq
operator|=
name|create_singlethread_workqueue
argument_list|(
literal|"rx_comp_wq"
argument_list|)
expr_stmt|;
name|ib_register_client
argument_list|(
operator|&
name|sdp_client
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|struct
name|domain
name|sdpdomain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pr_usrreqs
name|sdp_usrreqs
init|=
block|{
operator|.
name|pru_abort
operator|=
name|sdp_abort
block|,
operator|.
name|pru_accept
operator|=
name|sdp_accept
block|,
operator|.
name|pru_attach
operator|=
name|sdp_attach
block|,
operator|.
name|pru_bind
operator|=
name|sdp_bind
block|,
operator|.
name|pru_connect
operator|=
name|sdp_connect
block|,
operator|.
name|pru_control
operator|=
name|sdp_control
block|,
operator|.
name|pru_detach
operator|=
name|sdp_detach
block|,
operator|.
name|pru_disconnect
operator|=
name|sdp_disconnect
block|,
operator|.
name|pru_listen
operator|=
name|sdp_listen
block|,
operator|.
name|pru_peeraddr
operator|=
name|sdp_getpeeraddr
block|,
operator|.
name|pru_rcvoob
operator|=
name|sdp_rcvoob
block|,
operator|.
name|pru_send
operator|=
name|sdp_send
block|,
operator|.
name|pru_sosend
operator|=
name|sdp_sosend
block|,
operator|.
name|pru_soreceive
operator|=
name|sdp_sorecv
block|,
operator|.
name|pru_shutdown
operator|=
name|sdp_shutdown
block|,
operator|.
name|pru_sockaddr
operator|=
name|sdp_getsockaddr
block|,
operator|.
name|pru_close
operator|=
name|sdp_close
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|protosw
name|sdpsw
index|[]
init|=
block|{
block|{
operator|.
name|pr_type
operator|=
name|SOCK_STREAM
block|,
operator|.
name|pr_domain
operator|=
operator|&
name|sdpdomain
block|,
operator|.
name|pr_protocol
operator|=
name|IPPROTO_IP
block|,
operator|.
name|pr_flags
operator|=
name|PR_CONNREQUIRED
operator||
name|PR_IMPLOPCL
operator||
name|PR_WANTRCVD
block|,
operator|.
name|pr_ctlinput
operator|=
name|sdp_ctlinput
block|,
operator|.
name|pr_ctloutput
operator|=
name|sdp_ctloutput
block|,
operator|.
name|pr_usrreqs
operator|=
operator|&
name|sdp_usrreqs
block|}
block|,
block|{
operator|.
name|pr_type
operator|=
name|SOCK_STREAM
block|,
operator|.
name|pr_domain
operator|=
operator|&
name|sdpdomain
block|,
operator|.
name|pr_protocol
operator|=
name|IPPROTO_TCP
block|,
operator|.
name|pr_flags
operator|=
name|PR_CONNREQUIRED
operator||
name|PR_IMPLOPCL
operator||
name|PR_WANTRCVD
block|,
operator|.
name|pr_ctlinput
operator|=
name|sdp_ctlinput
block|,
operator|.
name|pr_ctloutput
operator|=
name|sdp_ctloutput
block|,
operator|.
name|pr_usrreqs
operator|=
operator|&
name|sdp_usrreqs
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|domain
name|sdpdomain
init|=
block|{
operator|.
name|dom_family
operator|=
name|AF_INET_SDP
block|,
operator|.
name|dom_name
operator|=
literal|"SDP"
block|,
operator|.
name|dom_init
operator|=
name|sdp_init
block|,
operator|.
name|dom_protosw
operator|=
name|sdpsw
block|,
operator|.
name|dom_protoswNPROTOSW
operator|=
operator|&
name|sdpsw
index|[
sizeof|sizeof
argument_list|(
name|sdpsw
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|sdpsw
index|[
literal|0
index|]
argument_list|)
index|]
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DOMAIN_SET
argument_list|(
name|sdp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|sdp_debug_level
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sdp_data_debug_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

end_unit

