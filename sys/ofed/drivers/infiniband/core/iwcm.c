begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004, 2005 Intel Corporation.  All rights reserved.  * Copyright (c) 2004 Topspin Corporation.  All rights reserved.  * Copyright (c) 2004, 2005 Voltaire Corporation.  All rights reserved.  * Copyright (c) 2005 Sun Microsystems, Inc. All rights reserved.  * Copyright (c) 2005 Open Grid Computing, Inc. All rights reserved.  * Copyright (c) 2005 Network Appliance, Inc. All rights reserved.  * Copyright (c) 2016 Chelsio Communications.  All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<linux/dma-mapping.h>
end_include

begin_include
include|#
directive|include
file|<linux/err.h>
end_include

begin_include
include|#
directive|include
file|<linux/idr.h>
end_include

begin_include
include|#
directive|include
file|<linux/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<linux/rbtree.h>
end_include

begin_include
include|#
directive|include
file|<linux/sched.h>
end_include

begin_include
include|#
directive|include
file|<linux/spinlock.h>
end_include

begin_include
include|#
directive|include
file|<linux/workqueue.h>
end_include

begin_include
include|#
directive|include
file|<linux/completion.h>
end_include

begin_include
include|#
directive|include
file|<linux/slab.h>
end_include

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/string.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<rdma/rdma_cm.h>
end_include

begin_include
include|#
directive|include
file|<rdma/iw_cm.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_addr.h>
end_include

begin_include
include|#
directive|include
file|"iwcm.h"
end_include

begin_expr_stmt
name|MODULE_AUTHOR
argument_list|(
literal|"Tom Tucker"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DESCRIPTION
argument_list|(
literal|"iWARP CM"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_LICENSE
argument_list|(
literal|"Dual BSD/GPL"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|workqueue_struct
modifier|*
name|iwcm_wq
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|iwcm_work
block|{
name|struct
name|work_struct
name|work
decl_stmt|;
name|struct
name|iwcm_id_private
modifier|*
name|cm_id
decl_stmt|;
name|struct
name|list_head
name|list
decl_stmt|;
name|struct
name|iw_cm_event
name|event
decl_stmt|;
name|struct
name|list_head
name|free_list
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|iwcm_listen_work
block|{
name|struct
name|work_struct
name|work
decl_stmt|;
name|struct
name|iw_cm_id
modifier|*
name|cm_id
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
name|listen_port_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|DEFINE_MUTEX
argument_list|(
name|listen_port_mutex
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|listen_port_info
block|{
name|struct
name|list_head
name|list
decl_stmt|;
name|uint16_t
name|port_num
decl_stmt|;
name|uint32_t
name|refcnt
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int32_t
name|add_port_to_listenlist
parameter_list|(
name|uint16_t
name|port
parameter_list|)
block|{
name|struct
name|listen_port_info
modifier|*
name|port_info
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|listen_port_mutex
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|port_info
argument_list|,
argument|&listen_port_list
argument_list|,
argument|list
argument_list|)
if|if
condition|(
name|port_info
operator|->
name|port_num
operator|==
name|port
condition|)
goto|goto
name|found_port
goto|;
name|port_info
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|port_info
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port_info
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|listen_port_mutex
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|port_info
operator|->
name|port_num
operator|=
name|port
expr_stmt|;
name|port_info
operator|->
name|refcnt
operator|=
literal|0
expr_stmt|;
name|list_add
argument_list|(
operator|&
name|port_info
operator|->
name|list
argument_list|,
operator|&
name|listen_port_list
argument_list|)
expr_stmt|;
name|found_port
label|:
operator|++
operator|(
name|port_info
operator|->
name|refcnt
operator|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|listen_port_mutex
argument_list|)
expr_stmt|;
return|return
name|port_info
operator|->
name|refcnt
return|;
name|out
label|:
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
name|rem_port_from_listenlist
parameter_list|(
name|uint16_t
name|port
parameter_list|)
block|{
name|struct
name|listen_port_info
modifier|*
name|port_info
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|found_port
init|=
literal|0
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|listen_port_mutex
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|port_info
argument_list|,
argument|&listen_port_list
argument_list|,
argument|list
argument_list|)
if|if
condition|(
name|port_info
operator|->
name|port_num
operator|==
name|port
condition|)
block|{
name|found_port
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found_port
condition|)
block|{
operator|--
operator|(
name|port_info
operator|->
name|refcnt
operator|)
expr_stmt|;
name|ret
operator|=
name|port_info
operator|->
name|refcnt
expr_stmt|;
if|if
condition|(
name|port_info
operator|->
name|refcnt
operator|==
literal|0
condition|)
block|{
comment|/* Remove this entry from the list as there are no 			 * more listeners for this port_num. 			 */
name|list_del
argument_list|(
operator|&
name|port_info
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|port_info
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
name|mutex_unlock
argument_list|(
operator|&
name|listen_port_mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * The following services provide a mechanism for pre-allocating iwcm_work  * elements.  The design pre-allocates them  based on the cm_id type:  *	LISTENING IDS: 	Get enough elements preallocated to handle the  *			listen backlog.  *	ACTIVE IDS:	4: CONNECT_REPLY, ESTABLISHED, DISCONNECT, CLOSE  *	PASSIVE IDS:	3: ESTABLISHED, DISCONNECT, CLOSE  *  * Allocating them in connect and listen avoids having to deal  * with allocation failures on the event upcall from the provider (which  * is called in the interrupt context).  *  * One exception is when creating the cm_id for incoming connection requests.  * There are two cases:  * 1) in the event upcall, cm_event_handler(), for a listening cm_id.  If  *    the backlog is exceeded, then no more connection request events will  *    be processed.  cm_event_handler() returns -ENOMEM in this case.  Its up  *    to the provider to reject the connection request.  * 2) in the connection request workqueue handler, cm_conn_req_handler().  *    If work elements cannot be allocated for the new connect request cm_id,  *    then IWCM will call the provider reject method.  This is ok since  *    cm_conn_req_handler() runs in the workqueue thread context.  */
end_comment

begin_function
specifier|static
name|struct
name|iwcm_work
modifier|*
name|get_work
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
parameter_list|)
block|{
name|struct
name|iwcm_work
modifier|*
name|work
decl_stmt|;
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_free_list
argument_list|)
condition|)
return|return
name|NULL
return|;
name|work
operator|=
name|list_entry
argument_list|(
name|cm_id_priv
operator|->
name|work_free_list
operator|.
name|next
argument_list|,
expr|struct
name|iwcm_work
argument_list|,
name|free_list
argument_list|)
expr_stmt|;
name|list_del_init
argument_list|(
operator|&
name|work
operator|->
name|free_list
argument_list|)
expr_stmt|;
return|return
name|work
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|put_work
parameter_list|(
name|struct
name|iwcm_work
modifier|*
name|work
parameter_list|)
block|{
name|list_add
argument_list|(
operator|&
name|work
operator|->
name|free_list
argument_list|,
operator|&
name|work
operator|->
name|cm_id
operator|->
name|work_free_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dealloc_work_entries
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
parameter_list|)
block|{
name|struct
name|list_head
modifier|*
name|e
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|list_for_each_safe
argument_list|(
argument|e
argument_list|,
argument|tmp
argument_list|,
argument|&cm_id_priv->work_free_list
argument_list|)
name|kfree
argument_list|(
name|list_entry
argument_list|(
name|e
argument_list|,
expr|struct
name|iwcm_work
argument_list|,
name|free_list
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_work_entries
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|iwcm_work
modifier|*
name|work
decl_stmt|;
name|BUG_ON
argument_list|(
operator|!
name|list_empty
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_free_list
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|work
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iwcm_work
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|work
condition|)
block|{
name|dealloc_work_entries
argument_list|(
name|cm_id_priv
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|work
operator|->
name|cm_id
operator|=
name|cm_id_priv
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|work
operator|->
name|list
argument_list|)
expr_stmt|;
name|put_work
argument_list|(
name|work
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Save private data from incoming connection requests to  * iw_cm_event, so the low level driver doesn't have to. Adjust  * the event ptr to point to the local copy.  */
end_comment

begin_function
specifier|static
name|int
name|copy_private_data
parameter_list|(
name|struct
name|iw_cm_event
modifier|*
name|event
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|kmemdup
argument_list|(
name|event
operator|->
name|private_data
argument_list|,
name|event
operator|->
name|private_data_len
argument_list|,
name|GFP_ATOMIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|event
operator|->
name|private_data
operator|=
name|p
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_cm_id
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
parameter_list|)
block|{
name|dealloc_work_entries
argument_list|(
name|cm_id_priv
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|cm_id_priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Release a reference on cm_id. If the last reference is being  * released, enable the waiting thread (in iw_destroy_cm_id) to  * get woken up, and return 1 if a thread is already waiting.  */
end_comment

begin_function
specifier|static
name|int
name|iwcm_deref_id
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
parameter_list|)
block|{
name|BUG_ON
argument_list|(
name|atomic_read
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|refcount
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_dec_and_test
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|refcount
argument_list|)
condition|)
block|{
name|BUG_ON
argument_list|(
operator|!
name|list_empty
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_list
argument_list|)
argument_list|)
expr_stmt|;
name|complete
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|destroy_comp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_ref
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|)
block|{
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|atomic_inc
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|refcount
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rem_ref
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|)
block|{
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|int
name|cb_destroy
decl_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* 	 * Test bit before deref in case the cm_id gets freed on another 	 * thread. 	 */
name|cb_destroy
operator|=
name|test_bit
argument_list|(
name|IWCM_F_CALLBACK_DESTROY
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|iwcm_deref_id
argument_list|(
name|cm_id_priv
argument_list|)
operator|&&
name|cb_destroy
condition|)
block|{
name|BUG_ON
argument_list|(
operator|!
name|list_empty
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_list
argument_list|)
argument_list|)
expr_stmt|;
name|free_cm_id
argument_list|(
name|cm_id_priv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function_decl
specifier|static
name|int
name|cm_event_handler
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
name|struct
name|iw_cm_event
modifier|*
name|event
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|struct
name|iw_cm_id
modifier|*
name|iw_create_cm_id
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|iw_cm_handler
name|cm_handler
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|cm_id_priv
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cm_id_priv
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cm_id_priv
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_IDLE
expr_stmt|;
name|cm_id_priv
operator|->
name|id
operator|.
name|device
operator|=
name|device
expr_stmt|;
name|cm_id_priv
operator|->
name|id
operator|.
name|cm_handler
operator|=
name|cm_handler
expr_stmt|;
name|cm_id_priv
operator|->
name|id
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|cm_id_priv
operator|->
name|id
operator|.
name|event_handler
operator|=
name|cm_event_handler
expr_stmt|;
name|cm_id_priv
operator|->
name|id
operator|.
name|add_ref
operator|=
name|add_ref
expr_stmt|;
name|cm_id_priv
operator|->
name|id
operator|.
name|rem_ref
operator|=
name|rem_ref
expr_stmt|;
name|cm_id_priv
operator|->
name|id
operator|.
name|so
operator|=
name|so
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
name|atomic_set
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|init_waitqueue_head
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|connect_wait
argument_list|)
expr_stmt|;
name|init_completion
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|destroy_comp
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_free_list
argument_list|)
expr_stmt|;
return|return
operator|&
name|cm_id_priv
operator|->
name|id
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|iw_create_cm_id
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|iwcm_modify_qp_err
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|ib_qp_attr
name|qp_attr
decl_stmt|;
if|if
condition|(
operator|!
name|qp
condition|)
return|return
operator|-
name|EINVAL
return|;
name|qp_attr
operator|.
name|qp_state
operator|=
name|IB_QPS_ERR
expr_stmt|;
return|return
name|ib_modify_qp
argument_list|(
name|qp
argument_list|,
operator|&
name|qp_attr
argument_list|,
name|IB_QP_STATE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is really the RDMAC CLOSING state. It is most similar to the  * IB SQD QP state.  */
end_comment

begin_function
specifier|static
name|int
name|iwcm_modify_qp_sqd
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|ib_qp_attr
name|qp_attr
decl_stmt|;
name|BUG_ON
argument_list|(
name|qp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|qp_attr
operator|.
name|qp_state
operator|=
name|IB_QPS_SQD
expr_stmt|;
return|return
name|ib_modify_qp
argument_list|(
name|qp
argument_list|,
operator|&
name|qp_attr
argument_list|,
name|IB_QP_STATE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * CM_ID<-- CLOSING  *  * Block if a passive or active connection is currently being processed. Then  * process the event as follows:  * - If we are ESTABLISHED, move to CLOSING and modify the QP state  *   based on the abrupt flag  * - If the connection is already in the CLOSING or IDLE state, the peer is  *   disconnecting concurrently with us and we've already seen the  *   DISCONNECT event -- ignore the request and return 0  * - Disconnect on a listening endpoint returns -EINVAL  */
end_comment

begin_function
name|int
name|iw_cm_disconnect
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
name|int
name|abrupt
parameter_list|)
block|{
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|ib_qp
modifier|*
name|qp
init|=
name|NULL
decl_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* Wait if we're currently in a connect or accept downcall */
name|wait_event
argument_list|(
name|cm_id_priv
operator|->
name|connect_wait
argument_list|,
operator|!
name|test_bit
argument_list|(
name|IWCM_F_CONNECT_WAIT
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cm_id_priv
operator|->
name|state
condition|)
block|{
case|case
name|IW_CM_STATE_ESTABLISHED
case|:
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_CLOSING
expr_stmt|;
comment|/* QP could be<nul> for user-mode client */
if|if
condition|(
name|cm_id_priv
operator|->
name|qp
condition|)
name|qp
operator|=
name|cm_id_priv
operator|->
name|qp
expr_stmt|;
else|else
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
case|case
name|IW_CM_STATE_LISTEN
case|:
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
case|case
name|IW_CM_STATE_CLOSING
case|:
comment|/* remote peer closed first */
case|case
name|IW_CM_STATE_IDLE
case|:
comment|/* accept or connect returned !0 */
break|break;
case|case
name|IW_CM_STATE_CONN_RECV
case|:
comment|/* 		 * App called disconnect before/without calling accept after 		 * connect_request event delivered. 		 */
break|break;
case|case
name|IW_CM_STATE_CONN_SENT
case|:
comment|/* Can only get here if wait above fails */
default|default:
name|BUG
argument_list|()
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
condition|)
block|{
if|if
condition|(
name|abrupt
condition|)
name|ret
operator|=
name|iwcm_modify_qp_err
argument_list|(
name|qp
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|iwcm_modify_qp_sqd
argument_list|(
name|qp
argument_list|)
expr_stmt|;
comment|/* 		 * If both sides are disconnecting the QP could 		 * already be in ERR or SQD states 		 */
name|ret
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|iw_cm_disconnect
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|struct
name|socket
modifier|*
name|dequeue_socket
parameter_list|(
name|struct
name|socket
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|remote
decl_stmt|;
name|ACCEPT_LOCK
argument_list|()
expr_stmt|;
name|so
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|head
operator|->
name|so_comp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|so
condition|)
block|{
name|ACCEPT_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
comment|/* 	 * Before changing the flags on the socket, we have to bump the 	 * reference count.  Otherwise, if the protocol calls sofree(), 	 * the socket will be released due to a zero refcount. 	 */
name|soref
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|head
operator|->
name|so_comp
argument_list|,
name|so
argument_list|,
name|so_list
argument_list|)
expr_stmt|;
name|head
operator|->
name|so_qlen
operator|--
expr_stmt|;
name|so
operator|->
name|so_qstate
operator|&=
operator|~
name|SQ_COMP
expr_stmt|;
name|so
operator|->
name|so_head
operator|=
name|NULL
expr_stmt|;
name|so
operator|->
name|so_state
operator||=
name|SS_NBIO
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|ACCEPT_UNLOCK
argument_list|()
expr_stmt|;
name|soaccept
argument_list|(
name|so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
operator|&
name|remote
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|remote
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
return|return
name|so
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iw_so_event_handler
parameter_list|(
name|struct
name|work_struct
modifier|*
name|_work
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET
name|struct
name|iwcm_listen_work
modifier|*
name|work
init|=
name|container_of
argument_list|(
name|_work
argument_list|,
expr|struct
name|iwcm_listen_work
argument_list|,
name|work
argument_list|)
decl_stmt|;
name|struct
name|iw_cm_id
modifier|*
name|listen_cm_id
init|=
name|work
operator|->
name|cm_id
decl_stmt|;
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|struct
name|iw_cm_id
modifier|*
name|real_cm_id
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|local
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|listen_cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm_id_priv
operator|->
name|state
operator|!=
name|IW_CM_STATE_LISTEN
condition|)
block|{
name|kfree
argument_list|(
name|work
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Dequeue& process  all new 'so' connection requests for this cmid */
while|while
condition|(
operator|(
name|so
operator|=
name|dequeue_socket
argument_list|(
name|work
operator|->
name|cm_id
operator|->
name|so
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rdma_cma_any_addr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|listen_cm_id
operator|->
name|local_addr
argument_list|)
condition|)
block|{
name|in_getsockaddr
argument_list|(
name|so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
operator|&
name|local
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdma_find_cmid_laddr
argument_list|(
name|local
argument_list|,
name|ARPHRD_ETHER
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|real_cm_id
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|local
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|free
argument_list|(
name|local
argument_list|,
name|M_SONAME
argument_list|)
expr_stmt|;
name|real_cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|newconn
argument_list|(
name|real_cm_id
argument_list|,
name|so
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|listen_cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|newconn
argument_list|(
name|listen_cm_id
argument_list|,
name|so
argument_list|)
expr_stmt|;
block|}
block|}
name|err
label|:
name|kfree
argument_list|(
name|work
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|iw_so_upcall
parameter_list|(
name|struct
name|socket
modifier|*
name|parent_so
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|waitflag
parameter_list|)
block|{
name|struct
name|iwcm_listen_work
modifier|*
name|work
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|iw_cm_id
modifier|*
name|cm_id
init|=
name|arg
decl_stmt|;
comment|/* check whether iw_so_event_handler() already dequeued this 'so' */
name|so
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|parent_so
operator|->
name|so_comp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|so
condition|)
return|return
name|SU_OK
return|;
name|work
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|work
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|work
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|work
operator|->
name|cm_id
operator|=
name|cm_id
expr_stmt|;
name|INIT_WORK
argument_list|(
operator|&
name|work
operator|->
name|work
argument_list|,
name|iw_so_event_handler
argument_list|)
expr_stmt|;
name|queue_work
argument_list|(
name|iwcm_wq
argument_list|,
operator|&
name|work
operator|->
name|work
argument_list|)
expr_stmt|;
return|return
name|SU_OK
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iw_init_sock
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|)
block|{
name|struct
name|sockopt
name|sopt
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|cm_id
operator|->
name|so
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|soupcall_set
argument_list|(
name|so
argument_list|,
name|SO_RCV
argument_list|,
name|iw_so_upcall
argument_list|,
name|cm_id
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_state
operator||=
name|SS_NBIO
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sopt
operator|.
name|sopt_dir
operator|=
name|SOPT_SET
expr_stmt|;
name|sopt
operator|.
name|sopt_level
operator|=
name|IPPROTO_TCP
expr_stmt|;
name|sopt
operator|.
name|sopt_name
operator|=
name|TCP_NODELAY
expr_stmt|;
name|sopt
operator|.
name|sopt_val
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|on
expr_stmt|;
name|sopt
operator|.
name|sopt_valsize
operator|=
sizeof|sizeof
argument_list|(
name|on
argument_list|)
expr_stmt|;
name|sopt
operator|.
name|sopt_td
operator|=
name|NULL
expr_stmt|;
name|sosetopt
argument_list|(
name|so
argument_list|,
operator|&
name|sopt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|iw_close_socket
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
name|int
name|close
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|cm_id
operator|->
name|so
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|soupcall_clear
argument_list|(
name|so
argument_list|,
name|SO_RCV
argument_list|)
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|close
condition|)
name|rc
operator|=
name|soclose
argument_list|(
name|so
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
name|soshutdown
argument_list|(
name|so
argument_list|,
name|SHUT_WR
operator||
name|SHUT_RD
argument_list|)
expr_stmt|;
name|cm_id
operator|->
name|so
operator|=
name|NULL
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iw_create_listen
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
name|int
name|backlog
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|iw_init_sock
argument_list|(
name|cm_id
argument_list|)
expr_stmt|;
name|rc
operator|=
name|solisten
argument_list|(
name|cm_id
operator|->
name|so
argument_list|,
name|backlog
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
name|iw_close_socket
argument_list|(
name|cm_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iw_destroy_listen
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|iw_close_socket
argument_list|(
name|cm_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/*  * CM_ID<-- DESTROYING  *  * Clean up all resources associated with the connection and release  * the initial reference taken by iw_create_cm_id.  */
end_comment

begin_function
specifier|static
name|void
name|destroy_cm_id
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|)
block|{
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|refcnt
decl_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
comment|/* 	 * Wait if we're currently in a connect or accept downcall. A 	 * listening endpoint should never block here. 	 */
name|wait_event
argument_list|(
name|cm_id_priv
operator|->
name|connect_wait
argument_list|,
operator|!
name|test_bit
argument_list|(
name|IWCM_F_CONNECT_WAIT
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cm_id_priv
operator|->
name|state
condition|)
block|{
case|case
name|IW_CM_STATE_LISTEN
case|:
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_DESTROYING
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdma_cma_any_addr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|cm_id
operator|->
name|local_addr
argument_list|)
condition|)
block|{
name|refcnt
operator|=
name|rem_port_from_listenlist
argument_list|(
name|cm_id
operator|->
name|local_addr
operator|.
name|sin_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|refcnt
operator|==
literal|0
condition|)
name|ret
operator|=
name|iw_destroy_listen
argument_list|(
name|cm_id
argument_list|)
expr_stmt|;
name|cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|destroy_listen_ep
argument_list|(
name|cm_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|iw_destroy_listen
argument_list|(
name|cm_id
argument_list|)
expr_stmt|;
name|cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|destroy_listen_ep
argument_list|(
name|cm_id
argument_list|)
expr_stmt|;
block|}
name|spin_lock_irqsave
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|IW_CM_STATE_ESTABLISHED
case|:
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_DESTROYING
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Abrupt close of the connection */
operator|(
name|void
operator|)
name|iwcm_modify_qp_err
argument_list|(
name|cm_id_priv
operator|->
name|qp
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|IW_CM_STATE_IDLE
case|:
case|case
name|IW_CM_STATE_CLOSING
case|:
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_DESTROYING
expr_stmt|;
break|break;
case|case
name|IW_CM_STATE_CONN_RECV
case|:
comment|/* 		 * App called destroy before/without calling accept after 		 * receiving connection request event notification or 		 * returned non zero from the event callback function. 		 * In either case, must tell the provider to reject. 		 */
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_DESTROYING
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|reject
argument_list|(
name|cm_id
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|IW_CM_STATE_CONN_SENT
case|:
case|case
name|IW_CM_STATE_DESTROYING
case|:
default|default:
name|BUG
argument_list|()
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cm_id_priv
operator|->
name|qp
condition|)
block|{
name|cm_id_priv
operator|->
name|id
operator|.
name|device
operator|->
name|iwcm
operator|->
name|rem_ref
argument_list|(
name|cm_id_priv
operator|->
name|qp
argument_list|)
expr_stmt|;
name|cm_id_priv
operator|->
name|qp
operator|=
name|NULL
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|iwcm_deref_id
argument_list|(
name|cm_id_priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function is only called by the application thread and cannot  * be called by the event thread. The function will wait for all  * references to be released on the cm_id and then kfree the cm_id  * object.  */
end_comment

begin_function
name|void
name|iw_destroy_cm_id
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|)
block|{
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|test_bit
argument_list|(
name|IWCM_F_CALLBACK_DESTROY
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|)
argument_list|)
expr_stmt|;
name|destroy_cm_id
argument_list|(
name|cm_id
argument_list|)
expr_stmt|;
name|wait_for_completion
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|destroy_comp
argument_list|)
expr_stmt|;
name|free_cm_id
argument_list|(
name|cm_id_priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|iw_destroy_cm_id
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * CM_ID<-- LISTEN  *  * Start listening for connect requests. Generates one CONNECT_REQUEST  * event for each inbound connect request.  */
end_comment

begin_function
name|int
name|iw_cm_listen
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
name|int
name|backlog
parameter_list|)
block|{
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|refcnt
decl_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|ret
operator|=
name|alloc_work_entries
argument_list|(
name|cm_id_priv
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cm_id_priv
operator|->
name|state
condition|)
block|{
case|case
name|IW_CM_STATE_IDLE
case|:
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_LISTEN
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdma_cma_any_addr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|cm_id
operator|->
name|local_addr
argument_list|)
condition|)
block|{
name|refcnt
operator|=
name|add_port_to_listenlist
argument_list|(
name|cm_id
operator|->
name|local_addr
operator|.
name|sin_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|refcnt
operator|==
literal|1
condition|)
block|{
name|ret
operator|=
name|iw_create_listen
argument_list|(
name|cm_id
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|refcnt
operator|<=
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
comment|/* if refcnt> 1, a socket listener created 				 * already. And we need not create socket 				 * listener on other rdma devices/listen cm_id's 				 * due to TOE. That is when a socket listener is 				 * created with INADDR_ANY all registered TOE 				 * devices will get a call to start 				 * hardware listeners. 				 */
block|}
block|}
else|else
block|{
name|ret
operator|=
name|iw_create_listen
argument_list|(
name|cm_id
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ret
condition|)
name|cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|create_listen_ep
argument_list|(
name|cm_id
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
else|else
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_IDLE
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|iw_cm_listen
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * CM_ID<-- IDLE  *  * Rejects an inbound connection request. No events are generated.  */
end_comment

begin_function
name|int
name|iw_cm_reject
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
specifier|const
name|void
modifier|*
name|private_data
parameter_list|,
name|u8
name|private_data_len
parameter_list|)
block|{
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|IWCM_F_CONNECT_WAIT
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm_id_priv
operator|->
name|state
operator|!=
name|IW_CM_STATE_CONN_RECV
condition|)
block|{
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|clear_bit
argument_list|(
name|IWCM_F_CONNECT_WAIT
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|)
expr_stmt|;
name|wake_up_all
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|connect_wait
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_IDLE
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|reject
argument_list|(
name|cm_id
argument_list|,
name|private_data
argument_list|,
name|private_data_len
argument_list|)
expr_stmt|;
name|clear_bit
argument_list|(
name|IWCM_F_CONNECT_WAIT
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|)
expr_stmt|;
name|wake_up_all
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|connect_wait
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|iw_cm_reject
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * CM_ID<-- ESTABLISHED  *  * Accepts an inbound connection request and generates an ESTABLISHED  * event. Callers of iw_cm_disconnect and iw_destroy_cm_id will block  * until the ESTABLISHED event is received from the provider.  */
end_comment

begin_function
name|int
name|iw_cm_accept
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
name|struct
name|iw_cm_conn_param
modifier|*
name|iw_param
parameter_list|)
block|{
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|struct
name|ib_qp
modifier|*
name|qp
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|IWCM_F_CONNECT_WAIT
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm_id_priv
operator|->
name|state
operator|!=
name|IW_CM_STATE_CONN_RECV
condition|)
block|{
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|clear_bit
argument_list|(
name|IWCM_F_CONNECT_WAIT
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|)
expr_stmt|;
name|wake_up_all
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|connect_wait
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Get the ib_qp given the QPN */
name|qp
operator|=
name|cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|get_qp
argument_list|(
name|cm_id
operator|->
name|device
argument_list|,
name|iw_param
operator|->
name|qpn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qp
condition|)
block|{
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|clear_bit
argument_list|(
name|IWCM_F_CONNECT_WAIT
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|)
expr_stmt|;
name|wake_up_all
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|connect_wait
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|add_ref
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|cm_id_priv
operator|->
name|qp
operator|=
name|qp
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|accept
argument_list|(
name|cm_id
argument_list|,
name|iw_param
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* An error on accept precludes provider events */
name|BUG_ON
argument_list|(
name|cm_id_priv
operator|->
name|state
operator|!=
name|IW_CM_STATE_CONN_RECV
argument_list|)
expr_stmt|;
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_IDLE
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm_id_priv
operator|->
name|qp
condition|)
block|{
name|cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|rem_ref
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|cm_id_priv
operator|->
name|qp
operator|=
name|NULL
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|clear_bit
argument_list|(
name|IWCM_F_CONNECT_WAIT
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|)
expr_stmt|;
name|wake_up_all
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|connect_wait
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|iw_cm_accept
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Active Side: CM_ID<-- CONN_SENT  *  * If successful, results in the generation of a CONNECT_REPLY  * event. iw_cm_disconnect and iw_cm_destroy will block until the  * CONNECT_REPLY event is received from the provider.  */
end_comment

begin_function
name|int
name|iw_cm_connect
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
name|struct
name|iw_cm_conn_param
modifier|*
name|iw_param
parameter_list|)
block|{
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|struct
name|ib_qp
modifier|*
name|qp
decl_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|ret
operator|=
name|alloc_work_entries
argument_list|(
name|cm_id_priv
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|set_bit
argument_list|(
name|IWCM_F_CONNECT_WAIT
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm_id_priv
operator|->
name|state
operator|!=
name|IW_CM_STATE_IDLE
condition|)
block|{
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|clear_bit
argument_list|(
name|IWCM_F_CONNECT_WAIT
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|)
expr_stmt|;
name|wake_up_all
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|connect_wait
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
comment|/* Get the ib_qp given the QPN */
name|qp
operator|=
name|cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|get_qp
argument_list|(
name|cm_id
operator|->
name|device
argument_list|,
name|iw_param
operator|->
name|qpn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qp
condition|)
block|{
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|clear_bit
argument_list|(
name|IWCM_F_CONNECT_WAIT
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|)
expr_stmt|;
name|wake_up_all
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|connect_wait
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|add_ref
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|cm_id_priv
operator|->
name|qp
operator|=
name|qp
expr_stmt|;
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_CONN_SENT
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|connect
argument_list|(
name|cm_id
argument_list|,
name|iw_param
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|spin_lock_irqsave
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm_id_priv
operator|->
name|qp
condition|)
block|{
name|cm_id
operator|->
name|device
operator|->
name|iwcm
operator|->
name|rem_ref
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|cm_id_priv
operator|->
name|qp
operator|=
name|NULL
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|cm_id_priv
operator|->
name|state
operator|!=
name|IW_CM_STATE_CONN_SENT
argument_list|)
expr_stmt|;
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_IDLE
expr_stmt|;
name|clear_bit
argument_list|(
name|IWCM_F_CONNECT_WAIT
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|)
expr_stmt|;
name|wake_up_all
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|connect_wait
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|iw_cm_connect
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Passive Side: new CM_ID<-- CONN_RECV  *  * Handles an inbound connect request. The function creates a new  * iw_cm_id to represent the new connection and inherits the client  * callback function and other attributes from the listening parent.  *  * The work item contains a pointer to the listen_cm_id and the event. The  * listen_cm_id contains the client cm_handler, context and  * device. These are copied when the device is cloned. The event  * contains the new four tuple.  *  * An error on the child should not affect the parent, so this  * function does not return a value.  */
end_comment

begin_function
specifier|static
name|void
name|cm_conn_req_handler
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|listen_id_priv
parameter_list|,
name|struct
name|iw_cm_event
modifier|*
name|iw_event
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|struct
name|iw_cm_id
modifier|*
name|cm_id
decl_stmt|;
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* 	 * The provider should never generate a connection request 	 * event with a bad status. 	 */
name|BUG_ON
argument_list|(
name|iw_event
operator|->
name|status
argument_list|)
expr_stmt|;
name|cm_id
operator|=
name|iw_create_cm_id
argument_list|(
name|listen_id_priv
operator|->
name|id
operator|.
name|device
argument_list|,
name|iw_event
operator|->
name|so
argument_list|,
name|listen_id_priv
operator|->
name|id
operator|.
name|cm_handler
argument_list|,
name|listen_id_priv
operator|->
name|id
operator|.
name|context
argument_list|)
expr_stmt|;
comment|/* If the cm_id could not be created, ignore the request */
if|if
condition|(
name|IS_ERR
argument_list|(
name|cm_id
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|cm_id
operator|->
name|provider_data
operator|=
name|iw_event
operator|->
name|provider_data
expr_stmt|;
name|cm_id
operator|->
name|local_addr
operator|=
name|iw_event
operator|->
name|local_addr
expr_stmt|;
name|cm_id
operator|->
name|remote_addr
operator|=
name|iw_event
operator|->
name|remote_addr
expr_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_CONN_RECV
expr_stmt|;
comment|/* 	 * We could be destroying the listening id. If so, ignore this 	 * upcall. 	 */
name|spin_lock_irqsave
argument_list|(
operator|&
name|listen_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|listen_id_priv
operator|->
name|state
operator|!=
name|IW_CM_STATE_LISTEN
condition|)
block|{
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|listen_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|iw_cm_reject
argument_list|(
name|cm_id
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iw_destroy_cm_id
argument_list|(
name|cm_id
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|listen_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ret
operator|=
name|alloc_work_entries
argument_list|(
name|cm_id_priv
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|iw_cm_reject
argument_list|(
name|cm_id
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|iw_destroy_cm_id
argument_list|(
name|cm_id
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Call the client CM handler */
name|ret
operator|=
name|cm_id
operator|->
name|cm_handler
argument_list|(
name|cm_id
argument_list|,
name|iw_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|iw_cm_reject
argument_list|(
name|cm_id
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|IWCM_F_CALLBACK_DESTROY
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|)
expr_stmt|;
name|destroy_cm_id
argument_list|(
name|cm_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|atomic_read
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|refcount
argument_list|)
operator|==
literal|0
condition|)
name|free_cm_id
argument_list|(
name|cm_id_priv
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|iw_event
operator|->
name|private_data_len
condition|)
name|kfree
argument_list|(
name|iw_event
operator|->
name|private_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Passive Side: CM_ID<-- ESTABLISHED  *  * The provider generated an ESTABLISHED event which means that  * the MPA negotion has completed successfully and we are now in MPA  * FPDU mode.  *  * This event can only be received in the CONN_RECV state. If the  * remote peer closed, the ESTABLISHED event would be received followed  * by the CLOSE event. If the app closes, it will block until we wake  * it up after processing this event.  */
end_comment

begin_function
specifier|static
name|int
name|cm_conn_est_handler
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
parameter_list|,
name|struct
name|iw_cm_event
modifier|*
name|iw_event
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 * We clear the CONNECT_WAIT bit here to allow the callback 	 * function to call iw_cm_disconnect. Calling iw_destroy_cm_id 	 * from a callback handler is not allowed. 	 */
name|clear_bit
argument_list|(
name|IWCM_F_CONNECT_WAIT
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|cm_id_priv
operator|->
name|state
operator|!=
name|IW_CM_STATE_CONN_RECV
argument_list|)
expr_stmt|;
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_ESTABLISHED
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cm_id_priv
operator|->
name|id
operator|.
name|cm_handler
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|id
argument_list|,
name|iw_event
argument_list|)
expr_stmt|;
name|wake_up_all
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|connect_wait
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Active Side: CM_ID<-- ESTABLISHED  *  * The app has called connect and is waiting for the established event to  * post it's requests to the server. This event will wake up anyone  * blocked in iw_cm_disconnect or iw_destroy_id.  */
end_comment

begin_function
specifier|static
name|int
name|cm_conn_rep_handler
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
parameter_list|,
name|struct
name|iw_cm_event
modifier|*
name|iw_event
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the connect wait bit so a callback function calling 	 * iw_cm_disconnect will not wait and deadlock this thread 	 */
name|clear_bit
argument_list|(
name|IWCM_F_CONNECT_WAIT
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|cm_id_priv
operator|->
name|state
operator|!=
name|IW_CM_STATE_CONN_SENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|iw_event
operator|->
name|status
operator|==
literal|0
condition|)
block|{
name|cm_id_priv
operator|->
name|id
operator|.
name|local_addr
operator|=
name|iw_event
operator|->
name|local_addr
expr_stmt|;
name|cm_id_priv
operator|->
name|id
operator|.
name|remote_addr
operator|=
name|iw_event
operator|->
name|remote_addr
expr_stmt|;
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_ESTABLISHED
expr_stmt|;
block|}
else|else
block|{
comment|/* REJECTED or RESET */
name|cm_id_priv
operator|->
name|id
operator|.
name|device
operator|->
name|iwcm
operator|->
name|rem_ref
argument_list|(
name|cm_id_priv
operator|->
name|qp
argument_list|)
expr_stmt|;
name|cm_id_priv
operator|->
name|qp
operator|=
name|NULL
expr_stmt|;
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_IDLE
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cm_id_priv
operator|->
name|id
operator|.
name|cm_handler
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|id
argument_list|,
name|iw_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|iw_event
operator|->
name|private_data_len
condition|)
name|kfree
argument_list|(
name|iw_event
operator|->
name|private_data
argument_list|)
expr_stmt|;
comment|/* Wake up waiters on connect complete */
name|wake_up_all
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|connect_wait
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * CM_ID<-- CLOSING  *  * If in the ESTABLISHED state, move to CLOSING.  */
end_comment

begin_function
specifier|static
name|void
name|cm_disconnect_handler
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
parameter_list|,
name|struct
name|iw_cm_event
modifier|*
name|iw_event
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm_id_priv
operator|->
name|state
operator|==
name|IW_CM_STATE_ESTABLISHED
condition|)
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_CLOSING
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * CM_ID<-- IDLE  *  * If in the ESTBLISHED or CLOSING states, the QP will have have been  * moved by the provider to the ERR state. Disassociate the CM_ID from  * the QP,  move to IDLE, and remove the 'connected' reference.  *  * If in some other state, the cm_id was destroyed asynchronously.  * This is the last reference that will result in waking up  * the app thread blocked in iw_destroy_cm_id.  */
end_comment

begin_function
specifier|static
name|int
name|cm_close_handler
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
parameter_list|,
name|struct
name|iw_cm_event
modifier|*
name|iw_event
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cm_id_priv
operator|->
name|qp
condition|)
block|{
name|cm_id_priv
operator|->
name|id
operator|.
name|device
operator|->
name|iwcm
operator|->
name|rem_ref
argument_list|(
name|cm_id_priv
operator|->
name|qp
argument_list|)
expr_stmt|;
name|cm_id_priv
operator|->
name|qp
operator|=
name|NULL
expr_stmt|;
block|}
switch|switch
condition|(
name|cm_id_priv
operator|->
name|state
condition|)
block|{
case|case
name|IW_CM_STATE_ESTABLISHED
case|:
case|case
name|IW_CM_STATE_CLOSING
case|:
name|cm_id_priv
operator|->
name|state
operator|=
name|IW_CM_STATE_IDLE
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ret
operator|=
name|cm_id_priv
operator|->
name|id
operator|.
name|cm_handler
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|id
argument_list|,
name|iw_event
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|IW_CM_STATE_DESTROYING
case|:
break|break;
default|default:
name|BUG
argument_list|()
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|process_event
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
parameter_list|,
name|struct
name|iw_cm_event
modifier|*
name|iw_event
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|iw_event
operator|->
name|event
condition|)
block|{
case|case
name|IW_CM_EVENT_CONNECT_REQUEST
case|:
name|cm_conn_req_handler
argument_list|(
name|cm_id_priv
argument_list|,
name|iw_event
argument_list|)
expr_stmt|;
break|break;
case|case
name|IW_CM_EVENT_CONNECT_REPLY
case|:
name|ret
operator|=
name|cm_conn_rep_handler
argument_list|(
name|cm_id_priv
argument_list|,
name|iw_event
argument_list|)
expr_stmt|;
break|break;
case|case
name|IW_CM_EVENT_ESTABLISHED
case|:
name|ret
operator|=
name|cm_conn_est_handler
argument_list|(
name|cm_id_priv
argument_list|,
name|iw_event
argument_list|)
expr_stmt|;
break|break;
case|case
name|IW_CM_EVENT_DISCONNECT
case|:
name|cm_disconnect_handler
argument_list|(
name|cm_id_priv
argument_list|,
name|iw_event
argument_list|)
expr_stmt|;
break|break;
case|case
name|IW_CM_EVENT_CLOSE
case|:
name|ret
operator|=
name|cm_close_handler
argument_list|(
name|cm_id_priv
argument_list|,
name|iw_event
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BUG
argument_list|()
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Process events on the work_list for the cm_id. If the callback  * function requests that the cm_id be deleted, a flag is set in the  * cm_id flags to indicate that when the last reference is  * removed, the cm_id is to be destroyed. This is necessary to  * distinguish between an object that will be destroyed by the app  * thread asleep on the destroy_comp list vs. an object destroyed  * here synchronously when the last reference is removed.  */
end_comment

begin_function
specifier|static
name|void
name|cm_work_handler
parameter_list|(
name|struct
name|work_struct
modifier|*
name|_work
parameter_list|)
block|{
name|struct
name|iwcm_work
modifier|*
name|work
init|=
name|container_of
argument_list|(
name|_work
argument_list|,
expr|struct
name|iwcm_work
argument_list|,
name|work
argument_list|)
decl_stmt|;
name|struct
name|iw_cm_event
name|levent
decl_stmt|;
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
init|=
name|work
operator|->
name|cm_id
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|empty
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|destroy_id
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|empty
operator|=
name|list_empty
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_list
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|empty
condition|)
block|{
name|work
operator|=
name|list_entry
argument_list|(
name|cm_id_priv
operator|->
name|work_list
operator|.
name|next
argument_list|,
expr|struct
name|iwcm_work
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|list_del_init
argument_list|(
operator|&
name|work
operator|->
name|list
argument_list|)
expr_stmt|;
name|empty
operator|=
name|list_empty
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_list
argument_list|)
expr_stmt|;
name|levent
operator|=
name|work
operator|->
name|event
expr_stmt|;
name|put_work
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ret
operator|=
name|process_event
argument_list|(
name|cm_id_priv
argument_list|,
operator|&
name|levent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|set_bit
argument_list|(
name|IWCM_F_CALLBACK_DESTROY
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|)
expr_stmt|;
name|destroy_cm_id
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
name|BUG_ON
argument_list|(
name|atomic_read
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|refcount
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|destroy_id
operator|=
name|test_bit
argument_list|(
name|IWCM_F_CALLBACK_DESTROY
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|iwcm_deref_id
argument_list|(
name|cm_id_priv
argument_list|)
condition|)
block|{
if|if
condition|(
name|destroy_id
condition|)
block|{
name|BUG_ON
argument_list|(
operator|!
name|list_empty
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_list
argument_list|)
argument_list|)
expr_stmt|;
name|free_cm_id
argument_list|(
name|cm_id_priv
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|empty
condition|)
return|return;
name|spin_lock_irqsave
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function is called on interrupt context. Schedule events on  * the iwcm_wq thread to allow callback functions to downcall into  * the CM and/or block.  Events are queued to a per-CM_ID  * work_list. If this is the first event on the work_list, the work  * element is also queued on the iwcm_wq thread.  *  * Each event holds a reference on the cm_id. Until the last posted  * event has been delivered and processed, the cm_id cannot be  * deleted.  *  * Returns:  * 	      0	- the event was handled.  *	-ENOMEM	- the event was not handled due to lack of resources.  */
end_comment

begin_function
specifier|static
name|int
name|cm_event_handler
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
name|struct
name|iw_cm_event
modifier|*
name|iw_event
parameter_list|)
block|{
name|struct
name|iwcm_work
modifier|*
name|work
decl_stmt|;
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|work
operator|=
name|get_work
argument_list|(
name|cm_id_priv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|work
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|INIT_WORK
argument_list|(
operator|&
name|work
operator|->
name|work
argument_list|,
name|cm_work_handler
argument_list|)
expr_stmt|;
name|work
operator|->
name|cm_id
operator|=
name|cm_id_priv
expr_stmt|;
name|work
operator|->
name|event
operator|=
operator|*
name|iw_event
expr_stmt|;
if|if
condition|(
operator|(
name|work
operator|->
name|event
operator|.
name|event
operator|==
name|IW_CM_EVENT_CONNECT_REQUEST
operator|||
name|work
operator|->
name|event
operator|.
name|event
operator|==
name|IW_CM_EVENT_CONNECT_REPLY
operator|)
operator|&&
name|work
operator|->
name|event
operator|.
name|private_data_len
condition|)
block|{
name|ret
operator|=
name|copy_private_data
argument_list|(
operator|&
name|work
operator|->
name|event
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|put_work
argument_list|(
name|work
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|atomic_inc
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|refcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|work_list
argument_list|)
condition|)
block|{
name|list_add_tail
argument_list|(
operator|&
name|work
operator|->
name|list
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|work_list
argument_list|)
expr_stmt|;
name|queue_work
argument_list|(
name|iwcm_wq
argument_list|,
operator|&
name|work
operator|->
name|work
argument_list|)
expr_stmt|;
block|}
else|else
name|list_add_tail
argument_list|(
operator|&
name|work
operator|->
name|list
argument_list|,
operator|&
name|cm_id_priv
operator|->
name|work_list
argument_list|)
expr_stmt|;
name|out
label|:
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwcm_init_qp_init_attr
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
parameter_list|,
name|struct
name|ib_qp_attr
modifier|*
name|qp_attr
parameter_list|,
name|int
modifier|*
name|qp_attr_mask
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cm_id_priv
operator|->
name|state
condition|)
block|{
case|case
name|IW_CM_STATE_IDLE
case|:
case|case
name|IW_CM_STATE_CONN_SENT
case|:
case|case
name|IW_CM_STATE_CONN_RECV
case|:
case|case
name|IW_CM_STATE_ESTABLISHED
case|:
operator|*
name|qp_attr_mask
operator|=
name|IB_QP_STATE
operator||
name|IB_QP_ACCESS_FLAGS
expr_stmt|;
name|qp_attr
operator|->
name|qp_access_flags
operator|=
name|IB_ACCESS_REMOTE_WRITE
operator||
name|IB_ACCESS_REMOTE_READ
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iwcm_init_qp_rts_attr
parameter_list|(
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
parameter_list|,
name|struct
name|ib_qp_attr
modifier|*
name|qp_attr
parameter_list|,
name|int
modifier|*
name|qp_attr_mask
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cm_id_priv
operator|->
name|state
condition|)
block|{
case|case
name|IW_CM_STATE_IDLE
case|:
case|case
name|IW_CM_STATE_CONN_SENT
case|:
case|case
name|IW_CM_STATE_CONN_RECV
case|:
case|case
name|IW_CM_STATE_ESTABLISHED
case|:
operator|*
name|qp_attr_mask
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cm_id_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|iw_cm_init_qp_attr
parameter_list|(
name|struct
name|iw_cm_id
modifier|*
name|cm_id
parameter_list|,
name|struct
name|ib_qp_attr
modifier|*
name|qp_attr
parameter_list|,
name|int
modifier|*
name|qp_attr_mask
parameter_list|)
block|{
name|struct
name|iwcm_id_private
modifier|*
name|cm_id_priv
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|cm_id_priv
operator|=
name|container_of
argument_list|(
name|cm_id
argument_list|,
expr|struct
name|iwcm_id_private
argument_list|,
name|id
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|qp_attr
operator|->
name|qp_state
condition|)
block|{
case|case
name|IB_QPS_INIT
case|:
case|case
name|IB_QPS_RTR
case|:
name|ret
operator|=
name|iwcm_init_qp_init_attr
argument_list|(
name|cm_id_priv
argument_list|,
name|qp_attr
argument_list|,
name|qp_attr_mask
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_QPS_RTS
case|:
name|ret
operator|=
name|iwcm_init_qp_rts_attr
argument_list|(
name|cm_id_priv
argument_list|,
name|qp_attr
argument_list|,
name|qp_attr_mask
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|iw_cm_init_qp_attr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|__init
name|iw_cm_init
parameter_list|(
name|void
parameter_list|)
block|{
name|iwcm_wq
operator|=
name|create_singlethread_workqueue
argument_list|(
literal|"iw_cm_wq"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|iwcm_wq
condition|)
return|return
operator|-
name|ENOMEM
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__exit
name|iw_cm_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|destroy_workqueue
argument_list|(
name|iwcm_wq
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|module_init
argument_list|(
name|iw_cm_init
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_exit
argument_list|(
name|iw_cm_cleanup
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

