begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004-2007 Voltaire, Inc. All rights reserved.  * Copyright (c) 2005 Intel Corporation.  All rights reserved.  * Copyright (c) 2005 Mellanox Technologies Ltd.  All rights reserved.  * Copyright (c) 2009 HNR Consulting. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  *  */
end_comment

begin_define
define|#
directive|define
name|LINUXKPI_PARAM_PREFIX
value|ibcore_
end_define

begin_include
include|#
directive|include
file|<linux/dma-mapping.h>
end_include

begin_include
include|#
directive|include
file|<linux/slab.h>
end_include

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/string.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_cache.h>
end_include

begin_include
include|#
directive|include
file|"mad_priv.h"
end_include

begin_include
include|#
directive|include
file|"mad_rmpp.h"
end_include

begin_include
include|#
directive|include
file|"smi.h"
end_include

begin_include
include|#
directive|include
file|"agent.h"
end_include

begin_expr_stmt
name|MODULE_LICENSE
argument_list|(
literal|"Dual BSD/GPL"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DESCRIPTION
argument_list|(
literal|"kernel IB MAD API"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_AUTHOR
argument_list|(
literal|"Hal Rosenstock"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_AUTHOR
argument_list|(
literal|"Sean Hefty"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|mad_sendq_size
init|=
name|IB_MAD_QP_SEND_SIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mad_recvq_size
init|=
name|IB_MAD_QP_RECV_SIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|send_queue_size
argument_list|,
name|mad_sendq_size
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|send_queue_size
argument_list|,
literal|"Size of send queue in number of work requests"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|recv_queue_size
argument_list|,
name|mad_recvq_size
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|recv_queue_size
argument_list|,
literal|"Size of receive queue in number of work requests"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|kmem_cache
modifier|*
name|ib_mad_cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|list_head
name|ib_mad_port_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u32
name|ib_mad_client_id
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Timeout FIFO (tf) param  */
end_comment

begin_enum
enum|enum
block|{
comment|/* min time between 2 consecutive activations of tf workqueue */
name|MIN_BETWEEN_ACTIVATIONS_MS
init|=
literal|5
block|}
enum|;
end_enum

begin_comment
comment|/*  * SA congestion control params  */
end_comment

begin_enum
enum|enum
block|{
name|MAX_OUTSTANDING_SA_MADS
init|=
literal|10
block|,
name|MIN_TIME_FOR_SA_MAD_SEND_MS
init|=
literal|20
block|,
name|MAX_SA_MADS
init|=
literal|10000
block|}
enum|;
end_enum

begin_comment
comment|/* Port list lock */
end_comment

begin_expr_stmt
specifier|static
name|DEFINE_SPINLOCK
argument_list|(
name|ib_mad_port_list_lock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Forward declarations */
end_comment

begin_function_decl
specifier|static
name|int
name|method_in_use
parameter_list|(
name|struct
name|ib_mad_mgmt_method_table
modifier|*
modifier|*
name|method
parameter_list|,
name|struct
name|ib_mad_reg_req
modifier|*
name|mad_reg_req
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|remove_mad_reg_req
parameter_list|(
name|struct
name|ib_mad_agent_private
modifier|*
name|priv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ib_mad_agent_private
modifier|*
name|find_mad_agent
parameter_list|(
name|struct
name|ib_mad_port_private
modifier|*
name|port_priv
parameter_list|,
name|struct
name|ib_mad
modifier|*
name|mad
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ib_mad_post_receive_mads
parameter_list|(
name|struct
name|ib_mad_qp_info
modifier|*
name|qp_info
parameter_list|,
name|struct
name|ib_mad_private
modifier|*
name|mad
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cancel_mads
parameter_list|(
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|timeout_sends
parameter_list|(
name|struct
name|work_struct
modifier|*
name|work
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|local_completions
parameter_list|(
name|struct
name|work_struct
modifier|*
name|work
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_nonoui_reg_req
parameter_list|(
name|struct
name|ib_mad_reg_req
modifier|*
name|mad_reg_req
parameter_list|,
name|struct
name|ib_mad_agent_private
modifier|*
name|agent_priv
parameter_list|,
name|u8
name|mgmt_class
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_oui_reg_req
parameter_list|(
name|struct
name|ib_mad_reg_req
modifier|*
name|mad_reg_req
parameter_list|,
name|struct
name|ib_mad_agent_private
modifier|*
name|agent_priv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|send_sa_cc_mad
parameter_list|(
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
parameter_list|,
name|u32
name|timeout_ms
parameter_list|,
name|u32
name|retries_left
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Timeout FIFO functions - implements FIFO with timeout mechanism  */
end_comment

begin_function
specifier|static
name|void
name|activate_timeout_handler_task
parameter_list|(
name|unsigned
name|long
name|data
parameter_list|)
block|{
name|struct
name|to_fifo
modifier|*
name|tf
decl_stmt|;
name|tf
operator|=
operator|(
expr|struct
name|to_fifo
operator|*
operator|)
name|data
expr_stmt|;
name|del_timer
argument_list|(
operator|&
name|tf
operator|->
name|timer
argument_list|)
expr_stmt|;
name|queue_work
argument_list|(
name|tf
operator|->
name|workq
argument_list|,
operator|&
name|tf
operator|->
name|work
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|long
name|adjusted_time
parameter_list|(
name|unsigned
name|long
name|last
parameter_list|,
name|unsigned
name|long
name|next
parameter_list|)
block|{
name|unsigned
name|long
name|min_next
decl_stmt|;
name|min_next
operator|=
name|last
operator|+
name|msecs_to_jiffies
argument_list|(
name|MIN_BETWEEN_ACTIVATIONS_MS
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_after
argument_list|(
name|min_next
argument_list|,
name|next
argument_list|)
condition|)
return|return
name|min_next
return|;
return|return
name|next
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|notify_failure
parameter_list|(
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
parameter_list|,
name|enum
name|ib_wc_status
name|status
parameter_list|)
block|{
name|struct
name|ib_mad_send_wc
name|mad_send_wc
decl_stmt|;
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
decl_stmt|;
name|mad_send_wc
operator|.
name|status
operator|=
name|status
expr_stmt|;
name|mad_send_wc
operator|.
name|vendor_err
operator|=
literal|0
expr_stmt|;
name|mad_send_wc
operator|.
name|send_buf
operator|=
operator|&
name|mad_send_wr
operator|->
name|send_buf
expr_stmt|;
name|mad_agent_priv
operator|=
name|mad_send_wr
operator|->
name|mad_agent_priv
expr_stmt|;
name|mad_agent_priv
operator|->
name|agent
operator|.
name|send_handler
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|agent
argument_list|,
operator|&
name|mad_send_wc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|sa_cc_data
modifier|*
name|get_cc_obj
parameter_list|(
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
parameter_list|)
block|{
return|return
operator|&
name|mad_send_wr
operator|->
name|mad_agent_priv
operator|->
name|qp_info
operator|->
name|port_priv
operator|->
name|sa_cc
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|ib_mad_send_wr_private
modifier|*
name|tfe_to_mad
parameter_list|(
name|struct
name|tf_entry
modifier|*
name|tfe
parameter_list|)
block|{
return|return
name|container_of
argument_list|(
name|tfe
argument_list|,
expr|struct
name|ib_mad_send_wr_private
argument_list|,
name|tf_list
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|timeout_handler_task
parameter_list|(
name|struct
name|work_struct
modifier|*
name|work
parameter_list|)
block|{
name|struct
name|tf_entry
modifier|*
name|tmp1
decl_stmt|,
modifier|*
name|tmp2
decl_stmt|;
name|struct
name|list_head
modifier|*
name|list_item
decl_stmt|,
name|exp_lst
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|,
name|curr_time
decl_stmt|;
name|int
name|lst_empty
decl_stmt|;
name|struct
name|to_fifo
modifier|*
name|tf
decl_stmt|;
name|tf
operator|=
name|container_of
argument_list|(
name|work
argument_list|,
expr|struct
name|to_fifo
argument_list|,
name|work
argument_list|)
expr_stmt|;
do|do
block|{
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|exp_lst
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|tf
operator|->
name|lists_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|curr_time
operator|=
name|jiffies
expr_stmt|;
name|list_for_each
argument_list|(
argument|list_item
argument_list|,
argument|&tf->to_head
argument_list|)
block|{
name|tmp1
operator|=
name|list_entry
argument_list|(
name|list_item
argument_list|,
expr|struct
name|tf_entry
argument_list|,
name|to_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_before
argument_list|(
name|curr_time
argument_list|,
name|tmp1
operator|->
name|exp_time
argument_list|)
condition|)
break|break;
name|list_del
argument_list|(
operator|&
name|tmp1
operator|->
name|fifo_list
argument_list|)
expr_stmt|;
name|tf
operator|->
name|num_items
operator|--
expr_stmt|;
block|}
comment|/* cut list up to and including list_item->prev */
name|list_cut_position
argument_list|(
operator|&
name|exp_lst
argument_list|,
operator|&
name|tf
operator|->
name|to_head
argument_list|,
name|list_item
operator|->
name|prev
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|tf
operator|->
name|lists_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|lst_empty
operator|=
name|list_empty
argument_list|(
operator|&
name|exp_lst
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|tmp1
argument_list|,
argument|tmp2
argument_list|,
argument|&exp_lst
argument_list|,
argument|to_list
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|tmp1
operator|->
name|to_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp1
operator|->
name|canceled
condition|)
block|{
name|tmp1
operator|->
name|canceled
operator|=
literal|0
expr_stmt|;
name|notify_failure
argument_list|(
name|tfe_to_mad
argument_list|(
name|tmp1
argument_list|)
argument_list|,
name|IB_WC_WR_FLUSH_ERR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|notify_failure
argument_list|(
name|tfe_to_mad
argument_list|(
name|tmp1
argument_list|)
argument_list|,
name|IB_WC_RESP_TIMEOUT_ERR
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|!
name|lst_empty
condition|)
do|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|tf
operator|->
name|lists_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|tf
operator|->
name|to_head
argument_list|)
condition|)
block|{
name|tmp1
operator|=
name|list_entry
argument_list|(
name|tf
operator|->
name|to_head
operator|.
name|next
argument_list|,
expr|struct
name|tf_entry
argument_list|,
name|to_list
argument_list|)
expr_stmt|;
name|mod_timer
argument_list|(
operator|&
name|tf
operator|->
name|timer
argument_list|,
name|adjusted_time
argument_list|(
name|curr_time
argument_list|,
name|tmp1
operator|->
name|exp_time
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|tf
operator|->
name|lists_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * tf_create - creates new timeout-fifo object  * @fifo_size: Maximum fifo size  *  * Allocate and initialize new timeout-fifo object  */
end_comment

begin_function
specifier|static
name|struct
name|to_fifo
modifier|*
name|tf_create
parameter_list|(
name|u32
name|fifo_size
parameter_list|)
block|{
name|struct
name|to_fifo
modifier|*
name|tf
decl_stmt|;
name|tf
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tf
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tf
condition|)
block|{
name|tf
operator|->
name|workq
operator|=
name|create_singlethread_workqueue
argument_list|(
literal|"to_fifo"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tf
operator|->
name|workq
condition|)
block|{
name|kfree
argument_list|(
name|tf
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|spin_lock_init
argument_list|(
operator|&
name|tf
operator|->
name|lists_lock
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|tf
operator|->
name|to_head
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|tf
operator|->
name|fifo_head
argument_list|)
expr_stmt|;
name|init_timer
argument_list|(
operator|&
name|tf
operator|->
name|timer
argument_list|)
expr_stmt|;
name|INIT_WORK
argument_list|(
operator|&
name|tf
operator|->
name|work
argument_list|,
name|timeout_handler_task
argument_list|)
expr_stmt|;
name|tf
operator|->
name|timer
operator|.
name|data
operator|=
operator|(
name|unsigned
name|long
operator|)
name|tf
expr_stmt|;
name|tf
operator|->
name|timer
operator|.
name|function
operator|=
name|activate_timeout_handler_task
expr_stmt|;
name|tf
operator|->
name|timer
operator|.
name|expires
operator|=
name|jiffies
expr_stmt|;
name|tf
operator|->
name|fifo_size
operator|=
name|fifo_size
expr_stmt|;
name|tf
operator|->
name|stop_enqueue
operator|=
literal|0
expr_stmt|;
name|tf
operator|->
name|num_items
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|tf
return|;
block|}
end_function

begin_comment
comment|/**  * tf_enqueue - enqueue item to timeout-fifo object  * @tf:timeout-fifo object  * @item: item to enqueue.  * @timeout_ms: item expiration time in ms.  *  * Enqueue item to fifo and modify expiration timer when required.  *  * Returns 0 on success and negative on failure.  */
end_comment

begin_function
specifier|static
name|int
name|tf_enqueue
parameter_list|(
name|struct
name|to_fifo
modifier|*
name|tf
parameter_list|,
name|struct
name|tf_entry
modifier|*
name|item
parameter_list|,
name|u32
name|timeout_ms
parameter_list|)
block|{
name|struct
name|tf_entry
modifier|*
name|tmp
decl_stmt|;
name|struct
name|list_head
modifier|*
name|list_item
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|item
operator|->
name|exp_time
operator|=
name|jiffies
operator|+
name|msecs_to_jiffies
argument_list|(
name|timeout_ms
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|tf
operator|->
name|lists_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|tf
operator|->
name|num_items
operator|>=
name|tf
operator|->
name|fifo_size
operator|||
name|tf
operator|->
name|stop_enqueue
condition|)
block|{
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|tf
operator|->
name|lists_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|-
name|EBUSY
return|;
block|}
comment|/* Insert item to timeout list */
name|list_for_each_prev
argument_list|(
argument|list_item
argument_list|,
argument|&tf->to_head
argument_list|)
block|{
name|tmp
operator|=
name|list_entry
argument_list|(
name|list_item
argument_list|,
expr|struct
name|tf_entry
argument_list|,
name|to_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_after
argument_list|(
name|item
operator|->
name|exp_time
argument_list|,
name|tmp
operator|->
name|exp_time
argument_list|)
condition|)
break|break;
block|}
name|list_add
argument_list|(
operator|&
name|item
operator|->
name|to_list
argument_list|,
name|list_item
argument_list|)
expr_stmt|;
comment|/* Insert item to fifo list */
name|list_add_tail
argument_list|(
operator|&
name|item
operator|->
name|fifo_list
argument_list|,
operator|&
name|tf
operator|->
name|fifo_head
argument_list|)
expr_stmt|;
name|tf
operator|->
name|num_items
operator|++
expr_stmt|;
comment|/* modify expiration timer if required */
if|if
condition|(
name|list_item
operator|==
operator|&
name|tf
operator|->
name|to_head
condition|)
name|mod_timer
argument_list|(
operator|&
name|tf
operator|->
name|timer
argument_list|,
name|item
operator|->
name|exp_time
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|tf
operator|->
name|lists_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * tf_dequeue - dequeue item from timeout-fifo object  * @tf:timeout-fifo object  * @time_left_ms: returns the time left for expiration in ms.  *  * Dequeue item from fifo and modify expiration timer when required.  *  * Returns pointer to tf_entry on success and NULL on failure.  */
end_comment

begin_function
specifier|static
name|struct
name|tf_entry
modifier|*
name|tf_dequeue
parameter_list|(
name|struct
name|to_fifo
modifier|*
name|tf
parameter_list|,
name|u32
modifier|*
name|time_left_ms
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|unsigned
name|long
name|time_left
decl_stmt|;
name|struct
name|tf_entry
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|tmp1
decl_stmt|;
name|bool
name|found
init|=
name|false
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|tf
operator|->
name|lists_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|tf
operator|->
name|fifo_head
argument_list|)
condition|)
block|{
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|tf
operator|->
name|lists_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|list_for_each_entry
argument_list|(
argument|tmp
argument_list|,
argument|&tf->fifo_head
argument_list|,
argument|fifo_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|tmp
operator|->
name|canceled
condition|)
block|{
name|found
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|tf
operator|->
name|lists_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* modify timer in case enqueued item is the next to expire */
if|if
condition|(
name|tf
operator|->
name|to_head
operator|.
name|next
operator|==
operator|&
name|tmp
operator|->
name|to_list
condition|)
block|{
if|if
condition|(
name|list_is_last
argument_list|(
operator|&
name|tmp
operator|->
name|to_list
argument_list|,
operator|&
name|tf
operator|->
name|to_head
argument_list|)
condition|)
block|{
name|del_timer
argument_list|(
operator|&
name|tf
operator|->
name|timer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmp1
operator|=
name|list_entry
argument_list|(
name|tmp
operator|->
name|to_list
operator|.
name|next
argument_list|,
expr|struct
name|tf_entry
argument_list|,
name|to_list
argument_list|)
expr_stmt|;
name|mod_timer
argument_list|(
operator|&
name|tf
operator|->
name|timer
argument_list|,
name|tmp1
operator|->
name|exp_time
argument_list|)
expr_stmt|;
block|}
block|}
name|list_del
argument_list|(
operator|&
name|tmp
operator|->
name|fifo_list
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|tmp
operator|->
name|to_list
argument_list|)
expr_stmt|;
name|tf
operator|->
name|num_items
operator|--
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|tf
operator|->
name|lists_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|time_left
operator|=
name|tmp
operator|->
name|exp_time
operator|-
name|jiffies
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|time_left
operator|<=
literal|0
condition|)
name|time_left
operator|=
literal|0
expr_stmt|;
operator|*
name|time_left_ms
operator|=
name|jiffies_to_msecs
argument_list|(
name|time_left
argument_list|)
expr_stmt|;
return|return
name|tmp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tf_stop_enqueue
parameter_list|(
name|struct
name|to_fifo
modifier|*
name|tf
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|tf
operator|->
name|lists_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|tf
operator|->
name|stop_enqueue
operator|=
literal|1
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|tf
operator|->
name|lists_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * tf_free - free empty timeout-fifo object  * @tf:timeout-fifo object  *  */
end_comment

begin_function
specifier|static
name|void
name|tf_free
parameter_list|(
name|struct
name|to_fifo
modifier|*
name|tf
parameter_list|)
block|{
name|del_timer_sync
argument_list|(
operator|&
name|tf
operator|->
name|timer
argument_list|)
expr_stmt|;
name|flush_workqueue
argument_list|(
name|tf
operator|->
name|workq
argument_list|)
expr_stmt|;
name|destroy_workqueue
argument_list|(
name|tf
operator|->
name|workq
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|tf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * tf_free_agent - free MADs related to specific MAD agent from timeout-fifo  * @tf:timeout-fifo object  * @mad_agent_priv: MAD agent.  *  */
end_comment

begin_function
specifier|static
name|void
name|tf_free_agent
parameter_list|(
name|struct
name|to_fifo
modifier|*
name|tf
parameter_list|,
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|struct
name|tf_entry
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|tmp1
decl_stmt|;
name|struct
name|list_head
name|tmp_head
decl_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|tmp_head
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|tf
operator|->
name|lists_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|tmp
argument_list|,
argument|tmp1
argument_list|,
argument|&tf->fifo_head
argument_list|,
argument|fifo_list
argument_list|)
block|{
if|if
condition|(
name|tfe_to_mad
argument_list|(
name|tmp
argument_list|)
operator|->
name|mad_agent_priv
operator|==
name|mad_agent_priv
condition|)
block|{
name|list_del
argument_list|(
operator|&
name|tmp
operator|->
name|to_list
argument_list|)
expr_stmt|;
name|list_move
argument_list|(
operator|&
name|tmp
operator|->
name|fifo_list
argument_list|,
operator|&
name|tmp_head
argument_list|)
expr_stmt|;
name|tf
operator|->
name|num_items
operator|--
expr_stmt|;
block|}
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|tf
operator|->
name|lists_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|tmp
argument_list|,
argument|tmp1
argument_list|,
argument|&tmp_head
argument_list|,
argument|fifo_list
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|tmp
operator|->
name|fifo_list
argument_list|)
expr_stmt|;
name|notify_failure
argument_list|(
name|tfe_to_mad
argument_list|(
name|tmp
argument_list|)
argument_list|,
name|IB_WC_WR_FLUSH_ERR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * tf_modify_item - to modify expiration time for specific item  * @tf:timeout-fifo object  * @mad_agent_priv: MAD agent.  * @send_buf: the MAD to modify in queue  * @timeout_ms: new timeout to set.  *  * Returns 0 if item found on list and -ENXIO if not.  *  * Note: The send_buf may point on MAD that is already released.  *       Therefore we can't use this struct before finding it in the list  */
end_comment

begin_function
specifier|static
name|int
name|tf_modify_item
parameter_list|(
name|struct
name|to_fifo
modifier|*
name|tf
parameter_list|,
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
parameter_list|,
name|struct
name|ib_mad_send_buf
modifier|*
name|send_buf
parameter_list|,
name|u32
name|timeout_ms
parameter_list|)
block|{
name|struct
name|tf_entry
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|item
decl_stmt|;
name|struct
name|list_head
modifier|*
name|list_item
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|tf
operator|->
name|lists_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|item
argument_list|,
argument|&tf->fifo_head
argument_list|,
argument|fifo_list
argument_list|)
block|{
if|if
condition|(
name|tfe_to_mad
argument_list|(
name|item
argument_list|)
operator|->
name|mad_agent_priv
operator|==
name|mad_agent_priv
operator|&&
operator|&
name|tfe_to_mad
argument_list|(
name|item
argument_list|)
operator|->
name|send_buf
operator|==
name|send_buf
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|tf
operator|->
name|lists_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENXIO
return|;
block|}
name|item
operator|->
name|exp_time
operator|=
name|jiffies
operator|+
name|msecs_to_jiffies
argument_list|(
name|timeout_ms
argument_list|)
expr_stmt|;
if|if
condition|(
name|timeout_ms
condition|)
block|{
name|list_del
argument_list|(
operator|&
name|item
operator|->
name|to_list
argument_list|)
expr_stmt|;
name|list_for_each_prev
argument_list|(
argument|list_item
argument_list|,
argument|&tf->to_head
argument_list|)
block|{
name|tmp
operator|=
name|list_entry
argument_list|(
name|list_item
argument_list|,
expr|struct
name|tf_entry
argument_list|,
name|to_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_after
argument_list|(
name|item
operator|->
name|exp_time
argument_list|,
name|tmp
operator|->
name|exp_time
argument_list|)
condition|)
break|break;
block|}
name|list_add
argument_list|(
operator|&
name|item
operator|->
name|to_list
argument_list|,
name|list_item
argument_list|)
expr_stmt|;
comment|/* modify expiration timer if required */
if|if
condition|(
name|list_item
operator|==
operator|&
name|tf
operator|->
name|to_head
condition|)
name|mod_timer
argument_list|(
operator|&
name|tf
operator|->
name|timer
argument_list|,
name|item
operator|->
name|exp_time
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * when item canceled (timeout_ms == 0) move item to 		 * head of timeout list and to the tail of fifo list 		 */
name|item
operator|->
name|canceled
operator|=
literal|1
expr_stmt|;
name|list_move
argument_list|(
operator|&
name|item
operator|->
name|to_list
argument_list|,
operator|&
name|tf
operator|->
name|to_head
argument_list|)
expr_stmt|;
name|list_move_tail
argument_list|(
operator|&
name|item
operator|->
name|fifo_list
argument_list|,
operator|&
name|tf
operator|->
name|fifo_head
argument_list|)
expr_stmt|;
name|mod_timer
argument_list|(
operator|&
name|tf
operator|->
name|timer
argument_list|,
name|item
operator|->
name|exp_time
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|tf
operator|->
name|lists_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * SA congestion control functions  */
end_comment

begin_comment
comment|/*  * Defines which MAD is under congestion control.  */
end_comment

begin_function
specifier|static
name|int
name|is_sa_cc_mad
parameter_list|(
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
parameter_list|)
block|{
name|struct
name|ib_mad_hdr
modifier|*
name|mad
decl_stmt|;
name|mad
operator|=
operator|(
expr|struct
name|ib_mad_hdr
operator|*
operator|)
name|mad_send_wr
operator|->
name|send_buf
operator|.
name|mad
expr_stmt|;
return|return
operator|(
operator|(
name|mad_send_wr
operator|->
name|send_buf
operator|.
name|timeout_ms
operator|)
operator|&&
operator|(
name|mad
operator|->
name|mgmt_class
operator|==
name|IB_MGMT_CLASS_SUBN_ADM
operator|)
operator|&&
operator|(
operator|(
name|mad
operator|->
name|method
operator|==
name|IB_MGMT_METHOD_GET
operator|)
operator|||
operator|(
name|mad
operator|->
name|method
operator|==
name|IB_MGMT_METHOD_SET
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Notify that SA congestion controlled MAD is done.  * to allow dequeuing SA MAD from congestion control queue.  */
end_comment

begin_function
specifier|static
name|void
name|sa_cc_mad_done
parameter_list|(
name|struct
name|sa_cc_data
modifier|*
name|cc_obj
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|struct
name|tf_entry
modifier|*
name|tfe
decl_stmt|;
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
decl_stmt|;
name|u32
name|time_left_ms
decl_stmt|,
name|timeout_ms
decl_stmt|,
name|retries
decl_stmt|;
name|int
name|ret
decl_stmt|;
do|do
block|{
name|spin_lock_irqsave
argument_list|(
operator|&
name|cc_obj
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|tfe
operator|=
name|tf_dequeue
argument_list|(
name|cc_obj
operator|->
name|tf
argument_list|,
operator|&
name|time_left_ms
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tfe
condition|)
block|{
if|if
condition|(
name|cc_obj
operator|->
name|outstanding
operator|>
literal|0
condition|)
name|cc_obj
operator|->
name|outstanding
operator|--
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cc_obj
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cc_obj
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|mad_send_wr
operator|=
name|tfe_to_mad
argument_list|(
name|tfe
argument_list|)
expr_stmt|;
name|time_left_ms
operator|+=
name|MIN_TIME_FOR_SA_MAD_SEND_MS
expr_stmt|;
if|if
condition|(
name|time_left_ms
operator|>
name|mad_send_wr
operator|->
name|send_buf
operator|.
name|timeout_ms
condition|)
block|{
name|retries
operator|=
name|time_left_ms
operator|/
name|mad_send_wr
operator|->
name|send_buf
operator|.
name|timeout_ms
operator|-
literal|1
expr_stmt|;
name|timeout_ms
operator|=
name|mad_send_wr
operator|->
name|send_buf
operator|.
name|timeout_ms
expr_stmt|;
block|}
else|else
block|{
name|retries
operator|=
literal|0
expr_stmt|;
name|timeout_ms
operator|=
name|time_left_ms
expr_stmt|;
block|}
name|ret
operator|=
name|send_sa_cc_mad
argument_list|(
name|mad_send_wr
argument_list|,
name|timeout_ms
argument_list|,
name|retries
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|ret
operator|==
operator|-
name|ENOMEM
condition|)
name|notify_failure
argument_list|(
name|mad_send_wr
argument_list|,
name|IB_WC_GENERAL_ERR
argument_list|)
expr_stmt|;
else|else
name|notify_failure
argument_list|(
name|mad_send_wr
argument_list|,
name|IB_WC_LOC_QP_OP_ERR
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|ret
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Send SA MAD under congestion control.  */
end_comment

begin_function
specifier|static
name|int
name|sa_cc_mad_send
parameter_list|(
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|sa_cc_data
modifier|*
name|cc_obj
decl_stmt|;
name|cc_obj
operator|=
name|get_cc_obj
argument_list|(
name|mad_send_wr
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|cc_obj
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc_obj
operator|->
name|outstanding
operator|<
name|MAX_OUTSTANDING_SA_MADS
condition|)
block|{
name|cc_obj
operator|->
name|outstanding
operator|++
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cc_obj
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ret
operator|=
name|send_sa_cc_mad
argument_list|(
name|mad_send_wr
argument_list|,
name|mad_send_wr
operator|->
name|send_buf
operator|.
name|timeout_ms
argument_list|,
name|mad_send_wr
operator|->
name|retries_left
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|sa_cc_mad_done
argument_list|(
name|cc_obj
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|qtime
init|=
operator|(
name|mad_send_wr
operator|->
name|send_buf
operator|.
name|timeout_ms
operator|*
operator|(
name|mad_send_wr
operator|->
name|retries_left
operator|+
literal|1
operator|)
operator|)
operator|-
name|MIN_TIME_FOR_SA_MAD_SEND_MS
decl_stmt|;
if|if
condition|(
name|qtime
operator|<
literal|0
condition|)
name|qtime
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|tf_enqueue
argument_list|(
name|cc_obj
operator|->
name|tf
argument_list|,
operator|&
name|mad_send_wr
operator|->
name|tf_list
argument_list|,
operator|(
name|u32
operator|)
name|qtime
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|cc_obj
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize SA congestion control.  */
end_comment

begin_function
specifier|static
name|int
name|sa_cc_init
parameter_list|(
name|struct
name|sa_cc_data
modifier|*
name|cc_obj
parameter_list|)
block|{
name|spin_lock_init
argument_list|(
operator|&
name|cc_obj
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cc_obj
operator|->
name|outstanding
operator|=
literal|0
expr_stmt|;
name|cc_obj
operator|->
name|tf
operator|=
name|tf_create
argument_list|(
name|MAX_SA_MADS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cc_obj
operator|->
name|tf
condition|)
return|return
operator|-
name|ENOMEM
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Cancel SA MADs from congestion control queue.  */
end_comment

begin_function
specifier|static
name|void
name|cancel_sa_cc_mads
parameter_list|(
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
parameter_list|)
block|{
name|tf_free_agent
argument_list|(
name|mad_agent_priv
operator|->
name|qp_info
operator|->
name|port_priv
operator|->
name|sa_cc
operator|.
name|tf
argument_list|,
name|mad_agent_priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Modify timeout of SA MAD on congestion control queue.  */
end_comment

begin_function
specifier|static
name|int
name|modify_sa_cc_mad
parameter_list|(
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
parameter_list|,
name|struct
name|ib_mad_send_buf
modifier|*
name|send_buf
parameter_list|,
name|u32
name|timeout_ms
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|qtime
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|timeout_ms
operator|>
name|MIN_TIME_FOR_SA_MAD_SEND_MS
condition|)
name|qtime
operator|=
name|timeout_ms
operator|-
name|MIN_TIME_FOR_SA_MAD_SEND_MS
expr_stmt|;
name|ret
operator|=
name|tf_modify_item
argument_list|(
name|mad_agent_priv
operator|->
name|qp_info
operator|->
name|port_priv
operator|->
name|sa_cc
operator|.
name|tf
argument_list|,
name|mad_agent_priv
argument_list|,
name|send_buf
argument_list|,
operator|(
name|u32
operator|)
name|qtime
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sa_cc_destroy
parameter_list|(
name|struct
name|sa_cc_data
modifier|*
name|cc_obj
parameter_list|)
block|{
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
decl_stmt|;
name|struct
name|tf_entry
modifier|*
name|tfe
decl_stmt|;
name|struct
name|ib_mad_send_wc
name|mad_send_wc
decl_stmt|;
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
decl_stmt|;
name|u32
name|time_left_ms
decl_stmt|;
name|mad_send_wc
operator|.
name|status
operator|=
name|IB_WC_WR_FLUSH_ERR
expr_stmt|;
name|mad_send_wc
operator|.
name|vendor_err
operator|=
literal|0
expr_stmt|;
name|tf_stop_enqueue
argument_list|(
name|cc_obj
operator|->
name|tf
argument_list|)
expr_stmt|;
name|tfe
operator|=
name|tf_dequeue
argument_list|(
name|cc_obj
operator|->
name|tf
argument_list|,
operator|&
name|time_left_ms
argument_list|)
expr_stmt|;
while|while
condition|(
name|tfe
condition|)
block|{
name|mad_send_wr
operator|=
name|tfe_to_mad
argument_list|(
name|tfe
argument_list|)
expr_stmt|;
name|mad_send_wc
operator|.
name|send_buf
operator|=
operator|&
name|mad_send_wr
operator|->
name|send_buf
expr_stmt|;
name|mad_agent_priv
operator|=
name|mad_send_wr
operator|->
name|mad_agent_priv
expr_stmt|;
name|mad_agent_priv
operator|->
name|agent
operator|.
name|send_handler
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|agent
argument_list|,
operator|&
name|mad_send_wc
argument_list|)
expr_stmt|;
name|tfe
operator|=
name|tf_dequeue
argument_list|(
name|cc_obj
operator|->
name|tf
argument_list|,
operator|&
name|time_left_ms
argument_list|)
expr_stmt|;
block|}
name|tf_free
argument_list|(
name|cc_obj
operator|->
name|tf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns a ib_mad_port_private structure or NULL for a device/port  * Assumes ib_mad_port_list_lock is being held  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|ib_mad_port_private
modifier|*
name|__ib_get_mad_port
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
name|port_num
parameter_list|)
block|{
name|struct
name|ib_mad_port_private
modifier|*
name|entry
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|entry
argument_list|,
argument|&ib_mad_port_list
argument_list|,
argument|port_list
argument_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|device
operator|==
name|device
operator|&&
name|entry
operator|->
name|port_num
operator|==
name|port_num
condition|)
return|return
name|entry
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Wrapper function to return a ib_mad_port_private structure or NULL  * for a device/port  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|ib_mad_port_private
modifier|*
name|ib_get_mad_port
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
name|port_num
parameter_list|)
block|{
name|struct
name|ib_mad_port_private
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|ib_mad_port_list_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|entry
operator|=
name|__ib_get_mad_port
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|ib_mad_port_list_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u8
name|convert_mgmt_class
parameter_list|(
name|u8
name|mgmt_class
parameter_list|)
block|{
comment|/* Alias IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE to 0 */
return|return
name|mgmt_class
operator|==
name|IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE
condition|?
literal|0
else|:
name|mgmt_class
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_spl_qp_index
parameter_list|(
name|enum
name|ib_qp_type
name|qp_type
parameter_list|)
block|{
switch|switch
condition|(
name|qp_type
condition|)
block|{
case|case
name|IB_QPT_SMI
case|:
return|return
literal|0
return|;
case|case
name|IB_QPT_GSI
case|:
return|return
literal|1
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|vendor_class_index
parameter_list|(
name|u8
name|mgmt_class
parameter_list|)
block|{
return|return
name|mgmt_class
operator|-
name|IB_MGMT_CLASS_VENDOR_RANGE2_START
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_vendor_class
parameter_list|(
name|u8
name|mgmt_class
parameter_list|)
block|{
if|if
condition|(
operator|(
name|mgmt_class
operator|<
name|IB_MGMT_CLASS_VENDOR_RANGE2_START
operator|)
operator|||
operator|(
name|mgmt_class
operator|>
name|IB_MGMT_CLASS_VENDOR_RANGE2_END
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_vendor_oui
parameter_list|(
name|char
modifier|*
name|oui
parameter_list|)
block|{
if|if
condition|(
name|oui
index|[
literal|0
index|]
operator|||
name|oui
index|[
literal|1
index|]
operator|||
name|oui
index|[
literal|2
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_vendor_method_in_use
parameter_list|(
name|struct
name|ib_mad_mgmt_vendor_class
modifier|*
name|vendor_class
parameter_list|,
name|struct
name|ib_mad_reg_req
modifier|*
name|mad_reg_req
parameter_list|)
block|{
name|struct
name|ib_mad_mgmt_method_table
modifier|*
name|method
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MGMT_OUI
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|vendor_class
operator|->
name|oui
index|[
name|i
index|]
argument_list|,
name|mad_reg_req
operator|->
name|oui
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|method
operator|=
name|vendor_class
operator|->
name|method_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|method
condition|)
block|{
if|if
condition|(
name|method_in_use
argument_list|(
operator|&
name|method
argument_list|,
name|mad_reg_req
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
break|break;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ib_response_mad
parameter_list|(
name|struct
name|ib_mad
modifier|*
name|mad
parameter_list|)
block|{
return|return
operator|(
operator|(
name|mad
operator|->
name|mad_hdr
operator|.
name|method
operator|&
name|IB_MGMT_METHOD_RESP
operator|)
operator|||
operator|(
name|mad
operator|->
name|mad_hdr
operator|.
name|method
operator|==
name|IB_MGMT_METHOD_TRAP_REPRESS
operator|)
operator|||
operator|(
operator|(
name|mad
operator|->
name|mad_hdr
operator|.
name|mgmt_class
operator|==
name|IB_MGMT_CLASS_BM
operator|)
operator|&&
operator|(
name|mad
operator|->
name|mad_hdr
operator|.
name|attr_mod
operator|&
name|IB_BM_ATTR_MOD_RESP
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_response_mad
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * ib_register_mad_agent - Register to send/receive MADs  */
end_comment

begin_function
name|struct
name|ib_mad_agent
modifier|*
name|ib_register_mad_agent
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|enum
name|ib_qp_type
name|qp_type
parameter_list|,
name|struct
name|ib_mad_reg_req
modifier|*
name|mad_reg_req
parameter_list|,
name|u8
name|rmpp_version
parameter_list|,
name|ib_mad_send_handler
name|send_handler
parameter_list|,
name|ib_mad_recv_handler
name|recv_handler
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|ib_mad_port_private
modifier|*
name|port_priv
decl_stmt|;
name|struct
name|ib_mad_agent
modifier|*
name|ret
init|=
name|ERR_PTR
argument_list|(
operator|-
name|EINVAL
argument_list|)
decl_stmt|;
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
decl_stmt|;
name|struct
name|ib_mad_reg_req
modifier|*
name|reg_req
init|=
name|NULL
decl_stmt|;
name|struct
name|ib_mad_mgmt_class_table
modifier|*
name|class
decl_stmt|;
name|struct
name|ib_mad_mgmt_vendor_class_table
modifier|*
name|vendor
decl_stmt|;
name|struct
name|ib_mad_mgmt_vendor_class
modifier|*
name|vendor_class
decl_stmt|;
name|struct
name|ib_mad_mgmt_method_table
modifier|*
name|method
decl_stmt|;
name|int
name|ret2
decl_stmt|,
name|qpn
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|u8
name|mgmt_class
decl_stmt|,
name|vclass
decl_stmt|;
comment|/* Validate parameters */
name|qpn
operator|=
name|get_spl_qp_index
argument_list|(
name|qp_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|qpn
operator|==
operator|-
literal|1
condition|)
goto|goto
name|error1
goto|;
if|if
condition|(
name|rmpp_version
operator|&&
name|rmpp_version
operator|!=
name|IB_MGMT_RMPP_VERSION
condition|)
goto|goto
name|error1
goto|;
comment|/* Validate MAD registration request if supplied */
if|if
condition|(
name|mad_reg_req
condition|)
block|{
if|if
condition|(
name|mad_reg_req
operator|->
name|mgmt_class_version
operator|>=
name|MAX_MGMT_VERSION
condition|)
goto|goto
name|error1
goto|;
if|if
condition|(
operator|!
name|recv_handler
condition|)
goto|goto
name|error1
goto|;
if|if
condition|(
name|mad_reg_req
operator|->
name|mgmt_class
operator|>=
name|MAX_MGMT_CLASS
condition|)
block|{
comment|/* 			 * IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE is the only 			 * one in this range currently allowed 			 */
if|if
condition|(
name|mad_reg_req
operator|->
name|mgmt_class
operator|!=
name|IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE
condition|)
goto|goto
name|error1
goto|;
block|}
elseif|else
if|if
condition|(
name|mad_reg_req
operator|->
name|mgmt_class
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Class 0 is reserved in IBA and is used for 			 * aliasing of IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE 			 */
goto|goto
name|error1
goto|;
block|}
elseif|else
if|if
condition|(
name|is_vendor_class
argument_list|(
name|mad_reg_req
operator|->
name|mgmt_class
argument_list|)
condition|)
block|{
comment|/* 			 * If class is in "new" vendor range, 			 * ensure supplied OUI is not zero 			 */
if|if
condition|(
operator|!
name|is_vendor_oui
argument_list|(
name|mad_reg_req
operator|->
name|oui
argument_list|)
condition|)
goto|goto
name|error1
goto|;
block|}
comment|/* Make sure class supplied is consistent with RMPP */
if|if
condition|(
operator|!
name|ib_is_mad_class_rmpp
argument_list|(
name|mad_reg_req
operator|->
name|mgmt_class
argument_list|)
condition|)
block|{
if|if
condition|(
name|rmpp_version
condition|)
goto|goto
name|error1
goto|;
block|}
comment|/* Make sure class supplied is consistent with QP type */
if|if
condition|(
name|qp_type
operator|==
name|IB_QPT_SMI
condition|)
block|{
if|if
condition|(
operator|(
name|mad_reg_req
operator|->
name|mgmt_class
operator|!=
name|IB_MGMT_CLASS_SUBN_LID_ROUTED
operator|)
operator|&&
operator|(
name|mad_reg_req
operator|->
name|mgmt_class
operator|!=
name|IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE
operator|)
condition|)
goto|goto
name|error1
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|mad_reg_req
operator|->
name|mgmt_class
operator|==
name|IB_MGMT_CLASS_SUBN_LID_ROUTED
operator|)
operator|||
operator|(
name|mad_reg_req
operator|->
name|mgmt_class
operator|==
name|IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE
operator|)
condition|)
goto|goto
name|error1
goto|;
block|}
block|}
else|else
block|{
comment|/* No registration request supplied */
if|if
condition|(
operator|!
name|send_handler
condition|)
goto|goto
name|error1
goto|;
block|}
comment|/* Validate device and port */
name|port_priv
operator|=
name|ib_get_mad_port
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port_priv
condition|)
block|{
name|ret
operator|=
name|ERR_PTR
argument_list|(
operator|-
name|ENODEV
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
comment|/* Verify the QP requested is supported.  For example, Ethernet devices 	 * will not have QP0 */
if|if
condition|(
operator|!
name|port_priv
operator|->
name|qp_info
index|[
name|qpn
index|]
operator|.
name|qp
condition|)
block|{
name|ret
operator|=
name|ERR_PTR
argument_list|(
operator|-
name|EPROTONOSUPPORT
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
comment|/* Allocate structures */
name|mad_agent_priv
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|mad_agent_priv
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mad_agent_priv
condition|)
block|{
name|ret
operator|=
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
name|mad_agent_priv
operator|->
name|agent
operator|.
name|mr
operator|=
name|ib_get_dma_mr
argument_list|(
name|port_priv
operator|->
name|qp_info
index|[
name|qpn
index|]
operator|.
name|qp
operator|->
name|pd
argument_list|,
name|IB_ACCESS_LOCAL_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mad_agent_priv
operator|->
name|agent
operator|.
name|mr
argument_list|)
condition|)
block|{
name|ret
operator|=
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
expr_stmt|;
goto|goto
name|error2
goto|;
block|}
if|if
condition|(
name|mad_reg_req
condition|)
block|{
name|reg_req
operator|=
name|kmemdup
argument_list|(
name|mad_reg_req
argument_list|,
sizeof|sizeof
expr|*
name|reg_req
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reg_req
condition|)
block|{
name|ret
operator|=
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
expr_stmt|;
goto|goto
name|error3
goto|;
block|}
block|}
comment|/* Now, fill in the various structures */
name|mad_agent_priv
operator|->
name|qp_info
operator|=
operator|&
name|port_priv
operator|->
name|qp_info
index|[
name|qpn
index|]
expr_stmt|;
name|mad_agent_priv
operator|->
name|reg_req
operator|=
name|reg_req
expr_stmt|;
name|mad_agent_priv
operator|->
name|agent
operator|.
name|rmpp_version
operator|=
name|rmpp_version
expr_stmt|;
name|mad_agent_priv
operator|->
name|agent
operator|.
name|device
operator|=
name|device
expr_stmt|;
name|mad_agent_priv
operator|->
name|agent
operator|.
name|recv_handler
operator|=
name|recv_handler
expr_stmt|;
name|mad_agent_priv
operator|->
name|agent
operator|.
name|send_handler
operator|=
name|send_handler
expr_stmt|;
name|mad_agent_priv
operator|->
name|agent
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|mad_agent_priv
operator|->
name|agent
operator|.
name|qp
operator|=
name|port_priv
operator|->
name|qp_info
index|[
name|qpn
index|]
operator|.
name|qp
expr_stmt|;
name|mad_agent_priv
operator|->
name|agent
operator|.
name|port_num
operator|=
name|port_num
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|send_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|wait_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|done_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|rmpp_list
argument_list|)
expr_stmt|;
name|INIT_DELAYED_WORK
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|timed_work
argument_list|,
name|timeout_sends
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|local_list
argument_list|)
expr_stmt|;
name|INIT_WORK
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|local_work
argument_list|,
name|local_completions
argument_list|)
expr_stmt|;
name|atomic_set
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|init_completion
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|comp
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|port_priv
operator|->
name|reg_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|mad_agent_priv
operator|->
name|agent
operator|.
name|hi_tid
operator|=
operator|++
name|ib_mad_client_id
expr_stmt|;
comment|/* 	 * Make sure MAD registration (if supplied) 	 * is non overlapping with any existing ones 	 */
if|if
condition|(
name|mad_reg_req
condition|)
block|{
name|mgmt_class
operator|=
name|convert_mgmt_class
argument_list|(
name|mad_reg_req
operator|->
name|mgmt_class
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_vendor_class
argument_list|(
name|mgmt_class
argument_list|)
condition|)
block|{
name|class
operator|=
name|port_priv
operator|->
name|version
index|[
name|mad_reg_req
operator|->
name|mgmt_class_version
index|]
operator|.
name|class
expr_stmt|;
if|if
condition|(
name|class
condition|)
block|{
name|method
operator|=
name|class
operator|->
name|method_table
index|[
name|mgmt_class
index|]
expr_stmt|;
if|if
condition|(
name|method
condition|)
block|{
if|if
condition|(
name|method_in_use
argument_list|(
operator|&
name|method
argument_list|,
name|mad_reg_req
argument_list|)
condition|)
goto|goto
name|error4
goto|;
block|}
block|}
name|ret2
operator|=
name|add_nonoui_reg_req
argument_list|(
name|mad_reg_req
argument_list|,
name|mad_agent_priv
argument_list|,
name|mgmt_class
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* "New" vendor class range */
name|vendor
operator|=
name|port_priv
operator|->
name|version
index|[
name|mad_reg_req
operator|->
name|mgmt_class_version
index|]
operator|.
name|vendor
expr_stmt|;
if|if
condition|(
name|vendor
condition|)
block|{
name|vclass
operator|=
name|vendor_class_index
argument_list|(
name|mgmt_class
argument_list|)
expr_stmt|;
name|vendor_class
operator|=
name|vendor
operator|->
name|vendor_class
index|[
name|vclass
index|]
expr_stmt|;
if|if
condition|(
name|vendor_class
condition|)
block|{
if|if
condition|(
name|is_vendor_method_in_use
argument_list|(
name|vendor_class
argument_list|,
name|mad_reg_req
argument_list|)
condition|)
goto|goto
name|error4
goto|;
block|}
block|}
name|ret2
operator|=
name|add_oui_reg_req
argument_list|(
name|mad_reg_req
argument_list|,
name|mad_agent_priv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret2
condition|)
block|{
name|ret
operator|=
name|ERR_PTR
argument_list|(
name|ret2
argument_list|)
expr_stmt|;
goto|goto
name|error4
goto|;
block|}
block|}
comment|/* Add mad agent into port's agent list */
name|list_add_tail
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|agent_list
argument_list|,
operator|&
name|port_priv
operator|->
name|agent_list
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|port_priv
operator|->
name|reg_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|&
name|mad_agent_priv
operator|->
name|agent
return|;
name|error4
label|:
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|port_priv
operator|->
name|reg_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|reg_req
argument_list|)
expr_stmt|;
name|error3
label|:
name|ib_dereg_mr
argument_list|(
name|mad_agent_priv
operator|->
name|agent
operator|.
name|mr
argument_list|)
expr_stmt|;
name|error2
label|:
name|kfree
argument_list|(
name|mad_agent_priv
argument_list|)
expr_stmt|;
name|error1
label|:
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_register_mad_agent
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
specifier|inline
name|int
name|is_snooping_sends
parameter_list|(
name|int
name|mad_snoop_flags
parameter_list|)
block|{
return|return
operator|(
name|mad_snoop_flags
operator|&
operator|(
comment|/*IB_MAD_SNOOP_POSTED_SENDS | 		 IB_MAD_SNOOP_RMPP_SENDS |*/
name|IB_MAD_SNOOP_SEND_COMPLETIONS
comment|/*| 		 IB_MAD_SNOOP_RMPP_SEND_COMPLETIONS*/
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|is_snooping_recvs
parameter_list|(
name|int
name|mad_snoop_flags
parameter_list|)
block|{
return|return
operator|(
name|mad_snoop_flags
operator|&
operator|(
name|IB_MAD_SNOOP_RECVS
comment|/*| 		 IB_MAD_SNOOP_RMPP_RECVS*/
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|register_snoop_agent
parameter_list|(
name|struct
name|ib_mad_qp_info
modifier|*
name|qp_info
parameter_list|,
name|struct
name|ib_mad_snoop_private
modifier|*
name|mad_snoop_priv
parameter_list|)
block|{
name|struct
name|ib_mad_snoop_private
modifier|*
modifier|*
name|new_snoop_table
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|i
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|qp_info
operator|->
name|snoop_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Check for empty slot in array. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp_info
operator|->
name|snoop_table_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|qp_info
operator|->
name|snoop_table
index|[
name|i
index|]
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|qp_info
operator|->
name|snoop_table_size
condition|)
block|{
comment|/* Grow table. */
name|new_snoop_table
operator|=
name|krealloc
argument_list|(
name|qp_info
operator|->
name|snoop_table
argument_list|,
sizeof|sizeof
name|mad_snoop_priv
operator|*
operator|(
name|qp_info
operator|->
name|snoop_table_size
operator|+
literal|1
operator|)
argument_list|,
name|GFP_ATOMIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_snoop_table
condition|)
block|{
name|i
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|qp_info
operator|->
name|snoop_table
operator|=
name|new_snoop_table
expr_stmt|;
name|qp_info
operator|->
name|snoop_table_size
operator|++
expr_stmt|;
block|}
name|qp_info
operator|->
name|snoop_table
index|[
name|i
index|]
operator|=
name|mad_snoop_priv
expr_stmt|;
name|atomic_inc
argument_list|(
operator|&
name|qp_info
operator|->
name|snoop_count
argument_list|)
expr_stmt|;
name|out
label|:
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|qp_info
operator|->
name|snoop_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
end_function

begin_function
name|struct
name|ib_mad_agent
modifier|*
name|ib_register_mad_snoop
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|enum
name|ib_qp_type
name|qp_type
parameter_list|,
name|int
name|mad_snoop_flags
parameter_list|,
name|ib_mad_snoop_handler
name|snoop_handler
parameter_list|,
name|ib_mad_recv_handler
name|recv_handler
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|ib_mad_port_private
modifier|*
name|port_priv
decl_stmt|;
name|struct
name|ib_mad_agent
modifier|*
name|ret
decl_stmt|;
name|struct
name|ib_mad_snoop_private
modifier|*
name|mad_snoop_priv
decl_stmt|;
name|int
name|qpn
decl_stmt|;
comment|/* Validate parameters */
if|if
condition|(
operator|(
name|is_snooping_sends
argument_list|(
name|mad_snoop_flags
argument_list|)
operator|&&
operator|!
name|snoop_handler
operator|)
operator|||
operator|(
name|is_snooping_recvs
argument_list|(
name|mad_snoop_flags
argument_list|)
operator|&&
operator|!
name|recv_handler
operator|)
condition|)
block|{
name|ret
operator|=
name|ERR_PTR
argument_list|(
operator|-
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
name|qpn
operator|=
name|get_spl_qp_index
argument_list|(
name|qp_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|qpn
operator|==
operator|-
literal|1
condition|)
block|{
name|ret
operator|=
name|ERR_PTR
argument_list|(
operator|-
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
name|port_priv
operator|=
name|ib_get_mad_port
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port_priv
condition|)
block|{
name|ret
operator|=
name|ERR_PTR
argument_list|(
operator|-
name|ENODEV
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
comment|/* Allocate structures */
name|mad_snoop_priv
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|mad_snoop_priv
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mad_snoop_priv
condition|)
block|{
name|ret
operator|=
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
comment|/* Now, fill in the various structures */
name|mad_snoop_priv
operator|->
name|qp_info
operator|=
operator|&
name|port_priv
operator|->
name|qp_info
index|[
name|qpn
index|]
expr_stmt|;
name|mad_snoop_priv
operator|->
name|agent
operator|.
name|device
operator|=
name|device
expr_stmt|;
name|mad_snoop_priv
operator|->
name|agent
operator|.
name|recv_handler
operator|=
name|recv_handler
expr_stmt|;
name|mad_snoop_priv
operator|->
name|agent
operator|.
name|snoop_handler
operator|=
name|snoop_handler
expr_stmt|;
name|mad_snoop_priv
operator|->
name|agent
operator|.
name|context
operator|=
name|context
expr_stmt|;
name|mad_snoop_priv
operator|->
name|agent
operator|.
name|qp
operator|=
name|port_priv
operator|->
name|qp_info
index|[
name|qpn
index|]
operator|.
name|qp
expr_stmt|;
name|mad_snoop_priv
operator|->
name|agent
operator|.
name|port_num
operator|=
name|port_num
expr_stmt|;
name|mad_snoop_priv
operator|->
name|mad_snoop_flags
operator|=
name|mad_snoop_flags
expr_stmt|;
name|init_completion
argument_list|(
operator|&
name|mad_snoop_priv
operator|->
name|comp
argument_list|)
expr_stmt|;
name|mad_snoop_priv
operator|->
name|snoop_index
operator|=
name|register_snoop_agent
argument_list|(
operator|&
name|port_priv
operator|->
name|qp_info
index|[
name|qpn
index|]
argument_list|,
name|mad_snoop_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|mad_snoop_priv
operator|->
name|snoop_index
operator|<
literal|0
condition|)
block|{
name|ret
operator|=
name|ERR_PTR
argument_list|(
name|mad_snoop_priv
operator|->
name|snoop_index
argument_list|)
expr_stmt|;
goto|goto
name|error2
goto|;
block|}
name|atomic_set
argument_list|(
operator|&
name|mad_snoop_priv
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|&
name|mad_snoop_priv
operator|->
name|agent
return|;
name|error2
label|:
name|kfree
argument_list|(
name|mad_snoop_priv
argument_list|)
expr_stmt|;
name|error1
label|:
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_register_mad_snoop
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
specifier|inline
name|void
name|deref_mad_agent
parameter_list|(
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
parameter_list|)
block|{
if|if
condition|(
name|atomic_dec_and_test
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|refcount
argument_list|)
condition|)
name|complete
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|comp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|deref_snoop_agent
parameter_list|(
name|struct
name|ib_mad_snoop_private
modifier|*
name|mad_snoop_priv
parameter_list|)
block|{
if|if
condition|(
name|atomic_dec_and_test
argument_list|(
operator|&
name|mad_snoop_priv
operator|->
name|refcount
argument_list|)
condition|)
name|complete
argument_list|(
operator|&
name|mad_snoop_priv
operator|->
name|comp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unregister_mad_agent
parameter_list|(
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
parameter_list|)
block|{
name|struct
name|ib_mad_port_private
modifier|*
name|port_priv
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
comment|/* Note that we could still be handling received MADs */
comment|/* 	 * Canceling all sends results in dropping received response 	 * MADs, preventing us from queuing additional work 	 */
name|cancel_mads
argument_list|(
name|mad_agent_priv
argument_list|)
expr_stmt|;
name|port_priv
operator|=
name|mad_agent_priv
operator|->
name|qp_info
operator|->
name|port_priv
expr_stmt|;
name|cancel_delayed_work_sync
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|timed_work
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|port_priv
operator|->
name|reg_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|remove_mad_reg_req
argument_list|(
name|mad_agent_priv
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|agent_list
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|port_priv
operator|->
name|reg_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|flush_workqueue
argument_list|(
name|port_priv
operator|->
name|wq
argument_list|)
expr_stmt|;
name|ib_cancel_rmpp_recvs
argument_list|(
name|mad_agent_priv
argument_list|)
expr_stmt|;
name|deref_mad_agent
argument_list|(
name|mad_agent_priv
argument_list|)
expr_stmt|;
name|wait_for_completion
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|comp
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mad_agent_priv
operator|->
name|reg_req
argument_list|)
expr_stmt|;
name|ib_dereg_mr
argument_list|(
name|mad_agent_priv
operator|->
name|agent
operator|.
name|mr
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mad_agent_priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unregister_mad_snoop
parameter_list|(
name|struct
name|ib_mad_snoop_private
modifier|*
name|mad_snoop_priv
parameter_list|)
block|{
name|struct
name|ib_mad_qp_info
modifier|*
name|qp_info
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|qp_info
operator|=
name|mad_snoop_priv
operator|->
name|qp_info
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|qp_info
operator|->
name|snoop_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|qp_info
operator|->
name|snoop_table
index|[
name|mad_snoop_priv
operator|->
name|snoop_index
index|]
operator|=
name|NULL
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|qp_info
operator|->
name|snoop_count
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|qp_info
operator|->
name|snoop_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|deref_snoop_agent
argument_list|(
name|mad_snoop_priv
argument_list|)
expr_stmt|;
name|wait_for_completion
argument_list|(
operator|&
name|mad_snoop_priv
operator|->
name|comp
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mad_snoop_priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ib_unregister_mad_agent - Unregisters a client from using MAD services  */
end_comment

begin_function
name|int
name|ib_unregister_mad_agent
parameter_list|(
name|struct
name|ib_mad_agent
modifier|*
name|mad_agent
parameter_list|)
block|{
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
decl_stmt|;
name|struct
name|ib_mad_snoop_private
modifier|*
name|mad_snoop_priv
decl_stmt|;
if|if
condition|(
operator|!
name|IS_ERR
argument_list|(
name|mad_agent
argument_list|)
condition|)
block|{
comment|/* If the TID is zero, the agent can only snoop. */
if|if
condition|(
name|mad_agent
operator|->
name|hi_tid
condition|)
block|{
name|mad_agent_priv
operator|=
name|container_of
argument_list|(
name|mad_agent
argument_list|,
expr|struct
name|ib_mad_agent_private
argument_list|,
name|agent
argument_list|)
expr_stmt|;
name|unregister_mad_agent
argument_list|(
name|mad_agent_priv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mad_snoop_priv
operator|=
name|container_of
argument_list|(
name|mad_agent
argument_list|,
expr|struct
name|ib_mad_snoop_private
argument_list|,
name|agent
argument_list|)
expr_stmt|;
name|unregister_mad_snoop
argument_list|(
name|mad_snoop_priv
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_unregister_mad_agent
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|dequeue_mad
parameter_list|(
name|struct
name|ib_mad_list_head
modifier|*
name|mad_list
parameter_list|)
block|{
name|struct
name|ib_mad_queue
modifier|*
name|mad_queue
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|BUG_ON
argument_list|(
operator|!
name|mad_list
operator|->
name|mad_queue
argument_list|)
expr_stmt|;
name|mad_queue
operator|=
name|mad_list
operator|->
name|mad_queue
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|mad_queue
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|mad_list
operator|->
name|list
argument_list|)
expr_stmt|;
name|mad_queue
operator|->
name|count
operator|--
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|mad_queue
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|snoop_send
parameter_list|(
name|struct
name|ib_mad_qp_info
modifier|*
name|qp_info
parameter_list|,
name|struct
name|ib_mad_send_buf
modifier|*
name|send_buf
parameter_list|,
name|struct
name|ib_mad_send_wc
modifier|*
name|mad_send_wc
parameter_list|,
name|int
name|mad_snoop_flags
parameter_list|)
block|{
name|struct
name|ib_mad_snoop_private
modifier|*
name|mad_snoop_priv
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|i
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|qp_info
operator|->
name|snoop_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp_info
operator|->
name|snoop_table_size
condition|;
name|i
operator|++
control|)
block|{
name|mad_snoop_priv
operator|=
name|qp_info
operator|->
name|snoop_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|mad_snoop_priv
operator|||
operator|!
operator|(
name|mad_snoop_priv
operator|->
name|mad_snoop_flags
operator|&
name|mad_snoop_flags
operator|)
condition|)
continue|continue;
name|atomic_inc
argument_list|(
operator|&
name|mad_snoop_priv
operator|->
name|refcount
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|qp_info
operator|->
name|snoop_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|mad_snoop_priv
operator|->
name|agent
operator|.
name|snoop_handler
argument_list|(
operator|&
name|mad_snoop_priv
operator|->
name|agent
argument_list|,
name|send_buf
argument_list|,
name|mad_send_wc
argument_list|)
expr_stmt|;
name|deref_snoop_agent
argument_list|(
name|mad_snoop_priv
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|qp_info
operator|->
name|snoop_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|qp_info
operator|->
name|snoop_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|snoop_recv
parameter_list|(
name|struct
name|ib_mad_qp_info
modifier|*
name|qp_info
parameter_list|,
name|struct
name|ib_mad_recv_wc
modifier|*
name|mad_recv_wc
parameter_list|,
name|int
name|mad_snoop_flags
parameter_list|)
block|{
name|struct
name|ib_mad_snoop_private
modifier|*
name|mad_snoop_priv
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|i
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|qp_info
operator|->
name|snoop_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp_info
operator|->
name|snoop_table_size
condition|;
name|i
operator|++
control|)
block|{
name|mad_snoop_priv
operator|=
name|qp_info
operator|->
name|snoop_table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|mad_snoop_priv
operator|||
operator|!
operator|(
name|mad_snoop_priv
operator|->
name|mad_snoop_flags
operator|&
name|mad_snoop_flags
operator|)
condition|)
continue|continue;
name|atomic_inc
argument_list|(
operator|&
name|mad_snoop_priv
operator|->
name|refcount
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|qp_info
operator|->
name|snoop_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|mad_snoop_priv
operator|->
name|agent
operator|.
name|recv_handler
argument_list|(
operator|&
name|mad_snoop_priv
operator|->
name|agent
argument_list|,
name|mad_recv_wc
argument_list|)
expr_stmt|;
name|deref_snoop_agent
argument_list|(
name|mad_snoop_priv
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|qp_info
operator|->
name|snoop_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|qp_info
operator|->
name|snoop_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_smp_wc
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|u64
name|wr_id
parameter_list|,
name|u16
name|slid
parameter_list|,
name|u16
name|pkey_index
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|struct
name|ib_wc
modifier|*
name|wc
parameter_list|)
block|{
name|memset
argument_list|(
name|wc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|wc
argument_list|)
expr_stmt|;
name|wc
operator|->
name|wr_id
operator|=
name|wr_id
expr_stmt|;
name|wc
operator|->
name|status
operator|=
name|IB_WC_SUCCESS
expr_stmt|;
name|wc
operator|->
name|opcode
operator|=
name|IB_WC_RECV
expr_stmt|;
name|wc
operator|->
name|pkey_index
operator|=
name|pkey_index
expr_stmt|;
name|wc
operator|->
name|byte_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ib_mad
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ib_grh
argument_list|)
expr_stmt|;
name|wc
operator|->
name|src_qp
operator|=
name|IB_QP0
expr_stmt|;
name|wc
operator|->
name|qp
operator|=
name|qp
expr_stmt|;
name|wc
operator|->
name|slid
operator|=
name|slid
expr_stmt|;
name|wc
operator|->
name|sl
operator|=
literal|0
expr_stmt|;
name|wc
operator|->
name|dlid_path_bits
operator|=
literal|0
expr_stmt|;
name|wc
operator|->
name|port_num
operator|=
name|port_num
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return 0 if SMP is to be sent  * Return 1 if SMP was consumed locally (whether or not solicited)  * Return< 0 if error  */
end_comment

begin_function
specifier|static
name|int
name|handle_outgoing_dr_smp
parameter_list|(
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
parameter_list|,
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|ib_smp
modifier|*
name|smp
init|=
name|mad_send_wr
operator|->
name|send_buf
operator|.
name|mad
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|struct
name|ib_mad_local_private
modifier|*
name|local
decl_stmt|;
name|struct
name|ib_mad_private
modifier|*
name|mad_priv
decl_stmt|;
name|struct
name|ib_mad_port_private
modifier|*
name|port_priv
decl_stmt|;
name|struct
name|ib_mad_agent_private
modifier|*
name|recv_mad_agent
init|=
name|NULL
decl_stmt|;
name|struct
name|ib_device
modifier|*
name|device
init|=
name|mad_agent_priv
operator|->
name|agent
operator|.
name|device
decl_stmt|;
name|u8
name|port_num
decl_stmt|;
name|struct
name|ib_wc
name|mad_wc
decl_stmt|;
name|struct
name|ib_send_wr
modifier|*
name|send_wr
init|=
operator|&
name|mad_send_wr
operator|->
name|send_wr
decl_stmt|;
if|if
condition|(
name|device
operator|->
name|node_type
operator|==
name|RDMA_NODE_IB_SWITCH
operator|&&
name|smp
operator|->
name|mgmt_class
operator|==
name|IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE
condition|)
name|port_num
operator|=
name|send_wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|port_num
expr_stmt|;
else|else
name|port_num
operator|=
name|mad_agent_priv
operator|->
name|agent
operator|.
name|port_num
expr_stmt|;
comment|/* 	 * Directed route handling starts if the initial LID routed part of 	 * a request or the ending LID routed part of a response is empty. 	 * If we are at the start of the LID routed part, don't update the 	 * hop_ptr or hop_cnt.  See section 14.2.2, Vol 1 IB spec. 	 */
if|if
condition|(
operator|(
name|ib_get_smp_direction
argument_list|(
name|smp
argument_list|)
condition|?
name|smp
operator|->
name|dr_dlid
else|:
name|smp
operator|->
name|dr_slid
operator|)
operator|!=
name|IB_LID_PERMISSIVE
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|smi_handle_dr_smp_send
argument_list|(
name|smp
argument_list|,
name|device
operator|->
name|node_type
argument_list|,
name|port_num
argument_list|)
operator|==
name|IB_SMI_DISCARD
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"Invalid directed route\n"
argument_list|)
empty_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Check to post send on QP or process locally */
if|if
condition|(
name|smi_check_local_smp
argument_list|(
name|smp
argument_list|,
name|device
argument_list|)
operator|==
name|IB_SMI_DISCARD
operator|&&
name|smi_check_local_returning_smp
argument_list|(
name|smp
argument_list|,
name|device
argument_list|)
operator|==
name|IB_SMI_DISCARD
condition|)
goto|goto
name|out
goto|;
name|local
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|local
argument_list|,
name|GFP_ATOMIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"No memory for ib_mad_local_private\n"
argument_list|)
empty_stmt|;
goto|goto
name|out
goto|;
block|}
name|local
operator|->
name|mad_priv
operator|=
name|NULL
expr_stmt|;
name|local
operator|->
name|recv_mad_agent
operator|=
name|NULL
expr_stmt|;
name|mad_priv
operator|=
name|kmem_cache_alloc
argument_list|(
name|ib_mad_cache
argument_list|,
name|GFP_ATOMIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mad_priv
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"No memory for local response MAD\n"
argument_list|)
empty_stmt|;
name|kfree
argument_list|(
name|local
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|build_smp_wc
argument_list|(
name|mad_agent_priv
operator|->
name|agent
operator|.
name|qp
argument_list|,
name|send_wr
operator|->
name|wr_id
argument_list|,
name|be16_to_cpu
argument_list|(
name|smp
operator|->
name|dr_slid
argument_list|)
argument_list|,
name|send_wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|pkey_index
argument_list|,
name|send_wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|port_num
argument_list|,
operator|&
name|mad_wc
argument_list|)
expr_stmt|;
comment|/* No GRH for DR SMP */
name|ret
operator|=
name|device
operator|->
name|process_mad
argument_list|(
name|device
argument_list|,
literal|0
argument_list|,
name|port_num
argument_list|,
operator|&
name|mad_wc
argument_list|,
name|NULL
argument_list|,
operator|(
expr|struct
name|ib_mad
operator|*
operator|)
name|smp
argument_list|,
operator|(
expr|struct
name|ib_mad
operator|*
operator|)
operator|&
name|mad_priv
operator|->
name|mad
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|IB_MAD_RESULT_SUCCESS
operator||
name|IB_MAD_RESULT_REPLY
case|:
if|if
condition|(
name|ib_response_mad
argument_list|(
operator|&
name|mad_priv
operator|->
name|mad
operator|.
name|mad
argument_list|)
operator|&&
name|mad_agent_priv
operator|->
name|agent
operator|.
name|recv_handler
condition|)
block|{
name|local
operator|->
name|mad_priv
operator|=
name|mad_priv
expr_stmt|;
name|local
operator|->
name|recv_mad_agent
operator|=
name|mad_agent_priv
expr_stmt|;
comment|/* 			 * Reference MAD agent until receive 			 * side of local completion handled 			 */
name|atomic_inc
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|refcount
argument_list|)
expr_stmt|;
block|}
else|else
name|kmem_cache_free
argument_list|(
name|ib_mad_cache
argument_list|,
name|mad_priv
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_MAD_RESULT_SUCCESS
operator||
name|IB_MAD_RESULT_CONSUMED
case|:
name|kmem_cache_free
argument_list|(
name|ib_mad_cache
argument_list|,
name|mad_priv
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_MAD_RESULT_SUCCESS
case|:
comment|/* Treat like an incoming receive MAD */
name|port_priv
operator|=
name|ib_get_mad_port
argument_list|(
name|mad_agent_priv
operator|->
name|agent
operator|.
name|device
argument_list|,
name|mad_agent_priv
operator|->
name|agent
operator|.
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|port_priv
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|mad_priv
operator|->
name|mad
operator|.
name|mad
argument_list|,
name|smp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ib_mad
argument_list|)
argument_list|)
expr_stmt|;
name|recv_mad_agent
operator|=
name|find_mad_agent
argument_list|(
name|port_priv
argument_list|,
operator|&
name|mad_priv
operator|->
name|mad
operator|.
name|mad
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|port_priv
operator|||
operator|!
name|recv_mad_agent
condition|)
block|{
comment|/* 			 * No receiving agent so drop packet and 			 * generate send completion. 			 */
name|kmem_cache_free
argument_list|(
name|ib_mad_cache
argument_list|,
name|mad_priv
argument_list|)
expr_stmt|;
break|break;
block|}
name|local
operator|->
name|mad_priv
operator|=
name|mad_priv
expr_stmt|;
name|local
operator|->
name|recv_mad_agent
operator|=
name|recv_mad_agent
expr_stmt|;
break|break;
default|default:
name|kmem_cache_free
argument_list|(
name|ib_mad_cache
argument_list|,
name|mad_priv
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|local
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|local
operator|->
name|mad_send_wr
operator|=
name|mad_send_wr
expr_stmt|;
comment|/* Reference MAD agent until send side of local completion handled */
name|atomic_inc
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|refcount
argument_list|)
expr_stmt|;
comment|/* Queue local completion to local list */
name|spin_lock_irqsave
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|local
operator|->
name|completion_list
argument_list|,
operator|&
name|mad_agent_priv
operator|->
name|local_list
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|queue_work
argument_list|(
name|mad_agent_priv
operator|->
name|qp_info
operator|->
name|port_priv
operator|->
name|wq
argument_list|,
operator|&
name|mad_agent_priv
operator|->
name|local_work
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_pad_size
parameter_list|(
name|int
name|hdr_len
parameter_list|,
name|int
name|data_len
parameter_list|)
block|{
name|int
name|seg_size
decl_stmt|,
name|pad
decl_stmt|;
name|seg_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ib_mad
argument_list|)
operator|-
name|hdr_len
expr_stmt|;
if|if
condition|(
name|data_len
operator|&&
name|seg_size
condition|)
block|{
name|pad
operator|=
name|seg_size
operator|-
name|data_len
operator|%
name|seg_size
expr_stmt|;
return|return
name|pad
operator|==
name|seg_size
condition|?
literal|0
else|:
name|pad
return|;
block|}
else|else
return|return
name|seg_size
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_send_rmpp_list
parameter_list|(
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
parameter_list|)
block|{
name|struct
name|ib_rmpp_segment
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|s
argument_list|,
argument|t
argument_list|,
argument|&mad_send_wr->rmpp_list
argument_list|,
argument|list
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|s
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_send_rmpp_list
parameter_list|(
name|struct
name|ib_mad_send_wr_private
modifier|*
name|send_wr
parameter_list|,
name|gfp_t
name|gfp_mask
parameter_list|)
block|{
name|struct
name|ib_mad_send_buf
modifier|*
name|send_buf
init|=
operator|&
name|send_wr
operator|->
name|send_buf
decl_stmt|;
name|struct
name|ib_rmpp_mad
modifier|*
name|rmpp_mad
init|=
name|send_buf
operator|->
name|mad
decl_stmt|;
name|struct
name|ib_rmpp_segment
modifier|*
name|seg
init|=
name|NULL
decl_stmt|;
name|int
name|left
decl_stmt|,
name|seg_size
decl_stmt|,
name|pad
decl_stmt|;
name|send_buf
operator|->
name|seg_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ib_mad
argument_list|)
operator|-
name|send_buf
operator|->
name|hdr_len
expr_stmt|;
name|seg_size
operator|=
name|send_buf
operator|->
name|seg_size
expr_stmt|;
name|pad
operator|=
name|send_wr
operator|->
name|pad
expr_stmt|;
comment|/* Allocate data segments. */
for|for
control|(
name|left
operator|=
name|send_buf
operator|->
name|data_len
operator|+
name|pad
init|;
name|left
operator|>
literal|0
condition|;
name|left
operator|-=
name|seg_size
control|)
block|{
name|seg
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|seg
argument_list|)
operator|+
name|seg_size
argument_list|,
name|gfp_mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|seg
condition|)
block|{
name|printk
argument_list|(
name|KERN_ERR
literal|"alloc_send_rmpp_segs: RMPP mem "
literal|"alloc failed for len %zd, gfp %#x\n"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|seg
argument_list|)
operator|+
name|seg_size
argument_list|,
name|gfp_mask
argument_list|)
expr_stmt|;
name|free_send_rmpp_list
argument_list|(
name|send_wr
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|seg
operator|->
name|num
operator|=
operator|++
name|send_buf
operator|->
name|seg_count
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|seg
operator|->
name|list
argument_list|,
operator|&
name|send_wr
operator|->
name|rmpp_list
argument_list|)
expr_stmt|;
block|}
comment|/* Zero any padding */
if|if
condition|(
name|pad
condition|)
name|memset
argument_list|(
name|seg
operator|->
name|data
operator|+
name|seg_size
operator|-
name|pad
argument_list|,
literal|0
argument_list|,
name|pad
argument_list|)
expr_stmt|;
name|rmpp_mad
operator|->
name|rmpp_hdr
operator|.
name|rmpp_version
operator|=
name|send_wr
operator|->
name|mad_agent_priv
operator|->
name|agent
operator|.
name|rmpp_version
expr_stmt|;
name|rmpp_mad
operator|->
name|rmpp_hdr
operator|.
name|rmpp_type
operator|=
name|IB_MGMT_RMPP_TYPE_DATA
expr_stmt|;
name|ib_set_rmpp_flags
argument_list|(
operator|&
name|rmpp_mad
operator|->
name|rmpp_hdr
argument_list|,
name|IB_MGMT_RMPP_FLAG_ACTIVE
argument_list|)
expr_stmt|;
name|send_wr
operator|->
name|cur_seg
operator|=
name|container_of
argument_list|(
name|send_wr
operator|->
name|rmpp_list
operator|.
name|next
argument_list|,
expr|struct
name|ib_rmpp_segment
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|send_wr
operator|->
name|last_ack_seg
operator|=
name|send_wr
operator|->
name|cur_seg
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|ib_mad_send_buf
modifier|*
name|ib_create_send_mad
parameter_list|(
name|struct
name|ib_mad_agent
modifier|*
name|mad_agent
parameter_list|,
name|u32
name|remote_qpn
parameter_list|,
name|u16
name|pkey_index
parameter_list|,
name|int
name|rmpp_active
parameter_list|,
name|int
name|hdr_len
parameter_list|,
name|int
name|data_len
parameter_list|,
name|gfp_t
name|gfp_mask
parameter_list|)
block|{
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
decl_stmt|;
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
decl_stmt|;
name|int
name|pad
decl_stmt|,
name|message_size
decl_stmt|,
name|ret
decl_stmt|,
name|size
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|mad_agent_priv
operator|=
name|container_of
argument_list|(
name|mad_agent
argument_list|,
expr|struct
name|ib_mad_agent_private
argument_list|,
name|agent
argument_list|)
expr_stmt|;
name|pad
operator|=
name|get_pad_size
argument_list|(
name|hdr_len
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
name|message_size
operator|=
name|hdr_len
operator|+
name|data_len
operator|+
name|pad
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|mad_agent
operator|->
name|rmpp_version
operator|&&
operator|(
name|rmpp_active
operator|||
name|message_size
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ib_mad
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|!
name|rmpp_active
operator|&&
name|message_size
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ib_mad
argument_list|)
operator|)
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|EINVAL
argument_list|)
return|;
name|size
operator|=
name|rmpp_active
condition|?
name|hdr_len
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|ib_mad
argument_list|)
expr_stmt|;
name|buf
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|mad_send_wr
operator|+
name|size
argument_list|,
name|gfp_mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|mad_send_wr
operator|=
name|buf
operator|+
name|size
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|mad_send_wr
operator|->
name|rmpp_list
argument_list|)
expr_stmt|;
name|mad_send_wr
operator|->
name|send_buf
operator|.
name|mad
operator|=
name|buf
expr_stmt|;
name|mad_send_wr
operator|->
name|send_buf
operator|.
name|hdr_len
operator|=
name|hdr_len
expr_stmt|;
name|mad_send_wr
operator|->
name|send_buf
operator|.
name|data_len
operator|=
name|data_len
expr_stmt|;
name|mad_send_wr
operator|->
name|pad
operator|=
name|pad
expr_stmt|;
name|mad_send_wr
operator|->
name|mad_agent_priv
operator|=
name|mad_agent_priv
expr_stmt|;
name|mad_send_wr
operator|->
name|sg_list
index|[
literal|0
index|]
operator|.
name|length
operator|=
name|hdr_len
expr_stmt|;
name|mad_send_wr
operator|->
name|sg_list
index|[
literal|0
index|]
operator|.
name|lkey
operator|=
name|mad_agent
operator|->
name|mr
operator|->
name|lkey
expr_stmt|;
name|mad_send_wr
operator|->
name|sg_list
index|[
literal|1
index|]
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ib_mad
argument_list|)
operator|-
name|hdr_len
expr_stmt|;
name|mad_send_wr
operator|->
name|sg_list
index|[
literal|1
index|]
operator|.
name|lkey
operator|=
name|mad_agent
operator|->
name|mr
operator|->
name|lkey
expr_stmt|;
name|mad_send_wr
operator|->
name|send_wr
operator|.
name|wr_id
operator|=
operator|(
name|unsigned
name|long
operator|)
name|mad_send_wr
expr_stmt|;
name|mad_send_wr
operator|->
name|send_wr
operator|.
name|sg_list
operator|=
name|mad_send_wr
operator|->
name|sg_list
expr_stmt|;
name|mad_send_wr
operator|->
name|send_wr
operator|.
name|num_sge
operator|=
literal|2
expr_stmt|;
name|mad_send_wr
operator|->
name|send_wr
operator|.
name|opcode
operator|=
name|IB_WR_SEND
expr_stmt|;
name|mad_send_wr
operator|->
name|send_wr
operator|.
name|send_flags
operator|=
name|IB_SEND_SIGNALED
expr_stmt|;
name|mad_send_wr
operator|->
name|send_wr
operator|.
name|wr
operator|.
name|ud
operator|.
name|remote_qpn
operator|=
name|remote_qpn
expr_stmt|;
name|mad_send_wr
operator|->
name|send_wr
operator|.
name|wr
operator|.
name|ud
operator|.
name|remote_qkey
operator|=
name|IB_QP_SET_QKEY
expr_stmt|;
name|mad_send_wr
operator|->
name|send_wr
operator|.
name|wr
operator|.
name|ud
operator|.
name|pkey_index
operator|=
name|pkey_index
expr_stmt|;
if|if
condition|(
name|rmpp_active
condition|)
block|{
name|ret
operator|=
name|alloc_send_rmpp_list
argument_list|(
name|mad_send_wr
argument_list|,
name|gfp_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|kfree
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
name|ret
argument_list|)
return|;
block|}
block|}
name|mad_send_wr
operator|->
name|send_buf
operator|.
name|mad_agent
operator|=
name|mad_agent
expr_stmt|;
name|atomic_inc
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|refcount
argument_list|)
expr_stmt|;
return|return
operator|&
name|mad_send_wr
operator|->
name|send_buf
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_create_send_mad
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|ib_get_mad_data_offset
parameter_list|(
name|u8
name|mgmt_class
parameter_list|)
block|{
if|if
condition|(
name|mgmt_class
operator|==
name|IB_MGMT_CLASS_SUBN_ADM
condition|)
return|return
name|IB_MGMT_SA_HDR
return|;
elseif|else
if|if
condition|(
operator|(
name|mgmt_class
operator|==
name|IB_MGMT_CLASS_DEVICE_MGMT
operator|)
operator|||
operator|(
name|mgmt_class
operator|==
name|IB_MGMT_CLASS_DEVICE_ADM
operator|)
operator|||
operator|(
name|mgmt_class
operator|==
name|IB_MGMT_CLASS_BIS
operator|)
condition|)
return|return
name|IB_MGMT_DEVICE_HDR
return|;
elseif|else
if|if
condition|(
operator|(
name|mgmt_class
operator|>=
name|IB_MGMT_CLASS_VENDOR_RANGE2_START
operator|)
operator|&&
operator|(
name|mgmt_class
operator|<=
name|IB_MGMT_CLASS_VENDOR_RANGE2_END
operator|)
condition|)
return|return
name|IB_MGMT_VENDOR_HDR
return|;
else|else
return|return
name|IB_MGMT_MAD_HDR
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_get_mad_data_offset
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|ib_is_mad_class_rmpp
parameter_list|(
name|u8
name|mgmt_class
parameter_list|)
block|{
if|if
condition|(
operator|(
name|mgmt_class
operator|==
name|IB_MGMT_CLASS_SUBN_ADM
operator|)
operator|||
operator|(
name|mgmt_class
operator|==
name|IB_MGMT_CLASS_DEVICE_MGMT
operator|)
operator|||
operator|(
name|mgmt_class
operator|==
name|IB_MGMT_CLASS_DEVICE_ADM
operator|)
operator|||
operator|(
name|mgmt_class
operator|==
name|IB_MGMT_CLASS_BIS
operator|)
operator|||
operator|(
operator|(
name|mgmt_class
operator|>=
name|IB_MGMT_CLASS_VENDOR_RANGE2_START
operator|)
operator|&&
operator|(
name|mgmt_class
operator|<=
name|IB_MGMT_CLASS_VENDOR_RANGE2_END
operator|)
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_is_mad_class_rmpp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
modifier|*
name|ib_get_rmpp_segment
parameter_list|(
name|struct
name|ib_mad_send_buf
modifier|*
name|send_buf
parameter_list|,
name|int
name|seg_num
parameter_list|)
block|{
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
decl_stmt|;
name|struct
name|list_head
modifier|*
name|list
decl_stmt|;
name|mad_send_wr
operator|=
name|container_of
argument_list|(
name|send_buf
argument_list|,
expr|struct
name|ib_mad_send_wr_private
argument_list|,
name|send_buf
argument_list|)
expr_stmt|;
name|list
operator|=
operator|&
name|mad_send_wr
operator|->
name|cur_seg
operator|->
name|list
expr_stmt|;
if|if
condition|(
name|mad_send_wr
operator|->
name|cur_seg
operator|->
name|num
operator|<
name|seg_num
condition|)
block|{
name|list_for_each_entry
argument_list|(
argument|mad_send_wr->cur_seg
argument_list|,
argument|list
argument_list|,
argument|list
argument_list|)
if|if
condition|(
name|mad_send_wr
operator|->
name|cur_seg
operator|->
name|num
operator|==
name|seg_num
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|mad_send_wr
operator|->
name|cur_seg
operator|->
name|num
operator|>
name|seg_num
condition|)
block|{
name|list_for_each_entry_reverse
argument_list|(
argument|mad_send_wr->cur_seg
argument_list|,
argument|list
argument_list|,
argument|list
argument_list|)
if|if
condition|(
name|mad_send_wr
operator|->
name|cur_seg
operator|->
name|num
operator|==
name|seg_num
condition|)
break|break;
block|}
return|return
name|mad_send_wr
operator|->
name|cur_seg
operator|->
name|data
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_get_rmpp_segment
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|ib_get_payload
parameter_list|(
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
parameter_list|)
block|{
if|if
condition|(
name|mad_send_wr
operator|->
name|send_buf
operator|.
name|seg_count
condition|)
return|return
name|ib_get_rmpp_segment
argument_list|(
operator|&
name|mad_send_wr
operator|->
name|send_buf
argument_list|,
name|mad_send_wr
operator|->
name|seg_num
argument_list|)
return|;
else|else
return|return
name|mad_send_wr
operator|->
name|send_buf
operator|.
name|mad
operator|+
name|mad_send_wr
operator|->
name|send_buf
operator|.
name|hdr_len
return|;
block|}
end_function

begin_function
name|void
name|ib_free_send_mad
parameter_list|(
name|struct
name|ib_mad_send_buf
modifier|*
name|send_buf
parameter_list|)
block|{
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
decl_stmt|;
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
decl_stmt|;
name|mad_agent_priv
operator|=
name|container_of
argument_list|(
name|send_buf
operator|->
name|mad_agent
argument_list|,
expr|struct
name|ib_mad_agent_private
argument_list|,
name|agent
argument_list|)
expr_stmt|;
name|mad_send_wr
operator|=
name|container_of
argument_list|(
name|send_buf
argument_list|,
expr|struct
name|ib_mad_send_wr_private
argument_list|,
name|send_buf
argument_list|)
expr_stmt|;
name|free_send_rmpp_list
argument_list|(
name|mad_send_wr
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|send_buf
operator|->
name|mad
argument_list|)
expr_stmt|;
name|deref_mad_agent
argument_list|(
name|mad_agent_priv
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_free_send_mad
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|ib_send_mad
parameter_list|(
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
parameter_list|)
block|{
name|struct
name|ib_mad_qp_info
modifier|*
name|qp_info
decl_stmt|;
name|struct
name|list_head
modifier|*
name|list
decl_stmt|;
name|struct
name|ib_send_wr
modifier|*
name|bad_send_wr
decl_stmt|;
name|struct
name|ib_mad_agent
modifier|*
name|mad_agent
decl_stmt|;
name|struct
name|ib_sge
modifier|*
name|sge
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* Set WR ID to find mad_send_wr upon completion */
name|qp_info
operator|=
name|mad_send_wr
operator|->
name|mad_agent_priv
operator|->
name|qp_info
expr_stmt|;
name|mad_send_wr
operator|->
name|send_wr
operator|.
name|wr_id
operator|=
operator|(
name|unsigned
name|long
operator|)
operator|&
name|mad_send_wr
operator|->
name|mad_list
expr_stmt|;
name|mad_send_wr
operator|->
name|mad_list
operator|.
name|mad_queue
operator|=
operator|&
name|qp_info
operator|->
name|send_queue
expr_stmt|;
name|mad_agent
operator|=
name|mad_send_wr
operator|->
name|send_buf
operator|.
name|mad_agent
expr_stmt|;
name|sge
operator|=
name|mad_send_wr
operator|->
name|sg_list
expr_stmt|;
name|sge
index|[
literal|0
index|]
operator|.
name|addr
operator|=
name|ib_dma_map_single
argument_list|(
name|mad_agent
operator|->
name|device
argument_list|,
name|mad_send_wr
operator|->
name|send_buf
operator|.
name|mad
argument_list|,
name|sge
index|[
literal|0
index|]
operator|.
name|length
argument_list|,
name|DMA_TO_DEVICE
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ib_dma_mapping_error
argument_list|(
name|mad_agent
operator|->
name|device
argument_list|,
name|sge
index|[
literal|0
index|]
operator|.
name|addr
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|sge
index|[
literal|1
index|]
operator|.
name|addr
operator|=
name|ib_dma_map_single
argument_list|(
name|mad_agent
operator|->
name|device
argument_list|,
name|ib_get_payload
argument_list|(
name|mad_send_wr
argument_list|)
argument_list|,
name|sge
index|[
literal|1
index|]
operator|.
name|length
argument_list|,
name|DMA_TO_DEVICE
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ib_dma_mapping_error
argument_list|(
name|mad_agent
operator|->
name|device
argument_list|,
name|sge
index|[
literal|1
index|]
operator|.
name|addr
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|dma1_err
goto|;
block|}
name|mad_send_wr
operator|->
name|header_mapping
operator|=
name|sge
index|[
literal|0
index|]
operator|.
name|addr
expr_stmt|;
name|mad_send_wr
operator|->
name|payload_mapping
operator|=
name|sge
index|[
literal|1
index|]
operator|.
name|addr
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|qp_info
operator|->
name|send_queue
operator|.
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp_info
operator|->
name|send_queue
operator|.
name|count
operator|<
name|qp_info
operator|->
name|send_queue
operator|.
name|max_active
condition|)
block|{
name|ret
operator|=
name|ib_post_send
argument_list|(
name|mad_agent
operator|->
name|qp
argument_list|,
operator|&
name|mad_send_wr
operator|->
name|send_wr
argument_list|,
operator|&
name|bad_send_wr
argument_list|)
expr_stmt|;
name|list
operator|=
operator|&
name|qp_info
operator|->
name|send_queue
operator|.
name|list
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
literal|0
expr_stmt|;
name|list
operator|=
operator|&
name|qp_info
operator|->
name|overflow_list
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|qp_info
operator|->
name|send_queue
operator|.
name|count
operator|++
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|mad_send_wr
operator|->
name|mad_list
operator|.
name|list
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|qp_info
operator|->
name|send_queue
operator|.
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
return|return
literal|0
return|;
name|ib_dma_unmap_single
argument_list|(
name|mad_agent
operator|->
name|device
argument_list|,
name|mad_send_wr
operator|->
name|header_mapping
argument_list|,
name|sge
index|[
literal|1
index|]
operator|.
name|length
argument_list|,
name|DMA_TO_DEVICE
argument_list|)
expr_stmt|;
name|dma1_err
label|:
name|ib_dma_unmap_single
argument_list|(
name|mad_agent
operator|->
name|device
argument_list|,
name|mad_send_wr
operator|->
name|payload_mapping
argument_list|,
name|sge
index|[
literal|0
index|]
operator|.
name|length
argument_list|,
name|DMA_TO_DEVICE
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Send SA MAD that passed congestion control  */
end_comment

begin_function
specifier|static
name|int
name|send_sa_cc_mad
parameter_list|(
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
parameter_list|,
name|u32
name|timeout_ms
parameter_list|,
name|u32
name|retries_left
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
decl_stmt|;
name|mad_agent_priv
operator|=
name|mad_send_wr
operator|->
name|mad_agent_priv
expr_stmt|;
name|mad_send_wr
operator|->
name|timeout
operator|=
name|msecs_to_jiffies
argument_list|(
name|timeout_ms
argument_list|)
expr_stmt|;
name|mad_send_wr
operator|->
name|retries_left
operator|=
name|retries_left
expr_stmt|;
name|mad_send_wr
operator|->
name|refcount
operator|=
literal|1
operator|+
operator|(
name|mad_send_wr
operator|->
name|timeout
operator|>
literal|0
operator|)
expr_stmt|;
comment|/* Reference MAD agent until send completes */
name|atomic_inc
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|refcount
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|mad_send_wr
operator|->
name|agent_list
argument_list|,
operator|&
name|mad_agent_priv
operator|->
name|send_list
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ib_send_mad
argument_list|(
name|mad_send_wr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/* Fail send request */
name|spin_lock_irqsave
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|mad_send_wr
operator|->
name|agent_list
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|refcount
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * ib_post_send_mad - Posts MAD(s) to the send queue of the QP associated  *  with the registered client  */
end_comment

begin_function
name|int
name|ib_post_send_mad
parameter_list|(
name|struct
name|ib_mad_send_buf
modifier|*
name|send_buf
parameter_list|,
name|struct
name|ib_mad_send_buf
modifier|*
modifier|*
name|bad_send_buf
parameter_list|)
block|{
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
decl_stmt|;
name|struct
name|ib_mad_send_buf
modifier|*
name|next_send_buf
decl_stmt|;
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|ret
init|=
operator|-
name|EINVAL
decl_stmt|;
comment|/* Walk list of send WRs and post each on send list */
for|for
control|(
init|;
name|send_buf
condition|;
name|send_buf
operator|=
name|next_send_buf
control|)
block|{
name|mad_send_wr
operator|=
name|container_of
argument_list|(
name|send_buf
argument_list|,
expr|struct
name|ib_mad_send_wr_private
argument_list|,
name|send_buf
argument_list|)
expr_stmt|;
name|mad_agent_priv
operator|=
name|mad_send_wr
operator|->
name|mad_agent_priv
expr_stmt|;
if|if
condition|(
operator|!
name|send_buf
operator|->
name|mad_agent
operator|->
name|send_handler
operator|||
operator|(
name|send_buf
operator|->
name|timeout_ms
operator|&&
operator|!
name|send_buf
operator|->
name|mad_agent
operator|->
name|recv_handler
operator|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|!
name|ib_is_mad_class_rmpp
argument_list|(
operator|(
operator|(
expr|struct
name|ib_mad_hdr
operator|*
operator|)
name|send_buf
operator|->
name|mad
operator|)
operator|->
name|mgmt_class
argument_list|)
condition|)
block|{
if|if
condition|(
name|mad_agent_priv
operator|->
name|agent
operator|.
name|rmpp_version
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
comment|/* 		 * Save pointer to next work request to post in case the 		 * current one completes, and the user modifies the work 		 * request associated with the completion 		 */
name|next_send_buf
operator|=
name|send_buf
operator|->
name|next
expr_stmt|;
name|mad_send_wr
operator|->
name|send_wr
operator|.
name|wr
operator|.
name|ud
operator|.
name|ah
operator|=
name|send_buf
operator|->
name|ah
expr_stmt|;
if|if
condition|(
operator|(
operator|(
expr|struct
name|ib_mad_hdr
operator|*
operator|)
name|send_buf
operator|->
name|mad
operator|)
operator|->
name|mgmt_class
operator|==
name|IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE
condition|)
block|{
name|ret
operator|=
name|handle_outgoing_dr_smp
argument_list|(
name|mad_agent_priv
argument_list|,
name|mad_send_wr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
comment|/* error */
goto|goto
name|error
goto|;
elseif|else
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
comment|/* locally consumed */
continue|continue;
block|}
name|mad_send_wr
operator|->
name|tid
operator|=
operator|(
operator|(
expr|struct
name|ib_mad_hdr
operator|*
operator|)
name|send_buf
operator|->
name|mad
operator|)
operator|->
name|tid
expr_stmt|;
comment|/* Timeout will be updated after send completes */
name|mad_send_wr
operator|->
name|timeout
operator|=
name|msecs_to_jiffies
argument_list|(
name|send_buf
operator|->
name|timeout_ms
argument_list|)
expr_stmt|;
name|mad_send_wr
operator|->
name|max_retries
operator|=
name|send_buf
operator|->
name|retries
expr_stmt|;
name|mad_send_wr
operator|->
name|retries_left
operator|=
name|send_buf
operator|->
name|retries
expr_stmt|;
name|send_buf
operator|->
name|retries
operator|=
literal|0
expr_stmt|;
comment|/* Reference for work request to QP + response */
name|mad_send_wr
operator|->
name|refcount
operator|=
literal|1
operator|+
operator|(
name|mad_send_wr
operator|->
name|timeout
operator|>
literal|0
operator|)
expr_stmt|;
name|mad_send_wr
operator|->
name|status
operator|=
name|IB_WC_SUCCESS
expr_stmt|;
if|if
condition|(
name|is_sa_cc_mad
argument_list|(
name|mad_send_wr
argument_list|)
condition|)
block|{
name|mad_send_wr
operator|->
name|is_sa_cc_mad
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
name|sa_cc_mad_send
argument_list|(
name|mad_send_wr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
block|}
else|else
block|{
comment|/* Reference MAD agent until send completes */
name|atomic_inc
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|refcount
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|mad_send_wr
operator|->
name|agent_list
argument_list|,
operator|&
name|mad_agent_priv
operator|->
name|send_list
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|mad_agent_priv
operator|->
name|agent
operator|.
name|rmpp_version
condition|)
block|{
name|ret
operator|=
name|ib_send_rmpp_mad
argument_list|(
name|mad_send_wr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
operator|&&
name|ret
operator|!=
name|IB_RMPP_RESULT_CONSUMED
condition|)
name|ret
operator|=
name|ib_send_mad
argument_list|(
name|mad_send_wr
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|ib_send_mad
argument_list|(
name|mad_send_wr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/* Fail send request */
name|spin_lock_irqsave
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|mad_send_wr
operator|->
name|agent_list
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|refcount
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
block|}
block|}
return|return
literal|0
return|;
name|error
label|:
if|if
condition|(
name|bad_send_buf
condition|)
operator|*
name|bad_send_buf
operator|=
name|send_buf
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_post_send_mad
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * ib_free_recv_mad - Returns data buffers used to receive  *  a MAD to the access layer  */
end_comment

begin_function
name|void
name|ib_free_recv_mad
parameter_list|(
name|struct
name|ib_mad_recv_wc
modifier|*
name|mad_recv_wc
parameter_list|)
block|{
name|struct
name|ib_mad_recv_buf
modifier|*
name|mad_recv_buf
decl_stmt|,
modifier|*
name|temp_recv_buf
decl_stmt|;
name|struct
name|ib_mad_private_header
modifier|*
name|mad_priv_hdr
decl_stmt|;
name|struct
name|ib_mad_private
modifier|*
name|priv
decl_stmt|;
name|struct
name|list_head
name|free_list
decl_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|free_list
argument_list|)
expr_stmt|;
name|list_splice_init
argument_list|(
operator|&
name|mad_recv_wc
operator|->
name|rmpp_list
argument_list|,
operator|&
name|free_list
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|mad_recv_buf
argument_list|,
argument|temp_recv_buf
argument_list|,
argument|&free_list
argument_list|,
argument|list
argument_list|)
block|{
name|mad_recv_wc
operator|=
name|container_of
argument_list|(
name|mad_recv_buf
argument_list|,
expr|struct
name|ib_mad_recv_wc
argument_list|,
name|recv_buf
argument_list|)
expr_stmt|;
name|mad_priv_hdr
operator|=
name|container_of
argument_list|(
name|mad_recv_wc
argument_list|,
expr|struct
name|ib_mad_private_header
argument_list|,
name|recv_wc
argument_list|)
expr_stmt|;
name|priv
operator|=
name|container_of
argument_list|(
name|mad_priv_hdr
argument_list|,
expr|struct
name|ib_mad_private
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|ib_mad_cache
argument_list|,
name|priv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_free_recv_mad
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|struct
name|ib_mad_agent
modifier|*
name|ib_redirect_mad_qp
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|u8
name|rmpp_version
parameter_list|,
name|ib_mad_send_handler
name|send_handler
parameter_list|,
name|ib_mad_recv_handler
name|recv_handler
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
return|return
name|ERR_PTR
argument_list|(
operator|-
name|EINVAL
argument_list|)
return|;
comment|/* XXX: for now */
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_redirect_mad_qp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|ib_process_mad_wc
parameter_list|(
name|struct
name|ib_mad_agent
modifier|*
name|mad_agent
parameter_list|,
name|struct
name|ib_wc
modifier|*
name|wc
parameter_list|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"ib_process_mad_wc() not implemented yet\n"
argument_list|)
empty_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_process_mad_wc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|method_in_use
parameter_list|(
name|struct
name|ib_mad_mgmt_method_table
modifier|*
modifier|*
name|method
parameter_list|,
name|struct
name|ib_mad_reg_req
modifier|*
name|mad_reg_req
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|for_each_set_bit
argument_list|(
argument|i
argument_list|,
argument|mad_reg_req->method_mask
argument_list|,
argument|IB_MGMT_MAX_METHODS
argument_list|)
block|{
if|if
condition|(
operator|(
operator|*
name|method
operator|)
operator|->
name|agent
index|[
name|i
index|]
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"Method %d already in use\n"
argument_list|,
argument|i
argument_list|)
empty_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|allocate_method_table
parameter_list|(
name|struct
name|ib_mad_mgmt_method_table
modifier|*
modifier|*
name|method
parameter_list|)
block|{
comment|/* Allocate management method table */
operator|*
name|method
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
operator|*
name|method
argument_list|,
name|GFP_ATOMIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|method
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"No memory for "
literal|"ib_mad_mgmt_method_table\n"
argument_list|)
empty_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if there are any methods still in use  */
end_comment

begin_function
specifier|static
name|int
name|check_method_table
parameter_list|(
name|struct
name|ib_mad_mgmt_method_table
modifier|*
name|method
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IB_MGMT_MAX_METHODS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|method
operator|->
name|agent
index|[
name|i
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Check to see if there are any method tables for this class still in use  */
end_comment

begin_function
specifier|static
name|int
name|check_class_table
parameter_list|(
name|struct
name|ib_mad_mgmt_class_table
modifier|*
name|class
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MGMT_CLASS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|class
operator|->
name|method_table
index|[
name|i
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_vendor_class
parameter_list|(
name|struct
name|ib_mad_mgmt_vendor_class
modifier|*
name|vendor_class
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MGMT_OUI
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vendor_class
operator|->
name|method_table
index|[
name|i
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find_vendor_oui
parameter_list|(
name|struct
name|ib_mad_mgmt_vendor_class
modifier|*
name|vendor_class
parameter_list|,
name|char
modifier|*
name|oui
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MGMT_OUI
condition|;
name|i
operator|++
control|)
comment|/* Is there matching OUI for this vendor class ? */
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|vendor_class
operator|->
name|oui
index|[
name|i
index|]
argument_list|,
name|oui
argument_list|,
literal|3
argument_list|)
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_vendor_table
parameter_list|(
name|struct
name|ib_mad_mgmt_vendor_class_table
modifier|*
name|vendor
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MGMT_VENDOR_RANGE2
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vendor
operator|->
name|vendor_class
index|[
name|i
index|]
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_methods_mad_agent
parameter_list|(
name|struct
name|ib_mad_mgmt_method_table
modifier|*
name|method
parameter_list|,
name|struct
name|ib_mad_agent_private
modifier|*
name|agent
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* Remove any methods for this mad agent */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IB_MGMT_MAX_METHODS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|method
operator|->
name|agent
index|[
name|i
index|]
operator|==
name|agent
condition|)
block|{
name|method
operator|->
name|agent
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|add_nonoui_reg_req
parameter_list|(
name|struct
name|ib_mad_reg_req
modifier|*
name|mad_reg_req
parameter_list|,
name|struct
name|ib_mad_agent_private
modifier|*
name|agent_priv
parameter_list|,
name|u8
name|mgmt_class
parameter_list|)
block|{
name|struct
name|ib_mad_port_private
modifier|*
name|port_priv
decl_stmt|;
name|struct
name|ib_mad_mgmt_class_table
modifier|*
modifier|*
name|class
decl_stmt|;
name|struct
name|ib_mad_mgmt_method_table
modifier|*
modifier|*
name|method
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
name|port_priv
operator|=
name|agent_priv
operator|->
name|qp_info
operator|->
name|port_priv
expr_stmt|;
name|class
operator|=
operator|&
name|port_priv
operator|->
name|version
index|[
name|mad_reg_req
operator|->
name|mgmt_class_version
index|]
operator|.
name|class
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|class
condition|)
block|{
comment|/* Allocate management class table for "new" class version */
operator|*
name|class
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
operator|*
name|class
argument_list|,
name|GFP_ATOMIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|class
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"No memory for "
literal|"ib_mad_mgmt_class_table\n"
argument_list|)
empty_stmt|;
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
comment|/* Allocate method table for this management class */
name|method
operator|=
operator|&
operator|(
operator|*
name|class
operator|)
operator|->
name|method_table
index|[
name|mgmt_class
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|allocate_method_table
argument_list|(
name|method
argument_list|)
operator|)
condition|)
goto|goto
name|error2
goto|;
block|}
else|else
block|{
name|method
operator|=
operator|&
operator|(
operator|*
name|class
operator|)
operator|->
name|method_table
index|[
name|mgmt_class
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|method
condition|)
block|{
comment|/* Allocate method table for this management class */
if|if
condition|(
operator|(
name|ret
operator|=
name|allocate_method_table
argument_list|(
name|method
argument_list|)
operator|)
condition|)
goto|goto
name|error1
goto|;
block|}
block|}
comment|/* Now, make sure methods are not already in use */
if|if
condition|(
name|method_in_use
argument_list|(
name|method
argument_list|,
name|mad_reg_req
argument_list|)
condition|)
goto|goto
name|error3
goto|;
comment|/* Finally, add in methods being registered */
name|for_each_set_bit
argument_list|(
name|i
argument_list|,
name|mad_reg_req
operator|->
name|method_mask
argument_list|,
name|IB_MGMT_MAX_METHODS
argument_list|)
argument_list|(
operator|*
name|method
argument_list|)
operator|->
name|agent
index|[
name|i
index|]
operator|=
name|agent_priv
expr_stmt|;
return|return
literal|0
return|;
name|error3
label|:
comment|/* Remove any methods for this mad agent */
name|remove_methods_mad_agent
argument_list|(
operator|*
name|method
argument_list|,
name|agent_priv
argument_list|)
expr_stmt|;
comment|/* Now, check to see if there are any methods in use */
if|if
condition|(
operator|!
name|check_method_table
argument_list|(
operator|*
name|method
argument_list|)
condition|)
block|{
comment|/* If not, release management method table */
name|kfree
argument_list|(
operator|*
name|method
argument_list|)
expr_stmt|;
operator|*
name|method
operator|=
name|NULL
expr_stmt|;
block|}
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|error1
goto|;
name|error2
label|:
name|kfree
argument_list|(
operator|*
name|class
argument_list|)
expr_stmt|;
operator|*
name|class
operator|=
name|NULL
expr_stmt|;
name|error1
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_oui_reg_req
parameter_list|(
name|struct
name|ib_mad_reg_req
modifier|*
name|mad_reg_req
parameter_list|,
name|struct
name|ib_mad_agent_private
modifier|*
name|agent_priv
parameter_list|)
block|{
name|struct
name|ib_mad_port_private
modifier|*
name|port_priv
decl_stmt|;
name|struct
name|ib_mad_mgmt_vendor_class_table
modifier|*
modifier|*
name|vendor_table
decl_stmt|;
name|struct
name|ib_mad_mgmt_vendor_class_table
modifier|*
name|vendor
init|=
name|NULL
decl_stmt|;
name|struct
name|ib_mad_mgmt_vendor_class
modifier|*
name|vendor_class
init|=
name|NULL
decl_stmt|;
name|struct
name|ib_mad_mgmt_method_table
modifier|*
modifier|*
name|method
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
init|=
operator|-
name|ENOMEM
decl_stmt|;
name|u8
name|vclass
decl_stmt|;
comment|/* "New" vendor (with OUI) class */
name|vclass
operator|=
name|vendor_class_index
argument_list|(
name|mad_reg_req
operator|->
name|mgmt_class
argument_list|)
expr_stmt|;
name|port_priv
operator|=
name|agent_priv
operator|->
name|qp_info
operator|->
name|port_priv
expr_stmt|;
name|vendor_table
operator|=
operator|&
name|port_priv
operator|->
name|version
index|[
name|mad_reg_req
operator|->
name|mgmt_class_version
index|]
operator|.
name|vendor
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|vendor_table
condition|)
block|{
comment|/* Allocate mgmt vendor class table for "new" class version */
name|vendor
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|vendor
argument_list|,
name|GFP_ATOMIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vendor
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"No memory for "
literal|"ib_mad_mgmt_vendor_class_table\n"
argument_list|)
empty_stmt|;
goto|goto
name|error1
goto|;
block|}
operator|*
name|vendor_table
operator|=
name|vendor
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
operator|*
name|vendor_table
operator|)
operator|->
name|vendor_class
index|[
name|vclass
index|]
condition|)
block|{
comment|/* Allocate table for this management vendor class */
name|vendor_class
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|vendor_class
argument_list|,
name|GFP_ATOMIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vendor_class
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"No memory for "
literal|"ib_mad_mgmt_vendor_class\n"
argument_list|)
empty_stmt|;
goto|goto
name|error2
goto|;
block|}
operator|(
operator|*
name|vendor_table
operator|)
operator|->
name|vendor_class
index|[
name|vclass
index|]
operator|=
name|vendor_class
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MGMT_OUI
condition|;
name|i
operator|++
control|)
block|{
comment|/* Is there matching OUI for this vendor class ? */
if|if
condition|(
operator|!
name|memcmp
argument_list|(
operator|(
operator|*
name|vendor_table
operator|)
operator|->
name|vendor_class
index|[
name|vclass
index|]
operator|->
name|oui
index|[
name|i
index|]
argument_list|,
name|mad_reg_req
operator|->
name|oui
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|method
operator|=
operator|&
operator|(
operator|*
name|vendor_table
operator|)
operator|->
name|vendor_class
index|[
name|vclass
index|]
operator|->
name|method_table
index|[
name|i
index|]
expr_stmt|;
name|BUG_ON
argument_list|(
operator|!
operator|*
name|method
argument_list|)
expr_stmt|;
goto|goto
name|check_in_use
goto|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_MGMT_OUI
condition|;
name|i
operator|++
control|)
block|{
comment|/* OUI slot available ? */
if|if
condition|(
operator|!
name|is_vendor_oui
argument_list|(
operator|(
operator|*
name|vendor_table
operator|)
operator|->
name|vendor_class
index|[
name|vclass
index|]
operator|->
name|oui
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|method
operator|=
operator|&
operator|(
operator|*
name|vendor_table
operator|)
operator|->
name|vendor_class
index|[
name|vclass
index|]
operator|->
name|method_table
index|[
name|i
index|]
expr_stmt|;
name|BUG_ON
argument_list|(
operator|*
name|method
argument_list|)
expr_stmt|;
comment|/* Allocate method table for this OUI */
if|if
condition|(
operator|(
name|ret
operator|=
name|allocate_method_table
argument_list|(
name|method
argument_list|)
operator|)
condition|)
goto|goto
name|error3
goto|;
name|memcpy
argument_list|(
operator|(
operator|*
name|vendor_table
operator|)
operator|->
name|vendor_class
index|[
name|vclass
index|]
operator|->
name|oui
index|[
name|i
index|]
argument_list|,
name|mad_reg_req
operator|->
name|oui
argument_list|,
literal|3
argument_list|)
expr_stmt|;
goto|goto
name|check_in_use
goto|;
block|}
block|}
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"All OUI slots in use\n"
argument_list|)
empty_stmt|;
goto|goto
name|error3
goto|;
name|check_in_use
label|:
comment|/* Now, make sure methods are not already in use */
if|if
condition|(
name|method_in_use
argument_list|(
name|method
argument_list|,
name|mad_reg_req
argument_list|)
condition|)
goto|goto
name|error4
goto|;
comment|/* Finally, add in methods being registered */
name|for_each_set_bit
argument_list|(
name|i
argument_list|,
name|mad_reg_req
operator|->
name|method_mask
argument_list|,
name|IB_MGMT_MAX_METHODS
argument_list|)
argument_list|(
operator|*
name|method
argument_list|)
operator|->
name|agent
index|[
name|i
index|]
operator|=
name|agent_priv
expr_stmt|;
return|return
literal|0
return|;
name|error4
label|:
comment|/* Remove any methods for this mad agent */
name|remove_methods_mad_agent
argument_list|(
operator|*
name|method
argument_list|,
name|agent_priv
argument_list|)
expr_stmt|;
comment|/* Now, check to see if there are any methods in use */
if|if
condition|(
operator|!
name|check_method_table
argument_list|(
operator|*
name|method
argument_list|)
condition|)
block|{
comment|/* If not, release management method table */
name|kfree
argument_list|(
operator|*
name|method
argument_list|)
expr_stmt|;
operator|*
name|method
operator|=
name|NULL
expr_stmt|;
block|}
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
name|error3
label|:
if|if
condition|(
name|vendor_class
condition|)
block|{
operator|(
operator|*
name|vendor_table
operator|)
operator|->
name|vendor_class
index|[
name|vclass
index|]
operator|=
name|NULL
expr_stmt|;
name|kfree
argument_list|(
name|vendor_class
argument_list|)
expr_stmt|;
block|}
name|error2
label|:
if|if
condition|(
name|vendor
condition|)
block|{
operator|*
name|vendor_table
operator|=
name|NULL
expr_stmt|;
name|kfree
argument_list|(
name|vendor
argument_list|)
expr_stmt|;
block|}
name|error1
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_mad_reg_req
parameter_list|(
name|struct
name|ib_mad_agent_private
modifier|*
name|agent_priv
parameter_list|)
block|{
name|struct
name|ib_mad_port_private
modifier|*
name|port_priv
decl_stmt|;
name|struct
name|ib_mad_mgmt_class_table
modifier|*
name|class
decl_stmt|;
name|struct
name|ib_mad_mgmt_method_table
modifier|*
name|method
decl_stmt|;
name|struct
name|ib_mad_mgmt_vendor_class_table
modifier|*
name|vendor
decl_stmt|;
name|struct
name|ib_mad_mgmt_vendor_class
modifier|*
name|vendor_class
decl_stmt|;
name|int
name|index
decl_stmt|;
name|u8
name|mgmt_class
decl_stmt|;
comment|/* 	 * Was MAD registration request supplied 	 * with original registration ? 	 */
if|if
condition|(
operator|!
name|agent_priv
operator|->
name|reg_req
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|port_priv
operator|=
name|agent_priv
operator|->
name|qp_info
operator|->
name|port_priv
expr_stmt|;
name|mgmt_class
operator|=
name|convert_mgmt_class
argument_list|(
name|agent_priv
operator|->
name|reg_req
operator|->
name|mgmt_class
argument_list|)
expr_stmt|;
name|class
operator|=
name|port_priv
operator|->
name|version
index|[
name|agent_priv
operator|->
name|reg_req
operator|->
name|mgmt_class_version
index|]
operator|.
name|class
expr_stmt|;
if|if
condition|(
operator|!
name|class
condition|)
goto|goto
name|vendor_check
goto|;
name|method
operator|=
name|class
operator|->
name|method_table
index|[
name|mgmt_class
index|]
expr_stmt|;
if|if
condition|(
name|method
condition|)
block|{
comment|/* Remove any methods for this mad agent */
name|remove_methods_mad_agent
argument_list|(
name|method
argument_list|,
name|agent_priv
argument_list|)
expr_stmt|;
comment|/* Now, check to see if there are any methods still in use */
if|if
condition|(
operator|!
name|check_method_table
argument_list|(
name|method
argument_list|)
condition|)
block|{
comment|/* If not, release management method table */
name|kfree
argument_list|(
name|method
argument_list|)
expr_stmt|;
name|class
operator|->
name|method_table
index|[
name|mgmt_class
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Any management classes left ? */
if|if
condition|(
operator|!
name|check_class_table
argument_list|(
name|class
argument_list|)
condition|)
block|{
comment|/* If not, release management class table */
name|kfree
argument_list|(
name|class
argument_list|)
expr_stmt|;
name|port_priv
operator|->
name|version
index|[
name|agent_priv
operator|->
name|reg_req
operator|->
name|mgmt_class_version
index|]
operator|.
name|class
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|vendor_check
label|:
if|if
condition|(
operator|!
name|is_vendor_class
argument_list|(
name|mgmt_class
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* normalize mgmt_class to vendor range 2 */
name|mgmt_class
operator|=
name|vendor_class_index
argument_list|(
name|agent_priv
operator|->
name|reg_req
operator|->
name|mgmt_class
argument_list|)
expr_stmt|;
name|vendor
operator|=
name|port_priv
operator|->
name|version
index|[
name|agent_priv
operator|->
name|reg_req
operator|->
name|mgmt_class_version
index|]
operator|.
name|vendor
expr_stmt|;
if|if
condition|(
operator|!
name|vendor
condition|)
goto|goto
name|out
goto|;
name|vendor_class
operator|=
name|vendor
operator|->
name|vendor_class
index|[
name|mgmt_class
index|]
expr_stmt|;
if|if
condition|(
name|vendor_class
condition|)
block|{
name|index
operator|=
name|find_vendor_oui
argument_list|(
name|vendor_class
argument_list|,
name|agent_priv
operator|->
name|reg_req
operator|->
name|oui
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
literal|0
condition|)
goto|goto
name|out
goto|;
name|method
operator|=
name|vendor_class
operator|->
name|method_table
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|method
condition|)
block|{
comment|/* Remove any methods for this mad agent */
name|remove_methods_mad_agent
argument_list|(
name|method
argument_list|,
name|agent_priv
argument_list|)
expr_stmt|;
comment|/* 			 * Now, check to see if there are 			 * any methods still in use 			 */
if|if
condition|(
operator|!
name|check_method_table
argument_list|(
name|method
argument_list|)
condition|)
block|{
comment|/* If not, release management method table */
name|kfree
argument_list|(
name|method
argument_list|)
expr_stmt|;
name|vendor_class
operator|->
name|method_table
index|[
name|index
index|]
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
name|vendor_class
operator|->
name|oui
index|[
name|index
index|]
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* Any OUIs left ? */
if|if
condition|(
operator|!
name|check_vendor_class
argument_list|(
name|vendor_class
argument_list|)
condition|)
block|{
comment|/* If not, release vendor class table */
name|kfree
argument_list|(
name|vendor_class
argument_list|)
expr_stmt|;
name|vendor
operator|->
name|vendor_class
index|[
name|mgmt_class
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Any other vendor classes left ? */
if|if
condition|(
operator|!
name|check_vendor_table
argument_list|(
name|vendor
argument_list|)
condition|)
block|{
name|kfree
argument_list|(
name|vendor
argument_list|)
expr_stmt|;
name|port_priv
operator|->
name|version
index|[
name|agent_priv
operator|->
name|reg_req
operator|->
name|mgmt_class_version
index|]
operator|.
name|vendor
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|out
label|:
return|return;
block|}
end_function

begin_function
specifier|static
name|struct
name|ib_mad_agent_private
modifier|*
name|find_mad_agent
parameter_list|(
name|struct
name|ib_mad_port_private
modifier|*
name|port_priv
parameter_list|,
name|struct
name|ib_mad
modifier|*
name|mad
parameter_list|)
block|{
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|port_priv
operator|->
name|reg_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_response_mad
argument_list|(
name|mad
argument_list|)
condition|)
block|{
name|u32
name|hi_tid
decl_stmt|;
name|struct
name|ib_mad_agent_private
modifier|*
name|entry
decl_stmt|;
comment|/* 		 * Routing is based on high 32 bits of transaction ID 		 * of MAD. 		 */
name|hi_tid
operator|=
name|be64_to_cpu
argument_list|(
name|mad
operator|->
name|mad_hdr
operator|.
name|tid
argument_list|)
operator|>>
literal|32
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|entry
argument_list|,
argument|&port_priv->agent_list
argument_list|,
argument|agent_list
argument_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|agent
operator|.
name|hi_tid
operator|==
name|hi_tid
condition|)
block|{
name|mad_agent
operator|=
name|entry
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|struct
name|ib_mad_mgmt_class_table
modifier|*
name|class
decl_stmt|;
name|struct
name|ib_mad_mgmt_method_table
modifier|*
name|method
decl_stmt|;
name|struct
name|ib_mad_mgmt_vendor_class_table
modifier|*
name|vendor
decl_stmt|;
name|struct
name|ib_mad_mgmt_vendor_class
modifier|*
name|vendor_class
decl_stmt|;
name|struct
name|ib_vendor_mad
modifier|*
name|vendor_mad
decl_stmt|;
name|int
name|index
decl_stmt|;
comment|/* 		 * Routing is based on version, class, and method 		 * For "newer" vendor MADs, also based on OUI 		 */
if|if
condition|(
name|mad
operator|->
name|mad_hdr
operator|.
name|class_version
operator|>=
name|MAX_MGMT_VERSION
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|is_vendor_class
argument_list|(
name|mad
operator|->
name|mad_hdr
operator|.
name|mgmt_class
argument_list|)
condition|)
block|{
name|class
operator|=
name|port_priv
operator|->
name|version
index|[
name|mad
operator|->
name|mad_hdr
operator|.
name|class_version
index|]
operator|.
name|class
expr_stmt|;
if|if
condition|(
operator|!
name|class
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|convert_mgmt_class
argument_list|(
name|mad
operator|->
name|mad_hdr
operator|.
name|mgmt_class
argument_list|)
operator|>=
name|IB_MGMT_MAX_METHODS
condition|)
goto|goto
name|out
goto|;
name|method
operator|=
name|class
operator|->
name|method_table
index|[
name|convert_mgmt_class
argument_list|(
name|mad
operator|->
name|mad_hdr
operator|.
name|mgmt_class
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|method
condition|)
name|mad_agent
operator|=
name|method
operator|->
name|agent
index|[
name|mad
operator|->
name|mad_hdr
operator|.
name|method
operator|&
operator|~
name|IB_MGMT_METHOD_RESP
index|]
expr_stmt|;
block|}
else|else
block|{
name|vendor
operator|=
name|port_priv
operator|->
name|version
index|[
name|mad
operator|->
name|mad_hdr
operator|.
name|class_version
index|]
operator|.
name|vendor
expr_stmt|;
if|if
condition|(
operator|!
name|vendor
condition|)
goto|goto
name|out
goto|;
name|vendor_class
operator|=
name|vendor
operator|->
name|vendor_class
index|[
name|vendor_class_index
argument_list|(
name|mad
operator|->
name|mad_hdr
operator|.
name|mgmt_class
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|vendor_class
condition|)
goto|goto
name|out
goto|;
comment|/* Find matching OUI */
name|vendor_mad
operator|=
operator|(
expr|struct
name|ib_vendor_mad
operator|*
operator|)
name|mad
expr_stmt|;
name|index
operator|=
name|find_vendor_oui
argument_list|(
name|vendor_class
argument_list|,
name|vendor_mad
operator|->
name|oui
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
operator|-
literal|1
condition|)
goto|goto
name|out
goto|;
name|method
operator|=
name|vendor_class
operator|->
name|method_table
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|method
condition|)
block|{
name|mad_agent
operator|=
name|method
operator|->
name|agent
index|[
name|mad
operator|->
name|mad_hdr
operator|.
name|method
operator|&
operator|~
name|IB_MGMT_METHOD_RESP
index|]
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|mad_agent
condition|)
block|{
if|if
condition|(
name|mad_agent
operator|->
name|agent
operator|.
name|recv_handler
condition|)
name|atomic_inc
argument_list|(
operator|&
name|mad_agent
operator|->
name|refcount
argument_list|)
expr_stmt|;
else|else
block|{
name|printk
argument_list|(
argument|KERN_NOTICE PFX
literal|"No receive handler for client "
literal|"%p on port %d\n"
argument_list|,
argument|&mad_agent->agent
argument_list|,
argument|port_priv->port_num
argument_list|)
empty_stmt|;
name|mad_agent
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|out
label|:
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|port_priv
operator|->
name|reg_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|mad_agent
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|validate_mad
parameter_list|(
name|struct
name|ib_mad
modifier|*
name|mad
parameter_list|,
name|u32
name|qp_num
parameter_list|)
block|{
name|int
name|valid
init|=
literal|0
decl_stmt|;
comment|/* Make sure MAD base version is understood */
if|if
condition|(
name|mad
operator|->
name|mad_hdr
operator|.
name|base_version
operator|!=
name|IB_MGMT_BASE_VERSION
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"MAD received with unsupported base "
literal|"version %d\n"
argument_list|,
argument|mad->mad_hdr.base_version
argument_list|)
empty_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Filter SMI packets sent to other than QP0 */
if|if
condition|(
operator|(
name|mad
operator|->
name|mad_hdr
operator|.
name|mgmt_class
operator|==
name|IB_MGMT_CLASS_SUBN_LID_ROUTED
operator|)
operator|||
operator|(
name|mad
operator|->
name|mad_hdr
operator|.
name|mgmt_class
operator|==
name|IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE
operator|)
condition|)
block|{
if|if
condition|(
name|qp_num
operator|==
literal|0
condition|)
name|valid
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Filter GSI packets sent to QP0 */
if|if
condition|(
name|qp_num
operator|!=
literal|0
condition|)
name|valid
operator|=
literal|1
expr_stmt|;
block|}
name|out
label|:
return|return
name|valid
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_data_mad
parameter_list|(
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
parameter_list|,
name|struct
name|ib_mad_hdr
modifier|*
name|mad_hdr
parameter_list|)
block|{
name|struct
name|ib_rmpp_mad
modifier|*
name|rmpp_mad
decl_stmt|;
name|rmpp_mad
operator|=
operator|(
expr|struct
name|ib_rmpp_mad
operator|*
operator|)
name|mad_hdr
expr_stmt|;
return|return
operator|!
name|mad_agent_priv
operator|->
name|agent
operator|.
name|rmpp_version
operator|||
operator|!
operator|(
name|ib_get_rmpp_flags
argument_list|(
operator|&
name|rmpp_mad
operator|->
name|rmpp_hdr
argument_list|)
operator|&
name|IB_MGMT_RMPP_FLAG_ACTIVE
operator|)
operator|||
operator|(
name|rmpp_mad
operator|->
name|rmpp_hdr
operator|.
name|rmpp_type
operator|==
name|IB_MGMT_RMPP_TYPE_DATA
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|rcv_has_same_class
parameter_list|(
name|struct
name|ib_mad_send_wr_private
modifier|*
name|wr
parameter_list|,
name|struct
name|ib_mad_recv_wc
modifier|*
name|rwc
parameter_list|)
block|{
return|return
operator|(
operator|(
expr|struct
name|ib_mad
operator|*
operator|)
operator|(
name|wr
operator|->
name|send_buf
operator|.
name|mad
operator|)
operator|)
operator|->
name|mad_hdr
operator|.
name|mgmt_class
operator|==
name|rwc
operator|->
name|recv_buf
operator|.
name|mad
operator|->
name|mad_hdr
operator|.
name|mgmt_class
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|rcv_has_same_gid
parameter_list|(
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
parameter_list|,
name|struct
name|ib_mad_send_wr_private
modifier|*
name|wr
parameter_list|,
name|struct
name|ib_mad_recv_wc
modifier|*
name|rwc
parameter_list|)
block|{
name|struct
name|ib_ah_attr
name|attr
decl_stmt|;
name|u8
name|send_resp
decl_stmt|,
name|rcv_resp
decl_stmt|;
name|union
name|ib_gid
name|sgid
decl_stmt|;
name|struct
name|ib_device
modifier|*
name|device
init|=
name|mad_agent_priv
operator|->
name|agent
operator|.
name|device
decl_stmt|;
name|u8
name|port_num
init|=
name|mad_agent_priv
operator|->
name|agent
operator|.
name|port_num
decl_stmt|;
name|u8
name|lmc
decl_stmt|;
name|send_resp
operator|=
name|ib_response_mad
argument_list|(
operator|(
expr|struct
name|ib_mad
operator|*
operator|)
name|wr
operator|->
name|send_buf
operator|.
name|mad
argument_list|)
expr_stmt|;
name|rcv_resp
operator|=
name|ib_response_mad
argument_list|(
name|rwc
operator|->
name|recv_buf
operator|.
name|mad
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_resp
operator|==
name|rcv_resp
condition|)
comment|/* both requests, or both responses. GIDs different */
return|return
literal|0
return|;
if|if
condition|(
name|ib_query_ah
argument_list|(
name|wr
operator|->
name|send_buf
operator|.
name|ah
argument_list|,
operator|&
name|attr
argument_list|)
condition|)
comment|/* Assume not equal, to avoid false positives. */
return|return
literal|0
return|;
if|if
condition|(
operator|!
operator|!
operator|(
name|attr
operator|.
name|ah_flags
operator|&
name|IB_AH_GRH
operator|)
operator|!=
operator|!
operator|!
operator|(
name|rwc
operator|->
name|wc
operator|->
name|wc_flags
operator|&
name|IB_WC_GRH
operator|)
condition|)
comment|/* one has GID, other does not.  Assume different */
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|send_resp
operator|&&
name|rcv_resp
condition|)
block|{
comment|/* is request/response. */
if|if
condition|(
operator|!
operator|(
name|attr
operator|.
name|ah_flags
operator|&
name|IB_AH_GRH
operator|)
condition|)
block|{
if|if
condition|(
name|ib_get_cached_lmc
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|,
operator|&
name|lmc
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
operator|!
name|lmc
operator|||
operator|!
operator|(
operator|(
name|attr
operator|.
name|src_path_bits
operator|^
name|rwc
operator|->
name|wc
operator|->
name|dlid_path_bits
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|lmc
operator|)
operator|-
literal|1
operator|)
operator|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|ib_get_cached_gid
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|,
name|attr
operator|.
name|grh
operator|.
name|sgid_index
argument_list|,
operator|&
name|sgid
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
operator|!
name|memcmp
argument_list|(
name|sgid
operator|.
name|raw
argument_list|,
name|rwc
operator|->
name|recv_buf
operator|.
name|grh
operator|->
name|dgid
operator|.
name|raw
argument_list|,
literal|16
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|attr
operator|.
name|ah_flags
operator|&
name|IB_AH_GRH
operator|)
condition|)
return|return
name|attr
operator|.
name|dlid
operator|==
name|rwc
operator|->
name|wc
operator|->
name|slid
return|;
else|else
return|return
operator|!
name|memcmp
argument_list|(
name|attr
operator|.
name|grh
operator|.
name|dgid
operator|.
name|raw
argument_list|,
name|rwc
operator|->
name|recv_buf
operator|.
name|grh
operator|->
name|sgid
operator|.
name|raw
argument_list|,
literal|16
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|is_direct
parameter_list|(
name|u8
name|class
parameter_list|)
block|{
return|return
operator|(
name|class
operator|==
name|IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|ib_mad_send_wr_private
modifier|*
name|ib_find_send_mad
parameter_list|(
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
parameter_list|,
name|struct
name|ib_mad_recv_wc
modifier|*
name|wc
parameter_list|)
block|{
name|struct
name|ib_mad_send_wr_private
modifier|*
name|wr
decl_stmt|;
name|struct
name|ib_mad
modifier|*
name|mad
decl_stmt|;
name|mad
operator|=
operator|(
expr|struct
name|ib_mad
operator|*
operator|)
name|wc
operator|->
name|recv_buf
operator|.
name|mad
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|wr
argument_list|,
argument|&mad_agent_priv->wait_list
argument_list|,
argument|agent_list
argument_list|)
block|{
if|if
condition|(
operator|(
name|wr
operator|->
name|tid
operator|==
name|mad
operator|->
name|mad_hdr
operator|.
name|tid
operator|)
operator|&&
name|rcv_has_same_class
argument_list|(
name|wr
argument_list|,
name|wc
argument_list|)
operator|&&
comment|/* 		     * Don't check GID for direct routed MADs. 		     * These might have permissive LIDs. 		     */
operator|(
name|is_direct
argument_list|(
name|wc
operator|->
name|recv_buf
operator|.
name|mad
operator|->
name|mad_hdr
operator|.
name|mgmt_class
argument_list|)
operator|||
name|rcv_has_same_gid
argument_list|(
name|mad_agent_priv
argument_list|,
name|wr
argument_list|,
name|wc
argument_list|)
operator|)
condition|)
return|return
operator|(
name|wr
operator|->
name|status
operator|==
name|IB_WC_SUCCESS
operator|)
condition|?
name|wr
else|:
name|NULL
return|;
block|}
comment|/* 	 * It's possible to receive the response before we've 	 * been notified that the send has completed 	 */
name|list_for_each_entry
argument_list|(
argument|wr
argument_list|,
argument|&mad_agent_priv->send_list
argument_list|,
argument|agent_list
argument_list|)
block|{
if|if
condition|(
name|is_data_mad
argument_list|(
name|mad_agent_priv
argument_list|,
name|wr
operator|->
name|send_buf
operator|.
name|mad
argument_list|)
operator|&&
name|wr
operator|->
name|tid
operator|==
name|mad
operator|->
name|mad_hdr
operator|.
name|tid
operator|&&
name|wr
operator|->
name|timeout
operator|&&
name|rcv_has_same_class
argument_list|(
name|wr
argument_list|,
name|wc
argument_list|)
operator|&&
comment|/* 		     * Don't check GID for direct routed MADs. 		     * These might have permissive LIDs. 		     */
operator|(
name|is_direct
argument_list|(
name|wc
operator|->
name|recv_buf
operator|.
name|mad
operator|->
name|mad_hdr
operator|.
name|mgmt_class
argument_list|)
operator|||
name|rcv_has_same_gid
argument_list|(
name|mad_agent_priv
argument_list|,
name|wr
argument_list|,
name|wc
argument_list|)
operator|)
condition|)
comment|/* Verify request has not been canceled */
return|return
operator|(
name|wr
operator|->
name|status
operator|==
name|IB_WC_SUCCESS
operator|)
condition|?
name|wr
else|:
name|NULL
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|ib_mark_mad_done
parameter_list|(
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
parameter_list|)
block|{
name|mad_send_wr
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mad_send_wr
operator|->
name|refcount
operator|==
literal|1
condition|)
name|list_move_tail
argument_list|(
operator|&
name|mad_send_wr
operator|->
name|agent_list
argument_list|,
operator|&
name|mad_send_wr
operator|->
name|mad_agent_priv
operator|->
name|done_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ib_mad_complete_recv
parameter_list|(
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
parameter_list|,
name|struct
name|ib_mad_recv_wc
modifier|*
name|mad_recv_wc
parameter_list|)
block|{
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
decl_stmt|;
name|struct
name|ib_mad_send_wc
name|mad_send_wc
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|mad_recv_wc
operator|->
name|rmpp_list
argument_list|)
expr_stmt|;
name|list_add
argument_list|(
operator|&
name|mad_recv_wc
operator|->
name|recv_buf
operator|.
name|list
argument_list|,
operator|&
name|mad_recv_wc
operator|->
name|rmpp_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|mad_agent_priv
operator|->
name|agent
operator|.
name|rmpp_version
condition|)
block|{
name|mad_recv_wc
operator|=
name|ib_process_rmpp_recv_wc
argument_list|(
name|mad_agent_priv
argument_list|,
name|mad_recv_wc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mad_recv_wc
condition|)
block|{
name|deref_mad_agent
argument_list|(
name|mad_agent_priv
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Complete corresponding request */
if|if
condition|(
name|ib_response_mad
argument_list|(
name|mad_recv_wc
operator|->
name|recv_buf
operator|.
name|mad
argument_list|)
condition|)
block|{
name|spin_lock_irqsave
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|mad_send_wr
operator|=
name|ib_find_send_mad
argument_list|(
name|mad_agent_priv
argument_list|,
name|mad_recv_wc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mad_send_wr
condition|)
block|{
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ib_free_recv_mad
argument_list|(
name|mad_recv_wc
argument_list|)
expr_stmt|;
name|deref_mad_agent
argument_list|(
name|mad_agent_priv
argument_list|)
expr_stmt|;
return|return;
block|}
name|ib_mark_mad_done
argument_list|(
name|mad_send_wr
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Defined behavior is to complete response before request */
name|mad_recv_wc
operator|->
name|wc
operator|->
name|wr_id
operator|=
operator|(
name|unsigned
name|long
operator|)
operator|&
name|mad_send_wr
operator|->
name|send_buf
expr_stmt|;
name|mad_agent_priv
operator|->
name|agent
operator|.
name|recv_handler
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|agent
argument_list|,
name|mad_recv_wc
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|refcount
argument_list|)
expr_stmt|;
name|mad_send_wc
operator|.
name|status
operator|=
name|IB_WC_SUCCESS
expr_stmt|;
name|mad_send_wc
operator|.
name|vendor_err
operator|=
literal|0
expr_stmt|;
name|mad_send_wc
operator|.
name|send_buf
operator|=
operator|&
name|mad_send_wr
operator|->
name|send_buf
expr_stmt|;
name|ib_mad_complete_send_wr
argument_list|(
name|mad_send_wr
argument_list|,
operator|&
name|mad_send_wc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mad_agent_priv
operator|->
name|agent
operator|.
name|recv_handler
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|agent
argument_list|,
name|mad_recv_wc
argument_list|)
expr_stmt|;
name|deref_mad_agent
argument_list|(
name|mad_agent_priv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|generate_unmatched_resp
parameter_list|(
name|struct
name|ib_mad_private
modifier|*
name|recv
parameter_list|,
name|struct
name|ib_mad_private
modifier|*
name|response
parameter_list|)
block|{
if|if
condition|(
name|recv
operator|->
name|mad
operator|.
name|mad
operator|.
name|mad_hdr
operator|.
name|method
operator|==
name|IB_MGMT_METHOD_GET
operator|||
name|recv
operator|->
name|mad
operator|.
name|mad
operator|.
name|mad_hdr
operator|.
name|method
operator|==
name|IB_MGMT_METHOD_SET
condition|)
block|{
name|memcpy
argument_list|(
name|response
argument_list|,
name|recv
argument_list|,
sizeof|sizeof
expr|*
name|response
argument_list|)
expr_stmt|;
name|response
operator|->
name|header
operator|.
name|recv_wc
operator|.
name|wc
operator|=
operator|&
name|response
operator|->
name|header
operator|.
name|wc
expr_stmt|;
name|response
operator|->
name|header
operator|.
name|recv_wc
operator|.
name|recv_buf
operator|.
name|mad
operator|=
operator|&
name|response
operator|->
name|mad
operator|.
name|mad
expr_stmt|;
name|response
operator|->
name|header
operator|.
name|recv_wc
operator|.
name|recv_buf
operator|.
name|grh
operator|=
operator|&
name|response
operator|->
name|grh
expr_stmt|;
name|response
operator|->
name|mad
operator|.
name|mad
operator|.
name|mad_hdr
operator|.
name|method
operator|=
name|IB_MGMT_METHOD_GET_RESP
expr_stmt|;
name|response
operator|->
name|mad
operator|.
name|mad
operator|.
name|mad_hdr
operator|.
name|status
operator|=
name|cpu_to_be16
argument_list|(
name|IB_MGMT_MAD_STATUS_UNSUPPORTED_METHOD_ATTRIB
argument_list|)
expr_stmt|;
if|if
condition|(
name|recv
operator|->
name|mad
operator|.
name|mad
operator|.
name|mad_hdr
operator|.
name|mgmt_class
operator|==
name|IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE
condition|)
name|response
operator|->
name|mad
operator|.
name|mad
operator|.
name|mad_hdr
operator|.
name|status
operator||=
name|IB_SMP_DIRECTION
expr_stmt|;
return|return
name|true
return|;
block|}
else|else
block|{
return|return
name|false
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ib_mad_recv_done_handler
parameter_list|(
name|struct
name|ib_mad_port_private
modifier|*
name|port_priv
parameter_list|,
name|struct
name|ib_wc
modifier|*
name|wc
parameter_list|)
block|{
name|struct
name|ib_mad_qp_info
modifier|*
name|qp_info
decl_stmt|;
name|struct
name|ib_mad_private_header
modifier|*
name|mad_priv_hdr
decl_stmt|;
name|struct
name|ib_mad_private
modifier|*
name|recv
decl_stmt|,
modifier|*
name|response
init|=
name|NULL
decl_stmt|;
name|struct
name|ib_mad_list_head
modifier|*
name|mad_list
decl_stmt|;
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent
decl_stmt|;
name|int
name|port_num
decl_stmt|;
name|int
name|ret
init|=
name|IB_MAD_RESULT_SUCCESS
decl_stmt|;
name|mad_list
operator|=
operator|(
expr|struct
name|ib_mad_list_head
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|wc
operator|->
name|wr_id
expr_stmt|;
name|qp_info
operator|=
name|mad_list
operator|->
name|mad_queue
operator|->
name|qp_info
expr_stmt|;
name|dequeue_mad
argument_list|(
name|mad_list
argument_list|)
expr_stmt|;
name|mad_priv_hdr
operator|=
name|container_of
argument_list|(
name|mad_list
argument_list|,
expr|struct
name|ib_mad_private_header
argument_list|,
name|mad_list
argument_list|)
expr_stmt|;
name|recv
operator|=
name|container_of
argument_list|(
name|mad_priv_hdr
argument_list|,
expr|struct
name|ib_mad_private
argument_list|,
name|header
argument_list|)
expr_stmt|;
name|ib_dma_unmap_single
argument_list|(
name|port_priv
operator|->
name|device
argument_list|,
name|recv
operator|->
name|header
operator|.
name|mapping
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ib_mad_private
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ib_mad_private_header
argument_list|)
argument_list|,
name|DMA_FROM_DEVICE
argument_list|)
expr_stmt|;
comment|/* Setup MAD receive work completion from "normal" work completion */
name|recv
operator|->
name|header
operator|.
name|wc
operator|=
operator|*
name|wc
expr_stmt|;
name|recv
operator|->
name|header
operator|.
name|recv_wc
operator|.
name|wc
operator|=
operator|&
name|recv
operator|->
name|header
operator|.
name|wc
expr_stmt|;
name|recv
operator|->
name|header
operator|.
name|recv_wc
operator|.
name|mad_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ib_mad
argument_list|)
expr_stmt|;
name|recv
operator|->
name|header
operator|.
name|recv_wc
operator|.
name|recv_buf
operator|.
name|mad
operator|=
operator|&
name|recv
operator|->
name|mad
operator|.
name|mad
expr_stmt|;
name|recv
operator|->
name|header
operator|.
name|recv_wc
operator|.
name|recv_buf
operator|.
name|grh
operator|=
operator|&
name|recv
operator|->
name|grh
expr_stmt|;
if|if
condition|(
name|atomic_read
argument_list|(
operator|&
name|qp_info
operator|->
name|snoop_count
argument_list|)
condition|)
name|snoop_recv
argument_list|(
name|qp_info
argument_list|,
operator|&
name|recv
operator|->
name|header
operator|.
name|recv_wc
argument_list|,
name|IB_MAD_SNOOP_RECVS
argument_list|)
expr_stmt|;
comment|/* Validate MAD */
if|if
condition|(
operator|!
name|validate_mad
argument_list|(
operator|&
name|recv
operator|->
name|mad
operator|.
name|mad
argument_list|,
name|qp_info
operator|->
name|qp
operator|->
name|qp_num
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|response
operator|=
name|kmem_cache_alloc
argument_list|(
name|ib_mad_cache
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|response
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"ib_mad_recv_done_handler no memory "
literal|"for response buffer\n"
argument_list|)
empty_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|port_priv
operator|->
name|device
operator|->
name|node_type
operator|==
name|RDMA_NODE_IB_SWITCH
condition|)
name|port_num
operator|=
name|wc
operator|->
name|port_num
expr_stmt|;
else|else
name|port_num
operator|=
name|port_priv
operator|->
name|port_num
expr_stmt|;
if|if
condition|(
name|recv
operator|->
name|mad
operator|.
name|mad
operator|.
name|mad_hdr
operator|.
name|mgmt_class
operator|==
name|IB_MGMT_CLASS_SUBN_DIRECTED_ROUTE
condition|)
block|{
name|enum
name|smi_forward_action
name|retsmi
decl_stmt|;
if|if
condition|(
name|smi_handle_dr_smp_recv
argument_list|(
operator|&
name|recv
operator|->
name|mad
operator|.
name|smp
argument_list|,
name|port_priv
operator|->
name|device
operator|->
name|node_type
argument_list|,
name|port_num
argument_list|,
name|port_priv
operator|->
name|device
operator|->
name|phys_port_cnt
argument_list|)
operator|==
name|IB_SMI_DISCARD
condition|)
goto|goto
name|out
goto|;
name|retsmi
operator|=
name|smi_check_forward_dr_smp
argument_list|(
operator|&
name|recv
operator|->
name|mad
operator|.
name|smp
argument_list|)
expr_stmt|;
if|if
condition|(
name|retsmi
operator|==
name|IB_SMI_LOCAL
condition|)
goto|goto
name|local
goto|;
if|if
condition|(
name|retsmi
operator|==
name|IB_SMI_SEND
condition|)
block|{
comment|/* don't forward */
if|if
condition|(
name|smi_handle_dr_smp_send
argument_list|(
operator|&
name|recv
operator|->
name|mad
operator|.
name|smp
argument_list|,
name|port_priv
operator|->
name|device
operator|->
name|node_type
argument_list|,
name|port_num
argument_list|)
operator|==
name|IB_SMI_DISCARD
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|smi_check_local_smp
argument_list|(
operator|&
name|recv
operator|->
name|mad
operator|.
name|smp
argument_list|,
name|port_priv
operator|->
name|device
argument_list|)
operator|==
name|IB_SMI_DISCARD
condition|)
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|port_priv
operator|->
name|device
operator|->
name|node_type
operator|==
name|RDMA_NODE_IB_SWITCH
condition|)
block|{
comment|/* forward case for switches */
name|memcpy
argument_list|(
name|response
argument_list|,
name|recv
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|response
argument_list|)
argument_list|)
expr_stmt|;
name|response
operator|->
name|header
operator|.
name|recv_wc
operator|.
name|wc
operator|=
operator|&
name|response
operator|->
name|header
operator|.
name|wc
expr_stmt|;
name|response
operator|->
name|header
operator|.
name|recv_wc
operator|.
name|recv_buf
operator|.
name|mad
operator|=
operator|&
name|response
operator|->
name|mad
operator|.
name|mad
expr_stmt|;
name|response
operator|->
name|header
operator|.
name|recv_wc
operator|.
name|recv_buf
operator|.
name|grh
operator|=
operator|&
name|response
operator|->
name|grh
expr_stmt|;
name|agent_send_response
argument_list|(
operator|&
name|response
operator|->
name|mad
operator|.
name|mad
argument_list|,
operator|&
name|response
operator|->
name|grh
argument_list|,
name|wc
argument_list|,
name|port_priv
operator|->
name|device
argument_list|,
name|smi_get_fwd_port
argument_list|(
operator|&
name|recv
operator|->
name|mad
operator|.
name|smp
argument_list|)
argument_list|,
name|qp_info
operator|->
name|qp
operator|->
name|qp_num
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|local
label|:
comment|/* Give driver "right of first refusal" on incoming MAD */
if|if
condition|(
name|port_priv
operator|->
name|device
operator|->
name|process_mad
condition|)
block|{
name|ret
operator|=
name|port_priv
operator|->
name|device
operator|->
name|process_mad
argument_list|(
name|port_priv
operator|->
name|device
argument_list|,
literal|0
argument_list|,
name|port_priv
operator|->
name|port_num
argument_list|,
name|wc
argument_list|,
operator|&
name|recv
operator|->
name|grh
argument_list|,
operator|&
name|recv
operator|->
name|mad
operator|.
name|mad
argument_list|,
operator|&
name|response
operator|->
name|mad
operator|.
name|mad
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&
name|IB_MAD_RESULT_SUCCESS
condition|)
block|{
if|if
condition|(
name|ret
operator|&
name|IB_MAD_RESULT_CONSUMED
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|ret
operator|&
name|IB_MAD_RESULT_REPLY
condition|)
block|{
name|agent_send_response
argument_list|(
operator|&
name|response
operator|->
name|mad
operator|.
name|mad
argument_list|,
operator|&
name|recv
operator|->
name|grh
argument_list|,
name|wc
argument_list|,
name|port_priv
operator|->
name|device
argument_list|,
name|port_num
argument_list|,
name|qp_info
operator|->
name|qp
operator|->
name|qp_num
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
name|mad_agent
operator|=
name|find_mad_agent
argument_list|(
name|port_priv
argument_list|,
operator|&
name|recv
operator|->
name|mad
operator|.
name|mad
argument_list|)
expr_stmt|;
if|if
condition|(
name|mad_agent
condition|)
block|{
name|ib_mad_complete_recv
argument_list|(
name|mad_agent
argument_list|,
operator|&
name|recv
operator|->
name|header
operator|.
name|recv_wc
argument_list|)
expr_stmt|;
comment|/* 		 * recv is freed up in error cases in ib_mad_complete_recv 		 * or via recv_handler in ib_mad_complete_recv() 		 */
name|recv
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ret
operator|&
name|IB_MAD_RESULT_SUCCESS
operator|)
operator|&&
name|generate_unmatched_resp
argument_list|(
name|recv
argument_list|,
name|response
argument_list|)
condition|)
block|{
name|agent_send_response
argument_list|(
operator|&
name|response
operator|->
name|mad
operator|.
name|mad
argument_list|,
operator|&
name|recv
operator|->
name|grh
argument_list|,
name|wc
argument_list|,
name|port_priv
operator|->
name|device
argument_list|,
name|port_num
argument_list|,
name|qp_info
operator|->
name|qp
operator|->
name|qp_num
argument_list|)
expr_stmt|;
block|}
name|out
label|:
comment|/* Post another receive request for this QP */
if|if
condition|(
name|response
condition|)
block|{
name|ib_mad_post_receive_mads
argument_list|(
name|qp_info
argument_list|,
name|response
argument_list|)
expr_stmt|;
if|if
condition|(
name|recv
condition|)
name|kmem_cache_free
argument_list|(
name|ib_mad_cache
argument_list|,
name|recv
argument_list|)
expr_stmt|;
block|}
else|else
name|ib_mad_post_receive_mads
argument_list|(
name|qp_info
argument_list|,
name|recv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|adjust_timeout
parameter_list|(
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
parameter_list|)
block|{
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
decl_stmt|;
name|unsigned
name|long
name|delay
decl_stmt|;
if|if
condition|(
name|list_empty
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|wait_list
argument_list|)
condition|)
block|{
name|cancel_delayed_work
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|timed_work
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mad_send_wr
operator|=
name|list_entry
argument_list|(
name|mad_agent_priv
operator|->
name|wait_list
operator|.
name|next
argument_list|,
expr|struct
name|ib_mad_send_wr_private
argument_list|,
name|agent_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_after
argument_list|(
name|mad_agent_priv
operator|->
name|timeout
argument_list|,
name|mad_send_wr
operator|->
name|timeout
argument_list|)
condition|)
block|{
name|mad_agent_priv
operator|->
name|timeout
operator|=
name|mad_send_wr
operator|->
name|timeout
expr_stmt|;
name|delay
operator|=
name|mad_send_wr
operator|->
name|timeout
operator|-
name|jiffies
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|delay
operator|<=
literal|0
condition|)
name|delay
operator|=
literal|1
expr_stmt|;
name|mod_delayed_work
argument_list|(
name|mad_agent_priv
operator|->
name|qp_info
operator|->
name|port_priv
operator|->
name|wq
argument_list|,
operator|&
name|mad_agent_priv
operator|->
name|timed_work
argument_list|,
name|delay
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|wait_for_response
parameter_list|(
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
parameter_list|)
block|{
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
decl_stmt|;
name|struct
name|ib_mad_send_wr_private
modifier|*
name|temp_mad_send_wr
decl_stmt|;
name|struct
name|list_head
modifier|*
name|list_item
decl_stmt|;
name|unsigned
name|long
name|delay
decl_stmt|;
name|mad_agent_priv
operator|=
name|mad_send_wr
operator|->
name|mad_agent_priv
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|mad_send_wr
operator|->
name|agent_list
argument_list|)
expr_stmt|;
name|delay
operator|=
name|mad_send_wr
operator|->
name|timeout
expr_stmt|;
name|mad_send_wr
operator|->
name|timeout
operator|+=
name|jiffies
expr_stmt|;
if|if
condition|(
name|delay
condition|)
block|{
name|list_for_each_prev
argument_list|(
argument|list_item
argument_list|,
argument|&mad_agent_priv->wait_list
argument_list|)
block|{
name|temp_mad_send_wr
operator|=
name|list_entry
argument_list|(
name|list_item
argument_list|,
expr|struct
name|ib_mad_send_wr_private
argument_list|,
name|agent_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_after
argument_list|(
name|mad_send_wr
operator|->
name|timeout
argument_list|,
name|temp_mad_send_wr
operator|->
name|timeout
argument_list|)
condition|)
break|break;
block|}
block|}
else|else
name|list_item
operator|=
operator|&
name|mad_agent_priv
operator|->
name|wait_list
expr_stmt|;
name|list_add
argument_list|(
operator|&
name|mad_send_wr
operator|->
name|agent_list
argument_list|,
name|list_item
argument_list|)
expr_stmt|;
comment|/* Reschedule a work item if we have a shorter timeout */
if|if
condition|(
name|mad_agent_priv
operator|->
name|wait_list
operator|.
name|next
operator|==
operator|&
name|mad_send_wr
operator|->
name|agent_list
condition|)
name|mod_delayed_work
argument_list|(
name|mad_agent_priv
operator|->
name|qp_info
operator|->
name|port_priv
operator|->
name|wq
argument_list|,
operator|&
name|mad_agent_priv
operator|->
name|timed_work
argument_list|,
name|delay
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ib_reset_mad_timeout
parameter_list|(
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
parameter_list|,
name|int
name|timeout_ms
parameter_list|)
block|{
name|mad_send_wr
operator|->
name|timeout
operator|=
name|msecs_to_jiffies
argument_list|(
name|timeout_ms
argument_list|)
expr_stmt|;
name|wait_for_response
argument_list|(
name|mad_send_wr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a send work completion  */
end_comment

begin_function
name|void
name|ib_mad_complete_send_wr
parameter_list|(
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
parameter_list|,
name|struct
name|ib_mad_send_wc
modifier|*
name|mad_send_wc
parameter_list|)
block|{
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|mad_agent_priv
operator|=
name|mad_send_wr
operator|->
name|mad_agent_priv
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|mad_agent_priv
operator|->
name|agent
operator|.
name|rmpp_version
condition|)
block|{
name|ret
operator|=
name|ib_process_rmpp_send_wc
argument_list|(
name|mad_send_wr
argument_list|,
name|mad_send_wc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|IB_RMPP_RESULT_CONSUMED
condition|)
goto|goto
name|done
goto|;
block|}
else|else
name|ret
operator|=
name|IB_RMPP_RESULT_UNHANDLED
expr_stmt|;
if|if
condition|(
name|mad_send_wc
operator|->
name|status
operator|!=
name|IB_WC_SUCCESS
operator|&&
name|mad_send_wr
operator|->
name|status
operator|==
name|IB_WC_SUCCESS
condition|)
block|{
name|mad_send_wr
operator|->
name|status
operator|=
name|mad_send_wc
operator|->
name|status
expr_stmt|;
name|mad_send_wr
operator|->
name|refcount
operator|-=
operator|(
name|mad_send_wr
operator|->
name|timeout
operator|>
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|--
name|mad_send_wr
operator|->
name|refcount
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mad_send_wr
operator|->
name|refcount
operator|==
literal|1
operator|&&
name|mad_send_wr
operator|->
name|timeout
operator|&&
name|mad_send_wr
operator|->
name|status
operator|==
name|IB_WC_SUCCESS
condition|)
block|{
name|wait_for_response
argument_list|(
name|mad_send_wr
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
comment|/* Remove send from MAD agent and notify client of completion */
name|list_del
argument_list|(
operator|&
name|mad_send_wr
operator|->
name|agent_list
argument_list|)
expr_stmt|;
name|adjust_timeout
argument_list|(
name|mad_agent_priv
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|mad_send_wr
operator|->
name|status
operator|!=
name|IB_WC_SUCCESS
condition|)
name|mad_send_wc
operator|->
name|status
operator|=
name|mad_send_wr
operator|->
name|status
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|IB_RMPP_RESULT_INTERNAL
condition|)
name|ib_rmpp_send_handler
argument_list|(
name|mad_send_wc
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|mad_send_wr
operator|->
name|is_sa_cc_mad
condition|)
name|sa_cc_mad_done
argument_list|(
name|get_cc_obj
argument_list|(
name|mad_send_wr
argument_list|)
argument_list|)
expr_stmt|;
name|mad_agent_priv
operator|->
name|agent
operator|.
name|send_handler
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|agent
argument_list|,
name|mad_send_wc
argument_list|)
expr_stmt|;
block|}
comment|/* Release reference on agent taken when sending */
name|deref_mad_agent
argument_list|(
name|mad_agent_priv
argument_list|)
expr_stmt|;
return|return;
name|done
label|:
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ib_mad_send_done_handler
parameter_list|(
name|struct
name|ib_mad_port_private
modifier|*
name|port_priv
parameter_list|,
name|struct
name|ib_wc
modifier|*
name|wc
parameter_list|)
block|{
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
decl_stmt|,
modifier|*
name|queued_send_wr
decl_stmt|;
name|struct
name|ib_mad_list_head
modifier|*
name|mad_list
decl_stmt|;
name|struct
name|ib_mad_qp_info
modifier|*
name|qp_info
decl_stmt|;
name|struct
name|ib_mad_queue
modifier|*
name|send_queue
decl_stmt|;
name|struct
name|ib_send_wr
modifier|*
name|bad_send_wr
decl_stmt|;
name|struct
name|ib_mad_send_wc
name|mad_send_wc
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|mad_list
operator|=
operator|(
expr|struct
name|ib_mad_list_head
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|wc
operator|->
name|wr_id
expr_stmt|;
name|mad_send_wr
operator|=
name|container_of
argument_list|(
name|mad_list
argument_list|,
expr|struct
name|ib_mad_send_wr_private
argument_list|,
name|mad_list
argument_list|)
expr_stmt|;
name|send_queue
operator|=
name|mad_list
operator|->
name|mad_queue
expr_stmt|;
name|qp_info
operator|=
name|send_queue
operator|->
name|qp_info
expr_stmt|;
name|retry
label|:
name|ib_dma_unmap_single
argument_list|(
name|mad_send_wr
operator|->
name|send_buf
operator|.
name|mad_agent
operator|->
name|device
argument_list|,
name|mad_send_wr
operator|->
name|header_mapping
argument_list|,
name|mad_send_wr
operator|->
name|sg_list
index|[
literal|0
index|]
operator|.
name|length
argument_list|,
name|DMA_TO_DEVICE
argument_list|)
expr_stmt|;
name|ib_dma_unmap_single
argument_list|(
name|mad_send_wr
operator|->
name|send_buf
operator|.
name|mad_agent
operator|->
name|device
argument_list|,
name|mad_send_wr
operator|->
name|payload_mapping
argument_list|,
name|mad_send_wr
operator|->
name|sg_list
index|[
literal|1
index|]
operator|.
name|length
argument_list|,
name|DMA_TO_DEVICE
argument_list|)
expr_stmt|;
name|queued_send_wr
operator|=
name|NULL
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|send_queue
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|mad_list
operator|->
name|list
argument_list|)
expr_stmt|;
comment|/* Move queued send to the send queue */
if|if
condition|(
name|send_queue
operator|->
name|count
operator|--
operator|>
name|send_queue
operator|->
name|max_active
condition|)
block|{
name|mad_list
operator|=
name|container_of
argument_list|(
name|qp_info
operator|->
name|overflow_list
operator|.
name|next
argument_list|,
expr|struct
name|ib_mad_list_head
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|queued_send_wr
operator|=
name|container_of
argument_list|(
name|mad_list
argument_list|,
expr|struct
name|ib_mad_send_wr_private
argument_list|,
name|mad_list
argument_list|)
expr_stmt|;
name|list_move_tail
argument_list|(
operator|&
name|mad_list
operator|->
name|list
argument_list|,
operator|&
name|send_queue
operator|->
name|list
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|send_queue
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|mad_send_wc
operator|.
name|send_buf
operator|=
operator|&
name|mad_send_wr
operator|->
name|send_buf
expr_stmt|;
name|mad_send_wc
operator|.
name|status
operator|=
name|wc
operator|->
name|status
expr_stmt|;
name|mad_send_wc
operator|.
name|vendor_err
operator|=
name|wc
operator|->
name|vendor_err
expr_stmt|;
if|if
condition|(
name|atomic_read
argument_list|(
operator|&
name|qp_info
operator|->
name|snoop_count
argument_list|)
condition|)
name|snoop_send
argument_list|(
name|qp_info
argument_list|,
operator|&
name|mad_send_wr
operator|->
name|send_buf
argument_list|,
operator|&
name|mad_send_wc
argument_list|,
name|IB_MAD_SNOOP_SEND_COMPLETIONS
argument_list|)
expr_stmt|;
name|ib_mad_complete_send_wr
argument_list|(
name|mad_send_wr
argument_list|,
operator|&
name|mad_send_wc
argument_list|)
expr_stmt|;
if|if
condition|(
name|queued_send_wr
condition|)
block|{
name|ret
operator|=
name|ib_post_send
argument_list|(
name|qp_info
operator|->
name|qp
argument_list|,
operator|&
name|queued_send_wr
operator|->
name|send_wr
argument_list|,
operator|&
name|bad_send_wr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"ib_post_send failed: %d\n"
argument_list|,
argument|ret
argument_list|)
empty_stmt|;
name|mad_send_wr
operator|=
name|queued_send_wr
expr_stmt|;
name|wc
operator|->
name|status
operator|=
name|IB_WC_LOC_QP_OP_ERR
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mark_sends_for_retry
parameter_list|(
name|struct
name|ib_mad_qp_info
modifier|*
name|qp_info
parameter_list|)
block|{
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
decl_stmt|;
name|struct
name|ib_mad_list_head
modifier|*
name|mad_list
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|qp_info
operator|->
name|send_queue
operator|.
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|mad_list
argument_list|,
argument|&qp_info->send_queue.list
argument_list|,
argument|list
argument_list|)
block|{
name|mad_send_wr
operator|=
name|container_of
argument_list|(
name|mad_list
argument_list|,
expr|struct
name|ib_mad_send_wr_private
argument_list|,
name|mad_list
argument_list|)
expr_stmt|;
name|mad_send_wr
operator|->
name|retry
operator|=
literal|1
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|qp_info
operator|->
name|send_queue
operator|.
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mad_error_handler
parameter_list|(
name|struct
name|ib_mad_port_private
modifier|*
name|port_priv
parameter_list|,
name|struct
name|ib_wc
modifier|*
name|wc
parameter_list|)
block|{
name|struct
name|ib_mad_list_head
modifier|*
name|mad_list
decl_stmt|;
name|struct
name|ib_mad_qp_info
modifier|*
name|qp_info
decl_stmt|;
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* Determine if failure was a send or receive */
name|mad_list
operator|=
operator|(
expr|struct
name|ib_mad_list_head
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|wc
operator|->
name|wr_id
expr_stmt|;
name|qp_info
operator|=
name|mad_list
operator|->
name|mad_queue
operator|->
name|qp_info
expr_stmt|;
if|if
condition|(
name|mad_list
operator|->
name|mad_queue
operator|==
operator|&
name|qp_info
operator|->
name|recv_queue
condition|)
comment|/* 		 * Receive errors indicate that the QP has entered the error 		 * state - error handling/shutdown code will cleanup 		 */
return|return;
comment|/* 	 * Send errors will transition the QP to SQE - move 	 * QP to RTS and repost flushed work requests 	 */
name|mad_send_wr
operator|=
name|container_of
argument_list|(
name|mad_list
argument_list|,
expr|struct
name|ib_mad_send_wr_private
argument_list|,
name|mad_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc
operator|->
name|status
operator|==
name|IB_WC_WR_FLUSH_ERR
condition|)
block|{
if|if
condition|(
name|mad_send_wr
operator|->
name|retry
condition|)
block|{
comment|/* Repost send */
name|struct
name|ib_send_wr
modifier|*
name|bad_send_wr
decl_stmt|;
name|mad_send_wr
operator|->
name|retry
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|ib_post_send
argument_list|(
name|qp_info
operator|->
name|qp
argument_list|,
operator|&
name|mad_send_wr
operator|->
name|send_wr
argument_list|,
operator|&
name|bad_send_wr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|ib_mad_send_done_handler
argument_list|(
name|port_priv
argument_list|,
name|wc
argument_list|)
expr_stmt|;
block|}
else|else
name|ib_mad_send_done_handler
argument_list|(
name|port_priv
argument_list|,
name|wc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ib_qp_attr
modifier|*
name|attr
decl_stmt|;
comment|/* Transition QP to RTS and fail offending send */
name|attr
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|attr
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr
condition|)
block|{
name|attr
operator|->
name|qp_state
operator|=
name|IB_QPS_RTS
expr_stmt|;
name|attr
operator|->
name|cur_qp_state
operator|=
name|IB_QPS_SQE
expr_stmt|;
name|ret
operator|=
name|ib_modify_qp
argument_list|(
name|qp_info
operator|->
name|qp
argument_list|,
name|attr
argument_list|,
name|IB_QP_STATE
operator||
name|IB_QP_CUR_STATE
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"mad_error_handler - "
literal|"ib_modify_qp to RTS : %d\n"
argument_list|,
argument|ret
argument_list|)
empty_stmt|;
else|else
name|mark_sends_for_retry
argument_list|(
name|qp_info
argument_list|)
expr_stmt|;
block|}
name|ib_mad_send_done_handler
argument_list|(
name|port_priv
argument_list|,
name|wc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * IB MAD completion callback  */
end_comment

begin_function
specifier|static
name|void
name|ib_mad_completion_handler
parameter_list|(
name|struct
name|work_struct
modifier|*
name|work
parameter_list|)
block|{
name|struct
name|ib_mad_port_private
modifier|*
name|port_priv
decl_stmt|;
name|struct
name|ib_wc
name|wc
decl_stmt|;
name|port_priv
operator|=
name|container_of
argument_list|(
name|work
argument_list|,
expr|struct
name|ib_mad_port_private
argument_list|,
name|work
argument_list|)
expr_stmt|;
name|ib_req_notify_cq
argument_list|(
name|port_priv
operator|->
name|cq
argument_list|,
name|IB_CQ_NEXT_COMP
argument_list|)
expr_stmt|;
while|while
condition|(
name|ib_poll_cq
argument_list|(
name|port_priv
operator|->
name|cq
argument_list|,
literal|1
argument_list|,
operator|&
name|wc
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|wc
operator|.
name|status
operator|==
name|IB_WC_SUCCESS
condition|)
block|{
switch|switch
condition|(
name|wc
operator|.
name|opcode
condition|)
block|{
case|case
name|IB_WC_SEND
case|:
name|ib_mad_send_done_handler
argument_list|(
name|port_priv
argument_list|,
operator|&
name|wc
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_WC_RECV
case|:
name|ib_mad_recv_done_handler
argument_list|(
name|port_priv
argument_list|,
operator|&
name|wc
argument_list|)
expr_stmt|;
break|break;
default|default:
name|BUG_ON
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
name|mad_error_handler
argument_list|(
name|port_priv
argument_list|,
operator|&
name|wc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cancel_mads
parameter_list|(
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
decl_stmt|,
modifier|*
name|temp_mad_send_wr
decl_stmt|;
name|struct
name|ib_mad_send_wc
name|mad_send_wc
decl_stmt|;
name|struct
name|list_head
name|cancel_list
decl_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|cancel_list
argument_list|)
expr_stmt|;
name|cancel_sa_cc_mads
argument_list|(
name|mad_agent_priv
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|mad_send_wr
argument_list|,
argument|temp_mad_send_wr
argument_list|,
argument|&mad_agent_priv->send_list
argument_list|,
argument|agent_list
argument_list|)
block|{
if|if
condition|(
name|mad_send_wr
operator|->
name|status
operator|==
name|IB_WC_SUCCESS
condition|)
block|{
name|mad_send_wr
operator|->
name|status
operator|=
name|IB_WC_WR_FLUSH_ERR
expr_stmt|;
name|mad_send_wr
operator|->
name|refcount
operator|-=
operator|(
name|mad_send_wr
operator|->
name|timeout
operator|>
literal|0
operator|)
expr_stmt|;
block|}
block|}
comment|/* Empty wait list to prevent receives from finding a request */
name|list_splice_init
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|wait_list
argument_list|,
operator|&
name|cancel_list
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Report all cancelled requests */
name|mad_send_wc
operator|.
name|status
operator|=
name|IB_WC_WR_FLUSH_ERR
expr_stmt|;
name|mad_send_wc
operator|.
name|vendor_err
operator|=
literal|0
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|mad_send_wr
argument_list|,
argument|temp_mad_send_wr
argument_list|,
argument|&cancel_list
argument_list|,
argument|agent_list
argument_list|)
block|{
name|mad_send_wc
operator|.
name|send_buf
operator|=
operator|&
name|mad_send_wr
operator|->
name|send_buf
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|mad_send_wr
operator|->
name|agent_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|mad_send_wr
operator|->
name|is_sa_cc_mad
condition|)
name|sa_cc_mad_done
argument_list|(
name|get_cc_obj
argument_list|(
name|mad_send_wr
argument_list|)
argument_list|)
expr_stmt|;
name|mad_agent_priv
operator|->
name|agent
operator|.
name|send_handler
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|agent
argument_list|,
operator|&
name|mad_send_wc
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|refcount
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|ib_mad_send_wr_private
modifier|*
name|find_send_wr
parameter_list|(
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
parameter_list|,
name|struct
name|ib_mad_send_buf
modifier|*
name|send_buf
parameter_list|)
block|{
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|mad_send_wr
argument_list|,
argument|&mad_agent_priv->wait_list
argument_list|,
argument|agent_list
argument_list|)
block|{
if|if
condition|(
operator|&
name|mad_send_wr
operator|->
name|send_buf
operator|==
name|send_buf
condition|)
return|return
name|mad_send_wr
return|;
block|}
name|list_for_each_entry
argument_list|(
argument|mad_send_wr
argument_list|,
argument|&mad_agent_priv->send_list
argument_list|,
argument|agent_list
argument_list|)
block|{
if|if
condition|(
name|is_data_mad
argument_list|(
name|mad_agent_priv
argument_list|,
name|mad_send_wr
operator|->
name|send_buf
operator|.
name|mad
argument_list|)
operator|&&
operator|&
name|mad_send_wr
operator|->
name|send_buf
operator|==
name|send_buf
condition|)
return|return
name|mad_send_wr
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|ib_modify_mad
parameter_list|(
name|struct
name|ib_mad_agent
modifier|*
name|mad_agent
parameter_list|,
name|struct
name|ib_mad_send_buf
modifier|*
name|send_buf
parameter_list|,
name|u32
name|timeout_ms
parameter_list|)
block|{
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
decl_stmt|;
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|active
decl_stmt|;
name|mad_agent_priv
operator|=
name|container_of
argument_list|(
name|mad_agent
argument_list|,
expr|struct
name|ib_mad_agent_private
argument_list|,
name|agent
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|mad_send_wr
operator|=
name|find_send_wr
argument_list|(
name|mad_agent_priv
argument_list|,
name|send_buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mad_send_wr
condition|)
block|{
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|modify_sa_cc_mad
argument_list|(
name|mad_agent_priv
argument_list|,
name|send_buf
argument_list|,
name|timeout_ms
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|mad_send_wr
operator|->
name|status
operator|!=
name|IB_WC_SUCCESS
condition|)
block|{
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|active
operator|=
operator|(
operator|!
name|mad_send_wr
operator|->
name|timeout
operator|||
name|mad_send_wr
operator|->
name|refcount
operator|>
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|timeout_ms
condition|)
block|{
name|mad_send_wr
operator|->
name|status
operator|=
name|IB_WC_WR_FLUSH_ERR
expr_stmt|;
name|mad_send_wr
operator|->
name|refcount
operator|-=
operator|(
name|mad_send_wr
operator|->
name|timeout
operator|>
literal|0
operator|)
expr_stmt|;
block|}
name|mad_send_wr
operator|->
name|send_buf
operator|.
name|timeout_ms
operator|=
name|timeout_ms
expr_stmt|;
if|if
condition|(
name|active
condition|)
name|mad_send_wr
operator|->
name|timeout
operator|=
name|msecs_to_jiffies
argument_list|(
name|timeout_ms
argument_list|)
expr_stmt|;
else|else
name|ib_reset_mad_timeout
argument_list|(
name|mad_send_wr
argument_list|,
name|timeout_ms
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_modify_mad
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|ib_cancel_mad
parameter_list|(
name|struct
name|ib_mad_agent
modifier|*
name|mad_agent
parameter_list|,
name|struct
name|ib_mad_send_buf
modifier|*
name|send_buf
parameter_list|)
block|{
name|ib_modify_mad
argument_list|(
name|mad_agent
argument_list|,
name|send_buf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_cancel_mad
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|local_completions
parameter_list|(
name|struct
name|work_struct
modifier|*
name|work
parameter_list|)
block|{
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
decl_stmt|;
name|struct
name|ib_mad_local_private
modifier|*
name|local
decl_stmt|;
name|struct
name|ib_mad_agent_private
modifier|*
name|recv_mad_agent
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|free_mad
decl_stmt|;
name|struct
name|ib_wc
name|wc
decl_stmt|;
name|struct
name|ib_mad_send_wc
name|mad_send_wc
decl_stmt|;
name|mad_agent_priv
operator|=
name|container_of
argument_list|(
name|work
argument_list|,
expr|struct
name|ib_mad_agent_private
argument_list|,
name|local_work
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|local_list
argument_list|)
condition|)
block|{
name|local
operator|=
name|list_entry
argument_list|(
name|mad_agent_priv
operator|->
name|local_list
operator|.
name|next
argument_list|,
expr|struct
name|ib_mad_local_private
argument_list|,
name|completion_list
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|local
operator|->
name|completion_list
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|free_mad
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|local
operator|->
name|mad_priv
condition|)
block|{
name|recv_mad_agent
operator|=
name|local
operator|->
name|recv_mad_agent
expr_stmt|;
if|if
condition|(
operator|!
name|recv_mad_agent
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"No receive MAD agent for local completion\n"
argument_list|)
empty_stmt|;
name|free_mad
operator|=
literal|1
expr_stmt|;
goto|goto
name|local_send_completion
goto|;
block|}
comment|/* 			 * Defined behavior is to complete response 			 * before request 			 */
name|build_smp_wc
argument_list|(
name|recv_mad_agent
operator|->
name|agent
operator|.
name|qp
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|local
operator|->
name|mad_send_wr
argument_list|,
name|be16_to_cpu
argument_list|(
name|IB_LID_PERMISSIVE
argument_list|)
argument_list|,
literal|0
argument_list|,
name|recv_mad_agent
operator|->
name|agent
operator|.
name|port_num
argument_list|,
operator|&
name|wc
argument_list|)
expr_stmt|;
name|local
operator|->
name|mad_priv
operator|->
name|header
operator|.
name|recv_wc
operator|.
name|wc
operator|=
operator|&
name|wc
expr_stmt|;
name|local
operator|->
name|mad_priv
operator|->
name|header
operator|.
name|recv_wc
operator|.
name|mad_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ib_mad
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|local
operator|->
name|mad_priv
operator|->
name|header
operator|.
name|recv_wc
operator|.
name|rmpp_list
argument_list|)
expr_stmt|;
name|list_add
argument_list|(
operator|&
name|local
operator|->
name|mad_priv
operator|->
name|header
operator|.
name|recv_wc
operator|.
name|recv_buf
operator|.
name|list
argument_list|,
operator|&
name|local
operator|->
name|mad_priv
operator|->
name|header
operator|.
name|recv_wc
operator|.
name|rmpp_list
argument_list|)
expr_stmt|;
name|local
operator|->
name|mad_priv
operator|->
name|header
operator|.
name|recv_wc
operator|.
name|recv_buf
operator|.
name|grh
operator|=
name|NULL
expr_stmt|;
name|local
operator|->
name|mad_priv
operator|->
name|header
operator|.
name|recv_wc
operator|.
name|recv_buf
operator|.
name|mad
operator|=
operator|&
name|local
operator|->
name|mad_priv
operator|->
name|mad
operator|.
name|mad
expr_stmt|;
if|if
condition|(
name|atomic_read
argument_list|(
operator|&
name|recv_mad_agent
operator|->
name|qp_info
operator|->
name|snoop_count
argument_list|)
condition|)
name|snoop_recv
argument_list|(
name|recv_mad_agent
operator|->
name|qp_info
argument_list|,
operator|&
name|local
operator|->
name|mad_priv
operator|->
name|header
operator|.
name|recv_wc
argument_list|,
name|IB_MAD_SNOOP_RECVS
argument_list|)
expr_stmt|;
name|recv_mad_agent
operator|->
name|agent
operator|.
name|recv_handler
argument_list|(
operator|&
name|recv_mad_agent
operator|->
name|agent
argument_list|,
operator|&
name|local
operator|->
name|mad_priv
operator|->
name|header
operator|.
name|recv_wc
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|recv_mad_agent
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|recv_mad_agent
operator|->
name|refcount
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|recv_mad_agent
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|local_send_completion
label|:
comment|/* Complete send */
name|mad_send_wc
operator|.
name|status
operator|=
name|IB_WC_SUCCESS
expr_stmt|;
name|mad_send_wc
operator|.
name|vendor_err
operator|=
literal|0
expr_stmt|;
name|mad_send_wc
operator|.
name|send_buf
operator|=
operator|&
name|local
operator|->
name|mad_send_wr
operator|->
name|send_buf
expr_stmt|;
if|if
condition|(
name|atomic_read
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|qp_info
operator|->
name|snoop_count
argument_list|)
condition|)
name|snoop_send
argument_list|(
name|mad_agent_priv
operator|->
name|qp_info
argument_list|,
operator|&
name|local
operator|->
name|mad_send_wr
operator|->
name|send_buf
argument_list|,
operator|&
name|mad_send_wc
argument_list|,
name|IB_MAD_SNOOP_SEND_COMPLETIONS
argument_list|)
expr_stmt|;
name|mad_agent_priv
operator|->
name|agent
operator|.
name|send_handler
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|agent
argument_list|,
operator|&
name|mad_send_wc
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|refcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_mad
condition|)
name|kmem_cache_free
argument_list|(
name|ib_mad_cache
argument_list|,
name|local
operator|->
name|mad_priv
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|local
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|retry_send
parameter_list|(
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|mad_send_wr
operator|->
name|retries_left
condition|)
return|return
operator|-
name|ETIMEDOUT
return|;
name|mad_send_wr
operator|->
name|retries_left
operator|--
expr_stmt|;
name|mad_send_wr
operator|->
name|send_buf
operator|.
name|retries
operator|++
expr_stmt|;
name|mad_send_wr
operator|->
name|timeout
operator|=
name|msecs_to_jiffies
argument_list|(
name|mad_send_wr
operator|->
name|send_buf
operator|.
name|timeout_ms
argument_list|)
expr_stmt|;
if|if
condition|(
name|mad_send_wr
operator|->
name|mad_agent_priv
operator|->
name|agent
operator|.
name|rmpp_version
condition|)
block|{
name|ret
operator|=
name|ib_retry_rmpp
argument_list|(
name|mad_send_wr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|IB_RMPP_RESULT_UNHANDLED
case|:
name|ret
operator|=
name|ib_send_mad
argument_list|(
name|mad_send_wr
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_RMPP_RESULT_CONSUMED
case|:
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
operator|-
name|ECOMM
expr_stmt|;
break|break;
block|}
block|}
else|else
name|ret
operator|=
name|ib_send_mad
argument_list|(
name|mad_send_wr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
name|mad_send_wr
operator|->
name|refcount
operator|++
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|mad_send_wr
operator|->
name|agent_list
argument_list|,
operator|&
name|mad_send_wr
operator|->
name|mad_agent_priv
operator|->
name|send_list
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|timeout_sends
parameter_list|(
name|struct
name|work_struct
modifier|*
name|work
parameter_list|)
block|{
name|struct
name|ib_mad_agent_private
modifier|*
name|mad_agent_priv
decl_stmt|;
name|struct
name|ib_mad_send_wr_private
modifier|*
name|mad_send_wr
decl_stmt|;
name|struct
name|ib_mad_send_wc
name|mad_send_wc
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|,
name|delay
decl_stmt|;
name|mad_agent_priv
operator|=
name|container_of
argument_list|(
name|work
argument_list|,
expr|struct
name|ib_mad_agent_private
argument_list|,
name|timed_work
operator|.
name|work
argument_list|)
expr_stmt|;
name|mad_send_wc
operator|.
name|vendor_err
operator|=
literal|0
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|wait_list
argument_list|)
condition|)
block|{
name|mad_send_wr
operator|=
name|list_entry
argument_list|(
name|mad_agent_priv
operator|->
name|wait_list
operator|.
name|next
argument_list|,
expr|struct
name|ib_mad_send_wr_private
argument_list|,
name|agent_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_after
argument_list|(
name|mad_send_wr
operator|->
name|timeout
argument_list|,
name|jiffies
argument_list|)
condition|)
block|{
name|delay
operator|=
name|mad_send_wr
operator|->
name|timeout
operator|-
name|jiffies
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|delay
operator|<=
literal|0
condition|)
name|delay
operator|=
literal|1
expr_stmt|;
name|queue_delayed_work
argument_list|(
name|mad_agent_priv
operator|->
name|qp_info
operator|->
name|port_priv
operator|->
name|wq
argument_list|,
operator|&
name|mad_agent_priv
operator|->
name|timed_work
argument_list|,
name|delay
argument_list|)
expr_stmt|;
break|break;
block|}
name|list_del
argument_list|(
operator|&
name|mad_send_wr
operator|->
name|agent_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|mad_send_wr
operator|->
name|status
operator|==
name|IB_WC_SUCCESS
operator|&&
operator|!
name|retry_send
argument_list|(
name|mad_send_wr
argument_list|)
condition|)
continue|continue;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|mad_send_wr
operator|->
name|status
operator|==
name|IB_WC_SUCCESS
condition|)
name|mad_send_wc
operator|.
name|status
operator|=
name|IB_WC_RESP_TIMEOUT_ERR
expr_stmt|;
else|else
name|mad_send_wc
operator|.
name|status
operator|=
name|mad_send_wr
operator|->
name|status
expr_stmt|;
name|mad_send_wc
operator|.
name|send_buf
operator|=
operator|&
name|mad_send_wr
operator|->
name|send_buf
expr_stmt|;
if|if
condition|(
name|mad_send_wr
operator|->
name|is_sa_cc_mad
condition|)
name|sa_cc_mad_done
argument_list|(
name|get_cc_obj
argument_list|(
name|mad_send_wr
argument_list|)
argument_list|)
expr_stmt|;
name|mad_agent_priv
operator|->
name|agent
operator|.
name|send_handler
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|agent
argument_list|,
operator|&
name|mad_send_wc
argument_list|)
expr_stmt|;
name|atomic_dec
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|refcount
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|mad_agent_priv
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ib_mad_thread_completion_handler
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ib_mad_port_private
modifier|*
name|port_priv
init|=
name|cq
operator|->
name|cq_context
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|ib_mad_port_list_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|port_priv
operator|->
name|port_list
argument_list|)
condition|)
name|queue_work
argument_list|(
name|port_priv
operator|->
name|wq
argument_list|,
operator|&
name|port_priv
operator|->
name|work
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|ib_mad_port_list_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate receive MADs and post receive WRs for them  */
end_comment

begin_function
specifier|static
name|int
name|ib_mad_post_receive_mads
parameter_list|(
name|struct
name|ib_mad_qp_info
modifier|*
name|qp_info
parameter_list|,
name|struct
name|ib_mad_private
modifier|*
name|mad
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|post
decl_stmt|,
name|ret
decl_stmt|;
name|struct
name|ib_mad_private
modifier|*
name|mad_priv
decl_stmt|;
name|struct
name|ib_sge
name|sg_list
decl_stmt|;
name|struct
name|ib_recv_wr
name|recv_wr
decl_stmt|,
modifier|*
name|bad_recv_wr
decl_stmt|;
name|struct
name|ib_mad_queue
modifier|*
name|recv_queue
init|=
operator|&
name|qp_info
operator|->
name|recv_queue
decl_stmt|;
comment|/* Initialize common scatter list fields */
name|sg_list
operator|.
name|length
operator|=
sizeof|sizeof
expr|*
name|mad_priv
operator|-
sizeof|sizeof
name|mad_priv
operator|->
name|header
expr_stmt|;
name|sg_list
operator|.
name|lkey
operator|=
operator|(
operator|*
name|qp_info
operator|->
name|port_priv
operator|->
name|mr
operator|)
operator|.
name|lkey
expr_stmt|;
comment|/* Initialize common receive WR fields */
name|recv_wr
operator|.
name|next
operator|=
name|NULL
expr_stmt|;
name|recv_wr
operator|.
name|sg_list
operator|=
operator|&
name|sg_list
expr_stmt|;
name|recv_wr
operator|.
name|num_sge
operator|=
literal|1
expr_stmt|;
do|do
block|{
comment|/* Allocate and map receive buffer */
if|if
condition|(
name|mad
condition|)
block|{
name|mad_priv
operator|=
name|mad
expr_stmt|;
name|mad
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|mad_priv
operator|=
name|kmem_cache_alloc
argument_list|(
name|ib_mad_cache
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mad_priv
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"No memory for receive buffer\n"
argument_list|)
empty_stmt|;
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
break|break;
block|}
block|}
name|sg_list
operator|.
name|addr
operator|=
name|ib_dma_map_single
argument_list|(
name|qp_info
operator|->
name|port_priv
operator|->
name|device
argument_list|,
operator|&
name|mad_priv
operator|->
name|grh
argument_list|,
sizeof|sizeof
expr|*
name|mad_priv
operator|-
sizeof|sizeof
name|mad_priv
operator|->
name|header
argument_list|,
name|DMA_FROM_DEVICE
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ib_dma_mapping_error
argument_list|(
name|qp_info
operator|->
name|port_priv
operator|->
name|device
argument_list|,
name|sg_list
operator|.
name|addr
argument_list|)
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|ib_mad_cache
argument_list|,
name|mad_priv
argument_list|)
expr_stmt|;
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"ib_dma_map_single failed\n"
argument_list|)
empty_stmt|;
break|break;
block|}
name|mad_priv
operator|->
name|header
operator|.
name|mapping
operator|=
name|sg_list
operator|.
name|addr
expr_stmt|;
name|recv_wr
operator|.
name|wr_id
operator|=
operator|(
name|unsigned
name|long
operator|)
operator|&
name|mad_priv
operator|->
name|header
operator|.
name|mad_list
expr_stmt|;
name|mad_priv
operator|->
name|header
operator|.
name|mad_list
operator|.
name|mad_queue
operator|=
name|recv_queue
expr_stmt|;
comment|/* Post receive WR */
name|spin_lock_irqsave
argument_list|(
operator|&
name|recv_queue
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|post
operator|=
operator|(
operator|++
name|recv_queue
operator|->
name|count
operator|<
name|recv_queue
operator|->
name|max_active
operator|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|mad_priv
operator|->
name|header
operator|.
name|mad_list
operator|.
name|list
argument_list|,
operator|&
name|recv_queue
operator|->
name|list
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|recv_queue
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ib_post_recv
argument_list|(
name|qp_info
operator|->
name|qp
argument_list|,
operator|&
name|recv_wr
argument_list|,
operator|&
name|bad_recv_wr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|spin_lock_irqsave
argument_list|(
operator|&
name|recv_queue
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|mad_priv
operator|->
name|header
operator|.
name|mad_list
operator|.
name|list
argument_list|)
expr_stmt|;
name|recv_queue
operator|->
name|count
operator|--
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|recv_queue
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ib_dma_unmap_single
argument_list|(
name|qp_info
operator|->
name|port_priv
operator|->
name|device
argument_list|,
name|mad_priv
operator|->
name|header
operator|.
name|mapping
argument_list|,
sizeof|sizeof
expr|*
name|mad_priv
operator|-
sizeof|sizeof
name|mad_priv
operator|->
name|header
argument_list|,
name|DMA_FROM_DEVICE
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|ib_mad_cache
argument_list|,
name|mad_priv
argument_list|)
expr_stmt|;
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"ib_post_recv failed: %d\n"
argument_list|,
argument|ret
argument_list|)
empty_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|post
condition|)
do|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Return all the posted receive MADs  */
end_comment

begin_function
specifier|static
name|void
name|cleanup_recv_queue
parameter_list|(
name|struct
name|ib_mad_qp_info
modifier|*
name|qp_info
parameter_list|)
block|{
name|struct
name|ib_mad_private_header
modifier|*
name|mad_priv_hdr
decl_stmt|;
name|struct
name|ib_mad_private
modifier|*
name|recv
decl_stmt|;
name|struct
name|ib_mad_list_head
modifier|*
name|mad_list
decl_stmt|;
if|if
condition|(
operator|!
name|qp_info
operator|->
name|qp
condition|)
return|return;
while|while
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|qp_info
operator|->
name|recv_queue
operator|.
name|list
argument_list|)
condition|)
block|{
name|mad_list
operator|=
name|list_entry
argument_list|(
name|qp_info
operator|->
name|recv_queue
operator|.
name|list
operator|.
name|next
argument_list|,
expr|struct
name|ib_mad_list_head
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|mad_priv_hdr
operator|=
name|container_of
argument_list|(
name|mad_list
argument_list|,
expr|struct
name|ib_mad_private_header
argument_list|,
name|mad_list
argument_list|)
expr_stmt|;
name|recv
operator|=
name|container_of
argument_list|(
name|mad_priv_hdr
argument_list|,
expr|struct
name|ib_mad_private
argument_list|,
name|header
argument_list|)
expr_stmt|;
comment|/* Remove from posted receive MAD list */
name|list_del
argument_list|(
operator|&
name|mad_list
operator|->
name|list
argument_list|)
expr_stmt|;
name|ib_dma_unmap_single
argument_list|(
name|qp_info
operator|->
name|port_priv
operator|->
name|device
argument_list|,
name|recv
operator|->
name|header
operator|.
name|mapping
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ib_mad_private
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ib_mad_private_header
argument_list|)
argument_list|,
name|DMA_FROM_DEVICE
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|ib_mad_cache
argument_list|,
name|recv
argument_list|)
expr_stmt|;
block|}
name|qp_info
operator|->
name|recv_queue
operator|.
name|count
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start the port  */
end_comment

begin_function
specifier|static
name|int
name|ib_mad_port_start
parameter_list|(
name|struct
name|ib_mad_port_private
modifier|*
name|port_priv
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|ib_qp_attr
modifier|*
name|attr
decl_stmt|;
name|struct
name|ib_qp
modifier|*
name|qp
decl_stmt|;
name|u16
name|pkey_index
init|=
literal|0
decl_stmt|;
name|attr
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|attr
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|attr
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"Couldn't kmalloc ib_qp_attr\n"
argument_list|)
empty_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|ret
operator|=
name|ib_find_pkey
argument_list|(
name|port_priv
operator|->
name|device
argument_list|,
name|port_priv
operator|->
name|port_num
argument_list|,
literal|0xFFFF
argument_list|,
operator|&
name|pkey_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|pkey_index
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IB_MAD_QPS_CORE
condition|;
name|i
operator|++
control|)
block|{
name|qp
operator|=
name|port_priv
operator|->
name|qp_info
index|[
name|i
index|]
operator|.
name|qp
expr_stmt|;
if|if
condition|(
operator|!
name|qp
condition|)
continue|continue;
comment|/* 		 * PKey index for QP1 is irrelevant but 		 * one is needed for the Reset to Init transition 		 */
name|attr
operator|->
name|qp_state
operator|=
name|IB_QPS_INIT
expr_stmt|;
name|attr
operator|->
name|pkey_index
operator|=
name|pkey_index
expr_stmt|;
name|attr
operator|->
name|qkey
operator|=
operator|(
name|qp
operator|->
name|qp_num
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
name|IB_QP1_QKEY
expr_stmt|;
name|ret
operator|=
name|ib_modify_qp
argument_list|(
name|qp
argument_list|,
name|attr
argument_list|,
name|IB_QP_STATE
operator||
name|IB_QP_PKEY_INDEX
operator||
name|IB_QP_QKEY
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"Couldn't change QP%d state to "
literal|"INIT: %d\n"
argument_list|,
argument|i
argument_list|,
argument|ret
argument_list|)
empty_stmt|;
goto|goto
name|out
goto|;
block|}
name|attr
operator|->
name|qp_state
operator|=
name|IB_QPS_RTR
expr_stmt|;
name|ret
operator|=
name|ib_modify_qp
argument_list|(
name|qp
argument_list|,
name|attr
argument_list|,
name|IB_QP_STATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"Couldn't change QP%d state to "
literal|"RTR: %d\n"
argument_list|,
argument|i
argument_list|,
argument|ret
argument_list|)
empty_stmt|;
goto|goto
name|out
goto|;
block|}
name|attr
operator|->
name|qp_state
operator|=
name|IB_QPS_RTS
expr_stmt|;
name|attr
operator|->
name|sq_psn
operator|=
name|IB_MAD_SEND_Q_PSN
expr_stmt|;
name|ret
operator|=
name|ib_modify_qp
argument_list|(
name|qp
argument_list|,
name|attr
argument_list|,
name|IB_QP_STATE
operator||
name|IB_QP_SQ_PSN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"Couldn't change QP%d state to "
literal|"RTS: %d\n"
argument_list|,
argument|i
argument_list|,
argument|ret
argument_list|)
empty_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|ret
operator|=
name|ib_req_notify_cq
argument_list|(
name|port_priv
operator|->
name|cq
argument_list|,
name|IB_CQ_NEXT_COMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"Failed to request completion "
literal|"notification: %d\n"
argument_list|,
argument|ret
argument_list|)
empty_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IB_MAD_QPS_CORE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|port_priv
operator|->
name|qp_info
index|[
name|i
index|]
operator|.
name|qp
condition|)
continue|continue;
name|ret
operator|=
name|ib_mad_post_receive_mads
argument_list|(
operator|&
name|port_priv
operator|->
name|qp_info
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"Couldn't post receive WRs\n"
argument_list|)
empty_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
name|kfree
argument_list|(
name|attr
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|qp_event_handler
parameter_list|(
name|struct
name|ib_event
modifier|*
name|event
parameter_list|,
name|void
modifier|*
name|qp_context
parameter_list|)
block|{
name|struct
name|ib_mad_qp_info
modifier|*
name|qp_info
init|=
name|qp_context
decl_stmt|;
comment|/* It's worse than that! He's dead, Jim! */
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"Fatal error (%d) on MAD QP (%d)\n"
argument_list|,
argument|event->event
argument_list|,
argument|qp_info->qp->qp_num
argument_list|)
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_mad_queue
parameter_list|(
name|struct
name|ib_mad_qp_info
modifier|*
name|qp_info
parameter_list|,
name|struct
name|ib_mad_queue
modifier|*
name|mad_queue
parameter_list|)
block|{
name|mad_queue
operator|->
name|qp_info
operator|=
name|qp_info
expr_stmt|;
name|mad_queue
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|mad_queue
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|mad_queue
operator|->
name|list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_mad_qp
parameter_list|(
name|struct
name|ib_mad_port_private
modifier|*
name|port_priv
parameter_list|,
name|struct
name|ib_mad_qp_info
modifier|*
name|qp_info
parameter_list|)
block|{
name|qp_info
operator|->
name|port_priv
operator|=
name|port_priv
expr_stmt|;
name|init_mad_queue
argument_list|(
name|qp_info
argument_list|,
operator|&
name|qp_info
operator|->
name|send_queue
argument_list|)
expr_stmt|;
name|init_mad_queue
argument_list|(
name|qp_info
argument_list|,
operator|&
name|qp_info
operator|->
name|recv_queue
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|qp_info
operator|->
name|overflow_list
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|qp_info
operator|->
name|snoop_lock
argument_list|)
expr_stmt|;
name|qp_info
operator|->
name|snoop_table
operator|=
name|NULL
expr_stmt|;
name|qp_info
operator|->
name|snoop_table_size
operator|=
literal|0
expr_stmt|;
name|atomic_set
argument_list|(
operator|&
name|qp_info
operator|->
name|snoop_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|create_mad_qp
parameter_list|(
name|struct
name|ib_mad_qp_info
modifier|*
name|qp_info
parameter_list|,
name|enum
name|ib_qp_type
name|qp_type
parameter_list|)
block|{
name|struct
name|ib_qp_init_attr
name|qp_init_attr
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|memset
argument_list|(
operator|&
name|qp_init_attr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|qp_init_attr
argument_list|)
expr_stmt|;
name|qp_init_attr
operator|.
name|send_cq
operator|=
name|qp_info
operator|->
name|port_priv
operator|->
name|cq
expr_stmt|;
name|qp_init_attr
operator|.
name|recv_cq
operator|=
name|qp_info
operator|->
name|port_priv
operator|->
name|cq
expr_stmt|;
name|qp_init_attr
operator|.
name|sq_sig_type
operator|=
name|IB_SIGNAL_ALL_WR
expr_stmt|;
name|qp_init_attr
operator|.
name|cap
operator|.
name|max_send_wr
operator|=
name|mad_sendq_size
expr_stmt|;
name|qp_init_attr
operator|.
name|cap
operator|.
name|max_recv_wr
operator|=
name|mad_recvq_size
expr_stmt|;
name|qp_init_attr
operator|.
name|cap
operator|.
name|max_send_sge
operator|=
name|IB_MAD_SEND_REQ_MAX_SG
expr_stmt|;
name|qp_init_attr
operator|.
name|cap
operator|.
name|max_recv_sge
operator|=
name|IB_MAD_RECV_REQ_MAX_SG
expr_stmt|;
name|qp_init_attr
operator|.
name|qp_type
operator|=
name|qp_type
expr_stmt|;
name|qp_init_attr
operator|.
name|port_num
operator|=
name|qp_info
operator|->
name|port_priv
operator|->
name|port_num
expr_stmt|;
name|qp_init_attr
operator|.
name|qp_context
operator|=
name|qp_info
expr_stmt|;
name|qp_init_attr
operator|.
name|event_handler
operator|=
name|qp_event_handler
expr_stmt|;
name|qp_info
operator|->
name|qp
operator|=
name|ib_create_qp
argument_list|(
name|qp_info
operator|->
name|port_priv
operator|->
name|pd
argument_list|,
operator|&
name|qp_init_attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|qp_info
operator|->
name|qp
argument_list|)
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"Couldn't create ib_mad QP%d\n"
argument_list|,
argument|get_spl_qp_index(qp_type)
argument_list|)
empty_stmt|;
name|ret
operator|=
name|PTR_ERR
argument_list|(
name|qp_info
operator|->
name|qp
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* Use minimum queue sizes unless the CQ is resized */
name|qp_info
operator|->
name|send_queue
operator|.
name|max_active
operator|=
name|mad_sendq_size
expr_stmt|;
name|qp_info
operator|->
name|recv_queue
operator|.
name|max_active
operator|=
name|mad_recvq_size
expr_stmt|;
return|return
literal|0
return|;
name|error
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_mad_qp
parameter_list|(
name|struct
name|ib_mad_qp_info
modifier|*
name|qp_info
parameter_list|)
block|{
if|if
condition|(
operator|!
name|qp_info
operator|->
name|qp
condition|)
return|return;
name|ib_destroy_qp
argument_list|(
name|qp_info
operator|->
name|qp
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|qp_info
operator|->
name|snoop_table
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open the port  * Create the QP, PD, MR, and CQ if needed  */
end_comment

begin_function
specifier|static
name|int
name|ib_mad_port_open
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
name|port_num
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|cq_size
decl_stmt|;
name|struct
name|ib_mad_port_private
modifier|*
name|port_priv
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|char
name|name
index|[
sizeof|sizeof
expr|"ib_mad123"]
expr_stmt|;
name|int
name|has_smi
decl_stmt|;
comment|/* Create new device info */
name|port_priv
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|port_priv
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port_priv
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"No memory for ib_mad_port_private\n"
argument_list|)
empty_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|port_priv
operator|->
name|device
operator|=
name|device
expr_stmt|;
name|port_priv
operator|->
name|port_num
operator|=
name|port_num
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|port_priv
operator|->
name|reg_lock
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|port_priv
operator|->
name|agent_list
argument_list|)
expr_stmt|;
name|init_mad_qp
argument_list|(
name|port_priv
argument_list|,
operator|&
name|port_priv
operator|->
name|qp_info
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|init_mad_qp
argument_list|(
name|port_priv
argument_list|,
operator|&
name|port_priv
operator|->
name|qp_info
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cq_size
operator|=
name|mad_sendq_size
operator|+
name|mad_recvq_size
expr_stmt|;
name|has_smi
operator|=
name|rdma_port_get_link_layer
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|)
operator|==
name|IB_LINK_LAYER_INFINIBAND
expr_stmt|;
if|if
condition|(
name|has_smi
condition|)
name|cq_size
operator|*=
literal|2
expr_stmt|;
name|port_priv
operator|->
name|cq
operator|=
name|ib_create_cq
argument_list|(
name|port_priv
operator|->
name|device
argument_list|,
name|ib_mad_thread_completion_handler
argument_list|,
name|NULL
argument_list|,
name|port_priv
argument_list|,
name|cq_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|port_priv
operator|->
name|cq
argument_list|)
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"Couldn't create ib_mad CQ\n"
argument_list|)
empty_stmt|;
name|ret
operator|=
name|PTR_ERR
argument_list|(
name|port_priv
operator|->
name|cq
argument_list|)
expr_stmt|;
goto|goto
name|error3
goto|;
block|}
name|port_priv
operator|->
name|pd
operator|=
name|ib_alloc_pd
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|port_priv
operator|->
name|pd
argument_list|)
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"Couldn't create ib_mad PD\n"
argument_list|)
empty_stmt|;
name|ret
operator|=
name|PTR_ERR
argument_list|(
name|port_priv
operator|->
name|pd
argument_list|)
expr_stmt|;
goto|goto
name|error4
goto|;
block|}
name|port_priv
operator|->
name|mr
operator|=
name|ib_get_dma_mr
argument_list|(
name|port_priv
operator|->
name|pd
argument_list|,
name|IB_ACCESS_LOCAL_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|port_priv
operator|->
name|mr
argument_list|)
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"Couldn't get ib_mad DMA MR\n"
argument_list|)
empty_stmt|;
name|ret
operator|=
name|PTR_ERR
argument_list|(
name|port_priv
operator|->
name|mr
argument_list|)
expr_stmt|;
goto|goto
name|error5
goto|;
block|}
if|if
condition|(
name|has_smi
condition|)
block|{
name|ret
operator|=
name|create_mad_qp
argument_list|(
operator|&
name|port_priv
operator|->
name|qp_info
index|[
literal|0
index|]
argument_list|,
name|IB_QPT_SMI
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|error6
goto|;
block|}
name|ret
operator|=
name|create_mad_qp
argument_list|(
operator|&
name|port_priv
operator|->
name|qp_info
index|[
literal|1
index|]
argument_list|,
name|IB_QPT_GSI
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|error7
goto|;
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
literal|"ib_mad%d"
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|port_priv
operator|->
name|wq
operator|=
name|create_singlethread_workqueue
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|port_priv
operator|->
name|wq
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|error8
goto|;
block|}
name|INIT_WORK
argument_list|(
operator|&
name|port_priv
operator|->
name|work
argument_list|,
name|ib_mad_completion_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa_cc_init
argument_list|(
operator|&
name|port_priv
operator|->
name|sa_cc
argument_list|)
condition|)
goto|goto
name|error9
goto|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|ib_mad_port_list_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|port_priv
operator|->
name|port_list
argument_list|,
operator|&
name|ib_mad_port_list
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|ib_mad_port_list_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ib_mad_port_start
argument_list|(
name|port_priv
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"Couldn't start port\n"
argument_list|)
empty_stmt|;
goto|goto
name|error10
goto|;
block|}
return|return
literal|0
return|;
name|error10
label|:
name|spin_lock_irqsave
argument_list|(
operator|&
name|ib_mad_port_list_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_del_init
argument_list|(
operator|&
name|port_priv
operator|->
name|port_list
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|ib_mad_port_list_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|destroy_workqueue
argument_list|(
name|port_priv
operator|->
name|wq
argument_list|)
expr_stmt|;
name|error9
label|:
name|sa_cc_destroy
argument_list|(
operator|&
name|port_priv
operator|->
name|sa_cc
argument_list|)
expr_stmt|;
name|error8
label|:
name|destroy_mad_qp
argument_list|(
operator|&
name|port_priv
operator|->
name|qp_info
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|error7
label|:
name|destroy_mad_qp
argument_list|(
operator|&
name|port_priv
operator|->
name|qp_info
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|error6
label|:
name|ib_dereg_mr
argument_list|(
name|port_priv
operator|->
name|mr
argument_list|)
expr_stmt|;
name|error5
label|:
name|ib_dealloc_pd
argument_list|(
name|port_priv
operator|->
name|pd
argument_list|)
expr_stmt|;
name|error4
label|:
name|ib_destroy_cq
argument_list|(
name|port_priv
operator|->
name|cq
argument_list|)
expr_stmt|;
name|cleanup_recv_queue
argument_list|(
operator|&
name|port_priv
operator|->
name|qp_info
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cleanup_recv_queue
argument_list|(
operator|&
name|port_priv
operator|->
name|qp_info
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|error3
label|:
name|kfree
argument_list|(
name|port_priv
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Close the port  * If there are no classes using the port, free the port  * resources (CQ, MR, PD, QP) and remove the port's info structure  */
end_comment

begin_function
specifier|static
name|int
name|ib_mad_port_close
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
name|port_num
parameter_list|)
block|{
name|struct
name|ib_mad_port_private
modifier|*
name|port_priv
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|ib_mad_port_list_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|port_priv
operator|=
name|__ib_get_mad_port
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|port_priv
operator|==
name|NULL
condition|)
block|{
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|ib_mad_port_list_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"Port %d not found\n"
argument_list|,
argument|port_num
argument_list|)
empty_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
name|list_del_init
argument_list|(
operator|&
name|port_priv
operator|->
name|port_list
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|ib_mad_port_list_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|destroy_workqueue
argument_list|(
name|port_priv
operator|->
name|wq
argument_list|)
expr_stmt|;
name|sa_cc_destroy
argument_list|(
operator|&
name|port_priv
operator|->
name|sa_cc
argument_list|)
expr_stmt|;
name|destroy_mad_qp
argument_list|(
operator|&
name|port_priv
operator|->
name|qp_info
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|destroy_mad_qp
argument_list|(
operator|&
name|port_priv
operator|->
name|qp_info
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ib_dereg_mr
argument_list|(
name|port_priv
operator|->
name|mr
argument_list|)
expr_stmt|;
name|ib_dealloc_pd
argument_list|(
name|port_priv
operator|->
name|pd
argument_list|)
expr_stmt|;
name|ib_destroy_cq
argument_list|(
name|port_priv
operator|->
name|cq
argument_list|)
expr_stmt|;
name|cleanup_recv_queue
argument_list|(
operator|&
name|port_priv
operator|->
name|qp_info
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cleanup_recv_queue
argument_list|(
operator|&
name|port_priv
operator|->
name|qp_info
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* XXX: Handle deallocation of MAD registration tables */
name|kfree
argument_list|(
name|port_priv
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ib_mad_init_device
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|)
block|{
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|rdma_node_get_transport
argument_list|(
name|device
operator|->
name|node_type
argument_list|)
operator|!=
name|RDMA_TRANSPORT_IB
condition|)
return|return;
if|if
condition|(
name|device
operator|->
name|node_type
operator|==
name|RDMA_NODE_IB_SWITCH
condition|)
block|{
name|start
operator|=
literal|0
expr_stmt|;
name|end
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|start
operator|=
literal|1
expr_stmt|;
name|end
operator|=
name|device
operator|->
name|phys_port_cnt
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<=
name|end
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ib_mad_port_open
argument_list|(
name|device
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"Couldn't open %s port %d\n"
argument_list|,
argument|device->name
argument_list|,
argument|i
argument_list|)
empty_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|ib_agent_port_open
argument_list|(
name|device
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"Couldn't open %s port %d "
literal|"for agents\n"
argument_list|,
argument|device->name
argument_list|,
argument|i
argument_list|)
empty_stmt|;
goto|goto
name|error_agent
goto|;
block|}
block|}
return|return;
name|error_agent
label|:
if|if
condition|(
name|ib_mad_port_close
argument_list|(
name|device
argument_list|,
name|i
argument_list|)
condition|)
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"Couldn't close %s port %d\n"
argument_list|,
argument|device->name
argument_list|,
argument|i
argument_list|)
empty_stmt|;
name|error
label|:
name|i
operator|--
expr_stmt|;
while|while
condition|(
name|i
operator|>=
name|start
condition|)
block|{
if|if
condition|(
name|ib_agent_port_close
argument_list|(
name|device
argument_list|,
name|i
argument_list|)
condition|)
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"Couldn't close %s port %d "
literal|"for agents\n"
argument_list|,
argument|device->name
argument_list|,
argument|i
argument_list|)
empty_stmt|;
if|if
condition|(
name|ib_mad_port_close
argument_list|(
name|device
argument_list|,
name|i
argument_list|)
condition|)
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"Couldn't close %s port %d\n"
argument_list|,
argument|device->name
argument_list|,
argument|i
argument_list|)
empty_stmt|;
name|i
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ib_mad_remove_device
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|num_ports
decl_stmt|,
name|cur_port
decl_stmt|;
if|if
condition|(
name|rdma_node_get_transport
argument_list|(
name|device
operator|->
name|node_type
argument_list|)
operator|!=
name|RDMA_TRANSPORT_IB
condition|)
return|return;
if|if
condition|(
name|device
operator|->
name|node_type
operator|==
name|RDMA_NODE_IB_SWITCH
condition|)
block|{
name|num_ports
operator|=
literal|1
expr_stmt|;
name|cur_port
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|num_ports
operator|=
name|device
operator|->
name|phys_port_cnt
expr_stmt|;
name|cur_port
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ports
condition|;
name|i
operator|++
operator|,
name|cur_port
operator|++
control|)
block|{
if|if
condition|(
name|ib_agent_port_close
argument_list|(
name|device
argument_list|,
name|cur_port
argument_list|)
condition|)
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"Couldn't close %s port %d "
literal|"for agents\n"
argument_list|,
argument|device->name
argument_list|,
argument|cur_port
argument_list|)
empty_stmt|;
if|if
condition|(
name|ib_mad_port_close
argument_list|(
name|device
argument_list|,
name|cur_port
argument_list|)
condition|)
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"Couldn't close %s port %d\n"
argument_list|,
argument|device->name
argument_list|,
argument|cur_port
argument_list|)
empty_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|ib_client
name|mad_client
init|=
block|{
operator|.
name|name
operator|=
literal|"mad"
block|,
operator|.
name|add
operator|=
name|ib_mad_init_device
block|,
operator|.
name|remove
operator|=
name|ib_mad_remove_device
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|__init
name|ib_mad_init_module
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|mad_recvq_size
operator|=
name|min
argument_list|(
name|mad_recvq_size
argument_list|,
name|IB_MAD_QP_MAX_SIZE
argument_list|)
expr_stmt|;
name|mad_recvq_size
operator|=
name|max
argument_list|(
name|mad_recvq_size
argument_list|,
name|IB_MAD_QP_MIN_SIZE
argument_list|)
expr_stmt|;
name|mad_sendq_size
operator|=
name|min
argument_list|(
name|mad_sendq_size
argument_list|,
name|IB_MAD_QP_MAX_SIZE
argument_list|)
expr_stmt|;
name|mad_sendq_size
operator|=
name|max
argument_list|(
name|mad_sendq_size
argument_list|,
name|IB_MAD_QP_MIN_SIZE
argument_list|)
expr_stmt|;
name|ib_mad_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"ib_mad"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ib_mad_private
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SLAB_HWCACHE_ALIGN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ib_mad_cache
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"Couldn't create ib_mad cache\n"
argument_list|)
empty_stmt|;
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|error1
goto|;
block|}
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|ib_mad_port_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_register_client
argument_list|(
operator|&
name|mad_client
argument_list|)
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"Couldn't register ib_mad client\n"
argument_list|)
empty_stmt|;
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|error2
goto|;
block|}
return|return
literal|0
return|;
name|error2
label|:
name|kmem_cache_destroy
argument_list|(
name|ib_mad_cache
argument_list|)
expr_stmt|;
name|error1
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__exit
name|ib_mad_cleanup_module
parameter_list|(
name|void
parameter_list|)
block|{
name|ib_unregister_client
argument_list|(
operator|&
name|mad_client
argument_list|)
expr_stmt|;
name|kmem_cache_destroy
argument_list|(
name|ib_mad_cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|module_init
argument_list|(
name|ib_mad_init_module
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_exit
argument_list|(
name|ib_mad_cleanup_module
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

