begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2014 Mellanox Technologies. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<linux/types.h>
end_include

begin_include
include|#
directive|include
file|<linux/sched.h>
end_include

begin_include
include|#
directive|include
file|<linux/slab.h>
end_include

begin_include
include|#
directive|include
file|<linux/vmalloc.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_verbs.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_umem.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_umem_odp.h>
end_include

begin_function
specifier|static
name|void
name|ib_umem_notifier_start_account
parameter_list|(
name|struct
name|ib_umem
modifier|*
name|item
parameter_list|)
block|{
name|mutex_lock
argument_list|(
operator|&
name|item
operator|->
name|odp_data
operator|->
name|umem_mutex
argument_list|)
expr_stmt|;
comment|/* Only update private counters for this umem if it has them. 	 * Otherwise skip it. All page faults will be delayed for this umem. */
if|if
condition|(
name|item
operator|->
name|odp_data
operator|->
name|mn_counters_active
condition|)
block|{
name|int
name|notifiers_count
init|=
name|item
operator|->
name|odp_data
operator|->
name|notifiers_count
operator|++
decl_stmt|;
if|if
condition|(
name|notifiers_count
operator|==
literal|0
condition|)
comment|/* Initialize the completion object for waiting on 			 * notifiers. Since notifier_count is zero, no one 			 * should be waiting right now. */
name|reinit_completion
argument_list|(
operator|&
name|item
operator|->
name|odp_data
operator|->
name|notifier_completion
argument_list|)
expr_stmt|;
block|}
name|mutex_unlock
argument_list|(
operator|&
name|item
operator|->
name|odp_data
operator|->
name|umem_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ib_umem_notifier_end_account
parameter_list|(
name|struct
name|ib_umem
modifier|*
name|item
parameter_list|)
block|{
name|mutex_lock
argument_list|(
operator|&
name|item
operator|->
name|odp_data
operator|->
name|umem_mutex
argument_list|)
expr_stmt|;
comment|/* Only update private counters for this umem if it has them. 	 * Otherwise skip it. All page faults will be delayed for this umem. */
if|if
condition|(
name|item
operator|->
name|odp_data
operator|->
name|mn_counters_active
condition|)
block|{
comment|/* 		 * This sequence increase will notify the QP page fault that 		 * the page that is going to be mapped in the spte could have 		 * been freed. 		 */
operator|++
name|item
operator|->
name|odp_data
operator|->
name|notifiers_seq
expr_stmt|;
if|if
condition|(
operator|--
name|item
operator|->
name|odp_data
operator|->
name|notifiers_count
operator|==
literal|0
condition|)
name|complete_all
argument_list|(
operator|&
name|item
operator|->
name|odp_data
operator|->
name|notifier_completion
argument_list|)
expr_stmt|;
block|}
name|mutex_unlock
argument_list|(
operator|&
name|item
operator|->
name|odp_data
operator|->
name|umem_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Account for a new mmu notifier in an ib_ucontext. */
end_comment

begin_function
specifier|static
name|void
name|ib_ucontext_notifier_start_account
parameter_list|(
name|struct
name|ib_ucontext
modifier|*
name|context
parameter_list|)
block|{
name|atomic_inc
argument_list|(
operator|&
name|context
operator|->
name|notifier_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Account for a terminating mmu notifier in an ib_ucontext.  *  * Must be called with the ib_ucontext->umem_rwsem semaphore unlocked, since  * the function takes the semaphore itself. */
end_comment

begin_function
specifier|static
name|void
name|ib_ucontext_notifier_end_account
parameter_list|(
name|struct
name|ib_ucontext
modifier|*
name|context
parameter_list|)
block|{
name|int
name|zero_notifiers
init|=
name|atomic_dec_and_test
argument_list|(
operator|&
name|context
operator|->
name|notifier_count
argument_list|)
decl_stmt|;
if|if
condition|(
name|zero_notifiers
operator|&&
operator|!
name|list_empty
argument_list|(
operator|&
name|context
operator|->
name|no_private_counters
argument_list|)
condition|)
block|{
comment|/* No currently running mmu notifiers. Now is the chance to 		 * add private accounting to all previously added umems. */
name|struct
name|ib_umem_odp
modifier|*
name|odp_data
decl_stmt|,
modifier|*
name|next
decl_stmt|;
comment|/* Prevent concurrent mmu notifiers from working on the 		 * no_private_counters list. */
name|down_write
argument_list|(
operator|&
name|context
operator|->
name|umem_rwsem
argument_list|)
expr_stmt|;
comment|/* Read the notifier_count again, with the umem_rwsem 		 * semaphore taken for write. */
if|if
condition|(
operator|!
name|atomic_read
argument_list|(
operator|&
name|context
operator|->
name|notifier_count
argument_list|)
condition|)
block|{
name|list_for_each_entry_safe
argument_list|(
argument|odp_data
argument_list|,
argument|next
argument_list|,
argument|&context->no_private_counters
argument_list|,
argument|no_private_counters
argument_list|)
block|{
name|mutex_lock
argument_list|(
operator|&
name|odp_data
operator|->
name|umem_mutex
argument_list|)
expr_stmt|;
name|odp_data
operator|->
name|mn_counters_active
operator|=
name|true
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|odp_data
operator|->
name|no_private_counters
argument_list|)
expr_stmt|;
name|complete_all
argument_list|(
operator|&
name|odp_data
operator|->
name|notifier_completion
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|odp_data
operator|->
name|umem_mutex
argument_list|)
expr_stmt|;
block|}
block|}
name|up_write
argument_list|(
operator|&
name|context
operator|->
name|umem_rwsem
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ib_umem_notifier_release_trampoline
parameter_list|(
name|struct
name|ib_umem
modifier|*
name|item
parameter_list|,
name|u64
name|start
parameter_list|,
name|u64
name|end
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
comment|/* 	 * Increase the number of notifiers running, to 	 * prevent any further fault handling on this MR. 	 */
name|ib_umem_notifier_start_account
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|item
operator|->
name|odp_data
operator|->
name|dying
operator|=
literal|1
expr_stmt|;
comment|/* Make sure that the fact the umem is dying is out before we release 	 * all pending page faults. */
name|smp_wmb
argument_list|()
expr_stmt|;
name|complete_all
argument_list|(
operator|&
name|item
operator|->
name|odp_data
operator|->
name|notifier_completion
argument_list|)
expr_stmt|;
name|item
operator|->
name|context
operator|->
name|invalidate_range
argument_list|(
name|item
argument_list|,
name|ib_umem_start
argument_list|(
name|item
argument_list|)
argument_list|,
name|ib_umem_end
argument_list|(
name|item
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ib_umem_notifier_release
parameter_list|(
name|struct
name|mmu_notifier
modifier|*
name|mn
parameter_list|,
name|struct
name|mm_struct
modifier|*
name|mm
parameter_list|)
block|{
name|struct
name|ib_ucontext
modifier|*
name|context
init|=
name|container_of
argument_list|(
name|mn
argument_list|,
expr|struct
name|ib_ucontext
argument_list|,
name|mn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|context
operator|->
name|invalidate_range
condition|)
return|return;
name|ib_ucontext_notifier_start_account
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|down_read
argument_list|(
operator|&
name|context
operator|->
name|umem_rwsem
argument_list|)
expr_stmt|;
name|rbt_ib_umem_for_each_in_range
argument_list|(
operator|&
name|context
operator|->
name|umem_tree
argument_list|,
literal|0
argument_list|,
name|ULLONG_MAX
argument_list|,
name|ib_umem_notifier_release_trampoline
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|up_read
argument_list|(
operator|&
name|context
operator|->
name|umem_rwsem
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|invalidate_page_trampoline
parameter_list|(
name|struct
name|ib_umem
modifier|*
name|item
parameter_list|,
name|u64
name|start
parameter_list|,
name|u64
name|end
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|ib_umem_notifier_start_account
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|item
operator|->
name|context
operator|->
name|invalidate_range
argument_list|(
name|item
argument_list|,
name|start
argument_list|,
name|start
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|ib_umem_notifier_end_account
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ib_umem_notifier_invalidate_page
parameter_list|(
name|struct
name|mmu_notifier
modifier|*
name|mn
parameter_list|,
name|struct
name|mm_struct
modifier|*
name|mm
parameter_list|,
name|unsigned
name|long
name|address
parameter_list|)
block|{
name|struct
name|ib_ucontext
modifier|*
name|context
init|=
name|container_of
argument_list|(
name|mn
argument_list|,
expr|struct
name|ib_ucontext
argument_list|,
name|mn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|context
operator|->
name|invalidate_range
condition|)
return|return;
name|ib_ucontext_notifier_start_account
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|down_read
argument_list|(
operator|&
name|context
operator|->
name|umem_rwsem
argument_list|)
expr_stmt|;
name|rbt_ib_umem_for_each_in_range
argument_list|(
operator|&
name|context
operator|->
name|umem_tree
argument_list|,
name|address
argument_list|,
name|address
operator|+
name|PAGE_SIZE
argument_list|,
name|invalidate_page_trampoline
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|up_read
argument_list|(
operator|&
name|context
operator|->
name|umem_rwsem
argument_list|)
expr_stmt|;
name|ib_ucontext_notifier_end_account
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|invalidate_range_start_trampoline
parameter_list|(
name|struct
name|ib_umem
modifier|*
name|item
parameter_list|,
name|u64
name|start
parameter_list|,
name|u64
name|end
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|ib_umem_notifier_start_account
argument_list|(
name|item
argument_list|)
expr_stmt|;
name|item
operator|->
name|context
operator|->
name|invalidate_range
argument_list|(
name|item
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ib_umem_notifier_invalidate_range_start
parameter_list|(
name|struct
name|mmu_notifier
modifier|*
name|mn
parameter_list|,
name|struct
name|mm_struct
modifier|*
name|mm
parameter_list|,
name|unsigned
name|long
name|start
parameter_list|,
name|unsigned
name|long
name|end
parameter_list|)
block|{
name|struct
name|ib_ucontext
modifier|*
name|context
init|=
name|container_of
argument_list|(
name|mn
argument_list|,
expr|struct
name|ib_ucontext
argument_list|,
name|mn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|context
operator|->
name|invalidate_range
condition|)
return|return;
name|ib_ucontext_notifier_start_account
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|down_read
argument_list|(
operator|&
name|context
operator|->
name|umem_rwsem
argument_list|)
expr_stmt|;
name|rbt_ib_umem_for_each_in_range
argument_list|(
operator|&
name|context
operator|->
name|umem_tree
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|invalidate_range_start_trampoline
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|up_read
argument_list|(
operator|&
name|context
operator|->
name|umem_rwsem
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|invalidate_range_end_trampoline
parameter_list|(
name|struct
name|ib_umem
modifier|*
name|item
parameter_list|,
name|u64
name|start
parameter_list|,
name|u64
name|end
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|ib_umem_notifier_end_account
argument_list|(
name|item
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ib_umem_notifier_invalidate_range_end
parameter_list|(
name|struct
name|mmu_notifier
modifier|*
name|mn
parameter_list|,
name|struct
name|mm_struct
modifier|*
name|mm
parameter_list|,
name|unsigned
name|long
name|start
parameter_list|,
name|unsigned
name|long
name|end
parameter_list|)
block|{
name|struct
name|ib_ucontext
modifier|*
name|context
init|=
name|container_of
argument_list|(
name|mn
argument_list|,
expr|struct
name|ib_ucontext
argument_list|,
name|mn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|context
operator|->
name|invalidate_range
condition|)
return|return;
name|down_read
argument_list|(
operator|&
name|context
operator|->
name|umem_rwsem
argument_list|)
expr_stmt|;
name|rbt_ib_umem_for_each_in_range
argument_list|(
operator|&
name|context
operator|->
name|umem_tree
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|invalidate_range_end_trampoline
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|up_read
argument_list|(
operator|&
name|context
operator|->
name|umem_rwsem
argument_list|)
expr_stmt|;
name|ib_ucontext_notifier_end_account
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|mmu_notifier_ops
name|ib_umem_notifiers
init|=
block|{
operator|.
name|release
operator|=
name|ib_umem_notifier_release
block|,
operator|.
name|invalidate_page
operator|=
name|ib_umem_notifier_invalidate_page
block|,
operator|.
name|invalidate_range_start
operator|=
name|ib_umem_notifier_invalidate_range_start
block|,
operator|.
name|invalidate_range_end
operator|=
name|ib_umem_notifier_invalidate_range_end
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|ib_umem_odp_get
parameter_list|(
name|struct
name|ib_ucontext
modifier|*
name|context
parameter_list|,
name|struct
name|ib_umem
modifier|*
name|umem
parameter_list|)
block|{
name|int
name|ret_val
decl_stmt|;
name|pid_t
name|our_pid
decl_stmt|;
name|struct
name|mm_struct
modifier|*
name|mm
init|=
name|get_task_mm
argument_list|(
name|current
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|mm
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* Prevent creating ODP MRs in child processes */
name|rcu_read_lock
argument_list|()
expr_stmt|;
name|our_pid
operator|=
name|get_pid
argument_list|(
name|task_pid_group_leader
argument_list|(
name|current
argument_list|)
argument_list|)
expr_stmt|;
name|rcu_read_unlock
argument_list|()
expr_stmt|;
name|put_pid
argument_list|(
name|our_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|tgid
operator|!=
name|our_pid
condition|)
block|{
name|ret_val
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out_mm
goto|;
block|}
name|umem
operator|->
name|odp_data
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|umem
operator|->
name|odp_data
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|umem
operator|->
name|odp_data
condition|)
block|{
name|ret_val
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out_mm
goto|;
block|}
name|umem
operator|->
name|odp_data
operator|->
name|umem
operator|=
name|umem
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|umem
operator|->
name|odp_data
operator|->
name|umem_mutex
argument_list|)
expr_stmt|;
name|init_completion
argument_list|(
operator|&
name|umem
operator|->
name|odp_data
operator|->
name|notifier_completion
argument_list|)
expr_stmt|;
name|umem
operator|->
name|odp_data
operator|->
name|page_list
operator|=
name|vzalloc
argument_list|(
name|ib_umem_num_pages
argument_list|(
name|umem
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|umem
operator|->
name|odp_data
operator|->
name|page_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|umem
operator|->
name|odp_data
operator|->
name|page_list
condition|)
block|{
name|ret_val
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out_odp_data
goto|;
block|}
name|umem
operator|->
name|odp_data
operator|->
name|dma_list
operator|=
name|vzalloc
argument_list|(
name|ib_umem_num_pages
argument_list|(
name|umem
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|umem
operator|->
name|odp_data
operator|->
name|dma_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|umem
operator|->
name|odp_data
operator|->
name|dma_list
condition|)
block|{
name|ret_val
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out_page_list
goto|;
block|}
comment|/* 	 * When using MMU notifiers, we will get a 	 * notification before the "current" task (and MM) is 	 * destroyed. We use the umem_rwsem semaphore to synchronize. 	 */
name|down_write
argument_list|(
operator|&
name|context
operator|->
name|umem_rwsem
argument_list|)
expr_stmt|;
name|context
operator|->
name|odp_mrs_count
operator|++
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|ib_umem_start
argument_list|(
name|umem
argument_list|)
operator|!=
name|ib_umem_end
argument_list|(
name|umem
argument_list|)
argument_list|)
condition|)
name|rbt_ib_umem_insert
argument_list|(
operator|&
name|umem
operator|->
name|odp_data
operator|->
name|interval_tree
argument_list|,
operator|&
name|context
operator|->
name|umem_tree
argument_list|)
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
operator|!
name|atomic_read
argument_list|(
operator|&
name|context
operator|->
name|notifier_count
argument_list|)
argument_list|)
operator|||
name|context
operator|->
name|odp_mrs_count
operator|==
literal|1
condition|)
name|umem
operator|->
name|odp_data
operator|->
name|mn_counters_active
operator|=
name|true
expr_stmt|;
else|else
name|list_add
argument_list|(
operator|&
name|umem
operator|->
name|odp_data
operator|->
name|no_private_counters
argument_list|,
operator|&
name|context
operator|->
name|no_private_counters
argument_list|)
expr_stmt|;
name|downgrade_write
argument_list|(
operator|&
name|context
operator|->
name|umem_rwsem
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|->
name|odp_mrs_count
operator|==
literal|1
condition|)
block|{
comment|/* 		 * Note that at this point, no MMU notifier is running 		 * for this context! 		 */
name|atomic_set
argument_list|(
operator|&
name|context
operator|->
name|notifier_count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INIT_HLIST_NODE
argument_list|(
operator|&
name|context
operator|->
name|mn
operator|.
name|hlist
argument_list|)
expr_stmt|;
name|context
operator|->
name|mn
operator|.
name|ops
operator|=
operator|&
name|ib_umem_notifiers
expr_stmt|;
comment|/* 		 * Lock-dep detects a false positive for mmap_sem vs. 		 * umem_rwsem, due to not grasping downgrade_write correctly. 		 */
name|ret_val
operator|=
name|mmu_notifier_register
argument_list|(
operator|&
name|context
operator|->
name|mn
argument_list|,
name|mm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
name|pr_err
argument_list|(
literal|"Failed to register mmu_notifier %d\n"
argument_list|,
name|ret_val
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
name|EBUSY
expr_stmt|;
goto|goto
name|out_mutex
goto|;
block|}
block|}
name|up_read
argument_list|(
operator|&
name|context
operator|->
name|umem_rwsem
argument_list|)
expr_stmt|;
comment|/* 	 * Note that doing an mmput can cause a notifier for the relevant mm. 	 * If the notifier is called while we hold the umem_rwsem, this will 	 * cause a deadlock. Therefore, we release the reference only after we 	 * released the semaphore. 	 */
name|mmput
argument_list|(
name|mm
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|out_mutex
label|:
name|up_read
argument_list|(
operator|&
name|context
operator|->
name|umem_rwsem
argument_list|)
expr_stmt|;
name|vfree
argument_list|(
name|umem
operator|->
name|odp_data
operator|->
name|dma_list
argument_list|)
expr_stmt|;
name|out_page_list
label|:
name|vfree
argument_list|(
name|umem
operator|->
name|odp_data
operator|->
name|page_list
argument_list|)
expr_stmt|;
name|out_odp_data
label|:
name|kfree
argument_list|(
name|umem
operator|->
name|odp_data
argument_list|)
expr_stmt|;
name|out_mm
label|:
name|mmput
argument_list|(
name|mm
argument_list|)
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_function
name|void
name|ib_umem_odp_release
parameter_list|(
name|struct
name|ib_umem
modifier|*
name|umem
parameter_list|)
block|{
name|struct
name|ib_ucontext
modifier|*
name|context
init|=
name|umem
operator|->
name|context
decl_stmt|;
comment|/* 	 * Ensure that no more pages are mapped in the umem. 	 * 	 * It is the driver's responsibility to ensure, before calling us, 	 * that the hardware will not attempt to access the MR any more. 	 */
name|ib_umem_odp_unmap_dma_pages
argument_list|(
name|umem
argument_list|,
name|ib_umem_start
argument_list|(
name|umem
argument_list|)
argument_list|,
name|ib_umem_end
argument_list|(
name|umem
argument_list|)
argument_list|)
expr_stmt|;
name|down_write
argument_list|(
operator|&
name|context
operator|->
name|umem_rwsem
argument_list|)
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|ib_umem_start
argument_list|(
name|umem
argument_list|)
operator|!=
name|ib_umem_end
argument_list|(
name|umem
argument_list|)
argument_list|)
condition|)
name|rbt_ib_umem_remove
argument_list|(
operator|&
name|umem
operator|->
name|odp_data
operator|->
name|interval_tree
argument_list|,
operator|&
name|context
operator|->
name|umem_tree
argument_list|)
expr_stmt|;
name|context
operator|->
name|odp_mrs_count
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|umem
operator|->
name|odp_data
operator|->
name|mn_counters_active
condition|)
block|{
name|list_del
argument_list|(
operator|&
name|umem
operator|->
name|odp_data
operator|->
name|no_private_counters
argument_list|)
expr_stmt|;
name|complete_all
argument_list|(
operator|&
name|umem
operator|->
name|odp_data
operator|->
name|notifier_completion
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Downgrade the lock to a read lock. This ensures that the notifiers 	 * (who lock the mutex for reading) will be able to finish, and we 	 * will be able to enventually obtain the mmu notifiers SRCU. Note 	 * that since we are doing it atomically, no other user could register 	 * and unregister while we do the check. 	 */
name|downgrade_write
argument_list|(
operator|&
name|context
operator|->
name|umem_rwsem
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|context
operator|->
name|odp_mrs_count
condition|)
block|{
name|struct
name|task_struct
modifier|*
name|owning_process
init|=
name|NULL
decl_stmt|;
name|struct
name|mm_struct
modifier|*
name|owning_mm
init|=
name|NULL
decl_stmt|;
name|owning_process
operator|=
name|get_pid_task
argument_list|(
name|context
operator|->
name|tgid
argument_list|,
name|PIDTYPE_PID
argument_list|)
expr_stmt|;
if|if
condition|(
name|owning_process
operator|==
name|NULL
condition|)
comment|/* 			 * The process is already dead, notifier were removed 			 * already. 			 */
goto|goto
name|out
goto|;
name|owning_mm
operator|=
name|get_task_mm
argument_list|(
name|owning_process
argument_list|)
expr_stmt|;
if|if
condition|(
name|owning_mm
operator|==
name|NULL
condition|)
comment|/* 			 * The process' mm is already dead, notifier were 			 * removed already. 			 */
goto|goto
name|out_put_task
goto|;
name|mmu_notifier_unregister
argument_list|(
operator|&
name|context
operator|->
name|mn
argument_list|,
name|owning_mm
argument_list|)
expr_stmt|;
name|mmput
argument_list|(
name|owning_mm
argument_list|)
expr_stmt|;
name|out_put_task
label|:
name|put_task_struct
argument_list|(
name|owning_process
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|up_read
argument_list|(
operator|&
name|context
operator|->
name|umem_rwsem
argument_list|)
expr_stmt|;
name|vfree
argument_list|(
name|umem
operator|->
name|odp_data
operator|->
name|dma_list
argument_list|)
expr_stmt|;
name|vfree
argument_list|(
name|umem
operator|->
name|odp_data
operator|->
name|page_list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|umem
operator|->
name|odp_data
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|umem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map for DMA and insert a single page into the on-demand paging page tables.  *  * @umem: the umem to insert the page to.  * @page_index: index in the umem to add the page to.  * @page: the page struct to map and add.  * @access_mask: access permissions needed for this page.  * @current_seq: sequence number for synchronization with invalidations.  *               the sequence number is taken from  *               umem->odp_data->notifiers_seq.  *  * The function returns -EFAULT if the DMA mapping operation fails. It returns  * -EAGAIN if a concurrent invalidation prevents us from updating the page.  *  * The page is released via put_page even if the operation failed. For  * on-demand pinning, the page is released whenever it isn't stored in the  * umem.  */
end_comment

begin_function
specifier|static
name|int
name|ib_umem_odp_map_dma_single_page
parameter_list|(
name|struct
name|ib_umem
modifier|*
name|umem
parameter_list|,
name|int
name|page_index
parameter_list|,
name|u64
name|base_virt_addr
parameter_list|,
name|struct
name|page
modifier|*
name|page
parameter_list|,
name|u64
name|access_mask
parameter_list|,
name|unsigned
name|long
name|current_seq
parameter_list|)
block|{
name|struct
name|ib_device
modifier|*
name|dev
init|=
name|umem
operator|->
name|context
operator|->
name|device
decl_stmt|;
name|dma_addr_t
name|dma_addr
decl_stmt|;
name|int
name|stored_page
init|=
literal|0
decl_stmt|;
name|int
name|remove_existing_mapping
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* 	 * Note: we avoid writing if seq is different from the initial seq, to 	 * handle case of a racing notifier. This check also allows us to bail 	 * early if we have a notifier running in parallel with us. 	 */
if|if
condition|(
name|ib_umem_mmu_notifier_retry
argument_list|(
name|umem
argument_list|,
name|current_seq
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EAGAIN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|umem
operator|->
name|odp_data
operator|->
name|dma_list
index|[
name|page_index
index|]
operator|)
condition|)
block|{
name|dma_addr
operator|=
name|ib_dma_map_page
argument_list|(
name|dev
argument_list|,
name|page
argument_list|,
literal|0
argument_list|,
name|PAGE_SIZE
argument_list|,
name|DMA_BIDIRECTIONAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_dma_mapping_error
argument_list|(
name|dev
argument_list|,
name|dma_addr
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|umem
operator|->
name|odp_data
operator|->
name|dma_list
index|[
name|page_index
index|]
operator|=
name|dma_addr
operator||
name|access_mask
expr_stmt|;
name|umem
operator|->
name|odp_data
operator|->
name|page_list
index|[
name|page_index
index|]
operator|=
name|page
expr_stmt|;
name|stored_page
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|umem
operator|->
name|odp_data
operator|->
name|page_list
index|[
name|page_index
index|]
operator|==
name|page
condition|)
block|{
name|umem
operator|->
name|odp_data
operator|->
name|dma_list
index|[
name|page_index
index|]
operator||=
name|access_mask
expr_stmt|;
block|}
else|else
block|{
name|pr_err
argument_list|(
literal|"error: got different pages in IB device and from get_user_pages. IB device page: %p, gup page: %p\n"
argument_list|,
name|umem
operator|->
name|odp_data
operator|->
name|page_list
index|[
name|page_index
index|]
argument_list|,
name|page
argument_list|)
expr_stmt|;
comment|/* Better remove the mapping now, to prevent any further 		 * damage. */
name|remove_existing_mapping
operator|=
literal|1
expr_stmt|;
block|}
name|out
label|:
comment|/* On Demand Paging - avoid pinning the page */
if|if
condition|(
name|umem
operator|->
name|context
operator|->
name|invalidate_range
operator|||
operator|!
name|stored_page
condition|)
name|put_page
argument_list|(
name|page
argument_list|)
expr_stmt|;
if|if
condition|(
name|remove_existing_mapping
operator|&&
name|umem
operator|->
name|context
operator|->
name|invalidate_range
condition|)
block|{
name|invalidate_page_trampoline
argument_list|(
name|umem
argument_list|,
name|base_virt_addr
operator|+
operator|(
name|page_index
operator|*
name|PAGE_SIZE
operator|)
argument_list|,
name|base_virt_addr
operator|+
operator|(
operator|(
name|page_index
operator|+
literal|1
operator|)
operator|*
name|PAGE_SIZE
operator|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|EAGAIN
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * ib_umem_odp_map_dma_pages - Pin and DMA map userspace memory in an ODP MR.  *  * Pins the range of pages passed in the argument, and maps them to  * DMA addresses. The DMA addresses of the mapped pages is updated in  * umem->odp_data->dma_list.  *  * Returns the number of pages mapped in success, negative error code  * for failure.  * An -EAGAIN error code is returned when a concurrent mmu notifier prevents  * the function from completing its task.  *  * @umem: the umem to map and pin  * @user_virt: the address from which we need to map.  * @bcnt: the minimal number of bytes to pin and map. The mapping might be  *        bigger due to alignment, and may also be smaller in case of an error  *        pinning or mapping a page. The actual pages mapped is returned in  *        the return value.  * @access_mask: bit mask of the requested access permissions for the given  *               range.  * @current_seq: the MMU notifiers sequance value for synchronization with  *               invalidations. the sequance number is read from  *               umem->odp_data->notifiers_seq before calling this function  */
end_comment

begin_function
name|int
name|ib_umem_odp_map_dma_pages
parameter_list|(
name|struct
name|ib_umem
modifier|*
name|umem
parameter_list|,
name|u64
name|user_virt
parameter_list|,
name|u64
name|bcnt
parameter_list|,
name|u64
name|access_mask
parameter_list|,
name|unsigned
name|long
name|current_seq
parameter_list|)
block|{
name|struct
name|task_struct
modifier|*
name|owning_process
init|=
name|NULL
decl_stmt|;
name|struct
name|mm_struct
modifier|*
name|owning_mm
init|=
name|NULL
decl_stmt|;
name|struct
name|page
modifier|*
modifier|*
name|local_page_list
init|=
name|NULL
decl_stmt|;
name|u64
name|off
decl_stmt|;
name|int
name|j
decl_stmt|,
name|k
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|,
name|start_idx
decl_stmt|,
name|npages
init|=
literal|0
decl_stmt|;
name|u64
name|base_virt_addr
decl_stmt|;
name|unsigned
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|access_mask
operator|==
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|user_virt
operator|<
name|ib_umem_start
argument_list|(
name|umem
argument_list|)
operator|||
name|user_virt
operator|+
name|bcnt
operator|>
name|ib_umem_end
argument_list|(
name|umem
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
name|local_page_list
operator|=
operator|(
expr|struct
name|page
operator|*
operator|*
operator|)
name|__get_free_page
argument_list|(
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_page_list
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|off
operator|=
name|user_virt
operator|&
operator|(
operator|~
name|PAGE_MASK
operator|)
expr_stmt|;
name|user_virt
operator|=
name|user_virt
operator|&
name|PAGE_MASK
expr_stmt|;
name|base_virt_addr
operator|=
name|user_virt
expr_stmt|;
name|bcnt
operator|+=
name|off
expr_stmt|;
comment|/* Charge for the first page offset as well. */
name|owning_process
operator|=
name|get_pid_task
argument_list|(
name|umem
operator|->
name|context
operator|->
name|tgid
argument_list|,
name|PIDTYPE_PID
argument_list|)
expr_stmt|;
if|if
condition|(
name|owning_process
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out_no_task
goto|;
block|}
name|owning_mm
operator|=
name|get_task_mm
argument_list|(
name|owning_process
argument_list|)
expr_stmt|;
if|if
condition|(
name|owning_mm
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out_put_task
goto|;
block|}
if|if
condition|(
name|access_mask
operator|&
name|ODP_WRITE_ALLOWED_BIT
condition|)
name|flags
operator||=
name|FOLL_WRITE
expr_stmt|;
name|start_idx
operator|=
operator|(
name|user_virt
operator|-
name|ib_umem_start
argument_list|(
name|umem
argument_list|)
operator|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|k
operator|=
name|start_idx
expr_stmt|;
while|while
condition|(
name|bcnt
operator|>
literal|0
condition|)
block|{
specifier|const
name|size_t
name|gup_num_pages
init|=
name|min_t
argument_list|(
name|size_t
argument_list|,
name|ALIGN
argument_list|(
name|bcnt
argument_list|,
name|PAGE_SIZE
argument_list|)
operator|/
name|PAGE_SIZE
argument_list|,
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|page
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|down_read
argument_list|(
operator|&
name|owning_mm
operator|->
name|mmap_sem
argument_list|)
expr_stmt|;
comment|/* 		 * Note: this might result in redundent page getting. We can 		 * avoid this by checking dma_list to be 0 before calling 		 * get_user_pages. However, this make the code much more 		 * complex (and doesn't gain us much performance in most use 		 * cases). 		 */
name|npages
operator|=
name|get_user_pages_remote
argument_list|(
name|owning_process
argument_list|,
name|owning_mm
argument_list|,
name|user_virt
argument_list|,
name|gup_num_pages
argument_list|,
name|flags
argument_list|,
name|local_page_list
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|up_read
argument_list|(
operator|&
name|owning_mm
operator|->
name|mmap_sem
argument_list|)
expr_stmt|;
if|if
condition|(
name|npages
operator|<
literal|0
condition|)
break|break;
name|bcnt
operator|-=
name|min_t
argument_list|(
name|size_t
argument_list|,
name|npages
operator|<<
name|PAGE_SHIFT
argument_list|,
name|bcnt
argument_list|)
expr_stmt|;
name|user_virt
operator|+=
name|npages
operator|<<
name|PAGE_SHIFT
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|umem
operator|->
name|odp_data
operator|->
name|umem_mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|npages
condition|;
operator|++
name|j
control|)
block|{
name|ret
operator|=
name|ib_umem_odp_map_dma_single_page
argument_list|(
name|umem
argument_list|,
name|k
argument_list|,
name|base_virt_addr
argument_list|,
name|local_page_list
index|[
name|j
index|]
argument_list|,
name|access_mask
argument_list|,
name|current_seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
break|break;
name|k
operator|++
expr_stmt|;
block|}
name|mutex_unlock
argument_list|(
operator|&
name|umem
operator|->
name|odp_data
operator|->
name|umem_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/* Release left over pages when handling errors. */
for|for
control|(
operator|++
name|j
init|;
name|j
operator|<
name|npages
condition|;
operator|++
name|j
control|)
name|put_page
argument_list|(
name|local_page_list
index|[
name|j
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|npages
operator|<
literal|0
operator|&&
name|k
operator|==
name|start_idx
condition|)
name|ret
operator|=
name|npages
expr_stmt|;
else|else
name|ret
operator|=
name|k
operator|-
name|start_idx
expr_stmt|;
block|}
name|mmput
argument_list|(
name|owning_mm
argument_list|)
expr_stmt|;
name|out_put_task
label|:
name|put_task_struct
argument_list|(
name|owning_process
argument_list|)
expr_stmt|;
name|out_no_task
label|:
name|free_page
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|local_page_list
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_umem_odp_map_dma_pages
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|ib_umem_odp_unmap_dma_pages
parameter_list|(
name|struct
name|ib_umem
modifier|*
name|umem
parameter_list|,
name|u64
name|virt
parameter_list|,
name|u64
name|bound
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|u64
name|addr
decl_stmt|;
name|struct
name|ib_device
modifier|*
name|dev
init|=
name|umem
operator|->
name|context
operator|->
name|device
decl_stmt|;
name|virt
operator|=
name|max_t
argument_list|(
name|u64
argument_list|,
name|virt
argument_list|,
name|ib_umem_start
argument_list|(
name|umem
argument_list|)
argument_list|)
expr_stmt|;
name|bound
operator|=
name|min_t
argument_list|(
name|u64
argument_list|,
name|bound
argument_list|,
name|ib_umem_end
argument_list|(
name|umem
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note that during the run of this function, the 	 * notifiers_count of the MR is> 0, preventing any racing 	 * faults from completion. We might be racing with other 	 * invalidations, so we must make sure we free each page only 	 * once. */
name|mutex_lock
argument_list|(
operator|&
name|umem
operator|->
name|odp_data
operator|->
name|umem_mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|addr
operator|=
name|virt
init|;
name|addr
operator|<
name|bound
condition|;
name|addr
operator|+=
operator|(
name|u64
operator|)
name|umem
operator|->
name|page_size
control|)
block|{
name|idx
operator|=
operator|(
name|addr
operator|-
name|ib_umem_start
argument_list|(
name|umem
argument_list|)
operator|)
operator|/
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|umem
operator|->
name|odp_data
operator|->
name|page_list
index|[
name|idx
index|]
condition|)
block|{
name|struct
name|page
modifier|*
name|page
init|=
name|umem
operator|->
name|odp_data
operator|->
name|page_list
index|[
name|idx
index|]
decl_stmt|;
name|dma_addr_t
name|dma
init|=
name|umem
operator|->
name|odp_data
operator|->
name|dma_list
index|[
name|idx
index|]
decl_stmt|;
name|dma_addr_t
name|dma_addr
init|=
name|dma
operator|&
name|ODP_DMA_ADDR_MASK
decl_stmt|;
name|WARN_ON
argument_list|(
operator|!
name|dma_addr
argument_list|)
expr_stmt|;
name|ib_dma_unmap_page
argument_list|(
name|dev
argument_list|,
name|dma_addr
argument_list|,
name|PAGE_SIZE
argument_list|,
name|DMA_BIDIRECTIONAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|dma
operator|&
name|ODP_WRITE_ALLOWED_BIT
condition|)
block|{
name|struct
name|page
modifier|*
name|head_page
init|=
name|compound_head
argument_list|(
name|page
argument_list|)
decl_stmt|;
comment|/* 				 * set_page_dirty prefers being called with 				 * the page lock. However, MMU notifiers are 				 * called sometimes with and sometimes without 				 * the lock. We rely on the umem_mutex instead 				 * to prevent other mmu notifiers from 				 * continuing and allowing the page mapping to 				 * be removed. 				 */
name|set_page_dirty
argument_list|(
name|head_page
argument_list|)
expr_stmt|;
block|}
comment|/* on demand pinning support */
if|if
condition|(
operator|!
name|umem
operator|->
name|context
operator|->
name|invalidate_range
condition|)
name|put_page
argument_list|(
name|page
argument_list|)
expr_stmt|;
name|umem
operator|->
name|odp_data
operator|->
name|page_list
index|[
name|idx
index|]
operator|=
name|NULL
expr_stmt|;
name|umem
operator|->
name|odp_data
operator|->
name|dma_list
index|[
name|idx
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|mutex_unlock
argument_list|(
operator|&
name|umem
operator|->
name|odp_data
operator|->
name|umem_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_umem_odp_unmap_dma_pages
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

