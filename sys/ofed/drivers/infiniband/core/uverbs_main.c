begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2005 Topspin Communications.  All rights reserved.  * Copyright (c) 2005, 2006 Cisco Systems.  All rights reserved.  * Copyright (c) 2005 Mellanox Technologies. All rights reserved.  * Copyright (c) 2005 Voltaire, Inc. All rights reserved.  * Copyright (c) 2005 PathScale, Inc. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/device.h>
end_include

begin_include
include|#
directive|include
file|<linux/err.h>
end_include

begin_include
include|#
directive|include
file|<linux/fs.h>
end_include

begin_include
include|#
directive|include
file|<linux/poll.h>
end_include

begin_include
include|#
directive|include
file|<linux/sched.h>
end_include

begin_include
include|#
directive|include
file|<linux/file.h>
end_include

begin_include
include|#
directive|include
file|<linux/cdev.h>
end_include

begin_include
include|#
directive|include
file|<linux/slab.h>
end_include

begin_include
include|#
directive|include
file|<linux/ktime.h>
end_include

begin_include
include|#
directive|include
file|<linux/rbtree.h>
end_include

begin_include
include|#
directive|include
file|<linux/math64.h>
end_include

begin_include
include|#
directive|include
file|<asm/uaccess.h>
end_include

begin_include
include|#
directive|include
file|"uverbs.h"
end_include

begin_expr_stmt
name|MODULE_AUTHOR
argument_list|(
literal|"Roland Dreier"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DESCRIPTION
argument_list|(
literal|"InfiniBand userspace verbs access"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_LICENSE
argument_list|(
literal|"Dual BSD/GPL"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_enum
enum|enum
block|{
name|IB_UVERBS_MAJOR
init|=
literal|231
block|,
name|IB_UVERBS_BASE_MINOR
init|=
literal|192
block|,
name|IB_UVERBS_MAX_DEVICES
init|=
literal|32
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|IB_UVERBS_BASE_DEV
value|MKDEV(IB_UVERBS_MAJOR, IB_UVERBS_BASE_MINOR)
end_define

begin_function
specifier|static
name|int
name|uverbs_copy_from_udata_ex
parameter_list|(
name|void
modifier|*
name|dest
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|copy_from_user
argument_list|(
name|dest
argument_list|,
name|udata
operator|->
name|inbuf
argument_list|,
name|min
argument_list|(
name|udata
operator|->
name|inlen
argument_list|,
name|len
argument_list|)
argument_list|)
condition|?
operator|-
name|EFAULT
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|uverbs_copy_to_udata_ex
parameter_list|(
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|,
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
return|return
name|copy_to_user
argument_list|(
name|udata
operator|->
name|outbuf
argument_list|,
name|src
argument_list|,
name|min
argument_list|(
name|udata
operator|->
name|outlen
argument_list|,
name|len
argument_list|)
argument_list|)
condition|?
operator|-
name|EFAULT
else|:
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|ib_udata_ops
name|uverbs_copy_ex
init|=
block|{
operator|.
name|copy_from
operator|=
name|uverbs_copy_from_udata_ex
block|,
operator|.
name|copy_to
operator|=
name|uverbs_copy_to_udata_ex
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INIT_UDATA_EX
parameter_list|(
name|udata
parameter_list|,
name|ibuf
parameter_list|,
name|obuf
parameter_list|,
name|ilen
parameter_list|,
name|olen
parameter_list|)
define|\
value|do {							\ 		(udata)->ops    =&uverbs_copy_ex;		\ 		(udata)->inbuf  = (void __user *)(unsigned long)(ibuf);	\ 		(udata)->outbuf = (void __user *)(unsigned long)(obuf);	\ 		(udata)->inlen  = (ilen);			\ 		(udata)->outlen = (olen);			\ 	} while (0)
end_define

begin_decl_stmt
specifier|static
name|struct
name|class
modifier|*
name|uverbs_class
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_SPINLOCK
argument_list|(
name|ib_uverbs_idr_lock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_IDR
argument_list|(
name|ib_uverbs_pd_idr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_IDR
argument_list|(
name|ib_uverbs_mr_idr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_IDR
argument_list|(
name|ib_uverbs_mw_idr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_IDR
argument_list|(
name|ib_uverbs_ah_idr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_IDR
argument_list|(
name|ib_uverbs_cq_idr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_IDR
argument_list|(
name|ib_uverbs_qp_idr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_IDR
argument_list|(
name|ib_uverbs_srq_idr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_IDR
argument_list|(
name|ib_uverbs_xrcd_idr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_IDR
argument_list|(
name|ib_uverbs_rule_idr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_IDR
argument_list|(
name|ib_uverbs_dct_idr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|DEFINE_SPINLOCK
argument_list|(
name|map_lock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|DECLARE_BITMAP
argument_list|(
name|dev_map
argument_list|,
name|IB_UVERBS_MAX_DEVICES
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|ssize_t
function_decl|(
modifier|*
name|uverbs_cmd_table
index|[]
function_decl|)
parameter_list|(
name|struct
name|ib_uverbs_file
modifier|*
name|file
parameter_list|,
specifier|const
name|char
name|__user
modifier|*
name|buf
parameter_list|,
name|int
name|in_len
parameter_list|,
name|int
name|out_len
parameter_list|)
init|=
block|{
index|[
name|IB_USER_VERBS_CMD_GET_CONTEXT
index|]
operator|=
name|ib_uverbs_get_context
operator|,
function_decl|[IB_USER_VERBS_CMD_QUERY_DEVICE]
init|=
name|ib_uverbs_query_device
operator|,
function_decl|[IB_USER_VERBS_CMD_QUERY_PORT]
init|=
name|ib_uverbs_query_port
operator|,
function_decl|[IB_USER_VERBS_CMD_ALLOC_PD]
init|=
name|ib_uverbs_alloc_pd
operator|,
function_decl|[IB_USER_VERBS_CMD_DEALLOC_PD]
init|=
name|ib_uverbs_dealloc_pd
operator|,
function_decl|[IB_USER_VERBS_CMD_REG_MR]
init|=
name|ib_uverbs_reg_mr
operator|,
function_decl|[IB_USER_VERBS_CMD_DEREG_MR]
init|=
name|ib_uverbs_dereg_mr
operator|,
function_decl|[IB_USER_VERBS_CMD_ALLOC_MW]
init|=
name|ib_uverbs_alloc_mw
operator|,
function_decl|[IB_USER_VERBS_CMD_DEALLOC_MW]
init|=
name|ib_uverbs_dealloc_mw
operator|,
function_decl|[IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL]
init|=
name|ib_uverbs_create_comp_channel
operator|,
function_decl|[IB_USER_VERBS_CMD_CREATE_CQ]
init|=
name|ib_uverbs_create_cq
operator|,
function_decl|[IB_USER_VERBS_CMD_RESIZE_CQ]
init|=
name|ib_uverbs_resize_cq
operator|,
function_decl|[IB_USER_VERBS_CMD_POLL_CQ]
init|=
name|ib_uverbs_poll_cq
operator|,
function_decl|[IB_USER_VERBS_CMD_REQ_NOTIFY_CQ]
init|=
name|ib_uverbs_req_notify_cq
operator|,
function_decl|[IB_USER_VERBS_CMD_DESTROY_CQ]
init|=
name|ib_uverbs_destroy_cq
operator|,
function_decl|[IB_USER_VERBS_CMD_CREATE_QP]
init|=
name|ib_uverbs_create_qp
operator|,
function_decl|[IB_USER_VERBS_CMD_QUERY_QP]
init|=
name|ib_uverbs_query_qp
operator|,
function_decl|[IB_USER_VERBS_CMD_MODIFY_QP]
init|=
name|ib_uverbs_modify_qp
operator|,
function_decl|[IB_USER_VERBS_CMD_DESTROY_QP]
init|=
name|ib_uverbs_destroy_qp
operator|,
function_decl|[IB_USER_VERBS_CMD_POST_SEND]
init|=
name|ib_uverbs_post_send
operator|,
function_decl|[IB_USER_VERBS_CMD_POST_RECV]
init|=
name|ib_uverbs_post_recv
operator|,
function_decl|[IB_USER_VERBS_CMD_POST_SRQ_RECV]
init|=
name|ib_uverbs_post_srq_recv
operator|,
function_decl|[IB_USER_VERBS_CMD_CREATE_AH]
init|=
name|ib_uverbs_create_ah
operator|,
function_decl|[IB_USER_VERBS_CMD_DESTROY_AH]
init|=
name|ib_uverbs_destroy_ah
operator|,
function_decl|[IB_USER_VERBS_CMD_ATTACH_MCAST]
init|=
name|ib_uverbs_attach_mcast
operator|,
function_decl|[IB_USER_VERBS_CMD_DETACH_MCAST]
init|=
name|ib_uverbs_detach_mcast
operator|,
function_decl|[IB_USER_VERBS_CMD_CREATE_SRQ]
init|=
name|ib_uverbs_create_srq
operator|,
function_decl|[IB_USER_VERBS_CMD_MODIFY_SRQ]
init|=
name|ib_uverbs_modify_srq
operator|,
function_decl|[IB_USER_VERBS_CMD_QUERY_SRQ]
init|=
name|ib_uverbs_query_srq
operator|,
function_decl|[IB_USER_VERBS_CMD_DESTROY_SRQ]
init|=
name|ib_uverbs_destroy_srq
operator|,
function_decl|[IB_USER_VERBS_CMD_OPEN_XRCD]
init|=
name|ib_uverbs_open_xrcd
operator|,
function_decl|[IB_USER_VERBS_CMD_CLOSE_XRCD]
init|=
name|ib_uverbs_close_xrcd
operator|,
function_decl|[IB_USER_VERBS_CMD_CREATE_XSRQ]
init|=
name|ib_uverbs_create_xsrq
operator|,
function_decl|[IB_USER_VERBS_CMD_OPEN_QP]
init|=
name|ib_uverbs_open_qp
operator|,
end_function_decl

begin_function_decl
unit|};
specifier|static
name|int
function_decl|(
modifier|*
name|uverbs_ex_cmd_table
index|[]
function_decl|)
parameter_list|(
name|struct
name|ib_uverbs_file
modifier|*
name|file
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|ucore
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|uhw
parameter_list|)
init|=
block|{
index|[
name|IB_USER_VERBS_EX_CMD_CREATE_FLOW
index|]
operator|=
name|ib_uverbs_ex_create_flow
operator|,
function_decl|[IB_USER_VERBS_EX_CMD_DESTROY_FLOW]
init|=
name|ib_uverbs_ex_destroy_flow
operator|,
end_function_decl

begin_function_decl
unit|};
specifier|static
name|ssize_t
function_decl|(
modifier|*
name|uverbs_exp_cmd_table
index|[]
function_decl|)
parameter_list|(
name|struct
name|ib_uverbs_file
modifier|*
name|file
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|ucore
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|uhw
parameter_list|)
init|=
block|{
index|[
name|IB_USER_VERBS_EXP_CMD_CREATE_QP
index|]
operator|=
name|ib_uverbs_exp_create_qp
operator|,
function_decl|[IB_USER_VERBS_EXP_CMD_MODIFY_CQ]
init|=
name|ib_uverbs_exp_modify_cq
operator|,
function_decl|[IB_USER_VERBS_EXP_CMD_MODIFY_QP]
init|=
name|ib_uverbs_exp_modify_qp
operator|,
function_decl|[IB_USER_VERBS_EXP_CMD_CREATE_CQ]
init|=
name|ib_uverbs_exp_create_cq
operator|,
function_decl|[IB_USER_VERBS_EXP_CMD_QUERY_DEVICE]
init|=
name|ib_uverbs_exp_query_device
operator|,
function_decl|[IB_USER_VERBS_EXP_CMD_CREATE_DCT]
init|=
name|ib_uverbs_exp_create_dct
operator|,
function_decl|[IB_USER_VERBS_EXP_CMD_DESTROY_DCT]
init|=
name|ib_uverbs_exp_destroy_dct
operator|,
function_decl|[IB_USER_VERBS_EXP_CMD_QUERY_DCT]
init|=
name|ib_uverbs_exp_query_dct
operator|,
end_function_decl

begin_function_decl
unit|};
specifier|static
name|void
name|ib_uverbs_add_one
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ib_uverbs_remove_one
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|ib_uverbs_release_dev
parameter_list|(
name|struct
name|kref
modifier|*
name|ref
parameter_list|)
block|{
name|struct
name|ib_uverbs_device
modifier|*
name|dev
init|=
name|container_of
argument_list|(
name|ref
argument_list|,
expr|struct
name|ib_uverbs_device
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|complete
argument_list|(
operator|&
name|dev
operator|->
name|comp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ib_uverbs_release_event_file
parameter_list|(
name|struct
name|kref
modifier|*
name|ref
parameter_list|)
block|{
name|struct
name|ib_uverbs_event_file
modifier|*
name|file
init|=
name|container_of
argument_list|(
name|ref
argument_list|,
expr|struct
name|ib_uverbs_event_file
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|kfree
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ib_uverbs_release_ucq
parameter_list|(
name|struct
name|ib_uverbs_file
modifier|*
name|file
parameter_list|,
name|struct
name|ib_uverbs_event_file
modifier|*
name|ev_file
parameter_list|,
name|struct
name|ib_ucq_object
modifier|*
name|uobj
parameter_list|)
block|{
name|struct
name|ib_uverbs_event
modifier|*
name|evt
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
name|ev_file
condition|)
block|{
name|spin_lock_irq
argument_list|(
operator|&
name|ev_file
operator|->
name|lock
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|evt
argument_list|,
argument|tmp
argument_list|,
argument|&uobj->comp_list
argument_list|,
argument|obj_list
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|evt
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|evt
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irq
argument_list|(
operator|&
name|ev_file
operator|->
name|lock
argument_list|)
expr_stmt|;
name|kref_put
argument_list|(
operator|&
name|ev_file
operator|->
name|ref
argument_list|,
name|ib_uverbs_release_event_file
argument_list|)
expr_stmt|;
block|}
name|spin_lock_irq
argument_list|(
operator|&
name|file
operator|->
name|async_file
operator|->
name|lock
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|evt
argument_list|,
argument|tmp
argument_list|,
argument|&uobj->async_list
argument_list|,
argument|obj_list
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|evt
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|evt
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irq
argument_list|(
operator|&
name|file
operator|->
name|async_file
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ib_uverbs_release_uevent
parameter_list|(
name|struct
name|ib_uverbs_file
modifier|*
name|file
parameter_list|,
name|struct
name|ib_uevent_object
modifier|*
name|uobj
parameter_list|)
block|{
name|struct
name|ib_uverbs_event
modifier|*
name|evt
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|spin_lock_irq
argument_list|(
operator|&
name|file
operator|->
name|async_file
operator|->
name|lock
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|evt
argument_list|,
argument|tmp
argument_list|,
argument|&uobj->event_list
argument_list|,
argument|obj_list
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|evt
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|evt
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irq
argument_list|(
operator|&
name|file
operator|->
name|async_file
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ib_uverbs_detach_umcast
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_uqp_object
modifier|*
name|uobj
parameter_list|)
block|{
name|struct
name|ib_uverbs_mcast_entry
modifier|*
name|mcast
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|mcast
argument_list|,
argument|tmp
argument_list|,
argument|&uobj->mcast_list
argument_list|,
argument|list
argument_list|)
block|{
name|ib_detach_mcast
argument_list|(
name|qp
argument_list|,
operator|&
name|mcast
operator|->
name|gid
argument_list|,
name|mcast
operator|->
name|lid
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|mcast
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mcast
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ib_uverbs_cleanup_ucontext
parameter_list|(
name|struct
name|ib_uverbs_file
modifier|*
name|file
parameter_list|,
name|struct
name|ib_ucontext
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|ib_uobject
modifier|*
name|uobj
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
return|return
literal|0
return|;
name|context
operator|->
name|closing
operator|=
literal|1
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|uobj
argument_list|,
argument|tmp
argument_list|,
argument|&context->ah_list
argument_list|,
argument|list
argument_list|)
block|{
name|struct
name|ib_ah
modifier|*
name|ah
init|=
name|uobj
operator|->
name|object
decl_stmt|;
name|idr_remove_uobj
argument_list|(
operator|&
name|ib_uverbs_ah_idr
argument_list|,
name|uobj
argument_list|)
expr_stmt|;
name|ib_destroy_ah
argument_list|(
name|ah
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|uobj
argument_list|)
expr_stmt|;
block|}
comment|/* Remove MWs before QPs, in order to support type 2A MWs. */
name|list_for_each_entry_safe
argument_list|(
argument|uobj
argument_list|,
argument|tmp
argument_list|,
argument|&context->mw_list
argument_list|,
argument|list
argument_list|)
block|{
name|struct
name|ib_mw
modifier|*
name|mw
init|=
name|uobj
operator|->
name|object
decl_stmt|;
name|idr_remove_uobj
argument_list|(
operator|&
name|ib_uverbs_mw_idr
argument_list|,
name|uobj
argument_list|)
expr_stmt|;
name|err
operator|=
name|ib_dealloc_mw
argument_list|(
name|mw
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|pr_info
argument_list|(
literal|"user_verbs: couldn't deallocate MW during cleanup.\n"
argument_list|)
expr_stmt|;
name|pr_info
argument_list|(
literal|"user_verbs: the system may have become unstable.\n"
argument_list|)
expr_stmt|;
block|}
name|kfree
argument_list|(
name|uobj
argument_list|)
expr_stmt|;
block|}
name|list_for_each_entry_safe
argument_list|(
argument|uobj
argument_list|,
argument|tmp
argument_list|,
argument|&context->rule_list
argument_list|,
argument|list
argument_list|)
block|{
name|struct
name|ib_flow
modifier|*
name|flow_id
init|=
name|uobj
operator|->
name|object
decl_stmt|;
name|idr_remove_uobj
argument_list|(
operator|&
name|ib_uverbs_rule_idr
argument_list|,
name|uobj
argument_list|)
expr_stmt|;
name|ib_destroy_flow
argument_list|(
name|flow_id
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|uobj
argument_list|)
expr_stmt|;
block|}
name|list_for_each_entry_safe
argument_list|(
argument|uobj
argument_list|,
argument|tmp
argument_list|,
argument|&context->qp_list
argument_list|,
argument|list
argument_list|)
block|{
name|struct
name|ib_qp
modifier|*
name|qp
init|=
name|uobj
operator|->
name|object
decl_stmt|;
name|struct
name|ib_uqp_object
modifier|*
name|uqp
init|=
name|container_of
argument_list|(
name|uobj
argument_list|,
expr|struct
name|ib_uqp_object
argument_list|,
name|uevent
operator|.
name|uobject
argument_list|)
decl_stmt|;
name|idr_remove_uobj
argument_list|(
operator|&
name|ib_uverbs_qp_idr
argument_list|,
name|uobj
argument_list|)
expr_stmt|;
name|ib_uverbs_detach_umcast
argument_list|(
name|qp
argument_list|,
name|uqp
argument_list|)
expr_stmt|;
name|err
operator|=
name|ib_destroy_qp
argument_list|(
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|pr_info
argument_list|(
literal|"destroying uverbs qp failed: err %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|ib_uverbs_release_uevent
argument_list|(
name|file
argument_list|,
operator|&
name|uqp
operator|->
name|uevent
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|uqp
argument_list|)
expr_stmt|;
block|}
name|list_for_each_entry_safe
argument_list|(
argument|uobj
argument_list|,
argument|tmp
argument_list|,
argument|&context->dct_list
argument_list|,
argument|list
argument_list|)
block|{
name|struct
name|ib_dct
modifier|*
name|dct
init|=
name|uobj
operator|->
name|object
decl_stmt|;
name|struct
name|ib_udct_object
modifier|*
name|udct
init|=
name|container_of
argument_list|(
name|uobj
argument_list|,
expr|struct
name|ib_udct_object
argument_list|,
name|uobject
argument_list|)
decl_stmt|;
name|idr_remove_uobj
argument_list|(
operator|&
name|ib_uverbs_dct_idr
argument_list|,
name|uobj
argument_list|)
expr_stmt|;
name|err
operator|=
name|ib_destroy_dct
argument_list|(
name|dct
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|pr_info
argument_list|(
literal|"destroying uverbs dct failed: err %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|udct
argument_list|)
expr_stmt|;
block|}
name|list_for_each_entry_safe
argument_list|(
argument|uobj
argument_list|,
argument|tmp
argument_list|,
argument|&context->srq_list
argument_list|,
argument|list
argument_list|)
block|{
name|struct
name|ib_srq
modifier|*
name|srq
init|=
name|uobj
operator|->
name|object
decl_stmt|;
name|struct
name|ib_uevent_object
modifier|*
name|uevent
init|=
name|container_of
argument_list|(
name|uobj
argument_list|,
expr|struct
name|ib_uevent_object
argument_list|,
name|uobject
argument_list|)
decl_stmt|;
name|idr_remove_uobj
argument_list|(
operator|&
name|ib_uverbs_srq_idr
argument_list|,
name|uobj
argument_list|)
expr_stmt|;
name|err
operator|=
name|ib_destroy_srq
argument_list|(
name|srq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|pr_info
argument_list|(
literal|"destroying uverbs srq failed: err %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|ib_uverbs_release_uevent
argument_list|(
name|file
argument_list|,
name|uevent
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|uevent
argument_list|)
expr_stmt|;
block|}
name|list_for_each_entry_safe
argument_list|(
argument|uobj
argument_list|,
argument|tmp
argument_list|,
argument|&context->cq_list
argument_list|,
argument|list
argument_list|)
block|{
name|struct
name|ib_cq
modifier|*
name|cq
init|=
name|uobj
operator|->
name|object
decl_stmt|;
name|struct
name|ib_uverbs_event_file
modifier|*
name|ev_file
init|=
name|cq
operator|->
name|cq_context
decl_stmt|;
name|struct
name|ib_ucq_object
modifier|*
name|ucq
init|=
name|container_of
argument_list|(
name|uobj
argument_list|,
expr|struct
name|ib_ucq_object
argument_list|,
name|uobject
argument_list|)
decl_stmt|;
name|idr_remove_uobj
argument_list|(
operator|&
name|ib_uverbs_cq_idr
argument_list|,
name|uobj
argument_list|)
expr_stmt|;
name|err
operator|=
name|ib_destroy_cq
argument_list|(
name|cq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|pr_info
argument_list|(
literal|"destroying uverbs cq failed: err %d\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|ib_uverbs_release_ucq
argument_list|(
name|file
argument_list|,
name|ev_file
argument_list|,
name|ucq
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|ucq
argument_list|)
expr_stmt|;
block|}
name|list_for_each_entry_safe
argument_list|(
argument|uobj
argument_list|,
argument|tmp
argument_list|,
argument|&context->mr_list
argument_list|,
argument|list
argument_list|)
block|{
name|struct
name|ib_mr
modifier|*
name|mr
init|=
name|uobj
operator|->
name|object
decl_stmt|;
name|idr_remove_uobj
argument_list|(
operator|&
name|ib_uverbs_mr_idr
argument_list|,
name|uobj
argument_list|)
expr_stmt|;
name|err
operator|=
name|ib_dereg_mr
argument_list|(
name|mr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|pr_info
argument_list|(
literal|"user_verbs: couldn't deregister an MR during cleanup.\n"
argument_list|)
expr_stmt|;
name|pr_info
argument_list|(
literal|"user_verbs: the system may have become unstable.\n"
argument_list|)
expr_stmt|;
block|}
name|kfree
argument_list|(
name|uobj
argument_list|)
expr_stmt|;
block|}
name|mutex_lock
argument_list|(
operator|&
name|file
operator|->
name|device
operator|->
name|xrcd_tree_mutex
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|uobj
argument_list|,
argument|tmp
argument_list|,
argument|&context->xrcd_list
argument_list|,
argument|list
argument_list|)
block|{
name|struct
name|ib_xrcd
modifier|*
name|xrcd
init|=
name|uobj
operator|->
name|object
decl_stmt|;
name|struct
name|ib_uxrcd_object
modifier|*
name|uxrcd
init|=
name|container_of
argument_list|(
name|uobj
argument_list|,
expr|struct
name|ib_uxrcd_object
argument_list|,
name|uobject
argument_list|)
decl_stmt|;
name|idr_remove_uobj
argument_list|(
operator|&
name|ib_uverbs_xrcd_idr
argument_list|,
name|uobj
argument_list|)
expr_stmt|;
name|ib_uverbs_dealloc_xrcd
argument_list|(
name|file
operator|->
name|device
argument_list|,
name|xrcd
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|uxrcd
argument_list|)
expr_stmt|;
block|}
name|mutex_unlock
argument_list|(
operator|&
name|file
operator|->
name|device
operator|->
name|xrcd_tree_mutex
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|uobj
argument_list|,
argument|tmp
argument_list|,
argument|&context->pd_list
argument_list|,
argument|list
argument_list|)
block|{
name|struct
name|ib_pd
modifier|*
name|pd
init|=
name|uobj
operator|->
name|object
decl_stmt|;
name|idr_remove_uobj
argument_list|(
operator|&
name|ib_uverbs_pd_idr
argument_list|,
name|uobj
argument_list|)
expr_stmt|;
name|ib_dealloc_pd
argument_list|(
name|pd
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|uobj
argument_list|)
expr_stmt|;
block|}
return|return
name|context
operator|->
name|device
operator|->
name|dealloc_ucontext
argument_list|(
name|context
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ib_uverbs_release_file
parameter_list|(
name|struct
name|kref
modifier|*
name|ref
parameter_list|)
block|{
name|struct
name|ib_uverbs_file
modifier|*
name|file
init|=
name|container_of
argument_list|(
name|ref
argument_list|,
expr|struct
name|ib_uverbs_file
argument_list|,
name|ref
argument_list|)
decl_stmt|;
name|module_put
argument_list|(
name|file
operator|->
name|device
operator|->
name|ib_dev
operator|->
name|owner
argument_list|)
expr_stmt|;
name|kref_put
argument_list|(
operator|&
name|file
operator|->
name|device
operator|->
name|ref
argument_list|,
name|ib_uverbs_release_dev
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|ib_uverbs_event_read
parameter_list|(
name|struct
name|file
modifier|*
name|filp
parameter_list|,
name|char
name|__user
modifier|*
name|buf
parameter_list|,
name|size_t
name|count
parameter_list|,
name|loff_t
modifier|*
name|pos
parameter_list|)
block|{
name|struct
name|ib_uverbs_event_file
modifier|*
name|file
init|=
name|filp
operator|->
name|private_data
decl_stmt|;
name|struct
name|ib_uverbs_event
modifier|*
name|event
decl_stmt|;
name|int
name|eventsz
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|spin_lock_irq
argument_list|(
operator|&
name|file
operator|->
name|lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|list_empty
argument_list|(
operator|&
name|file
operator|->
name|event_list
argument_list|)
condition|)
block|{
name|spin_unlock_irq
argument_list|(
operator|&
name|file
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|filp
operator|->
name|f_flags
operator|&
name|O_NONBLOCK
condition|)
return|return
operator|-
name|EAGAIN
return|;
if|if
condition|(
name|wait_event_interruptible
argument_list|(
name|file
operator|->
name|poll_wait
argument_list|,
operator|!
name|list_empty
argument_list|(
operator|&
name|file
operator|->
name|event_list
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|ERESTARTSYS
return|;
name|spin_lock_irq
argument_list|(
operator|&
name|file
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|event
operator|=
name|list_entry
argument_list|(
name|file
operator|->
name|event_list
operator|.
name|next
argument_list|,
expr|struct
name|ib_uverbs_event
argument_list|,
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|is_async
condition|)
name|eventsz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ib_uverbs_async_event_desc
argument_list|)
expr_stmt|;
else|else
name|eventsz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ib_uverbs_comp_event_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|eventsz
operator|>
name|count
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
name|event
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|list_del
argument_list|(
name|file
operator|->
name|event_list
operator|.
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|counter
condition|)
block|{
operator|++
operator|(
operator|*
name|event
operator|->
name|counter
operator|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|event
operator|->
name|obj_list
argument_list|)
expr_stmt|;
block|}
block|}
name|spin_unlock_irq
argument_list|(
operator|&
name|file
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
condition|)
block|{
if|if
condition|(
name|copy_to_user
argument_list|(
name|buf
argument_list|,
name|event
argument_list|,
name|eventsz
argument_list|)
condition|)
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
else|else
name|ret
operator|=
name|eventsz
expr_stmt|;
block|}
name|kfree
argument_list|(
name|event
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|ib_uverbs_event_poll
parameter_list|(
name|struct
name|file
modifier|*
name|filp
parameter_list|,
name|struct
name|poll_table_struct
modifier|*
name|wait
parameter_list|)
block|{
name|unsigned
name|int
name|pollflags
init|=
literal|0
decl_stmt|;
name|struct
name|ib_uverbs_event_file
modifier|*
name|file
init|=
name|filp
operator|->
name|private_data
decl_stmt|;
name|file
operator|->
name|filp
operator|=
name|filp
expr_stmt|;
name|poll_wait
argument_list|(
name|filp
argument_list|,
operator|&
name|file
operator|->
name|poll_wait
argument_list|,
name|wait
argument_list|)
expr_stmt|;
name|spin_lock_irq
argument_list|(
operator|&
name|file
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|file
operator|->
name|event_list
argument_list|)
condition|)
name|pollflags
operator|=
name|POLLIN
operator||
name|POLLRDNORM
expr_stmt|;
name|spin_unlock_irq
argument_list|(
operator|&
name|file
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|pollflags
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ib_uverbs_event_fasync
parameter_list|(
name|int
name|fd
parameter_list|,
name|struct
name|file
modifier|*
name|filp
parameter_list|,
name|int
name|on
parameter_list|)
block|{
name|struct
name|ib_uverbs_event_file
modifier|*
name|file
init|=
name|filp
operator|->
name|private_data
decl_stmt|;
return|return
name|fasync_helper
argument_list|(
name|fd
argument_list|,
name|filp
argument_list|,
name|on
argument_list|,
operator|&
name|file
operator|->
name|async_queue
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ib_uverbs_event_close
parameter_list|(
name|struct
name|inode
modifier|*
name|inode
parameter_list|,
name|struct
name|file
modifier|*
name|filp
parameter_list|)
block|{
name|struct
name|ib_uverbs_event_file
modifier|*
name|file
init|=
name|filp
operator|->
name|private_data
decl_stmt|;
name|struct
name|ib_uverbs_event
modifier|*
name|entry
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|spin_lock_irq
argument_list|(
operator|&
name|file
operator|->
name|lock
argument_list|)
expr_stmt|;
name|file
operator|->
name|is_closed
operator|=
literal|1
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|entry
argument_list|,
argument|tmp
argument_list|,
argument|&file->event_list
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|entry
operator|->
name|counter
condition|)
name|list_del
argument_list|(
operator|&
name|entry
operator|->
name|obj_list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irq
argument_list|(
operator|&
name|file
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|is_async
condition|)
block|{
name|ib_unregister_event_handler
argument_list|(
operator|&
name|file
operator|->
name|uverbs_file
operator|->
name|event_handler
argument_list|)
expr_stmt|;
name|kref_put
argument_list|(
operator|&
name|file
operator|->
name|uverbs_file
operator|->
name|ref
argument_list|,
name|ib_uverbs_release_file
argument_list|)
expr_stmt|;
block|}
name|kref_put
argument_list|(
operator|&
name|file
operator|->
name|ref
argument_list|,
name|ib_uverbs_release_event_file
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|file_operations
name|uverbs_event_fops
init|=
block|{
operator|.
name|owner
operator|=
name|THIS_MODULE
block|,
operator|.
name|read
operator|=
name|ib_uverbs_event_read
block|,
operator|.
name|poll
operator|=
name|ib_uverbs_event_poll
block|,
operator|.
name|release
operator|=
name|ib_uverbs_event_close
block|,
operator|.
name|fasync
operator|=
name|ib_uverbs_event_fasync
block|,
operator|.
name|llseek
operator|=
name|no_llseek
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ib_uverbs_comp_handler
parameter_list|(
name|struct
name|ib_cq
modifier|*
name|cq
parameter_list|,
name|void
modifier|*
name|cq_context
parameter_list|)
block|{
name|struct
name|ib_uverbs_event_file
modifier|*
name|file
init|=
name|cq_context
decl_stmt|;
name|struct
name|ib_ucq_object
modifier|*
name|uobj
decl_stmt|;
name|struct
name|ib_uverbs_event
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
return|return;
name|spin_lock_irqsave
argument_list|(
operator|&
name|file
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|is_closed
condition|)
block|{
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|file
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
name|entry
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|entry
argument_list|,
name|GFP_ATOMIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
block|{
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|file
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
name|uobj
operator|=
name|container_of
argument_list|(
name|cq
operator|->
name|uobject
argument_list|,
expr|struct
name|ib_ucq_object
argument_list|,
name|uobject
argument_list|)
expr_stmt|;
name|entry
operator|->
name|desc
operator|.
name|comp
operator|.
name|cq_handle
operator|=
name|cq
operator|->
name|uobject
operator|->
name|user_handle
expr_stmt|;
name|entry
operator|->
name|counter
operator|=
operator|&
name|uobj
operator|->
name|comp_events_reported
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|entry
operator|->
name|list
argument_list|,
operator|&
name|file
operator|->
name|event_list
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|entry
operator|->
name|obj_list
argument_list|,
operator|&
name|uobj
operator|->
name|comp_list
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|file
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|wake_up_interruptible
argument_list|(
operator|&
name|file
operator|->
name|poll_wait
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|filp
condition|)
name|selwakeup
argument_list|(
operator|&
name|file
operator|->
name|filp
operator|->
name|f_selinfo
argument_list|)
expr_stmt|;
name|kill_fasync
argument_list|(
operator|&
name|file
operator|->
name|async_queue
argument_list|,
name|SIGIO
argument_list|,
name|POLL_IN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ib_uverbs_async_handler
parameter_list|(
name|struct
name|ib_uverbs_file
modifier|*
name|file
parameter_list|,
name|__u64
name|element
parameter_list|,
name|__u64
name|event
parameter_list|,
name|struct
name|list_head
modifier|*
name|obj_list
parameter_list|,
name|u32
modifier|*
name|counter
parameter_list|)
block|{
name|struct
name|ib_uverbs_event
modifier|*
name|entry
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|file
operator|->
name|async_file
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|async_file
operator|->
name|is_closed
condition|)
block|{
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|file
operator|->
name|async_file
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
name|entry
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|entry
argument_list|,
name|GFP_ATOMIC
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
condition|)
block|{
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|file
operator|->
name|async_file
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
name|entry
operator|->
name|desc
operator|.
name|async
operator|.
name|element
operator|=
name|element
expr_stmt|;
name|entry
operator|->
name|desc
operator|.
name|async
operator|.
name|event_type
operator|=
name|event
expr_stmt|;
name|entry
operator|->
name|counter
operator|=
name|counter
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|entry
operator|->
name|list
argument_list|,
operator|&
name|file
operator|->
name|async_file
operator|->
name|event_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj_list
condition|)
name|list_add_tail
argument_list|(
operator|&
name|entry
operator|->
name|obj_list
argument_list|,
name|obj_list
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|file
operator|->
name|async_file
operator|->
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|wake_up_interruptible
argument_list|(
operator|&
name|file
operator|->
name|async_file
operator|->
name|poll_wait
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|async_file
operator|->
name|filp
condition|)
name|selwakeup
argument_list|(
operator|&
name|file
operator|->
name|async_file
operator|->
name|filp
operator|->
name|f_selinfo
argument_list|)
expr_stmt|;
name|kill_fasync
argument_list|(
operator|&
name|file
operator|->
name|async_file
operator|->
name|async_queue
argument_list|,
name|SIGIO
argument_list|,
name|POLL_IN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ib_uverbs_cq_event_handler
parameter_list|(
name|struct
name|ib_event
modifier|*
name|event
parameter_list|,
name|void
modifier|*
name|context_ptr
parameter_list|)
block|{
name|struct
name|ib_ucq_object
modifier|*
name|uobj
init|=
name|container_of
argument_list|(
name|event
operator|->
name|element
operator|.
name|cq
operator|->
name|uobject
argument_list|,
expr|struct
name|ib_ucq_object
argument_list|,
name|uobject
argument_list|)
decl_stmt|;
name|ib_uverbs_async_handler
argument_list|(
name|uobj
operator|->
name|uverbs_file
argument_list|,
name|uobj
operator|->
name|uobject
operator|.
name|user_handle
argument_list|,
name|event
operator|->
name|event
argument_list|,
operator|&
name|uobj
operator|->
name|async_list
argument_list|,
operator|&
name|uobj
operator|->
name|async_events_reported
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ib_uverbs_qp_event_handler
parameter_list|(
name|struct
name|ib_event
modifier|*
name|event
parameter_list|,
name|void
modifier|*
name|context_ptr
parameter_list|)
block|{
name|struct
name|ib_uevent_object
modifier|*
name|uobj
decl_stmt|;
name|uobj
operator|=
name|container_of
argument_list|(
name|event
operator|->
name|element
operator|.
name|qp
operator|->
name|uobject
argument_list|,
expr|struct
name|ib_uevent_object
argument_list|,
name|uobject
argument_list|)
expr_stmt|;
name|ib_uverbs_async_handler
argument_list|(
name|context_ptr
argument_list|,
name|uobj
operator|->
name|uobject
operator|.
name|user_handle
argument_list|,
name|event
operator|->
name|event
argument_list|,
operator|&
name|uobj
operator|->
name|event_list
argument_list|,
operator|&
name|uobj
operator|->
name|events_reported
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ib_uverbs_srq_event_handler
parameter_list|(
name|struct
name|ib_event
modifier|*
name|event
parameter_list|,
name|void
modifier|*
name|context_ptr
parameter_list|)
block|{
name|struct
name|ib_uevent_object
modifier|*
name|uobj
decl_stmt|;
name|uobj
operator|=
name|container_of
argument_list|(
name|event
operator|->
name|element
operator|.
name|srq
operator|->
name|uobject
argument_list|,
expr|struct
name|ib_uevent_object
argument_list|,
name|uobject
argument_list|)
expr_stmt|;
name|ib_uverbs_async_handler
argument_list|(
name|context_ptr
argument_list|,
name|uobj
operator|->
name|uobject
operator|.
name|user_handle
argument_list|,
name|event
operator|->
name|event
argument_list|,
operator|&
name|uobj
operator|->
name|event_list
argument_list|,
operator|&
name|uobj
operator|->
name|events_reported
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ib_uverbs_event_handler
parameter_list|(
name|struct
name|ib_event_handler
modifier|*
name|handler
parameter_list|,
name|struct
name|ib_event
modifier|*
name|event
parameter_list|)
block|{
name|struct
name|ib_uverbs_file
modifier|*
name|file
init|=
name|container_of
argument_list|(
name|handler
argument_list|,
expr|struct
name|ib_uverbs_file
argument_list|,
name|event_handler
argument_list|)
decl_stmt|;
name|ib_uverbs_async_handler
argument_list|(
name|file
argument_list|,
name|event
operator|->
name|element
operator|.
name|port_num
argument_list|,
name|event
operator|->
name|event
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|file
modifier|*
name|ib_uverbs_alloc_event_file
parameter_list|(
name|struct
name|ib_uverbs_file
modifier|*
name|uverbs_file
parameter_list|,
name|int
name|is_async
parameter_list|)
block|{
name|struct
name|ib_uverbs_event_file
modifier|*
name|ev_file
decl_stmt|;
name|struct
name|file
modifier|*
name|filp
decl_stmt|;
name|ev_file
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|ev_file
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ev_file
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|kref_init
argument_list|(
operator|&
name|ev_file
operator|->
name|ref
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|ev_file
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|ev_file
operator|->
name|event_list
argument_list|)
expr_stmt|;
name|init_waitqueue_head
argument_list|(
operator|&
name|ev_file
operator|->
name|poll_wait
argument_list|)
expr_stmt|;
name|ev_file
operator|->
name|uverbs_file
operator|=
name|uverbs_file
expr_stmt|;
name|ev_file
operator|->
name|is_async
operator|=
name|is_async
expr_stmt|;
comment|/* 	 * fops_get() can't fail here, because we're coming from a 	 * system call on a uverbs file, which will already have a 	 * module reference. 	 */
name|filp
operator|=
name|alloc_file
argument_list|(
name|FMODE_READ
argument_list|,
name|fops_get
argument_list|(
operator|&
name|uverbs_event_fops
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|filp
argument_list|)
condition|)
block|{
name|kfree
argument_list|(
name|ev_file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|filp
operator|->
name|private_data
operator|=
name|ev_file
expr_stmt|;
block|}
return|return
name|filp
return|;
block|}
end_function

begin_comment
comment|/*  * Look up a completion event file by FD.  If lookup is successful,  * takes a ref to the event file struct that it returns; if  * unsuccessful, returns NULL.  */
end_comment

begin_function
name|struct
name|ib_uverbs_event_file
modifier|*
name|ib_uverbs_lookup_comp_file
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|struct
name|ib_uverbs_event_file
modifier|*
name|ev_file
init|=
name|NULL
decl_stmt|;
name|struct
name|fd
name|f
init|=
name|fdget
argument_list|(
name|fd
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
operator|.
name|file
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|f
operator|.
name|file
operator|->
name|f_op
operator|!=
operator|&
name|uverbs_event_fops
condition|)
goto|goto
name|out
goto|;
name|ev_file
operator|=
name|f
operator|.
name|file
operator|->
name|private_data
expr_stmt|;
if|if
condition|(
name|ev_file
operator|->
name|is_async
condition|)
block|{
name|ev_file
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|kref_get
argument_list|(
operator|&
name|ev_file
operator|->
name|ref
argument_list|)
expr_stmt|;
name|out
label|:
name|fdput
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return
name|ev_file
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|verbs_cmd_str
parameter_list|(
name|__u32
name|cmd
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|IB_USER_VERBS_CMD_GET_CONTEXT
case|:
return|return
literal|"GET_CONTEXT"
return|;
case|case
name|IB_USER_VERBS_CMD_QUERY_DEVICE
case|:
return|return
literal|"QUERY_DEVICE"
return|;
case|case
name|IB_USER_VERBS_CMD_QUERY_PORT
case|:
return|return
literal|"QUERY_PORT"
return|;
case|case
name|IB_USER_VERBS_CMD_ALLOC_PD
case|:
return|return
literal|"ALLOC_PD"
return|;
case|case
name|IB_USER_VERBS_CMD_DEALLOC_PD
case|:
return|return
literal|"DEALLOC_PD"
return|;
case|case
name|IB_USER_VERBS_CMD_REG_MR
case|:
return|return
literal|"REG_MR"
return|;
case|case
name|IB_USER_VERBS_CMD_DEREG_MR
case|:
return|return
literal|"DEREG_MR"
return|;
case|case
name|IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL
case|:
return|return
literal|"CREATE_COMP_CHANNEL"
return|;
case|case
name|IB_USER_VERBS_CMD_CREATE_CQ
case|:
return|return
literal|"CREATE_CQ"
return|;
case|case
name|IB_USER_VERBS_CMD_RESIZE_CQ
case|:
return|return
literal|"RESIZE_CQ"
return|;
case|case
name|IB_USER_VERBS_CMD_POLL_CQ
case|:
return|return
literal|"POLL_CQ"
return|;
case|case
name|IB_USER_VERBS_CMD_REQ_NOTIFY_CQ
case|:
return|return
literal|"REQ_NOTIFY_CQ"
return|;
case|case
name|IB_USER_VERBS_CMD_DESTROY_CQ
case|:
return|return
literal|"DESTROY_CQ"
return|;
case|case
name|IB_USER_VERBS_CMD_CREATE_QP
case|:
return|return
literal|"CREATE_QP"
return|;
case|case
name|IB_USER_VERBS_CMD_QUERY_QP
case|:
return|return
literal|"QUERY_QP"
return|;
case|case
name|IB_USER_VERBS_CMD_MODIFY_QP
case|:
return|return
literal|"MODIFY_QP"
return|;
case|case
name|IB_USER_VERBS_CMD_DESTROY_QP
case|:
return|return
literal|"DESTROY_QP"
return|;
case|case
name|IB_USER_VERBS_CMD_POST_SEND
case|:
return|return
literal|"POST_SEND"
return|;
case|case
name|IB_USER_VERBS_CMD_POST_RECV
case|:
return|return
literal|"POST_RECV"
return|;
case|case
name|IB_USER_VERBS_CMD_POST_SRQ_RECV
case|:
return|return
literal|"POST_SRQ_RECV"
return|;
case|case
name|IB_USER_VERBS_CMD_CREATE_AH
case|:
return|return
literal|"CREATE_AH"
return|;
case|case
name|IB_USER_VERBS_CMD_DESTROY_AH
case|:
return|return
literal|"DESTROY_AH"
return|;
case|case
name|IB_USER_VERBS_CMD_ATTACH_MCAST
case|:
return|return
literal|"ATTACH_MCAST"
return|;
case|case
name|IB_USER_VERBS_CMD_DETACH_MCAST
case|:
return|return
literal|"DETACH_MCAST"
return|;
case|case
name|IB_USER_VERBS_CMD_CREATE_SRQ
case|:
return|return
literal|"CREATE_SRQ"
return|;
case|case
name|IB_USER_VERBS_CMD_MODIFY_SRQ
case|:
return|return
literal|"MODIFY_SRQ"
return|;
case|case
name|IB_USER_VERBS_CMD_QUERY_SRQ
case|:
return|return
literal|"QUERY_SRQ"
return|;
case|case
name|IB_USER_VERBS_CMD_DESTROY_SRQ
case|:
return|return
literal|"DESTROY_SRQ"
return|;
case|case
name|IB_USER_VERBS_CMD_OPEN_XRCD
case|:
return|return
literal|"OPEN_XRCD"
return|;
case|case
name|IB_USER_VERBS_CMD_CLOSE_XRCD
case|:
return|return
literal|"CLOSE_XRCD"
return|;
case|case
name|IB_USER_VERBS_CMD_CREATE_XSRQ
case|:
return|return
literal|"CREATE_XSRQ"
return|;
case|case
name|IB_USER_VERBS_CMD_OPEN_QP
case|:
return|return
literal|"OPEN_QP"
return|;
block|}
return|return
literal|"Unknown command"
return|;
block|}
end_function

begin_enum
enum|enum
block|{
name|COMMAND_INFO_MASK
init|=
literal|0x1000
block|, }
enum|;
end_enum

begin_function
specifier|static
name|ssize_t
name|ib_uverbs_exp_handle_cmd
parameter_list|(
name|struct
name|ib_uverbs_file
modifier|*
name|file
parameter_list|,
specifier|const
name|char
name|__user
modifier|*
name|buf
parameter_list|,
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|ib_uverbs_cmd_hdr
modifier|*
name|hdr
parameter_list|,
name|size_t
name|count
parameter_list|,
name|int
name|legacy_ex_cmd
parameter_list|)
block|{
name|struct
name|ib_udata
name|ucore
decl_stmt|;
name|struct
name|ib_udata
name|uhw
decl_stmt|;
name|struct
name|ib_uverbs_ex_cmd_hdr
name|ex_hdr
decl_stmt|;
name|__u32
name|command
init|=
name|hdr
operator|->
name|command
operator|-
name|IB_USER_VERBS_EXP_CMD_FIRST
decl_stmt|;
if|if
condition|(
name|hdr
operator|->
name|command
operator|&
operator|~
call|(
name|__u32
call|)
argument_list|(
name|IB_USER_VERBS_CMD_FLAGS_MASK
operator||
name|IB_USER_VERBS_CMD_COMMAND_MASK
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|command
operator|>=
name|ARRAY_SIZE
argument_list|(
name|uverbs_exp_cmd_table
argument_list|)
operator|||
operator|!
name|uverbs_exp_cmd_table
index|[
name|command
index|]
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
name|file
operator|->
name|ucontext
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|uverbs_exp_cmd_mask
operator|&
operator|(
literal|1ull
operator|<<
name|command
operator|)
operator|)
condition|)
return|return
operator|-
name|ENOSYS
return|;
if|if
condition|(
name|legacy_ex_cmd
condition|)
block|{
name|struct
name|ib_uverbs_ex_cmd_hdr_legacy
name|hxl
decl_stmt|;
name|struct
name|ib_uverbs_ex_cmd_resp1_legacy
name|resp1
decl_stmt|;
name|__u64
name|response
decl_stmt|;
name|ssize_t
name|ret
decl_stmt|;
if|if
condition|(
name|count
operator|<
sizeof|sizeof
argument_list|(
name|hxl
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|hxl
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|hxl
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
if|if
condition|(
operator|(
operator|(
name|hxl
operator|.
name|in_words
operator|+
name|hxl
operator|.
name|provider_in_words
operator|)
operator|*
literal|4
operator|)
operator|!=
name|count
condition|)
return|return
operator|-
name|EINVAL
return|;
name|count
operator|-=
sizeof|sizeof
argument_list|(
name|hxl
argument_list|)
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|hxl
argument_list|)
expr_stmt|;
if|if
condition|(
name|hxl
operator|.
name|out_words
operator|||
name|hxl
operator|.
name|provider_out_words
condition|)
block|{
if|if
condition|(
name|count
operator|<
sizeof|sizeof
argument_list|(
name|resp1
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|resp1
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|resp1
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
name|response
operator|=
name|resp1
operator|.
name|response
expr_stmt|;
if|if
condition|(
operator|!
name|response
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* 			 * Change user buffer to comply with new extension format. 			 */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|resp1
operator|.
name|comp_mask
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|resp1
operator|.
name|response
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|resp1
operator|.
name|comp_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_to_user
argument_list|(
name|__DECONST
argument_list|(
argument|void __user *
argument_list|,
argument|buf
argument_list|)
argument_list|,
operator|&
name|resp1
operator|.
name|comp_mask
argument_list|,
sizeof|sizeof
argument_list|(
name|resp1
operator|.
name|response
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
block|}
else|else
block|{
name|response
operator|=
literal|0
expr_stmt|;
block|}
name|INIT_UDATA_EX
argument_list|(
operator|&
name|ucore
argument_list|,
operator|(
name|hxl
operator|.
name|in_words
operator|)
condition|?
name|buf
else|:
literal|0
argument_list|,
name|response
argument_list|,
name|hxl
operator|.
name|in_words
operator|*
literal|4
argument_list|,
name|hxl
operator|.
name|out_words
operator|*
literal|4
argument_list|)
expr_stmt|;
name|INIT_UDATA_EX
argument_list|(
operator|&
name|uhw
argument_list|,
operator|(
name|hxl
operator|.
name|provider_in_words
operator|)
condition|?
name|buf
operator|+
name|ucore
operator|.
name|inlen
else|:
literal|0
argument_list|,
operator|(
name|hxl
operator|.
name|provider_out_words
operator|)
condition|?
name|response
operator|+
name|ucore
operator|.
name|outlen
else|:
literal|0
argument_list|,
name|hxl
operator|.
name|provider_in_words
operator|*
literal|4
argument_list|,
name|hxl
operator|.
name|provider_out_words
operator|*
literal|4
argument_list|)
expr_stmt|;
name|ret
operator|=
name|uverbs_exp_cmd_table
index|[
name|command
index|]
operator|(
name|file
operator|,
operator|&
name|ucore
operator|,
operator|&
name|uhw
operator|)
expr_stmt|;
comment|/* 		 * UnChange user buffer 		 */
if|if
condition|(
name|response
operator|&&
name|copy_to_user
argument_list|(
name|__DECONST
argument_list|(
argument|void __user *
argument_list|,
argument|buf
argument_list|)
argument_list|,
operator|&
name|resp1
operator|.
name|response
argument_list|,
sizeof|sizeof
argument_list|(
name|resp1
operator|.
name|response
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
return|return
name|ret
return|;
block|}
else|else
block|{
if|if
condition|(
name|count
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ex_hdr
argument_list|)
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|ex_hdr
argument_list|,
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ex_hdr
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ex_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|->
name|in_words
operator|+
name|ex_hdr
operator|.
name|provider_in_words
operator|)
operator|*
literal|8
operator|!=
name|count
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|ex_hdr
operator|.
name|response
condition|)
block|{
if|if
condition|(
operator|!
name|hdr
operator|->
name|out_words
operator|&&
operator|!
name|ex_hdr
operator|.
name|provider_out_words
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
else|else
block|{
if|if
condition|(
name|hdr
operator|->
name|out_words
operator|||
name|ex_hdr
operator|.
name|provider_out_words
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
name|INIT_UDATA_EX
argument_list|(
operator|&
name|ucore
argument_list|,
operator|(
name|hdr
operator|->
name|in_words
operator|)
condition|?
name|buf
else|:
literal|0
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ex_hdr
operator|.
name|response
argument_list|,
name|hdr
operator|->
name|in_words
operator|*
literal|8
argument_list|,
name|hdr
operator|->
name|out_words
operator|*
literal|8
argument_list|)
expr_stmt|;
name|INIT_UDATA_EX
argument_list|(
operator|&
name|uhw
argument_list|,
operator|(
name|ex_hdr
operator|.
name|provider_in_words
operator|)
condition|?
name|buf
operator|+
name|ucore
operator|.
name|inlen
else|:
literal|0
argument_list|,
operator|(
name|ex_hdr
operator|.
name|provider_out_words
operator|)
condition|?
name|ex_hdr
operator|.
name|response
operator|+
name|ucore
operator|.
name|outlen
else|:
literal|0
argument_list|,
name|ex_hdr
operator|.
name|provider_in_words
operator|*
literal|8
argument_list|,
name|ex_hdr
operator|.
name|provider_out_words
operator|*
literal|8
argument_list|)
expr_stmt|;
return|return
name|uverbs_exp_cmd_table
index|[
name|command
index|]
operator|(
name|file
operator|,
operator|&
name|ucore
operator|,
operator|&
name|uhw
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|ib_uverbs_write
parameter_list|(
name|struct
name|file
modifier|*
name|filp
parameter_list|,
specifier|const
name|char
name|__user
modifier|*
name|buf
parameter_list|,
name|size_t
name|count
parameter_list|,
name|loff_t
modifier|*
name|pos
parameter_list|)
block|{
name|struct
name|ib_uverbs_file
modifier|*
name|file
init|=
name|filp
operator|->
name|private_data
decl_stmt|;
name|struct
name|ib_device
modifier|*
name|dev
init|=
name|file
operator|->
name|device
operator|->
name|ib_dev
decl_stmt|;
name|struct
name|ib_uverbs_cmd_hdr
name|hdr
decl_stmt|;
name|struct
name|timespec
name|ts1
decl_stmt|;
name|struct
name|timespec
name|ts2
decl_stmt|;
name|ktime_t
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|delta
decl_stmt|;
name|s64
name|ds
decl_stmt|;
name|ssize_t
name|ret
decl_stmt|;
name|u64
name|dividend
decl_stmt|;
name|u32
name|divisor
decl_stmt|;
name|__u32
name|flags
decl_stmt|;
name|__u32
name|command
decl_stmt|;
name|int
name|legacy_ex_cmd
init|=
literal|0
decl_stmt|;
name|size_t
name|written_count
init|=
name|count
decl_stmt|;
if|if
condition|(
name|count
operator|<
sizeof|sizeof
name|hdr
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|hdr
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|hdr
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
comment|/* 	 * For BWD compatibility change old style extension verbs commands 	 * to their equivalent experimental command. 	 */
if|if
condition|(
operator|(
name|hdr
operator|.
name|command
operator|>=
name|IB_USER_VERBS_LEGACY_CMD_FIRST
operator|)
operator|&&
operator|(
name|hdr
operator|.
name|command
operator|<=
name|IB_USER_VERBS_LEGACY_EX_CMD_LAST
operator|)
condition|)
block|{
name|hdr
operator|.
name|command
operator|+=
name|IB_USER_VERBS_EXP_CMD_FIRST
operator|-
name|IB_USER_VERBS_LEGACY_CMD_FIRST
expr_stmt|;
name|legacy_ex_cmd
operator|=
literal|1
expr_stmt|;
block|}
name|flags
operator|=
operator|(
name|hdr
operator|.
name|command
operator|&
name|IB_USER_VERBS_CMD_FLAGS_MASK
operator|)
operator|>>
name|IB_USER_VERBS_CMD_FLAGS_SHIFT
expr_stmt|;
name|command
operator|=
name|hdr
operator|.
name|command
operator|&
name|IB_USER_VERBS_CMD_COMMAND_MASK
expr_stmt|;
name|ktime_get_ts
argument_list|(
operator|&
name|ts1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|flags
operator|&&
operator|(
name|command
operator|>=
name|IB_USER_VERBS_EXP_CMD_FIRST
operator|)
condition|)
block|{
name|ret
operator|=
name|ib_uverbs_exp_handle_cmd
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|dev
argument_list|,
operator|&
name|hdr
argument_list|,
name|count
argument_list|,
name|legacy_ex_cmd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|flags
condition|)
block|{
if|if
condition|(
name|command
operator|>=
name|ARRAY_SIZE
argument_list|(
name|uverbs_cmd_table
argument_list|)
operator|||
operator|!
name|uverbs_cmd_table
index|[
name|command
index|]
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
name|file
operator|->
name|ucontext
operator|&&
name|command
operator|!=
name|IB_USER_VERBS_CMD_GET_CONTEXT
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|uverbs_cmd_mask
operator|&
operator|(
literal|1ull
operator|<<
name|command
operator|)
operator|)
condition|)
return|return
operator|-
name|ENOSYS
return|;
if|if
condition|(
name|hdr
operator|.
name|in_words
operator|*
literal|4
operator|!=
name|count
condition|)
return|return
operator|-
name|EINVAL
return|;
name|ret
operator|=
name|uverbs_cmd_table
index|[
name|command
index|]
operator|(
name|file
operator|,
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
operator|,
name|hdr
operator|.
name|in_words
operator|*
literal|4
operator|,
name|hdr
operator|.
name|out_words
operator|*
literal|4
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|==
name|IB_USER_VERBS_CMD_FLAG_EXTENDED
condition|)
block|{
name|struct
name|ib_udata
name|ucore
decl_stmt|;
name|struct
name|ib_udata
name|uhw
decl_stmt|;
name|struct
name|ib_uverbs_ex_cmd_hdr
name|ex_hdr
decl_stmt|;
if|if
condition|(
name|hdr
operator|.
name|command
operator|&
operator|~
call|(
name|__u32
call|)
argument_list|(
name|IB_USER_VERBS_CMD_FLAGS_MASK
operator||
name|IB_USER_VERBS_CMD_COMMAND_MASK
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|command
operator|>=
name|ARRAY_SIZE
argument_list|(
name|uverbs_ex_cmd_table
argument_list|)
operator|||
operator|!
name|uverbs_ex_cmd_table
index|[
name|command
index|]
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
name|file
operator|->
name|ucontext
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|uverbs_ex_cmd_mask
operator|&
operator|(
literal|1ull
operator|<<
name|command
operator|)
operator|)
condition|)
return|return
operator|-
name|ENOSYS
return|;
if|if
condition|(
name|count
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ex_hdr
argument_list|)
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|copy_from_user
argument_list|(
operator|&
name|ex_hdr
argument_list|,
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ex_hdr
argument_list|)
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
name|count
operator|-=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ex_hdr
argument_list|)
expr_stmt|;
name|buf
operator|+=
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ex_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hdr
operator|.
name|in_words
operator|+
name|ex_hdr
operator|.
name|provider_in_words
operator|)
operator|*
literal|8
operator|!=
name|count
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|ex_hdr
operator|.
name|response
condition|)
block|{
if|if
condition|(
operator|!
name|hdr
operator|.
name|out_words
operator|&&
operator|!
name|ex_hdr
operator|.
name|provider_out_words
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
else|else
block|{
if|if
condition|(
name|hdr
operator|.
name|out_words
operator|||
name|ex_hdr
operator|.
name|provider_out_words
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
name|INIT_UDATA_EX
argument_list|(
operator|&
name|ucore
argument_list|,
operator|(
name|hdr
operator|.
name|in_words
operator|)
condition|?
name|buf
else|:
literal|0
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|ex_hdr
operator|.
name|response
argument_list|,
name|hdr
operator|.
name|in_words
operator|*
literal|8
argument_list|,
name|hdr
operator|.
name|out_words
operator|*
literal|8
argument_list|)
expr_stmt|;
name|INIT_UDATA_EX
argument_list|(
operator|&
name|uhw
argument_list|,
operator|(
name|ex_hdr
operator|.
name|provider_in_words
operator|)
condition|?
name|buf
operator|+
name|ucore
operator|.
name|inlen
else|:
literal|0
argument_list|,
operator|(
name|ex_hdr
operator|.
name|provider_out_words
operator|)
condition|?
name|ex_hdr
operator|.
name|response
operator|+
name|ucore
operator|.
name|outlen
else|:
literal|0
argument_list|,
name|ex_hdr
operator|.
name|provider_in_words
operator|*
literal|8
argument_list|,
name|ex_hdr
operator|.
name|provider_out_words
operator|*
literal|8
argument_list|)
expr_stmt|;
name|ret
operator|=
name|uverbs_ex_cmd_table
index|[
name|command
index|]
operator|(
name|file
operator|,
operator|&
name|ucore
operator|,
operator|&
name|uhw
operator|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
return|return
name|written_count
return|;
block|}
else|else
block|{
return|return
operator|-
name|EFAULT
return|;
block|}
if|if
condition|(
operator|(
name|dev
operator|->
name|cmd_perf
operator|&
operator|(
name|COMMAND_INFO_MASK
operator|-
literal|1
operator|)
operator|)
operator|==
name|hdr
operator|.
name|command
condition|)
block|{
name|ktime_get_ts
argument_list|(
operator|&
name|ts2
argument_list|)
expr_stmt|;
name|t1
operator|=
name|timespec_to_ktime
argument_list|(
name|ts1
argument_list|)
expr_stmt|;
name|t2
operator|=
name|timespec_to_ktime
argument_list|(
name|ts2
argument_list|)
expr_stmt|;
name|delta
operator|=
name|ktime_sub
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
expr_stmt|;
name|ds
operator|=
name|ktime_to_ns
argument_list|(
name|delta
argument_list|)
expr_stmt|;
name|spin_lock
argument_list|(
operator|&
name|dev
operator|->
name|cmd_perf_lock
argument_list|)
expr_stmt|;
name|dividend
operator|=
name|dev
operator|->
name|cmd_avg
operator|*
name|dev
operator|->
name|cmd_n
operator|+
name|ds
expr_stmt|;
operator|++
name|dev
operator|->
name|cmd_n
expr_stmt|;
name|divisor
operator|=
name|dev
operator|->
name|cmd_n
expr_stmt|;
name|do_div
argument_list|(
name|dividend
argument_list|,
name|divisor
argument_list|)
expr_stmt|;
name|dev
operator|->
name|cmd_avg
operator|=
name|dividend
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|dev
operator|->
name|cmd_perf_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|cmd_perf
operator|&
name|COMMAND_INFO_MASK
condition|)
block|{
name|pr_info
argument_list|(
literal|"%s: %s execution time = %lld nsec\n"
argument_list|,
name|file
operator|->
name|device
operator|->
name|ib_dev
operator|->
name|name
argument_list|,
name|verbs_cmd_str
argument_list|(
name|hdr
operator|.
name|command
argument_list|)
argument_list|,
operator|(
name|long
name|long
operator|)
name|ds
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ib_uverbs_mmap
parameter_list|(
name|struct
name|file
modifier|*
name|filp
parameter_list|,
name|struct
name|vm_area_struct
modifier|*
name|vma
parameter_list|)
block|{
name|struct
name|ib_uverbs_file
modifier|*
name|file
init|=
name|filp
operator|->
name|private_data
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|->
name|ucontext
condition|)
return|return
operator|-
name|ENODEV
return|;
else|else
return|return
name|file
operator|->
name|device
operator|->
name|ib_dev
operator|->
name|mmap
argument_list|(
name|file
operator|->
name|ucontext
argument_list|,
name|vma
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* XXX Not supported in FreeBSD */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static unsigned long ib_uverbs_get_unmapped_area(struct file *filp, 		unsigned long addr, 		unsigned long len, unsigned long pgoff, unsigned long flags) { 	struct ib_uverbs_file *file = filp->private_data;  	if (!file->ucontext) 		return -ENODEV; 	else { 		if (!file->device->ib_dev->get_unmapped_area) 			return current->mm->get_unmapped_area(filp, addr, len, 								pgoff, flags);  		return file->device->ib_dev->get_unmapped_area(filp, addr, len, 								pgoff, flags); 	} }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|long
name|ib_uverbs_ioctl
parameter_list|(
name|struct
name|file
modifier|*
name|filp
parameter_list|,
name|unsigned
name|int
name|cmd
parameter_list|,
name|unsigned
name|long
name|arg
parameter_list|)
block|{
name|struct
name|ib_uverbs_file
modifier|*
name|file
init|=
name|filp
operator|->
name|private_data
decl_stmt|;
if|if
condition|(
operator|!
name|file
operator|->
name|device
operator|->
name|ib_dev
operator|->
name|ioctl
condition|)
return|return
operator|-
name|ENOTSUPP
return|;
if|if
condition|(
operator|!
name|file
operator|->
name|ucontext
condition|)
return|return
operator|-
name|ENODEV
return|;
else|else
comment|/* provider should provide it's own locking mechanism */
return|return
name|file
operator|->
name|device
operator|->
name|ib_dev
operator|->
name|ioctl
argument_list|(
name|file
operator|->
name|ucontext
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * ib_uverbs_open() does not need the BKL:  *  *  - the ib_uverbs_device structures are properly reference counted and  *    everything else is purely local to the file being created, so  *    races against other open calls are not a problem;  *  - there is no ioctl method to race against;  *  - the open method will either immediately run -ENXIO, or all  *    required initialization will be done.  */
end_comment

begin_function
specifier|static
name|int
name|ib_uverbs_open
parameter_list|(
name|struct
name|inode
modifier|*
name|inode
parameter_list|,
name|struct
name|file
modifier|*
name|filp
parameter_list|)
block|{
name|struct
name|ib_uverbs_device
modifier|*
name|dev
decl_stmt|;
name|struct
name|ib_uverbs_file
modifier|*
name|file
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|dev
operator|=
name|container_of
argument_list|(
name|inode
operator|->
name|i_cdev
operator|->
name|si_drv1
argument_list|,
expr|struct
name|ib_uverbs_device
argument_list|,
name|cdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
condition|)
name|kref_get
argument_list|(
operator|&
name|dev
operator|->
name|ref
argument_list|)
expr_stmt|;
else|else
return|return
operator|-
name|ENXIO
return|;
if|if
condition|(
operator|!
name|try_module_get
argument_list|(
name|dev
operator|->
name|ib_dev
operator|->
name|owner
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|file
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|file
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|file
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_module
goto|;
block|}
name|file
operator|->
name|device
operator|=
name|dev
expr_stmt|;
name|file
operator|->
name|ucontext
operator|=
name|NULL
expr_stmt|;
name|file
operator|->
name|async_file
operator|=
name|NULL
expr_stmt|;
name|kref_init
argument_list|(
operator|&
name|file
operator|->
name|ref
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|file
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|filp
operator|->
name|private_data
operator|=
name|file
expr_stmt|;
return|return
name|nonseekable_open
argument_list|(
name|inode
argument_list|,
name|filp
argument_list|)
return|;
name|err_module
label|:
name|module_put
argument_list|(
name|dev
operator|->
name|ib_dev
operator|->
name|owner
argument_list|)
expr_stmt|;
name|err
label|:
name|kref_put
argument_list|(
operator|&
name|dev
operator|->
name|ref
argument_list|,
name|ib_uverbs_release_dev
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ib_uverbs_close
parameter_list|(
name|struct
name|inode
modifier|*
name|inode
parameter_list|,
name|struct
name|file
modifier|*
name|filp
parameter_list|)
block|{
name|struct
name|ib_uverbs_file
modifier|*
name|file
init|=
name|filp
operator|->
name|private_data
decl_stmt|;
name|ib_uverbs_cleanup_ucontext
argument_list|(
name|file
argument_list|,
name|file
operator|->
name|ucontext
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|async_file
condition|)
name|kref_put
argument_list|(
operator|&
name|file
operator|->
name|async_file
operator|->
name|ref
argument_list|,
name|ib_uverbs_release_event_file
argument_list|)
expr_stmt|;
name|kref_put
argument_list|(
operator|&
name|file
operator|->
name|ref
argument_list|,
name|ib_uverbs_release_file
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|file_operations
name|uverbs_fops
init|=
block|{
operator|.
name|owner
operator|=
name|THIS_MODULE
block|,
operator|.
name|write
operator|=
name|ib_uverbs_write
block|,
operator|.
name|open
operator|=
name|ib_uverbs_open
block|,
operator|.
name|release
operator|=
name|ib_uverbs_close
block|,
operator|.
name|llseek
operator|=
name|no_llseek
block|,
operator|.
name|unlocked_ioctl
operator|=
name|ib_uverbs_ioctl
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|file_operations
name|uverbs_mmap_fops
init|=
block|{
operator|.
name|owner
operator|=
name|THIS_MODULE
block|,
operator|.
name|write
operator|=
name|ib_uverbs_write
block|,
operator|.
name|mmap
operator|=
name|ib_uverbs_mmap
block|,
operator|.
name|open
operator|=
name|ib_uverbs_open
block|,
operator|.
name|release
operator|=
name|ib_uverbs_close
block|,
operator|.
name|llseek
operator|=
name|no_llseek
block|,
comment|/* XXX Not supported in FreeBSD */
if|#
directive|if
literal|0
block|.get_unmapped_area = ib_uverbs_get_unmapped_area,
endif|#
directive|endif
operator|.
name|unlocked_ioctl
operator|=
name|ib_uverbs_ioctl
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ib_client
name|uverbs_client
init|=
block|{
operator|.
name|name
operator|=
literal|"uverbs"
block|,
operator|.
name|add
operator|=
name|ib_uverbs_add_one
block|,
operator|.
name|remove
operator|=
name|ib_uverbs_remove_one
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|ssize_t
name|show_ibdev
parameter_list|(
name|struct
name|device
modifier|*
name|device
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|ib_uverbs_device
modifier|*
name|dev
init|=
name|dev_get_drvdata
argument_list|(
name|device
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dev
condition|)
return|return
operator|-
name|ENODEV
return|;
return|return
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s\n"
argument_list|,
name|dev
operator|->
name|ib_dev
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|DEVICE_ATTR
argument_list|(
name|ibdev
argument_list|,
name|S_IRUGO
argument_list|,
name|show_ibdev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|ssize_t
name|show_dev_ref_cnt
parameter_list|(
name|struct
name|device
modifier|*
name|device
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|ib_uverbs_device
modifier|*
name|dev
init|=
name|dev_get_drvdata
argument_list|(
name|device
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dev
condition|)
return|return
operator|-
name|ENODEV
return|;
return|return
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d\n"
argument_list|,
name|atomic_read
argument_list|(
operator|&
name|dev
operator|->
name|ref
operator|.
name|refcount
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|DEVICE_ATTR
argument_list|(
name|ref_cnt
argument_list|,
name|S_IRUGO
argument_list|,
name|show_dev_ref_cnt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|ssize_t
name|show_dev_abi_version
parameter_list|(
name|struct
name|device
modifier|*
name|device
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|ib_uverbs_device
modifier|*
name|dev
init|=
name|dev_get_drvdata
argument_list|(
name|device
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dev
condition|)
return|return
operator|-
name|ENODEV
return|;
return|return
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d\n"
argument_list|,
name|dev
operator|->
name|ib_dev
operator|->
name|uverbs_abi_ver
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|DEVICE_ATTR
argument_list|(
name|abi_version
argument_list|,
name|S_IRUGO
argument_list|,
name|show_dev_abi_version
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|ssize_t
name|show_abi_version
parameter_list|(
name|struct
name|class
modifier|*
name|class
parameter_list|,
name|struct
name|class_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
return|return
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d\n"
argument_list|,
name|IB_USER_VERBS_ABI_VERSION
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|CLASS_ATTR
argument_list|(
name|abi_version
argument_list|,
name|S_IRUGO
argument_list|,
name|show_abi_version
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|dev_t
name|overflow_maj
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|DECLARE_BITMAP
argument_list|(
name|overflow_map
argument_list|,
name|IB_UVERBS_MAX_DEVICES
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * If we have more than IB_UVERBS_MAX_DEVICES, dynamically overflow by  * requesting a new major number and doubling the number of max devices we  * support. It's stupid, but simple.  */
end_comment

begin_function
specifier|static
name|int
name|find_overflow_devnum
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|!
name|overflow_maj
condition|)
block|{
name|ret
operator|=
name|alloc_chrdev_region
argument_list|(
operator|&
name|overflow_maj
argument_list|,
literal|0
argument_list|,
name|IB_UVERBS_MAX_DEVICES
argument_list|,
literal|"infiniband_verbs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printk
argument_list|(
name|KERN_ERR
literal|"user_verbs: couldn't register dynamic device number\n"
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
block|}
name|ret
operator|=
name|find_first_zero_bit
argument_list|(
name|overflow_map
argument_list|,
name|IB_UVERBS_MAX_DEVICES
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
name|IB_UVERBS_MAX_DEVICES
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|ret
return|;
block|}
end_function

begin_include
include|#
directive|include
file|<linux/pci.h>
end_include

begin_function
specifier|static
name|ssize_t
name|show_dev_device
parameter_list|(
name|struct
name|device
modifier|*
name|device
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|ib_uverbs_device
modifier|*
name|dev
init|=
name|dev_get_drvdata
argument_list|(
name|device
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dev
operator|||
operator|!
name|dev
operator|->
name|ib_dev
operator|->
name|dma_device
condition|)
return|return
operator|-
name|ENODEV
return|;
return|return
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x%04x\n"
argument_list|,
operator|(
operator|(
expr|struct
name|pci_dev
operator|*
operator|)
name|dev
operator|->
name|ib_dev
operator|->
name|dma_device
operator|)
operator|->
name|device
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|DEVICE_ATTR
argument_list|(
name|device
argument_list|,
name|S_IRUGO
argument_list|,
name|show_dev_device
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|ssize_t
name|show_dev_vendor
parameter_list|(
name|struct
name|device
modifier|*
name|device
parameter_list|,
name|struct
name|device_attribute
modifier|*
name|attr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|struct
name|ib_uverbs_device
modifier|*
name|dev
init|=
name|dev_get_drvdata
argument_list|(
name|device
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|dev
operator|||
operator|!
name|dev
operator|->
name|ib_dev
operator|->
name|dma_device
condition|)
return|return
operator|-
name|ENODEV
return|;
return|return
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"0x%04x\n"
argument_list|,
operator|(
operator|(
expr|struct
name|pci_dev
operator|*
operator|)
name|dev
operator|->
name|ib_dev
operator|->
name|dma_device
operator|)
operator|->
name|vendor
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|DEVICE_ATTR
argument_list|(
name|vendor
argument_list|,
name|S_IRUGO
argument_list|,
name|show_dev_vendor
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|attribute
modifier|*
name|device_attrs
index|[]
init|=
block|{
operator|&
name|dev_attr_device
operator|.
name|attr
block|,
operator|&
name|dev_attr_vendor
operator|.
name|attr
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|attribute_group
name|device_group
init|=
block|{
operator|.
name|name
operator|=
literal|"device"
block|,
operator|.
name|attrs
operator|=
name|device_attrs
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ib_uverbs_add_one
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|)
block|{
name|int
name|devnum
decl_stmt|;
name|dev_t
name|base
decl_stmt|;
name|struct
name|ib_uverbs_device
modifier|*
name|uverbs_dev
decl_stmt|;
if|if
condition|(
operator|!
name|device
operator|->
name|alloc_ucontext
condition|)
return|return;
name|uverbs_dev
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|uverbs_dev
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|uverbs_dev
condition|)
return|return;
name|kref_init
argument_list|(
operator|&
name|uverbs_dev
operator|->
name|ref
argument_list|)
expr_stmt|;
name|init_completion
argument_list|(
operator|&
name|uverbs_dev
operator|->
name|comp
argument_list|)
expr_stmt|;
name|uverbs_dev
operator|->
name|xrcd_tree
operator|=
name|RB_ROOT
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|uverbs_dev
operator|->
name|xrcd_tree_mutex
argument_list|)
expr_stmt|;
name|spin_lock
argument_list|(
operator|&
name|map_lock
argument_list|)
expr_stmt|;
name|devnum
operator|=
name|find_first_zero_bit
argument_list|(
name|dev_map
argument_list|,
name|IB_UVERBS_MAX_DEVICES
argument_list|)
expr_stmt|;
if|if
condition|(
name|devnum
operator|>=
name|IB_UVERBS_MAX_DEVICES
condition|)
block|{
name|spin_unlock
argument_list|(
operator|&
name|map_lock
argument_list|)
expr_stmt|;
name|devnum
operator|=
name|find_overflow_devnum
argument_list|()
expr_stmt|;
if|if
condition|(
name|devnum
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
name|spin_lock
argument_list|(
operator|&
name|map_lock
argument_list|)
expr_stmt|;
name|uverbs_dev
operator|->
name|devnum
operator|=
name|devnum
operator|+
name|IB_UVERBS_MAX_DEVICES
expr_stmt|;
name|base
operator|=
name|devnum
operator|+
name|overflow_maj
expr_stmt|;
name|set_bit
argument_list|(
name|devnum
argument_list|,
name|overflow_map
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uverbs_dev
operator|->
name|devnum
operator|=
name|devnum
expr_stmt|;
name|base
operator|=
name|devnum
operator|+
name|IB_UVERBS_BASE_DEV
expr_stmt|;
name|set_bit
argument_list|(
name|devnum
argument_list|,
name|dev_map
argument_list|)
expr_stmt|;
block|}
name|spin_unlock
argument_list|(
operator|&
name|map_lock
argument_list|)
expr_stmt|;
name|uverbs_dev
operator|->
name|ib_dev
operator|=
name|device
expr_stmt|;
name|uverbs_dev
operator|->
name|num_comp_vectors
operator|=
name|device
operator|->
name|num_comp_vectors
expr_stmt|;
name|cdev_init
argument_list|(
operator|&
name|uverbs_dev
operator|->
name|cdev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|uverbs_dev
operator|->
name|cdev
operator|.
name|owner
operator|=
name|THIS_MODULE
expr_stmt|;
name|uverbs_dev
operator|->
name|cdev
operator|.
name|ops
operator|=
name|device
operator|->
name|mmap
condition|?
operator|&
name|uverbs_mmap_fops
else|:
operator|&
name|uverbs_fops
expr_stmt|;
name|kobject_set_name
argument_list|(
operator|&
name|uverbs_dev
operator|->
name|cdev
operator|.
name|kobj
argument_list|,
literal|"uverbs%d"
argument_list|,
name|uverbs_dev
operator|->
name|devnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdev_add
argument_list|(
operator|&
name|uverbs_dev
operator|->
name|cdev
argument_list|,
name|base
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|err_cdev
goto|;
name|uverbs_dev
operator|->
name|dev
operator|=
name|device_create
argument_list|(
name|uverbs_class
argument_list|,
name|device
operator|->
name|dma_device
argument_list|,
name|uverbs_dev
operator|->
name|cdev
operator|.
name|dev
argument_list|,
name|uverbs_dev
argument_list|,
literal|"uverbs%d"
argument_list|,
name|uverbs_dev
operator|->
name|devnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|uverbs_dev
operator|->
name|dev
argument_list|)
condition|)
goto|goto
name|err_cdev
goto|;
if|if
condition|(
name|device_create_file
argument_list|(
name|uverbs_dev
operator|->
name|dev
argument_list|,
operator|&
name|dev_attr_ibdev
argument_list|)
condition|)
goto|goto
name|err_class
goto|;
if|if
condition|(
name|device_create_file
argument_list|(
name|uverbs_dev
operator|->
name|dev
argument_list|,
operator|&
name|dev_attr_ref_cnt
argument_list|)
condition|)
goto|goto
name|err_class
goto|;
if|if
condition|(
name|device_create_file
argument_list|(
name|uverbs_dev
operator|->
name|dev
argument_list|,
operator|&
name|dev_attr_abi_version
argument_list|)
condition|)
goto|goto
name|err_class
goto|;
if|if
condition|(
name|sysfs_create_group
argument_list|(
operator|&
name|uverbs_dev
operator|->
name|dev
operator|->
name|kobj
argument_list|,
operator|&
name|device_group
argument_list|)
condition|)
goto|goto
name|err_class
goto|;
name|ib_set_client_data
argument_list|(
name|device
argument_list|,
operator|&
name|uverbs_client
argument_list|,
name|uverbs_dev
argument_list|)
expr_stmt|;
return|return;
name|err_class
label|:
name|device_destroy
argument_list|(
name|uverbs_class
argument_list|,
name|uverbs_dev
operator|->
name|cdev
operator|.
name|dev
argument_list|)
expr_stmt|;
name|err_cdev
label|:
name|cdev_del
argument_list|(
operator|&
name|uverbs_dev
operator|->
name|cdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|uverbs_dev
operator|->
name|devnum
operator|<
name|IB_UVERBS_MAX_DEVICES
condition|)
name|clear_bit
argument_list|(
name|devnum
argument_list|,
name|dev_map
argument_list|)
expr_stmt|;
else|else
name|clear_bit
argument_list|(
name|devnum
argument_list|,
name|overflow_map
argument_list|)
expr_stmt|;
name|err
label|:
name|kref_put
argument_list|(
operator|&
name|uverbs_dev
operator|->
name|ref
argument_list|,
name|ib_uverbs_release_dev
argument_list|)
expr_stmt|;
name|wait_for_completion
argument_list|(
operator|&
name|uverbs_dev
operator|->
name|comp
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|uverbs_dev
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|ib_uverbs_remove_one
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|)
block|{
name|struct
name|ib_uverbs_device
modifier|*
name|uverbs_dev
init|=
name|ib_get_client_data
argument_list|(
name|device
argument_list|,
operator|&
name|uverbs_client
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|uverbs_dev
condition|)
return|return;
name|sysfs_remove_group
argument_list|(
operator|&
name|uverbs_dev
operator|->
name|dev
operator|->
name|kobj
argument_list|,
operator|&
name|device_group
argument_list|)
expr_stmt|;
name|dev_set_drvdata
argument_list|(
name|uverbs_dev
operator|->
name|dev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|device_destroy
argument_list|(
name|uverbs_class
argument_list|,
name|uverbs_dev
operator|->
name|cdev
operator|.
name|dev
argument_list|)
expr_stmt|;
name|cdev_del
argument_list|(
operator|&
name|uverbs_dev
operator|->
name|cdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|uverbs_dev
operator|->
name|devnum
operator|<
name|IB_UVERBS_MAX_DEVICES
condition|)
name|clear_bit
argument_list|(
name|uverbs_dev
operator|->
name|devnum
argument_list|,
name|dev_map
argument_list|)
expr_stmt|;
else|else
name|clear_bit
argument_list|(
name|uverbs_dev
operator|->
name|devnum
operator|-
name|IB_UVERBS_MAX_DEVICES
argument_list|,
name|overflow_map
argument_list|)
expr_stmt|;
name|kref_put
argument_list|(
operator|&
name|uverbs_dev
operator|->
name|ref
argument_list|,
name|ib_uverbs_release_dev
argument_list|)
expr_stmt|;
name|wait_for_completion
argument_list|(
operator|&
name|uverbs_dev
operator|->
name|comp
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|uverbs_dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|uverbs_devnode
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|umode_t
modifier|*
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
condition|)
operator|*
name|mode
operator|=
literal|0666
expr_stmt|;
return|return
name|kasprintf
argument_list|(
name|GFP_KERNEL
argument_list|,
literal|"infiniband/%s"
argument_list|,
name|dev_name
argument_list|(
name|dev
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__init
name|ib_uverbs_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|register_chrdev_region
argument_list|(
name|IB_UVERBS_BASE_DEV
argument_list|,
name|IB_UVERBS_MAX_DEVICES
argument_list|,
literal|"infiniband_verbs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printk
argument_list|(
name|KERN_ERR
literal|"user_verbs: couldn't register device number\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|uverbs_class
operator|=
name|class_create
argument_list|(
name|THIS_MODULE
argument_list|,
literal|"infiniband_verbs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|uverbs_class
argument_list|)
condition|)
block|{
name|ret
operator|=
name|PTR_ERR
argument_list|(
name|uverbs_class
argument_list|)
expr_stmt|;
name|printk
argument_list|(
name|KERN_ERR
literal|"user_verbs: couldn't create class infiniband_verbs\n"
argument_list|)
expr_stmt|;
goto|goto
name|out_chrdev
goto|;
block|}
name|uverbs_class
operator|->
name|devnode
operator|=
name|uverbs_devnode
expr_stmt|;
name|ret
operator|=
name|class_create_file
argument_list|(
name|uverbs_class
argument_list|,
operator|&
name|class_attr_abi_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printk
argument_list|(
name|KERN_ERR
literal|"user_verbs: couldn't create abi_version attribute\n"
argument_list|)
expr_stmt|;
goto|goto
name|out_class
goto|;
block|}
name|ret
operator|=
name|ib_register_client
argument_list|(
operator|&
name|uverbs_client
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|printk
argument_list|(
name|KERN_ERR
literal|"user_verbs: couldn't register client\n"
argument_list|)
expr_stmt|;
goto|goto
name|out_class
goto|;
block|}
return|return
literal|0
return|;
name|out_class
label|:
name|class_destroy
argument_list|(
name|uverbs_class
argument_list|)
expr_stmt|;
name|out_chrdev
label|:
name|unregister_chrdev_region
argument_list|(
name|IB_UVERBS_BASE_DEV
argument_list|,
name|IB_UVERBS_MAX_DEVICES
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__exit
name|ib_uverbs_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|ib_unregister_client
argument_list|(
operator|&
name|uverbs_client
argument_list|)
expr_stmt|;
name|class_destroy
argument_list|(
name|uverbs_class
argument_list|)
expr_stmt|;
name|unregister_chrdev_region
argument_list|(
name|IB_UVERBS_BASE_DEV
argument_list|,
name|IB_UVERBS_MAX_DEVICES
argument_list|)
expr_stmt|;
if|if
condition|(
name|overflow_maj
condition|)
name|unregister_chrdev_region
argument_list|(
name|overflow_maj
argument_list|,
name|IB_UVERBS_MAX_DEVICES
argument_list|)
expr_stmt|;
name|idr_destroy
argument_list|(
operator|&
name|ib_uverbs_pd_idr
argument_list|)
expr_stmt|;
name|idr_destroy
argument_list|(
operator|&
name|ib_uverbs_mr_idr
argument_list|)
expr_stmt|;
name|idr_destroy
argument_list|(
operator|&
name|ib_uverbs_mw_idr
argument_list|)
expr_stmt|;
name|idr_destroy
argument_list|(
operator|&
name|ib_uverbs_ah_idr
argument_list|)
expr_stmt|;
name|idr_destroy
argument_list|(
operator|&
name|ib_uverbs_cq_idr
argument_list|)
expr_stmt|;
name|idr_destroy
argument_list|(
operator|&
name|ib_uverbs_qp_idr
argument_list|)
expr_stmt|;
name|idr_destroy
argument_list|(
operator|&
name|ib_uverbs_srq_idr
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|module_init
argument_list|(
name|ib_uverbs_init
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_exit
argument_list|(
name|ib_uverbs_cleanup
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

