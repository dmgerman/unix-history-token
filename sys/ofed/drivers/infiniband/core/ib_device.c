begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004 Topspin Communications.  All rights reserved.  * Copyright (c) 2005 Sun Microsystems, Inc. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/string.h>
end_include

begin_include
include|#
directive|include
file|<linux/errno.h>
end_include

begin_include
include|#
directive|include
file|<linux/kernel.h>
end_include

begin_include
include|#
directive|include
file|<linux/slab.h>
end_include

begin_include
include|#
directive|include
file|<linux/mutex.h>
end_include

begin_include
include|#
directive|include
file|<linux/netdevice.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_addr.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_cache.h>
end_include

begin_include
include|#
directive|include
file|"core_priv.h"
end_include

begin_expr_stmt
name|MODULE_AUTHOR
argument_list|(
literal|"Roland Dreier"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DESCRIPTION
argument_list|(
literal|"core kernel InfiniBand API"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_LICENSE
argument_list|(
literal|"Dual BSD/GPL"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|ib_client_data
block|{
name|struct
name|list_head
name|list
decl_stmt|;
name|struct
name|ib_client
modifier|*
name|client
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
comment|/* The device or client is going down. Do not call client or device 	 * callbacks other than remove(). */
name|bool
name|going_down
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|workqueue_struct
modifier|*
name|ib_comp_wq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|workqueue_struct
modifier|*
name|ib_wq
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|EXPORT_SYMBOL_GPL
argument_list|(
name|ib_wq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The device_list and client_list contain devices and clients after their  * registration has completed, and the devices and clients are removed  * during unregistration. */
end_comment

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
name|device_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
name|client_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * device_mutex and lists_rwsem protect access to both device_list and  * client_list.  device_mutex protects writer access by device and client  * registration / de-registration.  lists_rwsem protects reader access to  * these lists.  Iterators of these lists must lock it for read, while updates  * to the lists must be done with a write lock. A special case is when the  * device_mutex is locked. In this case locking the lists for read access is  * not necessary as the device_mutex implies it.  *  * lists_rwsem also protects access to the client data list.  */
end_comment

begin_expr_stmt
specifier|static
name|DEFINE_MUTEX
argument_list|(
name|device_mutex
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|DECLARE_RWSEM
argument_list|(
name|lists_rwsem
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|ib_device_check_mandatory
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|)
block|{
define|#
directive|define
name|IB_MANDATORY_FUNC
parameter_list|(
name|x
parameter_list|)
value|{ offsetof(struct ib_device, x), #x }
specifier|static
specifier|const
struct|struct
block|{
name|size_t
name|offset
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|mandatory_table
index|[]
init|=
block|{
name|IB_MANDATORY_FUNC
argument_list|(
name|query_device
argument_list|)
block|,
name|IB_MANDATORY_FUNC
argument_list|(
name|query_port
argument_list|)
block|,
name|IB_MANDATORY_FUNC
argument_list|(
name|query_pkey
argument_list|)
block|,
name|IB_MANDATORY_FUNC
argument_list|(
name|query_gid
argument_list|)
block|,
name|IB_MANDATORY_FUNC
argument_list|(
name|alloc_pd
argument_list|)
block|,
name|IB_MANDATORY_FUNC
argument_list|(
name|dealloc_pd
argument_list|)
block|,
name|IB_MANDATORY_FUNC
argument_list|(
name|create_ah
argument_list|)
block|,
name|IB_MANDATORY_FUNC
argument_list|(
name|destroy_ah
argument_list|)
block|,
name|IB_MANDATORY_FUNC
argument_list|(
name|create_qp
argument_list|)
block|,
name|IB_MANDATORY_FUNC
argument_list|(
name|modify_qp
argument_list|)
block|,
name|IB_MANDATORY_FUNC
argument_list|(
name|destroy_qp
argument_list|)
block|,
name|IB_MANDATORY_FUNC
argument_list|(
name|post_send
argument_list|)
block|,
name|IB_MANDATORY_FUNC
argument_list|(
name|post_recv
argument_list|)
block|,
name|IB_MANDATORY_FUNC
argument_list|(
name|create_cq
argument_list|)
block|,
name|IB_MANDATORY_FUNC
argument_list|(
name|destroy_cq
argument_list|)
block|,
name|IB_MANDATORY_FUNC
argument_list|(
name|poll_cq
argument_list|)
block|,
name|IB_MANDATORY_FUNC
argument_list|(
name|req_notify_cq
argument_list|)
block|,
name|IB_MANDATORY_FUNC
argument_list|(
name|get_dma_mr
argument_list|)
block|,
name|IB_MANDATORY_FUNC
argument_list|(
name|dereg_mr
argument_list|)
block|,
name|IB_MANDATORY_FUNC
argument_list|(
argument|get_port_immutable
argument_list|)
block|}
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|mandatory_table
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|device
operator|+
name|mandatory_table
index|[
name|i
index|]
operator|.
name|offset
operator|)
condition|)
block|{
name|pr_warn
argument_list|(
literal|"Device %s is missing mandatory function %s\n"
argument_list|,
name|device
operator|->
name|name
argument_list|,
name|mandatory_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ib_device
modifier|*
name|__ib_device_get_by_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|device
argument_list|,
argument|&device_list
argument_list|,
argument|core_list
argument_list|)
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|device
operator|->
name|name
argument_list|,
name|IB_DEVICE_NAME_MAX
argument_list|)
condition|)
return|return
name|device
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_name
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|unsigned
name|long
modifier|*
name|inuse
decl_stmt|;
name|char
name|buf
index|[
name|IB_DEVICE_NAME_MAX
index|]
decl_stmt|;
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|int
name|i
decl_stmt|;
name|inuse
operator|=
operator|(
name|unsigned
name|long
operator|*
operator|)
name|get_zeroed_page
argument_list|(
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inuse
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|list_for_each_entry
argument_list|(
argument|device
argument_list|,
argument|&device_list
argument_list|,
argument|core_list
argument_list|)
block|{
if|if
condition|(
operator|!
name|sscanf
argument_list|(
name|device
operator|->
name|name
argument_list|,
name|name
argument_list|,
operator|&
name|i
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>=
name|PAGE_SIZE
operator|*
literal|8
condition|)
continue|continue;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
name|device
operator|->
name|name
argument_list|,
name|IB_DEVICE_NAME_MAX
argument_list|)
condition|)
name|set_bit
argument_list|(
name|i
argument_list|,
name|inuse
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|find_first_zero_bit
argument_list|(
name|inuse
argument_list|,
name|PAGE_SIZE
operator|*
literal|8
argument_list|)
expr_stmt|;
name|free_page
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|inuse
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|__ib_device_get_by_name
argument_list|(
name|buf
argument_list|)
condition|)
return|return
operator|-
name|ENFILE
return|;
name|strlcpy
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
name|IB_DEVICE_NAME_MAX
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ib_device_release
parameter_list|(
name|struct
name|device
modifier|*
name|device
parameter_list|)
block|{
name|struct
name|ib_device
modifier|*
name|dev
init|=
name|container_of
argument_list|(
name|device
argument_list|,
expr|struct
name|ib_device
argument_list|,
name|dev
argument_list|)
decl_stmt|;
name|ib_cache_release_one
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|port_immutable
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|class
name|ib_class
init|=
block|{
operator|.
name|name
operator|=
literal|"infiniband"
block|,
operator|.
name|dev_release
operator|=
name|ib_device_release
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * ib_alloc_device - allocate an IB device struct  * @size:size of structure to allocate  *  * Low-level drivers should use ib_alloc_device() to allocate&struct  * ib_device.  @size is the size of the structure to be allocated,  * including any private data used by the low-level driver.  * ib_dealloc_device() must be used to free structures allocated with  * ib_alloc_device().  */
end_comment

begin_function
name|struct
name|ib_device
modifier|*
name|ib_alloc_device
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
if|if
condition|(
name|WARN_ON
argument_list|(
name|size
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ib_device
argument_list|)
argument_list|)
condition|)
return|return
name|NULL
return|;
name|device
operator|=
name|kzalloc
argument_list|(
name|size
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|device
condition|)
return|return
name|NULL
return|;
name|device
operator|->
name|dev
operator|.
name|parent
operator|=
operator|&
name|linux_root_device
expr_stmt|;
name|device
operator|->
name|dev
operator|.
name|class
operator|=
operator|&
name|ib_class
expr_stmt|;
name|device_initialize
argument_list|(
operator|&
name|device
operator|->
name|dev
argument_list|)
expr_stmt|;
name|dev_set_drvdata
argument_list|(
operator|&
name|device
operator|->
name|dev
argument_list|,
name|device
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|device
operator|->
name|event_handler_list
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|device
operator|->
name|event_handler_lock
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|device
operator|->
name|client_data_lock
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|device
operator|->
name|client_data_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|device
operator|->
name|port_list
argument_list|)
expr_stmt|;
return|return
name|device
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_alloc_device
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * ib_dealloc_device - free an IB device struct  * @device:structure to free  *  * Free a structure allocated with ib_alloc_device().  */
end_comment

begin_function
name|void
name|ib_dealloc_device
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|)
block|{
name|WARN_ON
argument_list|(
name|device
operator|->
name|reg_state
operator|!=
name|IB_DEV_UNREGISTERED
operator|&&
name|device
operator|->
name|reg_state
operator|!=
name|IB_DEV_UNINITIALIZED
argument_list|)
expr_stmt|;
name|kobject_put
argument_list|(
operator|&
name|device
operator|->
name|dev
operator|.
name|kobj
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_dealloc_device
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|add_client_context
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|struct
name|ib_client
modifier|*
name|client
parameter_list|)
block|{
name|struct
name|ib_client_data
modifier|*
name|context
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|context
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|context
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
block|{
name|pr_warn
argument_list|(
literal|"Couldn't allocate client context for %s/%s\n"
argument_list|,
name|device
operator|->
name|name
argument_list|,
name|client
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|context
operator|->
name|client
operator|=
name|client
expr_stmt|;
name|context
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|context
operator|->
name|going_down
operator|=
name|false
expr_stmt|;
name|down_write
argument_list|(
operator|&
name|lists_rwsem
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|device
operator|->
name|client_data_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_add
argument_list|(
operator|&
name|context
operator|->
name|list
argument_list|,
operator|&
name|device
operator|->
name|client_data_list
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|device
operator|->
name|client_data_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|up_write
argument_list|(
operator|&
name|lists_rwsem
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|verify_immutable
parameter_list|(
specifier|const
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|)
block|{
return|return
name|WARN_ON
argument_list|(
operator|!
name|rdma_cap_ib_mad
argument_list|(
name|dev
argument_list|,
name|port
argument_list|)
operator|&&
name|rdma_max_mad_size
argument_list|(
name|dev
argument_list|,
name|port
argument_list|)
operator|!=
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|read_port_immutable
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|u8
name|start_port
init|=
name|rdma_start_port
argument_list|(
name|device
argument_list|)
decl_stmt|;
name|u8
name|end_port
init|=
name|rdma_end_port
argument_list|(
name|device
argument_list|)
decl_stmt|;
name|u8
name|port
decl_stmt|;
comment|/** 	 * device->port_immutable is indexed directly by the port number to make 	 * access to this data as efficient as possible. 	 * 	 * Therefore port_immutable is declared as a 1 based array with 	 * potential empty slots at the beginning. 	 */
name|device
operator|->
name|port_immutable
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|device
operator|->
name|port_immutable
argument_list|)
operator|*
operator|(
name|end_port
operator|+
literal|1
operator|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|device
operator|->
name|port_immutable
condition|)
return|return
operator|-
name|ENOMEM
return|;
for|for
control|(
name|port
operator|=
name|start_port
init|;
name|port
operator|<=
name|end_port
condition|;
operator|++
name|port
control|)
block|{
name|ret
operator|=
name|device
operator|->
name|get_port_immutable
argument_list|(
name|device
argument_list|,
name|port
argument_list|,
operator|&
name|device
operator|->
name|port_immutable
index|[
name|port
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
name|verify_immutable
argument_list|(
name|device
argument_list|,
name|port
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ib_get_device_fw_str
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|str_len
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|get_dev_fw_str
condition|)
name|dev
operator|->
name|get_dev_fw_str
argument_list|(
name|dev
argument_list|,
name|str
argument_list|,
name|str_len
argument_list|)
expr_stmt|;
else|else
name|str
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_get_device_fw_str
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * ib_register_device - Register an IB device with IB core  * @device:Device to register  *  * Low-level drivers use ib_register_device() to register their  * devices with the IB core.  All registered clients will receive a  * callback for each device that is added. @device must be allocated  * with ib_alloc_device().  */
end_comment

begin_function
name|int
name|ib_register_device
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
function_decl|(
modifier|*
name|port_callback
function_decl|)
parameter_list|(
name|struct
name|ib_device
modifier|*
parameter_list|,
name|u8
parameter_list|,
name|struct
name|kobject
modifier|*
parameter_list|)
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|ib_client
modifier|*
name|client
decl_stmt|;
name|struct
name|ib_udata
name|uhw
init|=
block|{
operator|.
name|outlen
operator|=
literal|0
block|,
operator|.
name|inlen
operator|=
literal|0
block|}
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|device_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|device
operator|->
name|name
argument_list|,
literal|'%'
argument_list|)
condition|)
block|{
name|ret
operator|=
name|alloc_name
argument_list|(
name|device
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|ib_device_check_mandatory
argument_list|(
name|device
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|read_port_immutable
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|pr_warn
argument_list|(
literal|"Couldn't create per port immutable data %s\n"
argument_list|,
name|device
operator|->
name|name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|ib_cache_setup_one
argument_list|(
name|device
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|pr_warn
argument_list|(
literal|"Couldn't set up InfiniBand P_Key/GID cache\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|memset
argument_list|(
operator|&
name|device
operator|->
name|attrs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|device
operator|->
name|attrs
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|device
operator|->
name|query_device
argument_list|(
name|device
argument_list|,
operator|&
name|device
operator|->
name|attrs
argument_list|,
operator|&
name|uhw
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|pr_warn
argument_list|(
literal|"Couldn't query the device attributes\n"
argument_list|)
expr_stmt|;
name|ib_cache_cleanup_one
argument_list|(
name|device
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|ib_device_register_sysfs
argument_list|(
name|device
argument_list|,
name|port_callback
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|pr_warn
argument_list|(
literal|"Couldn't register device %s with driver model\n"
argument_list|,
name|device
operator|->
name|name
argument_list|)
expr_stmt|;
name|ib_cache_cleanup_one
argument_list|(
name|device
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|device
operator|->
name|reg_state
operator|=
name|IB_DEV_REGISTERED
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|client
argument_list|,
argument|&client_list
argument_list|,
argument|list
argument_list|)
if|if
condition|(
name|client
operator|->
name|add
operator|&&
operator|!
name|add_client_context
argument_list|(
name|device
argument_list|,
name|client
argument_list|)
condition|)
name|client
operator|->
name|add
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|down_write
argument_list|(
operator|&
name|lists_rwsem
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|device
operator|->
name|core_list
argument_list|,
operator|&
name|device_list
argument_list|)
expr_stmt|;
name|up_write
argument_list|(
operator|&
name|lists_rwsem
argument_list|)
expr_stmt|;
name|out
label|:
name|mutex_unlock
argument_list|(
operator|&
name|device_mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_register_device
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * ib_unregister_device - Unregister an IB device  * @device:Device to unregister  *  * Unregister an IB device.  All clients will receive a remove callback.  */
end_comment

begin_function
name|void
name|ib_unregister_device
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|)
block|{
name|struct
name|ib_client_data
modifier|*
name|context
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|device_mutex
argument_list|)
expr_stmt|;
name|down_write
argument_list|(
operator|&
name|lists_rwsem
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|device
operator|->
name|core_list
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|device
operator|->
name|client_data_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|context
argument_list|,
argument|tmp
argument_list|,
argument|&device->client_data_list
argument_list|,
argument|list
argument_list|)
name|context
operator|->
name|going_down
operator|=
name|true
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|device
operator|->
name|client_data_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|downgrade_write
argument_list|(
operator|&
name|lists_rwsem
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|context
argument_list|,
argument|tmp
argument_list|,
argument|&device->client_data_list
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|context
operator|->
name|client
operator|->
name|remove
condition|)
name|context
operator|->
name|client
operator|->
name|remove
argument_list|(
name|device
argument_list|,
name|context
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
name|up_read
argument_list|(
operator|&
name|lists_rwsem
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|device_mutex
argument_list|)
expr_stmt|;
name|ib_device_unregister_sysfs
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|ib_cache_cleanup_one
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|down_write
argument_list|(
operator|&
name|lists_rwsem
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|device
operator|->
name|client_data_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|context
argument_list|,
argument|tmp
argument_list|,
argument|&device->client_data_list
argument_list|,
argument|list
argument_list|)
name|kfree
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|device
operator|->
name|client_data_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|up_write
argument_list|(
operator|&
name|lists_rwsem
argument_list|)
expr_stmt|;
name|device
operator|->
name|reg_state
operator|=
name|IB_DEV_UNREGISTERED
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_unregister_device
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * ib_register_client - Register an IB client  * @client:Client to register  *  * Upper level users of the IB drivers can use ib_register_client() to  * register callbacks for IB device addition and removal.  When an IB  * device is added, each registered client's add method will be called  * (in the order the clients were registered), and when a device is  * removed, each client's remove method will be called (in the reverse  * order that clients were registered).  In addition, when  * ib_register_client() is called, the client will receive an add  * callback for all devices already registered.  */
end_comment

begin_function
name|int
name|ib_register_client
parameter_list|(
name|struct
name|ib_client
modifier|*
name|client
parameter_list|)
block|{
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|device_mutex
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|device
argument_list|,
argument|&device_list
argument_list|,
argument|core_list
argument_list|)
if|if
condition|(
name|client
operator|->
name|add
operator|&&
operator|!
name|add_client_context
argument_list|(
name|device
argument_list|,
name|client
argument_list|)
condition|)
name|client
operator|->
name|add
argument_list|(
name|device
argument_list|)
expr_stmt|;
name|down_write
argument_list|(
operator|&
name|lists_rwsem
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|client
operator|->
name|list
argument_list|,
operator|&
name|client_list
argument_list|)
expr_stmt|;
name|up_write
argument_list|(
operator|&
name|lists_rwsem
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|device_mutex
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_register_client
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * ib_unregister_client - Unregister an IB client  * @client:Client to unregister  *  * Upper level users use ib_unregister_client() to remove their client  * registration.  When ib_unregister_client() is called, the client  * will receive a remove callback for each IB device still registered.  */
end_comment

begin_function
name|void
name|ib_unregister_client
parameter_list|(
name|struct
name|ib_client
modifier|*
name|client
parameter_list|)
block|{
name|struct
name|ib_client_data
modifier|*
name|context
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|device_mutex
argument_list|)
expr_stmt|;
name|down_write
argument_list|(
operator|&
name|lists_rwsem
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|client
operator|->
name|list
argument_list|)
expr_stmt|;
name|up_write
argument_list|(
operator|&
name|lists_rwsem
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|device
argument_list|,
argument|&device_list
argument_list|,
argument|core_list
argument_list|)
block|{
name|struct
name|ib_client_data
modifier|*
name|found_context
init|=
name|NULL
decl_stmt|;
name|down_write
argument_list|(
operator|&
name|lists_rwsem
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|device
operator|->
name|client_data_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|context
argument_list|,
argument|tmp
argument_list|,
argument|&device->client_data_list
argument_list|,
argument|list
argument_list|)
if|if
condition|(
name|context
operator|->
name|client
operator|==
name|client
condition|)
block|{
name|context
operator|->
name|going_down
operator|=
name|true
expr_stmt|;
name|found_context
operator|=
name|context
expr_stmt|;
break|break;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|device
operator|->
name|client_data_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|up_write
argument_list|(
operator|&
name|lists_rwsem
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
operator|->
name|remove
condition|)
name|client
operator|->
name|remove
argument_list|(
name|device
argument_list|,
name|found_context
condition|?
name|found_context
operator|->
name|data
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found_context
condition|)
block|{
name|pr_warn
argument_list|(
literal|"No client context found for %s/%s\n"
argument_list|,
name|device
operator|->
name|name
argument_list|,
name|client
operator|->
name|name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|down_write
argument_list|(
operator|&
name|lists_rwsem
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|device
operator|->
name|client_data_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|found_context
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|found_context
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|device
operator|->
name|client_data_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|up_write
argument_list|(
operator|&
name|lists_rwsem
argument_list|)
expr_stmt|;
block|}
name|mutex_unlock
argument_list|(
operator|&
name|device_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_unregister_client
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * ib_get_client_data - Get IB client context  * @device:Device to get context for  * @client:Client to get context for  *  * ib_get_client_data() returns client context set with  * ib_set_client_data().  */
end_comment

begin_function
name|void
modifier|*
name|ib_get_client_data
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|struct
name|ib_client
modifier|*
name|client
parameter_list|)
block|{
name|struct
name|ib_client_data
modifier|*
name|context
decl_stmt|;
name|void
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|device
operator|->
name|client_data_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|context
argument_list|,
argument|&device->client_data_list
argument_list|,
argument|list
argument_list|)
if|if
condition|(
name|context
operator|->
name|client
operator|==
name|client
condition|)
block|{
name|ret
operator|=
name|context
operator|->
name|data
expr_stmt|;
break|break;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|device
operator|->
name|client_data_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_get_client_data
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * ib_set_client_data - Set IB client context  * @device:Device to set context for  * @client:Client to set context for  * @data:Context to set  *  * ib_set_client_data() sets client context that can be retrieved with  * ib_get_client_data().  */
end_comment

begin_function
name|void
name|ib_set_client_data
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|struct
name|ib_client
modifier|*
name|client
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|ib_client_data
modifier|*
name|context
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|device
operator|->
name|client_data_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|context
argument_list|,
argument|&device->client_data_list
argument_list|,
argument|list
argument_list|)
if|if
condition|(
name|context
operator|->
name|client
operator|==
name|client
condition|)
block|{
name|context
operator|->
name|data
operator|=
name|data
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|pr_warn
argument_list|(
literal|"No client context found for %s/%s\n"
argument_list|,
name|device
operator|->
name|name
argument_list|,
name|client
operator|->
name|name
argument_list|)
expr_stmt|;
name|out
label|:
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|device
operator|->
name|client_data_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_set_client_data
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * ib_register_event_handler - Register an IB event handler  * @event_handler:Handler to register  *  * ib_register_event_handler() registers an event handler that will be  * called back when asynchronous IB events occur (as defined in  * chapter 11 of the InfiniBand Architecture Specification).  This  * callback may occur in interrupt context.  */
end_comment

begin_function
name|int
name|ib_register_event_handler
parameter_list|(
name|struct
name|ib_event_handler
modifier|*
name|event_handler
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|event_handler
operator|->
name|device
operator|->
name|event_handler_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|event_handler
operator|->
name|list
argument_list|,
operator|&
name|event_handler
operator|->
name|device
operator|->
name|event_handler_list
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|event_handler
operator|->
name|device
operator|->
name|event_handler_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_register_event_handler
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * ib_unregister_event_handler - Unregister an event handler  * @event_handler:Handler to unregister  *  * Unregister an event handler registered with  * ib_register_event_handler().  */
end_comment

begin_function
name|int
name|ib_unregister_event_handler
parameter_list|(
name|struct
name|ib_event_handler
modifier|*
name|event_handler
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|event_handler
operator|->
name|device
operator|->
name|event_handler_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|event_handler
operator|->
name|list
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|event_handler
operator|->
name|device
operator|->
name|event_handler_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_unregister_event_handler
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * ib_dispatch_event - Dispatch an asynchronous event  * @event:Event to dispatch  *  * Low-level drivers must call ib_dispatch_event() to dispatch the  * event to all registered event handlers when an asynchronous event  * occurs.  */
end_comment

begin_function
name|void
name|ib_dispatch_event
parameter_list|(
name|struct
name|ib_event
modifier|*
name|event
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|;
name|struct
name|ib_event_handler
modifier|*
name|handler
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|event
operator|->
name|device
operator|->
name|event_handler_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|handler
argument_list|,
argument|&event->device->event_handler_list
argument_list|,
argument|list
argument_list|)
name|handler
operator|->
name|handler
argument_list|(
name|handler
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|event
operator|->
name|device
operator|->
name|event_handler_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_dispatch_event
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * ib_query_port - Query IB port attributes  * @device:Device to query  * @port_num:Port number to query  * @port_attr:Port attributes  *  * ib_query_port() returns the attributes of a port through the  * @port_attr pointer.  */
end_comment

begin_function
name|int
name|ib_query_port
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|struct
name|ib_port_attr
modifier|*
name|port_attr
parameter_list|)
block|{
name|union
name|ib_gid
name|gid
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|port_num
operator|<
name|rdma_start_port
argument_list|(
name|device
argument_list|)
operator|||
name|port_num
operator|>
name|rdma_end_port
argument_list|(
name|device
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|memset
argument_list|(
name|port_attr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|port_attr
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|device
operator|->
name|query_port
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|,
name|port_attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|port_attr
operator|->
name|subnet_prefix
condition|)
return|return
name|err
return|;
if|if
condition|(
name|rdma_port_get_link_layer
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|)
operator|!=
name|IB_LINK_LAYER_INFINIBAND
condition|)
return|return
literal|0
return|;
name|err
operator|=
name|ib_query_gid
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|,
literal|0
argument_list|,
operator|&
name|gid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|port_attr
operator|->
name|subnet_prefix
operator|=
name|be64_to_cpu
argument_list|(
name|gid
operator|.
name|global
operator|.
name|subnet_prefix
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_query_port
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * ib_query_gid - Get GID table entry  * @device:Device to query  * @port_num:Port number to query  * @index:GID table index to query  * @gid:Returned GID  * @attr: Returned GID attributes related to this GID index (only in RoCE).  *   NULL means ignore.  *  * ib_query_gid() fetches the specified GID table entry.  */
end_comment

begin_function
name|int
name|ib_query_gid
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|int
name|index
parameter_list|,
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|,
name|struct
name|ib_gid_attr
modifier|*
name|attr
parameter_list|)
block|{
if|if
condition|(
name|rdma_cap_roce_gid_table
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|)
condition|)
return|return
name|ib_get_cached_gid
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|,
name|index
argument_list|,
name|gid
argument_list|,
name|attr
argument_list|)
return|;
if|if
condition|(
name|attr
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
name|device
operator|->
name|query_gid
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|,
name|index
argument_list|,
name|gid
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_query_gid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * ib_enum_roce_netdev - enumerate all RoCE ports  * @ib_dev : IB device we want to query  * @filter: Should we call the callback?  * @filter_cookie: Cookie passed to filter  * @cb: Callback to call for each found RoCE ports  * @cookie: Cookie passed back to the callback  *  * Enumerates all of the physical RoCE ports of ib_dev  * which are related to netdevice and calls callback() on each  * device for which filter() function returns non zero.  */
end_comment

begin_function
name|void
name|ib_enum_roce_netdev
parameter_list|(
name|struct
name|ib_device
modifier|*
name|ib_dev
parameter_list|,
name|roce_netdev_filter
name|filter
parameter_list|,
name|void
modifier|*
name|filter_cookie
parameter_list|,
name|roce_netdev_callback
name|cb
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|u8
name|port
decl_stmt|;
for|for
control|(
name|port
operator|=
name|rdma_start_port
argument_list|(
name|ib_dev
argument_list|)
init|;
name|port
operator|<=
name|rdma_end_port
argument_list|(
name|ib_dev
argument_list|)
condition|;
name|port
operator|++
control|)
if|if
condition|(
name|rdma_protocol_roce
argument_list|(
name|ib_dev
argument_list|,
name|port
argument_list|)
condition|)
block|{
name|struct
name|net_device
modifier|*
name|idev
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ib_dev
operator|->
name|get_netdev
condition|)
name|idev
operator|=
name|ib_dev
operator|->
name|get_netdev
argument_list|(
name|ib_dev
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|idev
operator|&&
operator|(
name|idev
operator|->
name|if_flags
operator|&
name|IFF_DYING
operator|)
condition|)
block|{
name|dev_put
argument_list|(
name|idev
argument_list|)
expr_stmt|;
name|idev
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|filter
argument_list|(
name|ib_dev
argument_list|,
name|port
argument_list|,
name|idev
argument_list|,
name|filter_cookie
argument_list|)
condition|)
name|cb
argument_list|(
name|ib_dev
argument_list|,
name|port
argument_list|,
name|idev
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|idev
condition|)
name|dev_put
argument_list|(
name|idev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * ib_enum_all_roce_netdevs - enumerate all RoCE devices  * @filter: Should we call the callback?  * @filter_cookie: Cookie passed to filter  * @cb: Callback to call for each found RoCE ports  * @cookie: Cookie passed back to the callback  *  * Enumerates all RoCE devices' physical ports which are related  * to netdevices and calls callback() on each device for which  * filter() function returns non zero.  */
end_comment

begin_function
name|void
name|ib_enum_all_roce_netdevs
parameter_list|(
name|roce_netdev_filter
name|filter
parameter_list|,
name|void
modifier|*
name|filter_cookie
parameter_list|,
name|roce_netdev_callback
name|cb
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|ib_device
modifier|*
name|dev
decl_stmt|;
name|down_read
argument_list|(
operator|&
name|lists_rwsem
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|dev
argument_list|,
argument|&device_list
argument_list|,
argument|core_list
argument_list|)
name|ib_enum_roce_netdev
argument_list|(
name|dev
argument_list|,
name|filter
argument_list|,
name|filter_cookie
argument_list|,
name|cb
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
name|up_read
argument_list|(
operator|&
name|lists_rwsem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ib_cache_gid_del_all_by_netdev - delete GIDs belonging a netdevice  *  * @ndev: Pointer to netdevice  */
end_comment

begin_function
name|void
name|ib_cache_gid_del_all_by_netdev
parameter_list|(
name|struct
name|net_device
modifier|*
name|ndev
parameter_list|)
block|{
name|struct
name|ib_device
modifier|*
name|ib_dev
decl_stmt|;
name|u8
name|port
decl_stmt|;
name|down_read
argument_list|(
operator|&
name|lists_rwsem
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|ib_dev
argument_list|,
argument|&device_list
argument_list|,
argument|core_list
argument_list|)
block|{
for|for
control|(
name|port
operator|=
name|rdma_start_port
argument_list|(
name|ib_dev
argument_list|)
init|;
name|port
operator|<=
name|rdma_end_port
argument_list|(
name|ib_dev
argument_list|)
condition|;
name|port
operator|++
control|)
block|{
if|if
condition|(
name|rdma_protocol_roce
argument_list|(
name|ib_dev
argument_list|,
name|port
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
operator|(
name|void
operator|)
name|ib_cache_gid_del_all_netdev_gids
argument_list|(
name|ib_dev
argument_list|,
name|port
argument_list|,
name|ndev
argument_list|)
expr_stmt|;
block|}
block|}
name|up_read
argument_list|(
operator|&
name|lists_rwsem
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * ib_query_pkey - Get P_Key table entry  * @device:Device to query  * @port_num:Port number to query  * @index:P_Key table index to query  * @pkey:Returned P_Key  *  * ib_query_pkey() fetches the specified P_Key table entry.  */
end_comment

begin_function
name|int
name|ib_query_pkey
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|u16
name|index
parameter_list|,
name|u16
modifier|*
name|pkey
parameter_list|)
block|{
return|return
name|device
operator|->
name|query_pkey
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|,
name|index
argument_list|,
name|pkey
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_query_pkey
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * ib_modify_device - Change IB device attributes  * @device:Device to modify  * @device_modify_mask:Mask of attributes to change  * @device_modify:New attribute values  *  * ib_modify_device() changes a device's attributes as specified by  * the @device_modify_mask and @device_modify structure.  */
end_comment

begin_function
name|int
name|ib_modify_device
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|int
name|device_modify_mask
parameter_list|,
name|struct
name|ib_device_modify
modifier|*
name|device_modify
parameter_list|)
block|{
if|if
condition|(
operator|!
name|device
operator|->
name|modify_device
condition|)
return|return
operator|-
name|ENOSYS
return|;
return|return
name|device
operator|->
name|modify_device
argument_list|(
name|device
argument_list|,
name|device_modify_mask
argument_list|,
name|device_modify
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_modify_device
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * ib_modify_port - Modifies the attributes for the specified port.  * @device: The device to modify.  * @port_num: The number of the port to modify.  * @port_modify_mask: Mask used to specify which attributes of the port  *   to change.  * @port_modify: New attribute values for the port.  *  * ib_modify_port() changes a port's attributes as specified by the  * @port_modify_mask and @port_modify structure.  */
end_comment

begin_function
name|int
name|ib_modify_port
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|int
name|port_modify_mask
parameter_list|,
name|struct
name|ib_port_modify
modifier|*
name|port_modify
parameter_list|)
block|{
if|if
condition|(
operator|!
name|device
operator|->
name|modify_port
condition|)
return|return
operator|-
name|ENOSYS
return|;
if|if
condition|(
name|port_num
operator|<
name|rdma_start_port
argument_list|(
name|device
argument_list|)
operator|||
name|port_num
operator|>
name|rdma_end_port
argument_list|(
name|device
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
name|device
operator|->
name|modify_port
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|,
name|port_modify_mask
argument_list|,
name|port_modify
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_modify_port
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * ib_find_gid - Returns the port number and GID table index where  *   a specified GID value occurs.  * @device: The device to query.  * @gid: The GID value to search for.  * @gid_type: Type of GID.  * @ndev: The ndev related to the GID to search for.  * @port_num: The port number of the device where the GID value was found.  * @index: The index into the GID table where the GID was found.  This  *   parameter may be NULL.  */
end_comment

begin_function
name|int
name|ib_find_gid
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|,
name|enum
name|ib_gid_type
name|gid_type
parameter_list|,
name|struct
name|net_device
modifier|*
name|ndev
parameter_list|,
name|u8
modifier|*
name|port_num
parameter_list|,
name|u16
modifier|*
name|index
parameter_list|)
block|{
name|union
name|ib_gid
name|tmp_gid
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|port
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|port
operator|=
name|rdma_start_port
argument_list|(
name|device
argument_list|)
init|;
name|port
operator|<=
name|rdma_end_port
argument_list|(
name|device
argument_list|)
condition|;
operator|++
name|port
control|)
block|{
if|if
condition|(
name|rdma_cap_roce_gid_table
argument_list|(
name|device
argument_list|,
name|port
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ib_find_cached_gid_by_port
argument_list|(
name|device
argument_list|,
name|gid
argument_list|,
name|gid_type
argument_list|,
name|port
argument_list|,
name|ndev
argument_list|,
name|index
argument_list|)
condition|)
block|{
operator|*
name|port_num
operator|=
name|port
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|gid_type
operator|!=
name|IB_GID_TYPE_IB
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|device
operator|->
name|port_immutable
index|[
name|port
index|]
operator|.
name|gid_tbl_len
condition|;
operator|++
name|i
control|)
block|{
name|ret
operator|=
name|ib_query_gid
argument_list|(
name|device
argument_list|,
name|port
argument_list|,
name|i
argument_list|,
operator|&
name|tmp_gid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
operator|&
name|tmp_gid
argument_list|,
name|gid
argument_list|,
sizeof|sizeof
expr|*
name|gid
argument_list|)
condition|)
block|{
operator|*
name|port_num
operator|=
name|port
expr_stmt|;
if|if
condition|(
name|index
condition|)
operator|*
name|index
operator|=
name|i
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
block|}
return|return
operator|-
name|ENOENT
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_find_gid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * ib_find_pkey - Returns the PKey table index where a specified  *   PKey value occurs.  * @device: The device to query.  * @port_num: The port number of the device to search for the PKey.  * @pkey: The PKey value to search for.  * @index: The index into the PKey table where the PKey was found.  */
end_comment

begin_function
name|int
name|ib_find_pkey
parameter_list|(
name|struct
name|ib_device
modifier|*
name|device
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|u16
name|pkey
parameter_list|,
name|u16
modifier|*
name|index
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|i
decl_stmt|;
name|u16
name|tmp_pkey
decl_stmt|;
name|int
name|partial_ix
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|device
operator|->
name|port_immutable
index|[
name|port_num
index|]
operator|.
name|pkey_tbl_len
condition|;
operator|++
name|i
control|)
block|{
name|ret
operator|=
name|ib_query_pkey
argument_list|(
name|device
argument_list|,
name|port_num
argument_list|,
name|i
argument_list|,
operator|&
name|tmp_pkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|(
name|pkey
operator|&
literal|0x7fff
operator|)
operator|==
operator|(
name|tmp_pkey
operator|&
literal|0x7fff
operator|)
condition|)
block|{
comment|/* if there is full-member pkey take it.*/
if|if
condition|(
name|tmp_pkey
operator|&
literal|0x8000
condition|)
block|{
operator|*
name|index
operator|=
name|i
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|partial_ix
operator|<
literal|0
condition|)
name|partial_ix
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/*no full-member, if exists take the limited*/
if|if
condition|(
name|partial_ix
operator|>=
literal|0
condition|)
block|{
operator|*
name|index
operator|=
name|partial_ix
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|-
name|ENOENT
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_find_pkey
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * ib_get_net_dev_by_params() - Return the appropriate net_dev  * for a received CM request  * @dev:	An RDMA device on which the request has been received.  * @port:	Port number on the RDMA device.  * @pkey:	The Pkey the request came on.  * @gid:	A GID that the net_dev uses to communicate.  * @addr:	Contains the IP address that the request specified as its  *		destination.  */
end_comment

begin_function
name|struct
name|net_device
modifier|*
name|ib_get_net_dev_by_params
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|u16
name|pkey
parameter_list|,
specifier|const
name|union
name|ib_gid
modifier|*
name|gid
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|net_device
modifier|*
name|net_dev
init|=
name|NULL
decl_stmt|;
name|struct
name|ib_client_data
modifier|*
name|context
decl_stmt|;
if|if
condition|(
operator|!
name|rdma_protocol_ib
argument_list|(
name|dev
argument_list|,
name|port
argument_list|)
condition|)
return|return
name|NULL
return|;
name|down_read
argument_list|(
operator|&
name|lists_rwsem
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|context
argument_list|,
argument|&dev->client_data_list
argument_list|,
argument|list
argument_list|)
block|{
name|struct
name|ib_client
modifier|*
name|client
init|=
name|context
operator|->
name|client
decl_stmt|;
if|if
condition|(
name|context
operator|->
name|going_down
condition|)
continue|continue;
if|if
condition|(
name|client
operator|->
name|get_net_dev_by_params
condition|)
block|{
name|net_dev
operator|=
name|client
operator|->
name|get_net_dev_by_params
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|pkey
argument_list|,
name|gid
argument_list|,
name|addr
argument_list|,
name|context
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|net_dev
condition|)
break|break;
block|}
block|}
name|up_read
argument_list|(
operator|&
name|lists_rwsem
argument_list|)
expr_stmt|;
return|return
name|net_dev
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_get_net_dev_by_params
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|__init
name|ib_core_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ib_wq
operator|=
name|alloc_workqueue
argument_list|(
literal|"infiniband"
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ib_wq
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|ib_comp_wq
operator|=
name|alloc_workqueue
argument_list|(
literal|"ib-comp-wq"
argument_list|,
name|WQ_UNBOUND
operator||
name|WQ_HIGHPRI
operator||
name|WQ_MEM_RECLAIM
argument_list|,
name|mp_ncpus
operator|*
literal|4
comment|/* WQ_UNBOUND_MAX_ACTIVE */
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ib_comp_wq
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ret
operator|=
name|class_register
argument_list|(
operator|&
name|ib_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|pr_warn
argument_list|(
literal|"Couldn't create InfiniBand device class\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_comp
goto|;
block|}
name|ret
operator|=
name|addr_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|pr_warn
argument_list|(
literal|"Could't init IB address resolution\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_sysfs
goto|;
block|}
name|ret
operator|=
name|ib_mad_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|pr_warn
argument_list|(
literal|"Couldn't init IB MAD\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_addr
goto|;
block|}
name|ret
operator|=
name|ib_sa_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|pr_warn
argument_list|(
literal|"Couldn't init SA\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_mad
goto|;
block|}
name|ib_cache_setup
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
name|err_mad
label|:
name|ib_mad_cleanup
argument_list|()
expr_stmt|;
name|err_addr
label|:
name|addr_cleanup
argument_list|()
expr_stmt|;
name|err_sysfs
label|:
name|class_unregister
argument_list|(
operator|&
name|ib_class
argument_list|)
expr_stmt|;
name|err_comp
label|:
name|destroy_workqueue
argument_list|(
name|ib_comp_wq
argument_list|)
expr_stmt|;
name|err
label|:
name|destroy_workqueue
argument_list|(
name|ib_wq
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__exit
name|ib_core_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|ib_cache_cleanup
argument_list|()
expr_stmt|;
name|ib_sa_cleanup
argument_list|()
expr_stmt|;
name|ib_mad_cleanup
argument_list|()
expr_stmt|;
name|addr_cleanup
argument_list|()
expr_stmt|;
name|class_unregister
argument_list|(
operator|&
name|ib_class
argument_list|)
expr_stmt|;
name|destroy_workqueue
argument_list|(
name|ib_comp_wq
argument_list|)
expr_stmt|;
comment|/* Make sure that any pending umem accounting work is done. */
name|destroy_workqueue
argument_list|(
name|ib_wq
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|module_init
argument_list|(
name|ib_core_init
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_exit
argument_list|(
name|ib_core_cleanup
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|ibcore
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|ibcore
argument_list|,
name|linuxkpi
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

