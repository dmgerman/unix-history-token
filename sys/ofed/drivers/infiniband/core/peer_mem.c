begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2013,  Mellanox Technologies. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<rdma/ib_peer_mem.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_verbs.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_umem.h>
end_include

begin_expr_stmt
specifier|static
name|DEFINE_MUTEX
argument_list|(
name|peer_memory_mutex
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
name|peer_memory_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|num_registered_peers
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This code uses the sysfs which is not supporeted by the FreeBSD.  *  * Will be added in future to the sysctl */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static struct kobject *peers_kobj; static struct ib_peer_memory_client *get_peer_by_kobj(void *kobj); static ssize_t version_show(struct kobject *kobj, 				struct kobj_attribute *attr, char *buf) { 	struct ib_peer_memory_client *ib_peer_client = get_peer_by_kobj(kobj);  	if (ib_peer_client) { 		sprintf(buf, "%s\n", ib_peer_client->peer_mem->version); 		return strlen(buf); 	}
comment|/* not found - nothing is return */
end_comment

begin_comment
unit|return 0; }  static ssize_t num_alloc_mrs_show(struct kobject *kobj, 	struct kobj_attribute *attr, char *buf) { 	struct ib_peer_memory_client *ib_peer_client = get_peer_by_kobj(kobj);  	if (ib_peer_client) { 		sprintf(buf, "%lu\n", ib_peer_client->stats.num_alloc_mrs); 		return strlen(buf); 	}
comment|/* not found - nothing is return */
end_comment

begin_comment
unit|return 0; }  static ssize_t num_reg_pages_show(struct kobject *kobj, 					struct kobj_attribute *attr, char *buf) { 	struct ib_peer_memory_client *ib_peer_client = get_peer_by_kobj(kobj);  	if (ib_peer_client) { 		sprintf(buf, "%lu\n", ib_peer_client->stats.num_reg_pages); 		return strlen(buf); 	}
comment|/* not found - nothing is return */
end_comment

begin_comment
unit|return 0; }  static ssize_t num_dereg_pages_show(struct kobject *kobj, 					struct kobj_attribute *attr, char *buf) { 	struct ib_peer_memory_client *ib_peer_client = get_peer_by_kobj(kobj);  	if (ib_peer_client) { 		sprintf(buf, "%lu\n", ib_peer_client->stats.num_dereg_pages); 		return strlen(buf); 	}
comment|/* not found - nothing is return */
end_comment

begin_comment
unit|return 0; }  static ssize_t num_free_callbacks_show(struct kobject *kobj, 					struct kobj_attribute *attr, char *buf) { 	struct ib_peer_memory_client *ib_peer_client = get_peer_by_kobj(kobj);  	if (ib_peer_client) { 		sprintf(buf, "%lu\n", ib_peer_client->stats.num_free_callbacks); 		return strlen(buf); 	}
comment|/* not found - nothing is return */
end_comment

begin_endif
unit|return 0; }  static struct kobj_attribute version_attr = __ATTR_RO(version); static struct kobj_attribute num_alloc_mrs = __ATTR_RO(num_alloc_mrs); static struct kobj_attribute num_reg_pages = __ATTR_RO(num_reg_pages); static struct kobj_attribute num_dereg_pages = __ATTR_RO(num_dereg_pages); static struct kobj_attribute num_free_callbacks = __ATTR_RO(num_free_callbacks);  static struct attribute *peer_mem_attrs[] = {&version_attr.attr,&num_alloc_mrs.attr,&num_reg_pages.attr,&num_dereg_pages.attr,&num_free_callbacks.attr, 			NULL, };
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static void destroy_peer_sysfs(struct ib_peer_memory_client *ib_peer_client) { 	kobject_put(ib_peer_client->kobj); 	if (!num_registered_peers) 		kobject_put(peers_kobj);  	return; }
comment|/* This code uses the sysfs which is not supporeted by the FreeBSD.  * Will be added in future to the sysctl */
end_comment

begin_comment
unit|static int create_peer_sysfs(struct ib_peer_memory_client *ib_peer_client) { 	int ret;  	if (!num_registered_peers) {
comment|/* creating under /sys/kernel/mm */
end_comment

begin_comment
unit|peers_kobj = kobject_create_and_add("memory_peers", mm_kobj); 		if (!peers_kobj) 			return -ENOMEM; 	}  	ib_peer_client->peer_mem_attr_group.attrs = peer_mem_attrs;
comment|/* Dir alreday was created explicitly to get its kernel object for further usage */
end_comment

begin_comment
unit|ib_peer_client->peer_mem_attr_group.name =  NULL; 	ib_peer_client->kobj = kobject_create_and_add(ib_peer_client->peer_mem->name, 		peers_kobj);  	if (!ib_peer_client->kobj) { 		ret = -EINVAL; 		goto free; 	}
comment|/* Create the files associated with this kobject */
end_comment

begin_endif
unit|ret = sysfs_create_group(ib_peer_client->kobj,&ib_peer_client->peer_mem_attr_group); 	if (ret) 		goto peer_free;  	return 0;  peer_free: 	kobject_put(ib_peer_client->kobj);  free: 	if (!num_registered_peers) 		kobject_put(peers_kobj);  	return ret; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|ib_invalidate_peer_memory
parameter_list|(
name|void
modifier|*
name|reg_handle
parameter_list|,
name|void
modifier|*
name|core_context
parameter_list|)
block|{
name|struct
name|ib_peer_memory_client
modifier|*
name|ib_peer_client
init|=
operator|(
expr|struct
name|ib_peer_memory_client
operator|*
operator|)
name|reg_handle
decl_stmt|;
name|struct
name|invalidation_ctx
modifier|*
name|invalidation_ctx
decl_stmt|;
name|struct
name|core_ticket
modifier|*
name|core_ticket
decl_stmt|;
name|int
name|need_unlock
init|=
literal|1
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|ib_peer_client
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ib_peer_client
operator|->
name|stats
operator|.
name|num_free_callbacks
operator|+=
literal|1
expr_stmt|;
name|core_ticket
operator|=
name|ib_peer_search_context
argument_list|(
name|ib_peer_client
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|core_context
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|core_ticket
condition|)
goto|goto
name|out
goto|;
name|invalidation_ctx
operator|=
operator|(
expr|struct
name|invalidation_ctx
operator|*
operator|)
name|core_ticket
operator|->
name|context
expr_stmt|;
comment|/* If context not ready yet mark to be invalidated */
if|if
condition|(
operator|!
name|invalidation_ctx
operator|->
name|func
condition|)
block|{
name|invalidation_ctx
operator|->
name|peer_invalidated
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|invalidation_ctx
operator|->
name|func
argument_list|(
name|invalidation_ctx
operator|->
name|cookie
argument_list|,
name|invalidation_ctx
operator|->
name|umem
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|invalidation_ctx
operator|->
name|inflight_invalidation
condition|)
block|{
comment|/* init the completion to wait on before letting other thread to run */
name|init_completion
argument_list|(
operator|&
name|invalidation_ctx
operator|->
name|comp
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|ib_peer_client
operator|->
name|lock
argument_list|)
expr_stmt|;
name|need_unlock
operator|=
literal|0
expr_stmt|;
name|wait_for_completion
argument_list|(
operator|&
name|invalidation_ctx
operator|->
name|comp
argument_list|)
expr_stmt|;
block|}
name|kfree
argument_list|(
name|invalidation_ctx
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|need_unlock
condition|)
name|mutex_unlock
argument_list|(
operator|&
name|ib_peer_client
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* access to that peer client is under its lock - no extra lock is needed */
end_comment

begin_function
name|unsigned
name|long
name|ib_peer_insert_context
parameter_list|(
name|struct
name|ib_peer_memory_client
modifier|*
name|ib_peer_client
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|core_ticket
modifier|*
name|core_ticket
init|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|core_ticket
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
decl_stmt|;
name|ib_peer_client
operator|->
name|last_ticket
operator|++
expr_stmt|;
name|core_ticket
operator|->
name|context
operator|=
name|context
expr_stmt|;
name|core_ticket
operator|->
name|key
operator|=
name|ib_peer_client
operator|->
name|last_ticket
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|core_ticket
operator|->
name|ticket_list
argument_list|,
operator|&
name|ib_peer_client
operator|->
name|core_ticket_list
argument_list|)
expr_stmt|;
return|return
name|core_ticket
operator|->
name|key
return|;
block|}
end_function

begin_function
name|int
name|ib_peer_remove_context
parameter_list|(
name|struct
name|ib_peer_memory_client
modifier|*
name|ib_peer_client
parameter_list|,
name|unsigned
name|long
name|key
parameter_list|)
block|{
name|struct
name|core_ticket
modifier|*
name|core_ticket
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|core_ticket
argument_list|,
argument|tmp
argument_list|,
argument|&ib_peer_client->core_ticket_list
argument_list|,
argument|ticket_list
argument_list|)
block|{
if|if
condition|(
name|core_ticket
operator|->
name|key
operator|==
name|key
condition|)
block|{
name|list_del
argument_list|(
operator|&
name|core_ticket
operator|->
name|ticket_list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|core_ticket
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|struct
name|core_ticket
modifier|*
name|ib_peer_search_context
parameter_list|(
name|struct
name|ib_peer_memory_client
modifier|*
name|ib_peer_client
parameter_list|,
name|unsigned
name|long
name|key
parameter_list|)
block|{
name|struct
name|core_ticket
modifier|*
name|core_ticket
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|core_ticket
argument_list|,
argument|tmp
argument_list|,
argument|&ib_peer_client->core_ticket_list
argument_list|,
argument|ticket_list
argument_list|)
block|{
if|if
condition|(
name|core_ticket
operator|->
name|key
operator|==
name|key
condition|)
return|return
name|core_ticket
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ib_memory_peer_check_mandatory
parameter_list|(
name|struct
name|peer_memory_client
modifier|*
name|peer_client
parameter_list|)
block|{
define|#
directive|define
name|PEER_MEM_MANDATORY_FUNC
parameter_list|(
name|x
parameter_list|)
value|{\ 	offsetof(struct peer_memory_client, x), #x }
specifier|static
specifier|const
struct|struct
block|{
name|size_t
name|offset
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|mandatory_table
index|[]
init|=
block|{
name|PEER_MEM_MANDATORY_FUNC
argument_list|(
name|acquire
argument_list|)
block|,
name|PEER_MEM_MANDATORY_FUNC
argument_list|(
name|get_pages
argument_list|)
block|,
name|PEER_MEM_MANDATORY_FUNC
argument_list|(
name|put_pages
argument_list|)
block|,
name|PEER_MEM_MANDATORY_FUNC
argument_list|(
name|get_page_size
argument_list|)
block|,
name|PEER_MEM_MANDATORY_FUNC
argument_list|(
name|dma_map
argument_list|)
block|,
name|PEER_MEM_MANDATORY_FUNC
argument_list|(
argument|dma_unmap
argument_list|)
block|}
struct|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARRAY_SIZE
argument_list|(
name|mandatory_table
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
operator|*
operator|(
name|void
operator|*
operator|*
operator|)
operator|(
operator|(
name|void
operator|*
operator|)
name|peer_client
operator|+
name|mandatory_table
index|[
name|i
index|]
operator|.
name|offset
operator|)
condition|)
block|{
name|printk
argument_list|(
name|KERN_WARNING
literal|"Peer memory %s is missing mandatory function %s\n"
argument_list|,
name|peer_client
operator|->
name|name
argument_list|,
name|mandatory_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|ib_register_peer_memory_client
parameter_list|(
name|struct
name|peer_memory_client
modifier|*
name|peer_client
parameter_list|,
name|invalidate_peer_memory
modifier|*
name|invalidate_callback
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|ib_peer_memory_client
modifier|*
name|ib_peer_client
init|=
name|NULL
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|peer_memory_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ib_memory_peer_check_mandatory
argument_list|(
name|peer_client
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ib_peer_client
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ib_peer_client
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ib_peer_client
condition|)
goto|goto
name|out
goto|;
name|ib_peer_client
operator|->
name|peer_mem
operator|=
name|peer_client
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|ib_peer_client
operator|->
name|core_ticket_list
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|ib_peer_client
operator|->
name|lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|ib_peer_client
operator|->
name|holdcount
operator|=
literal|0
expr_stmt|;
name|ib_peer_client
operator|->
name|needwakeup
operator|=
literal|0
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|ib_peer_client
operator|->
name|peer_cv
argument_list|,
literal|"ibprcl"
argument_list|)
expr_stmt|;
else|#
directive|else
name|ret
operator|=
name|init_srcu_struct
argument_list|(
operator|&
name|ib_peer_client
operator|->
name|peer_srcu
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|free
goto|;
endif|#
directive|endif
if|#
directive|if
literal|0
block|if (create_peer_sysfs(ib_peer_client)) 		goto free;
endif|#
directive|endif
operator|*
name|invalidate_callback
operator|=
name|ib_invalidate_peer_memory
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|ib_peer_client
operator|->
name|core_peer_list
argument_list|,
operator|&
name|peer_memory_list
argument_list|)
expr_stmt|;
name|num_registered_peers
operator|++
expr_stmt|;
goto|goto
name|out
goto|;
if|#
directive|if
literal|0
block|free: 	kfree(ib_peer_client); 	ib_peer_client = NULL;
endif|#
directive|endif
name|out
label|:
name|mutex_unlock
argument_list|(
operator|&
name|peer_memory_mutex
argument_list|)
expr_stmt|;
return|return
name|ib_peer_client
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_register_peer_memory_client
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|ib_unregister_peer_memory_client
parameter_list|(
name|void
modifier|*
name|reg_handle
parameter_list|)
block|{
name|struct
name|ib_peer_memory_client
modifier|*
name|ib_peer_client
init|=
operator|(
expr|struct
name|ib_peer_memory_client
operator|*
operator|)
name|reg_handle
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|peer_memory_mutex
argument_list|)
expr_stmt|;
comment|/* remove from list to prevent future core clients usage as it goes down  */
name|list_del
argument_list|(
operator|&
name|ib_peer_client
operator|->
name|core_peer_list
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
while|while
condition|(
name|ib_peer_client
operator|->
name|holdcount
operator|!=
literal|0
condition|)
block|{
name|ib_peer_client
operator|->
name|needwakeup
operator|=
literal|1
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|ib_peer_client
operator|->
name|peer_cv
argument_list|,
operator|&
name|peer_memory_mutex
operator|.
name|sx
argument_list|)
expr_stmt|;
block|}
name|cv_destroy
argument_list|(
operator|&
name|ib_peer_client
operator|->
name|peer_cv
argument_list|)
expr_stmt|;
else|#
directive|else
name|mutex_unlock
argument_list|(
operator|&
name|peer_memory_mutex
argument_list|)
expr_stmt|;
comment|/* peer memory can't go down while there are active clients */
name|synchronize_srcu
argument_list|(
operator|&
name|ib_peer_client
operator|->
name|peer_srcu
argument_list|)
expr_stmt|;
name|cleanup_srcu_struct
argument_list|(
operator|&
name|ib_peer_client
operator|->
name|peer_srcu
argument_list|)
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|peer_memory_mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|num_registered_peers
operator|--
expr_stmt|;
comment|/* This code uses the sysfs which is not supporeted by the FreeBSD.  * Will be added in future to the sysctl */
if|#
directive|if
literal|0
block|destroy_peer_sysfs(ib_peer_client);
endif|#
directive|endif
name|mutex_unlock
argument_list|(
operator|&
name|peer_memory_mutex
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|ib_peer_client
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_unregister_peer_memory_client
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This code uses the sysfs which is not supporeted by the FreeBSD.  * Will be added in future to the sysctl */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static struct ib_peer_memory_client *get_peer_by_kobj(void *kobj) { 	struct ib_peer_memory_client *ib_peer_client;  	mutex_lock(&peer_memory_mutex); 	list_for_each_entry(ib_peer_client,&peer_memory_list, core_peer_list) { 		if (ib_peer_client->kobj == kobj) 			goto found; 	}  	ib_peer_client = NULL;  found:  	mutex_unlock(&peer_memory_mutex); 	return ib_peer_client; }
endif|#
directive|endif
end_endif

begin_function
name|struct
name|ib_peer_memory_client
modifier|*
name|ib_get_peer_client
parameter_list|(
name|struct
name|ib_ucontext
modifier|*
name|context
parameter_list|,
name|unsigned
name|long
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
modifier|*
name|peer_client_context
parameter_list|,
name|int
modifier|*
name|srcu_key
parameter_list|)
block|{
name|struct
name|ib_peer_memory_client
modifier|*
name|ib_peer_client
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|peer_memory_mutex
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|ib_peer_client
argument_list|,
argument|&peer_memory_list
argument_list|,
argument|core_peer_list
argument_list|)
block|{
name|ret
operator|=
name|ib_peer_client
operator|->
name|peer_mem
operator|->
name|acquire
argument_list|(
name|addr
argument_list|,
name|size
argument_list|,
name|context
operator|->
name|peer_mem_private_data
argument_list|,
name|context
operator|->
name|peer_mem_name
argument_list|,
name|peer_client_context
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
goto|goto
name|found
goto|;
block|}
name|ib_peer_client
operator|=
name|NULL
expr_stmt|;
name|found
label|:
if|if
condition|(
name|ib_peer_client
condition|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|ib_peer_client
operator|->
name|holdcount
operator|++
expr_stmt|;
else|#
directive|else
operator|*
name|srcu_key
operator|=
name|srcu_read_lock
argument_list|(
operator|&
name|ib_peer_client
operator|->
name|peer_srcu
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|mutex_unlock
argument_list|(
operator|&
name|peer_memory_mutex
argument_list|)
expr_stmt|;
return|return
name|ib_peer_client
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_get_peer_client
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|ib_put_peer_client
parameter_list|(
name|struct
name|ib_peer_memory_client
modifier|*
name|ib_peer_client
parameter_list|,
name|void
modifier|*
name|peer_client_context
parameter_list|,
name|int
name|srcu_key
parameter_list|)
block|{
if|if
condition|(
name|ib_peer_client
operator|->
name|peer_mem
operator|->
name|release
condition|)
name|ib_peer_client
operator|->
name|peer_mem
operator|->
name|release
argument_list|(
name|peer_client_context
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__FreeBSD__
name|ib_peer_client
operator|->
name|holdcount
operator|--
expr_stmt|;
if|if
condition|(
name|ib_peer_client
operator|->
name|holdcount
operator|==
literal|0
operator|&&
name|ib_peer_client
operator|->
name|needwakeup
condition|)
block|{
name|cv_signal
argument_list|(
operator|&
name|ib_peer_client
operator|->
name|peer_cv
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|srcu_read_unlock
argument_list|(
operator|&
name|ib_peer_client
operator|->
name|peer_srcu
argument_list|,
name|srcu_key
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|ib_put_peer_client
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

