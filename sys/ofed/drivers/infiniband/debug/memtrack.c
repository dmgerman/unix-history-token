begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   This software is available to you under a choice of one of two   licenses.  You may choose to be licensed under the terms of the GNU   General Public License (GPL) Version 2, available at<http://www.fsf.org/copyleft/gpl.html>, or the OpenIB.org BSD   license, available in the LICENSE.TXT file accompanying this   software.  These details are also available at<http://openib.org/license.html>.    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   SOFTWARE.    Copyright (c) 2004 Mellanox Technologies Ltd.  All rights reserved. */
end_comment

begin_define
define|#
directive|define
name|LINUXKPI_PARAM_PREFIX
value|memtrack_
end_define

begin_define
define|#
directive|define
name|C_MEMTRACK_C
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|kmalloc
end_ifdef

begin_undef
undef|#
directive|undef
name|kmalloc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|kfree
end_ifdef

begin_undef
undef|#
directive|undef
name|kfree
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|vmalloc
end_ifdef

begin_undef
undef|#
directive|undef
name|vmalloc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|vfree
end_ifdef

begin_undef
undef|#
directive|undef
name|vfree
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|kmem_cache_alloc
end_ifdef

begin_undef
undef|#
directive|undef
name|kmem_cache_alloc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|kmem_cache_free
end_ifdef

begin_undef
undef|#
directive|undef
name|kmem_cache_free
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/kernel.h>
end_include

begin_include
include|#
directive|include
file|<linux/slab.h>
end_include

begin_include
include|#
directive|include
file|<linux/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<linux/vmalloc.h>
end_include

begin_include
include|#
directive|include
file|<linux/version.h>
end_include

begin_include
include|#
directive|include
file|<asm/uaccess.h>
end_include

begin_include
include|#
directive|include
file|<linux/proc_fs.h>
end_include

begin_include
include|#
directive|include
file|<memtrack.h>
end_include

begin_include
include|#
directive|include
file|<linux/moduleparam.h>
end_include

begin_expr_stmt
name|MODULE_AUTHOR
argument_list|(
literal|"Mellanox Technologies LTD."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DESCRIPTION
argument_list|(
literal|"Memory allocations tracking"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_LICENSE
argument_list|(
literal|"GPL"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|MEMTRACK_HASH_SZ
value|((1<<15)-19)
end_define

begin_comment
comment|/* prime: http://www.utm.edu/research/primes/lists/2small/0bit.html */
end_comment

begin_define
define|#
directive|define
name|MAX_FILENAME_LEN
value|31
end_define

begin_define
define|#
directive|define
name|memtrack_spin_lock
parameter_list|(
name|spl
parameter_list|,
name|flags
parameter_list|)
value|spin_lock_irqsave(spl, flags)
end_define

begin_define
define|#
directive|define
name|memtrack_spin_unlock
parameter_list|(
name|spl
parameter_list|,
name|flags
parameter_list|)
value|spin_unlock_irqrestore(spl, flags)
end_define

begin_comment
comment|/* if a bit is set then the corresponding allocation is tracked.    bit0 corresponds to MEMTRACK_KMALLOC, bit1 corresponds to MEMTRACK_VMALLOC etc. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|track_mask
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* effectively everything */
end_comment

begin_expr_stmt
name|module_param
argument_list|(
name|track_mask
argument_list|,
name|ulong
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|track_mask
argument_list|,
literal|"bitmask definenig what is tracked"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* if a bit is set then the corresponding allocation is strictly tracked.    That is, before inserting the whole range is checked to not overlap any    of the allocations already in the database */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|strict_track_mask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* no strict tracking */
end_comment

begin_expr_stmt
name|module_param
argument_list|(
name|strict_track_mask
argument_list|,
name|ulong
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|strict_track_mask
argument_list|,
literal|"bitmask which allocation requires strict tracking"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
struct|struct
name|memtrack_meminfo_st
block|{
name|unsigned
name|long
name|addr
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|unsigned
name|long
name|line_num
decl_stmt|;
name|struct
name|memtrack_meminfo_st
modifier|*
name|next
decl_stmt|;
name|struct
name|list_head
name|list
decl_stmt|;
comment|/* used to link all items from a certain type together */
name|char
name|filename
index|[
name|MAX_FILENAME_LEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* putting the char array last is better for struct. packing */
block|}
name|memtrack_meminfo_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|struct
name|kmem_cache
modifier|*
name|meminfo_cache
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|memtrack_meminfo_t
modifier|*
name|mem_hash
index|[
name|MEMTRACK_HASH_SZ
index|]
decl_stmt|;
name|spinlock_t
name|hash_lock
decl_stmt|;
name|unsigned
name|long
name|count
decl_stmt|;
comment|/* size of memory tracked (*malloc) or number of objects tracked */
name|struct
name|list_head
name|tracked_objs_head
decl_stmt|;
comment|/* head of list of all objects */
name|int
name|strict_track
decl_stmt|;
comment|/* if 1 then for each object inserted check if it overlaps any of the objects already in the list */
block|}
name|tracked_obj_desc_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|tracked_obj_desc_t
modifier|*
name|tracked_objs_arr
index|[
name|MEMTRACK_NUM_OF_MEMTYPES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|rsc_names
index|[
name|MEMTRACK_NUM_OF_MEMTYPES
index|]
init|=
block|{
literal|"kmalloc"
block|,
literal|"vmalloc"
block|,
literal|"kmem_cache_alloc"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|rsc_free_names
index|[
name|MEMTRACK_NUM_OF_MEMTYPES
index|]
init|=
block|{
literal|"kfree"
block|,
literal|"vfree"
block|,
literal|"kmem_cache_free"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|memtype_alloc_str
parameter_list|(
name|memtrack_memtype_t
name|memtype
parameter_list|)
block|{
switch|switch
condition|(
name|memtype
condition|)
block|{
case|case
name|MEMTRACK_KMALLOC
case|:
case|case
name|MEMTRACK_VMALLOC
case|:
case|case
name|MEMTRACK_KMEM_OBJ
case|:
return|return
name|rsc_names
index|[
name|memtype
index|]
return|;
default|default:
return|return
literal|"(Unknown allocation type)"
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|memtype_free_str
parameter_list|(
name|memtrack_memtype_t
name|memtype
parameter_list|)
block|{
switch|switch
condition|(
name|memtype
condition|)
block|{
case|case
name|MEMTRACK_KMALLOC
case|:
case|case
name|MEMTRACK_VMALLOC
case|:
case|case
name|MEMTRACK_KMEM_OBJ
case|:
return|return
name|rsc_free_names
index|[
name|memtype
index|]
return|;
default|default:
return|return
literal|"(Unknown allocation type)"
return|;
block|}
block|}
end_function

begin_comment
comment|/*  *  overlap_a_b  */
end_comment

begin_function
specifier|static
name|int
name|overlap_a_b
parameter_list|(
name|unsigned
name|long
name|a_start
parameter_list|,
name|unsigned
name|long
name|a_end
parameter_list|,
name|unsigned
name|long
name|b_start
parameter_list|,
name|unsigned
name|long
name|b_end
parameter_list|)
block|{
if|if
condition|(
operator|(
name|b_start
operator|>
name|a_end
operator|)
operator|||
operator|(
name|a_start
operator|>
name|b_end
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  *  check_overlap  */
end_comment

begin_function
specifier|static
name|void
name|check_overlap
parameter_list|(
name|memtrack_memtype_t
name|memtype
parameter_list|,
name|memtrack_meminfo_t
modifier|*
name|mem_info_p
parameter_list|,
name|tracked_obj_desc_t
modifier|*
name|obj_desc_p
parameter_list|)
block|{
name|struct
name|list_head
modifier|*
name|pos
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|memtrack_meminfo_t
modifier|*
name|cur
decl_stmt|;
name|unsigned
name|long
name|start_a
decl_stmt|,
name|end_a
decl_stmt|,
name|start_b
decl_stmt|,
name|end_b
decl_stmt|;
name|list_for_each_safe
argument_list|(
argument|pos
argument_list|,
argument|next
argument_list|,
argument|&obj_desc_p->tracked_objs_head
argument_list|)
block|{
name|cur
operator|=
name|list_entry
argument_list|(
name|pos
argument_list|,
name|memtrack_meminfo_t
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|start_a
operator|=
name|mem_info_p
operator|->
name|addr
expr_stmt|;
name|end_a
operator|=
name|mem_info_p
operator|->
name|addr
operator|+
name|mem_info_p
operator|->
name|size
operator|-
literal|1
expr_stmt|;
name|start_b
operator|=
name|cur
operator|->
name|addr
expr_stmt|;
name|end_b
operator|=
name|cur
operator|->
name|addr
operator|+
name|cur
operator|->
name|size
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|overlap_a_b
argument_list|(
name|start_a
argument_list|,
name|end_a
argument_list|,
name|start_b
argument_list|,
name|end_b
argument_list|)
condition|)
block|{
name|printk
argument_list|(
literal|"%s overlaps! new_start=0x%lx, new_end=0x%lx, item_start=0x%lx, item_end=0x%lx\n"
argument_list|,
name|memtype_alloc_str
argument_list|(
name|memtype
argument_list|)
argument_list|,
name|mem_info_p
operator|->
name|addr
argument_list|,
name|mem_info_p
operator|->
name|addr
operator|+
name|mem_info_p
operator|->
name|size
operator|-
literal|1
argument_list|,
name|cur
operator|->
name|addr
argument_list|,
name|cur
operator|->
name|addr
operator|+
name|cur
operator|->
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Invoke on memory allocation */
end_comment

begin_function
name|void
name|memtrack_alloc
parameter_list|(
name|memtrack_memtype_t
name|memtype
parameter_list|,
name|unsigned
name|long
name|addr
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|unsigned
name|long
name|line_num
parameter_list|,
name|int
name|alloc_flags
parameter_list|)
block|{
name|unsigned
name|long
name|hash_val
decl_stmt|;
name|memtrack_meminfo_t
modifier|*
name|cur_mem_info_p
decl_stmt|,
modifier|*
name|new_mem_info_p
decl_stmt|;
name|tracked_obj_desc_t
modifier|*
name|obj_desc_p
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
if|if
condition|(
name|memtype
operator|>=
name|MEMTRACK_NUM_OF_MEMTYPES
condition|)
block|{
name|printk
argument_list|(
literal|"%s: Invalid memory type (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|memtype
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|tracked_objs_arr
index|[
name|memtype
index|]
condition|)
block|{
comment|/* object is not tracked */
return|return;
block|}
name|obj_desc_p
operator|=
name|tracked_objs_arr
index|[
name|memtype
index|]
expr_stmt|;
name|hash_val
operator|=
name|addr
operator|%
name|MEMTRACK_HASH_SZ
expr_stmt|;
name|new_mem_info_p
operator|=
operator|(
name|memtrack_meminfo_t
operator|*
operator|)
name|kmem_cache_alloc
argument_list|(
name|meminfo_cache
argument_list|,
name|alloc_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_mem_info_p
operator|==
name|NULL
condition|)
block|{
name|printk
argument_list|(
literal|"%s: Failed allocating kmem_cache item for new mem_info. "
literal|"Lost tracking on allocation at %s:%lu...\n"
argument_list|,
name|__func__
argument_list|,
name|filename
argument_list|,
name|line_num
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* save allocation properties */
name|new_mem_info_p
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|new_mem_info_p
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|new_mem_info_p
operator|->
name|line_num
operator|=
name|line_num
expr_stmt|;
comment|/* Make sure that we will print out the path tail if the given filename is longer          * than MAX_FILENAME_LEN. (otherwise, we will not see the name of the actual file          * in the printout -- only the path head!          */
if|if
condition|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|>
name|MAX_FILENAME_LEN
condition|)
block|{
name|strncpy
argument_list|(
name|new_mem_info_p
operator|->
name|filename
argument_list|,
name|filename
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|-
name|MAX_FILENAME_LEN
argument_list|,
name|MAX_FILENAME_LEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|new_mem_info_p
operator|->
name|filename
argument_list|,
name|filename
argument_list|,
name|MAX_FILENAME_LEN
argument_list|)
expr_stmt|;
block|}
name|new_mem_info_p
operator|->
name|filename
index|[
name|MAX_FILENAME_LEN
index|]
operator|=
literal|0
expr_stmt|;
comment|/* NULL terminate anyway */
name|memtrack_spin_lock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* make sure given memory location is not already allocated */
name|cur_mem_info_p
operator|=
name|obj_desc_p
operator|->
name|mem_hash
index|[
name|hash_val
index|]
expr_stmt|;
while|while
condition|(
name|cur_mem_info_p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cur_mem_info_p
operator|->
name|addr
operator|==
name|addr
condition|)
block|{
comment|/* Found given address in the database */
name|printk
argument_list|(
literal|"mtl rsc inconsistency: %s: %s::%lu: %s @ addr=0x%lX which is already known from %s:%lu\n"
argument_list|,
name|__func__
argument_list|,
name|filename
argument_list|,
name|line_num
argument_list|,
name|memtype_alloc_str
argument_list|(
name|memtype
argument_list|)
argument_list|,
name|addr
argument_list|,
name|cur_mem_info_p
operator|->
name|filename
argument_list|,
name|cur_mem_info_p
operator|->
name|line_num
argument_list|)
expr_stmt|;
name|memtrack_spin_unlock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|meminfo_cache
argument_list|,
name|new_mem_info_p
argument_list|)
expr_stmt|;
return|return;
block|}
name|cur_mem_info_p
operator|=
name|cur_mem_info_p
operator|->
name|next
expr_stmt|;
block|}
comment|/* not found - we can put in the hash bucket */
comment|/* link as first */
name|new_mem_info_p
operator|->
name|next
operator|=
name|obj_desc_p
operator|->
name|mem_hash
index|[
name|hash_val
index|]
expr_stmt|;
name|obj_desc_p
operator|->
name|mem_hash
index|[
name|hash_val
index|]
operator|=
name|new_mem_info_p
expr_stmt|;
if|if
condition|(
name|obj_desc_p
operator|->
name|strict_track
condition|)
block|{
name|check_overlap
argument_list|(
name|memtype
argument_list|,
name|new_mem_info_p
argument_list|,
name|obj_desc_p
argument_list|)
expr_stmt|;
block|}
name|obj_desc_p
operator|->
name|count
operator|+=
name|size
expr_stmt|;
name|list_add
argument_list|(
operator|&
name|new_mem_info_p
operator|->
name|list
argument_list|,
operator|&
name|obj_desc_p
operator|->
name|tracked_objs_head
argument_list|)
expr_stmt|;
name|memtrack_spin_unlock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Invoke on memory free */
end_comment

begin_function
name|void
name|memtrack_free
parameter_list|(
name|memtrack_memtype_t
name|memtype
parameter_list|,
name|unsigned
name|long
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|unsigned
name|long
name|line_num
parameter_list|)
block|{
name|unsigned
name|long
name|hash_val
decl_stmt|;
name|memtrack_meminfo_t
modifier|*
name|cur_mem_info_p
decl_stmt|,
modifier|*
name|prev_mem_info_p
decl_stmt|;
name|tracked_obj_desc_t
modifier|*
name|obj_desc_p
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
if|if
condition|(
name|memtype
operator|>=
name|MEMTRACK_NUM_OF_MEMTYPES
condition|)
block|{
name|printk
argument_list|(
literal|"%s: Invalid memory type (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|memtype
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|tracked_objs_arr
index|[
name|memtype
index|]
condition|)
block|{
comment|/* object is not tracked */
return|return;
block|}
name|obj_desc_p
operator|=
name|tracked_objs_arr
index|[
name|memtype
index|]
expr_stmt|;
name|hash_val
operator|=
name|addr
operator|%
name|MEMTRACK_HASH_SZ
expr_stmt|;
name|memtrack_spin_lock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* find  mem_info of given memory location */
name|prev_mem_info_p
operator|=
name|NULL
expr_stmt|;
name|cur_mem_info_p
operator|=
name|obj_desc_p
operator|->
name|mem_hash
index|[
name|hash_val
index|]
expr_stmt|;
while|while
condition|(
name|cur_mem_info_p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cur_mem_info_p
operator|->
name|addr
operator|==
name|addr
condition|)
block|{
comment|/* Found given address in the database - remove from the bucket/list */
if|if
condition|(
name|prev_mem_info_p
operator|==
name|NULL
condition|)
block|{
name|obj_desc_p
operator|->
name|mem_hash
index|[
name|hash_val
index|]
operator|=
name|cur_mem_info_p
operator|->
name|next
expr_stmt|;
comment|/* removing first */
block|}
else|else
block|{
name|prev_mem_info_p
operator|->
name|next
operator|=
name|cur_mem_info_p
operator|->
name|next
expr_stmt|;
comment|/* "crossover" */
block|}
name|list_del
argument_list|(
operator|&
name|cur_mem_info_p
operator|->
name|list
argument_list|)
expr_stmt|;
name|obj_desc_p
operator|->
name|count
operator|-=
name|cur_mem_info_p
operator|->
name|size
expr_stmt|;
name|memtrack_spin_unlock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|meminfo_cache
argument_list|,
name|cur_mem_info_p
argument_list|)
expr_stmt|;
return|return;
block|}
name|prev_mem_info_p
operator|=
name|cur_mem_info_p
expr_stmt|;
name|cur_mem_info_p
operator|=
name|cur_mem_info_p
operator|->
name|next
expr_stmt|;
block|}
comment|/* not found */
name|printk
argument_list|(
literal|"mtl rsc inconsistency: %s: %s::%lu: %s for unknown address=0x%lX\n"
argument_list|,
name|__func__
argument_list|,
name|filename
argument_list|,
name|line_num
argument_list|,
name|memtype_free_str
argument_list|(
name|memtype
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|memtrack_spin_unlock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Report current allocations status (for all memory types) */
end_comment

begin_function
specifier|static
name|void
name|memtrack_report
parameter_list|(
name|void
parameter_list|)
block|{
name|memtrack_memtype_t
name|memtype
decl_stmt|;
name|unsigned
name|long
name|cur_bucket
decl_stmt|;
name|memtrack_meminfo_t
modifier|*
name|cur_mem_info_p
decl_stmt|;
name|int
name|serial
init|=
literal|1
decl_stmt|;
name|tracked_obj_desc_t
modifier|*
name|obj_desc_p
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|printk
argument_list|(
literal|"%s: Currently known allocations:\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
for|for
control|(
name|memtype
operator|=
literal|0
init|;
name|memtype
operator|<
name|MEMTRACK_NUM_OF_MEMTYPES
condition|;
name|memtype
operator|++
control|)
block|{
if|if
condition|(
name|tracked_objs_arr
index|[
name|memtype
index|]
condition|)
block|{
name|printk
argument_list|(
literal|"%d) %s:\n"
argument_list|,
name|serial
argument_list|,
name|memtype_alloc_str
argument_list|(
name|memtype
argument_list|)
argument_list|)
expr_stmt|;
name|obj_desc_p
operator|=
name|tracked_objs_arr
index|[
name|memtype
index|]
expr_stmt|;
comment|/* Scan all buckets to find existing allocations */
comment|/* TBD: this may be optimized by holding a linked list of all hash items */
for|for
control|(
name|cur_bucket
operator|=
literal|0
init|;
name|cur_bucket
operator|<
name|MEMTRACK_HASH_SZ
condition|;
name|cur_bucket
operator|++
control|)
block|{
name|memtrack_spin_lock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* protect per bucket/list */
name|cur_mem_info_p
operator|=
name|obj_desc_p
operator|->
name|mem_hash
index|[
name|cur_bucket
index|]
expr_stmt|;
while|while
condition|(
name|cur_mem_info_p
operator|!=
name|NULL
condition|)
block|{
comment|/* scan bucket */
name|printk
argument_list|(
literal|"%s::%lu: %s(%lu)==%lX\n"
argument_list|,
name|cur_mem_info_p
operator|->
name|filename
argument_list|,
name|cur_mem_info_p
operator|->
name|line_num
argument_list|,
name|memtype_alloc_str
argument_list|(
name|memtype
argument_list|)
argument_list|,
name|cur_mem_info_p
operator|->
name|size
argument_list|,
name|cur_mem_info_p
operator|->
name|addr
argument_list|)
expr_stmt|;
name|cur_mem_info_p
operator|=
name|cur_mem_info_p
operator|->
name|next
expr_stmt|;
block|}
comment|/* while cur_mem_info_p */
name|memtrack_spin_unlock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/* for cur_bucket */
name|serial
operator|++
expr_stmt|;
block|}
block|}
comment|/* for memtype */
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|proc_dir_entry
modifier|*
name|memtrack_tree
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|memtrack_memtype_t
name|get_rsc_by_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|memtrack_memtype_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MEMTRACK_NUM_OF_MEMTYPES
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|rsc_names
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
name|i
return|;
block|}
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|memtrack_read
parameter_list|(
name|struct
name|file
modifier|*
name|filp
parameter_list|,
name|char
name|__user
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|loff_t
modifier|*
name|offset
parameter_list|)
block|{
name|unsigned
name|long
name|cur
decl_stmt|,
name|flags
decl_stmt|;
name|loff_t
name|pos
init|=
operator|*
name|offset
decl_stmt|;
specifier|static
name|char
name|kbuf
index|[
literal|20
index|]
decl_stmt|;
specifier|static
name|int
name|file_len
decl_stmt|;
name|int
name|_read
decl_stmt|,
name|to_ret
decl_stmt|,
name|left
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|memtrack_memtype_t
name|memtype
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
name|fname
operator|=
name|filp
operator|->
name|f_dentry
operator|->
name|d_name
operator|.
name|name
expr_stmt|;
name|memtype
operator|=
name|get_rsc_by_name
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|memtype
operator|>=
name|MEMTRACK_NUM_OF_MEMTYPES
condition|)
block|{
name|printk
argument_list|(
literal|"invalid file name\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
block|{
name|memtrack_spin_lock
argument_list|(
operator|&
name|tracked_objs_arr
index|[
name|memtype
index|]
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|cur
operator|=
name|tracked_objs_arr
index|[
name|memtype
index|]
operator|->
name|count
expr_stmt|;
name|memtrack_spin_unlock
argument_list|(
operator|&
name|tracked_objs_arr
index|[
name|memtype
index|]
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|_read
operator|=
name|sprintf
argument_list|(
name|kbuf
argument_list|,
literal|"%lu\n"
argument_list|,
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|_read
operator|<
literal|0
condition|)
block|{
return|return
name|_read
return|;
block|}
else|else
block|{
name|file_len
operator|=
name|_read
expr_stmt|;
block|}
block|}
name|left
operator|=
name|file_len
operator|-
name|pos
expr_stmt|;
name|to_ret
operator|=
operator|(
name|left
operator|<
name|size
operator|)
condition|?
name|left
else|:
name|size
expr_stmt|;
if|if
condition|(
name|copy_to_user
argument_list|(
name|buf
argument_list|,
name|kbuf
operator|+
name|pos
argument_list|,
name|to_ret
argument_list|)
condition|)
block|{
return|return
operator|-
name|EFAULT
return|;
block|}
else|else
block|{
operator|*
name|offset
operator|=
name|pos
operator|+
name|to_ret
expr_stmt|;
return|return
name|to_ret
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|file_operations
name|memtrack_proc_fops
init|=
block|{
operator|.
name|read
operator|=
name|memtrack_read
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|memtrack_proc_entry_name
init|=
literal|"mt_memtrack"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|create_procfs_tree
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|proc_dir_entry
modifier|*
name|dir_ent
decl_stmt|;
name|struct
name|proc_dir_entry
modifier|*
name|proc_ent
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|long
name|bit_mask
decl_stmt|;
name|dir_ent
operator|=
name|proc_mkdir
argument_list|(
name|memtrack_proc_entry_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dir_ent
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|memtrack_tree
operator|=
name|dir_ent
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|bit_mask
operator|=
literal|1
init|;
name|i
operator|<
name|MEMTRACK_NUM_OF_MEMTYPES
condition|;
operator|++
name|i
operator|,
name|bit_mask
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|bit_mask
operator|&
name|track_mask
condition|)
block|{
name|proc_ent
operator|=
name|create_proc_entry
argument_list|(
name|rsc_names
index|[
name|i
index|]
argument_list|,
name|S_IRUGO
argument_list|,
name|memtrack_tree
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proc_ent
condition|)
goto|goto
name|undo_create_root
goto|;
name|proc_ent
operator|->
name|proc_fops
operator|=
operator|&
name|memtrack_proc_fops
expr_stmt|;
block|}
block|}
goto|goto
name|exit_ok
goto|;
name|undo_create_root
label|:
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|bit_mask
operator|=
literal|1
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
operator|,
name|bit_mask
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|bit_mask
operator|&
name|track_mask
condition|)
block|{
name|remove_proc_entry
argument_list|(
name|rsc_names
index|[
name|j
index|]
argument_list|,
name|memtrack_tree
argument_list|)
expr_stmt|;
block|}
block|}
name|remove_proc_entry
argument_list|(
name|memtrack_proc_entry_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
name|exit_ok
label|:
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_procfs_tree
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|bit_mask
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|bit_mask
operator|=
literal|1
init|;
name|i
operator|<
name|MEMTRACK_NUM_OF_MEMTYPES
condition|;
operator|++
name|i
operator|,
name|bit_mask
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|bit_mask
operator|&
name|track_mask
condition|)
block|{
name|remove_proc_entry
argument_list|(
name|rsc_names
index|[
name|i
index|]
argument_list|,
name|memtrack_tree
argument_list|)
expr_stmt|;
block|}
block|}
name|remove_proc_entry
argument_list|(
name|memtrack_proc_entry_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* module entry points */
end_comment

begin_function
name|int
name|init_module
parameter_list|(
name|void
parameter_list|)
block|{
name|memtrack_memtype_t
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|unsigned
name|long
name|bit_mask
decl_stmt|;
comment|/* create a cache for the memtrack_meminfo_t strcutures */
name|meminfo_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"memtrack_meminfo_t"
argument_list|,
sizeof|sizeof
argument_list|(
name|memtrack_meminfo_t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SLAB_HWCACHE_ALIGN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|meminfo_cache
condition|)
block|{
name|printk
argument_list|(
literal|"memtrack::%s: failed to allocate meminfo cache\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* initialize array of descriptors */
name|memset
argument_list|(
name|tracked_objs_arr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tracked_objs_arr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create a tracking object descriptor for all required objects */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|bit_mask
operator|=
literal|1
init|;
name|i
operator|<
name|MEMTRACK_NUM_OF_MEMTYPES
condition|;
operator|++
name|i
operator|,
name|bit_mask
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|bit_mask
operator|&
name|track_mask
condition|)
block|{
name|tracked_objs_arr
index|[
name|i
index|]
operator|=
name|vmalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tracked_obj_desc_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tracked_objs_arr
index|[
name|i
index|]
condition|)
block|{
name|printk
argument_list|(
literal|"memtrack: failed to allocate tracking object\n"
argument_list|)
expr_stmt|;
goto|goto
name|undo_cache_create
goto|;
block|}
name|memset
argument_list|(
name|tracked_objs_arr
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tracked_obj_desc_t
argument_list|)
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|tracked_objs_arr
index|[
name|i
index|]
operator|->
name|hash_lock
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|tracked_objs_arr
index|[
name|i
index|]
operator|->
name|tracked_objs_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit_mask
operator|&
name|strict_track_mask
condition|)
block|{
name|tracked_objs_arr
index|[
name|i
index|]
operator|->
name|strict_track
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tracked_objs_arr
index|[
name|i
index|]
operator|->
name|strict_track
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|create_procfs_tree
argument_list|()
condition|)
block|{
name|printk
argument_list|(
literal|"%s: create_procfs_tree() failed\n"
argument_list|,
name|__FILE__
argument_list|)
expr_stmt|;
goto|goto
name|undo_cache_create
goto|;
block|}
name|printk
argument_list|(
literal|"memtrack::%s done.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|undo_cache_create
label|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|tracked_objs_arr
index|[
name|j
index|]
condition|)
block|{
name|vfree
argument_list|(
name|tracked_objs_arr
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|#
directive|if
name|LINUX_VERSION_CODE
operator|<
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|19
argument_list|)
if|if
condition|(
name|kmem_cache_destroy
argument_list|(
name|meminfo_cache
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printk
argument_list|(
literal|"Failed on kmem_cache_destroy !\n"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|kmem_cache_destroy
argument_list|(
name|meminfo_cache
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
name|cleanup_module
parameter_list|(
name|void
parameter_list|)
block|{
name|memtrack_memtype_t
name|memtype
decl_stmt|;
name|unsigned
name|long
name|cur_bucket
decl_stmt|;
name|memtrack_meminfo_t
modifier|*
name|cur_mem_info_p
decl_stmt|,
modifier|*
name|next_mem_info_p
decl_stmt|;
name|tracked_obj_desc_t
modifier|*
name|obj_desc_p
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|memtrack_report
argument_list|()
expr_stmt|;
name|destroy_procfs_tree
argument_list|()
expr_stmt|;
comment|/* clean up any hash table left-overs */
for|for
control|(
name|memtype
operator|=
literal|0
init|;
name|memtype
operator|<
name|MEMTRACK_NUM_OF_MEMTYPES
condition|;
name|memtype
operator|++
control|)
block|{
comment|/* Scan all buckets to find existing allocations */
comment|/* TBD: this may be optimized by holding a linked list of all hash items */
if|if
condition|(
name|tracked_objs_arr
index|[
name|memtype
index|]
condition|)
block|{
name|obj_desc_p
operator|=
name|tracked_objs_arr
index|[
name|memtype
index|]
expr_stmt|;
for|for
control|(
name|cur_bucket
operator|=
literal|0
init|;
name|cur_bucket
operator|<
name|MEMTRACK_HASH_SZ
condition|;
name|cur_bucket
operator|++
control|)
block|{
name|memtrack_spin_lock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* protect per bucket/list */
name|cur_mem_info_p
operator|=
name|obj_desc_p
operator|->
name|mem_hash
index|[
name|cur_bucket
index|]
expr_stmt|;
while|while
condition|(
name|cur_mem_info_p
operator|!=
name|NULL
condition|)
block|{
comment|/* scan bucket */
name|next_mem_info_p
operator|=
name|cur_mem_info_p
operator|->
name|next
expr_stmt|;
comment|/* save "next" pointer before the "free" */
name|kmem_cache_free
argument_list|(
name|meminfo_cache
argument_list|,
name|cur_mem_info_p
argument_list|)
expr_stmt|;
name|cur_mem_info_p
operator|=
name|next_mem_info_p
expr_stmt|;
block|}
comment|/* while cur_mem_info_p */
name|memtrack_spin_unlock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/* for cur_bucket */
name|vfree
argument_list|(
name|obj_desc_p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* for memtype */
if|#
directive|if
name|LINUX_VERSION_CODE
operator|<
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|19
argument_list|)
if|if
condition|(
name|kmem_cache_destroy
argument_list|(
name|meminfo_cache
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printk
argument_list|(
literal|"memtrack::cleanup_module: Failed on kmem_cache_destroy !\n"
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|kmem_cache_destroy
argument_list|(
name|meminfo_cache
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printk
argument_list|(
literal|"memtrack::cleanup_module done.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|memtrack_alloc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|memtrack_free
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|//module_init(memtrack_init)
end_comment

begin_comment
comment|//module_exit(memtrack_exit)
end_comment

end_unit

