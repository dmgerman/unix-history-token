begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   This software is available to you under a choice of one of two   licenses.  You may choose to be licensed under the terms of the GNU   General Public License (GPL) Version 2, available at<http://www.fsf.org/copyleft/gpl.html>, or the OpenIB.org BSD   license, available in the LICENSE.TXT file accompanying this   software.  These details are also available at<http://openib.org/license.html>.    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE   SOFTWARE.    Copyright (c) 2004 Mellanox Technologies Ltd.  All rights reserved. */
end_comment

begin_define
define|#
directive|define
name|C_MEMTRACK_C
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|kmalloc
end_ifdef

begin_undef
undef|#
directive|undef
name|kmalloc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|kmemdup
end_ifdef

begin_undef
undef|#
directive|undef
name|kmemdup
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|kfree
end_ifdef

begin_undef
undef|#
directive|undef
name|kfree
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|vmalloc
end_ifdef

begin_undef
undef|#
directive|undef
name|vmalloc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|vzalloc
end_ifdef

begin_undef
undef|#
directive|undef
name|vzalloc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|vzalloc_node
end_ifdef

begin_undef
undef|#
directive|undef
name|vzalloc_node
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|vfree
end_ifdef

begin_undef
undef|#
directive|undef
name|vfree
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|kmem_cache_alloc
end_ifdef

begin_undef
undef|#
directive|undef
name|kmem_cache_alloc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|kmem_cache_free
end_ifdef

begin_undef
undef|#
directive|undef
name|kmem_cache_free
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ioremap
end_ifdef

begin_undef
undef|#
directive|undef
name|ioremap
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|io_mapping_create_wc
end_ifdef

begin_undef
undef|#
directive|undef
name|io_mapping_create_wc
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|io_mapping_free
end_ifdef

begin_undef
undef|#
directive|undef
name|io_mapping_free
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ioremap_nocache
end_ifdef

begin_undef
undef|#
directive|undef
name|ioremap_nocache
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|iounmap
end_ifdef

begin_undef
undef|#
directive|undef
name|iounmap
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|alloc_pages
end_ifdef

begin_undef
undef|#
directive|undef
name|alloc_pages
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|free_pages
end_ifdef

begin_undef
undef|#
directive|undef
name|free_pages
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|get_page
end_ifdef

begin_undef
undef|#
directive|undef
name|get_page
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|put_page
end_ifdef

begin_undef
undef|#
directive|undef
name|put_page
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|create_workqueue
end_ifdef

begin_undef
undef|#
directive|undef
name|create_workqueue
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|create_rt_workqueue
end_ifdef

begin_undef
undef|#
directive|undef
name|create_rt_workqueue
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|create_freezeable_workqueue
end_ifdef

begin_undef
undef|#
directive|undef
name|create_freezeable_workqueue
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|create_singlethread_workqueue
end_ifdef

begin_undef
undef|#
directive|undef
name|create_singlethread_workqueue
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|destroy_workqueue
end_ifdef

begin_undef
undef|#
directive|undef
name|destroy_workqueue
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/kernel.h>
end_include

begin_include
include|#
directive|include
file|<linux/slab.h>
end_include

begin_include
include|#
directive|include
file|<linux/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<linux/vmalloc.h>
end_include

begin_include
include|#
directive|include
file|<linux/mm.h>
end_include

begin_include
include|#
directive|include
file|<asm/uaccess.h>
end_include

begin_include
include|#
directive|include
file|<linux/proc_fs.h>
end_include

begin_include
include|#
directive|include
file|<linux/random.h>
end_include

begin_include
include|#
directive|include
file|"memtrack.h"
end_include

begin_include
include|#
directive|include
file|<linux/moduleparam.h>
end_include

begin_expr_stmt
name|MODULE_AUTHOR
argument_list|(
literal|"Mellanox Technologies LTD."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DESCRIPTION
argument_list|(
literal|"Memory allocations tracking"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_LICENSE
argument_list|(
literal|"GPL"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|MEMTRACK_HASH_SZ
value|((1<<15)-19)
end_define

begin_comment
comment|/* prime: http://www.utm.edu/research/primes/lists/2small/0bit.html */
end_comment

begin_define
define|#
directive|define
name|MAX_FILENAME_LEN
value|31
end_define

begin_define
define|#
directive|define
name|memtrack_spin_lock
parameter_list|(
name|spl
parameter_list|,
name|flags
parameter_list|)
value|spin_lock_irqsave(spl, flags)
end_define

begin_define
define|#
directive|define
name|memtrack_spin_unlock
parameter_list|(
name|spl
parameter_list|,
name|flags
parameter_list|)
value|spin_unlock_irqrestore(spl, flags)
end_define

begin_comment
comment|/* if a bit is set then the corresponding allocation is tracked.    bit0 corresponds to MEMTRACK_KMALLOC, bit1 corresponds to MEMTRACK_VMALLOC etc. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|track_mask
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* effectively everything */
end_comment

begin_expr_stmt
name|module_param
argument_list|(
name|track_mask
argument_list|,
name|ulong
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|track_mask
argument_list|,
literal|"bitmask defining what is tracked"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* if a bit is set then the corresponding allocation is strictly tracked.    That is, before inserting the whole range is checked to not overlap any    of the allocations already in the database */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|strict_track_mask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* no strict tracking */
end_comment

begin_expr_stmt
name|module_param
argument_list|(
name|strict_track_mask
argument_list|,
name|ulong
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|strict_track_mask
argument_list|,
literal|"bitmask which allocation requires strict tracking"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Sets the frequency of allocations failures injections    if set to 0 all allocation should succeed */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|inject_freq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param
argument_list|(
name|inject_freq
argument_list|,
name|uint
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|inject_freq
argument_list|,
literal|"Error injection frequency, default is 0 (disabled)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|random_mem
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param
argument_list|(
name|random_mem
argument_list|,
name|uint
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|random_mem
argument_list|,
literal|"When set, randomize allocated memory, default is 1 (enabled)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|memtrack_meminfo_t
block|{
name|unsigned
name|long
name|addr
decl_stmt|;
name|unsigned
name|long
name|size
decl_stmt|;
name|unsigned
name|long
name|line_num
decl_stmt|;
name|unsigned
name|long
name|dev
decl_stmt|;
name|unsigned
name|long
name|addr2
decl_stmt|;
name|int
name|direction
decl_stmt|;
name|struct
name|memtrack_meminfo_t
modifier|*
name|next
decl_stmt|;
name|struct
name|list_head
name|list
decl_stmt|;
comment|/* used to link all items from a certain type together */
name|char
name|filename
index|[
name|MAX_FILENAME_LEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* putting the char array last is better for struct. packing */
name|char
name|ext_info
index|[
literal|32
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|kmem_cache
modifier|*
name|meminfo_cache
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|tracked_obj_desc_t
block|{
name|struct
name|memtrack_meminfo_t
modifier|*
name|mem_hash
index|[
name|MEMTRACK_HASH_SZ
index|]
decl_stmt|;
name|spinlock_t
name|hash_lock
decl_stmt|;
name|unsigned
name|long
name|count
decl_stmt|;
comment|/* size of memory tracked (*malloc) or number of objects tracked */
name|struct
name|list_head
name|tracked_objs_head
decl_stmt|;
comment|/* head of list of all objects */
name|int
name|strict_track
decl_stmt|;
comment|/* if 1 then for each object inserted check if it overlaps any of the objects already in the list */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|tracked_obj_desc_t
modifier|*
name|tracked_objs_arr
index|[
name|MEMTRACK_NUM_OF_MEMTYPES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|rsc_names
index|[
name|MEMTRACK_NUM_OF_MEMTYPES
index|]
init|=
block|{
literal|"kmalloc"
block|,
literal|"vmalloc"
block|,
literal|"kmem_cache_alloc"
block|,
literal|"io_remap"
block|,
literal|"create_workqueue"
block|,
literal|"alloc_pages"
block|,
literal|"ib_dma_map_single"
block|,
literal|"ib_dma_map_page"
block|,
literal|"ib_dma_map_sg"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|rsc_free_names
index|[
name|MEMTRACK_NUM_OF_MEMTYPES
index|]
init|=
block|{
literal|"kfree"
block|,
literal|"vfree"
block|,
literal|"kmem_cache_free"
block|,
literal|"io_unmap"
block|,
literal|"destory_workqueue"
block|,
literal|"free_pages"
block|,
literal|"ib_dma_unmap_single"
block|,
literal|"ib_dma_unmap_page"
block|,
literal|"ib_dma_unmap_sg"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|memtype_alloc_str
parameter_list|(
name|enum
name|memtrack_memtype_t
name|memtype
parameter_list|)
block|{
switch|switch
condition|(
name|memtype
condition|)
block|{
case|case
name|MEMTRACK_KMALLOC
case|:
case|case
name|MEMTRACK_VMALLOC
case|:
case|case
name|MEMTRACK_KMEM_OBJ
case|:
case|case
name|MEMTRACK_IOREMAP
case|:
case|case
name|MEMTRACK_WORK_QUEUE
case|:
case|case
name|MEMTRACK_PAGE_ALLOC
case|:
case|case
name|MEMTRACK_DMA_MAP_SINGLE
case|:
case|case
name|MEMTRACK_DMA_MAP_PAGE
case|:
case|case
name|MEMTRACK_DMA_MAP_SG
case|:
return|return
name|rsc_names
index|[
name|memtype
index|]
return|;
default|default:
return|return
literal|"(Unknown allocation type)"
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|memtype_free_str
parameter_list|(
name|enum
name|memtrack_memtype_t
name|memtype
parameter_list|)
block|{
switch|switch
condition|(
name|memtype
condition|)
block|{
case|case
name|MEMTRACK_KMALLOC
case|:
case|case
name|MEMTRACK_VMALLOC
case|:
case|case
name|MEMTRACK_KMEM_OBJ
case|:
case|case
name|MEMTRACK_IOREMAP
case|:
case|case
name|MEMTRACK_WORK_QUEUE
case|:
case|case
name|MEMTRACK_PAGE_ALLOC
case|:
case|case
name|MEMTRACK_DMA_MAP_SINGLE
case|:
case|case
name|MEMTRACK_DMA_MAP_PAGE
case|:
case|case
name|MEMTRACK_DMA_MAP_SG
case|:
return|return
name|rsc_free_names
index|[
name|memtype
index|]
return|;
default|default:
return|return
literal|"(Unknown allocation type)"
return|;
block|}
block|}
end_function

begin_comment
comment|/*  *  overlap_a_b  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|overlap_a_b
parameter_list|(
name|unsigned
name|long
name|a_start
parameter_list|,
name|unsigned
name|long
name|a_end
parameter_list|,
name|unsigned
name|long
name|b_start
parameter_list|,
name|unsigned
name|long
name|b_end
parameter_list|)
block|{
if|if
condition|(
operator|(
name|b_start
operator|>
name|a_end
operator|)
operator|||
operator|(
name|a_start
operator|>
name|b_end
operator|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  *  check_overlap  */
end_comment

begin_function
specifier|static
name|void
name|check_overlap
parameter_list|(
name|enum
name|memtrack_memtype_t
name|memtype
parameter_list|,
name|struct
name|memtrack_meminfo_t
modifier|*
name|mem_info_p
parameter_list|,
name|struct
name|tracked_obj_desc_t
modifier|*
name|obj_desc_p
parameter_list|)
block|{
name|struct
name|list_head
modifier|*
name|pos
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|memtrack_meminfo_t
modifier|*
name|cur
decl_stmt|;
name|unsigned
name|long
name|start_a
decl_stmt|,
name|end_a
decl_stmt|,
name|start_b
decl_stmt|,
name|end_b
decl_stmt|;
name|start_a
operator|=
name|mem_info_p
operator|->
name|addr
expr_stmt|;
name|end_a
operator|=
name|mem_info_p
operator|->
name|addr
operator|+
name|mem_info_p
operator|->
name|size
operator|-
literal|1
expr_stmt|;
name|list_for_each_safe
argument_list|(
argument|pos
argument_list|,
argument|next
argument_list|,
argument|&obj_desc_p->tracked_objs_head
argument_list|)
block|{
name|cur
operator|=
name|list_entry
argument_list|(
name|pos
argument_list|,
expr|struct
name|memtrack_meminfo_t
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|start_b
operator|=
name|cur
operator|->
name|addr
expr_stmt|;
name|end_b
operator|=
name|cur
operator|->
name|addr
operator|+
name|cur
operator|->
name|size
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|overlap_a_b
argument_list|(
name|start_a
argument_list|,
name|end_a
argument_list|,
name|start_b
argument_list|,
name|end_b
argument_list|)
condition|)
name|printk
argument_list|(
name|KERN_ERR
literal|"%s overlaps! new_start=0x%lx, new_end=0x%lx, item_start=0x%lx, item_end=0x%lx\n"
argument_list|,
name|memtype_alloc_str
argument_list|(
name|memtype
argument_list|)
argument_list|,
name|mem_info_p
operator|->
name|addr
argument_list|,
name|mem_info_p
operator|->
name|addr
operator|+
name|mem_info_p
operator|->
name|size
operator|-
literal|1
argument_list|,
name|cur
operator|->
name|addr
argument_list|,
name|cur
operator|->
name|addr
operator|+
name|cur
operator|->
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Invoke on memory allocation */
end_comment

begin_function
name|void
name|memtrack_alloc
parameter_list|(
name|enum
name|memtrack_memtype_t
name|memtype
parameter_list|,
name|unsigned
name|long
name|dev
parameter_list|,
name|unsigned
name|long
name|addr
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|unsigned
name|long
name|addr2
parameter_list|,
name|int
name|direction
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|unsigned
name|long
name|line_num
parameter_list|,
name|int
name|alloc_flags
parameter_list|)
block|{
name|unsigned
name|long
name|hash_val
decl_stmt|;
name|struct
name|memtrack_meminfo_t
modifier|*
name|cur_mem_info_p
decl_stmt|,
modifier|*
name|new_mem_info_p
decl_stmt|;
name|struct
name|tracked_obj_desc_t
modifier|*
name|obj_desc_p
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
if|if
condition|(
name|memtype
operator|>=
name|MEMTRACK_NUM_OF_MEMTYPES
condition|)
block|{
name|printk
argument_list|(
name|KERN_ERR
literal|"%s: Invalid memory type (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|memtype
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|tracked_objs_arr
index|[
name|memtype
index|]
condition|)
block|{
comment|/* object is not tracked */
return|return;
block|}
name|obj_desc_p
operator|=
name|tracked_objs_arr
index|[
name|memtype
index|]
expr_stmt|;
name|hash_val
operator|=
name|addr
operator|%
name|MEMTRACK_HASH_SZ
expr_stmt|;
name|new_mem_info_p
operator|=
operator|(
expr|struct
name|memtrack_meminfo_t
operator|*
operator|)
name|kmem_cache_alloc
argument_list|(
name|meminfo_cache
argument_list|,
name|alloc_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_mem_info_p
operator|==
name|NULL
condition|)
block|{
name|printk
argument_list|(
name|KERN_ERR
literal|"%s: Failed allocating kmem_cache item for new mem_info. "
literal|"Lost tracking on allocation at %s:%lu...\n"
argument_list|,
name|__func__
argument_list|,
name|filename
argument_list|,
name|line_num
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* save allocation properties */
name|new_mem_info_p
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|new_mem_info_p
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|new_mem_info_p
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|new_mem_info_p
operator|->
name|addr2
operator|=
name|addr2
expr_stmt|;
name|new_mem_info_p
operator|->
name|direction
operator|=
name|direction
expr_stmt|;
name|new_mem_info_p
operator|->
name|line_num
operator|=
name|line_num
expr_stmt|;
operator|*
name|new_mem_info_p
operator|->
name|ext_info
operator|=
literal|'\0'
expr_stmt|;
comment|/* Make sure that we will print out the path tail if the given filename is longer          * than MAX_FILENAME_LEN. (otherwise, we will not see the name of the actual file          * in the printout -- only the path head!          */
if|if
condition|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|>
name|MAX_FILENAME_LEN
condition|)
name|strncpy
argument_list|(
name|new_mem_info_p
operator|->
name|filename
argument_list|,
name|filename
operator|+
name|strlen
argument_list|(
name|filename
argument_list|)
operator|-
name|MAX_FILENAME_LEN
argument_list|,
name|MAX_FILENAME_LEN
argument_list|)
expr_stmt|;
else|else
name|strncpy
argument_list|(
name|new_mem_info_p
operator|->
name|filename
argument_list|,
name|filename
argument_list|,
name|MAX_FILENAME_LEN
argument_list|)
expr_stmt|;
name|new_mem_info_p
operator|->
name|filename
index|[
name|MAX_FILENAME_LEN
index|]
operator|=
literal|0
expr_stmt|;
comment|/* NULL terminate anyway */
name|memtrack_spin_lock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* make sure given memory location is not already allocated */
if|if
condition|(
operator|(
name|memtype
operator|!=
name|MEMTRACK_DMA_MAP_SINGLE
operator|)
operator|&&
operator|(
name|memtype
operator|!=
name|MEMTRACK_DMA_MAP_PAGE
operator|)
operator|&&
operator|(
name|memtype
operator|!=
name|MEMTRACK_DMA_MAP_SG
operator|)
condition|)
block|{
comment|/* make sure given memory location is not already allocated */
name|cur_mem_info_p
operator|=
name|obj_desc_p
operator|->
name|mem_hash
index|[
name|hash_val
index|]
expr_stmt|;
while|while
condition|(
name|cur_mem_info_p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|cur_mem_info_p
operator|->
name|addr
operator|==
name|addr
operator|)
operator|&&
operator|(
name|cur_mem_info_p
operator|->
name|dev
operator|==
name|dev
operator|)
condition|)
block|{
comment|/* Found given address in the database */
name|printk
argument_list|(
name|KERN_ERR
literal|"mtl rsc inconsistency: %s: %s::%lu: %s @ addr=0x%lX which is already known from %s:%lu\n"
argument_list|,
name|__func__
argument_list|,
name|filename
argument_list|,
name|line_num
argument_list|,
name|memtype_alloc_str
argument_list|(
name|memtype
argument_list|)
argument_list|,
name|addr
argument_list|,
name|cur_mem_info_p
operator|->
name|filename
argument_list|,
name|cur_mem_info_p
operator|->
name|line_num
argument_list|)
expr_stmt|;
name|memtrack_spin_unlock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|meminfo_cache
argument_list|,
name|new_mem_info_p
argument_list|)
expr_stmt|;
return|return;
block|}
name|cur_mem_info_p
operator|=
name|cur_mem_info_p
operator|->
name|next
expr_stmt|;
block|}
block|}
comment|/* not found - we can put in the hash bucket */
comment|/* link as first */
name|new_mem_info_p
operator|->
name|next
operator|=
name|obj_desc_p
operator|->
name|mem_hash
index|[
name|hash_val
index|]
expr_stmt|;
name|obj_desc_p
operator|->
name|mem_hash
index|[
name|hash_val
index|]
operator|=
name|new_mem_info_p
expr_stmt|;
if|if
condition|(
name|obj_desc_p
operator|->
name|strict_track
condition|)
name|check_overlap
argument_list|(
name|memtype
argument_list|,
name|new_mem_info_p
argument_list|,
name|obj_desc_p
argument_list|)
expr_stmt|;
name|obj_desc_p
operator|->
name|count
operator|+=
name|size
expr_stmt|;
name|list_add
argument_list|(
operator|&
name|new_mem_info_p
operator|->
name|list
argument_list|,
operator|&
name|obj_desc_p
operator|->
name|tracked_objs_head
argument_list|)
expr_stmt|;
name|memtrack_spin_unlock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|memtrack_alloc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Invoke on memory free */
end_comment

begin_function
name|void
name|memtrack_free
parameter_list|(
name|enum
name|memtrack_memtype_t
name|memtype
parameter_list|,
name|unsigned
name|long
name|dev
parameter_list|,
name|unsigned
name|long
name|addr
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
name|int
name|direction
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|unsigned
name|long
name|line_num
parameter_list|)
block|{
name|unsigned
name|long
name|hash_val
decl_stmt|;
name|struct
name|memtrack_meminfo_t
modifier|*
name|cur_mem_info_p
decl_stmt|,
modifier|*
name|prev_mem_info_p
decl_stmt|;
name|struct
name|tracked_obj_desc_t
modifier|*
name|obj_desc_p
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
if|if
condition|(
name|memtype
operator|>=
name|MEMTRACK_NUM_OF_MEMTYPES
condition|)
block|{
name|printk
argument_list|(
name|KERN_ERR
literal|"%s: Invalid memory type (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|memtype
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|tracked_objs_arr
index|[
name|memtype
index|]
condition|)
block|{
comment|/* object is not tracked */
return|return;
block|}
name|obj_desc_p
operator|=
name|tracked_objs_arr
index|[
name|memtype
index|]
expr_stmt|;
name|hash_val
operator|=
name|addr
operator|%
name|MEMTRACK_HASH_SZ
expr_stmt|;
name|memtrack_spin_lock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* find  mem_info of given memory location */
name|prev_mem_info_p
operator|=
name|NULL
expr_stmt|;
name|cur_mem_info_p
operator|=
name|obj_desc_p
operator|->
name|mem_hash
index|[
name|hash_val
index|]
expr_stmt|;
while|while
condition|(
name|cur_mem_info_p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|cur_mem_info_p
operator|->
name|addr
operator|==
name|addr
operator|)
operator|&&
operator|(
name|cur_mem_info_p
operator|->
name|dev
operator|==
name|dev
operator|)
condition|)
block|{
comment|/* Found given address in the database */
if|if
condition|(
operator|(
name|memtype
operator|==
name|MEMTRACK_DMA_MAP_SINGLE
operator|)
operator|||
operator|(
name|memtype
operator|==
name|MEMTRACK_DMA_MAP_PAGE
operator|)
operator|||
operator|(
name|memtype
operator|==
name|MEMTRACK_DMA_MAP_SG
operator|)
condition|)
block|{
if|if
condition|(
name|direction
operator|!=
name|cur_mem_info_p
operator|->
name|direction
condition|)
name|printk
argument_list|(
name|KERN_ERR
literal|"mtl rsc inconsistency: %s: %s::%lu: %s bad direction for addr 0x%lX: alloc:0x%x, free:0x%x (allocated in %s::%lu)\n"
argument_list|,
name|__func__
argument_list|,
name|filename
argument_list|,
name|line_num
argument_list|,
name|memtype_free_str
argument_list|(
name|memtype
argument_list|)
argument_list|,
name|addr
argument_list|,
name|cur_mem_info_p
operator|->
name|direction
argument_list|,
name|direction
argument_list|,
name|cur_mem_info_p
operator|->
name|filename
argument_list|,
name|cur_mem_info_p
operator|->
name|line_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
name|cur_mem_info_p
operator|->
name|size
condition|)
name|printk
argument_list|(
name|KERN_ERR
literal|"mtl rsc inconsistency: %s: %s::%lu: %s bad size for addr 0x%lX: size:%lu, free:%lu (allocated in %s::%lu)\n"
argument_list|,
name|__func__
argument_list|,
name|filename
argument_list|,
name|line_num
argument_list|,
name|memtype_free_str
argument_list|(
name|memtype
argument_list|)
argument_list|,
name|addr
argument_list|,
name|cur_mem_info_p
operator|->
name|size
argument_list|,
name|size
argument_list|,
name|cur_mem_info_p
operator|->
name|filename
argument_list|,
name|cur_mem_info_p
operator|->
name|line_num
argument_list|)
expr_stmt|;
block|}
comment|/* Remove from the bucket/list */
if|if
condition|(
name|prev_mem_info_p
operator|==
name|NULL
condition|)
name|obj_desc_p
operator|->
name|mem_hash
index|[
name|hash_val
index|]
operator|=
name|cur_mem_info_p
operator|->
name|next
expr_stmt|;
comment|/* removing first */
else|else
name|prev_mem_info_p
operator|->
name|next
operator|=
name|cur_mem_info_p
operator|->
name|next
expr_stmt|;
comment|/* "crossover" */
name|list_del
argument_list|(
operator|&
name|cur_mem_info_p
operator|->
name|list
argument_list|)
expr_stmt|;
name|obj_desc_p
operator|->
name|count
operator|-=
name|cur_mem_info_p
operator|->
name|size
expr_stmt|;
name|memtrack_spin_unlock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|meminfo_cache
argument_list|,
name|cur_mem_info_p
argument_list|)
expr_stmt|;
return|return;
block|}
name|prev_mem_info_p
operator|=
name|cur_mem_info_p
expr_stmt|;
name|cur_mem_info_p
operator|=
name|cur_mem_info_p
operator|->
name|next
expr_stmt|;
block|}
comment|/* not found */
name|printk
argument_list|(
name|KERN_ERR
literal|"mtl rsc inconsistency: %s: %s::%lu: %s for unknown address=0x%lX, device=0x%lX\n"
argument_list|,
name|__func__
argument_list|,
name|filename
argument_list|,
name|line_num
argument_list|,
name|memtype_free_str
argument_list|(
name|memtype
argument_list|)
argument_list|,
name|addr
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|memtrack_spin_unlock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|memtrack_free
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This function recognizes allocations which  * may be released by kernel (e.g. skb) and  * therefore not trackable by memtrack.  * The allocations are recognized by the name  * of their calling function.  */
end_comment

begin_function
name|int
name|is_non_trackable_alloc_func
parameter_list|(
specifier|const
name|char
modifier|*
name|func_name
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|str_str_arr
index|[]
init|=
block|{
comment|/* functions containing these strings consider non trackable */
literal|"skb"
block|,         }
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|str_str_excep_arr
index|[]
init|=
block|{
comment|/* functions which are exception to the str_str_arr table */
literal|"ipoib_cm_skb_too_long"
block|}
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|str_cmp_arr
index|[]
init|=
block|{
comment|/* functions that allocate SKBs */
literal|"mlx4_en_alloc_frags"
block|,
literal|"mlx4_en_alloc_frag"
block|,
literal|"mlx4_en_init_allocator"
block|,
literal|"mlx4_en_free_frag"
block|,
literal|"mlx4_en_free_rx_desc"
block|,
literal|"mlx4_en_destroy_allocator"
block|,
literal|"mlx4_en_complete_rx_desc"
block|,
comment|/* vnic skb functions */
literal|"free_single_frag"
block|,
literal|"vnic_alloc_rx_skb"
block|,
literal|"vnic_rx_skb"
block|,
literal|"vnic_alloc_frag"
block|,
literal|"vnic_empty_rx_entry"
block|,
literal|"vnic_init_allocator"
block|,
literal|"vnic_destroy_allocator"
block|,
literal|"sdp_post_recv"
block|,
literal|"sdp_rx_ring_purge"
block|,
literal|"sdp_post_srcavail"
block|,
literal|"sk_stream_alloc_page"
block|,
literal|"update_send_head"
block|,
literal|"sdp_bcopy_get"
block|,
literal|"sdp_destroy_resources"
block|,
comment|/* function that allocate memory for RDMA device context */
literal|"ib_alloc_device"
block|}
decl_stmt|;
name|size_t
name|str_str_arr_size
init|=
sizeof|sizeof
argument_list|(
name|str_str_arr
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|;
name|size_t
name|str_str_excep_size
init|=
sizeof|sizeof
argument_list|(
name|str_str_excep_arr
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|;
name|size_t
name|str_cmp_arr_size
init|=
sizeof|sizeof
argument_list|(
name|str_cmp_arr
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|str_str_arr_size
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|strstr
argument_list|(
name|func_name
argument_list|,
name|str_str_arr
index|[
name|i
index|]
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|str_str_excep_size
condition|;
operator|++
name|j
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|func_name
argument_list|,
name|str_str_excep_arr
index|[
name|j
index|]
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|str_cmp_arr_size
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|func_name
argument_list|,
name|str_cmp_arr
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|is_non_trackable_alloc_func
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * In some cases we need to free a memory  * we defined as "non trackable" (see  * is_non_trackable_alloc_func).  * This function recognizes such releases  * by the name of their calling function.  */
end_comment

begin_function
name|int
name|is_non_trackable_free_func
parameter_list|(
specifier|const
name|char
modifier|*
name|func_name
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|str_cmp_arr
index|[]
init|=
block|{
comment|/* function that deallocate memory for RDMA device context */
literal|"ib_dealloc_device"
block|}
decl_stmt|;
name|size_t
name|str_cmp_arr_size
init|=
sizeof|sizeof
argument_list|(
name|str_cmp_arr
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|str_cmp_arr_size
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|func_name
argument_list|,
name|str_cmp_arr
index|[
name|i
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|is_non_trackable_free_func
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* WA - In this function handles confirm    the the function name is    '__ib_umem_release' or 'ib_umem_get'    In this case we won't track the    memory there because the kernel    was the one who allocated it.    Return value:      1 - if the function name is match, else 0 */
end_comment

begin_function
name|int
name|is_umem_put_page
parameter_list|(
specifier|const
name|char
modifier|*
name|func_name
parameter_list|)
block|{
specifier|const
name|char
name|func_str
index|[
literal|18
index|]
init|=
literal|"__ib_umem_release"
decl_stmt|;
comment|/* In case of error flow put_page is called as part of ib_umem_get */
specifier|const
name|char
name|func_str1
index|[
literal|12
index|]
init|=
literal|"ib_umem_get"
decl_stmt|;
return|return
operator|(
operator|(
name|strstr
argument_list|(
name|func_name
argument_list|,
name|func_str
argument_list|)
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|strstr
argument_list|(
name|func_name
argument_list|,
name|func_str1
argument_list|)
operator|!=
name|NULL
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|is_umem_put_page
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Check page order size    When Freeing a page allocation it checks whether    we are trying to free the same size    we asked to allocate                             */
end_comment

begin_function
name|int
name|memtrack_check_size
parameter_list|(
name|enum
name|memtrack_memtype_t
name|memtype
parameter_list|,
name|unsigned
name|long
name|addr
parameter_list|,
name|unsigned
name|long
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|unsigned
name|long
name|line_num
parameter_list|)
block|{
name|unsigned
name|long
name|hash_val
decl_stmt|;
name|struct
name|memtrack_meminfo_t
modifier|*
name|cur_mem_info_p
decl_stmt|;
name|struct
name|tracked_obj_desc_t
modifier|*
name|obj_desc_p
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|memtype
operator|>=
name|MEMTRACK_NUM_OF_MEMTYPES
condition|)
block|{
name|printk
argument_list|(
name|KERN_ERR
literal|"%s: Invalid memory type (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|memtype
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|tracked_objs_arr
index|[
name|memtype
index|]
condition|)
block|{
comment|/* object is not tracked */
return|return
literal|1
return|;
block|}
name|obj_desc_p
operator|=
name|tracked_objs_arr
index|[
name|memtype
index|]
expr_stmt|;
name|hash_val
operator|=
name|addr
operator|%
name|MEMTRACK_HASH_SZ
expr_stmt|;
name|memtrack_spin_lock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* find mem_info of given memory location */
name|cur_mem_info_p
operator|=
name|obj_desc_p
operator|->
name|mem_hash
index|[
name|hash_val
index|]
expr_stmt|;
while|while
condition|(
name|cur_mem_info_p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cur_mem_info_p
operator|->
name|addr
operator|==
name|addr
condition|)
block|{
comment|/* Found given address in the database - check size */
if|if
condition|(
name|cur_mem_info_p
operator|->
name|size
operator|!=
name|size
condition|)
block|{
name|printk
argument_list|(
name|KERN_ERR
literal|"mtl size inconsistency: %s: %s::%lu: try to %s at address=0x%lX with size %lu while was created with size %lu\n"
argument_list|,
name|__func__
argument_list|,
name|filename
argument_list|,
name|line_num
argument_list|,
name|memtype_free_str
argument_list|(
name|memtype
argument_list|)
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|cur_mem_info_p
operator|->
name|size
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|cur_mem_info_p
operator|->
name|ext_info
argument_list|,
sizeof|sizeof
argument_list|(
name|cur_mem_info_p
operator|->
name|ext_info
argument_list|)
argument_list|,
literal|"invalid free size %lu\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
name|memtrack_spin_unlock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|cur_mem_info_p
operator|=
name|cur_mem_info_p
operator|->
name|next
expr_stmt|;
block|}
comment|/* not found - This function will not give any indication                        but will only check the correct size\order                        For inconsistency the 'free' function will check that */
name|memtrack_spin_unlock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|memtrack_check_size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Search for a specific addr whether it exist in the    current data-base.    It will print an error msg if we get an unexpected result,    Return value: 0 - if addr exist, else 1 */
end_comment

begin_function
name|int
name|memtrack_is_new_addr
parameter_list|(
name|enum
name|memtrack_memtype_t
name|memtype
parameter_list|,
name|unsigned
name|long
name|addr
parameter_list|,
name|int
name|expect_exist
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|unsigned
name|long
name|line_num
parameter_list|)
block|{
name|unsigned
name|long
name|hash_val
decl_stmt|;
name|struct
name|memtrack_meminfo_t
modifier|*
name|cur_mem_info_p
decl_stmt|;
name|struct
name|tracked_obj_desc_t
modifier|*
name|obj_desc_p
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
if|if
condition|(
name|memtype
operator|>=
name|MEMTRACK_NUM_OF_MEMTYPES
condition|)
block|{
name|printk
argument_list|(
name|KERN_ERR
literal|"%s: Invalid memory type (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|memtype
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|tracked_objs_arr
index|[
name|memtype
index|]
condition|)
block|{
comment|/* object is not tracked */
return|return
literal|0
return|;
block|}
name|obj_desc_p
operator|=
name|tracked_objs_arr
index|[
name|memtype
index|]
expr_stmt|;
name|hash_val
operator|=
name|addr
operator|%
name|MEMTRACK_HASH_SZ
expr_stmt|;
name|memtrack_spin_lock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* find mem_info of given memory location */
name|cur_mem_info_p
operator|=
name|obj_desc_p
operator|->
name|mem_hash
index|[
name|hash_val
index|]
expr_stmt|;
while|while
condition|(
name|cur_mem_info_p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cur_mem_info_p
operator|->
name|addr
operator|==
name|addr
condition|)
block|{
comment|/* Found given address in the database - exiting */
name|memtrack_spin_unlock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|cur_mem_info_p
operator|=
name|cur_mem_info_p
operator|->
name|next
expr_stmt|;
block|}
comment|/* not found */
if|if
condition|(
name|expect_exist
condition|)
name|printk
argument_list|(
name|KERN_ERR
literal|"mtl rsc inconsistency: %s: %s::%lu: %s for unknown address=0x%lX\n"
argument_list|,
name|__func__
argument_list|,
name|filename
argument_list|,
name|line_num
argument_list|,
name|memtype_free_str
argument_list|(
name|memtype
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|memtrack_spin_unlock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|memtrack_is_new_addr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Return current page reference counter */
end_comment

begin_function
name|int
name|memtrack_get_page_ref_count
parameter_list|(
name|unsigned
name|long
name|addr
parameter_list|)
block|{
name|unsigned
name|long
name|hash_val
decl_stmt|;
name|struct
name|memtrack_meminfo_t
modifier|*
name|cur_mem_info_p
decl_stmt|;
name|struct
name|tracked_obj_desc_t
modifier|*
name|obj_desc_p
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
comment|/* This function is called only for page allocation */
name|enum
name|memtrack_memtype_t
name|memtype
init|=
name|MEMTRACK_PAGE_ALLOC
decl_stmt|;
name|int
name|ref_conut
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|tracked_objs_arr
index|[
name|memtype
index|]
condition|)
block|{
comment|/* object is not tracked */
return|return
name|ref_conut
return|;
block|}
name|obj_desc_p
operator|=
name|tracked_objs_arr
index|[
name|memtype
index|]
expr_stmt|;
name|hash_val
operator|=
name|addr
operator|%
name|MEMTRACK_HASH_SZ
expr_stmt|;
name|memtrack_spin_lock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* find mem_info of given memory location */
name|cur_mem_info_p
operator|=
name|obj_desc_p
operator|->
name|mem_hash
index|[
name|hash_val
index|]
expr_stmt|;
while|while
condition|(
name|cur_mem_info_p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cur_mem_info_p
operator|->
name|addr
operator|==
name|addr
condition|)
block|{
comment|/* Found given address in the database - check ref-count */
name|struct
name|page
modifier|*
name|page
init|=
operator|(
expr|struct
name|page
operator|*
operator|)
operator|(
name|cur_mem_info_p
operator|->
name|addr
operator|)
decl_stmt|;
name|ref_conut
operator|=
name|atomic_read
argument_list|(
operator|&
name|page
operator|->
name|_count
argument_list|)
expr_stmt|;
name|memtrack_spin_unlock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|ref_conut
return|;
block|}
name|cur_mem_info_p
operator|=
name|cur_mem_info_p
operator|->
name|next
expr_stmt|;
block|}
comment|/* not found */
name|memtrack_spin_unlock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|ref_conut
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|memtrack_get_page_ref_count
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Report current allocations status (for all memory types) */
end_comment

begin_function
specifier|static
name|void
name|memtrack_report
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|memtrack_memtype_t
name|memtype
decl_stmt|;
name|unsigned
name|long
name|cur_bucket
decl_stmt|;
name|struct
name|memtrack_meminfo_t
modifier|*
name|cur_mem_info_p
decl_stmt|;
name|int
name|serial
init|=
literal|1
decl_stmt|;
name|struct
name|tracked_obj_desc_t
modifier|*
name|obj_desc_p
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|unsigned
name|long
name|detected_leaks
init|=
literal|0
decl_stmt|;
name|printk
argument_list|(
name|KERN_INFO
literal|"%s: Currently known allocations:\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
for|for
control|(
name|memtype
operator|=
literal|0
init|;
name|memtype
operator|<
name|MEMTRACK_NUM_OF_MEMTYPES
condition|;
name|memtype
operator|++
control|)
block|{
if|if
condition|(
name|tracked_objs_arr
index|[
name|memtype
index|]
condition|)
block|{
name|printk
argument_list|(
name|KERN_INFO
literal|"%d) %s:\n"
argument_list|,
name|serial
argument_list|,
name|memtype_alloc_str
argument_list|(
name|memtype
argument_list|)
argument_list|)
expr_stmt|;
name|obj_desc_p
operator|=
name|tracked_objs_arr
index|[
name|memtype
index|]
expr_stmt|;
comment|/* Scan all buckets to find existing allocations */
comment|/* TBD: this may be optimized by holding a linked list of all hash items */
for|for
control|(
name|cur_bucket
operator|=
literal|0
init|;
name|cur_bucket
operator|<
name|MEMTRACK_HASH_SZ
condition|;
name|cur_bucket
operator|++
control|)
block|{
name|memtrack_spin_lock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* protect per bucket/list */
name|cur_mem_info_p
operator|=
name|obj_desc_p
operator|->
name|mem_hash
index|[
name|cur_bucket
index|]
expr_stmt|;
while|while
condition|(
name|cur_mem_info_p
operator|!=
name|NULL
condition|)
block|{
comment|/* scan bucket */
name|printk
argument_list|(
name|KERN_INFO
literal|"%s::%lu: %s(%lu)==%lX dev=%lX %s\n"
argument_list|,
name|cur_mem_info_p
operator|->
name|filename
argument_list|,
name|cur_mem_info_p
operator|->
name|line_num
argument_list|,
name|memtype_alloc_str
argument_list|(
name|memtype
argument_list|)
argument_list|,
name|cur_mem_info_p
operator|->
name|size
argument_list|,
name|cur_mem_info_p
operator|->
name|addr
argument_list|,
name|cur_mem_info_p
operator|->
name|dev
argument_list|,
name|cur_mem_info_p
operator|->
name|ext_info
argument_list|)
expr_stmt|;
name|cur_mem_info_p
operator|=
name|cur_mem_info_p
operator|->
name|next
expr_stmt|;
operator|++
name|detected_leaks
expr_stmt|;
block|}
comment|/* while cur_mem_info_p */
name|memtrack_spin_unlock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/* for cur_bucket */
name|serial
operator|++
expr_stmt|;
block|}
block|}
comment|/* for memtype */
name|printk
argument_list|(
name|KERN_INFO
literal|"%s: Summary: %lu leak(s) detected\n"
argument_list|,
name|__func__
argument_list|,
name|detected_leaks
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|proc_dir_entry
modifier|*
name|memtrack_tree
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|enum
name|memtrack_memtype_t
name|get_rsc_by_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|enum
name|memtrack_memtype_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MEMTRACK_NUM_OF_MEMTYPES
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|rsc_names
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
name|i
return|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|memtrack_read
parameter_list|(
name|struct
name|file
modifier|*
name|filp
parameter_list|,
name|char
name|__user
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|loff_t
modifier|*
name|offset
parameter_list|)
block|{
name|unsigned
name|long
name|cur
decl_stmt|,
name|flags
decl_stmt|;
name|loff_t
name|pos
init|=
operator|*
name|offset
decl_stmt|;
specifier|static
name|char
name|kbuf
index|[
literal|20
index|]
decl_stmt|;
specifier|static
name|int
name|file_len
decl_stmt|;
name|int
name|_read
decl_stmt|,
name|to_ret
decl_stmt|,
name|left
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|enum
name|memtrack_memtype_t
name|memtype
decl_stmt|;
if|if
condition|(
name|pos
operator|<
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
name|fname
operator|=
name|filp
operator|->
name|f_dentry
operator|->
name|d_name
operator|.
name|name
expr_stmt|;
name|memtype
operator|=
name|get_rsc_by_name
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|memtype
operator|>=
name|MEMTRACK_NUM_OF_MEMTYPES
condition|)
block|{
name|printk
argument_list|(
name|KERN_ERR
literal|"invalid file name\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
block|{
name|memtrack_spin_lock
argument_list|(
operator|&
name|tracked_objs_arr
index|[
name|memtype
index|]
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|cur
operator|=
name|tracked_objs_arr
index|[
name|memtype
index|]
operator|->
name|count
expr_stmt|;
name|memtrack_spin_unlock
argument_list|(
operator|&
name|tracked_objs_arr
index|[
name|memtype
index|]
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|_read
operator|=
name|sprintf
argument_list|(
name|kbuf
argument_list|,
literal|"%lu\n"
argument_list|,
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|_read
operator|<
literal|0
condition|)
return|return
name|_read
return|;
else|else
name|file_len
operator|=
name|_read
expr_stmt|;
block|}
name|left
operator|=
name|file_len
operator|-
name|pos
expr_stmt|;
name|to_ret
operator|=
operator|(
name|left
operator|<
name|size
operator|)
condition|?
name|left
else|:
name|size
expr_stmt|;
if|if
condition|(
name|copy_to_user
argument_list|(
name|buf
argument_list|,
name|kbuf
operator|+
name|pos
argument_list|,
name|to_ret
argument_list|)
condition|)
return|return
operator|-
name|EFAULT
return|;
else|else
block|{
operator|*
name|offset
operator|=
name|pos
operator|+
name|to_ret
expr_stmt|;
return|return
name|to_ret
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|file_operations
name|memtrack_proc_fops
init|=
block|{
operator|.
name|read
operator|=
name|memtrack_read
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|memtrack_proc_entry_name
init|=
literal|"mt_memtrack"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|create_procfs_tree
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|proc_dir_entry
modifier|*
name|dir_ent
decl_stmt|;
name|struct
name|proc_dir_entry
modifier|*
name|proc_ent
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|long
name|bit_mask
decl_stmt|;
name|dir_ent
operator|=
name|proc_mkdir
argument_list|(
name|memtrack_proc_entry_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dir_ent
condition|)
return|return
operator|-
literal|1
return|;
name|memtrack_tree
operator|=
name|dir_ent
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|bit_mask
operator|=
literal|1
init|;
name|i
operator|<
name|MEMTRACK_NUM_OF_MEMTYPES
condition|;
operator|++
name|i
operator|,
name|bit_mask
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|bit_mask
operator|&
name|track_mask
condition|)
block|{
name|proc_ent
operator|=
name|create_proc_entry
argument_list|(
name|rsc_names
index|[
name|i
index|]
argument_list|,
name|S_IRUGO
argument_list|,
name|memtrack_tree
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|proc_ent
condition|)
goto|goto
name|undo_create_root
goto|;
name|proc_ent
operator|->
name|proc_fops
operator|=
operator|&
name|memtrack_proc_fops
expr_stmt|;
block|}
block|}
goto|goto
name|exit_ok
goto|;
name|undo_create_root
label|:
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|bit_mask
operator|=
literal|1
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
operator|,
name|bit_mask
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|bit_mask
operator|&
name|track_mask
condition|)
name|remove_proc_entry
argument_list|(
name|rsc_names
index|[
name|j
index|]
argument_list|,
name|memtrack_tree
argument_list|)
expr_stmt|;
block|}
name|remove_proc_entry
argument_list|(
name|memtrack_proc_entry_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
name|exit_ok
label|:
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_procfs_tree
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|bit_mask
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|bit_mask
operator|=
literal|1
init|;
name|i
operator|<
name|MEMTRACK_NUM_OF_MEMTYPES
condition|;
operator|++
name|i
operator|,
name|bit_mask
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|bit_mask
operator|&
name|track_mask
condition|)
name|remove_proc_entry
argument_list|(
name|rsc_names
index|[
name|i
index|]
argument_list|,
name|memtrack_tree
argument_list|)
expr_stmt|;
block|}
name|remove_proc_entry
argument_list|(
name|memtrack_proc_entry_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|memtrack_inject_error
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|inject_freq
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|random32
argument_list|()
operator|%
name|inject_freq
operator|)
condition|)
name|val
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|memtrack_inject_error
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|memtrack_randomize_mem
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|random_mem
return|;
block|}
end_function

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|memtrack_randomize_mem
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* module entry points */
end_comment

begin_function
name|int
name|init_module
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|memtrack_memtype_t
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|unsigned
name|long
name|bit_mask
decl_stmt|;
comment|/* create a cache for the memtrack_meminfo_t strcutures */
name|meminfo_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"memtrack_meminfo_t"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|memtrack_meminfo_t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SLAB_HWCACHE_ALIGN
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|meminfo_cache
condition|)
block|{
name|printk
argument_list|(
name|KERN_ERR
literal|"memtrack::%s: failed to allocate meminfo cache\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* initialize array of descriptors */
name|memset
argument_list|(
name|tracked_objs_arr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tracked_objs_arr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create a tracking object descriptor for all required objects */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|bit_mask
operator|=
literal|1
init|;
name|i
operator|<
name|MEMTRACK_NUM_OF_MEMTYPES
condition|;
operator|++
name|i
operator|,
name|bit_mask
operator|<<=
literal|1
control|)
block|{
if|if
condition|(
name|bit_mask
operator|&
name|track_mask
condition|)
block|{
name|tracked_objs_arr
index|[
name|i
index|]
operator|=
name|vmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tracked_obj_desc_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tracked_objs_arr
index|[
name|i
index|]
condition|)
block|{
name|printk
argument_list|(
name|KERN_ERR
literal|"memtrack: failed to allocate tracking object\n"
argument_list|)
expr_stmt|;
goto|goto
name|undo_cache_create
goto|;
block|}
name|memset
argument_list|(
name|tracked_objs_arr
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tracked_obj_desc_t
argument_list|)
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|tracked_objs_arr
index|[
name|i
index|]
operator|->
name|hash_lock
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|tracked_objs_arr
index|[
name|i
index|]
operator|->
name|tracked_objs_head
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit_mask
operator|&
name|strict_track_mask
condition|)
name|tracked_objs_arr
index|[
name|i
index|]
operator|->
name|strict_track
operator|=
literal|1
expr_stmt|;
else|else
name|tracked_objs_arr
index|[
name|i
index|]
operator|->
name|strict_track
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|create_procfs_tree
argument_list|()
condition|)
block|{
name|printk
argument_list|(
name|KERN_ERR
literal|"%s: create_procfs_tree() failed\n"
argument_list|,
name|__FILE__
argument_list|)
expr_stmt|;
goto|goto
name|undo_cache_create
goto|;
block|}
name|printk
argument_list|(
name|KERN_INFO
literal|"memtrack::%s done.\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|undo_cache_create
label|:
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|tracked_objs_arr
index|[
name|j
index|]
condition|)
name|vfree
argument_list|(
name|tracked_objs_arr
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|LINUX_VERSION_CODE
operator|<
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|19
argument_list|)
if|if
condition|(
name|kmem_cache_destroy
argument_list|(
name|meminfo_cache
argument_list|)
operator|!=
literal|0
condition|)
name|printk
argument_list|(
name|KERN_ERR
literal|"Failed on kmem_cache_destroy!\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|kmem_cache_destroy
argument_list|(
name|meminfo_cache
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
name|cleanup_module
parameter_list|(
name|void
parameter_list|)
block|{
name|enum
name|memtrack_memtype_t
name|memtype
decl_stmt|;
name|unsigned
name|long
name|cur_bucket
decl_stmt|;
name|struct
name|memtrack_meminfo_t
modifier|*
name|cur_mem_info_p
decl_stmt|,
modifier|*
name|next_mem_info_p
decl_stmt|;
name|struct
name|tracked_obj_desc_t
modifier|*
name|obj_desc_p
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|memtrack_report
argument_list|()
expr_stmt|;
name|destroy_procfs_tree
argument_list|()
expr_stmt|;
comment|/* clean up any hash table left-overs */
for|for
control|(
name|memtype
operator|=
literal|0
init|;
name|memtype
operator|<
name|MEMTRACK_NUM_OF_MEMTYPES
condition|;
name|memtype
operator|++
control|)
block|{
comment|/* Scan all buckets to find existing allocations */
comment|/* TBD: this may be optimized by holding a linked list of all hash items */
if|if
condition|(
name|tracked_objs_arr
index|[
name|memtype
index|]
condition|)
block|{
name|obj_desc_p
operator|=
name|tracked_objs_arr
index|[
name|memtype
index|]
expr_stmt|;
for|for
control|(
name|cur_bucket
operator|=
literal|0
init|;
name|cur_bucket
operator|<
name|MEMTRACK_HASH_SZ
condition|;
name|cur_bucket
operator|++
control|)
block|{
name|memtrack_spin_lock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* protect per bucket/list */
name|cur_mem_info_p
operator|=
name|obj_desc_p
operator|->
name|mem_hash
index|[
name|cur_bucket
index|]
expr_stmt|;
while|while
condition|(
name|cur_mem_info_p
operator|!=
name|NULL
condition|)
block|{
comment|/* scan bucket */
name|next_mem_info_p
operator|=
name|cur_mem_info_p
operator|->
name|next
expr_stmt|;
comment|/* save "next" pointer before the "free" */
name|kmem_cache_free
argument_list|(
name|meminfo_cache
argument_list|,
name|cur_mem_info_p
argument_list|)
expr_stmt|;
name|cur_mem_info_p
operator|=
name|next_mem_info_p
expr_stmt|;
block|}
comment|/* while cur_mem_info_p */
name|memtrack_spin_unlock
argument_list|(
operator|&
name|obj_desc_p
operator|->
name|hash_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/* for cur_bucket */
name|vfree
argument_list|(
name|obj_desc_p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* for memtype */
if|#
directive|if
name|LINUX_VERSION_CODE
operator|<
name|KERNEL_VERSION
argument_list|(
literal|2
operator|,
literal|6
operator|,
literal|19
argument_list|)
if|if
condition|(
name|kmem_cache_destroy
argument_list|(
name|meminfo_cache
argument_list|)
operator|!=
literal|0
condition|)
name|printk
argument_list|(
name|KERN_ERR
literal|"memtrack::cleanup_module: Failed on kmem_cache_destroy!\n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|kmem_cache_destroy
argument_list|(
name|meminfo_cache
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|printk
argument_list|(
name|KERN_INFO
literal|"memtrack::cleanup_module done.\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

