begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2012 Mellanox Technologies. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_comment
comment|/***********************************************************/
end_comment

begin_comment
comment|/*This file support the handling of the Alias GUID feature. */
end_comment

begin_comment
comment|/***********************************************************/
end_comment

begin_include
include|#
directive|include
file|<rdma/ib_mad.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_smi.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_cache.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_sa.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_pack.h>
end_include

begin_include
include|#
directive|include
file|<linux/mlx4/cmd.h>
end_include

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/errno.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_user_verbs.h>
end_include

begin_include
include|#
directive|include
file|<linux/delay.h>
end_include

begin_include
include|#
directive|include
file|"mlx4_ib.h"
end_include

begin_comment
comment|/* The driver keeps the current state of all guids, as they are in the HW. Whenever we receive an smp mad GUIDInfo record, the data will be cached. */
end_comment

begin_struct
struct|struct
name|mlx4_alias_guid_work_context
block|{
name|u8
name|port
decl_stmt|;
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
decl_stmt|;
name|struct
name|ib_sa_query
modifier|*
name|sa_query
decl_stmt|;
name|struct
name|completion
name|done
decl_stmt|;
name|int
name|query_id
decl_stmt|;
name|struct
name|list_head
name|list
decl_stmt|;
name|int
name|block_num
decl_stmt|;
name|u8
name|method
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|mlx4_next_alias_guid_work
block|{
name|u8
name|port
decl_stmt|;
name|u8
name|block_num
decl_stmt|;
name|struct
name|mlx4_sriov_alias_guid_info_rec_det
name|rec_det
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|void
name|mlx4_ib_update_cache_on_guid_change
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|int
name|block_num
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|u8
modifier|*
name|p_data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u64
name|guid_indexes
decl_stmt|;
name|int
name|slave_id
decl_stmt|;
name|int
name|port_index
init|=
name|port_num
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_master
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
condition|)
return|return;
name|guid_indexes
operator|=
name|be64_to_cpu
argument_list|(
operator|(
name|__force
name|__be64
operator|)
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port_num
operator|-
literal|1
index|]
operator|.
name|all_rec_per_port
index|[
name|block_num
index|]
operator|.
name|guid_indexes
argument_list|)
expr_stmt|;
name|pr_debug
argument_list|(
literal|"port: %d, guid_indexes: 0x%llx\n"
argument_list|,
name|port_num
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|guid_indexes
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ALIAS_GUID_IN_REC
condition|;
name|i
operator|++
control|)
block|{
comment|/* The location of the specific index starts from bit number 4 		 * until bit num 11 */
if|if
condition|(
name|test_bit
argument_list|(
name|i
operator|+
literal|4
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|&
name|guid_indexes
argument_list|)
condition|)
block|{
name|slave_id
operator|=
operator|(
name|block_num
operator|*
name|NUM_ALIAS_GUID_IN_REC
operator|)
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|slave_id
operator|>=
name|dev
operator|->
name|dev
operator|->
name|num_slaves
condition|)
block|{
name|pr_debug
argument_list|(
literal|"The last slave: %d\n"
argument_list|,
name|slave_id
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* cache the guid: */
name|memcpy
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|demux
index|[
name|port_index
index|]
operator|.
name|guid_cache
index|[
name|slave_id
index|]
argument_list|,
operator|&
name|p_data
index|[
name|i
operator|*
name|GUID_REC_SIZE
index|]
argument_list|,
name|GUID_REC_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
name|pr_debug
argument_list|(
literal|"Guid number: %d in block: %d"
literal|" was not updated\n"
argument_list|,
name|i
argument_list|,
name|block_num
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__be64
name|get_cached_alias_guid
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|index
operator|>=
name|NUM_ALIAS_GUID_PER_PORT
condition|)
block|{
name|pr_err
argument_list|(
literal|"%s: ERROR: asked for index:%d\n"
argument_list|,
name|__func__
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
operator|(
name|__force
name|__be64
operator|)
operator|-
literal|1
return|;
block|}
return|return
operator|*
operator|(
name|__be64
operator|*
operator|)
operator|&
name|dev
operator|->
name|sriov
operator|.
name|demux
index|[
name|port
operator|-
literal|1
index|]
operator|.
name|guid_cache
index|[
name|index
index|]
return|;
block|}
end_function

begin_function
name|ib_sa_comp_mask
name|mlx4_ib_get_aguid_comp_mask_from_ix
parameter_list|(
name|int
name|index
parameter_list|)
block|{
return|return
name|IB_SA_COMP_MASK
argument_list|(
literal|4
operator|+
name|index
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Whenever new GUID is set/unset (guid table change) create event and  * notify the relevant slave (master also should be notified).  * If the GUID value is not as we have in the cache the slave will not be  * updated; in this case it waits for the smp_snoop or the port management  * event to call the function and to update the slave.  * block_number - the index of the block (16 blocks available)  * port_number - 1 or 2  */
end_comment

begin_function
name|void
name|mlx4_ib_notify_slaves_on_guid_change
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|int
name|block_num
parameter_list|,
name|u8
name|port_num
parameter_list|,
name|u8
modifier|*
name|p_data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u64
name|guid_indexes
decl_stmt|;
name|int
name|slave_id
decl_stmt|;
name|enum
name|slave_port_state
name|new_state
decl_stmt|;
name|enum
name|slave_port_state
name|prev_state
decl_stmt|;
name|__be64
name|tmp_cur_ag
decl_stmt|,
name|form_cache_ag
decl_stmt|;
name|enum
name|slave_port_gen_event
name|gen_event
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_master
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
condition|)
return|return;
name|guid_indexes
operator|=
name|be64_to_cpu
argument_list|(
operator|(
name|__force
name|__be64
operator|)
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port_num
operator|-
literal|1
index|]
operator|.
name|all_rec_per_port
index|[
name|block_num
index|]
operator|.
name|guid_indexes
argument_list|)
expr_stmt|;
name|pr_debug
argument_list|(
literal|"port: %d, guid_indexes: 0x%llx\n"
argument_list|,
name|port_num
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|guid_indexes
argument_list|)
expr_stmt|;
comment|/*calculate the slaves and notify them*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ALIAS_GUID_IN_REC
condition|;
name|i
operator|++
control|)
block|{
comment|/* the location of the specific index runs from bits 4..11 */
if|if
condition|(
operator|!
operator|(
name|test_bit
argument_list|(
name|i
operator|+
literal|4
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|&
name|guid_indexes
argument_list|)
operator|)
condition|)
continue|continue;
name|slave_id
operator|=
operator|(
name|block_num
operator|*
name|NUM_ALIAS_GUID_IN_REC
operator|)
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|slave_id
operator|>=
name|dev
operator|->
name|dev
operator|->
name|num_slaves
condition|)
return|return;
name|tmp_cur_ag
operator|=
operator|*
operator|(
name|__be64
operator|*
operator|)
operator|&
name|p_data
index|[
name|i
operator|*
name|GUID_REC_SIZE
index|]
expr_stmt|;
name|form_cache_ag
operator|=
name|get_cached_alias_guid
argument_list|(
name|dev
argument_list|,
name|port_num
argument_list|,
operator|(
name|NUM_ALIAS_GUID_IN_REC
operator|*
name|block_num
operator|)
operator|+
name|i
argument_list|)
expr_stmt|;
comment|/* 		 * Check if guid is not the same as in the cache, 		 * If it is different, wait for the snoop_smp or the port mgmt 		 * change event to update the slave on its port state change 		 */
if|if
condition|(
name|tmp_cur_ag
operator|!=
name|form_cache_ag
condition|)
continue|continue;
name|mlx4_gen_guid_change_eqe
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|slave_id
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
comment|/*2 cases: Valid GUID, and Invalid Guid*/
if|if
condition|(
name|tmp_cur_ag
operator|!=
name|MLX4_NOT_SET_GUID
condition|)
block|{
comment|/*valid GUID*/
name|prev_state
operator|=
name|mlx4_get_slave_port_state
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|slave_id
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|new_state
operator|=
name|set_and_calc_slave_port_state
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|slave_id
argument_list|,
name|port_num
argument_list|,
name|MLX4_PORT_STATE_IB_PORT_STATE_EVENT_GID_VALID
argument_list|,
operator|&
name|gen_event
argument_list|)
expr_stmt|;
name|pr_debug
argument_list|(
literal|"slave: %d, port: %d prev_port_state: %d,"
literal|" new_port_state: %d, gen_event: %d\n"
argument_list|,
name|slave_id
argument_list|,
name|port_num
argument_list|,
name|prev_state
argument_list|,
name|new_state
argument_list|,
name|gen_event
argument_list|)
expr_stmt|;
if|if
condition|(
name|gen_event
operator|==
name|SLAVE_PORT_GEN_EVENT_UP
condition|)
block|{
name|pr_debug
argument_list|(
literal|"sending PORT_UP event to slave: %d, port: %d\n"
argument_list|,
name|slave_id
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|mlx4_gen_port_state_change_eqe
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|slave_id
argument_list|,
name|port_num
argument_list|,
name|MLX4_PORT_CHANGE_SUBTYPE_ACTIVE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* request to invalidate GUID */
name|set_and_calc_slave_port_state
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|slave_id
argument_list|,
name|port_num
argument_list|,
name|MLX4_PORT_STATE_IB_EVENT_GID_INVALID
argument_list|,
operator|&
name|gen_event
argument_list|)
expr_stmt|;
name|pr_debug
argument_list|(
literal|"sending PORT DOWN event to slave: %d, port: %d\n"
argument_list|,
name|slave_id
argument_list|,
name|port_num
argument_list|)
expr_stmt|;
name|mlx4_gen_port_state_change_eqe
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|slave_id
argument_list|,
name|port_num
argument_list|,
name|MLX4_PORT_CHANGE_SUBTYPE_DOWN
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|aliasguid_query_handler
parameter_list|(
name|int
name|status
parameter_list|,
name|struct
name|ib_sa_guidinfo_rec
modifier|*
name|guid_rec
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
decl_stmt|;
name|struct
name|mlx4_alias_guid_work_context
modifier|*
name|cb_ctx
init|=
name|context
decl_stmt|;
name|u8
name|port_index
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|mlx4_sriov_alias_guid_info_rec_det
modifier|*
name|rec
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|,
name|flags1
decl_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
return|return;
name|dev
operator|=
name|cb_ctx
operator|->
name|dev
expr_stmt|;
name|port_index
operator|=
name|cb_ctx
operator|->
name|port
operator|-
literal|1
expr_stmt|;
name|rec
operator|=
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port_index
index|]
operator|.
name|all_rec_per_port
index|[
name|cb_ctx
operator|->
name|block_num
index|]
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|rec
operator|->
name|status
operator|=
name|MLX4_GUID_INFO_STATUS_IDLE
expr_stmt|;
name|pr_debug
argument_list|(
literal|"(port: %d) failed: status = %d\n"
argument_list|,
name|cb_ctx
operator|->
name|port
argument_list|,
name|status
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|guid_rec
operator|->
name|block_num
operator|!=
name|cb_ctx
operator|->
name|block_num
condition|)
block|{
name|pr_err
argument_list|(
literal|"block num mismatch: %d != %d\n"
argument_list|,
name|cb_ctx
operator|->
name|block_num
argument_list|,
name|guid_rec
operator|->
name|block_num
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|pr_debug
argument_list|(
literal|"lid/port: %d/%d, block_num: %d\n"
argument_list|,
name|be16_to_cpu
argument_list|(
name|guid_rec
operator|->
name|lid
argument_list|)
argument_list|,
name|cb_ctx
operator|->
name|port
argument_list|,
name|guid_rec
operator|->
name|block_num
argument_list|)
expr_stmt|;
name|rec
operator|=
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port_index
index|]
operator|.
name|all_rec_per_port
index|[
name|guid_rec
operator|->
name|block_num
index|]
expr_stmt|;
name|rec
operator|->
name|status
operator|=
name|MLX4_GUID_INFO_STATUS_SET
expr_stmt|;
name|rec
operator|->
name|method
operator|=
name|MLX4_GUID_INFO_RECORD_SET
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ALIAS_GUID_IN_REC
condition|;
name|i
operator|++
control|)
block|{
name|__be64
name|tmp_cur_ag
decl_stmt|;
name|tmp_cur_ag
operator|=
operator|*
operator|(
name|__be64
operator|*
operator|)
operator|&
name|guid_rec
operator|->
name|guid_info_list
index|[
name|i
operator|*
name|GUID_REC_SIZE
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|cb_ctx
operator|->
name|method
operator|==
name|MLX4_GUID_INFO_RECORD_DELETE
operator|)
operator|&&
operator|(
name|MLX4_NOT_SET_GUID
operator|==
name|tmp_cur_ag
operator|)
condition|)
block|{
name|pr_debug
argument_list|(
literal|"%s:Record num %d in block_num:%d "
literal|"was deleted by SM,ownership by %d "
literal|"(0 = driver, 1=sysAdmin, 2=None)\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|guid_rec
operator|->
name|block_num
argument_list|,
name|rec
operator|->
name|ownership
argument_list|)
expr_stmt|;
name|rec
operator|->
name|guid_indexes
operator|=
name|rec
operator|->
name|guid_indexes
operator|&
operator|~
name|mlx4_ib_get_aguid_comp_mask_from_ix
argument_list|(
name|i
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* check if the SM didn't assign one of the records. 		 * if it didn't, if it was not sysadmin request: 		 * ask the SM to give a new GUID, (instead of the driver request). 		 */
if|if
condition|(
name|tmp_cur_ag
operator|==
name|MLX4_NOT_SET_GUID
condition|)
block|{
name|mlx4_ib_warn
argument_list|(
operator|&
name|dev
operator|->
name|ib_dev
argument_list|,
literal|"%s:Record num %d in "
literal|"block_num: %d was declined by SM, "
literal|"ownership by %d (0 = driver, 1=sysAdmin,"
literal|" 2=None)\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|guid_rec
operator|->
name|block_num
argument_list|,
name|rec
operator|->
name|ownership
argument_list|)
expr_stmt|;
if|if
condition|(
name|rec
operator|->
name|ownership
operator|==
name|MLX4_GUID_DRIVER_ASSIGN
condition|)
block|{
comment|/* if it is driver assign, asks for new GUID from SM*/
operator|*
operator|(
name|__be64
operator|*
operator|)
operator|&
name|rec
operator|->
name|all_recs
index|[
name|i
operator|*
name|GUID_REC_SIZE
index|]
operator|=
name|MLX4_NOT_SET_GUID
expr_stmt|;
comment|/* Mark the record as not assigned, and let it 				 * be sent again in the next work sched.*/
name|rec
operator|->
name|status
operator|=
name|MLX4_GUID_INFO_STATUS_IDLE
expr_stmt|;
name|rec
operator|->
name|guid_indexes
operator||=
name|mlx4_ib_get_aguid_comp_mask_from_ix
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* properly assigned record. */
comment|/* We save the GUID we just got from the SM in the 			* admin_guid in order to be persistent, and in the 			* request from the sm the process will ask for the same GUID */
if|if
condition|(
name|rec
operator|->
name|ownership
operator|==
name|MLX4_GUID_SYSADMIN_ASSIGN
operator|&&
name|tmp_cur_ag
operator|!=
operator|*
operator|(
name|__be64
operator|*
operator|)
operator|&
name|rec
operator|->
name|all_recs
index|[
name|i
operator|*
name|GUID_REC_SIZE
index|]
condition|)
block|{
comment|/* the sysadmin assignment failed.*/
name|mlx4_ib_warn
argument_list|(
operator|&
name|dev
operator|->
name|ib_dev
argument_list|,
literal|"%s: Failed to set"
literal|" admin guid after SysAdmin "
literal|"configuration. "
literal|"Record num %d in block_num:%d "
literal|"was declined by SM, "
literal|"new val(0x%llx) was kept\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|,
name|guid_rec
operator|->
name|block_num
argument_list|,
operator|(
name|long
name|long
operator|)
name|be64_to_cpu
argument_list|(
operator|*
operator|(
name|__be64
operator|*
operator|)
operator|&
name|rec
operator|->
name|all_recs
index|[
name|i
operator|*
name|GUID_REC_SIZE
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|rec
operator|->
name|all_recs
index|[
name|i
operator|*
name|GUID_REC_SIZE
index|]
argument_list|,
operator|&
name|guid_rec
operator|->
name|guid_info_list
index|[
name|i
operator|*
name|GUID_REC_SIZE
index|]
argument_list|,
name|GUID_REC_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	The func is call here to close the cases when the 	sm doesn't send smp, so in the sa response the driver 	notifies the slave. 	*/
name|mlx4_ib_notify_slaves_on_guid_change
argument_list|(
name|dev
argument_list|,
name|guid_rec
operator|->
name|block_num
argument_list|,
name|cb_ctx
operator|->
name|port
argument_list|,
name|guid_rec
operator|->
name|guid_info_list
argument_list|)
expr_stmt|;
name|out
label|:
name|spin_lock_irqsave
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|going_down_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ag_work_lock
argument_list|,
name|flags1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|sriov
operator|.
name|is_going_down
condition|)
name|queue_delayed_work
argument_list|(
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port_index
index|]
operator|.
name|wq
argument_list|,
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port_index
index|]
operator|.
name|alias_guid_work
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb_ctx
operator|->
name|sa_query
condition|)
block|{
name|list_del
argument_list|(
operator|&
name|cb_ctx
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|cb_ctx
argument_list|)
expr_stmt|;
block|}
else|else
name|complete
argument_list|(
operator|&
name|cb_ctx
operator|->
name|done
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ag_work_lock
argument_list|,
name|flags1
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|going_down_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|invalidate_guid_record
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u64
name|cur_admin_val
decl_stmt|;
name|ib_sa_comp_mask
name|comp_mask
init|=
literal|0
decl_stmt|;
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port
operator|-
literal|1
index|]
operator|.
name|all_rec_per_port
index|[
name|index
index|]
operator|.
name|status
operator|=
name|MLX4_GUID_INFO_STATUS_IDLE
expr_stmt|;
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port
operator|-
literal|1
index|]
operator|.
name|all_rec_per_port
index|[
name|index
index|]
operator|.
name|method
operator|=
name|MLX4_GUID_INFO_RECORD_SET
expr_stmt|;
comment|/* calculate the comp_mask for that record.*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ALIAS_GUID_IN_REC
condition|;
name|i
operator|++
control|)
block|{
name|cur_admin_val
operator|=
operator|*
operator|(
name|u64
operator|*
operator|)
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port
operator|-
literal|1
index|]
operator|.
name|all_rec_per_port
index|[
name|index
index|]
operator|.
name|all_recs
index|[
name|GUID_REC_SIZE
operator|*
name|i
index|]
expr_stmt|;
comment|/* 		check the admin value: if it's for delete (~00LL) or 		it is the first guid of the first record (hw guid) or 		the records is not in ownership of the sysadmin and the sm doesn't 		need to assign GUIDs, then don't put it up for assignment. 		*/
if|if
condition|(
name|MLX4_GUID_FOR_DELETE_VAL
operator|==
name|cur_admin_val
operator|||
operator|(
operator|!
name|index
operator|&&
operator|!
name|i
operator|)
operator|||
name|MLX4_GUID_NONE_ASSIGN
operator|==
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port
operator|-
literal|1
index|]
operator|.
name|all_rec_per_port
index|[
name|index
index|]
operator|.
name|ownership
condition|)
continue|continue;
name|comp_mask
operator||=
name|mlx4_ib_get_aguid_comp_mask_from_ix
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port
operator|-
literal|1
index|]
operator|.
name|all_rec_per_port
index|[
name|index
index|]
operator|.
name|guid_indexes
operator|=
name|comp_mask
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_guid_rec
parameter_list|(
name|struct
name|ib_device
modifier|*
name|ibdev
parameter_list|,
name|u8
name|port
parameter_list|,
name|int
name|index
parameter_list|,
name|struct
name|mlx4_sriov_alias_guid_info_rec_det
modifier|*
name|rec_det
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
decl_stmt|;
name|struct
name|ib_sa_guidinfo_rec
name|guid_info_rec
decl_stmt|;
name|ib_sa_comp_mask
name|comp_mask
decl_stmt|;
name|struct
name|ib_port_attr
name|attr
decl_stmt|;
name|struct
name|mlx4_alias_guid_work_context
modifier|*
name|callback_context
decl_stmt|;
name|unsigned
name|long
name|resched_delay
decl_stmt|,
name|flags
decl_stmt|,
name|flags1
decl_stmt|;
name|struct
name|list_head
modifier|*
name|head
init|=
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port
operator|-
literal|1
index|]
operator|.
name|cb_list
decl_stmt|;
name|err
operator|=
name|__mlx4_ib_query_port
argument_list|(
name|ibdev
argument_list|,
name|port
argument_list|,
operator|&
name|attr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|pr_debug
argument_list|(
literal|"mlx4_ib_query_port failed (err: %d), port: %d\n"
argument_list|,
name|err
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/*check the port was configured by the sm, otherwise no need to send */
if|if
condition|(
name|attr
operator|.
name|state
operator|!=
name|IB_PORT_ACTIVE
condition|)
block|{
name|pr_debug
argument_list|(
literal|"port %d not active...rescheduling\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|resched_delay
operator|=
literal|5
operator|*
name|HZ
expr_stmt|;
name|err
operator|=
operator|-
name|EAGAIN
expr_stmt|;
goto|goto
name|new_schedule
goto|;
block|}
name|callback_context
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|callback_context
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|callback_context
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
name|resched_delay
operator|=
name|HZ
operator|*
literal|5
expr_stmt|;
goto|goto
name|new_schedule
goto|;
block|}
name|callback_context
operator|->
name|port
operator|=
name|port
expr_stmt|;
name|callback_context
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|callback_context
operator|->
name|block_num
operator|=
name|index
expr_stmt|;
name|callback_context
operator|->
name|method
operator|=
name|rec_det
operator|->
name|method
expr_stmt|;
name|memset
argument_list|(
operator|&
name|guid_info_rec
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ib_sa_guidinfo_rec
argument_list|)
argument_list|)
expr_stmt|;
name|guid_info_rec
operator|.
name|lid
operator|=
name|cpu_to_be16
argument_list|(
name|attr
operator|.
name|lid
argument_list|)
expr_stmt|;
name|guid_info_rec
operator|.
name|block_num
operator|=
name|index
expr_stmt|;
name|memcpy
argument_list|(
name|guid_info_rec
operator|.
name|guid_info_list
argument_list|,
name|rec_det
operator|->
name|all_recs
argument_list|,
name|GUID_REC_SIZE
operator|*
name|NUM_ALIAS_GUID_IN_REC
argument_list|)
expr_stmt|;
name|comp_mask
operator|=
name|IB_SA_GUIDINFO_REC_LID
operator||
name|IB_SA_GUIDINFO_REC_BLOCK_NUM
operator||
name|rec_det
operator|->
name|guid_indexes
expr_stmt|;
name|init_completion
argument_list|(
operator|&
name|callback_context
operator|->
name|done
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ag_work_lock
argument_list|,
name|flags1
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|callback_context
operator|->
name|list
argument_list|,
name|head
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ag_work_lock
argument_list|,
name|flags1
argument_list|)
expr_stmt|;
name|callback_context
operator|->
name|query_id
operator|=
name|ib_sa_guid_info_rec_query
argument_list|(
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|sa_client
argument_list|,
name|ibdev
argument_list|,
name|port
argument_list|,
operator|&
name|guid_info_rec
argument_list|,
name|comp_mask
argument_list|,
name|rec_det
operator|->
name|method
argument_list|,
literal|1000
argument_list|,
name|GFP_KERNEL
argument_list|,
name|aliasguid_query_handler
argument_list|,
name|callback_context
argument_list|,
operator|&
name|callback_context
operator|->
name|sa_query
argument_list|)
expr_stmt|;
if|if
condition|(
name|callback_context
operator|->
name|query_id
operator|<
literal|0
condition|)
block|{
name|pr_debug
argument_list|(
literal|"ib_sa_guid_info_rec_query failed, query_id: "
literal|"%d. will reschedule to the next 1 sec.\n"
argument_list|,
name|callback_context
operator|->
name|query_id
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ag_work_lock
argument_list|,
name|flags1
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|callback_context
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|callback_context
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ag_work_lock
argument_list|,
name|flags1
argument_list|)
expr_stmt|;
name|resched_delay
operator|=
literal|1
operator|*
name|HZ
expr_stmt|;
name|err
operator|=
operator|-
name|EAGAIN
expr_stmt|;
goto|goto
name|new_schedule
goto|;
block|}
name|err
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
name|new_schedule
label|:
name|spin_lock_irqsave
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|going_down_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ag_work_lock
argument_list|,
name|flags1
argument_list|)
expr_stmt|;
name|invalidate_guid_record
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|sriov
operator|.
name|is_going_down
condition|)
block|{
name|queue_delayed_work
argument_list|(
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port
operator|-
literal|1
index|]
operator|.
name|wq
argument_list|,
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port
operator|-
literal|1
index|]
operator|.
name|alias_guid_work
argument_list|,
name|resched_delay
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ag_work_lock
argument_list|,
name|flags1
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|going_down_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|err
return|;
block|}
end_function

begin_function
name|void
name|mlx4_ib_invalidate_all_guid_record
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|,
name|flags1
decl_stmt|;
name|pr_debug
argument_list|(
literal|"port %d\n"
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|going_down_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ag_work_lock
argument_list|,
name|flags1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_ALIAS_GUID_REC_IN_PORT
condition|;
name|i
operator|++
control|)
name|invalidate_guid_record
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
operator|&&
operator|!
name|dev
operator|->
name|sriov
operator|.
name|is_going_down
condition|)
block|{
comment|/* 		make sure no work waits in the queue, if the work is already 		queued(not on the timer) the cancel will fail. That is not a problem 		because we just want the work started. 		*/
name|cancel_delayed_work
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port
operator|-
literal|1
index|]
operator|.
name|alias_guid_work
argument_list|)
expr_stmt|;
name|queue_delayed_work
argument_list|(
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port
operator|-
literal|1
index|]
operator|.
name|wq
argument_list|,
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port
operator|-
literal|1
index|]
operator|.
name|alias_guid_work
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ag_work_lock
argument_list|,
name|flags1
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|going_down_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* The function returns the next record that was  * not configured (or failed to be configured) */
end_comment

begin_function
specifier|static
name|int
name|get_next_record_to_update
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|u8
name|port
parameter_list|,
name|struct
name|mlx4_next_alias_guid_work
modifier|*
name|rec
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_ALIAS_GUID_REC_IN_PORT
condition|;
name|j
operator|++
control|)
block|{
name|spin_lock_irqsave
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ag_work_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port
index|]
operator|.
name|all_rec_per_port
index|[
name|j
index|]
operator|.
name|status
operator|==
name|MLX4_GUID_INFO_STATUS_IDLE
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|rec
operator|->
name|rec_det
argument_list|,
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port
index|]
operator|.
name|all_rec_per_port
index|[
name|j
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_sriov_alias_guid_info_rec_det
argument_list|)
argument_list|)
expr_stmt|;
name|rec
operator|->
name|port
operator|=
name|port
expr_stmt|;
name|rec
operator|->
name|block_num
operator|=
name|j
expr_stmt|;
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port
index|]
operator|.
name|all_rec_per_port
index|[
name|j
index|]
operator|.
name|status
operator|=
name|MLX4_GUID_INFO_STATUS_PENDING
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ag_work_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ag_work_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
return|return
operator|-
name|ENOENT
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_administratively_guid_record
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|,
name|int
name|rec_index
parameter_list|,
name|struct
name|mlx4_sriov_alias_guid_info_rec_det
modifier|*
name|rec_det
parameter_list|)
block|{
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port
index|]
operator|.
name|all_rec_per_port
index|[
name|rec_index
index|]
operator|.
name|guid_indexes
operator|=
name|rec_det
operator|->
name|guid_indexes
expr_stmt|;
name|memcpy
argument_list|(
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port
index|]
operator|.
name|all_rec_per_port
index|[
name|rec_index
index|]
operator|.
name|all_recs
argument_list|,
name|rec_det
operator|->
name|all_recs
argument_list|,
name|NUM_ALIAS_GUID_IN_REC
operator|*
name|GUID_REC_SIZE
argument_list|)
expr_stmt|;
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port
index|]
operator|.
name|all_rec_per_port
index|[
name|rec_index
index|]
operator|.
name|status
operator|=
name|rec_det
operator|->
name|status
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_all_slaves_guids
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|struct
name|mlx4_sriov_alias_guid_info_rec_det
name|rec_det
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_ALIAS_GUID_REC_IN_PORT
condition|;
name|j
operator|++
control|)
block|{
name|memset
argument_list|(
name|rec_det
operator|.
name|all_recs
argument_list|,
literal|0
argument_list|,
name|NUM_ALIAS_GUID_IN_REC
operator|*
name|GUID_REC_SIZE
argument_list|)
expr_stmt|;
name|rec_det
operator|.
name|guid_indexes
operator|=
operator|(
operator|!
name|j
condition|?
literal|0
else|:
name|IB_SA_GUIDINFO_REC_GID0
operator|)
operator||
name|IB_SA_GUIDINFO_REC_GID1
operator||
name|IB_SA_GUIDINFO_REC_GID2
operator||
name|IB_SA_GUIDINFO_REC_GID3
operator||
name|IB_SA_GUIDINFO_REC_GID4
operator||
name|IB_SA_GUIDINFO_REC_GID5
operator||
name|IB_SA_GUIDINFO_REC_GID6
operator||
name|IB_SA_GUIDINFO_REC_GID7
expr_stmt|;
name|rec_det
operator|.
name|status
operator|=
name|MLX4_GUID_INFO_STATUS_IDLE
expr_stmt|;
name|set_administratively_guid_record
argument_list|(
name|dev
argument_list|,
name|port
argument_list|,
name|j
argument_list|,
operator|&
name|rec_det
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|alias_guid_work
parameter_list|(
name|struct
name|work_struct
modifier|*
name|work
parameter_list|)
block|{
name|struct
name|delayed_work
modifier|*
name|delay
init|=
name|to_delayed_work
argument_list|(
name|work
argument_list|)
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|mlx4_next_alias_guid_work
modifier|*
name|rec
decl_stmt|;
name|struct
name|mlx4_sriov_alias_guid_port_rec_det
modifier|*
name|sriov_alias_port
init|=
name|container_of
argument_list|(
name|delay
argument_list|,
expr|struct
name|mlx4_sriov_alias_guid_port_rec_det
argument_list|,
name|alias_guid_work
argument_list|)
decl_stmt|;
name|struct
name|mlx4_sriov_alias_guid
modifier|*
name|sriov_alias_guid
init|=
name|sriov_alias_port
operator|->
name|parent
decl_stmt|;
name|struct
name|mlx4_ib_sriov
modifier|*
name|ib_sriov
init|=
name|container_of
argument_list|(
name|sriov_alias_guid
argument_list|,
expr|struct
name|mlx4_ib_sriov
argument_list|,
name|alias_guid
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|container_of
argument_list|(
name|ib_sriov
argument_list|,
expr|struct
name|mlx4_ib_dev
argument_list|,
name|sriov
argument_list|)
decl_stmt|;
name|rec
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|rec
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rec
condition|)
block|{
name|pr_err
argument_list|(
literal|"alias_guid_work: No Memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|pr_debug
argument_list|(
literal|"starting [port: %d]...\n"
argument_list|,
name|sriov_alias_port
operator|->
name|port
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|get_next_record_to_update
argument_list|(
name|dev
argument_list|,
name|sriov_alias_port
operator|->
name|port
argument_list|,
name|rec
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|pr_debug
argument_list|(
literal|"No more records to update.\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|set_guid_rec
argument_list|(
operator|&
name|dev
operator|->
name|ib_dev
argument_list|,
name|rec
operator|->
name|port
operator|+
literal|1
argument_list|,
name|rec
operator|->
name|block_num
argument_list|,
operator|&
name|rec
operator|->
name|rec_det
argument_list|)
expr_stmt|;
name|out
label|:
name|kfree
argument_list|(
name|rec
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mlx4_ib_init_alias_guid_work
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|unsigned
name|long
name|flags
decl_stmt|,
name|flags1
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_master
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
condition|)
return|return;
name|spin_lock_irqsave
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|going_down_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ag_work_lock
argument_list|,
name|flags1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|sriov
operator|.
name|is_going_down
condition|)
block|{
name|queue_delayed_work
argument_list|(
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port
index|]
operator|.
name|wq
argument_list|,
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|port
index|]
operator|.
name|alias_guid_work
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ag_work_lock
argument_list|,
name|flags1
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|going_down_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mlx4_ib_destroy_alias_guid_service
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|mlx4_ib_sriov
modifier|*
name|sriov
init|=
operator|&
name|dev
operator|->
name|sriov
decl_stmt|;
name|struct
name|mlx4_alias_guid_work_context
modifier|*
name|cb_ctx
decl_stmt|;
name|struct
name|mlx4_sriov_alias_guid_port_rec_det
modifier|*
name|det
decl_stmt|;
name|struct
name|ib_sa_query
modifier|*
name|sa_query
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|cancel_delayed_work
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|i
index|]
operator|.
name|alias_guid_work
argument_list|)
expr_stmt|;
name|det
operator|=
operator|&
name|sriov
operator|->
name|alias_guid
operator|.
name|ports_guid
index|[
name|i
index|]
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|sriov
operator|->
name|alias_guid
operator|.
name|ag_work_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|list_empty
argument_list|(
operator|&
name|det
operator|->
name|cb_list
argument_list|)
condition|)
block|{
name|cb_ctx
operator|=
name|list_entry
argument_list|(
name|det
operator|->
name|cb_list
operator|.
name|next
argument_list|,
expr|struct
name|mlx4_alias_guid_work_context
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|sa_query
operator|=
name|cb_ctx
operator|->
name|sa_query
expr_stmt|;
name|cb_ctx
operator|->
name|sa_query
operator|=
name|NULL
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|cb_ctx
operator|->
name|list
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|sriov
operator|->
name|alias_guid
operator|.
name|ag_work_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ib_sa_cancel_query
argument_list|(
name|cb_ctx
operator|->
name|query_id
argument_list|,
name|sa_query
argument_list|)
expr_stmt|;
name|wait_for_completion
argument_list|(
operator|&
name|cb_ctx
operator|->
name|done
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|cb_ctx
argument_list|)
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|sriov
operator|->
name|alias_guid
operator|.
name|ag_work_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|sriov
operator|->
name|alias_guid
operator|.
name|ag_work_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|flush_workqueue
argument_list|(
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|i
index|]
operator|.
name|wq
argument_list|)
expr_stmt|;
name|destroy_workqueue
argument_list|(
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|i
index|]
operator|.
name|wq
argument_list|)
expr_stmt|;
block|}
name|ib_sa_unregister_client
argument_list|(
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|sa_client
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|sa_client
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mlx4_ib_init_alias_guid_service
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|)
block|{
name|char
name|alias_wq_name
index|[
literal|15
index|]
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|union
name|ib_gid
name|gid
decl_stmt|;
if|if
condition|(
operator|!
name|mlx4_is_master
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
condition|)
return|return
literal|0
return|;
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|sa_client
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|sa_client
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|sa_client
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|ib_sa_register_client
argument_list|(
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|sa_client
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ag_work_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|dev
operator|->
name|num_ports
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|dev
operator|->
name|ib_dev
operator|.
name|query_gid
argument_list|(
operator|&
name|dev
operator|->
name|ib_dev
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
operator|&
name|gid
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|err_unregister
goto|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
name|memset
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_sriov_alias_guid_port_rec_det
argument_list|)
argument_list|)
expr_stmt|;
comment|/*Check if the SM doesn't need to assign the GUIDs*/
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_ALIAS_GUID_REC_IN_PORT
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|mlx4_ib_sm_guid_assign
condition|)
block|{
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|i
index|]
operator|.
name|all_rec_per_port
index|[
name|j
index|]
operator|.
name|ownership
operator|=
name|MLX4_GUID_DRIVER_ASSIGN
expr_stmt|;
continue|continue;
block|}
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|i
index|]
operator|.
name|all_rec_per_port
index|[
name|j
index|]
operator|.
name|ownership
operator|=
name|MLX4_GUID_NONE_ASSIGN
expr_stmt|;
comment|/*mark each val as it was deleted, 			  till the sysAdmin will give it valid val*/
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NUM_ALIAS_GUID_IN_REC
condition|;
name|k
operator|++
control|)
block|{
operator|*
operator|(
name|__be64
operator|*
operator|)
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|i
index|]
operator|.
name|all_rec_per_port
index|[
name|j
index|]
operator|.
name|all_recs
index|[
name|GUID_REC_SIZE
operator|*
name|k
index|]
operator|=
name|cpu_to_be64
argument_list|(
name|MLX4_GUID_FOR_DELETE_VAL
argument_list|)
expr_stmt|;
block|}
block|}
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|i
index|]
operator|.
name|cb_list
argument_list|)
expr_stmt|;
comment|/*prepare the records, set them to be allocated by sm*/
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|NUM_ALIAS_GUID_REC_IN_PORT
condition|;
name|j
operator|++
control|)
name|invalidate_guid_record
argument_list|(
name|dev
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|i
index|]
operator|.
name|parent
operator|=
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
expr_stmt|;
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|i
index|]
operator|.
name|port
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|mlx4_ib_sm_guid_assign
condition|)
name|set_all_slaves_guids
argument_list|(
name|dev
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|alias_wq_name
argument_list|,
sizeof|sizeof
name|alias_wq_name
argument_list|,
literal|"alias_guid%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|i
index|]
operator|.
name|wq
operator|=
name|create_singlethread_workqueue
argument_list|(
name|alias_wq_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|i
index|]
operator|.
name|wq
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_thread
goto|;
block|}
name|INIT_DELAYED_WORK
argument_list|(
operator|&
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|i
index|]
operator|.
name|alias_guid_work
argument_list|,
name|alias_guid_work
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|err_thread
label|:
for|for
control|(
operator|--
name|i
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|destroy_workqueue
argument_list|(
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|i
index|]
operator|.
name|wq
argument_list|)
expr_stmt|;
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|ports_guid
index|[
name|i
index|]
operator|.
name|wq
operator|=
name|NULL
expr_stmt|;
block|}
name|err_unregister
label|:
name|ib_sa_unregister_client
argument_list|(
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|sa_client
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|sa_client
argument_list|)
expr_stmt|;
name|dev
operator|->
name|sriov
operator|.
name|alias_guid
operator|.
name|sa_client
operator|=
name|NULL
expr_stmt|;
name|pr_err
argument_list|(
literal|"init_alias_guid_service: Failed. (ret:%d)\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

end_unit

