begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2007 Cisco Systems, Inc. All rights reserved.  * Copyright (c) 2007, 2008 Mellanox Technologies. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<linux/slab.h>
end_include

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/sched.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_include
include|#
directive|include
file|<linux/proc_fs.h>
end_include

begin_include
include|#
directive|include
file|<linux/cred.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"mlx4_ib.h"
end_include

begin_function
specifier|static
name|u32
name|convert_access
parameter_list|(
name|int
name|acc
parameter_list|)
block|{
return|return
operator|(
name|acc
operator|&
name|IB_ACCESS_REMOTE_ATOMIC
condition|?
name|MLX4_PERM_ATOMIC
else|:
literal|0
operator|)
operator||
operator|(
name|acc
operator|&
name|IB_ACCESS_REMOTE_WRITE
condition|?
name|MLX4_PERM_REMOTE_WRITE
else|:
literal|0
operator|)
operator||
operator|(
name|acc
operator|&
name|IB_ACCESS_REMOTE_READ
condition|?
name|MLX4_PERM_REMOTE_READ
else|:
literal|0
operator|)
operator||
operator|(
name|acc
operator|&
name|IB_ACCESS_LOCAL_WRITE
condition|?
name|MLX4_PERM_LOCAL_WRITE
else|:
literal|0
operator|)
operator||
name|MLX4_PERM_LOCAL_READ
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_function
specifier|static
name|ssize_t
name|shared_mr_proc_read
parameter_list|(
name|struct
name|file
modifier|*
name|file
parameter_list|,
name|char
name|__user
modifier|*
name|buffer
parameter_list|,
name|size_t
name|len
parameter_list|,
name|loff_t
modifier|*
name|offset
parameter_list|)
block|{
return|return
operator|-
name|ENOSYS
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|shared_mr_proc_write
parameter_list|(
name|struct
name|file
modifier|*
name|file
parameter_list|,
specifier|const
name|char
name|__user
modifier|*
name|buffer
parameter_list|,
name|size_t
name|len
parameter_list|,
name|loff_t
modifier|*
name|offset
parameter_list|)
block|{
return|return
operator|-
name|ENOSYS
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|shared_mr_mmap
parameter_list|(
name|struct
name|file
modifier|*
name|filep
parameter_list|,
name|struct
name|vm_area_struct
modifier|*
name|vma
parameter_list|)
block|{
name|struct
name|proc_dir_entry
modifier|*
name|pde
init|=
name|PDE
argument_list|(
name|filep
operator|->
name|f_path
operator|.
name|dentry
operator|->
name|d_inode
argument_list|)
decl_stmt|;
name|struct
name|mlx4_shared_mr_info
modifier|*
name|smr_info
init|=
operator|(
expr|struct
name|mlx4_shared_mr_info
operator|*
operator|)
name|pde
operator|->
name|data
decl_stmt|;
comment|/* Prevent any mapping not on start of area */
if|if
condition|(
name|vma
operator|->
name|vm_pgoff
operator|!=
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
name|ib_umem_map_to_vma
argument_list|(
name|smr_info
operator|->
name|umem
argument_list|,
name|vma
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|file_operations
name|shared_mr_proc_ops
init|=
block|{
operator|.
name|owner
operator|=
name|THIS_MODULE
block|,
operator|.
name|read
operator|=
name|shared_mr_proc_read
block|,
operator|.
name|write
operator|=
name|shared_mr_proc_write
block|,
operator|.
name|mmap
operator|=
name|shared_mr_mmap
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|mode_t
name|convert_shared_access
parameter_list|(
name|int
name|acc
parameter_list|)
block|{
return|return
operator|(
name|acc
operator|&
name|IB_ACCESS_SHARED_MR_USER_READ
condition|?
name|S_IRUSR
else|:
literal|0
operator|)
operator||
operator|(
name|acc
operator|&
name|IB_ACCESS_SHARED_MR_USER_WRITE
condition|?
name|S_IWUSR
else|:
literal|0
operator|)
operator||
operator|(
name|acc
operator|&
name|IB_ACCESS_SHARED_MR_GROUP_READ
condition|?
name|S_IRGRP
else|:
literal|0
operator|)
operator||
operator|(
name|acc
operator|&
name|IB_ACCESS_SHARED_MR_GROUP_WRITE
condition|?
name|S_IWGRP
else|:
literal|0
operator|)
operator||
operator|(
name|acc
operator|&
name|IB_ACCESS_SHARED_MR_OTHER_READ
condition|?
name|S_IROTH
else|:
literal|0
operator|)
operator||
operator|(
name|acc
operator|&
name|IB_ACCESS_SHARED_MR_OTHER_WRITE
condition|?
name|S_IWOTH
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|struct
name|ib_mr
modifier|*
name|mlx4_ib_get_dma_mr
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|int
name|acc
parameter_list|)
block|{
name|struct
name|mlx4_ib_mr
modifier|*
name|mr
decl_stmt|;
name|int
name|err
decl_stmt|;
name|mr
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|mr
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mr
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|err
operator|=
name|mlx4_mr_alloc
argument_list|(
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
operator|->
name|dev
argument_list|,
name|to_mpd
argument_list|(
name|pd
argument_list|)
operator|->
name|pdn
argument_list|,
literal|0
argument_list|,
operator|~
literal|0ull
argument_list|,
name|convert_access
argument_list|(
name|acc
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|mr
operator|->
name|mmr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_free
goto|;
name|err
operator|=
name|mlx4_mr_enable
argument_list|(
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
operator|->
name|dev
argument_list|,
operator|&
name|mr
operator|->
name|mmr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_mr
goto|;
name|mr
operator|->
name|ibmr
operator|.
name|rkey
operator|=
name|mr
operator|->
name|ibmr
operator|.
name|lkey
operator|=
name|mr
operator|->
name|mmr
operator|.
name|key
expr_stmt|;
name|mr
operator|->
name|umem
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|mr
operator|->
name|ibmr
return|;
name|err_mr
label|:
name|mlx4_mr_free
argument_list|(
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
operator|->
name|dev
argument_list|,
operator|&
name|mr
operator|->
name|mmr
argument_list|)
expr_stmt|;
name|err_free
label|:
name|kfree
argument_list|(
name|mr
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_umem_write_mtt_block
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_mtt
modifier|*
name|mtt
parameter_list|,
name|u64
name|mtt_size
parameter_list|,
name|u64
name|mtt_shift
parameter_list|,
name|u64
name|len
parameter_list|,
name|u64
name|cur_start_addr
parameter_list|,
name|u64
modifier|*
name|pages
parameter_list|,
name|int
modifier|*
name|start_index
parameter_list|,
name|int
modifier|*
name|npages
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|u64
name|mtt_entries
decl_stmt|;
name|u64
name|cur_end_addr
init|=
name|cur_start_addr
operator|+
name|len
decl_stmt|;
name|u64
name|cur_end_addr_aligned
init|=
literal|0
decl_stmt|;
name|len
operator|+=
operator|(
name|cur_start_addr
operator|&
operator|(
name|mtt_size
operator|-
literal|1ULL
operator|)
operator|)
expr_stmt|;
name|cur_end_addr_aligned
operator|=
name|round_up
argument_list|(
name|cur_end_addr
argument_list|,
name|mtt_size
argument_list|)
expr_stmt|;
name|len
operator|+=
operator|(
name|cur_end_addr_aligned
operator|-
name|cur_end_addr
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|&
operator|(
name|mtt_size
operator|-
literal|1ULL
operator|)
condition|)
block|{
name|WARN
argument_list|(
literal|1
argument_list|,
literal|"write_block: len %llx is not aligned to mtt_size %llx\n"
argument_list|,
name|len
argument_list|,
name|mtt_size
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|mtt_entries
operator|=
operator|(
name|len
operator|>>
name|mtt_shift
operator|)
expr_stmt|;
comment|/* Align the MTT start address to 		the mtt_size. 		Required to handle cases when the MR 		starts in the middle of an MTT record. 		Was not required in old code since 		the physical addresses provided by 		the dma subsystem were page aligned, 		which was also the MTT size. 	*/
name|cur_start_addr
operator|=
name|round_down
argument_list|(
name|cur_start_addr
argument_list|,
name|mtt_size
argument_list|)
expr_stmt|;
comment|/* A new block is started ...*/
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|mtt_entries
condition|;
operator|++
name|k
control|)
block|{
name|pages
index|[
operator|*
name|npages
index|]
operator|=
name|cur_start_addr
operator|+
operator|(
name|mtt_size
operator|*
name|k
operator|)
expr_stmt|;
operator|(
operator|*
name|npages
operator|)
operator|++
expr_stmt|;
comment|/* 		 * Be friendly to mlx4_write_mtt() and 		 * pass it chunks of appropriate size. 		 */
if|if
condition|(
operator|*
name|npages
operator|==
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
condition|)
block|{
name|err
operator|=
name|mlx4_write_mtt
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|mtt
argument_list|,
operator|*
name|start_index
argument_list|,
operator|*
name|npages
argument_list|,
name|pages
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
operator|(
operator|*
name|start_index
operator|)
operator|+=
operator|*
name|npages
expr_stmt|;
operator|*
name|npages
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx4_ib_umem_write_mtt
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_mtt
modifier|*
name|mtt
parameter_list|,
name|struct
name|ib_umem
modifier|*
name|umem
parameter_list|)
block|{
name|u64
modifier|*
name|pages
decl_stmt|;
name|struct
name|ib_umem_chunk
modifier|*
name|chunk
decl_stmt|;
name|int
name|j
decl_stmt|;
name|u64
name|len
init|=
literal|0
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|u64
name|mtt_size
decl_stmt|;
name|u64
name|cur_start_addr
init|=
literal|0
decl_stmt|;
name|u64
name|mtt_shift
decl_stmt|;
name|int
name|start_index
init|=
literal|0
decl_stmt|;
name|int
name|npages
init|=
literal|0
decl_stmt|;
name|pages
operator|=
operator|(
name|u64
operator|*
operator|)
name|__get_free_page
argument_list|(
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pages
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|mtt_shift
operator|=
name|mtt
operator|->
name|page_shift
expr_stmt|;
name|mtt_size
operator|=
literal|1ULL
operator|<<
name|mtt_shift
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|chunk
argument_list|,
argument|&umem->chunk_list
argument_list|,
argument|list
argument_list|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|chunk
operator|->
name|nmap
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|cur_start_addr
operator|+
name|len
operator|==
name|sg_dma_address
argument_list|(
operator|&
name|chunk
operator|->
name|page_list
index|[
name|j
index|]
argument_list|)
condition|)
block|{
comment|/* still the same block */
name|len
operator|+=
name|sg_dma_len
argument_list|(
operator|&
name|chunk
operator|->
name|page_list
index|[
name|j
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* A new block is started ...*/
comment|/* If len is malaligned, write an extra mtt entry to 			    cover the misaligned area (round up the division) 			*/
name|err
operator|=
name|mlx4_ib_umem_write_mtt_block
argument_list|(
name|dev
argument_list|,
name|mtt
argument_list|,
name|mtt_size
argument_list|,
name|mtt_shift
argument_list|,
name|len
argument_list|,
name|cur_start_addr
argument_list|,
name|pages
argument_list|,
operator|&
name|start_index
argument_list|,
operator|&
name|npages
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|cur_start_addr
operator|=
name|sg_dma_address
argument_list|(
operator|&
name|chunk
operator|->
name|page_list
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|len
operator|=
name|sg_dma_len
argument_list|(
operator|&
name|chunk
operator|->
name|page_list
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Handle the last block */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/*  If len is malaligned, write an extra mtt entry to cover 		     the misaligned area (round up the division) 		*/
name|err
operator|=
name|mlx4_ib_umem_write_mtt_block
argument_list|(
name|dev
argument_list|,
name|mtt
argument_list|,
name|mtt_size
argument_list|,
name|mtt_shift
argument_list|,
name|len
argument_list|,
name|cur_start_addr
argument_list|,
name|pages
argument_list|,
operator|&
name|start_index
argument_list|,
operator|&
name|npages
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|npages
condition|)
name|err
operator|=
name|mlx4_write_mtt
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|mtt
argument_list|,
name|start_index
argument_list|,
name|npages
argument_list|,
name|pages
argument_list|)
expr_stmt|;
name|out
label|:
name|free_page
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|pages
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u64
name|alignment_of
parameter_list|(
name|u64
name|ptr
parameter_list|)
block|{
return|return
name|ilog2
argument_list|(
name|ptr
operator|&
operator|(
operator|~
operator|(
name|ptr
operator|-
literal|1
operator|)
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_umem_calc_block_mtt
parameter_list|(
name|u64
name|next_block_start
parameter_list|,
name|u64
name|current_block_end
parameter_list|,
name|u64
name|block_shift
parameter_list|)
block|{
comment|/* Check whether the alignment of the new block 	     is aligned as well as the previous block. 	     Block address must start with zeros till size of entity_size. 	*/
if|if
condition|(
operator|(
name|next_block_start
operator|&
operator|(
operator|(
literal|1ULL
operator|<<
name|block_shift
operator|)
operator|-
literal|1ULL
operator|)
operator|)
operator|!=
literal|0
condition|)
comment|/* It is not as well aligned as the 		previous block-reduce the mtt size 		accordingly. 		Here we take the last right bit 		which is 1. 		*/
name|block_shift
operator|=
name|alignment_of
argument_list|(
name|next_block_start
argument_list|)
expr_stmt|;
comment|/*  Check whether the alignment of the 	     end of previous block - is it aligned 	     as well as the start of the block 	*/
if|if
condition|(
operator|(
operator|(
name|current_block_end
operator|)
operator|&
operator|(
operator|(
literal|1ULL
operator|<<
name|block_shift
operator|)
operator|-
literal|1ULL
operator|)
operator|)
operator|!=
literal|0
condition|)
comment|/* It is not as well aligned as 		the start of the block - reduce the 		mtt size accordingly. 		*/
name|block_shift
operator|=
name|alignment_of
argument_list|(
name|current_block_end
argument_list|)
expr_stmt|;
return|return
name|block_shift
return|;
block|}
end_function

begin_comment
comment|/* Calculate optimal mtt size based on contiguous pages. * Function will return also the number of pages that are not aligned to the    calculated mtt_size to be added to total number     of pages. For that we should check the first chunk length& last chunk     length and if not aligned to mtt_size we should increment     the non_aligned_pages number.     All chunks in the middle already handled as part of mtt shift calculation     for both their start& end addresses. */
end_comment

begin_function
name|int
name|mlx4_ib_umem_calc_optimal_mtt_size
parameter_list|(
name|struct
name|ib_umem
modifier|*
name|umem
parameter_list|,
name|u64
name|start_va
parameter_list|,
name|int
modifier|*
name|num_of_mtts
parameter_list|)
block|{
name|struct
name|ib_umem_chunk
modifier|*
name|chunk
decl_stmt|;
name|int
name|j
decl_stmt|;
name|u64
name|block_shift
init|=
name|MLX4_MAX_MTT_SHIFT
decl_stmt|;
name|u64
name|current_block_len
init|=
literal|0
decl_stmt|;
name|u64
name|current_block_start
init|=
literal|0
decl_stmt|;
name|u64
name|misalignment_bits
decl_stmt|;
name|u64
name|first_block_start
init|=
literal|0
decl_stmt|;
name|u64
name|last_block_end
init|=
literal|0
decl_stmt|;
name|u64
name|total_len
init|=
literal|0
decl_stmt|;
name|u64
name|last_block_aligned_end
init|=
literal|0
decl_stmt|;
name|u64
name|min_shift
init|=
name|ilog2
argument_list|(
name|umem
operator|->
name|page_size
argument_list|)
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|chunk
argument_list|,
argument|&umem->chunk_list
argument_list|,
argument|list
argument_list|)
block|{
comment|/* Initialization - save the first chunk start as 		    the current_block_start - block means contiguous pages. 		*/
if|if
condition|(
name|current_block_len
operator|==
literal|0
operator|&&
name|current_block_start
operator|==
literal|0
condition|)
block|{
name|first_block_start
operator|=
name|current_block_start
operator|=
name|sg_dma_address
argument_list|(
operator|&
name|chunk
operator|->
name|page_list
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* Find the bits that are different between 			    the physical address and the virtual 			    address for the start of the MR. 			*/
comment|/* umem_get aligned the start_va to a page 			   boundry. Therefore, we need to align the 			   start va to the same boundry */
comment|/* misalignment_bits is needed to handle the 			   case of a single memory region. In this 			   case, the rest of the logic will not reduce 			   the block size.  If we use a block size 			   which is bigger than the alignment of the 			   misalignment bits, we might use the virtual 			   page number instead of the physical page 			   number, resulting in access to the wrong 			   data. */
name|misalignment_bits
operator|=
operator|(
name|start_va
operator|&
operator|(
operator|~
operator|(
operator|(
call|(
name|u64
call|)
argument_list|(
name|umem
operator|->
name|page_size
argument_list|)
operator|)
operator|-
literal|1ULL
operator|)
operator|)
operator|)
operator|^
name|current_block_start
expr_stmt|;
name|block_shift
operator|=
name|min
argument_list|(
name|alignment_of
argument_list|(
name|misalignment_bits
argument_list|)
argument_list|,
name|block_shift
argument_list|)
expr_stmt|;
block|}
comment|/* Go over the scatter entries in the current chunk, check 		     if they continue the previous scatter entry. 		*/
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|chunk
operator|->
name|nmap
condition|;
operator|++
name|j
control|)
block|{
name|u64
name|next_block_start
init|=
name|sg_dma_address
argument_list|(
operator|&
name|chunk
operator|->
name|page_list
index|[
name|j
index|]
argument_list|)
decl_stmt|;
name|u64
name|current_block_end
init|=
name|current_block_start
operator|+
name|current_block_len
decl_stmt|;
comment|/* If we have a split (non-contig.) between two block*/
if|if
condition|(
name|current_block_end
operator|!=
name|next_block_start
condition|)
block|{
name|block_shift
operator|=
name|mlx4_ib_umem_calc_block_mtt
argument_list|(
name|next_block_start
argument_list|,
name|current_block_end
argument_list|,
name|block_shift
argument_list|)
expr_stmt|;
comment|/* If we reached the minimum shift for 4k 				     page we stop the loop. 				*/
if|if
condition|(
name|block_shift
operator|<=
name|min_shift
condition|)
goto|goto
name|end
goto|;
comment|/* If not saved yet we are in first block - 				     we save the length of first block to 				     calculate the non_aligned_pages number at 				*    the end. 				*/
name|total_len
operator|+=
name|current_block_len
expr_stmt|;
comment|/* Start a new block */
name|current_block_start
operator|=
name|next_block_start
expr_stmt|;
name|current_block_len
operator|=
name|sg_dma_len
argument_list|(
operator|&
name|chunk
operator|->
name|page_list
index|[
name|j
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* The scatter entry is another part of 			     the current block, increase the block size 			* An entry in the scatter can be larger than 			4k (page) as of dma mapping 			which merge some blocks together. 			*/
name|current_block_len
operator|+=
name|sg_dma_len
argument_list|(
operator|&
name|chunk
operator|->
name|page_list
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Account for the last block in the total len */
name|total_len
operator|+=
name|current_block_len
expr_stmt|;
comment|/* Add to the first block the misalignment that it suffers from.*/
name|total_len
operator|+=
operator|(
name|first_block_start
operator|&
operator|(
operator|(
literal|1ULL
operator|<<
name|block_shift
operator|)
operator|-
literal|1ULL
operator|)
operator|)
expr_stmt|;
name|last_block_end
operator|=
name|current_block_start
operator|+
name|current_block_len
expr_stmt|;
name|last_block_aligned_end
operator|=
name|round_up
argument_list|(
name|last_block_end
argument_list|,
literal|1
operator|<<
name|block_shift
argument_list|)
expr_stmt|;
name|total_len
operator|+=
operator|(
name|last_block_aligned_end
operator|-
name|last_block_end
operator|)
expr_stmt|;
name|WARN
argument_list|(
operator|(
name|total_len
operator|&
operator|(
operator|(
literal|1ULL
operator|<<
name|block_shift
operator|)
operator|-
literal|1ULL
operator|)
operator|)
argument_list|,
literal|" misaligned total length detected (%llu, %llu)!"
argument_list|,
name|total_len
argument_list|,
name|block_shift
argument_list|)
expr_stmt|;
operator|*
name|num_of_mtts
operator|=
name|total_len
operator|>>
name|block_shift
expr_stmt|;
name|end
label|:
if|if
condition|(
name|block_shift
operator|<
name|min_shift
condition|)
block|{
comment|/* If shift is less than the min we set a WARN and 		     return the min shift. 		*/
name|WARN
argument_list|(
literal|1
argument_list|,
literal|"mlx4_ib_umem_calc_optimal_mtt_size - unexpected shift %lld\n"
argument_list|,
name|block_shift
argument_list|)
expr_stmt|;
name|block_shift
operator|=
name|min_shift
expr_stmt|;
block|}
return|return
name|block_shift
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__linux__
end_ifdef

begin_function
specifier|static
name|int
name|prepare_shared_mr
parameter_list|(
name|struct
name|mlx4_ib_mr
modifier|*
name|mr
parameter_list|,
name|int
name|access_flags
parameter_list|,
name|int
name|mr_id
parameter_list|)
block|{
name|struct
name|proc_dir_entry
modifier|*
name|mr_proc_entry
decl_stmt|;
name|mode_t
name|mode
init|=
name|S_IFREG
decl_stmt|;
name|char
name|name_buff
index|[
literal|16
index|]
decl_stmt|;
name|mode
operator||=
name|convert_shared_access
argument_list|(
name|access_flags
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name_buff
argument_list|,
literal|"%X"
argument_list|,
name|mr_id
argument_list|)
expr_stmt|;
name|mr
operator|->
name|smr_info
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_shared_mr_info
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|mr
operator|->
name|smr_info
operator|->
name|mr_id
operator|=
name|mr_id
expr_stmt|;
name|mr
operator|->
name|smr_info
operator|->
name|umem
operator|=
name|mr
operator|->
name|umem
expr_stmt|;
name|mr_proc_entry
operator|=
name|proc_create_data
argument_list|(
name|name_buff
argument_list|,
name|mode
argument_list|,
name|mlx4_mrs_dir_entry
argument_list|,
operator|&
name|shared_mr_proc_ops
argument_list|,
name|mr
operator|->
name|smr_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mr_proc_entry
condition|)
block|{
name|pr_err
argument_list|(
literal|"prepare_shared_mr failed via proc\n"
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mr
operator|->
name|smr_info
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
name|current_uid_gid
argument_list|(
operator|&
operator|(
name|mr_proc_entry
operator|->
name|uid
operator|)
argument_list|,
operator|&
operator|(
name|mr_proc_entry
operator|->
name|gid
operator|)
argument_list|)
expr_stmt|;
name|mr_proc_entry
operator|->
name|size
operator|=
name|mr
operator|->
name|umem
operator|->
name|length
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_shared_mr
parameter_list|(
name|int
name|access_flags
parameter_list|)
block|{
comment|/* We should check whether IB_ACCESS_SHARED_MR_USER_READ or 	other shared bits were turned on. 	*/
return|return
operator|!
operator|!
operator|(
name|access_flags
operator|&
operator|(
name|IB_ACCESS_SHARED_MR_USER_READ
operator||
name|IB_ACCESS_SHARED_MR_USER_WRITE
operator||
name|IB_ACCESS_SHARED_MR_GROUP_READ
operator||
name|IB_ACCESS_SHARED_MR_GROUP_WRITE
operator||
name|IB_ACCESS_SHARED_MR_OTHER_READ
operator||
name|IB_ACCESS_SHARED_MR_OTHER_WRITE
operator|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|struct
name|ib_mr
modifier|*
name|mlx4_ib_reg_user_mr
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|u64
name|start
parameter_list|,
name|u64
name|length
parameter_list|,
name|u64
name|virt_addr
parameter_list|,
name|int
name|access_flags
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|,
name|int
name|mr_id
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_mr
modifier|*
name|mr
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|n
decl_stmt|;
name|mr
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|mr
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mr
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|mr
operator|->
name|umem
operator|=
name|ib_umem_get
argument_list|(
name|pd
operator|->
name|uobject
operator|->
name|context
argument_list|,
name|start
argument_list|,
name|length
argument_list|,
name|access_flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mr
operator|->
name|umem
argument_list|)
condition|)
block|{
name|err
operator|=
name|PTR_ERR
argument_list|(
name|mr
operator|->
name|umem
argument_list|)
expr_stmt|;
goto|goto
name|err_free
goto|;
block|}
name|n
operator|=
name|ib_umem_page_count
argument_list|(
name|mr
operator|->
name|umem
argument_list|)
expr_stmt|;
name|shift
operator|=
name|mlx4_ib_umem_calc_optimal_mtt_size
argument_list|(
name|mr
operator|->
name|umem
argument_list|,
name|start
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_mr_alloc
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|to_mpd
argument_list|(
name|pd
argument_list|)
operator|->
name|pdn
argument_list|,
name|virt_addr
argument_list|,
name|length
argument_list|,
name|convert_access
argument_list|(
name|access_flags
argument_list|)
argument_list|,
name|n
argument_list|,
name|shift
argument_list|,
operator|&
name|mr
operator|->
name|mmr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_umem
goto|;
name|err
operator|=
name|mlx4_ib_umem_write_mtt
argument_list|(
name|dev
argument_list|,
operator|&
name|mr
operator|->
name|mmr
operator|.
name|mtt
argument_list|,
name|mr
operator|->
name|umem
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_mr
goto|;
name|err
operator|=
name|mlx4_mr_enable
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|mr
operator|->
name|mmr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_mr
goto|;
name|mr
operator|->
name|ibmr
operator|.
name|rkey
operator|=
name|mr
operator|->
name|ibmr
operator|.
name|lkey
operator|=
name|mr
operator|->
name|mmr
operator|.
name|key
expr_stmt|;
ifdef|#
directive|ifdef
name|__linux__
comment|/* Check whether MR should be shared */
if|if
condition|(
name|is_shared_mr
argument_list|(
name|access_flags
argument_list|)
condition|)
block|{
comment|/* start address and length must be aligned to page size in order 	    to map a full page and preventing leakage of data */
if|if
condition|(
name|mr
operator|->
name|umem
operator|->
name|offset
operator|||
operator|(
name|length
operator|&
operator|~
name|PAGE_MASK
operator|)
condition|)
block|{
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_mr
goto|;
block|}
name|err
operator|=
name|prepare_shared_mr
argument_list|(
name|mr
argument_list|,
name|access_flags
argument_list|,
name|mr_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_mr
goto|;
block|}
endif|#
directive|endif
return|return
operator|&
name|mr
operator|->
name|ibmr
return|;
name|err_mr
label|:
name|mlx4_mr_free
argument_list|(
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
operator|->
name|dev
argument_list|,
operator|&
name|mr
operator|->
name|mmr
argument_list|)
expr_stmt|;
name|err_umem
label|:
name|ib_umem_release
argument_list|(
name|mr
operator|->
name|umem
argument_list|)
expr_stmt|;
name|err_free
label|:
name|kfree
argument_list|(
name|mr
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_ib_dereg_mr
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|ibmr
parameter_list|)
block|{
name|struct
name|mlx4_ib_mr
modifier|*
name|mr
init|=
name|to_mmr
argument_list|(
name|ibmr
argument_list|)
decl_stmt|;
name|mlx4_mr_free
argument_list|(
name|to_mdev
argument_list|(
name|ibmr
operator|->
name|device
argument_list|)
operator|->
name|dev
argument_list|,
operator|&
name|mr
operator|->
name|mmr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mr
operator|->
name|smr_info
condition|)
block|{
comment|/* When master/parent shared mr is dereged there is 		no ability to share this mr any more - its mr_id will be 		returned to the kernel as part of ib_uverbs_dereg_mr 		and may be allocated again as part of other reg_mr. 		*/
name|char
name|name_buff
index|[
literal|16
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|name_buff
argument_list|,
literal|"%X"
argument_list|,
name|mr
operator|->
name|smr_info
operator|->
name|mr_id
argument_list|)
expr_stmt|;
comment|/* Remove proc entry is checking internally that no operation 		    was strated on that proc fs file and if in the middle 		    current process will wait till end of operation. 		    That's why no sync mechanism is needed when we release 		    below the shared umem. 		*/
ifdef|#
directive|ifdef
name|__linux__
name|remove_proc_entry
argument_list|(
name|name_buff
argument_list|,
name|mlx4_mrs_dir_entry
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mr
operator|->
name|smr_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|mr
operator|->
name|umem
condition|)
name|ib_umem_release
argument_list|(
name|mr
operator|->
name|umem
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|ib_mr
modifier|*
name|mlx4_ib_alloc_fast_reg_mr
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|int
name|max_page_list_len
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_mr
modifier|*
name|mr
decl_stmt|;
name|int
name|err
decl_stmt|;
name|mr
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|mr
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mr
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|err
operator|=
name|mlx4_mr_alloc
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|to_mpd
argument_list|(
name|pd
argument_list|)
operator|->
name|pdn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|max_page_list_len
argument_list|,
literal|0
argument_list|,
operator|&
name|mr
operator|->
name|mmr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_free
goto|;
name|err
operator|=
name|mlx4_mr_enable
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|mr
operator|->
name|mmr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_mr
goto|;
name|mr
operator|->
name|ibmr
operator|.
name|rkey
operator|=
name|mr
operator|->
name|ibmr
operator|.
name|lkey
operator|=
name|mr
operator|->
name|mmr
operator|.
name|key
expr_stmt|;
name|mr
operator|->
name|umem
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|mr
operator|->
name|ibmr
return|;
name|err_mr
label|:
name|mlx4_mr_free
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|mr
operator|->
name|mmr
argument_list|)
expr_stmt|;
name|err_free
label|:
name|kfree
argument_list|(
name|mr
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|ib_fast_reg_page_list
modifier|*
name|mlx4_ib_alloc_fast_reg_page_list
parameter_list|(
name|struct
name|ib_device
modifier|*
name|ibdev
parameter_list|,
name|int
name|page_list_len
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_fast_reg_page_list
modifier|*
name|mfrpl
decl_stmt|;
name|int
name|size
init|=
name|page_list_len
operator|*
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
decl_stmt|;
if|if
condition|(
name|page_list_len
operator|>
name|MLX4_MAX_FAST_REG_PAGES
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|EINVAL
argument_list|)
return|;
name|mfrpl
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|mfrpl
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mfrpl
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|mfrpl
operator|->
name|ibfrpl
operator|.
name|page_list
operator|=
name|kmalloc
argument_list|(
name|size
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mfrpl
operator|->
name|ibfrpl
operator|.
name|page_list
condition|)
goto|goto
name|err_free
goto|;
name|mfrpl
operator|->
name|mapped_page_list
operator|=
name|dma_alloc_coherent
argument_list|(
operator|&
name|dev
operator|->
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|size
argument_list|,
operator|&
name|mfrpl
operator|->
name|map
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mfrpl
operator|->
name|mapped_page_list
condition|)
goto|goto
name|err_free
goto|;
name|WARN_ON
argument_list|(
name|mfrpl
operator|->
name|map
operator|&
literal|0x3f
argument_list|)
expr_stmt|;
return|return
operator|&
name|mfrpl
operator|->
name|ibfrpl
return|;
name|err_free
label|:
name|kfree
argument_list|(
name|mfrpl
operator|->
name|ibfrpl
operator|.
name|page_list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mfrpl
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|mlx4_ib_free_fast_reg_page_list
parameter_list|(
name|struct
name|ib_fast_reg_page_list
modifier|*
name|page_list
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|page_list
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_fast_reg_page_list
modifier|*
name|mfrpl
init|=
name|to_mfrpl
argument_list|(
name|page_list
argument_list|)
decl_stmt|;
name|int
name|size
init|=
name|page_list
operator|->
name|max_page_list_len
operator|*
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
decl_stmt|;
name|dma_free_coherent
argument_list|(
operator|&
name|dev
operator|->
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|size
argument_list|,
name|mfrpl
operator|->
name|mapped_page_list
argument_list|,
name|mfrpl
operator|->
name|map
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mfrpl
operator|->
name|ibfrpl
operator|.
name|page_list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mfrpl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ib_fmr
modifier|*
name|mlx4_ib_fmr_alloc
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|int
name|acc
parameter_list|,
name|struct
name|ib_fmr_attr
modifier|*
name|fmr_attr
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_fmr
modifier|*
name|fmr
decl_stmt|;
name|int
name|err
init|=
operator|-
name|ENOMEM
decl_stmt|;
name|fmr
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|fmr
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fmr
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|err
operator|=
name|mlx4_fmr_alloc
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|to_mpd
argument_list|(
name|pd
argument_list|)
operator|->
name|pdn
argument_list|,
name|convert_access
argument_list|(
name|acc
argument_list|)
argument_list|,
name|fmr_attr
operator|->
name|max_pages
argument_list|,
name|fmr_attr
operator|->
name|max_maps
argument_list|,
name|fmr_attr
operator|->
name|page_shift
argument_list|,
operator|&
name|fmr
operator|->
name|mfmr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_free
goto|;
name|err
operator|=
name|mlx4_fmr_enable
argument_list|(
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
operator|->
name|dev
argument_list|,
operator|&
name|fmr
operator|->
name|mfmr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_mr
goto|;
name|fmr
operator|->
name|ibfmr
operator|.
name|rkey
operator|=
name|fmr
operator|->
name|ibfmr
operator|.
name|lkey
operator|=
name|fmr
operator|->
name|mfmr
operator|.
name|mr
operator|.
name|key
expr_stmt|;
return|return
operator|&
name|fmr
operator|->
name|ibfmr
return|;
name|err_mr
label|:
name|mlx4_mr_free
argument_list|(
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
operator|->
name|dev
argument_list|,
operator|&
name|fmr
operator|->
name|mfmr
operator|.
name|mr
argument_list|)
expr_stmt|;
name|err_free
label|:
name|kfree
argument_list|(
name|fmr
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_ib_map_phys_fmr
parameter_list|(
name|struct
name|ib_fmr
modifier|*
name|ibfmr
parameter_list|,
name|u64
modifier|*
name|page_list
parameter_list|,
name|int
name|npages
parameter_list|,
name|u64
name|iova
parameter_list|)
block|{
name|struct
name|mlx4_ib_fmr
modifier|*
name|ifmr
init|=
name|to_mfmr
argument_list|(
name|ibfmr
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ifmr
operator|->
name|ibfmr
operator|.
name|device
argument_list|)
decl_stmt|;
return|return
name|mlx4_map_phys_fmr
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|ifmr
operator|->
name|mfmr
argument_list|,
name|page_list
argument_list|,
name|npages
argument_list|,
name|iova
argument_list|,
operator|&
name|ifmr
operator|->
name|ibfmr
operator|.
name|lkey
argument_list|,
operator|&
name|ifmr
operator|->
name|ibfmr
operator|.
name|rkey
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_ib_unmap_fmr
parameter_list|(
name|struct
name|list_head
modifier|*
name|fmr_list
parameter_list|)
block|{
name|struct
name|ib_fmr
modifier|*
name|ibfmr
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|mdev
init|=
name|NULL
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|ibfmr
argument_list|,
argument|fmr_list
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|mdev
operator|&&
name|to_mdev
argument_list|(
name|ibfmr
operator|->
name|device
argument_list|)
operator|->
name|dev
operator|!=
name|mdev
condition|)
return|return
operator|-
name|EINVAL
return|;
name|mdev
operator|=
name|to_mdev
argument_list|(
name|ibfmr
operator|->
name|device
argument_list|)
operator|->
name|dev
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mdev
condition|)
return|return
literal|0
return|;
name|list_for_each_entry
argument_list|(
argument|ibfmr
argument_list|,
argument|fmr_list
argument_list|,
argument|list
argument_list|)
block|{
name|struct
name|mlx4_ib_fmr
modifier|*
name|ifmr
init|=
name|to_mfmr
argument_list|(
name|ibfmr
argument_list|)
decl_stmt|;
name|mlx4_fmr_unmap
argument_list|(
name|mdev
argument_list|,
operator|&
name|ifmr
operator|->
name|mfmr
argument_list|,
operator|&
name|ifmr
operator|->
name|ibfmr
operator|.
name|lkey
argument_list|,
operator|&
name|ifmr
operator|->
name|ibfmr
operator|.
name|rkey
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Make sure all MPT status updates are visible before issuing 	 * SYNC_TPT firmware command. 	 */
name|wmb
argument_list|()
expr_stmt|;
name|err
operator|=
name|mlx4_SYNC_TPT
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|pr_warn
argument_list|(
literal|"SYNC_TPT error %d when "
literal|"unmapping FMRs\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx4_ib_fmr_dealloc
parameter_list|(
name|struct
name|ib_fmr
modifier|*
name|ibfmr
parameter_list|)
block|{
name|struct
name|mlx4_ib_fmr
modifier|*
name|ifmr
init|=
name|to_mfmr
argument_list|(
name|ibfmr
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ibfmr
operator|->
name|device
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|mlx4_fmr_free
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|ifmr
operator|->
name|mfmr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|kfree
argument_list|(
name|ifmr
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

end_unit

