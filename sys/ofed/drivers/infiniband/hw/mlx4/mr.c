begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2007 Cisco Systems, Inc. All rights reserved.  * Copyright (c) 2007, 2008 Mellanox Technologies. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<linux/slab.h>
end_include

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/sched.h>
end_include

begin_include
include|#
directive|include
file|"mlx4_ib.h"
end_include

begin_function
specifier|static
name|u32
name|convert_access
parameter_list|(
name|int
name|acc
parameter_list|)
block|{
return|return
operator|(
name|acc
operator|&
name|IB_ACCESS_REMOTE_ATOMIC
condition|?
name|MLX4_PERM_ATOMIC
else|:
literal|0
operator|)
operator||
operator|(
name|acc
operator|&
name|IB_ACCESS_REMOTE_WRITE
condition|?
name|MLX4_PERM_REMOTE_WRITE
else|:
literal|0
operator|)
operator||
operator|(
name|acc
operator|&
name|IB_ACCESS_REMOTE_READ
condition|?
name|MLX4_PERM_REMOTE_READ
else|:
literal|0
operator|)
operator||
operator|(
name|acc
operator|&
name|IB_ACCESS_LOCAL_WRITE
condition|?
name|MLX4_PERM_LOCAL_WRITE
else|:
literal|0
operator|)
operator||
operator|(
name|acc
operator|&
name|IB_ACCESS_MW_BIND
condition|?
name|MLX4_PERM_BIND_MW
else|:
literal|0
operator|)
operator||
name|MLX4_PERM_LOCAL_READ
return|;
block|}
end_function

begin_comment
comment|/* No suuport for Shared MR feature */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static ssize_t shared_mr_proc_read(struct file *file, 			  char __user *buffer, 			  size_t len, 			  loff_t *offset) {  	return -ENOSYS;  }  static ssize_t shared_mr_proc_write(struct file *file, 			   const char __user *buffer, 			   size_t len, 			   loff_t *offset) {  	return -ENOSYS; }  static int shared_mr_mmap(struct file *filep, struct vm_area_struct *vma) {  	struct proc_dir_entry *pde = PDE(filep->f_path.dentry->d_inode); 	struct mlx4_shared_mr_info *smr_info = 		(struct mlx4_shared_mr_info *)pde->data;
comment|/* Prevent any mapping not on start of area */
end_comment

begin_endif
unit|if (vma->vm_pgoff != 0) 		return -EINVAL;  	return ib_umem_map_to_vma(smr_info->umem, 					vma);  }  static const struct file_operations shared_mr_proc_ops = { 	.owner	= THIS_MODULE, 	.read	= shared_mr_proc_read, 	.write	= shared_mr_proc_write, 	.mmap	= shared_mr_mmap };  static mode_t convert_shared_access(int acc) {  	return (acc& IB_ACCESS_SHARED_MR_USER_READ ? S_IRUSR       : 0) | 	       (acc& IB_ACCESS_SHARED_MR_USER_WRITE  ? S_IWUSR : 0) | 	       (acc& IB_ACCESS_SHARED_MR_GROUP_READ   ? S_IRGRP  : 0) | 	       (acc& IB_ACCESS_SHARED_MR_GROUP_WRITE   ? S_IWGRP  : 0) | 	       (acc& IB_ACCESS_SHARED_MR_OTHER_READ   ? S_IROTH  : 0) | 	       (acc& IB_ACCESS_SHARED_MR_OTHER_WRITE   ? S_IWOTH  : 0);  }
endif|#
directive|endif
end_endif

begin_function
name|struct
name|ib_mr
modifier|*
name|mlx4_ib_get_dma_mr
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|int
name|acc
parameter_list|)
block|{
name|struct
name|mlx4_ib_mr
modifier|*
name|mr
decl_stmt|;
name|int
name|err
decl_stmt|;
name|mr
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|mr
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mr
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|err
operator|=
name|mlx4_mr_alloc
argument_list|(
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
operator|->
name|dev
argument_list|,
name|to_mpd
argument_list|(
name|pd
argument_list|)
operator|->
name|pdn
argument_list|,
literal|0
argument_list|,
operator|~
literal|0ull
argument_list|,
name|convert_access
argument_list|(
name|acc
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|mr
operator|->
name|mmr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_free
goto|;
name|err
operator|=
name|mlx4_mr_enable
argument_list|(
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
operator|->
name|dev
argument_list|,
operator|&
name|mr
operator|->
name|mmr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_mr
goto|;
name|mr
operator|->
name|ibmr
operator|.
name|rkey
operator|=
name|mr
operator|->
name|ibmr
operator|.
name|lkey
operator|=
name|mr
operator|->
name|mmr
operator|.
name|key
expr_stmt|;
name|mr
operator|->
name|umem
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|mr
operator|->
name|ibmr
return|;
name|err_mr
label|:
operator|(
name|void
operator|)
name|mlx4_mr_free
argument_list|(
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
operator|->
name|dev
argument_list|,
operator|&
name|mr
operator|->
name|mmr
argument_list|)
expr_stmt|;
name|err_free
label|:
name|kfree
argument_list|(
name|mr
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_umem_write_mtt_block
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_mtt
modifier|*
name|mtt
parameter_list|,
name|u64
name|mtt_size
parameter_list|,
name|u64
name|mtt_shift
parameter_list|,
name|u64
name|len
parameter_list|,
name|u64
name|cur_start_addr
parameter_list|,
name|u64
modifier|*
name|pages
parameter_list|,
name|int
modifier|*
name|start_index
parameter_list|,
name|int
modifier|*
name|npages
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|u64
name|mtt_entries
decl_stmt|;
name|u64
name|cur_end_addr
init|=
name|cur_start_addr
operator|+
name|len
decl_stmt|;
name|u64
name|cur_end_addr_aligned
init|=
literal|0
decl_stmt|;
name|len
operator|+=
operator|(
name|cur_start_addr
operator|&
operator|(
name|mtt_size
operator|-
literal|1ULL
operator|)
operator|)
expr_stmt|;
name|cur_end_addr_aligned
operator|=
name|round_up
argument_list|(
name|cur_end_addr
argument_list|,
name|mtt_size
argument_list|)
expr_stmt|;
name|len
operator|+=
operator|(
name|cur_end_addr_aligned
operator|-
name|cur_end_addr
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|&
operator|(
name|mtt_size
operator|-
literal|1ULL
operator|)
condition|)
block|{
name|WARN
argument_list|(
literal|1
argument_list|,
literal|"write_block: len %llx is not aligned to mtt_size %llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|len
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|mtt_size
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|mtt_entries
operator|=
operator|(
name|len
operator|>>
name|mtt_shift
operator|)
expr_stmt|;
comment|/* Align the MTT start address to 		the mtt_size. 		Required to handle cases when the MR 		starts in the middle of an MTT record. 		Was not required in old code since 		the physical addresses provided by 		the dma subsystem were page aligned, 		which was also the MTT size. 	*/
name|cur_start_addr
operator|=
name|round_down
argument_list|(
name|cur_start_addr
argument_list|,
name|mtt_size
argument_list|)
expr_stmt|;
comment|/* A new block is started ...*/
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|mtt_entries
condition|;
operator|++
name|k
control|)
block|{
name|pages
index|[
operator|*
name|npages
index|]
operator|=
name|cur_start_addr
operator|+
operator|(
name|mtt_size
operator|*
name|k
operator|)
expr_stmt|;
operator|(
operator|*
name|npages
operator|)
operator|++
expr_stmt|;
comment|/* 		 * Be friendly to mlx4_write_mtt() and 		 * pass it chunks of appropriate size. 		 */
if|if
condition|(
operator|*
name|npages
operator|==
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
condition|)
block|{
name|err
operator|=
name|mlx4_write_mtt
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|mtt
argument_list|,
operator|*
name|start_index
argument_list|,
operator|*
name|npages
argument_list|,
name|pages
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
operator|(
operator|*
name|start_index
operator|)
operator|+=
operator|*
name|npages
expr_stmt|;
operator|*
name|npages
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx4_ib_umem_write_mtt
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_mtt
modifier|*
name|mtt
parameter_list|,
name|struct
name|ib_umem
modifier|*
name|umem
parameter_list|)
block|{
name|u64
modifier|*
name|pages
decl_stmt|;
name|u64
name|len
init|=
literal|0
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|u64
name|mtt_size
decl_stmt|;
name|u64
name|cur_start_addr
init|=
literal|0
decl_stmt|;
name|u64
name|mtt_shift
decl_stmt|;
name|int
name|start_index
init|=
literal|0
decl_stmt|;
name|int
name|npages
init|=
literal|0
decl_stmt|;
name|struct
name|scatterlist
modifier|*
name|sg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|pages
operator|=
operator|(
name|u64
operator|*
operator|)
name|__get_free_page
argument_list|(
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pages
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|mtt_shift
operator|=
name|mtt
operator|->
name|page_shift
expr_stmt|;
name|mtt_size
operator|=
literal|1ULL
operator|<<
name|mtt_shift
expr_stmt|;
name|for_each_sg
argument_list|(
argument|umem->sg_head.sgl
argument_list|,
argument|sg
argument_list|,
argument|umem->nmap
argument_list|,
argument|i
argument_list|)
block|{
if|if
condition|(
name|cur_start_addr
operator|+
name|len
operator|==
name|sg_dma_address
argument_list|(
name|sg
argument_list|)
condition|)
block|{
comment|/* still the same block */
name|len
operator|+=
name|sg_dma_len
argument_list|(
name|sg
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* A new block is started ...*/
comment|/* If len is malaligned, write an extra mtt entry to 			    cover the misaligned area (round up the division) 			*/
name|err
operator|=
name|mlx4_ib_umem_write_mtt_block
argument_list|(
name|dev
argument_list|,
name|mtt
argument_list|,
name|mtt_size
argument_list|,
name|mtt_shift
argument_list|,
name|len
argument_list|,
name|cur_start_addr
argument_list|,
name|pages
argument_list|,
operator|&
name|start_index
argument_list|,
operator|&
name|npages
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|cur_start_addr
operator|=
name|sg_dma_address
argument_list|(
name|sg
argument_list|)
expr_stmt|;
name|len
operator|=
name|sg_dma_len
argument_list|(
name|sg
argument_list|)
expr_stmt|;
block|}
comment|/* Handle the last block */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/*  If len is malaligned, write an extra mtt entry to cover 		     the misaligned area (round up the division) 		*/
name|err
operator|=
name|mlx4_ib_umem_write_mtt_block
argument_list|(
name|dev
argument_list|,
name|mtt
argument_list|,
name|mtt_size
argument_list|,
name|mtt_shift
argument_list|,
name|len
argument_list|,
name|cur_start_addr
argument_list|,
name|pages
argument_list|,
operator|&
name|start_index
argument_list|,
operator|&
name|npages
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|npages
condition|)
name|err
operator|=
name|mlx4_write_mtt
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|mtt
argument_list|,
name|start_index
argument_list|,
name|npages
argument_list|,
name|pages
argument_list|)
expr_stmt|;
name|out
label|:
name|free_page
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|pages
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u64
name|alignment_of
parameter_list|(
name|u64
name|ptr
parameter_list|)
block|{
return|return
name|ilog2
argument_list|(
name|ptr
operator|&
operator|(
operator|~
operator|(
name|ptr
operator|-
literal|1
operator|)
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_ib_umem_calc_block_mtt
parameter_list|(
name|u64
name|next_block_start
parameter_list|,
name|u64
name|current_block_end
parameter_list|,
name|u64
name|block_shift
parameter_list|)
block|{
comment|/* Check whether the alignment of the new block 	     is aligned as well as the previous block. 	     Block address must start with zeros till size of entity_size. 	*/
if|if
condition|(
operator|(
name|next_block_start
operator|&
operator|(
operator|(
literal|1ULL
operator|<<
name|block_shift
operator|)
operator|-
literal|1ULL
operator|)
operator|)
operator|!=
literal|0
condition|)
comment|/* It is not as well aligned as the 		previous block-reduce the mtt size 		accordingly. 		Here we take the last right bit 		which is 1. 		*/
name|block_shift
operator|=
name|alignment_of
argument_list|(
name|next_block_start
argument_list|)
expr_stmt|;
comment|/*  Check whether the alignment of the 	     end of previous block - is it aligned 	     as well as the start of the block 	*/
if|if
condition|(
operator|(
operator|(
name|current_block_end
operator|)
operator|&
operator|(
operator|(
literal|1ULL
operator|<<
name|block_shift
operator|)
operator|-
literal|1ULL
operator|)
operator|)
operator|!=
literal|0
condition|)
comment|/* It is not as well aligned as 		the start of the block - reduce the 		mtt size accordingly. 		*/
name|block_shift
operator|=
name|alignment_of
argument_list|(
name|current_block_end
argument_list|)
expr_stmt|;
return|return
name|block_shift
return|;
block|}
end_function

begin_comment
comment|/* Calculate optimal mtt size based on contiguous pages. * Function will return also the number of pages that are not aligned to the    calculated mtt_size to be added to total number     of pages. For that we should check the first chunk length& last chunk     length and if not aligned to mtt_size we should increment     the non_aligned_pages number.     All chunks in the middle already handled as part of mtt shift calculation     for both their start& end addresses. */
end_comment

begin_function
name|int
name|mlx4_ib_umem_calc_optimal_mtt_size
parameter_list|(
name|struct
name|ib_umem
modifier|*
name|umem
parameter_list|,
name|u64
name|start_va
parameter_list|,
name|int
modifier|*
name|num_of_mtts
parameter_list|)
block|{
name|u64
name|block_shift
init|=
name|MLX4_MAX_MTT_SHIFT
decl_stmt|;
name|u64
name|current_block_len
init|=
literal|0
decl_stmt|;
name|u64
name|current_block_start
init|=
literal|0
decl_stmt|;
name|u64
name|misalignment_bits
decl_stmt|;
name|u64
name|first_block_start
init|=
literal|0
decl_stmt|;
name|u64
name|last_block_end
init|=
literal|0
decl_stmt|;
name|u64
name|total_len
init|=
literal|0
decl_stmt|;
name|u64
name|last_block_aligned_end
init|=
literal|0
decl_stmt|;
name|u64
name|min_shift
init|=
name|ilog2
argument_list|(
name|umem
operator|->
name|page_size
argument_list|)
decl_stmt|;
name|struct
name|scatterlist
modifier|*
name|sg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u64
name|next_block_start
decl_stmt|;
name|u64
name|current_block_end
decl_stmt|;
name|for_each_sg
argument_list|(
argument|umem->sg_head.sgl
argument_list|,
argument|sg
argument_list|,
argument|umem->nmap
argument_list|,
argument|i
argument_list|)
block|{
comment|/* Initialization - save the first chunk start as 		    the current_block_start - block means contiguous pages. 		*/
if|if
condition|(
name|current_block_len
operator|==
literal|0
operator|&&
name|current_block_start
operator|==
literal|0
condition|)
block|{
name|first_block_start
operator|=
name|current_block_start
operator|=
name|sg_dma_address
argument_list|(
name|sg
argument_list|)
expr_stmt|;
comment|/* Find the bits that are different between 			    the physical address and the virtual 			    address for the start of the MR. 			*/
comment|/* umem_get aligned the start_va to a page 			   boundry. Therefore, we need to align the 			   start va to the same boundry */
comment|/* misalignment_bits is needed to handle the 			   case of a single memory region. In this 			   case, the rest of the logic will not reduce 			   the block size.  If we use a block size 			   which is bigger than the alignment of the 			   misalignment bits, we might use the virtual 			   page number instead of the physical page 			   number, resulting in access to the wrong 			   data. */
name|misalignment_bits
operator|=
operator|(
name|start_va
operator|&
operator|(
operator|~
operator|(
operator|(
call|(
name|u64
call|)
argument_list|(
name|umem
operator|->
name|page_size
argument_list|)
operator|)
operator|-
literal|1ULL
operator|)
operator|)
operator|)
operator|^
name|current_block_start
expr_stmt|;
name|block_shift
operator|=
name|min
argument_list|(
name|alignment_of
argument_list|(
name|misalignment_bits
argument_list|)
argument_list|,
name|block_shift
argument_list|)
expr_stmt|;
block|}
comment|/* Go over the scatter entries and check 		     if they continue the previous scatter entry. 		*/
name|next_block_start
operator|=
name|sg_dma_address
argument_list|(
name|sg
argument_list|)
expr_stmt|;
name|current_block_end
operator|=
name|current_block_start
operator|+
name|current_block_len
expr_stmt|;
comment|/* If we have a split (non-contig.) between two block*/
if|if
condition|(
name|current_block_end
operator|!=
name|next_block_start
condition|)
block|{
name|block_shift
operator|=
name|mlx4_ib_umem_calc_block_mtt
argument_list|(
name|next_block_start
argument_list|,
name|current_block_end
argument_list|,
name|block_shift
argument_list|)
expr_stmt|;
comment|/* If we reached the minimum shift for 4k 				     page we stop the loop. 				*/
if|if
condition|(
name|block_shift
operator|<=
name|min_shift
condition|)
goto|goto
name|end
goto|;
comment|/* If not saved yet we are in first block - 				     we save the length of first block to 				     calculate the non_aligned_pages number at 				*    the end. 				*/
name|total_len
operator|+=
name|current_block_len
expr_stmt|;
comment|/* Start a new block */
name|current_block_start
operator|=
name|next_block_start
expr_stmt|;
name|current_block_len
operator|=
name|sg_dma_len
argument_list|(
name|sg
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* The scatter entry is another part of 			     the current block, increase the block size 			* An entry in the scatter can be larger than 			4k (page) as of dma mapping 			which merge some blocks together. 			*/
name|current_block_len
operator|+=
name|sg_dma_len
argument_list|(
name|sg
argument_list|)
expr_stmt|;
block|}
comment|/* Account for the last block in the total len */
name|total_len
operator|+=
name|current_block_len
expr_stmt|;
comment|/* Add to the first block the misalignment that it suffers from.*/
name|total_len
operator|+=
operator|(
name|first_block_start
operator|&
operator|(
operator|(
literal|1ULL
operator|<<
name|block_shift
operator|)
operator|-
literal|1ULL
operator|)
operator|)
expr_stmt|;
name|last_block_end
operator|=
name|current_block_start
operator|+
name|current_block_len
expr_stmt|;
name|last_block_aligned_end
operator|=
name|round_up
argument_list|(
name|last_block_end
argument_list|,
literal|1
operator|<<
name|block_shift
argument_list|)
expr_stmt|;
name|total_len
operator|+=
operator|(
name|last_block_aligned_end
operator|-
name|last_block_end
operator|)
expr_stmt|;
name|WARN
argument_list|(
operator|(
name|total_len
operator|&
operator|(
operator|(
literal|1ULL
operator|<<
name|block_shift
operator|)
operator|-
literal|1ULL
operator|)
operator|)
argument_list|,
literal|" misaligned total length detected (%llu, %llu)!"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|total_len
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|block_shift
argument_list|)
expr_stmt|;
operator|*
name|num_of_mtts
operator|=
name|total_len
operator|>>
name|block_shift
expr_stmt|;
name|end
label|:
if|if
condition|(
name|block_shift
operator|<
name|min_shift
condition|)
block|{
comment|/* If shift is less than the min we set a WARN and 		     return the min shift. 		*/
name|WARN
argument_list|(
literal|1
argument_list|,
literal|"mlx4_ib_umem_calc_optimal_mtt_size - unexpected shift %lld\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|block_shift
argument_list|)
expr_stmt|;
name|block_shift
operator|=
name|min_shift
expr_stmt|;
block|}
return|return
name|block_shift
return|;
block|}
end_function

begin_comment
comment|/* No suuport for Shared MR */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
unit|static int prepare_shared_mr(struct mlx4_ib_mr *mr, int access_flags, int mr_id) {  	struct proc_dir_entry *mr_proc_entry; 	mode_t mode = S_IFREG; 	char name_buff[16];  	mode |= convert_shared_access(access_flags); 	sprintf(name_buff, "%X", mr_id); 	mr->smr_info = kmalloc(sizeof(struct mlx4_shared_mr_info), GFP_KERNEL); 	mr->smr_info->mr_id = mr_id; 	mr->smr_info->umem = mr->umem;  	mr_proc_entry = proc_create_data(name_buff, mode, 				mlx4_mrs_dir_entry,&shared_mr_proc_ops, 				mr->smr_info);  	if (!mr_proc_entry) { 		pr_err("prepare_shared_mr failed via proc\n"); 		kfree(mr->smr_info); 		return -ENODEV; 	}  	current_uid_gid(&(mr_proc_entry->uid),&(mr_proc_entry->gid)); 	mr_proc_entry->size = mr->umem->length; 	return 0;  } static int is_shared_mr(int access_flags) {
comment|/* We should check whether IB_ACCESS_SHARED_MR_USER_READ or 	other shared bits were turned on. 	*/
end_comment

begin_comment
unit|return !!(access_flags& (IB_ACCESS_SHARED_MR_USER_READ | 				IB_ACCESS_SHARED_MR_USER_WRITE | 				IB_ACCESS_SHARED_MR_GROUP_READ | 				IB_ACCESS_SHARED_MR_GROUP_WRITE | 				IB_ACCESS_SHARED_MR_OTHER_READ | 				IB_ACCESS_SHARED_MR_OTHER_WRITE));  }  static void free_smr_info(struct mlx4_ib_mr *mr) {
comment|/* When master/parent shared mr is dereged there is 	no ability to share this mr any more - its mr_id will be 	returned to the kernel as part of ib_uverbs_dereg_mr 	and may be allocated again as part of other reg_mr. 	*/
end_comment

begin_comment
unit|char name_buff[16];  	sprintf(name_buff, "%X", mr->smr_info->mr_id);
comment|/* Remove proc entry is checking internally that no operation 	was strated on that proc fs file and if in the middle 	current process will wait till end of operation. 	That's why no sync mechanism is needed when we release 	below the shared umem. 	*/
end_comment

begin_endif
unit|remove_proc_entry(name_buff, mlx4_mrs_dir_entry); 	kfree(mr->smr_info); 	mr->smr_info = NULL; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|mlx4_invalidate_umem
parameter_list|(
name|void
modifier|*
name|invalidation_cookie
parameter_list|,
name|struct
name|ib_umem
modifier|*
name|umem
parameter_list|,
name|unsigned
name|long
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|struct
name|mlx4_ib_mr
modifier|*
name|mr
init|=
operator|(
expr|struct
name|mlx4_ib_mr
operator|*
operator|)
name|invalidation_cookie
decl_stmt|;
comment|/* This function is called under client peer lock so its resources are race protected */
if|if
condition|(
name|atomic_inc_return
argument_list|(
operator|&
name|mr
operator|->
name|invalidated
argument_list|)
operator|>
literal|1
condition|)
block|{
name|umem
operator|->
name|invalidation_ctx
operator|->
name|inflight_invalidation
operator|=
literal|1
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|umem
operator|->
name|invalidation_ctx
operator|->
name|peer_callback
operator|=
literal|1
expr_stmt|;
name|mlx4_mr_free
argument_list|(
name|to_mdev
argument_list|(
name|mr
operator|->
name|ibmr
operator|.
name|device
argument_list|)
operator|->
name|dev
argument_list|,
operator|&
name|mr
operator|->
name|mmr
argument_list|)
expr_stmt|;
name|ib_umem_release
argument_list|(
name|umem
argument_list|)
expr_stmt|;
name|complete
argument_list|(
operator|&
name|mr
operator|->
name|invalidation_comp
argument_list|)
expr_stmt|;
name|end
label|:
return|return;
block|}
end_function

begin_function
name|struct
name|ib_mr
modifier|*
name|mlx4_ib_reg_user_mr
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|u64
name|start
parameter_list|,
name|u64
name|length
parameter_list|,
name|u64
name|virt_addr
parameter_list|,
name|int
name|access_flags
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|,
name|int
name|mr_id
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_mr
modifier|*
name|mr
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|n
decl_stmt|;
name|struct
name|ib_peer_memory_client
modifier|*
name|ib_peer_mem
decl_stmt|;
name|mr
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|mr
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mr
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|mr
operator|->
name|umem
operator|=
name|ib_umem_get_ex
argument_list|(
name|pd
operator|->
name|uobject
operator|->
name|context
argument_list|,
name|start
argument_list|,
name|length
argument_list|,
name|access_flags
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mr
operator|->
name|umem
argument_list|)
condition|)
block|{
name|err
operator|=
name|PTR_ERR
argument_list|(
name|mr
operator|->
name|umem
argument_list|)
expr_stmt|;
goto|goto
name|err_free
goto|;
block|}
name|ib_peer_mem
operator|=
name|mr
operator|->
name|umem
operator|->
name|ib_peer_mem
expr_stmt|;
name|n
operator|=
name|ib_umem_page_count
argument_list|(
name|mr
operator|->
name|umem
argument_list|)
expr_stmt|;
name|shift
operator|=
name|mlx4_ib_umem_calc_optimal_mtt_size
argument_list|(
name|mr
operator|->
name|umem
argument_list|,
name|start
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_mr_alloc
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|to_mpd
argument_list|(
name|pd
argument_list|)
operator|->
name|pdn
argument_list|,
name|virt_addr
argument_list|,
name|length
argument_list|,
name|convert_access
argument_list|(
name|access_flags
argument_list|)
argument_list|,
name|n
argument_list|,
name|shift
argument_list|,
operator|&
name|mr
operator|->
name|mmr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_umem
goto|;
name|err
operator|=
name|mlx4_ib_umem_write_mtt
argument_list|(
name|dev
argument_list|,
operator|&
name|mr
operator|->
name|mmr
operator|.
name|mtt
argument_list|,
name|mr
operator|->
name|umem
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_mr
goto|;
name|err
operator|=
name|mlx4_mr_enable
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|mr
operator|->
name|mmr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_mr
goto|;
name|mr
operator|->
name|ibmr
operator|.
name|rkey
operator|=
name|mr
operator|->
name|ibmr
operator|.
name|lkey
operator|=
name|mr
operator|->
name|mmr
operator|.
name|key
expr_stmt|;
comment|/* No suuport for Shared MR */
if|#
directive|if
literal|0
comment|/* Check whether MR should be shared */
block|if (is_shared_mr(access_flags)) {
comment|/* start address and length must be aligned to page size in order 	    to map a full page and preventing leakage of data */
block|if (mr->umem->offset || (length& ~PAGE_MASK)) { 		        err = -EINVAL; 		        goto err_mr; 		}  		err = prepare_shared_mr(mr, access_flags, mr_id); 		if (err) 			goto err_mr; 	}
endif|#
directive|endif
if|if
condition|(
name|ib_peer_mem
condition|)
block|{
if|if
condition|(
name|access_flags
operator|&
name|IB_ACCESS_MW_BIND
condition|)
block|{
comment|/* Prevent binding MW on peer clients. 			* mlx4_invalidate_umem must be void, 			* therefore, mlx4_mr_free should not fail 			* when using peer clients. */
name|err
operator|=
operator|-
name|ENOSYS
expr_stmt|;
name|pr_err
argument_list|(
literal|"MW is not supported with peer memory client"
argument_list|)
expr_stmt|;
goto|goto
name|err_smr
goto|;
block|}
name|init_completion
argument_list|(
operator|&
name|mr
operator|->
name|invalidation_comp
argument_list|)
expr_stmt|;
name|ib_umem_activate_invalidation_notifier
argument_list|(
name|mr
operator|->
name|umem
argument_list|,
name|mlx4_invalidate_umem
argument_list|,
name|mr
argument_list|)
expr_stmt|;
block|}
name|atomic_set
argument_list|(
operator|&
name|mr
operator|->
name|invalidated
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|&
name|mr
operator|->
name|ibmr
return|;
name|err_smr
label|:
comment|/* No suuport for Shared MR */
if|#
directive|if
literal|0
block|if (mr->smr_info) 		free_smr_info(mr);
endif|#
directive|endif
name|err_mr
label|:
operator|(
name|void
operator|)
name|mlx4_mr_free
argument_list|(
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
operator|->
name|dev
argument_list|,
operator|&
name|mr
operator|->
name|mmr
argument_list|)
expr_stmt|;
name|err_umem
label|:
name|ib_umem_release
argument_list|(
name|mr
operator|->
name|umem
argument_list|)
expr_stmt|;
name|err_free
label|:
name|kfree
argument_list|(
name|mr
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_ib_dereg_mr
parameter_list|(
name|struct
name|ib_mr
modifier|*
name|ibmr
parameter_list|)
block|{
name|struct
name|mlx4_ib_mr
modifier|*
name|mr
init|=
name|to_mmr
argument_list|(
name|ibmr
argument_list|)
decl_stmt|;
name|struct
name|ib_umem
modifier|*
name|umem
init|=
name|mr
operator|->
name|umem
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* No suuport for Shared MR */
if|#
directive|if
literal|0
block|if (mr->smr_info) 		free_smr_info(mr);
endif|#
directive|endif
if|if
condition|(
name|atomic_inc_return
argument_list|(
operator|&
name|mr
operator|->
name|invalidated
argument_list|)
operator|>
literal|1
condition|)
block|{
name|wait_for_completion
argument_list|(
operator|&
name|mr
operator|->
name|invalidation_comp
argument_list|)
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|ret
operator|=
name|mlx4_mr_free
argument_list|(
name|to_mdev
argument_list|(
name|ibmr
operator|->
name|device
argument_list|)
operator|->
name|dev
argument_list|,
operator|&
name|mr
operator|->
name|mmr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Error is not expected here, except when memory windows 		* are bound to MR which is not supported with 		* peer memory clients */
name|atomic_set
argument_list|(
operator|&
name|mr
operator|->
name|invalidated
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
operator|!
name|umem
condition|)
goto|goto
name|end
goto|;
name|ib_umem_release
argument_list|(
name|mr
operator|->
name|umem
argument_list|)
expr_stmt|;
name|end
label|:
name|kfree
argument_list|(
name|mr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|ib_mw
modifier|*
name|mlx4_ib_alloc_mw
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|enum
name|ib_mw_type
name|type
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_mw
modifier|*
name|mw
decl_stmt|;
name|int
name|err
decl_stmt|;
name|mw
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mw
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mw
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|err
operator|=
name|mlx4_mw_alloc
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|to_mpd
argument_list|(
name|pd
argument_list|)
operator|->
name|pdn
argument_list|,
operator|(
expr|enum
name|mlx4_mw_type
operator|)
name|type
argument_list|,
operator|&
name|mw
operator|->
name|mmw
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_free
goto|;
name|err
operator|=
name|mlx4_mw_enable
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|mw
operator|->
name|mmw
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_mw
goto|;
name|mw
operator|->
name|ibmw
operator|.
name|rkey
operator|=
name|mw
operator|->
name|mmw
operator|.
name|key
expr_stmt|;
return|return
operator|&
name|mw
operator|->
name|ibmw
return|;
name|err_mw
label|:
name|mlx4_mw_free
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|mw
operator|->
name|mmw
argument_list|)
expr_stmt|;
name|err_free
label|:
name|kfree
argument_list|(
name|mw
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_ib_bind_mw
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_mw
modifier|*
name|mw
parameter_list|,
name|struct
name|ib_mw_bind
modifier|*
name|mw_bind
parameter_list|)
block|{
name|struct
name|ib_send_wr
name|wr
decl_stmt|;
name|struct
name|ib_send_wr
modifier|*
name|bad_wr
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|memset
argument_list|(
operator|&
name|wr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|wr
argument_list|)
argument_list|)
expr_stmt|;
name|wr
operator|.
name|opcode
operator|=
name|IB_WR_BIND_MW
expr_stmt|;
name|wr
operator|.
name|wr_id
operator|=
name|mw_bind
operator|->
name|wr_id
expr_stmt|;
name|wr
operator|.
name|send_flags
operator|=
name|mw_bind
operator|->
name|send_flags
expr_stmt|;
name|wr
operator|.
name|wr
operator|.
name|bind_mw
operator|.
name|mw
operator|=
name|mw
expr_stmt|;
name|wr
operator|.
name|wr
operator|.
name|bind_mw
operator|.
name|bind_info
operator|=
name|mw_bind
operator|->
name|bind_info
expr_stmt|;
name|wr
operator|.
name|wr
operator|.
name|bind_mw
operator|.
name|rkey
operator|=
name|ib_inc_rkey
argument_list|(
name|mw
operator|->
name|rkey
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mlx4_ib_post_send
argument_list|(
name|qp
argument_list|,
operator|&
name|wr
argument_list|,
operator|&
name|bad_wr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|mw
operator|->
name|rkey
operator|=
name|wr
operator|.
name|wr
operator|.
name|bind_mw
operator|.
name|rkey
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|int
name|mlx4_ib_dealloc_mw
parameter_list|(
name|struct
name|ib_mw
modifier|*
name|ibmw
parameter_list|)
block|{
name|struct
name|mlx4_ib_mw
modifier|*
name|mw
init|=
name|to_mmw
argument_list|(
name|ibmw
argument_list|)
decl_stmt|;
name|mlx4_mw_free
argument_list|(
name|to_mdev
argument_list|(
name|ibmw
operator|->
name|device
argument_list|)
operator|->
name|dev
argument_list|,
operator|&
name|mw
operator|->
name|mmw
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mw
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|ib_mr
modifier|*
name|mlx4_ib_alloc_fast_reg_mr
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|int
name|max_page_list_len
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_mr
modifier|*
name|mr
decl_stmt|;
name|int
name|err
decl_stmt|;
name|mr
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|mr
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mr
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|err
operator|=
name|mlx4_mr_alloc
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|to_mpd
argument_list|(
name|pd
argument_list|)
operator|->
name|pdn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|max_page_list_len
argument_list|,
literal|0
argument_list|,
operator|&
name|mr
operator|->
name|mmr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_free
goto|;
name|err
operator|=
name|mlx4_mr_enable
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|mr
operator|->
name|mmr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_mr
goto|;
name|mr
operator|->
name|ibmr
operator|.
name|rkey
operator|=
name|mr
operator|->
name|ibmr
operator|.
name|lkey
operator|=
name|mr
operator|->
name|mmr
operator|.
name|key
expr_stmt|;
name|mr
operator|->
name|umem
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|mr
operator|->
name|ibmr
return|;
name|err_mr
label|:
operator|(
name|void
operator|)
name|mlx4_mr_free
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|mr
operator|->
name|mmr
argument_list|)
expr_stmt|;
name|err_free
label|:
name|kfree
argument_list|(
name|mr
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|ib_fast_reg_page_list
modifier|*
name|mlx4_ib_alloc_fast_reg_page_list
parameter_list|(
name|struct
name|ib_device
modifier|*
name|ibdev
parameter_list|,
name|int
name|page_list_len
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ibdev
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_fast_reg_page_list
modifier|*
name|mfrpl
decl_stmt|;
name|int
name|size
init|=
name|page_list_len
operator|*
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
decl_stmt|;
if|if
condition|(
name|page_list_len
operator|>
name|MLX4_MAX_FAST_REG_PAGES
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|EINVAL
argument_list|)
return|;
name|mfrpl
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|mfrpl
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mfrpl
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|mfrpl
operator|->
name|ibfrpl
operator|.
name|page_list
operator|=
name|kmalloc
argument_list|(
name|size
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mfrpl
operator|->
name|ibfrpl
operator|.
name|page_list
condition|)
goto|goto
name|err_free
goto|;
name|mfrpl
operator|->
name|mapped_page_list
operator|=
name|dma_alloc_coherent
argument_list|(
operator|&
name|dev
operator|->
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|size
argument_list|,
operator|&
name|mfrpl
operator|->
name|map
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mfrpl
operator|->
name|mapped_page_list
condition|)
goto|goto
name|err_free
goto|;
name|WARN_ON
argument_list|(
name|mfrpl
operator|->
name|map
operator|&
literal|0x3f
argument_list|)
expr_stmt|;
return|return
operator|&
name|mfrpl
operator|->
name|ibfrpl
return|;
name|err_free
label|:
name|kfree
argument_list|(
name|mfrpl
operator|->
name|ibfrpl
operator|.
name|page_list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mfrpl
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|mlx4_ib_free_fast_reg_page_list
parameter_list|(
name|struct
name|ib_fast_reg_page_list
modifier|*
name|page_list
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|page_list
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_fast_reg_page_list
modifier|*
name|mfrpl
init|=
name|to_mfrpl
argument_list|(
name|page_list
argument_list|)
decl_stmt|;
name|int
name|size
init|=
name|page_list
operator|->
name|max_page_list_len
operator|*
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
decl_stmt|;
name|dma_free_coherent
argument_list|(
operator|&
name|dev
operator|->
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|size
argument_list|,
name|mfrpl
operator|->
name|mapped_page_list
argument_list|,
name|mfrpl
operator|->
name|map
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mfrpl
operator|->
name|ibfrpl
operator|.
name|page_list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mfrpl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ib_fmr
modifier|*
name|mlx4_ib_fmr_alloc
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|int
name|acc
parameter_list|,
name|struct
name|ib_fmr_attr
modifier|*
name|fmr_attr
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_fmr
modifier|*
name|fmr
decl_stmt|;
name|int
name|err
init|=
operator|-
name|ENOMEM
decl_stmt|;
name|fmr
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|fmr
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fmr
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|err
operator|=
name|mlx4_fmr_alloc
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|to_mpd
argument_list|(
name|pd
argument_list|)
operator|->
name|pdn
argument_list|,
name|convert_access
argument_list|(
name|acc
argument_list|)
argument_list|,
name|fmr_attr
operator|->
name|max_pages
argument_list|,
name|fmr_attr
operator|->
name|max_maps
argument_list|,
name|fmr_attr
operator|->
name|page_shift
argument_list|,
operator|&
name|fmr
operator|->
name|mfmr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_free
goto|;
name|err
operator|=
name|mlx4_fmr_enable
argument_list|(
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
operator|->
name|dev
argument_list|,
operator|&
name|fmr
operator|->
name|mfmr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_mr
goto|;
name|fmr
operator|->
name|ibfmr
operator|.
name|rkey
operator|=
name|fmr
operator|->
name|ibfmr
operator|.
name|lkey
operator|=
name|fmr
operator|->
name|mfmr
operator|.
name|mr
operator|.
name|key
expr_stmt|;
return|return
operator|&
name|fmr
operator|->
name|ibfmr
return|;
name|err_mr
label|:
operator|(
name|void
operator|)
name|mlx4_mr_free
argument_list|(
name|to_mdev
argument_list|(
name|pd
operator|->
name|device
argument_list|)
operator|->
name|dev
argument_list|,
operator|&
name|fmr
operator|->
name|mfmr
operator|.
name|mr
argument_list|)
expr_stmt|;
name|err_free
label|:
name|kfree
argument_list|(
name|fmr
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_ib_map_phys_fmr
parameter_list|(
name|struct
name|ib_fmr
modifier|*
name|ibfmr
parameter_list|,
name|u64
modifier|*
name|page_list
parameter_list|,
name|int
name|npages
parameter_list|,
name|u64
name|iova
parameter_list|)
block|{
name|struct
name|mlx4_ib_fmr
modifier|*
name|ifmr
init|=
name|to_mfmr
argument_list|(
name|ibfmr
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ifmr
operator|->
name|ibfmr
operator|.
name|device
argument_list|)
decl_stmt|;
return|return
name|mlx4_map_phys_fmr
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|ifmr
operator|->
name|mfmr
argument_list|,
name|page_list
argument_list|,
name|npages
argument_list|,
name|iova
argument_list|,
operator|&
name|ifmr
operator|->
name|ibfmr
operator|.
name|lkey
argument_list|,
operator|&
name|ifmr
operator|->
name|ibfmr
operator|.
name|rkey
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mlx4_ib_unmap_fmr
parameter_list|(
name|struct
name|list_head
modifier|*
name|fmr_list
parameter_list|)
block|{
name|struct
name|ib_fmr
modifier|*
name|ibfmr
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|mlx4_dev
modifier|*
name|mdev
init|=
name|NULL
decl_stmt|;
name|list_for_each_entry
argument_list|(
argument|ibfmr
argument_list|,
argument|fmr_list
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|mdev
operator|&&
name|to_mdev
argument_list|(
name|ibfmr
operator|->
name|device
argument_list|)
operator|->
name|dev
operator|!=
name|mdev
condition|)
return|return
operator|-
name|EINVAL
return|;
name|mdev
operator|=
name|to_mdev
argument_list|(
name|ibfmr
operator|->
name|device
argument_list|)
operator|->
name|dev
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mdev
condition|)
return|return
literal|0
return|;
name|list_for_each_entry
argument_list|(
argument|ibfmr
argument_list|,
argument|fmr_list
argument_list|,
argument|list
argument_list|)
block|{
name|struct
name|mlx4_ib_fmr
modifier|*
name|ifmr
init|=
name|to_mfmr
argument_list|(
name|ibfmr
argument_list|)
decl_stmt|;
name|mlx4_fmr_unmap
argument_list|(
name|mdev
argument_list|,
operator|&
name|ifmr
operator|->
name|mfmr
argument_list|,
operator|&
name|ifmr
operator|->
name|ibfmr
operator|.
name|lkey
argument_list|,
operator|&
name|ifmr
operator|->
name|ibfmr
operator|.
name|rkey
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Make sure all MPT status updates are visible before issuing 	 * SYNC_TPT firmware command. 	 */
name|wmb
argument_list|()
expr_stmt|;
name|err
operator|=
name|mlx4_SYNC_TPT
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|pr_warn
argument_list|(
literal|"SYNC_TPT error %d when "
literal|"unmapping FMRs\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mlx4_ib_fmr_dealloc
parameter_list|(
name|struct
name|ib_fmr
modifier|*
name|ibfmr
parameter_list|)
block|{
name|struct
name|mlx4_ib_fmr
modifier|*
name|ifmr
init|=
name|to_mfmr
argument_list|(
name|ibfmr
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ibfmr
operator|->
name|device
argument_list|)
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|mlx4_fmr_free
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|ifmr
operator|->
name|mfmr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|kfree
argument_list|(
name|ifmr
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

end_unit

