begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2007 Cisco Systems, Inc. All rights reserved.  * Copyright (c) 2007, 2008 Mellanox Technologies. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<linux/log2.h>
end_include

begin_include
include|#
directive|include
file|<linux/slab.h>
end_include

begin_include
include|#
directive|include
file|<linux/netdevice.h>
end_include

begin_include
include|#
directive|include
file|<linux/bitmap.h>
end_include

begin_include
include|#
directive|include
file|<linux/bitops.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_cache.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_pack.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_addr.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_mad.h>
end_include

begin_include
include|#
directive|include
file|<linux/mlx4/qp.h>
end_include

begin_include
include|#
directive|include
file|<linux/mlx4/driver.h>
end_include

begin_include
include|#
directive|include
file|<linux/io.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__linux__
end_ifndef

begin_define
define|#
directive|define
name|asm
value|__asm
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"mlx4_ib.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_enum
enum|enum
block|{
name|MLX4_IB_ACK_REQ_FREQ
init|=
literal|8
block|, }
enum|;
end_enum

begin_enum
enum|enum
block|{
name|MLX4_IB_DEFAULT_SCHED_QUEUE
init|=
literal|0x83
block|,
name|MLX4_IB_DEFAULT_QP0_SCHED_QUEUE
init|=
literal|0x3f
block|,
name|MLX4_IB_LINK_TYPE_IB
init|=
literal|0
block|,
name|MLX4_IB_LINK_TYPE_ETH
init|=
literal|1
block|}
enum|;
end_enum

begin_enum
enum|enum
block|{
comment|/* 	 * Largest possible UD header: send with GRH and immediate 	 * data plus 18 bytes for an Ethernet header with VLAN/802.1Q 	 * tag.  (LRH would only use 8 bytes, so Ethernet is the 	 * biggest case) 	 */
name|MLX4_IB_UD_HEADER_SIZE
init|=
literal|82
block|,
name|MLX4_IB_LSO_HEADER_SPARE
init|=
literal|128
block|, }
enum|;
end_enum

begin_enum
enum|enum
block|{
name|MLX4_IB_IBOE_ETHERTYPE
init|=
literal|0x8915
block|}
enum|;
end_enum

begin_struct
struct|struct
name|mlx4_ib_sqp
block|{
name|struct
name|mlx4_ib_qp
name|qp
decl_stmt|;
name|int
name|pkey_index
decl_stmt|;
name|u32
name|qkey
decl_stmt|;
name|u32
name|send_psn
decl_stmt|;
name|struct
name|ib_ud_header
name|ud_header
decl_stmt|;
name|u8
name|header_buf
index|[
name|MLX4_IB_UD_HEADER_SIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
block|{
name|MLX4_IB_MIN_SQ_STRIDE
init|=
literal|6
block|,
name|MLX4_IB_CACHE_LINE_SIZE
init|=
literal|64
block|, }
enum|;
end_enum

begin_enum
enum|enum
block|{
name|MLX4_RAW_QP_MTU
init|=
literal|7
block|,
name|MLX4_RAW_QP_MSGMAX
init|=
literal|31
block|, }
enum|;
end_enum

begin_decl_stmt
specifier|static
specifier|const
name|__be32
name|mlx4_ib_opcode
index|[]
init|=
block|{
index|[
name|IB_WR_SEND
index|]
operator|=
name|cpu_to_be32
argument_list|(
name|MLX4_OPCODE_SEND
argument_list|)
block|,
index|[
name|IB_WR_LSO
index|]
operator|=
name|cpu_to_be32
argument_list|(
name|MLX4_OPCODE_LSO
argument_list|)
block|,
index|[
name|IB_WR_SEND_WITH_IMM
index|]
operator|=
name|cpu_to_be32
argument_list|(
name|MLX4_OPCODE_SEND_IMM
argument_list|)
block|,
index|[
name|IB_WR_RDMA_WRITE
index|]
operator|=
name|cpu_to_be32
argument_list|(
name|MLX4_OPCODE_RDMA_WRITE
argument_list|)
block|,
index|[
name|IB_WR_RDMA_WRITE_WITH_IMM
index|]
operator|=
name|cpu_to_be32
argument_list|(
name|MLX4_OPCODE_RDMA_WRITE_IMM
argument_list|)
block|,
index|[
name|IB_WR_RDMA_READ
index|]
operator|=
name|cpu_to_be32
argument_list|(
name|MLX4_OPCODE_RDMA_READ
argument_list|)
block|,
index|[
name|IB_WR_ATOMIC_CMP_AND_SWP
index|]
operator|=
name|cpu_to_be32
argument_list|(
name|MLX4_OPCODE_ATOMIC_CS
argument_list|)
block|,
index|[
name|IB_WR_ATOMIC_FETCH_AND_ADD
index|]
operator|=
name|cpu_to_be32
argument_list|(
name|MLX4_OPCODE_ATOMIC_FA
argument_list|)
block|,
index|[
name|IB_WR_SEND_WITH_INV
index|]
operator|=
name|cpu_to_be32
argument_list|(
name|MLX4_OPCODE_SEND_INVAL
argument_list|)
block|,
index|[
name|IB_WR_LOCAL_INV
index|]
operator|=
name|cpu_to_be32
argument_list|(
name|MLX4_OPCODE_LOCAL_INVAL
argument_list|)
block|,
index|[
name|IB_WR_FAST_REG_MR
index|]
operator|=
name|cpu_to_be32
argument_list|(
name|MLX4_OPCODE_FMR
argument_list|)
block|,
index|[
name|IB_WR_MASKED_ATOMIC_CMP_AND_SWP
index|]
operator|=
name|cpu_to_be32
argument_list|(
name|MLX4_OPCODE_MASKED_ATOMIC_CS
argument_list|)
block|,
index|[
name|IB_WR_MASKED_ATOMIC_FETCH_AND_ADD
index|]
operator|=
name|cpu_to_be32
argument_list|(
name|MLX4_OPCODE_MASKED_ATOMIC_FA
argument_list|)
block|, }
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|wc_wmb
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_define
define|#
directive|define
name|wc_wmb
parameter_list|()
value|asm volatile("lock; addl $0,0(%%esp) " ::: "memory")
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__x86_64__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|wc_wmb
parameter_list|()
value|asm volatile("sfence" ::: "memory")
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__ia64__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|wc_wmb
parameter_list|()
value|asm volatile("fwb" ::: "memory")
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|wc_wmb
parameter_list|()
value|wmb()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|struct
name|mlx4_ib_sqp
modifier|*
name|to_msqp
parameter_list|(
name|struct
name|mlx4_ib_qp
modifier|*
name|mqp
parameter_list|)
block|{
return|return
name|container_of
argument_list|(
name|mqp
argument_list|,
expr|struct
name|mlx4_ib_sqp
argument_list|,
name|qp
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_tunnel_qp
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mlx4_is_master
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|qp
operator|->
name|mqp
operator|.
name|qpn
operator|>=
name|dev
operator|->
name|dev
operator|->
name|phys_caps
operator|.
name|base_tunnel_sqpn
operator|&&
name|qp
operator|->
name|mqp
operator|.
name|qpn
operator|<
name|dev
operator|->
name|dev
operator|->
name|phys_caps
operator|.
name|base_tunnel_sqpn
operator|+
literal|8
operator|*
name|MLX4_MFUNC_MAX
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_sqp
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|)
block|{
name|int
name|proxy_sqp
init|=
literal|0
decl_stmt|;
name|int
name|real_sqp
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* PPF or Native -- real SQP */
name|real_sqp
operator|=
operator|(
operator|(
name|mlx4_is_master
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
operator|||
operator|!
name|mlx4_is_mfunc
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
operator|)
operator|&&
name|qp
operator|->
name|mqp
operator|.
name|qpn
operator|>=
name|dev
operator|->
name|dev
operator|->
name|phys_caps
operator|.
name|base_sqpn
operator|&&
name|qp
operator|->
name|mqp
operator|.
name|qpn
operator|<=
name|dev
operator|->
name|dev
operator|->
name|phys_caps
operator|.
name|base_sqpn
operator|+
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|real_sqp
condition|)
return|return
literal|1
return|;
comment|/* VF or PF -- proxy SQP */
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qp
operator|->
name|mqp
operator|.
name|qpn
operator|==
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
index|[
name|i
index|]
operator|||
name|qp
operator|->
name|mqp
operator|.
name|qpn
operator|==
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
index|[
name|i
index|]
condition|)
block|{
name|proxy_sqp
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|proxy_sqp
return|;
block|}
end_function

begin_comment
comment|/* used for INIT/CLOSE port logic */
end_comment

begin_function
specifier|static
name|int
name|is_qp0
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|)
block|{
name|int
name|proxy_qp0
init|=
literal|0
decl_stmt|;
name|int
name|real_qp0
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* PPF or Native -- real QP0 */
name|real_qp0
operator|=
operator|(
operator|(
name|mlx4_is_master
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
operator|||
operator|!
name|mlx4_is_mfunc
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
operator|)
operator|&&
name|qp
operator|->
name|mqp
operator|.
name|qpn
operator|>=
name|dev
operator|->
name|dev
operator|->
name|phys_caps
operator|.
name|base_sqpn
operator|&&
name|qp
operator|->
name|mqp
operator|.
name|qpn
operator|<=
name|dev
operator|->
name|dev
operator|->
name|phys_caps
operator|.
name|base_sqpn
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|real_qp0
condition|)
return|return
literal|1
return|;
comment|/* VF or PF -- proxy QP0 */
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qp
operator|->
name|mqp
operator|.
name|qpn
operator|==
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
index|[
name|i
index|]
condition|)
block|{
name|proxy_qp0
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
name|proxy_qp0
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|get_wqe
parameter_list|(
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
return|return
name|mlx4_buf_offset
argument_list|(
operator|&
name|qp
operator|->
name|buf
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|get_recv_wqe
parameter_list|(
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
name|get_wqe
argument_list|(
name|qp
argument_list|,
name|qp
operator|->
name|rq
operator|.
name|offset
operator|+
operator|(
name|n
operator|<<
name|qp
operator|->
name|rq
operator|.
name|wqe_shift
operator|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|get_send_wqe
parameter_list|(
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|,
name|int
name|n
parameter_list|)
block|{
return|return
name|get_wqe
argument_list|(
name|qp
argument_list|,
name|qp
operator|->
name|sq
operator|.
name|offset
operator|+
operator|(
name|n
operator|<<
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Stamp a SQ WQE so that it is invalid if prefetched by marking the  * first four bytes of every 64 byte chunk with  *     0x7FFFFFF | (invalid_ownership_value<< 31).  *  * When the max work request size is less than or equal to the WQE  * basic block size, as an optimization, we can stamp all WQEs with  * 0xffffffff, and skip the very first chunk of each WQE.  */
end_comment

begin_function
specifier|static
name|void
name|stamp_send_wqe
parameter_list|(
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|__be32
modifier|*
name|wqe
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|ind
decl_stmt|;
name|void
modifier|*
name|buf
decl_stmt|;
name|__be32
name|stamp
decl_stmt|;
name|struct
name|mlx4_wqe_ctrl_seg
modifier|*
name|ctrl
decl_stmt|;
if|if
condition|(
name|qp
operator|->
name|sq_max_wqes_per_wr
operator|>
literal|1
condition|)
block|{
name|s
operator|=
name|roundup
argument_list|(
name|size
argument_list|,
literal|1U
operator|<<
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s
condition|;
name|i
operator|+=
literal|64
control|)
block|{
name|ind
operator|=
operator|(
name|i
operator|>>
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|)
operator|+
name|n
expr_stmt|;
name|stamp
operator|=
name|ind
operator|&
name|qp
operator|->
name|sq
operator|.
name|wqe_cnt
condition|?
name|cpu_to_be32
argument_list|(
literal|0x7fffffff
argument_list|)
else|:
name|cpu_to_be32
argument_list|(
literal|0xffffffff
argument_list|)
expr_stmt|;
name|buf
operator|=
name|get_send_wqe
argument_list|(
name|qp
argument_list|,
name|ind
operator|&
operator|(
name|qp
operator|->
name|sq
operator|.
name|wqe_cnt
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|wqe
operator|=
name|buf
operator|+
operator|(
name|i
operator|&
operator|(
operator|(
literal|1
operator|<<
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
operator|*
name|wqe
operator|=
name|stamp
expr_stmt|;
block|}
block|}
else|else
block|{
name|ctrl
operator|=
name|buf
operator|=
name|get_send_wqe
argument_list|(
name|qp
argument_list|,
name|n
operator|&
operator|(
name|qp
operator|->
name|sq
operator|.
name|wqe_cnt
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|ctrl
operator|->
name|fence_size
operator|&
literal|0x3f
operator|)
operator|<<
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|64
init|;
name|i
operator|<
name|s
condition|;
name|i
operator|+=
literal|64
control|)
block|{
name|wqe
operator|=
name|buf
operator|+
name|i
expr_stmt|;
operator|*
name|wqe
operator|=
name|cpu_to_be32
argument_list|(
literal|0xffffffff
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|post_nop_wqe
parameter_list|(
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|mlx4_wqe_ctrl_seg
modifier|*
name|ctrl
decl_stmt|;
name|struct
name|mlx4_wqe_inline_seg
modifier|*
name|inl
decl_stmt|;
name|void
modifier|*
name|wqe
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ctrl
operator|=
name|wqe
operator|=
name|get_send_wqe
argument_list|(
name|qp
argument_list|,
name|n
operator|&
operator|(
name|qp
operator|->
name|sq
operator|.
name|wqe_cnt
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_ctrl_seg
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|ibqp
operator|.
name|qp_type
operator|==
name|IB_QPT_UD
condition|)
block|{
name|struct
name|mlx4_wqe_datagram_seg
modifier|*
name|dgram
init|=
name|wqe
operator|+
sizeof|sizeof
expr|*
name|ctrl
decl_stmt|;
name|struct
name|mlx4_av
modifier|*
name|av
init|=
operator|(
expr|struct
name|mlx4_av
operator|*
operator|)
name|dgram
operator|->
name|av
decl_stmt|;
name|memset
argument_list|(
name|dgram
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|dgram
argument_list|)
expr_stmt|;
name|av
operator|->
name|port_pd
operator|=
name|cpu_to_be32
argument_list|(
operator|(
name|qp
operator|->
name|port
operator|<<
literal|24
operator|)
operator||
name|to_mpd
argument_list|(
name|qp
operator|->
name|ibqp
operator|.
name|pd
argument_list|)
operator|->
name|pdn
argument_list|)
expr_stmt|;
name|s
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_datagram_seg
argument_list|)
expr_stmt|;
block|}
comment|/* Pad the remainder of the WQE with an inline data segment. */
if|if
condition|(
name|size
operator|>
name|s
condition|)
block|{
name|inl
operator|=
name|wqe
operator|+
name|s
expr_stmt|;
name|inl
operator|->
name|byte_count
operator|=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|31
operator||
operator|(
name|size
operator|-
name|s
operator|-
sizeof|sizeof
expr|*
name|inl
operator|)
argument_list|)
expr_stmt|;
block|}
name|ctrl
operator|->
name|srcrb_flags
operator|=
literal|0
expr_stmt|;
name|ctrl
operator|->
name|fence_size
operator|=
name|size
operator|/
literal|16
expr_stmt|;
comment|/* 	 * Make sure descriptor is fully written before setting ownership bit 	 * (because HW can start executing as soon as we do). 	 */
name|wmb
argument_list|()
expr_stmt|;
name|ctrl
operator|->
name|owner_opcode
operator|=
name|cpu_to_be32
argument_list|(
name|MLX4_OPCODE_NOP
operator||
name|MLX4_WQE_CTRL_NEC
argument_list|)
operator||
operator|(
name|n
operator|&
name|qp
operator|->
name|sq
operator|.
name|wqe_cnt
condition|?
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|31
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|stamp_send_wqe
argument_list|(
name|qp
argument_list|,
name|n
operator|+
name|qp
operator|->
name|sq_spare_wqes
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Post NOP WQE to prevent wrap-around in the middle of WR */
end_comment

begin_function
specifier|static
specifier|inline
name|unsigned
name|pad_wraparound
parameter_list|(
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|,
name|int
name|ind
parameter_list|)
block|{
name|unsigned
name|s
init|=
name|qp
operator|->
name|sq
operator|.
name|wqe_cnt
operator|-
operator|(
name|ind
operator|&
operator|(
name|qp
operator|->
name|sq
operator|.
name|wqe_cnt
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|s
operator|<
name|qp
operator|->
name|sq_max_wqes_per_wr
argument_list|)
condition|)
block|{
name|post_nop_wqe
argument_list|(
name|qp
argument_list|,
name|ind
argument_list|,
name|s
operator|<<
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
argument_list|)
expr_stmt|;
name|ind
operator|+=
name|s
expr_stmt|;
block|}
return|return
name|ind
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_ib_qp_event
parameter_list|(
name|struct
name|mlx4_qp
modifier|*
name|qp
parameter_list|,
name|enum
name|mlx4_event
name|type
parameter_list|)
block|{
name|struct
name|ib_event
name|event
decl_stmt|;
name|struct
name|ib_qp
modifier|*
name|ibqp
init|=
operator|&
name|to_mibqp
argument_list|(
name|qp
argument_list|)
operator|->
name|ibqp
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|MLX4_EVENT_TYPE_PATH_MIG
condition|)
name|to_mibqp
argument_list|(
name|qp
argument_list|)
operator|->
name|port
operator|=
name|to_mibqp
argument_list|(
name|qp
argument_list|)
operator|->
name|alt_port
expr_stmt|;
if|if
condition|(
name|ibqp
operator|->
name|event_handler
condition|)
block|{
name|event
operator|.
name|device
operator|=
name|ibqp
operator|->
name|device
expr_stmt|;
name|event
operator|.
name|element
operator|.
name|qp
operator|=
name|ibqp
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MLX4_EVENT_TYPE_PATH_MIG
case|:
name|event
operator|.
name|event
operator|=
name|IB_EVENT_PATH_MIG
expr_stmt|;
break|break;
case|case
name|MLX4_EVENT_TYPE_COMM_EST
case|:
name|event
operator|.
name|event
operator|=
name|IB_EVENT_COMM_EST
expr_stmt|;
break|break;
case|case
name|MLX4_EVENT_TYPE_SQ_DRAINED
case|:
name|event
operator|.
name|event
operator|=
name|IB_EVENT_SQ_DRAINED
expr_stmt|;
break|break;
case|case
name|MLX4_EVENT_TYPE_SRQ_QP_LAST_WQE
case|:
name|event
operator|.
name|event
operator|=
name|IB_EVENT_QP_LAST_WQE_REACHED
expr_stmt|;
break|break;
case|case
name|MLX4_EVENT_TYPE_WQ_CATAS_ERROR
case|:
name|event
operator|.
name|event
operator|=
name|IB_EVENT_QP_FATAL
expr_stmt|;
break|break;
case|case
name|MLX4_EVENT_TYPE_PATH_MIG_FAILED
case|:
name|event
operator|.
name|event
operator|=
name|IB_EVENT_PATH_MIG_ERR
expr_stmt|;
break|break;
case|case
name|MLX4_EVENT_TYPE_WQ_INVAL_REQ_ERROR
case|:
name|event
operator|.
name|event
operator|=
name|IB_EVENT_QP_REQ_ERR
expr_stmt|;
break|break;
case|case
name|MLX4_EVENT_TYPE_WQ_ACCESS_ERROR
case|:
name|event
operator|.
name|event
operator|=
name|IB_EVENT_QP_ACCESS_ERR
expr_stmt|;
break|break;
default|default:
name|pr_warn
argument_list|(
literal|"Unexpected event type %d "
literal|"on QP %06x\n"
argument_list|,
name|type
argument_list|,
name|qp
operator|->
name|qpn
argument_list|)
expr_stmt|;
return|return;
block|}
name|ibqp
operator|->
name|event_handler
argument_list|(
operator|&
name|event
argument_list|,
name|ibqp
operator|->
name|qp_context
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|send_wqe_overhead
parameter_list|(
name|enum
name|mlx4_ib_qp_type
name|type
parameter_list|,
name|u32
name|flags
parameter_list|)
block|{
comment|/* 	 * UD WQEs must have a datagram segment. 	 * RC and UC WQEs might have a remote address segment. 	 * MLX WQEs need two extra inline data segments (for the UD 	 * header and space for the ICRC). 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MLX4_IB_QPT_UD
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_ctrl_seg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_datagram_seg
argument_list|)
operator|+
operator|(
operator|(
name|flags
operator|&
name|MLX4_IB_QP_LSO
operator|)
condition|?
name|MLX4_IB_LSO_HEADER_SPARE
else|:
literal|0
operator|)
return|;
case|case
name|MLX4_IB_QPT_PROXY_SMI_OWNER
case|:
case|case
name|MLX4_IB_QPT_PROXY_SMI
case|:
case|case
name|MLX4_IB_QPT_PROXY_GSI
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_ctrl_seg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_datagram_seg
argument_list|)
operator|+
literal|64
return|;
case|case
name|MLX4_IB_QPT_TUN_SMI_OWNER
case|:
case|case
name|MLX4_IB_QPT_TUN_GSI
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_ctrl_seg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_datagram_seg
argument_list|)
return|;
case|case
name|MLX4_IB_QPT_UC
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_ctrl_seg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_raddr_seg
argument_list|)
return|;
case|case
name|MLX4_IB_QPT_RC
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_ctrl_seg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_masked_atomic_seg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_raddr_seg
argument_list|)
return|;
case|case
name|MLX4_IB_QPT_SMI
case|:
case|case
name|MLX4_IB_QPT_GSI
case|:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_ctrl_seg
argument_list|)
operator|+
name|ALIGN
argument_list|(
name|MLX4_IB_UD_HEADER_SIZE
operator|+
name|DIV_ROUND_UP
argument_list|(
name|MLX4_IB_UD_HEADER_SIZE
argument_list|,
name|MLX4_INLINE_ALIGN
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_inline_seg
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_data_seg
argument_list|)
argument_list|)
operator|+
name|ALIGN
argument_list|(
literal|4
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_inline_seg
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_data_seg
argument_list|)
argument_list|)
return|;
default|default:
return|return
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_ctrl_seg
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|set_rq_size
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|ib_qp_cap
modifier|*
name|cap
parameter_list|,
name|int
name|is_user
parameter_list|,
name|int
name|has_rq
parameter_list|,
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|)
block|{
comment|/* Sanity check RQ size before proceeding */
if|if
condition|(
name|cap
operator|->
name|max_recv_wr
operator|>
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_wqes
operator|-
name|MLX4_IB_SQ_MAX_SPARE
operator|||
name|cap
operator|->
name|max_recv_sge
operator|>
name|min
argument_list|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_sq_sg
argument_list|,
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_rq_sg
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
name|has_rq
condition|)
block|{
if|if
condition|(
name|cap
operator|->
name|max_recv_wr
condition|)
return|return
operator|-
name|EINVAL
return|;
name|qp
operator|->
name|rq
operator|.
name|wqe_cnt
operator|=
name|qp
operator|->
name|rq
operator|.
name|max_gs
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* HW requires>= 1 RQ entry with>= 1 gather entry */
if|if
condition|(
name|is_user
operator|&&
operator|(
operator|!
name|cap
operator|->
name|max_recv_wr
operator|||
operator|!
name|cap
operator|->
name|max_recv_sge
operator|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|qp
operator|->
name|rq
operator|.
name|wqe_cnt
operator|=
name|roundup_pow_of_two
argument_list|(
name|max
argument_list|(
literal|1U
argument_list|,
name|cap
operator|->
name|max_recv_wr
argument_list|)
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rq
operator|.
name|max_gs
operator|=
name|roundup_pow_of_two
argument_list|(
name|max
argument_list|(
literal|1U
argument_list|,
name|cap
operator|->
name|max_recv_sge
argument_list|)
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rq
operator|.
name|wqe_shift
operator|=
name|ilog2
argument_list|(
name|qp
operator|->
name|rq
operator|.
name|max_gs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_data_seg
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* leave userspace return values as they were, so as not to break ABI */
if|if
condition|(
name|is_user
condition|)
block|{
name|cap
operator|->
name|max_recv_wr
operator|=
name|qp
operator|->
name|rq
operator|.
name|max_post
operator|=
name|qp
operator|->
name|rq
operator|.
name|wqe_cnt
expr_stmt|;
name|cap
operator|->
name|max_recv_sge
operator|=
name|qp
operator|->
name|rq
operator|.
name|max_gs
expr_stmt|;
block|}
else|else
block|{
name|cap
operator|->
name|max_recv_wr
operator|=
name|qp
operator|->
name|rq
operator|.
name|max_post
operator|=
name|min
argument_list|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_wqes
operator|-
name|MLX4_IB_SQ_MAX_SPARE
argument_list|,
name|qp
operator|->
name|rq
operator|.
name|wqe_cnt
argument_list|)
expr_stmt|;
name|cap
operator|->
name|max_recv_sge
operator|=
name|min
argument_list|(
name|qp
operator|->
name|rq
operator|.
name|max_gs
argument_list|,
name|min
argument_list|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_sq_sg
argument_list|,
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_rq_sg
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_kernel_sq_size
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|ib_qp_cap
modifier|*
name|cap
parameter_list|,
name|enum
name|mlx4_ib_qp_type
name|type
parameter_list|,
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
comment|/* Sanity check SQ size before proceeding */
if|if
condition|(
name|cap
operator|->
name|max_send_wr
operator|>
operator|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_wqes
operator|-
name|MLX4_IB_SQ_MAX_SPARE
operator|)
operator|||
name|cap
operator|->
name|max_send_sge
operator|>
name|min
argument_list|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_sq_sg
argument_list|,
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_rq_sg
argument_list|)
operator|||
name|cap
operator|->
name|max_inline_data
operator|+
name|send_wqe_overhead
argument_list|(
name|type
argument_list|,
name|qp
operator|->
name|flags
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_inline_seg
argument_list|)
operator|>
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_sq_desc_sz
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* 	 * For MLX transport we need 2 extra S/G entries: 	 * one for the header and one for the checksum at the end 	 */
if|if
condition|(
operator|(
name|type
operator|==
name|MLX4_IB_QPT_SMI
operator|||
name|type
operator|==
name|MLX4_IB_QPT_GSI
operator|||
name|type
operator|&
operator|(
name|MLX4_IB_QPT_PROXY_SMI_OWNER
operator||
name|MLX4_IB_QPT_TUN_SMI_OWNER
operator|)
operator|)
operator|&&
name|cap
operator|->
name|max_send_sge
operator|+
literal|2
operator|>
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_sq_sg
condition|)
return|return
operator|-
name|EINVAL
return|;
name|s
operator|=
name|max
argument_list|(
name|cap
operator|->
name|max_send_sge
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_data_seg
argument_list|)
argument_list|,
name|cap
operator|->
name|max_inline_data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_inline_seg
argument_list|)
argument_list|)
operator|+
name|send_wqe_overhead
argument_list|(
name|type
argument_list|,
name|qp
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_sq_desc_sz
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* 	 * Hermon supports shrinking WQEs, such that a single work 	 * request can include multiple units of 1<< wqe_shift.  This 	 * way, work requests can differ in size, and do not have to 	 * be a power of 2 in size, saving memory and speeding up send 	 * WR posting.  Unfortunately, if we do this then the 	 * wqe_index field in CQEs can't be used to look up the WR ID 	 * anymore, so we do this only if selective signaling is off. 	 * 	 * Further, on 32-bit platforms, we can't use vmap() to make 	 * the QP buffer virtually contiguous.  Thus we have to use 	 * constant-sized WRs to make sure a WR is always fully within 	 * a single page-sized chunk. 	 * 	 * Finally, we use NOP work requests to pad the end of the 	 * work queue, to avoid wrap-around in the middle of WR.  We 	 * set NEC bit to avoid getting completions with error for 	 * these NOP WRs, but since NEC is only supported starting 	 * with firmware 2.2.232, we use constant-sized WRs for older 	 * firmware. 	 * 	 * And, since MLX QPs only support SEND, we use constant-sized 	 * WRs in this case. 	 * 	 * We look for the smallest value of wqe_shift such that the 	 * resulting number of wqes does not exceed device 	 * capabilities. 	 * 	 * We set WQE size to at least 64 bytes, this way stamping 	 * invalidates each WQE. 	 */
if|if
condition|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|fw_ver
operator|>=
name|MLX4_FW_VER_WQE_CTRL_NEC
operator|&&
name|qp
operator|->
name|sq_signal_bits
operator|&&
name|BITS_PER_LONG
operator|==
literal|64
operator|&&
name|type
operator|!=
name|MLX4_IB_QPT_SMI
operator|&&
name|type
operator|!=
name|MLX4_IB_QPT_GSI
operator|&&
operator|!
operator|(
name|type
operator|&
operator|(
name|MLX4_IB_QPT_PROXY_SMI_OWNER
operator||
name|MLX4_IB_QPT_PROXY_SMI
operator||
name|MLX4_IB_QPT_PROXY_GSI
operator||
name|MLX4_IB_QPT_TUN_SMI_OWNER
operator|)
operator|)
condition|)
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|=
name|ilog2
argument_list|(
literal|64
argument_list|)
expr_stmt|;
else|else
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|=
name|ilog2
argument_list|(
name|roundup_pow_of_two
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|qp
operator|->
name|sq_max_wqes_per_wr
operator|=
name|DIV_ROUND_UP
argument_list|(
name|s
argument_list|,
literal|1U
operator|<<
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
argument_list|)
expr_stmt|;
comment|/* 		 * We need to leave 2 KB + 1 WR of headroom in the SQ to 		 * allow HW to prefetch. 		 */
name|qp
operator|->
name|sq_spare_wqes
operator|=
operator|(
literal|2048
operator|>>
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|)
operator|+
name|qp
operator|->
name|sq_max_wqes_per_wr
expr_stmt|;
name|qp
operator|->
name|sq
operator|.
name|wqe_cnt
operator|=
name|roundup_pow_of_two
argument_list|(
name|cap
operator|->
name|max_send_wr
operator|*
name|qp
operator|->
name|sq_max_wqes_per_wr
operator|+
name|qp
operator|->
name|sq_spare_wqes
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|sq
operator|.
name|wqe_cnt
operator|<=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_wqes
condition|)
break|break;
if|if
condition|(
name|qp
operator|->
name|sq_max_wqes_per_wr
operator|<=
literal|1
condition|)
return|return
operator|-
name|EINVAL
return|;
operator|++
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
expr_stmt|;
block|}
name|qp
operator|->
name|sq
operator|.
name|max_gs
operator|=
operator|(
name|min
argument_list|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_sq_desc_sz
argument_list|,
operator|(
name|qp
operator|->
name|sq_max_wqes_per_wr
operator|<<
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|)
argument_list|)
operator|-
name|send_wqe_overhead
argument_list|(
name|type
argument_list|,
name|qp
operator|->
name|flags
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_data_seg
argument_list|)
expr_stmt|;
name|qp
operator|->
name|buf_size
operator|=
operator|(
name|qp
operator|->
name|rq
operator|.
name|wqe_cnt
operator|<<
name|qp
operator|->
name|rq
operator|.
name|wqe_shift
operator|)
operator|+
operator|(
name|qp
operator|->
name|sq
operator|.
name|wqe_cnt
operator|<<
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|rq
operator|.
name|wqe_shift
operator|>
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
condition|)
block|{
name|qp
operator|->
name|rq
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|sq
operator|.
name|offset
operator|=
name|qp
operator|->
name|rq
operator|.
name|wqe_cnt
operator|<<
name|qp
operator|->
name|rq
operator|.
name|wqe_shift
expr_stmt|;
block|}
else|else
block|{
name|qp
operator|->
name|rq
operator|.
name|offset
operator|=
name|qp
operator|->
name|sq
operator|.
name|wqe_cnt
operator|<<
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
expr_stmt|;
name|qp
operator|->
name|sq
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
block|}
name|cap
operator|->
name|max_send_wr
operator|=
name|qp
operator|->
name|sq
operator|.
name|max_post
operator|=
operator|(
name|qp
operator|->
name|sq
operator|.
name|wqe_cnt
operator|-
name|qp
operator|->
name|sq_spare_wqes
operator|)
operator|/
name|qp
operator|->
name|sq_max_wqes_per_wr
expr_stmt|;
name|cap
operator|->
name|max_send_sge
operator|=
name|min
argument_list|(
name|qp
operator|->
name|sq
operator|.
name|max_gs
argument_list|,
name|min
argument_list|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_sq_sg
argument_list|,
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_rq_sg
argument_list|)
argument_list|)
expr_stmt|;
name|qp
operator|->
name|max_inline_data
operator|=
name|cap
operator|->
name|max_inline_data
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_user_sq_size
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|mlx4_ib_create_qp
modifier|*
name|ucmd
parameter_list|)
block|{
comment|/* Sanity check SQ size before proceeding */
if|if
condition|(
operator|(
literal|1
operator|<<
name|ucmd
operator|->
name|log_sq_bb_count
operator|)
operator|>
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_wqes
operator|||
name|ucmd
operator|->
name|log_sq_stride
operator|>
name|ilog2
argument_list|(
name|roundup_pow_of_two
argument_list|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_sq_desc_sz
argument_list|)
argument_list|)
operator|||
name|ucmd
operator|->
name|log_sq_stride
operator|<
name|MLX4_IB_MIN_SQ_STRIDE
condition|)
return|return
operator|-
name|EINVAL
return|;
name|qp
operator|->
name|sq
operator|.
name|wqe_cnt
operator|=
literal|1
operator|<<
name|ucmd
operator|->
name|log_sq_bb_count
expr_stmt|;
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|=
name|ucmd
operator|->
name|log_sq_stride
expr_stmt|;
name|qp
operator|->
name|buf_size
operator|=
operator|(
name|qp
operator|->
name|rq
operator|.
name|wqe_cnt
operator|<<
name|qp
operator|->
name|rq
operator|.
name|wqe_shift
operator|)
operator|+
operator|(
name|qp
operator|->
name|sq
operator|.
name|wqe_cnt
operator|<<
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_proxy_bufs
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|qp
operator|->
name|sqp_proxy_rcv
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_ib_buf
argument_list|)
operator|*
name|qp
operator|->
name|rq
operator|.
name|wqe_cnt
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qp
operator|->
name|sqp_proxy_rcv
condition|)
return|return
operator|-
name|ENOMEM
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp
operator|->
name|rq
operator|.
name|wqe_cnt
condition|;
name|i
operator|++
control|)
block|{
name|qp
operator|->
name|sqp_proxy_rcv
index|[
name|i
index|]
operator|.
name|addr
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_ib_proxy_sqp_hdr
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qp
operator|->
name|sqp_proxy_rcv
index|[
name|i
index|]
operator|.
name|addr
condition|)
goto|goto
name|err
goto|;
name|qp
operator|->
name|sqp_proxy_rcv
index|[
name|i
index|]
operator|.
name|map
operator|=
name|ib_dma_map_single
argument_list|(
name|dev
argument_list|,
name|qp
operator|->
name|sqp_proxy_rcv
index|[
name|i
index|]
operator|.
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_ib_proxy_sqp_hdr
argument_list|)
argument_list|,
name|DMA_FROM_DEVICE
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|err
label|:
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
operator|--
name|i
expr_stmt|;
name|ib_dma_unmap_single
argument_list|(
name|dev
argument_list|,
name|qp
operator|->
name|sqp_proxy_rcv
index|[
name|i
index|]
operator|.
name|map
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_ib_proxy_sqp_hdr
argument_list|)
argument_list|,
name|DMA_FROM_DEVICE
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|qp
operator|->
name|sqp_proxy_rcv
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
block|}
name|kfree
argument_list|(
name|qp
operator|->
name|sqp_proxy_rcv
argument_list|)
expr_stmt|;
name|qp
operator|->
name|sqp_proxy_rcv
operator|=
name|NULL
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_proxy_bufs
parameter_list|(
name|struct
name|ib_device
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp
operator|->
name|rq
operator|.
name|wqe_cnt
condition|;
name|i
operator|++
control|)
block|{
name|ib_dma_unmap_single
argument_list|(
name|dev
argument_list|,
name|qp
operator|->
name|sqp_proxy_rcv
index|[
name|i
index|]
operator|.
name|map
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_ib_proxy_sqp_hdr
argument_list|)
argument_list|,
name|DMA_FROM_DEVICE
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|qp
operator|->
name|sqp_proxy_rcv
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
block|}
name|kfree
argument_list|(
name|qp
operator|->
name|sqp_proxy_rcv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|qp_has_rq
parameter_list|(
name|struct
name|ib_qp_init_attr
modifier|*
name|attr
parameter_list|)
block|{
if|if
condition|(
name|attr
operator|->
name|qp_type
operator|==
name|IB_QPT_XRC_INI
operator|||
name|attr
operator|->
name|qp_type
operator|==
name|IB_QPT_XRC_TGT
condition|)
return|return
literal|0
return|;
return|return
operator|!
name|attr
operator|->
name|srq
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_qpg_parent
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_ib_qp
modifier|*
name|pqp
parameter_list|,
name|struct
name|ib_qp_init_attr
modifier|*
name|attr
parameter_list|,
name|int
modifier|*
name|qpn
parameter_list|)
block|{
name|struct
name|mlx4_ib_qpg_data
modifier|*
name|qpg_data
decl_stmt|;
name|int
name|tss_num
decl_stmt|,
name|rss_num
decl_stmt|;
name|int
name|tss_align_num
decl_stmt|,
name|rss_align_num
decl_stmt|;
name|int
name|tss_base
decl_stmt|,
name|rss_base
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* Parent is part of the TSS range (in SW TSS ARP is sent via parent) */
name|tss_num
operator|=
literal|1
operator|+
name|attr
operator|->
name|parent_attrib
operator|.
name|tss_child_count
expr_stmt|;
name|tss_align_num
operator|=
name|roundup_pow_of_two
argument_list|(
name|tss_num
argument_list|)
expr_stmt|;
name|rss_num
operator|=
name|attr
operator|->
name|parent_attrib
operator|.
name|rss_child_count
expr_stmt|;
name|rss_align_num
operator|=
name|roundup_pow_of_two
argument_list|(
name|rss_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|rss_num
operator|>
literal|1
condition|)
block|{
comment|/* RSS is requested */
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_RSS
operator|)
condition|)
return|return
operator|-
name|ENOSYS
return|;
if|if
condition|(
name|rss_align_num
operator|>
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_rss_tbl_sz
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* We must work with power of two */
name|attr
operator|->
name|parent_attrib
operator|.
name|rss_child_count
operator|=
name|rss_align_num
expr_stmt|;
block|}
name|qpg_data
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|qpg_data
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qpg_data
condition|)
return|return
operator|-
name|ENOMEM
return|;
if|if
condition|(
name|pqp
operator|->
name|flags
operator|&
name|MLX4_IB_QP_NETIF
condition|)
name|err
operator|=
name|mlx4_ib_steer_qp_alloc
argument_list|(
name|dev
argument_list|,
name|tss_align_num
argument_list|,
operator|&
name|tss_base
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|mlx4_qp_reserve_range
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|tss_align_num
argument_list|,
name|tss_align_num
argument_list|,
operator|&
name|tss_base
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err1
goto|;
if|if
condition|(
name|tss_num
operator|>
literal|1
condition|)
block|{
name|u32
name|alloc
init|=
name|BITS_TO_LONGS
argument_list|(
name|tss_align_num
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
decl_stmt|;
name|qpg_data
operator|->
name|tss_bitmap
operator|=
name|kzalloc
argument_list|(
name|alloc
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|qpg_data
operator|->
name|tss_bitmap
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
name|bitmap_fill
argument_list|(
name|qpg_data
operator|->
name|tss_bitmap
argument_list|,
name|tss_num
argument_list|)
expr_stmt|;
comment|/* Note parent takes first index */
name|clear_bit
argument_list|(
literal|0
argument_list|,
name|qpg_data
operator|->
name|tss_bitmap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rss_num
operator|>
literal|1
condition|)
block|{
name|u32
name|alloc
init|=
name|BITS_TO_LONGS
argument_list|(
name|rss_align_num
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
decl_stmt|;
name|err
operator|=
name|mlx4_qp_reserve_range
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|rss_align_num
argument_list|,
literal|1
argument_list|,
operator|&
name|rss_base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err3
goto|;
name|qpg_data
operator|->
name|rss_bitmap
operator|=
name|kzalloc
argument_list|(
name|alloc
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|qpg_data
operator|->
name|rss_bitmap
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err4
goto|;
block|}
name|bitmap_fill
argument_list|(
name|qpg_data
operator|->
name|rss_bitmap
argument_list|,
name|rss_align_num
argument_list|)
expr_stmt|;
block|}
name|qpg_data
operator|->
name|tss_child_count
operator|=
name|attr
operator|->
name|parent_attrib
operator|.
name|tss_child_count
expr_stmt|;
name|qpg_data
operator|->
name|rss_child_count
operator|=
name|attr
operator|->
name|parent_attrib
operator|.
name|rss_child_count
expr_stmt|;
name|qpg_data
operator|->
name|qpg_parent
operator|=
name|pqp
expr_stmt|;
name|qpg_data
operator|->
name|qpg_tss_mask_sz
operator|=
name|ilog2
argument_list|(
name|tss_align_num
argument_list|)
expr_stmt|;
name|qpg_data
operator|->
name|tss_qpn_base
operator|=
name|tss_base
expr_stmt|;
name|qpg_data
operator|->
name|rss_qpn_base
operator|=
name|rss_base
expr_stmt|;
name|pqp
operator|->
name|qpg_data
operator|=
name|qpg_data
expr_stmt|;
operator|*
name|qpn
operator|=
name|tss_base
expr_stmt|;
return|return
literal|0
return|;
name|err4
label|:
name|mlx4_qp_release_range
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|rss_base
argument_list|,
name|rss_align_num
argument_list|)
expr_stmt|;
name|err3
label|:
if|if
condition|(
name|tss_num
operator|>
literal|1
condition|)
name|kfree
argument_list|(
name|qpg_data
operator|->
name|tss_bitmap
argument_list|)
expr_stmt|;
name|err2
label|:
if|if
condition|(
name|pqp
operator|->
name|flags
operator|&
name|MLX4_IB_QP_NETIF
condition|)
name|mlx4_ib_steer_qp_free
argument_list|(
name|dev
argument_list|,
name|tss_base
argument_list|,
name|tss_align_num
argument_list|)
expr_stmt|;
else|else
name|mlx4_qp_release_range
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|tss_base
argument_list|,
name|tss_align_num
argument_list|)
expr_stmt|;
name|err1
label|:
name|kfree
argument_list|(
name|qpg_data
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_qpg_parent
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_ib_qp
modifier|*
name|pqp
parameter_list|)
block|{
name|struct
name|mlx4_ib_qpg_data
modifier|*
name|qpg_data
init|=
name|pqp
operator|->
name|qpg_data
decl_stmt|;
name|int
name|align_num
decl_stmt|;
if|if
condition|(
name|qpg_data
operator|->
name|tss_child_count
operator|>
literal|1
condition|)
name|kfree
argument_list|(
name|qpg_data
operator|->
name|tss_bitmap
argument_list|)
expr_stmt|;
name|align_num
operator|=
name|roundup_pow_of_two
argument_list|(
literal|1
operator|+
name|qpg_data
operator|->
name|tss_child_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|pqp
operator|->
name|flags
operator|&
name|MLX4_IB_QP_NETIF
condition|)
name|mlx4_ib_steer_qp_free
argument_list|(
name|dev
argument_list|,
name|qpg_data
operator|->
name|tss_qpn_base
argument_list|,
name|align_num
argument_list|)
expr_stmt|;
else|else
name|mlx4_qp_release_range
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qpg_data
operator|->
name|tss_qpn_base
argument_list|,
name|align_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|qpg_data
operator|->
name|rss_child_count
operator|>
literal|1
condition|)
block|{
name|kfree
argument_list|(
name|qpg_data
operator|->
name|rss_bitmap
argument_list|)
expr_stmt|;
name|align_num
operator|=
name|roundup_pow_of_two
argument_list|(
name|qpg_data
operator|->
name|rss_child_count
argument_list|)
expr_stmt|;
name|mlx4_qp_release_range
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qpg_data
operator|->
name|rss_qpn_base
argument_list|,
name|align_num
argument_list|)
expr_stmt|;
block|}
name|kfree
argument_list|(
name|qpg_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_qpg_qpn
parameter_list|(
name|struct
name|ib_qp_init_attr
modifier|*
name|init_attr
parameter_list|,
name|struct
name|mlx4_ib_qp
modifier|*
name|pqp
parameter_list|,
name|int
modifier|*
name|qpn
parameter_list|)
block|{
name|struct
name|mlx4_ib_qp
modifier|*
name|mqp
init|=
name|to_mqp
argument_list|(
name|init_attr
operator|->
name|qpg_parent
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_qpg_data
modifier|*
name|qpg_data
init|=
name|mqp
operator|->
name|qpg_data
decl_stmt|;
name|u32
name|idx
decl_stmt|,
name|old
decl_stmt|;
switch|switch
condition|(
name|init_attr
operator|->
name|qpg_type
condition|)
block|{
case|case
name|IB_QPG_CHILD_TX
case|:
if|if
condition|(
name|qpg_data
operator|->
name|tss_child_count
operator|==
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
do|do
block|{
comment|/* Parent took index 0 */
name|idx
operator|=
name|find_first_bit
argument_list|(
name|qpg_data
operator|->
name|tss_bitmap
argument_list|,
name|qpg_data
operator|->
name|tss_child_count
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
name|qpg_data
operator|->
name|tss_child_count
operator|+
literal|1
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|old
operator|=
name|test_and_clear_bit
argument_list|(
name|idx
argument_list|,
name|qpg_data
operator|->
name|tss_bitmap
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|old
operator|==
literal|0
condition|)
do|;
name|idx
operator|+=
name|qpg_data
operator|->
name|tss_qpn_base
expr_stmt|;
break|break;
case|case
name|IB_QPG_CHILD_RX
case|:
if|if
condition|(
name|qpg_data
operator|->
name|rss_child_count
operator|==
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
do|do
block|{
name|idx
operator|=
name|find_first_bit
argument_list|(
name|qpg_data
operator|->
name|rss_bitmap
argument_list|,
name|qpg_data
operator|->
name|rss_child_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
name|qpg_data
operator|->
name|rss_child_count
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|old
operator|=
name|test_and_clear_bit
argument_list|(
name|idx
argument_list|,
name|qpg_data
operator|->
name|rss_bitmap
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|old
operator|==
literal|0
condition|)
do|;
name|idx
operator|+=
name|qpg_data
operator|->
name|rss_qpn_base
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
name|pqp
operator|->
name|qpg_data
operator|=
name|qpg_data
expr_stmt|;
operator|*
name|qpn
operator|=
name|idx
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_qpg_qpn
parameter_list|(
name|struct
name|mlx4_ib_qp
modifier|*
name|mqp
parameter_list|,
name|int
name|qpn
parameter_list|)
block|{
name|struct
name|mlx4_ib_qpg_data
modifier|*
name|qpg_data
init|=
name|mqp
operator|->
name|qpg_data
decl_stmt|;
switch|switch
condition|(
name|mqp
operator|->
name|qpg_type
condition|)
block|{
case|case
name|IB_QPG_CHILD_TX
case|:
comment|/* Do range check */
name|qpn
operator|-=
name|qpg_data
operator|->
name|tss_qpn_base
expr_stmt|;
name|set_bit
argument_list|(
name|qpn
argument_list|,
name|qpg_data
operator|->
name|tss_bitmap
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_QPG_CHILD_RX
case|:
name|qpn
operator|-=
name|qpg_data
operator|->
name|rss_qpn_base
expr_stmt|;
name|set_bit
argument_list|(
name|qpn
argument_list|,
name|qpg_data
operator|->
name|rss_bitmap
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* error */
name|pr_warn
argument_list|(
literal|"wrong qpg type (%d)\n"
argument_list|,
name|mqp
operator|->
name|qpg_type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|alloc_qpn_common
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_qp_init_attr
modifier|*
name|attr
parameter_list|,
name|int
modifier|*
name|qpn
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|attr
operator|->
name|qpg_type
condition|)
block|{
case|case
name|IB_QPG_NONE
case|:
comment|/* Raw packet QPNs must be aligned to 8 bits. If not, the WQE 		 * BlueFlame setup flow wrongly causes VLAN insertion. */
if|if
condition|(
name|attr
operator|->
name|qp_type
operator|==
name|IB_QPT_RAW_PACKET
condition|)
block|{
name|err
operator|=
name|mlx4_qp_reserve_range
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|qpn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|qp
operator|->
name|flags
operator|&
name|MLX4_IB_QP_NETIF
condition|)
name|err
operator|=
name|mlx4_ib_steer_qp_alloc
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|mlx4_qp_reserve_range
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|qpn
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IB_QPG_PARENT
case|:
name|err
operator|=
name|init_qpg_parent
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
name|attr
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_QPG_CHILD_TX
case|:
case|case
name|IB_QPG_CHILD_RX
case|:
name|err
operator|=
name|alloc_qpg_qpn
argument_list|(
name|attr
argument_list|,
name|qp
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
break|break;
default|default:
name|qp
operator|->
name|qpg_type
operator|=
name|IB_QPG_NONE
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|qp
operator|->
name|qpg_type
operator|=
name|attr
operator|->
name|qpg_type
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_qpn_common
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|,
name|enum
name|ib_qpg_type
name|qpg_type
parameter_list|,
name|int
name|qpn
parameter_list|)
block|{
switch|switch
condition|(
name|qpg_type
condition|)
block|{
case|case
name|IB_QPG_NONE
case|:
if|if
condition|(
name|qp
operator|->
name|flags
operator|&
name|MLX4_IB_QP_NETIF
condition|)
name|mlx4_ib_steer_qp_free
argument_list|(
name|dev
argument_list|,
name|qpn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|mlx4_qp_release_range
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qpn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_QPG_PARENT
case|:
name|free_qpg_parent
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_QPG_CHILD_TX
case|:
case|case
name|IB_QPG_CHILD_RX
case|:
name|free_qpg_qpn
argument_list|(
name|qp
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Revert allocation on create_qp_common */
end_comment

begin_function
specifier|static
name|void
name|unalloc_qpn_common
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_qp_init_attr
modifier|*
name|attr
parameter_list|,
name|int
name|qpn
parameter_list|)
block|{
name|free_qpn_common
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
name|attr
operator|->
name|qpg_type
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|release_qpn_common
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|)
block|{
name|free_qpn_common
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
name|qp
operator|->
name|qpg_type
argument_list|,
name|qp
operator|->
name|mqp
operator|.
name|qpn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|create_qp_common
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_qp_init_attr
modifier|*
name|init_attr
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|,
name|int
name|sqpn
parameter_list|,
name|struct
name|mlx4_ib_qp
modifier|*
modifier|*
name|caller_qp
parameter_list|)
block|{
name|int
name|qpn
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|mlx4_ib_sqp
modifier|*
name|sqp
decl_stmt|;
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
decl_stmt|;
name|enum
name|mlx4_ib_qp_type
name|qp_type
init|=
operator|(
expr|enum
name|mlx4_ib_qp_type
operator|)
name|init_attr
operator|->
name|qp_type
decl_stmt|;
comment|/* When tunneling special qps, we use a plain UD qp */
if|if
condition|(
name|sqpn
condition|)
block|{
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
operator|&&
operator|(
operator|!
name|mlx4_is_master
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
operator|||
operator|!
operator|(
name|init_attr
operator|->
name|create_flags
operator|&
name|MLX4_IB_SRIOV_SQP
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|init_attr
operator|->
name|qp_type
operator|==
name|IB_QPT_GSI
condition|)
name|qp_type
operator|=
name|MLX4_IB_QPT_PROXY_GSI
expr_stmt|;
elseif|else
if|if
condition|(
name|mlx4_is_master
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
condition|)
name|qp_type
operator|=
name|MLX4_IB_QPT_PROXY_SMI_OWNER
expr_stmt|;
else|else
name|qp_type
operator|=
name|MLX4_IB_QPT_PROXY_SMI
expr_stmt|;
block|}
name|qpn
operator|=
name|sqpn
expr_stmt|;
comment|/* add extra sg entry for tunneling */
name|init_attr
operator|->
name|cap
operator|.
name|max_recv_sge
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|init_attr
operator|->
name|create_flags
operator|&
name|MLX4_IB_SRIOV_TUNNEL_QP
condition|)
block|{
name|struct
name|mlx4_ib_qp_tunnel_init_attr
modifier|*
name|tnl_init
init|=
name|container_of
argument_list|(
name|init_attr
argument_list|,
expr|struct
name|mlx4_ib_qp_tunnel_init_attr
argument_list|,
name|init_attr
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|tnl_init
operator|->
name|proxy_qp_type
operator|!=
name|IB_QPT_SMI
operator|&&
name|tnl_init
operator|->
name|proxy_qp_type
operator|!=
name|IB_QPT_GSI
operator|)
operator|||
operator|!
name|mlx4_is_master
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|tnl_init
operator|->
name|proxy_qp_type
operator|==
name|IB_QPT_GSI
condition|)
name|qp_type
operator|=
name|MLX4_IB_QPT_TUN_GSI
expr_stmt|;
elseif|else
if|if
condition|(
name|tnl_init
operator|->
name|slave
operator|==
name|mlx4_master_func_num
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
condition|)
name|qp_type
operator|=
name|MLX4_IB_QPT_TUN_SMI_OWNER
expr_stmt|;
else|else
name|qp_type
operator|=
name|MLX4_IB_QPT_TUN_SMI
expr_stmt|;
comment|/* we are definitely in the PPF here, since we are creating 		 * tunnel QPs. base_tunnel_sqpn is therefore valid. */
name|qpn
operator|=
name|dev
operator|->
name|dev
operator|->
name|phys_caps
operator|.
name|base_tunnel_sqpn
operator|+
literal|8
operator|*
name|tnl_init
operator|->
name|slave
operator|+
name|tnl_init
operator|->
name|proxy_qp_type
operator|*
literal|2
operator|+
name|tnl_init
operator|->
name|port
operator|-
literal|1
expr_stmt|;
name|sqpn
operator|=
name|qpn
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|caller_qp
condition|)
block|{
if|if
condition|(
name|qp_type
operator|==
name|MLX4_IB_QPT_SMI
operator|||
name|qp_type
operator|==
name|MLX4_IB_QPT_GSI
operator|||
operator|(
name|qp_type
operator|&
operator|(
name|MLX4_IB_QPT_PROXY_SMI
operator||
name|MLX4_IB_QPT_PROXY_SMI_OWNER
operator||
name|MLX4_IB_QPT_PROXY_GSI
operator||
name|MLX4_IB_QPT_TUN_SMI_OWNER
operator|)
operator|)
condition|)
block|{
name|sqp
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_ib_sqp
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sqp
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|qp
operator|=
operator|&
name|sqp
operator|->
name|qp
expr_stmt|;
name|qp
operator|->
name|pri
operator|.
name|vid
operator|=
name|qp
operator|->
name|alt
operator|.
name|vid
operator|=
literal|0xFFFF
expr_stmt|;
block|}
else|else
block|{
name|qp
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_ib_qp
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qp
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|qp
operator|->
name|pri
operator|.
name|vid
operator|=
name|qp
operator|->
name|alt
operator|.
name|vid
operator|=
literal|0xFFFF
expr_stmt|;
block|}
block|}
else|else
name|qp
operator|=
operator|*
name|caller_qp
expr_stmt|;
name|qp
operator|->
name|mlx4_ib_qp_type
operator|=
name|qp_type
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|qp
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|qp
operator|->
name|sq
operator|.
name|lock
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|qp
operator|->
name|rq
operator|.
name|lock
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|qp
operator|->
name|gid_list
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|qp
operator|->
name|steering_rules
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|qp
operator|->
name|rules_list
argument_list|)
expr_stmt|;
name|qp
operator|->
name|state
operator|=
name|IB_QPS_RESET
expr_stmt|;
if|if
condition|(
name|init_attr
operator|->
name|sq_sig_type
operator|==
name|IB_SIGNAL_ALL_WR
condition|)
name|qp
operator|->
name|sq_signal_bits
operator|=
name|cpu_to_be32
argument_list|(
name|MLX4_WQE_CTRL_CQ_UPDATE
argument_list|)
expr_stmt|;
name|err
operator|=
name|set_rq_size
argument_list|(
name|dev
argument_list|,
operator|&
name|init_attr
operator|->
name|cap
argument_list|,
operator|!
operator|!
name|pd
operator|->
name|uobject
argument_list|,
name|qp_has_rq
argument_list|(
name|init_attr
argument_list|)
argument_list|,
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|pd
operator|->
name|uobject
condition|)
block|{
name|struct
name|mlx4_ib_create_qp
name|ucmd
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|ib_copy_from_udata
argument_list|(
operator|&
name|ucmd
argument_list|,
name|udata
argument_list|,
sizeof|sizeof
name|ucmd
argument_list|)
condition|)
block|{
name|err
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|qp
operator|->
name|sq_no_prefetch
operator|=
name|ucmd
operator|.
name|sq_no_prefetch
expr_stmt|;
name|err
operator|=
name|set_user_sq_size
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
operator|&
name|ucmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err
goto|;
name|qp
operator|->
name|umem
operator|=
name|ib_umem_get
argument_list|(
name|pd
operator|->
name|uobject
operator|->
name|context
argument_list|,
name|ucmd
operator|.
name|buf_addr
argument_list|,
name|qp
operator|->
name|buf_size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|qp
operator|->
name|umem
argument_list|)
condition|)
block|{
name|err
operator|=
name|PTR_ERR
argument_list|(
name|qp
operator|->
name|umem
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|n
operator|=
name|ib_umem_page_count
argument_list|(
name|qp
operator|->
name|umem
argument_list|)
expr_stmt|;
name|shift
operator|=
name|mlx4_ib_umem_calc_optimal_mtt_size
argument_list|(
name|qp
operator|->
name|umem
argument_list|,
literal|0
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|err
operator|=
name|mlx4_mtt_init
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|n
argument_list|,
name|shift
argument_list|,
operator|&
name|qp
operator|->
name|mtt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_buf
goto|;
name|err
operator|=
name|mlx4_ib_umem_write_mtt
argument_list|(
name|dev
argument_list|,
operator|&
name|qp
operator|->
name|mtt
argument_list|,
name|qp
operator|->
name|umem
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_mtt
goto|;
if|if
condition|(
name|qp_has_rq
argument_list|(
name|init_attr
argument_list|)
condition|)
block|{
name|err
operator|=
name|mlx4_ib_db_map_user
argument_list|(
name|to_mucontext
argument_list|(
name|pd
operator|->
name|uobject
operator|->
name|context
argument_list|)
argument_list|,
name|ucmd
operator|.
name|db_addr
argument_list|,
operator|&
name|qp
operator|->
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_mtt
goto|;
block|}
block|}
else|else
block|{
name|qp
operator|->
name|sq_no_prefetch
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|init_attr
operator|->
name|create_flags
operator|&
name|IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK
condition|)
name|qp
operator|->
name|flags
operator||=
name|MLX4_IB_QP_BLOCK_MULTICAST_LOOPBACK
expr_stmt|;
if|if
condition|(
name|init_attr
operator|->
name|create_flags
operator|&
name|IB_QP_CREATE_IPOIB_UD_LSO
condition|)
name|qp
operator|->
name|flags
operator||=
name|MLX4_IB_QP_LSO
expr_stmt|;
if|if
condition|(
name|init_attr
operator|->
name|create_flags
operator|&
name|IB_QP_CREATE_NETIF_QP
operator|&&
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|steering_mode
operator|==
name|MLX4_STEERING_MODE_DEVICE_MANAGED
operator|&&
operator|!
name|mlx4_is_mfunc
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
condition|)
name|qp
operator|->
name|flags
operator||=
name|MLX4_IB_QP_NETIF
expr_stmt|;
name|err
operator|=
name|set_kernel_sq_size
argument_list|(
name|dev
argument_list|,
operator|&
name|init_attr
operator|->
name|cap
argument_list|,
name|qp_type
argument_list|,
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|qp_has_rq
argument_list|(
name|init_attr
argument_list|)
condition|)
block|{
name|err
operator|=
name|mlx4_db_alloc
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|qp
operator|->
name|db
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err
goto|;
operator|*
name|qp
operator|->
name|db
operator|.
name|db
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|max_inline_data
condition|)
block|{
name|err
operator|=
name|mlx4_bf_alloc
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|qp
operator|->
name|bf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|pr_debug
argument_list|(
literal|"failed to allocate blue flame"
literal|" register (%d)"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|qp
operator|->
name|bf
operator|.
name|uar
operator|=
operator|&
name|dev
operator|->
name|priv_uar
expr_stmt|;
block|}
block|}
else|else
name|qp
operator|->
name|bf
operator|.
name|uar
operator|=
operator|&
name|dev
operator|->
name|priv_uar
expr_stmt|;
if|if
condition|(
name|mlx4_buf_alloc
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|buf_size
argument_list|,
name|PAGE_SIZE
operator|*
literal|2
argument_list|,
operator|&
name|qp
operator|->
name|buf
argument_list|)
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_db
goto|;
block|}
name|err
operator|=
name|mlx4_mtt_init
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|buf
operator|.
name|npages
argument_list|,
name|qp
operator|->
name|buf
operator|.
name|page_shift
argument_list|,
operator|&
name|qp
operator|->
name|mtt
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_buf
goto|;
name|err
operator|=
name|mlx4_buf_write_mtt
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|qp
operator|->
name|mtt
argument_list|,
operator|&
name|qp
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_mtt
goto|;
name|qp
operator|->
name|sq
operator|.
name|wrid
operator|=
name|kmalloc
argument_list|(
name|qp
operator|->
name|sq
operator|.
name|wqe_cnt
operator|*
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rq
operator|.
name|wrid
operator|=
name|kmalloc
argument_list|(
name|qp
operator|->
name|rq
operator|.
name|wqe_cnt
operator|*
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qp
operator|->
name|sq
operator|.
name|wrid
operator|||
operator|!
name|qp
operator|->
name|rq
operator|.
name|wrid
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_wrid
goto|;
block|}
block|}
if|if
condition|(
name|sqpn
condition|)
block|{
if|if
condition|(
name|qp
operator|->
name|mlx4_ib_qp_type
operator|&
operator|(
name|MLX4_IB_QPT_PROXY_SMI_OWNER
operator||
name|MLX4_IB_QPT_PROXY_SMI
operator||
name|MLX4_IB_QPT_PROXY_GSI
operator|)
condition|)
block|{
if|if
condition|(
name|alloc_proxy_bufs
argument_list|(
name|pd
operator|->
name|device
argument_list|,
name|qp
argument_list|)
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_wrid
goto|;
block|}
block|}
block|}
else|else
block|{
name|err
operator|=
name|alloc_qpn_common
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
name|init_attr
argument_list|,
operator|&
name|qpn
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_proxy
goto|;
block|}
name|err
operator|=
name|mlx4_qp_alloc
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qpn
argument_list|,
operator|&
name|qp
operator|->
name|mqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_qpn
goto|;
if|if
condition|(
name|init_attr
operator|->
name|qp_type
operator|==
name|IB_QPT_XRC_TGT
condition|)
name|qp
operator|->
name|mqp
operator|.
name|qpn
operator||=
operator|(
literal|1
operator|<<
literal|23
operator|)
expr_stmt|;
comment|/* 	 * Hardware wants QPN written in big-endian order (after 	 * shifting) for send doorbell.  Precompute this value to save 	 * a little bit when posting sends. 	 */
name|qp
operator|->
name|doorbell_qpn
operator|=
name|swab32
argument_list|(
name|qp
operator|->
name|mqp
operator|.
name|qpn
operator|<<
literal|8
argument_list|)
expr_stmt|;
name|qp
operator|->
name|mqp
operator|.
name|event
operator|=
name|mlx4_ib_qp_event
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|caller_qp
condition|)
operator|*
name|caller_qp
operator|=
name|qp
expr_stmt|;
return|return
literal|0
return|;
name|err_qpn
label|:
name|unalloc_qpn_common
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
name|init_attr
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
name|err_proxy
label|:
if|if
condition|(
name|qp
operator|->
name|mlx4_ib_qp_type
operator|==
name|MLX4_IB_QPT_PROXY_GSI
condition|)
name|free_proxy_bufs
argument_list|(
name|pd
operator|->
name|device
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|err_wrid
label|:
if|if
condition|(
name|pd
operator|->
name|uobject
condition|)
block|{
if|if
condition|(
name|qp_has_rq
argument_list|(
name|init_attr
argument_list|)
condition|)
name|mlx4_ib_db_unmap_user
argument_list|(
name|to_mucontext
argument_list|(
name|pd
operator|->
name|uobject
operator|->
name|context
argument_list|)
argument_list|,
operator|&
name|qp
operator|->
name|db
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kfree
argument_list|(
name|qp
operator|->
name|sq
operator|.
name|wrid
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|qp
operator|->
name|rq
operator|.
name|wrid
argument_list|)
expr_stmt|;
block|}
name|err_mtt
label|:
name|mlx4_mtt_cleanup
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|qp
operator|->
name|mtt
argument_list|)
expr_stmt|;
name|err_buf
label|:
if|if
condition|(
name|pd
operator|->
name|uobject
condition|)
name|ib_umem_release
argument_list|(
name|qp
operator|->
name|umem
argument_list|)
expr_stmt|;
else|else
name|mlx4_buf_free
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|buf_size
argument_list|,
operator|&
name|qp
operator|->
name|buf
argument_list|)
expr_stmt|;
name|err_db
label|:
if|if
condition|(
operator|!
name|pd
operator|->
name|uobject
operator|&&
name|qp_has_rq
argument_list|(
name|init_attr
argument_list|)
condition|)
name|mlx4_db_free
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|qp
operator|->
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|max_inline_data
condition|)
name|mlx4_bf_free
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|qp
operator|->
name|bf
argument_list|)
expr_stmt|;
name|err
label|:
if|if
condition|(
operator|!
operator|*
name|caller_qp
condition|)
name|kfree
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|mlx4_qp_state
name|to_mlx4_state
parameter_list|(
name|enum
name|ib_qp_state
name|state
parameter_list|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|IB_QPS_RESET
case|:
return|return
name|MLX4_QP_STATE_RST
return|;
case|case
name|IB_QPS_INIT
case|:
return|return
name|MLX4_QP_STATE_INIT
return|;
case|case
name|IB_QPS_RTR
case|:
return|return
name|MLX4_QP_STATE_RTR
return|;
case|case
name|IB_QPS_RTS
case|:
return|return
name|MLX4_QP_STATE_RTS
return|;
case|case
name|IB_QPS_SQD
case|:
return|return
name|MLX4_QP_STATE_SQD
return|;
case|case
name|IB_QPS_SQE
case|:
return|return
name|MLX4_QP_STATE_SQER
return|;
case|case
name|IB_QPS_ERR
case|:
return|return
name|MLX4_QP_STATE_ERR
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_ib_lock_cqs
parameter_list|(
name|struct
name|mlx4_ib_cq
modifier|*
name|send_cq
parameter_list|,
name|struct
name|mlx4_ib_cq
modifier|*
name|recv_cq
parameter_list|)
function|__acquires
parameter_list|(
function|&send_cq->lock
end_function

begin_macro
unit|)
name|__acquires
argument_list|(
argument|&recv_cq->lock
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|send_cq
operator|==
name|recv_cq
condition|)
block|{
name|spin_lock_irq
argument_list|(
operator|&
name|send_cq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|__acquire
argument_list|(
operator|&
name|recv_cq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|send_cq
operator|->
name|mcq
operator|.
name|cqn
operator|<
name|recv_cq
operator|->
name|mcq
operator|.
name|cqn
condition|)
block|{
name|spin_lock_irq
argument_list|(
operator|&
name|send_cq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|spin_lock_nested
argument_list|(
operator|&
name|recv_cq
operator|->
name|lock
argument_list|,
name|SINGLE_DEPTH_NESTING
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|spin_lock_irq
argument_list|(
operator|&
name|recv_cq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|spin_lock_nested
argument_list|(
operator|&
name|send_cq
operator|->
name|lock
argument_list|,
name|SINGLE_DEPTH_NESTING
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|void
name|mlx4_ib_unlock_cqs
parameter_list|(
name|struct
name|mlx4_ib_cq
modifier|*
name|send_cq
parameter_list|,
name|struct
name|mlx4_ib_cq
modifier|*
name|recv_cq
parameter_list|)
function|__releases
parameter_list|(
function|&send_cq->lock
end_function

begin_macro
unit|)
name|__releases
argument_list|(
argument|&recv_cq->lock
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|send_cq
operator|==
name|recv_cq
condition|)
block|{
name|__release
argument_list|(
operator|&
name|recv_cq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|spin_unlock_irq
argument_list|(
operator|&
name|send_cq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|send_cq
operator|->
name|mcq
operator|.
name|cqn
operator|<
name|recv_cq
operator|->
name|mcq
operator|.
name|cqn
condition|)
block|{
name|spin_unlock
argument_list|(
operator|&
name|recv_cq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|spin_unlock_irq
argument_list|(
operator|&
name|send_cq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|spin_unlock
argument_list|(
operator|&
name|send_cq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|spin_unlock_irq
argument_list|(
operator|&
name|recv_cq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|void
name|del_gid_entries
parameter_list|(
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|mlx4_ib_gid_entry
modifier|*
name|ge
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|ge
argument_list|,
argument|tmp
argument_list|,
argument|&qp->gid_list
argument_list|,
argument|list
argument_list|)
block|{
name|list_del
argument_list|(
operator|&
name|ge
operator|->
name|list
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|ge
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|mlx4_ib_pd
modifier|*
name|get_pd
parameter_list|(
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|)
block|{
if|if
condition|(
name|qp
operator|->
name|ibqp
operator|.
name|qp_type
operator|==
name|IB_QPT_XRC_TGT
condition|)
return|return
name|to_mpd
argument_list|(
name|to_mxrcd
argument_list|(
name|qp
operator|->
name|ibqp
operator|.
name|xrcd
argument_list|)
operator|->
name|pd
argument_list|)
return|;
else|else
return|return
name|to_mpd
argument_list|(
name|qp
operator|->
name|ibqp
operator|.
name|pd
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_cqs
parameter_list|(
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|mlx4_ib_cq
modifier|*
modifier|*
name|send_cq
parameter_list|,
name|struct
name|mlx4_ib_cq
modifier|*
modifier|*
name|recv_cq
parameter_list|)
block|{
switch|switch
condition|(
name|qp
operator|->
name|ibqp
operator|.
name|qp_type
condition|)
block|{
case|case
name|IB_QPT_XRC_TGT
case|:
operator|*
name|send_cq
operator|=
name|to_mcq
argument_list|(
name|to_mxrcd
argument_list|(
name|qp
operator|->
name|ibqp
operator|.
name|xrcd
argument_list|)
operator|->
name|cq
argument_list|)
expr_stmt|;
operator|*
name|recv_cq
operator|=
operator|*
name|send_cq
expr_stmt|;
break|break;
case|case
name|IB_QPT_XRC_INI
case|:
operator|*
name|send_cq
operator|=
name|to_mcq
argument_list|(
name|qp
operator|->
name|ibqp
operator|.
name|send_cq
argument_list|)
expr_stmt|;
operator|*
name|recv_cq
operator|=
operator|*
name|send_cq
expr_stmt|;
break|break;
default|default:
operator|*
name|send_cq
operator|=
name|to_mcq
argument_list|(
name|qp
operator|->
name|ibqp
operator|.
name|send_cq
argument_list|)
expr_stmt|;
operator|*
name|recv_cq
operator|=
name|to_mcq
argument_list|(
name|qp
operator|->
name|ibqp
operator|.
name|recv_cq
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_qp_common
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|,
name|int
name|is_user
parameter_list|)
block|{
name|struct
name|mlx4_ib_cq
modifier|*
name|send_cq
decl_stmt|,
modifier|*
name|recv_cq
decl_stmt|;
if|if
condition|(
name|qp
operator|->
name|state
operator|!=
name|IB_QPS_RESET
condition|)
block|{
if|if
condition|(
name|mlx4_qp_modify
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|NULL
argument_list|,
name|to_mlx4_state
argument_list|(
name|qp
operator|->
name|state
argument_list|)
argument_list|,
name|MLX4_QP_STATE_RST
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|qp
operator|->
name|mqp
argument_list|)
condition|)
name|pr_warn
argument_list|(
literal|"modify QP %06x to RESET failed.\n"
argument_list|,
name|qp
operator|->
name|mqp
operator|.
name|qpn
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|pri
operator|.
name|smac
condition|)
block|{
name|mlx4_unregister_mac
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|pri
operator|.
name|smac_port
argument_list|,
name|qp
operator|->
name|pri
operator|.
name|smac
argument_list|)
expr_stmt|;
name|qp
operator|->
name|pri
operator|.
name|smac
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|alt
operator|.
name|smac
condition|)
block|{
name|mlx4_unregister_mac
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|alt
operator|.
name|smac_port
argument_list|,
name|qp
operator|->
name|alt
operator|.
name|smac
argument_list|)
expr_stmt|;
name|qp
operator|->
name|alt
operator|.
name|smac
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|pri
operator|.
name|vid
operator|<
literal|0x1000
condition|)
block|{
name|mlx4_unregister_vlan
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|pri
operator|.
name|vlan_port
argument_list|,
name|qp
operator|->
name|pri
operator|.
name|vid
argument_list|)
expr_stmt|;
name|qp
operator|->
name|pri
operator|.
name|vid
operator|=
literal|0xFFFF
expr_stmt|;
name|qp
operator|->
name|pri
operator|.
name|candidate_vid
operator|=
literal|0xFFFF
expr_stmt|;
name|qp
operator|->
name|pri
operator|.
name|update_vid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|alt
operator|.
name|vid
operator|<
literal|0x1000
condition|)
block|{
name|mlx4_unregister_vlan
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|alt
operator|.
name|vlan_port
argument_list|,
name|qp
operator|->
name|alt
operator|.
name|vid
argument_list|)
expr_stmt|;
name|qp
operator|->
name|alt
operator|.
name|vid
operator|=
literal|0xFFFF
expr_stmt|;
name|qp
operator|->
name|alt
operator|.
name|candidate_vid
operator|=
literal|0xFFFF
expr_stmt|;
name|qp
operator|->
name|alt
operator|.
name|update_vid
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|get_cqs
argument_list|(
name|qp
argument_list|,
operator|&
name|send_cq
argument_list|,
operator|&
name|recv_cq
argument_list|)
expr_stmt|;
name|mlx4_ib_lock_cqs
argument_list|(
name|send_cq
argument_list|,
name|recv_cq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_user
condition|)
block|{
name|__mlx4_ib_cq_clean
argument_list|(
name|recv_cq
argument_list|,
name|qp
operator|->
name|mqp
operator|.
name|qpn
argument_list|,
name|qp
operator|->
name|ibqp
operator|.
name|srq
condition|?
name|to_msrq
argument_list|(
name|qp
operator|->
name|ibqp
operator|.
name|srq
argument_list|)
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_cq
operator|!=
name|recv_cq
condition|)
name|__mlx4_ib_cq_clean
argument_list|(
name|send_cq
argument_list|,
name|qp
operator|->
name|mqp
operator|.
name|qpn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mlx4_qp_remove
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|qp
operator|->
name|mqp
argument_list|)
expr_stmt|;
name|mlx4_ib_unlock_cqs
argument_list|(
name|send_cq
argument_list|,
name|recv_cq
argument_list|)
expr_stmt|;
name|mlx4_qp_free
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|qp
operator|->
name|mqp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_sqp
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|)
operator|&&
operator|!
name|is_tunnel_qp
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|)
condition|)
name|release_qpn_common
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|mlx4_mtt_cleanup
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|qp
operator|->
name|mtt
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_user
condition|)
block|{
if|if
condition|(
name|qp
operator|->
name|rq
operator|.
name|wqe_cnt
condition|)
name|mlx4_ib_db_unmap_user
argument_list|(
name|to_mucontext
argument_list|(
name|qp
operator|->
name|ibqp
operator|.
name|uobject
operator|->
name|context
argument_list|)
argument_list|,
operator|&
name|qp
operator|->
name|db
argument_list|)
expr_stmt|;
name|ib_umem_release
argument_list|(
name|qp
operator|->
name|umem
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kfree
argument_list|(
name|qp
operator|->
name|sq
operator|.
name|wrid
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|qp
operator|->
name|rq
operator|.
name|wrid
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|mlx4_ib_qp_type
operator|&
operator|(
name|MLX4_IB_QPT_PROXY_SMI_OWNER
operator||
name|MLX4_IB_QPT_PROXY_SMI
operator||
name|MLX4_IB_QPT_PROXY_GSI
operator|)
condition|)
name|free_proxy_bufs
argument_list|(
operator|&
name|dev
operator|->
name|ib_dev
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|mlx4_buf_free
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|buf_size
argument_list|,
operator|&
name|qp
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|max_inline_data
condition|)
name|mlx4_bf_free
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|qp
operator|->
name|bf
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|rq
operator|.
name|wqe_cnt
condition|)
name|mlx4_db_free
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|qp
operator|->
name|db
argument_list|)
expr_stmt|;
block|}
name|del_gid_entries
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u32
name|get_sqp_num
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|ib_qp_init_attr
modifier|*
name|attr
parameter_list|)
block|{
comment|/* Native or PPF */
if|if
condition|(
operator|!
name|mlx4_is_mfunc
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
operator|||
operator|(
name|mlx4_is_master
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
operator|&&
name|attr
operator|->
name|create_flags
operator|&
name|MLX4_IB_SRIOV_SQP
operator|)
condition|)
block|{
return|return
name|dev
operator|->
name|dev
operator|->
name|phys_caps
operator|.
name|base_sqpn
operator|+
operator|(
name|attr
operator|->
name|qp_type
operator|==
name|IB_QPT_SMI
condition|?
literal|0
else|:
literal|2
operator|)
operator|+
name|attr
operator|->
name|port_num
operator|-
literal|1
return|;
block|}
comment|/* PF or VF -- creating proxies */
if|if
condition|(
name|attr
operator|->
name|qp_type
operator|==
name|IB_QPT_SMI
condition|)
return|return
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|qp0_proxy
index|[
name|attr
operator|->
name|port_num
operator|-
literal|1
index|]
return|;
else|else
return|return
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|qp1_proxy
index|[
name|attr
operator|->
name|port_num
operator|-
literal|1
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|check_qpg_attr
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|ib_qp_init_attr
modifier|*
name|attr
parameter_list|)
block|{
if|if
condition|(
name|attr
operator|->
name|qpg_type
operator|==
name|IB_QPG_NONE
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|attr
operator|->
name|qp_type
operator|!=
name|IB_QPT_UD
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|attr
operator|->
name|qpg_type
operator|==
name|IB_QPG_PARENT
condition|)
block|{
if|if
condition|(
name|attr
operator|->
name|parent_attrib
operator|.
name|tss_child_count
operator|==
literal|1
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* Doesn't make sense */
if|if
condition|(
name|attr
operator|->
name|parent_attrib
operator|.
name|rss_child_count
operator|==
literal|1
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* Doesn't make sense */
if|if
condition|(
operator|(
name|attr
operator|->
name|parent_attrib
operator|.
name|tss_child_count
operator|==
literal|0
operator|)
operator|&&
operator|(
name|attr
operator|->
name|parent_attrib
operator|.
name|rss_child_count
operator|==
literal|0
operator|)
condition|)
comment|/* Should be called with IP_QPG_NONE */
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|attr
operator|->
name|parent_attrib
operator|.
name|rss_child_count
operator|>
literal|1
condition|)
block|{
name|int
name|rss_align_num
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_RSS
operator|)
condition|)
return|return
operator|-
name|ENOSYS
return|;
name|rss_align_num
operator|=
name|roundup_pow_of_two
argument_list|(
name|attr
operator|->
name|parent_attrib
operator|.
name|rss_child_count
argument_list|)
expr_stmt|;
if|if
condition|(
name|rss_align_num
operator|>
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_rss_tbl_sz
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
else|else
block|{
name|struct
name|mlx4_ib_qpg_data
modifier|*
name|qpg_data
decl_stmt|;
if|if
condition|(
name|attr
operator|->
name|qpg_parent
operator|==
name|NULL
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|attr
operator|->
name|qpg_parent
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|qpg_data
operator|=
name|to_mqp
argument_list|(
name|attr
operator|->
name|qpg_parent
argument_list|)
operator|->
name|qpg_data
expr_stmt|;
if|if
condition|(
name|qpg_data
operator|==
name|NULL
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|attr
operator|->
name|qpg_type
operator|==
name|IB_QPG_CHILD_TX
operator|&&
operator|!
name|qpg_data
operator|->
name|tss_child_count
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|attr
operator|->
name|qpg_type
operator|==
name|IB_QPG_CHILD_RX
operator|&&
operator|!
name|qpg_data
operator|->
name|rss_child_count
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|RESERVED_FLAGS_MASK
value|((((unsigned int)IB_QP_CREATE_RESERVED_END - 1) | IB_QP_CREATE_RESERVED_END)   \& ~(IB_QP_CREATE_RESERVED_START - 1))
end_define

begin_function
specifier|static
name|enum
name|mlx4_ib_qp_flags
name|to_mlx4_ib_qp_flags
parameter_list|(
name|enum
name|ib_qp_create_flags
name|ib_qp_flags
parameter_list|)
block|{
name|enum
name|mlx4_ib_qp_flags
name|mlx4_ib_qp_flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ib_qp_flags
operator|&
name|IB_QP_CREATE_IPOIB_UD_LSO
condition|)
name|mlx4_ib_qp_flags
operator||=
name|MLX4_IB_QP_LSO
expr_stmt|;
if|if
condition|(
name|ib_qp_flags
operator|&
name|IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK
condition|)
name|mlx4_ib_qp_flags
operator||=
name|MLX4_IB_QP_BLOCK_MULTICAST_LOOPBACK
expr_stmt|;
if|if
condition|(
name|ib_qp_flags
operator|&
name|IB_QP_CREATE_NETIF_QP
condition|)
name|mlx4_ib_qp_flags
operator||=
name|MLX4_IB_QP_NETIF
expr_stmt|;
comment|/* reserved flags */
name|mlx4_ib_qp_flags
operator||=
operator|(
name|ib_qp_flags
operator|&
name|RESERVED_FLAGS_MASK
operator|)
expr_stmt|;
return|return
name|mlx4_ib_qp_flags
return|;
block|}
end_function

begin_function
name|struct
name|ib_qp
modifier|*
name|mlx4_ib_create_qp
parameter_list|(
name|struct
name|ib_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|ib_qp_init_attr
modifier|*
name|init_attr
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
block|{
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|;
name|u16
name|xrcdn
init|=
literal|0
decl_stmt|;
name|enum
name|mlx4_ib_qp_flags
name|mlx4_qp_flags
init|=
name|to_mlx4_ib_qp_flags
argument_list|(
name|init_attr
operator|->
name|create_flags
argument_list|)
decl_stmt|;
name|struct
name|ib_device
modifier|*
name|device
decl_stmt|;
comment|/* see ib_core::ib_create_qp same handling */
name|device
operator|=
name|pd
condition|?
name|pd
operator|->
name|device
else|:
name|init_attr
operator|->
name|xrcd
operator|->
name|device
expr_stmt|;
comment|/* 	 * We only support LSO, vendor flag1, and multicast loopback blocking, 	 * and only for kernel UD QPs. 	 */
if|if
condition|(
name|mlx4_qp_flags
operator|&
operator|~
operator|(
name|MLX4_IB_QP_LSO
operator||
name|MLX4_IB_QP_BLOCK_MULTICAST_LOOPBACK
operator||
name|MLX4_IB_SRIOV_TUNNEL_QP
operator||
name|MLX4_IB_SRIOV_SQP
operator||
name|MLX4_IB_QP_NETIF
operator|)
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|EINVAL
argument_list|)
return|;
if|if
condition|(
name|init_attr
operator|->
name|create_flags
operator|&
name|IB_QP_CREATE_NETIF_QP
condition|)
block|{
if|if
condition|(
name|init_attr
operator|->
name|qp_type
operator|!=
name|IB_QPT_UD
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|EINVAL
argument_list|)
return|;
block|}
if|if
condition|(
name|init_attr
operator|->
name|create_flags
operator|&&
operator|(
name|udata
operator|||
operator|(
operator|(
name|mlx4_qp_flags
operator|&
operator|~
name|MLX4_IB_SRIOV_SQP
operator|)
operator|&&
name|init_attr
operator|->
name|qp_type
operator|!=
name|IB_QPT_UD
operator|)
operator|||
operator|(
operator|(
name|mlx4_qp_flags
operator|&
name|MLX4_IB_SRIOV_SQP
operator|)
operator|&&
name|init_attr
operator|->
name|qp_type
operator|>
name|IB_QPT_GSI
operator|)
operator|)
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|EINVAL
argument_list|)
return|;
name|err
operator|=
name|check_qpg_attr
argument_list|(
name|to_mdev
argument_list|(
name|device
argument_list|)
argument_list|,
name|init_attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|ERR_PTR
argument_list|(
name|err
argument_list|)
return|;
switch|switch
condition|(
name|init_attr
operator|->
name|qp_type
condition|)
block|{
case|case
name|IB_QPT_XRC_TGT
case|:
name|pd
operator|=
name|to_mxrcd
argument_list|(
name|init_attr
operator|->
name|xrcd
argument_list|)
operator|->
name|pd
expr_stmt|;
name|xrcdn
operator|=
name|to_mxrcd
argument_list|(
name|init_attr
operator|->
name|xrcd
argument_list|)
operator|->
name|xrcdn
expr_stmt|;
name|init_attr
operator|->
name|send_cq
operator|=
name|to_mxrcd
argument_list|(
name|init_attr
operator|->
name|xrcd
argument_list|)
operator|->
name|cq
expr_stmt|;
comment|/* fall through */
case|case
name|IB_QPT_XRC_INI
case|:
if|if
condition|(
operator|!
operator|(
name|to_mdev
argument_list|(
name|device
argument_list|)
operator|->
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_XRC
operator|)
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOSYS
argument_list|)
return|;
name|init_attr
operator|->
name|recv_cq
operator|=
name|init_attr
operator|->
name|send_cq
expr_stmt|;
comment|/* fall through */
case|case
name|IB_QPT_RC
case|:
case|case
name|IB_QPT_UC
case|:
case|case
name|IB_QPT_RAW_PACKET
case|:
name|qp
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|qp
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qp
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|qp
operator|->
name|pri
operator|.
name|vid
operator|=
name|qp
operator|->
name|alt
operator|.
name|vid
operator|=
literal|0xFFFF
expr_stmt|;
comment|/* fall through */
case|case
name|IB_QPT_UD
case|:
block|{
name|err
operator|=
name|create_qp_common
argument_list|(
name|to_mdev
argument_list|(
name|device
argument_list|)
argument_list|,
name|pd
argument_list|,
name|init_attr
argument_list|,
name|udata
argument_list|,
literal|0
argument_list|,
operator|&
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|kfree
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
name|err
argument_list|)
return|;
block|}
name|qp
operator|->
name|ibqp
operator|.
name|qp_num
operator|=
name|qp
operator|->
name|mqp
operator|.
name|qpn
expr_stmt|;
name|qp
operator|->
name|xrcdn
operator|=
name|xrcdn
expr_stmt|;
break|break;
block|}
case|case
name|IB_QPT_SMI
case|:
case|case
name|IB_QPT_GSI
case|:
block|{
comment|/* Userspace is not allowed to create special QPs: */
if|if
condition|(
name|udata
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|EINVAL
argument_list|)
return|;
name|err
operator|=
name|create_qp_common
argument_list|(
name|to_mdev
argument_list|(
name|device
argument_list|)
argument_list|,
name|pd
argument_list|,
name|init_attr
argument_list|,
name|udata
argument_list|,
name|get_sqp_num
argument_list|(
name|to_mdev
argument_list|(
name|device
argument_list|)
argument_list|,
name|init_attr
argument_list|)
argument_list|,
operator|&
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|ERR_PTR
argument_list|(
name|err
argument_list|)
return|;
name|qp
operator|->
name|port
operator|=
name|init_attr
operator|->
name|port_num
expr_stmt|;
name|qp
operator|->
name|ibqp
operator|.
name|qp_num
operator|=
name|init_attr
operator|->
name|qp_type
operator|==
name|IB_QPT_SMI
condition|?
literal|0
else|:
literal|1
expr_stmt|;
break|break;
block|}
default|default:
comment|/* Don't support raw QPs */
return|return
name|ERR_PTR
argument_list|(
operator|-
name|EINVAL
argument_list|)
return|;
block|}
return|return
operator|&
name|qp
operator|->
name|ibqp
return|;
block|}
end_function

begin_function
name|int
name|mlx4_ib_destroy_qp
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|qp
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_qp
modifier|*
name|mqp
init|=
name|to_mqp
argument_list|(
name|qp
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_pd
modifier|*
name|pd
decl_stmt|;
if|if
condition|(
name|is_qp0
argument_list|(
name|dev
argument_list|,
name|mqp
argument_list|)
condition|)
name|mlx4_CLOSE_PORT
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|mqp
operator|->
name|port
argument_list|)
expr_stmt|;
name|pd
operator|=
name|get_pd
argument_list|(
name|mqp
argument_list|)
expr_stmt|;
name|destroy_qp_common
argument_list|(
name|dev
argument_list|,
name|mqp
argument_list|,
operator|!
operator|!
name|pd
operator|->
name|ibpd
operator|.
name|uobject
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_sqp
argument_list|(
name|dev
argument_list|,
name|mqp
argument_list|)
condition|)
name|kfree
argument_list|(
name|to_msqp
argument_list|(
name|mqp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|kfree
argument_list|(
name|mqp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|to_mlx4_st
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|enum
name|mlx4_ib_qp_type
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MLX4_IB_QPT_RC
case|:
return|return
name|MLX4_QP_ST_RC
return|;
case|case
name|MLX4_IB_QPT_UC
case|:
return|return
name|MLX4_QP_ST_UC
return|;
case|case
name|MLX4_IB_QPT_UD
case|:
return|return
name|MLX4_QP_ST_UD
return|;
case|case
name|MLX4_IB_QPT_XRC_INI
case|:
case|case
name|MLX4_IB_QPT_XRC_TGT
case|:
return|return
name|MLX4_QP_ST_XRC
return|;
case|case
name|MLX4_IB_QPT_SMI
case|:
case|case
name|MLX4_IB_QPT_GSI
case|:
case|case
name|MLX4_IB_QPT_RAW_PACKET
case|:
return|return
name|MLX4_QP_ST_MLX
return|;
case|case
name|MLX4_IB_QPT_PROXY_SMI_OWNER
case|:
case|case
name|MLX4_IB_QPT_TUN_SMI_OWNER
case|:
return|return
operator|(
name|mlx4_is_mfunc
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
condition|?
name|MLX4_QP_ST_MLX
else|:
operator|-
literal|1
operator|)
return|;
case|case
name|MLX4_IB_QPT_PROXY_SMI
case|:
case|case
name|MLX4_IB_QPT_TUN_SMI
case|:
case|case
name|MLX4_IB_QPT_PROXY_GSI
case|:
case|case
name|MLX4_IB_QPT_TUN_GSI
case|:
return|return
operator|(
name|mlx4_is_mfunc
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
condition|?
name|MLX4_QP_ST_UD
else|:
operator|-
literal|1
operator|)
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|__be32
name|to_mlx4_access_flags
parameter_list|(
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|,
specifier|const
name|struct
name|ib_qp_attr
modifier|*
name|attr
parameter_list|,
name|int
name|attr_mask
parameter_list|)
block|{
name|u8
name|dest_rd_atomic
decl_stmt|;
name|u32
name|access_flags
decl_stmt|;
name|u32
name|hw_access_flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_MAX_DEST_RD_ATOMIC
condition|)
name|dest_rd_atomic
operator|=
name|attr
operator|->
name|max_dest_rd_atomic
expr_stmt|;
else|else
name|dest_rd_atomic
operator|=
name|qp
operator|->
name|resp_depth
expr_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_ACCESS_FLAGS
condition|)
name|access_flags
operator|=
name|attr
operator|->
name|qp_access_flags
expr_stmt|;
else|else
name|access_flags
operator|=
name|qp
operator|->
name|atomic_rd_en
expr_stmt|;
if|if
condition|(
operator|!
name|dest_rd_atomic
condition|)
name|access_flags
operator|&=
name|IB_ACCESS_REMOTE_WRITE
expr_stmt|;
if|if
condition|(
name|access_flags
operator|&
name|IB_ACCESS_REMOTE_READ
condition|)
name|hw_access_flags
operator||=
name|MLX4_QP_BIT_RRE
expr_stmt|;
if|if
condition|(
name|access_flags
operator|&
name|IB_ACCESS_REMOTE_ATOMIC
condition|)
name|hw_access_flags
operator||=
name|MLX4_QP_BIT_RAE
expr_stmt|;
if|if
condition|(
name|access_flags
operator|&
name|IB_ACCESS_REMOTE_WRITE
condition|)
name|hw_access_flags
operator||=
name|MLX4_QP_BIT_RWE
expr_stmt|;
return|return
name|cpu_to_be32
argument_list|(
name|hw_access_flags
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|store_sqp_attrs
parameter_list|(
name|struct
name|mlx4_ib_sqp
modifier|*
name|sqp
parameter_list|,
specifier|const
name|struct
name|ib_qp_attr
modifier|*
name|attr
parameter_list|,
name|int
name|attr_mask
parameter_list|)
block|{
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_PKEY_INDEX
condition|)
name|sqp
operator|->
name|pkey_index
operator|=
name|attr
operator|->
name|pkey_index
expr_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_QKEY
condition|)
name|sqp
operator|->
name|qkey
operator|=
name|attr
operator|->
name|qkey
expr_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_SQ_PSN
condition|)
name|sqp
operator|->
name|send_psn
operator|=
name|attr
operator|->
name|sq_psn
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mlx4_set_sched
parameter_list|(
name|struct
name|mlx4_qp_path
modifier|*
name|path
parameter_list|,
name|u8
name|port
parameter_list|)
block|{
name|path
operator|->
name|sched_queue
operator|=
operator|(
name|path
operator|->
name|sched_queue
operator|&
literal|0xbf
operator|)
operator||
operator|(
operator|(
name|port
operator|-
literal|1
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_set_path
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
specifier|const
name|struct
name|ib_ah_attr
modifier|*
name|ah
parameter_list|,
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|mlx4_qp_path
modifier|*
name|path
parameter_list|,
name|u8
name|port
parameter_list|,
name|int
name|is_primary
parameter_list|)
block|{
name|struct
name|net_device
modifier|*
name|ndev
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|is_eth
init|=
name|rdma_port_get_link_layer
argument_list|(
operator|&
name|dev
operator|->
name|ib_dev
argument_list|,
name|port
argument_list|)
operator|==
name|IB_LINK_LAYER_ETHERNET
decl_stmt|;
name|u8
name|mac
index|[
literal|6
index|]
decl_stmt|;
name|int
name|is_mcast
decl_stmt|;
name|u16
name|vlan_tag
decl_stmt|;
name|int
name|vidx
decl_stmt|;
name|int
name|smac_index
decl_stmt|;
name|u64
name|u64_mac
decl_stmt|;
name|u8
modifier|*
name|smac
decl_stmt|;
name|struct
name|mlx4_roce_smac_vlan_info
modifier|*
name|smac_info
decl_stmt|;
name|path
operator|->
name|grh_mylmc
operator|=
name|ah
operator|->
name|src_path_bits
operator|&
literal|0x7f
expr_stmt|;
name|path
operator|->
name|rlid
operator|=
name|cpu_to_be16
argument_list|(
name|ah
operator|->
name|dlid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ah
operator|->
name|static_rate
condition|)
block|{
name|path
operator|->
name|static_rate
operator|=
name|ah
operator|->
name|static_rate
operator|+
name|MLX4_STAT_RATE_OFFSET
expr_stmt|;
while|while
condition|(
name|path
operator|->
name|static_rate
operator|>
name|IB_RATE_2_5_GBPS
operator|+
name|MLX4_STAT_RATE_OFFSET
operator|&&
operator|!
operator|(
literal|1
operator|<<
name|path
operator|->
name|static_rate
operator|&
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|stat_rate_support
operator|)
condition|)
operator|--
name|path
operator|->
name|static_rate
expr_stmt|;
block|}
else|else
name|path
operator|->
name|static_rate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ah
operator|->
name|ah_flags
operator|&
name|IB_AH_GRH
condition|)
block|{
if|if
condition|(
name|ah
operator|->
name|grh
operator|.
name|sgid_index
operator|>=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|gid_table_len
index|[
name|port
index|]
condition|)
block|{
name|pr_err
argument_list|(
literal|"sgid_index (%u) too large. max is %d\n"
argument_list|,
name|ah
operator|->
name|grh
operator|.
name|sgid_index
argument_list|,
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|gid_table_len
index|[
name|port
index|]
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|path
operator|->
name|grh_mylmc
operator||=
literal|1
operator|<<
literal|7
expr_stmt|;
name|path
operator|->
name|mgid_index
operator|=
name|ah
operator|->
name|grh
operator|.
name|sgid_index
expr_stmt|;
name|path
operator|->
name|hop_limit
operator|=
name|ah
operator|->
name|grh
operator|.
name|hop_limit
expr_stmt|;
name|path
operator|->
name|tclass_flowlabel
operator|=
name|cpu_to_be32
argument_list|(
operator|(
name|ah
operator|->
name|grh
operator|.
name|traffic_class
operator|<<
literal|20
operator|)
operator||
operator|(
name|ah
operator|->
name|grh
operator|.
name|flow_label
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|path
operator|->
name|rgid
argument_list|,
name|ah
operator|->
name|grh
operator|.
name|dgid
operator|.
name|raw
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_eth
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ah
operator|->
name|ah_flags
operator|&
name|IB_AH_GRH
operator|)
condition|)
return|return
operator|-
literal|1
return|;
name|path
operator|->
name|sched_queue
operator|=
name|MLX4_IB_DEFAULT_SCHED_QUEUE
operator||
operator|(
operator|(
name|port
operator|-
literal|1
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
operator|(
name|ah
operator|->
name|sl
operator|&
literal|7
operator|)
operator|<<
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|is_primary
condition|)
name|smac_info
operator|=
operator|&
name|qp
operator|->
name|pri
expr_stmt|;
else|else
name|smac_info
operator|=
operator|&
name|qp
operator|->
name|alt
expr_stmt|;
name|vlan_tag
operator|=
name|rdma_get_vlan_id
argument_list|(
operator|&
name|dev
operator|->
name|iboe
operator|.
name|gid_table
index|[
name|port
operator|-
literal|1
index|]
index|[
name|ah
operator|->
name|grh
operator|.
name|sgid_index
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|vlan_tag
operator|<
literal|0x1000
condition|)
block|{
if|if
condition|(
name|smac_info
operator|->
name|vid
operator|<
literal|0x1000
condition|)
block|{
comment|/* both valid vlan ids */
if|if
condition|(
name|smac_info
operator|->
name|vid
operator|!=
name|vlan_tag
condition|)
block|{
comment|/* different VIDs.  unreg old and reg new */
name|err
operator|=
name|mlx4_register_vlan
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|port
argument_list|,
name|vlan_tag
argument_list|,
operator|&
name|vidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|smac_info
operator|->
name|candidate_vid
operator|=
name|vlan_tag
expr_stmt|;
name|smac_info
operator|->
name|candidate_vlan_index
operator|=
name|vidx
expr_stmt|;
name|smac_info
operator|->
name|candidate_vlan_port
operator|=
name|port
expr_stmt|;
name|smac_info
operator|->
name|update_vid
operator|=
literal|1
expr_stmt|;
name|path
operator|->
name|vlan_index
operator|=
name|vidx
expr_stmt|;
name|path
operator|->
name|fl
operator|=
literal|1
operator|<<
literal|6
expr_stmt|;
block|}
else|else
block|{
name|path
operator|->
name|vlan_index
operator|=
name|smac_info
operator|->
name|vlan_index
expr_stmt|;
name|path
operator|->
name|fl
operator|=
literal|1
operator|<<
literal|6
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* no current vlan tag in qp */
name|err
operator|=
name|mlx4_register_vlan
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|port
argument_list|,
name|vlan_tag
argument_list|,
operator|&
name|vidx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|smac_info
operator|->
name|candidate_vid
operator|=
name|vlan_tag
expr_stmt|;
name|smac_info
operator|->
name|candidate_vlan_index
operator|=
name|vidx
expr_stmt|;
name|smac_info
operator|->
name|candidate_vlan_port
operator|=
name|port
expr_stmt|;
name|smac_info
operator|->
name|update_vid
operator|=
literal|1
expr_stmt|;
name|path
operator|->
name|vlan_index
operator|=
name|vidx
expr_stmt|;
name|path
operator|->
name|fl
operator|=
literal|1
operator|<<
literal|6
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* have current vlan tag. unregister it at modify-qp success */
if|if
condition|(
name|smac_info
operator|->
name|vid
operator|<
literal|0x1000
condition|)
block|{
name|smac_info
operator|->
name|candidate_vid
operator|=
literal|0xFFFF
expr_stmt|;
name|smac_info
operator|->
name|update_vid
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|err
operator|=
name|mlx4_ib_resolve_grh
argument_list|(
name|dev
argument_list|,
name|ah
argument_list|,
name|mac
argument_list|,
operator|&
name|is_mcast
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
comment|/* get smac_index for RoCE use. 		 * If no smac was yet assigned, register one. 		 * If one was already assigned, but the new mac differs, 		 * unregister the old one and register the new one. 		*/
name|spin_lock
argument_list|(
operator|&
name|dev
operator|->
name|iboe
operator|.
name|lock
argument_list|)
expr_stmt|;
name|ndev
operator|=
name|dev
operator|->
name|iboe
operator|.
name|netdevs
index|[
name|port
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|ndev
condition|)
block|{
ifdef|#
directive|ifdef
name|__linux__
name|smac
operator|=
name|ndev
operator|->
name|dev_addr
expr_stmt|;
comment|/* fixme: cache this value */
else|#
directive|else
name|smac
operator|=
name|IF_LLADDR
argument_list|(
name|ndev
argument_list|)
expr_stmt|;
comment|/* fixme: cache this value */
endif|#
directive|endif
name|u64_mac
operator|=
name|mlx4_mac_to_u64
argument_list|(
name|smac
argument_list|)
expr_stmt|;
block|}
else|else
name|u64_mac
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|def_mac
index|[
name|port
index|]
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|dev
operator|->
name|iboe
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|smac_info
operator|->
name|smac
operator|||
name|smac_info
operator|->
name|smac
operator|!=
name|u64_mac
condition|)
block|{
comment|/* register candidate now, unreg if needed, after success */
name|smac_index
operator|=
name|mlx4_register_mac
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|port
argument_list|,
name|u64_mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|smac_index
operator|>=
literal|0
condition|)
block|{
name|smac_info
operator|->
name|candidate_smac_index
operator|=
name|smac_index
expr_stmt|;
name|smac_info
operator|->
name|candidate_smac
operator|=
name|u64_mac
expr_stmt|;
name|smac_info
operator|->
name|candidate_smac_port
operator|=
name|port
expr_stmt|;
block|}
else|else
return|return
operator|-
name|EINVAL
return|;
block|}
else|else
name|smac_index
operator|=
name|smac_info
operator|->
name|smac_index
expr_stmt|;
name|memcpy
argument_list|(
name|path
operator|->
name|dmac
argument_list|,
name|mac
argument_list|,
literal|6
argument_list|)
expr_stmt|;
name|path
operator|->
name|ackto
operator|=
name|MLX4_IB_LINK_TYPE_ETH
expr_stmt|;
comment|/* put MAC table smac index for IBoE */
name|path
operator|->
name|grh_mylmc
operator|=
call|(
name|u8
call|)
argument_list|(
name|smac_index
argument_list|)
operator||
literal|0x80
expr_stmt|;
block|}
else|else
name|path
operator|->
name|sched_queue
operator|=
name|MLX4_IB_DEFAULT_SCHED_QUEUE
operator||
operator|(
operator|(
name|port
operator|-
literal|1
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
operator|(
name|ah
operator|->
name|sl
operator|&
literal|0xf
operator|)
operator|<<
literal|2
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_mcg_macs
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|mlx4_ib_gid_entry
modifier|*
name|ge
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|ge
argument_list|,
argument|tmp
argument_list|,
argument|&qp->gid_list
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
operator|!
name|ge
operator|->
name|added
operator|&&
name|mlx4_ib_add_mc
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
operator|&
name|ge
operator|->
name|gid
argument_list|)
condition|)
block|{
name|ge
operator|->
name|added
operator|=
literal|1
expr_stmt|;
name|ge
operator|->
name|port
operator|=
name|qp
operator|->
name|port
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|handle_eth_ud_smac_index
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|mlx4_qp_context
modifier|*
name|context
parameter_list|)
block|{
name|struct
name|net_device
modifier|*
name|ndev
decl_stmt|;
name|u64
name|u64_mac
decl_stmt|;
name|u8
modifier|*
name|smac
decl_stmt|;
name|int
name|smac_index
decl_stmt|;
name|ndev
operator|=
name|dev
operator|->
name|iboe
operator|.
name|netdevs
index|[
name|qp
operator|->
name|port
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|ndev
condition|)
block|{
ifdef|#
directive|ifdef
name|__linux__
name|smac
operator|=
name|ndev
operator|->
name|dev_addr
expr_stmt|;
comment|/* fixme: cache this value */
else|#
directive|else
name|smac
operator|=
name|IF_LLADDR
argument_list|(
name|ndev
argument_list|)
expr_stmt|;
comment|/* fixme: cache this value */
endif|#
directive|endif
name|u64_mac
operator|=
name|mlx4_mac_to_u64
argument_list|(
name|smac
argument_list|)
expr_stmt|;
block|}
else|else
name|u64_mac
operator|=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|def_mac
index|[
name|qp
operator|->
name|port
index|]
expr_stmt|;
name|context
operator|->
name|pri_path
operator|.
name|sched_queue
operator|=
name|MLX4_IB_DEFAULT_SCHED_QUEUE
operator||
operator|(
operator|(
name|qp
operator|->
name|port
operator|-
literal|1
operator|)
operator|<<
literal|6
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|qp
operator|->
name|pri
operator|.
name|smac
condition|)
block|{
name|smac_index
operator|=
name|mlx4_register_mac
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|port
argument_list|,
name|u64_mac
argument_list|)
expr_stmt|;
if|if
condition|(
name|smac_index
operator|>=
literal|0
condition|)
block|{
name|qp
operator|->
name|pri
operator|.
name|candidate_smac_index
operator|=
name|smac_index
expr_stmt|;
name|qp
operator|->
name|pri
operator|.
name|candidate_smac
operator|=
name|u64_mac
expr_stmt|;
name|qp
operator|->
name|pri
operator|.
name|candidate_smac_port
operator|=
name|qp
operator|->
name|port
expr_stmt|;
name|context
operator|->
name|pri_path
operator|.
name|grh_mylmc
operator|=
literal|0x80
operator||
operator|(
name|u8
operator|)
name|smac_index
expr_stmt|;
block|}
else|else
return|return
operator|-
name|ENOENT
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__mlx4_ib_modify_qp
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|ibqp
parameter_list|,
specifier|const
name|struct
name|ib_qp_attr
modifier|*
name|attr
parameter_list|,
name|int
name|attr_mask
parameter_list|,
name|enum
name|ib_qp_state
name|cur_state
parameter_list|,
name|enum
name|ib_qp_state
name|new_state
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ibqp
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
init|=
name|to_mqp
argument_list|(
name|ibqp
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_pd
modifier|*
name|pd
decl_stmt|;
name|struct
name|mlx4_ib_cq
modifier|*
name|send_cq
decl_stmt|,
modifier|*
name|recv_cq
decl_stmt|;
name|struct
name|mlx4_qp_context
modifier|*
name|context
decl_stmt|;
name|enum
name|mlx4_qp_optpar
name|optpar
init|=
literal|0
decl_stmt|;
name|int
name|sqd_event
decl_stmt|;
name|int
name|steer_qp
init|=
literal|0
decl_stmt|;
name|int
name|err
init|=
operator|-
name|EINVAL
decl_stmt|;
name|int
name|is_eth
init|=
operator|-
literal|1
decl_stmt|;
name|context
operator|=
name|kzalloc
argument_list|(
sizeof|sizeof
expr|*
name|context
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|context
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|context
operator|->
name|flags
operator|=
name|cpu_to_be32
argument_list|(
operator|(
name|to_mlx4_state
argument_list|(
name|new_state
argument_list|)
operator|<<
literal|28
operator|)
operator||
operator|(
name|to_mlx4_st
argument_list|(
name|dev
argument_list|,
name|qp
operator|->
name|mlx4_ib_qp_type
argument_list|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|attr_mask
operator|&
name|IB_QP_PATH_MIG_STATE
operator|)
condition|)
name|context
operator|->
name|flags
operator||=
name|cpu_to_be32
argument_list|(
name|MLX4_QP_PM_MIGRATED
operator|<<
literal|11
argument_list|)
expr_stmt|;
else|else
block|{
name|optpar
operator||=
name|MLX4_QP_OPTPAR_PM_STATE
expr_stmt|;
switch|switch
condition|(
name|attr
operator|->
name|path_mig_state
condition|)
block|{
case|case
name|IB_MIG_MIGRATED
case|:
name|context
operator|->
name|flags
operator||=
name|cpu_to_be32
argument_list|(
name|MLX4_QP_PM_MIGRATED
operator|<<
literal|11
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_MIG_REARM
case|:
name|context
operator|->
name|flags
operator||=
name|cpu_to_be32
argument_list|(
name|MLX4_QP_PM_REARM
operator|<<
literal|11
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_MIG_ARMED
case|:
name|context
operator|->
name|flags
operator||=
name|cpu_to_be32
argument_list|(
name|MLX4_QP_PM_ARMED
operator|<<
literal|11
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ibqp
operator|->
name|qp_type
operator|==
name|IB_QPT_GSI
operator|||
name|ibqp
operator|->
name|qp_type
operator|==
name|IB_QPT_SMI
condition|)
name|context
operator|->
name|mtu_msgmax
operator|=
operator|(
name|IB_MTU_4096
operator|<<
literal|5
operator|)
operator||
literal|11
expr_stmt|;
elseif|else
if|if
condition|(
name|ibqp
operator|->
name|qp_type
operator|==
name|IB_QPT_RAW_PACKET
condition|)
name|context
operator|->
name|mtu_msgmax
operator|=
operator|(
name|MLX4_RAW_QP_MTU
operator|<<
literal|5
operator|)
operator||
name|MLX4_RAW_QP_MSGMAX
expr_stmt|;
elseif|else
if|if
condition|(
name|ibqp
operator|->
name|qp_type
operator|==
name|IB_QPT_UD
condition|)
block|{
if|if
condition|(
name|qp
operator|->
name|flags
operator|&
name|MLX4_IB_QP_LSO
condition|)
name|context
operator|->
name|mtu_msgmax
operator|=
operator|(
name|IB_MTU_4096
operator|<<
literal|5
operator|)
operator||
name|ilog2
argument_list|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_gso_sz
argument_list|)
expr_stmt|;
else|else
name|context
operator|->
name|mtu_msgmax
operator|=
operator|(
name|IB_MTU_4096
operator|<<
literal|5
operator|)
operator||
literal|12
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_PATH_MTU
condition|)
block|{
if|if
condition|(
name|attr
operator|->
name|path_mtu
operator|<
name|IB_MTU_256
operator|||
name|attr
operator|->
name|path_mtu
operator|>
name|IB_MTU_4096
condition|)
block|{
name|pr_err
argument_list|(
literal|"path MTU (%u) is invalid\n"
argument_list|,
name|attr
operator|->
name|path_mtu
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|context
operator|->
name|mtu_msgmax
operator|=
operator|(
name|attr
operator|->
name|path_mtu
operator|<<
literal|5
operator|)
operator||
name|ilog2
argument_list|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_msg_sz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|rq
operator|.
name|wqe_cnt
condition|)
name|context
operator|->
name|rq_size_stride
operator|=
name|ilog2
argument_list|(
name|qp
operator|->
name|rq
operator|.
name|wqe_cnt
argument_list|)
operator|<<
literal|3
expr_stmt|;
name|context
operator|->
name|rq_size_stride
operator||=
name|qp
operator|->
name|rq
operator|.
name|wqe_shift
operator|-
literal|4
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|sq
operator|.
name|wqe_cnt
condition|)
name|context
operator|->
name|sq_size_stride
operator|=
name|ilog2
argument_list|(
name|qp
operator|->
name|sq
operator|.
name|wqe_cnt
argument_list|)
operator|<<
literal|3
expr_stmt|;
name|context
operator|->
name|sq_size_stride
operator||=
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|-
literal|4
expr_stmt|;
if|if
condition|(
name|cur_state
operator|==
name|IB_QPS_RESET
operator|&&
name|new_state
operator|==
name|IB_QPS_INIT
condition|)
block|{
name|context
operator|->
name|sq_size_stride
operator||=
operator|!
operator|!
name|qp
operator|->
name|sq_no_prefetch
operator|<<
literal|7
expr_stmt|;
name|context
operator|->
name|xrcd
operator|=
name|cpu_to_be32
argument_list|(
operator|(
name|u32
operator|)
name|qp
operator|->
name|xrcdn
argument_list|)
expr_stmt|;
name|context
operator|->
name|param3
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|30
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|ibqp
operator|.
name|uobject
condition|)
name|context
operator|->
name|usr_page
operator|=
name|cpu_to_be32
argument_list|(
name|to_mucontext
argument_list|(
name|ibqp
operator|->
name|uobject
operator|->
name|context
argument_list|)
operator|->
name|uar
operator|.
name|index
argument_list|)
expr_stmt|;
else|else
name|context
operator|->
name|usr_page
operator|=
name|cpu_to_be32
argument_list|(
name|qp
operator|->
name|bf
operator|.
name|uar
operator|->
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_DEST_QPN
condition|)
name|context
operator|->
name|remote_qpn
operator|=
name|cpu_to_be32
argument_list|(
name|attr
operator|->
name|dest_qp_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_PORT
condition|)
block|{
if|if
condition|(
name|cur_state
operator|==
name|IB_QPS_SQD
operator|&&
name|new_state
operator|==
name|IB_QPS_SQD
operator|&&
operator|!
operator|(
name|attr_mask
operator|&
name|IB_QP_AV
operator|)
condition|)
block|{
name|mlx4_set_sched
argument_list|(
operator|&
name|context
operator|->
name|pri_path
argument_list|,
name|attr
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|optpar
operator||=
name|MLX4_QP_OPTPAR_SCHED_QUEUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cur_state
operator|==
name|IB_QPS_INIT
operator|&&
name|new_state
operator|==
name|IB_QPS_RTR
condition|)
block|{
if|if
condition|(
name|dev
operator|->
name|counters
index|[
name|qp
operator|->
name|port
operator|-
literal|1
index|]
operator|!=
operator|-
literal|1
condition|)
block|{
name|context
operator|->
name|pri_path
operator|.
name|counter_index
operator|=
name|dev
operator|->
name|counters
index|[
name|qp
operator|->
name|port
operator|-
literal|1
index|]
expr_stmt|;
name|optpar
operator||=
name|MLX4_QP_OPTPAR_COUNTER_INDEX
expr_stmt|;
block|}
else|else
name|context
operator|->
name|pri_path
operator|.
name|counter_index
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|flags
operator|&
name|MLX4_IB_QP_NETIF
operator|&&
operator|(
name|qp
operator|->
name|qpg_type
operator|==
name|IB_QPG_NONE
operator|||
name|qp
operator|->
name|qpg_type
operator|==
name|IB_QPG_PARENT
operator|)
condition|)
block|{
name|mlx4_ib_steer_qp_reg
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|steer_qp
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_PKEY_INDEX
condition|)
block|{
if|if
condition|(
name|qp
operator|->
name|mlx4_ib_qp_type
operator|&
name|MLX4_IB_QPT_ANY_SRIOV
condition|)
name|context
operator|->
name|pri_path
operator|.
name|disable_pkey_check
operator|=
literal|0x40
expr_stmt|;
name|context
operator|->
name|pri_path
operator|.
name|pkey_index
operator|=
name|attr
operator|->
name|pkey_index
expr_stmt|;
name|optpar
operator||=
name|MLX4_QP_OPTPAR_PKEY_INDEX
expr_stmt|;
block|}
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_AV
condition|)
block|{
if|if
condition|(
name|mlx4_set_path
argument_list|(
name|dev
argument_list|,
operator|&
name|attr
operator|->
name|ah_attr
argument_list|,
name|qp
argument_list|,
operator|&
name|context
operator|->
name|pri_path
argument_list|,
name|attr_mask
operator|&
name|IB_QP_PORT
condition|?
name|attr
operator|->
name|port_num
else|:
name|qp
operator|->
name|port
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|optpar
operator||=
operator|(
name|MLX4_QP_OPTPAR_PRIMARY_ADDR_PATH
operator||
name|MLX4_QP_OPTPAR_SCHED_QUEUE
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_TIMEOUT
condition|)
block|{
name|context
operator|->
name|pri_path
operator|.
name|ackto
operator||=
name|attr
operator|->
name|timeout
operator|<<
literal|3
expr_stmt|;
name|optpar
operator||=
name|MLX4_QP_OPTPAR_ACK_TIMEOUT
expr_stmt|;
block|}
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_ALT_PATH
condition|)
block|{
if|if
condition|(
name|attr
operator|->
name|alt_port_num
operator|==
literal|0
operator|||
name|attr
operator|->
name|alt_port_num
operator|>
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|attr
operator|->
name|alt_pkey_index
operator|>=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|pkey_table_len
index|[
name|attr
operator|->
name|alt_port_num
index|]
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|mlx4_set_path
argument_list|(
name|dev
argument_list|,
operator|&
name|attr
operator|->
name|alt_ah_attr
argument_list|,
name|qp
argument_list|,
operator|&
name|context
operator|->
name|alt_path
argument_list|,
name|attr
operator|->
name|alt_port_num
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|context
operator|->
name|alt_path
operator|.
name|pkey_index
operator|=
name|attr
operator|->
name|alt_pkey_index
expr_stmt|;
name|context
operator|->
name|alt_path
operator|.
name|ackto
operator|=
name|attr
operator|->
name|alt_timeout
operator|<<
literal|3
expr_stmt|;
name|optpar
operator||=
name|MLX4_QP_OPTPAR_ALT_ADDR_PATH
expr_stmt|;
block|}
name|pd
operator|=
name|get_pd
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|get_cqs
argument_list|(
name|qp
argument_list|,
operator|&
name|send_cq
argument_list|,
operator|&
name|recv_cq
argument_list|)
expr_stmt|;
name|context
operator|->
name|pd
operator|=
name|cpu_to_be32
argument_list|(
name|pd
operator|->
name|pdn
argument_list|)
expr_stmt|;
name|context
operator|->
name|cqn_send
operator|=
name|cpu_to_be32
argument_list|(
name|send_cq
operator|->
name|mcq
operator|.
name|cqn
argument_list|)
expr_stmt|;
name|context
operator|->
name|cqn_recv
operator|=
name|cpu_to_be32
argument_list|(
name|recv_cq
operator|->
name|mcq
operator|.
name|cqn
argument_list|)
expr_stmt|;
name|context
operator|->
name|params1
operator|=
name|cpu_to_be32
argument_list|(
name|MLX4_IB_ACK_REQ_FREQ
operator|<<
literal|28
argument_list|)
expr_stmt|;
comment|/* Set "fast registration enabled" for all kernel QPs */
if|if
condition|(
operator|!
name|qp
operator|->
name|ibqp
operator|.
name|uobject
condition|)
name|context
operator|->
name|params1
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|11
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_RNR_RETRY
condition|)
block|{
name|context
operator|->
name|params1
operator||=
name|cpu_to_be32
argument_list|(
name|attr
operator|->
name|rnr_retry
operator|<<
literal|13
argument_list|)
expr_stmt|;
name|optpar
operator||=
name|MLX4_QP_OPTPAR_RNR_RETRY
expr_stmt|;
block|}
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_RETRY_CNT
condition|)
block|{
name|context
operator|->
name|params1
operator||=
name|cpu_to_be32
argument_list|(
name|attr
operator|->
name|retry_cnt
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|optpar
operator||=
name|MLX4_QP_OPTPAR_RETRY_COUNT
expr_stmt|;
block|}
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_MAX_QP_RD_ATOMIC
condition|)
block|{
if|if
condition|(
name|attr
operator|->
name|max_rd_atomic
condition|)
name|context
operator|->
name|params1
operator||=
name|cpu_to_be32
argument_list|(
name|fls
argument_list|(
name|attr
operator|->
name|max_rd_atomic
operator|-
literal|1
argument_list|)
operator|<<
literal|21
argument_list|)
expr_stmt|;
name|optpar
operator||=
name|MLX4_QP_OPTPAR_SRA_MAX
expr_stmt|;
block|}
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_SQ_PSN
condition|)
name|context
operator|->
name|next_send_psn
operator|=
name|cpu_to_be32
argument_list|(
name|attr
operator|->
name|sq_psn
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_MAX_DEST_RD_ATOMIC
condition|)
block|{
if|if
condition|(
name|attr
operator|->
name|max_dest_rd_atomic
condition|)
name|context
operator|->
name|params2
operator||=
name|cpu_to_be32
argument_list|(
name|fls
argument_list|(
name|attr
operator|->
name|max_dest_rd_atomic
operator|-
literal|1
argument_list|)
operator|<<
literal|21
argument_list|)
expr_stmt|;
name|optpar
operator||=
name|MLX4_QP_OPTPAR_RRA_MAX
expr_stmt|;
block|}
if|if
condition|(
name|attr_mask
operator|&
operator|(
name|IB_QP_ACCESS_FLAGS
operator||
name|IB_QP_MAX_DEST_RD_ATOMIC
operator|)
condition|)
block|{
name|context
operator|->
name|params2
operator||=
name|to_mlx4_access_flags
argument_list|(
name|qp
argument_list|,
name|attr
argument_list|,
name|attr_mask
argument_list|)
expr_stmt|;
name|optpar
operator||=
name|MLX4_QP_OPTPAR_RWE
operator||
name|MLX4_QP_OPTPAR_RRE
operator||
name|MLX4_QP_OPTPAR_RAE
expr_stmt|;
block|}
if|if
condition|(
name|attr_mask
operator|&
name|IB_M_EXT_CLASS_1
condition|)
name|context
operator|->
name|params2
operator||=
name|cpu_to_be32
argument_list|(
name|MLX4_QP_BIT_COLL_MASTER
argument_list|)
expr_stmt|;
comment|/* for now we enable also sqe on send */
if|if
condition|(
name|attr_mask
operator|&
name|IB_M_EXT_CLASS_2
condition|)
block|{
name|context
operator|->
name|params2
operator||=
name|cpu_to_be32
argument_list|(
name|MLX4_QP_BIT_COLL_SYNC_SQ
argument_list|)
expr_stmt|;
name|context
operator|->
name|params2
operator||=
name|cpu_to_be32
argument_list|(
name|MLX4_QP_BIT_COLL_MASTER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attr_mask
operator|&
name|IB_M_EXT_CLASS_3
condition|)
name|context
operator|->
name|params2
operator||=
name|cpu_to_be32
argument_list|(
name|MLX4_QP_BIT_COLL_SYNC_RQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibqp
operator|->
name|srq
condition|)
name|context
operator|->
name|params2
operator||=
name|cpu_to_be32
argument_list|(
name|MLX4_QP_BIT_RIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_MIN_RNR_TIMER
condition|)
block|{
name|context
operator|->
name|rnr_nextrecvpsn
operator||=
name|cpu_to_be32
argument_list|(
name|attr
operator|->
name|min_rnr_timer
operator|<<
literal|24
argument_list|)
expr_stmt|;
name|optpar
operator||=
name|MLX4_QP_OPTPAR_RNR_TIMEOUT
expr_stmt|;
block|}
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_RQ_PSN
condition|)
name|context
operator|->
name|rnr_nextrecvpsn
operator||=
name|cpu_to_be32
argument_list|(
name|attr
operator|->
name|rq_psn
argument_list|)
expr_stmt|;
comment|/* proxy and tunnel qp qkeys will be changed in modify-qp wrappers */
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_QKEY
condition|)
block|{
if|if
condition|(
name|qp
operator|->
name|mlx4_ib_qp_type
operator|&
operator|(
name|MLX4_IB_QPT_PROXY_SMI_OWNER
operator||
name|MLX4_IB_QPT_TUN_SMI_OWNER
operator|)
condition|)
name|context
operator|->
name|qkey
operator|=
name|cpu_to_be32
argument_list|(
name|IB_QP_SET_QKEY
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|dev
operator|->
name|dev
argument_list|)
operator|&&
operator|!
operator|(
name|qp
operator|->
name|mlx4_ib_qp_type
operator|&
name|MLX4_IB_QPT_ANY_SRIOV
operator|)
operator|&&
operator|(
name|attr
operator|->
name|qkey
operator|&
name|MLX4_RESERVED_QKEY_MASK
operator|)
operator|==
name|MLX4_RESERVED_QKEY_BASE
condition|)
block|{
name|pr_err
argument_list|(
literal|"Cannot use reserved QKEY"
literal|" 0x%x (range 0xffff0000..0xffffffff"
literal|" is reserved)\n"
argument_list|,
name|attr
operator|->
name|qkey
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|context
operator|->
name|qkey
operator|=
name|cpu_to_be32
argument_list|(
name|attr
operator|->
name|qkey
argument_list|)
expr_stmt|;
block|}
name|optpar
operator||=
name|MLX4_QP_OPTPAR_Q_KEY
expr_stmt|;
block|}
if|if
condition|(
name|ibqp
operator|->
name|srq
condition|)
name|context
operator|->
name|srqn
operator|=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|24
operator||
name|to_msrq
argument_list|(
name|ibqp
operator|->
name|srq
argument_list|)
operator|->
name|msrq
operator|.
name|srqn
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|rq
operator|.
name|wqe_cnt
operator|&&
name|cur_state
operator|==
name|IB_QPS_RESET
operator|&&
name|new_state
operator|==
name|IB_QPS_INIT
condition|)
name|context
operator|->
name|db_rec_addr
operator|=
name|cpu_to_be64
argument_list|(
name|qp
operator|->
name|db
operator|.
name|dma
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_state
operator|==
name|IB_QPS_INIT
operator|&&
name|new_state
operator|==
name|IB_QPS_RTR
operator|&&
operator|(
name|ibqp
operator|->
name|qp_type
operator|==
name|IB_QPT_GSI
operator|||
name|ibqp
operator|->
name|qp_type
operator|==
name|IB_QPT_SMI
operator|||
name|ibqp
operator|->
name|qp_type
operator|==
name|IB_QPT_UD
operator|||
name|ibqp
operator|->
name|qp_type
operator|==
name|IB_QPT_RAW_PACKET
operator|)
condition|)
block|{
name|context
operator|->
name|pri_path
operator|.
name|sched_queue
operator|=
operator|(
name|qp
operator|->
name|port
operator|-
literal|1
operator|)
operator|<<
literal|6
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|mlx4_ib_qp_type
operator|==
name|MLX4_IB_QPT_SMI
operator|||
name|qp
operator|->
name|mlx4_ib_qp_type
operator|&
operator|(
name|MLX4_IB_QPT_PROXY_SMI_OWNER
operator||
name|MLX4_IB_QPT_TUN_SMI_OWNER
operator|)
condition|)
block|{
name|context
operator|->
name|pri_path
operator|.
name|sched_queue
operator||=
name|MLX4_IB_DEFAULT_QP0_SCHED_QUEUE
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|mlx4_ib_qp_type
operator|!=
name|MLX4_IB_QPT_SMI
condition|)
name|context
operator|->
name|pri_path
operator|.
name|fl
operator|=
literal|0x80
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|qp
operator|->
name|mlx4_ib_qp_type
operator|&
name|MLX4_IB_QPT_ANY_SRIOV
condition|)
name|context
operator|->
name|pri_path
operator|.
name|fl
operator|=
literal|0x80
expr_stmt|;
name|context
operator|->
name|pri_path
operator|.
name|sched_queue
operator||=
name|MLX4_IB_DEFAULT_SCHED_QUEUE
expr_stmt|;
block|}
name|is_eth
operator|=
name|rdma_port_get_link_layer
argument_list|(
operator|&
name|dev
operator|->
name|ib_dev
argument_list|,
name|qp
operator|->
name|port
argument_list|)
operator|==
name|IB_LINK_LAYER_ETHERNET
expr_stmt|;
if|if
condition|(
name|is_eth
condition|)
block|{
if|if
condition|(
name|qp
operator|->
name|mlx4_ib_qp_type
operator|==
name|MLX4_IB_QPT_TUN_GSI
operator|||
name|qp
operator|->
name|mlx4_ib_qp_type
operator|==
name|MLX4_IB_QPT_GSI
condition|)
name|context
operator|->
name|pri_path
operator|.
name|feup
operator|=
literal|1
operator|<<
literal|7
expr_stmt|;
comment|/* don't fsm */
comment|/* handle smac_index */
if|if
condition|(
name|qp
operator|->
name|mlx4_ib_qp_type
operator|==
name|MLX4_IB_QPT_UD
operator|||
name|qp
operator|->
name|mlx4_ib_qp_type
operator|==
name|MLX4_IB_QPT_PROXY_GSI
operator|||
name|qp
operator|->
name|mlx4_ib_qp_type
operator|==
name|MLX4_IB_QPT_TUN_GSI
condition|)
block|{
name|err
operator|=
name|handle_eth_ud_smac_index
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
block|}
block|}
if|if
condition|(
name|cur_state
operator|==
name|IB_QPS_RTS
operator|&&
name|new_state
operator|==
name|IB_QPS_SQD
operator|&&
name|attr_mask
operator|&
name|IB_QP_EN_SQD_ASYNC_NOTIFY
operator|&&
name|attr
operator|->
name|en_sqd_async_notify
condition|)
name|sqd_event
operator|=
literal|1
expr_stmt|;
else|else
name|sqd_event
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ibqp
operator|->
name|uobject
operator|&&
name|cur_state
operator|==
name|IB_QPS_RESET
operator|&&
name|new_state
operator|==
name|IB_QPS_INIT
condition|)
name|context
operator|->
name|rlkey
operator||=
operator|(
literal|1
operator|<<
literal|4
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|attr_mask
operator|&
name|IB_QP_GROUP_RSS
operator|)
operator|&&
operator|(
name|qp
operator|->
name|qpg_data
operator|->
name|rss_child_count
operator|>
literal|1
operator|)
condition|)
block|{
name|struct
name|mlx4_ib_qpg_data
modifier|*
name|qpg_data
init|=
name|qp
operator|->
name|qpg_data
decl_stmt|;
name|void
modifier|*
name|rss_context_base
init|=
operator|&
name|context
operator|->
name|pri_path
decl_stmt|;
name|struct
name|mlx4_rss_context
modifier|*
name|rss_context
init|=
operator|(
expr|struct
name|mlx4_rss_context
operator|*
operator|)
operator|(
name|rss_context_base
operator|+
name|MLX4_RSS_OFFSET_IN_QPC_PRI_PATH
operator|)
decl_stmt|;
name|context
operator|->
name|flags
operator||=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
name|MLX4_RSS_QPC_FLAG_OFFSET
argument_list|)
expr_stmt|;
comment|/* This should be tbl_sz_base_qpn */
name|rss_context
operator|->
name|base_qpn
operator|=
name|cpu_to_be32
argument_list|(
name|qpg_data
operator|->
name|rss_qpn_base
operator||
operator|(
name|ilog2
argument_list|(
name|qpg_data
operator|->
name|rss_child_count
argument_list|)
operator|<<
literal|24
operator|)
argument_list|)
expr_stmt|;
name|rss_context
operator|->
name|default_qpn
operator|=
name|cpu_to_be32
argument_list|(
name|qpg_data
operator|->
name|rss_qpn_base
argument_list|)
expr_stmt|;
comment|/* This should be flags_hash_fn */
name|rss_context
operator|->
name|flags
operator|=
name|MLX4_RSS_TCP_IPV6
operator||
name|MLX4_RSS_TCP_IPV4
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|flags
operator|&
name|MLX4_DEV_CAP_FLAG_UDP_RSS
condition|)
block|{
name|rss_context
operator|->
name|base_qpn_udp
operator|=
name|rss_context
operator|->
name|default_qpn
expr_stmt|;
name|rss_context
operator|->
name|flags
operator||=
name|MLX4_RSS_IPV6
operator||
name|MLX4_RSS_IPV4
operator||
name|MLX4_RSS_UDP_IPV6
operator||
name|MLX4_RSS_UDP_IPV4
expr_stmt|;
block|}
if|if
condition|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|flags2
operator|&
name|MLX4_DEV_CAP_FLAG2_RSS_TOP
condition|)
block|{
specifier|static
specifier|const
name|u32
name|rsskey
index|[
literal|10
index|]
init|=
block|{
literal|0xD181C62C
block|,
literal|0xF7F4DB5B
block|,
literal|0x1983A2FC
block|,
literal|0x943E1ADB
block|,
literal|0xD9389E6B
block|,
literal|0xD1039C2C
block|,
literal|0xA74499AD
block|,
literal|0x593D56D9
block|,
literal|0xF3253C06
block|,
literal|0x2ADC1FFC
block|}
decl_stmt|;
name|rss_context
operator|->
name|hash_fn
operator|=
name|MLX4_RSS_HASH_TOP
expr_stmt|;
name|memcpy
argument_list|(
name|rss_context
operator|->
name|rss_key
argument_list|,
name|rsskey
argument_list|,
sizeof|sizeof
argument_list|(
name|rss_context
operator|->
name|rss_key
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rss_context
operator|->
name|hash_fn
operator|=
name|MLX4_RSS_HASH_XOR
expr_stmt|;
name|memset
argument_list|(
name|rss_context
operator|->
name|rss_key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rss_context
operator|->
name|rss_key
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Before passing a kernel QP to the HW, make sure that the 	 * ownership bits of the send queue are set and the SQ 	 * headroom is stamped so that the hardware doesn't start 	 * processing stale work requests. 	 */
if|if
condition|(
operator|!
name|ibqp
operator|->
name|uobject
operator|&&
name|cur_state
operator|==
name|IB_QPS_RESET
operator|&&
name|new_state
operator|==
name|IB_QPS_INIT
condition|)
block|{
name|struct
name|mlx4_wqe_ctrl_seg
modifier|*
name|ctrl
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp
operator|->
name|sq
operator|.
name|wqe_cnt
condition|;
operator|++
name|i
control|)
block|{
name|ctrl
operator|=
name|get_send_wqe
argument_list|(
name|qp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ctrl
operator|->
name|owner_opcode
operator|=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|31
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|sq_max_wqes_per_wr
operator|==
literal|1
condition|)
name|ctrl
operator|->
name|fence_size
operator|=
literal|1
operator|<<
operator|(
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|-
literal|4
operator|)
expr_stmt|;
name|stamp_send_wqe
argument_list|(
name|qp
argument_list|,
name|i
argument_list|,
literal|1
operator|<<
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
argument_list|)
expr_stmt|;
block|}
block|}
name|err
operator|=
name|mlx4_qp_modify
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|qp
operator|->
name|mtt
argument_list|,
name|to_mlx4_state
argument_list|(
name|cur_state
argument_list|)
argument_list|,
name|to_mlx4_state
argument_list|(
name|new_state
argument_list|)
argument_list|,
name|context
argument_list|,
name|optpar
argument_list|,
name|sqd_event
argument_list|,
operator|&
name|qp
operator|->
name|mqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|qp
operator|->
name|state
operator|=
name|new_state
expr_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_ACCESS_FLAGS
condition|)
name|qp
operator|->
name|atomic_rd_en
operator|=
name|attr
operator|->
name|qp_access_flags
expr_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_MAX_DEST_RD_ATOMIC
condition|)
name|qp
operator|->
name|resp_depth
operator|=
name|attr
operator|->
name|max_dest_rd_atomic
expr_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_PORT
condition|)
block|{
name|qp
operator|->
name|port
operator|=
name|attr
operator|->
name|port_num
expr_stmt|;
name|update_mcg_macs
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_ALT_PATH
condition|)
name|qp
operator|->
name|alt_port
operator|=
name|attr
operator|->
name|alt_port_num
expr_stmt|;
if|if
condition|(
name|is_sqp
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|)
condition|)
name|store_sqp_attrs
argument_list|(
name|to_msqp
argument_list|(
name|qp
argument_list|)
argument_list|,
name|attr
argument_list|,
name|attr_mask
argument_list|)
expr_stmt|;
comment|/* Set 'ignore_cq_overrun' bits for collectives offload */
if|if
condition|(
name|cur_state
operator|==
name|IB_QPS_RESET
operator|&&
name|new_state
operator|==
name|IB_QPS_INIT
condition|)
block|{
if|if
condition|(
name|attr_mask
operator|&
operator|(
name|IB_M_EXT_CLASS_2
operator||
name|IB_M_EXT_CLASS_3
operator|)
condition|)
block|{
name|err
operator|=
name|mlx4_ib_ignore_overrun_cq
argument_list|(
name|ibqp
operator|->
name|send_cq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|pr_err
argument_list|(
literal|"Failed to set ignore CQ "
literal|"overrun for QP 0x%x's send CQ\n"
argument_list|,
name|ibqp
operator|->
name|qp_num
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|ibqp
operator|->
name|recv_cq
operator|!=
name|ibqp
operator|->
name|send_cq
condition|)
block|{
name|err
operator|=
name|mlx4_ib_ignore_overrun_cq
argument_list|(
name|ibqp
operator|->
name|recv_cq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|pr_err
argument_list|(
literal|"Failed to set ignore "
literal|"CQ overrun for QP 0x%x's recv "
literal|"CQ\n"
argument_list|,
name|ibqp
operator|->
name|qp_num
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
block|}
comment|/* 	 * If we moved QP0 to RTR, bring the IB link up; if we moved 	 * QP0 to RESET or ERROR, bring the link back down. 	 */
if|if
condition|(
name|is_qp0
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|)
condition|)
block|{
if|if
condition|(
name|cur_state
operator|!=
name|IB_QPS_RTR
operator|&&
name|new_state
operator|==
name|IB_QPS_RTR
condition|)
if|if
condition|(
name|mlx4_INIT_PORT
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|port
argument_list|)
condition|)
name|pr_warn
argument_list|(
literal|"INIT_PORT failed for port %d\n"
argument_list|,
name|qp
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_state
operator|!=
name|IB_QPS_RESET
operator|&&
name|cur_state
operator|!=
name|IB_QPS_ERR
operator|&&
operator|(
name|new_state
operator|==
name|IB_QPS_RESET
operator|||
name|new_state
operator|==
name|IB_QPS_ERR
operator|)
condition|)
name|mlx4_CLOSE_PORT
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|port
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we moved a kernel QP to RESET, clean up all old CQ 	 * entries and reinitialize the QP. 	 */
if|if
condition|(
name|new_state
operator|==
name|IB_QPS_RESET
condition|)
block|{
if|if
condition|(
operator|!
name|ibqp
operator|->
name|uobject
condition|)
block|{
name|mlx4_ib_cq_clean
argument_list|(
name|recv_cq
argument_list|,
name|qp
operator|->
name|mqp
operator|.
name|qpn
argument_list|,
name|ibqp
operator|->
name|srq
condition|?
name|to_msrq
argument_list|(
name|ibqp
operator|->
name|srq
argument_list|)
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_cq
operator|!=
name|recv_cq
condition|)
name|mlx4_ib_cq_clean
argument_list|(
name|send_cq
argument_list|,
name|qp
operator|->
name|mqp
operator|.
name|qpn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rq
operator|.
name|head
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|rq
operator|.
name|tail
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|sq
operator|.
name|head
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|sq
operator|.
name|tail
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|sq_next_wqe
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|rq
operator|.
name|wqe_cnt
condition|)
operator|*
name|qp
operator|->
name|db
operator|.
name|db
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|flags
operator|&
name|MLX4_IB_QP_NETIF
operator|&&
operator|(
name|qp
operator|->
name|qpg_type
operator|==
name|IB_QPG_NONE
operator|||
name|qp
operator|->
name|qpg_type
operator|==
name|IB_QPG_PARENT
operator|)
condition|)
name|mlx4_ib_steer_qp_reg
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|pri
operator|.
name|smac
condition|)
block|{
name|mlx4_unregister_mac
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|pri
operator|.
name|smac_port
argument_list|,
name|qp
operator|->
name|pri
operator|.
name|smac
argument_list|)
expr_stmt|;
name|qp
operator|->
name|pri
operator|.
name|smac
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|alt
operator|.
name|smac
condition|)
block|{
name|mlx4_unregister_mac
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|alt
operator|.
name|smac_port
argument_list|,
name|qp
operator|->
name|alt
operator|.
name|smac
argument_list|)
expr_stmt|;
name|qp
operator|->
name|alt
operator|.
name|smac
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|pri
operator|.
name|vid
operator|<
literal|0x1000
condition|)
block|{
name|mlx4_unregister_vlan
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|pri
operator|.
name|vlan_port
argument_list|,
name|qp
operator|->
name|pri
operator|.
name|vid
argument_list|)
expr_stmt|;
name|qp
operator|->
name|pri
operator|.
name|vid
operator|=
literal|0xFFFF
expr_stmt|;
name|qp
operator|->
name|pri
operator|.
name|candidate_vid
operator|=
literal|0xFFFF
expr_stmt|;
name|qp
operator|->
name|pri
operator|.
name|update_vid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|alt
operator|.
name|vid
operator|<
literal|0x1000
condition|)
block|{
name|mlx4_unregister_vlan
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|alt
operator|.
name|vlan_port
argument_list|,
name|qp
operator|->
name|alt
operator|.
name|vid
argument_list|)
expr_stmt|;
name|qp
operator|->
name|alt
operator|.
name|vid
operator|=
literal|0xFFFF
expr_stmt|;
name|qp
operator|->
name|alt
operator|.
name|candidate_vid
operator|=
literal|0xFFFF
expr_stmt|;
name|qp
operator|->
name|alt
operator|.
name|update_vid
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|out
label|:
if|if
condition|(
name|err
operator|&&
name|steer_qp
condition|)
name|mlx4_ib_steer_qp_reg
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|pri
operator|.
name|candidate_smac
condition|)
block|{
if|if
condition|(
name|err
condition|)
name|mlx4_unregister_mac
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|pri
operator|.
name|candidate_smac_port
argument_list|,
name|qp
operator|->
name|pri
operator|.
name|candidate_smac
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|qp
operator|->
name|pri
operator|.
name|smac
condition|)
block|{
name|mlx4_unregister_mac
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|pri
operator|.
name|smac_port
argument_list|,
name|qp
operator|->
name|pri
operator|.
name|smac
argument_list|)
expr_stmt|;
block|}
name|qp
operator|->
name|pri
operator|.
name|smac
operator|=
name|qp
operator|->
name|pri
operator|.
name|candidate_smac
expr_stmt|;
name|qp
operator|->
name|pri
operator|.
name|smac_index
operator|=
name|qp
operator|->
name|pri
operator|.
name|candidate_smac_index
expr_stmt|;
name|qp
operator|->
name|pri
operator|.
name|smac_port
operator|=
name|qp
operator|->
name|pri
operator|.
name|candidate_smac_port
expr_stmt|;
block|}
name|qp
operator|->
name|pri
operator|.
name|candidate_smac
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|pri
operator|.
name|candidate_smac_index
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|pri
operator|.
name|candidate_smac_port
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|alt
operator|.
name|candidate_smac
condition|)
block|{
if|if
condition|(
name|err
condition|)
name|mlx4_unregister_mac
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|alt
operator|.
name|candidate_smac_port
argument_list|,
name|qp
operator|->
name|pri
operator|.
name|candidate_smac
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|qp
operator|->
name|pri
operator|.
name|smac
condition|)
block|{
name|mlx4_unregister_mac
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|alt
operator|.
name|smac_port
argument_list|,
name|qp
operator|->
name|alt
operator|.
name|smac
argument_list|)
expr_stmt|;
block|}
name|qp
operator|->
name|alt
operator|.
name|smac
operator|=
name|qp
operator|->
name|alt
operator|.
name|candidate_smac
expr_stmt|;
name|qp
operator|->
name|alt
operator|.
name|smac_index
operator|=
name|qp
operator|->
name|alt
operator|.
name|candidate_smac_index
expr_stmt|;
name|qp
operator|->
name|alt
operator|.
name|smac_port
operator|=
name|qp
operator|->
name|alt
operator|.
name|candidate_smac_port
expr_stmt|;
block|}
name|qp
operator|->
name|pri
operator|.
name|candidate_smac
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|pri
operator|.
name|candidate_smac_index
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|pri
operator|.
name|candidate_smac_port
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|pri
operator|.
name|update_vid
condition|)
block|{
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|qp
operator|->
name|pri
operator|.
name|candidate_vid
operator|<
literal|0x1000
condition|)
name|mlx4_unregister_vlan
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|pri
operator|.
name|candidate_vlan_port
argument_list|,
name|qp
operator|->
name|pri
operator|.
name|candidate_vid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|qp
operator|->
name|pri
operator|.
name|vid
operator|<
literal|0x1000
condition|)
name|mlx4_unregister_vlan
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|pri
operator|.
name|vlan_port
argument_list|,
name|qp
operator|->
name|pri
operator|.
name|vid
argument_list|)
expr_stmt|;
name|qp
operator|->
name|pri
operator|.
name|vid
operator|=
name|qp
operator|->
name|pri
operator|.
name|candidate_vid
expr_stmt|;
name|qp
operator|->
name|pri
operator|.
name|vlan_port
operator|=
name|qp
operator|->
name|pri
operator|.
name|candidate_vlan_port
expr_stmt|;
name|qp
operator|->
name|pri
operator|.
name|vlan_index
operator|=
name|qp
operator|->
name|pri
operator|.
name|candidate_vlan_index
expr_stmt|;
block|}
name|qp
operator|->
name|pri
operator|.
name|candidate_vid
operator|=
literal|0xFFFF
expr_stmt|;
name|qp
operator|->
name|pri
operator|.
name|update_vid
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|alt
operator|.
name|update_vid
condition|)
block|{
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|qp
operator|->
name|alt
operator|.
name|candidate_vid
operator|<
literal|0x1000
condition|)
name|mlx4_unregister_vlan
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|alt
operator|.
name|candidate_vlan_port
argument_list|,
name|qp
operator|->
name|alt
operator|.
name|candidate_vid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|qp
operator|->
name|alt
operator|.
name|vid
operator|<
literal|0x1000
condition|)
name|mlx4_unregister_vlan
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
name|qp
operator|->
name|alt
operator|.
name|vlan_port
argument_list|,
name|qp
operator|->
name|alt
operator|.
name|vid
argument_list|)
expr_stmt|;
name|qp
operator|->
name|alt
operator|.
name|vid
operator|=
name|qp
operator|->
name|alt
operator|.
name|candidate_vid
expr_stmt|;
name|qp
operator|->
name|alt
operator|.
name|vlan_port
operator|=
name|qp
operator|->
name|alt
operator|.
name|candidate_vlan_port
expr_stmt|;
name|qp
operator|->
name|alt
operator|.
name|vlan_index
operator|=
name|qp
operator|->
name|alt
operator|.
name|candidate_vlan_index
expr_stmt|;
block|}
name|qp
operator|->
name|alt
operator|.
name|candidate_vid
operator|=
literal|0xFFFF
expr_stmt|;
name|qp
operator|->
name|alt
operator|.
name|update_vid
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_ib_modify_qp
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|ibqp
parameter_list|,
name|struct
name|ib_qp_attr
modifier|*
name|attr
parameter_list|,
name|int
name|attr_mask
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ibqp
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
init|=
name|to_mqp
argument_list|(
name|ibqp
argument_list|)
decl_stmt|;
name|enum
name|ib_qp_state
name|cur_state
decl_stmt|,
name|new_state
decl_stmt|;
name|int
name|err
init|=
operator|-
name|EINVAL
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|qp
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|cur_state
operator|=
name|attr_mask
operator|&
name|IB_QP_CUR_STATE
condition|?
name|attr
operator|->
name|cur_qp_state
else|:
name|qp
operator|->
name|state
expr_stmt|;
name|new_state
operator|=
name|attr_mask
operator|&
name|IB_QP_STATE
condition|?
name|attr
operator|->
name|qp_state
else|:
name|cur_state
expr_stmt|;
if|if
condition|(
operator|!
name|ib_modify_qp_is_ok
argument_list|(
name|cur_state
argument_list|,
name|new_state
argument_list|,
name|ibqp
operator|->
name|qp_type
argument_list|,
name|attr_mask
operator|&
operator|~
name|IB_M_QP_MOD_VEND_MASK
argument_list|)
condition|)
block|{
name|pr_debug
argument_list|(
literal|"qpn 0x%x: invalid attribute mask specified "
literal|"for transition %d to %d. qp_type %d,"
literal|" attr_mask 0x%x\n"
argument_list|,
name|ibqp
operator|->
name|qp_num
argument_list|,
name|cur_state
argument_list|,
name|new_state
argument_list|,
name|ibqp
operator|->
name|qp_type
argument_list|,
name|attr_mask
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|attr_mask
operator|&
name|IB_M_QP_MOD_VEND_MASK
operator|)
operator|&&
operator|!
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|sync_qp
condition|)
block|{
name|pr_err
argument_list|(
literal|"extended verbs are not supported by %s\n"
argument_list|,
name|dev
operator|->
name|ib_dev
operator|.
name|name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|attr_mask
operator|&
name|IB_QP_PORT
operator|)
operator|&&
operator|(
name|attr
operator|->
name|port_num
operator|==
literal|0
operator|||
name|attr
operator|->
name|port_num
operator|>
name|dev
operator|->
name|num_ports
operator|)
condition|)
block|{
name|pr_debug
argument_list|(
literal|"qpn 0x%x: invalid port number (%d) specified "
literal|"for transition %d to %d. qp_type %d\n"
argument_list|,
name|ibqp
operator|->
name|qp_num
argument_list|,
name|attr
operator|->
name|port_num
argument_list|,
name|cur_state
argument_list|,
name|new_state
argument_list|,
name|ibqp
operator|->
name|qp_type
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|attr_mask
operator|&
name|IB_QP_PORT
operator|)
operator|&&
operator|(
name|ibqp
operator|->
name|qp_type
operator|==
name|IB_QPT_RAW_PACKET
operator|)
operator|&&
operator|(
name|rdma_port_get_link_layer
argument_list|(
operator|&
name|dev
operator|->
name|ib_dev
argument_list|,
name|attr
operator|->
name|port_num
argument_list|)
operator|!=
name|IB_LINK_LAYER_ETHERNET
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_PKEY_INDEX
condition|)
block|{
name|int
name|p
init|=
name|attr_mask
operator|&
name|IB_QP_PORT
condition|?
name|attr
operator|->
name|port_num
else|:
name|qp
operator|->
name|port
decl_stmt|;
if|if
condition|(
name|attr
operator|->
name|pkey_index
operator|>=
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|pkey_table_len
index|[
name|p
index|]
condition|)
block|{
name|pr_debug
argument_list|(
literal|"qpn 0x%x: invalid pkey index (%d) specified "
literal|"for transition %d to %d. qp_type %d\n"
argument_list|,
name|ibqp
operator|->
name|qp_num
argument_list|,
name|attr
operator|->
name|pkey_index
argument_list|,
name|cur_state
argument_list|,
name|new_state
argument_list|,
name|ibqp
operator|->
name|qp_type
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_MAX_QP_RD_ATOMIC
operator|&&
name|attr
operator|->
name|max_rd_atomic
operator|>
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_qp_init_rdma
condition|)
block|{
name|pr_debug
argument_list|(
literal|"qpn 0x%x: max_rd_atomic (%d) too large. "
literal|"Transition %d to %d. qp_type %d\n"
argument_list|,
name|ibqp
operator|->
name|qp_num
argument_list|,
name|attr
operator|->
name|max_rd_atomic
argument_list|,
name|cur_state
argument_list|,
name|new_state
argument_list|,
name|ibqp
operator|->
name|qp_type
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_MAX_DEST_RD_ATOMIC
operator|&&
name|attr
operator|->
name|max_dest_rd_atomic
operator|>
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|max_qp_dest_rdma
condition|)
block|{
name|pr_debug
argument_list|(
literal|"qpn 0x%x: max_dest_rd_atomic (%d) too large. "
literal|"Transition %d to %d. qp_type %d\n"
argument_list|,
name|ibqp
operator|->
name|qp_num
argument_list|,
name|attr
operator|->
name|max_dest_rd_atomic
argument_list|,
name|cur_state
argument_list|,
name|new_state
argument_list|,
name|ibqp
operator|->
name|qp_type
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|cur_state
operator|==
name|new_state
operator|&&
name|cur_state
operator|==
name|IB_QPS_RESET
condition|)
block|{
name|err
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|err
operator|=
name|__mlx4_ib_modify_qp
argument_list|(
name|ibqp
argument_list|,
name|attr
argument_list|,
name|attr_mask
argument_list|,
name|cur_state
argument_list|,
name|new_state
argument_list|)
expr_stmt|;
name|out
label|:
name|mutex_unlock
argument_list|(
operator|&
name|qp
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|build_sriov_qp0_header
parameter_list|(
name|struct
name|mlx4_ib_sqp
modifier|*
name|sqp
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|,
name|void
modifier|*
name|wqe
parameter_list|,
name|unsigned
modifier|*
name|mlx_seg_len
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|mdev
init|=
name|to_mdev
argument_list|(
name|sqp
operator|->
name|qp
operator|.
name|ibqp
operator|.
name|device
argument_list|)
decl_stmt|;
name|struct
name|ib_device
modifier|*
name|ib_dev
init|=
operator|&
name|mdev
operator|->
name|ib_dev
decl_stmt|;
name|struct
name|mlx4_wqe_mlx_seg
modifier|*
name|mlx
init|=
name|wqe
decl_stmt|;
name|struct
name|mlx4_wqe_inline_seg
modifier|*
name|inl
init|=
name|wqe
operator|+
sizeof|sizeof
expr|*
name|mlx
decl_stmt|;
name|struct
name|mlx4_ib_ah
modifier|*
name|ah
init|=
name|to_mah
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|ah
argument_list|)
decl_stmt|;
name|u16
name|pkey
decl_stmt|;
name|u32
name|qkey
decl_stmt|;
name|int
name|send_size
decl_stmt|;
name|int
name|header_size
decl_stmt|;
name|int
name|spc
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|wr
operator|->
name|opcode
operator|!=
name|IB_WR_SEND
condition|)
return|return
operator|-
name|EINVAL
return|;
name|send_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wr
operator|->
name|num_sge
condition|;
operator|++
name|i
control|)
name|send_size
operator|+=
name|wr
operator|->
name|sg_list
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
comment|/* for proxy-qp0 sends, need to add in size of tunnel header */
comment|/* for tunnel-qp0 sends, tunnel header is already in s/g list */
if|if
condition|(
name|sqp
operator|->
name|qp
operator|.
name|mlx4_ib_qp_type
operator|==
name|MLX4_IB_QPT_PROXY_SMI_OWNER
condition|)
name|send_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_ib_tunnel_header
argument_list|)
expr_stmt|;
name|ib_ud_header_init
argument_list|(
name|send_size
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|sqp
operator|->
name|ud_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|sqp
operator|->
name|qp
operator|.
name|mlx4_ib_qp_type
operator|==
name|MLX4_IB_QPT_PROXY_SMI_OWNER
condition|)
block|{
name|sqp
operator|->
name|ud_header
operator|.
name|lrh
operator|.
name|service_level
operator|=
name|be32_to_cpu
argument_list|(
name|ah
operator|->
name|av
operator|.
name|ib
operator|.
name|sl_tclass_flowlabel
argument_list|)
operator|>>
literal|28
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|lrh
operator|.
name|destination_lid
operator|=
name|cpu_to_be16
argument_list|(
name|ah
operator|->
name|av
operator|.
name|ib
operator|.
name|g_slid
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|lrh
operator|.
name|source_lid
operator|=
name|cpu_to_be16
argument_list|(
name|ah
operator|->
name|av
operator|.
name|ib
operator|.
name|g_slid
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
block|}
name|mlx
operator|->
name|flags
operator|&=
name|cpu_to_be32
argument_list|(
name|MLX4_WQE_CTRL_CQ_UPDATE
argument_list|)
expr_stmt|;
comment|/* force loopback */
name|mlx
operator|->
name|flags
operator||=
name|cpu_to_be32
argument_list|(
name|MLX4_WQE_MLX_VL15
operator||
literal|0x1
operator||
name|MLX4_WQE_MLX_SLR
argument_list|)
expr_stmt|;
name|mlx
operator|->
name|rlid
operator|=
name|sqp
operator|->
name|ud_header
operator|.
name|lrh
operator|.
name|destination_lid
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|lrh
operator|.
name|virtual_lane
operator|=
literal|0
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|bth
operator|.
name|solicited_event
operator|=
operator|!
operator|!
operator|(
name|wr
operator|->
name|send_flags
operator|&
name|IB_SEND_SOLICITED
operator|)
expr_stmt|;
name|ib_get_cached_pkey
argument_list|(
name|ib_dev
argument_list|,
name|sqp
operator|->
name|qp
operator|.
name|port
argument_list|,
literal|0
argument_list|,
operator|&
name|pkey
argument_list|)
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|bth
operator|.
name|pkey
operator|=
name|cpu_to_be16
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|sqp
operator|->
name|qp
operator|.
name|mlx4_ib_qp_type
operator|==
name|MLX4_IB_QPT_TUN_SMI_OWNER
condition|)
name|sqp
operator|->
name|ud_header
operator|.
name|bth
operator|.
name|destination_qpn
operator|=
name|cpu_to_be32
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|remote_qpn
argument_list|)
expr_stmt|;
else|else
name|sqp
operator|->
name|ud_header
operator|.
name|bth
operator|.
name|destination_qpn
operator|=
name|cpu_to_be32
argument_list|(
name|mdev
operator|->
name|dev
operator|->
name|caps
operator|.
name|qp0_tunnel
index|[
name|sqp
operator|->
name|qp
operator|.
name|port
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|bth
operator|.
name|psn
operator|=
name|cpu_to_be32
argument_list|(
operator|(
name|sqp
operator|->
name|send_psn
operator|++
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|24
operator|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlx4_get_parav_qkey
argument_list|(
name|mdev
operator|->
name|dev
argument_list|,
name|sqp
operator|->
name|qp
operator|.
name|mqp
operator|.
name|qpn
argument_list|,
operator|&
name|qkey
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|sqp
operator|->
name|ud_header
operator|.
name|deth
operator|.
name|qkey
operator|=
name|cpu_to_be32
argument_list|(
name|qkey
argument_list|)
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|deth
operator|.
name|source_qpn
operator|=
name|cpu_to_be32
argument_list|(
name|sqp
operator|->
name|qp
operator|.
name|mqp
operator|.
name|qpn
argument_list|)
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|bth
operator|.
name|opcode
operator|=
name|IB_OPCODE_UD_SEND_ONLY
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|immediate_present
operator|=
literal|0
expr_stmt|;
name|header_size
operator|=
name|ib_ud_header_pack
argument_list|(
operator|&
name|sqp
operator|->
name|ud_header
argument_list|,
name|sqp
operator|->
name|header_buf
argument_list|)
expr_stmt|;
comment|/* 	 * Inline data segments may not cross a 64 byte boundary.  If 	 * our UD header is bigger than the space available up to the 	 * next 64 byte boundary in the WQE, use two inline data 	 * segments to hold the UD header. 	 */
name|spc
operator|=
name|MLX4_INLINE_ALIGN
operator|-
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|inl
operator|+
literal|1
argument_list|)
operator|&
operator|(
name|MLX4_INLINE_ALIGN
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|header_size
operator|<=
name|spc
condition|)
block|{
name|inl
operator|->
name|byte_count
operator|=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|31
operator||
name|header_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|inl
operator|+
literal|1
argument_list|,
name|sqp
operator|->
name|header_buf
argument_list|,
name|header_size
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|inl
operator|->
name|byte_count
operator|=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|31
operator||
name|spc
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|inl
operator|+
literal|1
argument_list|,
name|sqp
operator|->
name|header_buf
argument_list|,
name|spc
argument_list|)
expr_stmt|;
name|inl
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|inl
operator|+
literal|1
operator|)
operator|+
name|spc
expr_stmt|;
name|memcpy
argument_list|(
name|inl
operator|+
literal|1
argument_list|,
name|sqp
operator|->
name|header_buf
operator|+
name|spc
argument_list|,
name|header_size
operator|-
name|spc
argument_list|)
expr_stmt|;
comment|/* 		 * Need a barrier here to make sure all the data is 		 * visible before the byte_count field is set. 		 * Otherwise the HCA prefetcher could grab the 64-byte 		 * chunk with this inline segment and get a valid (!= 		 * 0xffffffff) byte count but stale data, and end up 		 * generating a packet with bad headers. 		 * 		 * The first inline segment's byte_count field doesn't 		 * need a barrier, because it comes after a 		 * control/MLX segment and therefore is at an offset 		 * of 16 mod 64. 		 */
name|wmb
argument_list|()
expr_stmt|;
name|inl
operator|->
name|byte_count
operator|=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|31
operator||
operator|(
name|header_size
operator|-
name|spc
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|2
expr_stmt|;
block|}
operator|*
name|mlx_seg_len
operator|=
name|ALIGN
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_inline_seg
argument_list|)
operator|+
name|header_size
argument_list|,
literal|16
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|build_mlx_header
parameter_list|(
name|struct
name|mlx4_ib_sqp
modifier|*
name|sqp
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|,
name|void
modifier|*
name|wqe
parameter_list|,
name|unsigned
modifier|*
name|mlx_seg_len
parameter_list|)
block|{
name|struct
name|ib_device
modifier|*
name|ib_dev
init|=
name|sqp
operator|->
name|qp
operator|.
name|ibqp
operator|.
name|device
decl_stmt|;
name|struct
name|mlx4_wqe_mlx_seg
modifier|*
name|mlx
init|=
name|wqe
decl_stmt|;
name|struct
name|mlx4_wqe_ctrl_seg
modifier|*
name|ctrl
init|=
name|wqe
decl_stmt|;
name|struct
name|mlx4_wqe_inline_seg
modifier|*
name|inl
init|=
name|wqe
operator|+
sizeof|sizeof
expr|*
name|mlx
decl_stmt|;
name|struct
name|mlx4_ib_ah
modifier|*
name|ah
init|=
name|to_mah
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|ah
argument_list|)
decl_stmt|;
name|union
name|ib_gid
name|sgid
decl_stmt|;
name|u16
name|pkey
decl_stmt|;
name|int
name|send_size
decl_stmt|;
name|int
name|header_size
decl_stmt|;
name|int
name|spc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|is_eth
decl_stmt|;
name|int
name|is_vlan
init|=
literal|0
decl_stmt|;
name|int
name|is_grh
decl_stmt|;
name|u16
name|vlan
init|=
literal|0
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|send_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wr
operator|->
name|num_sge
condition|;
operator|++
name|i
control|)
name|send_size
operator|+=
name|wr
operator|->
name|sg_list
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
name|is_eth
operator|=
name|rdma_port_get_link_layer
argument_list|(
name|sqp
operator|->
name|qp
operator|.
name|ibqp
operator|.
name|device
argument_list|,
name|sqp
operator|->
name|qp
operator|.
name|port
argument_list|)
operator|==
name|IB_LINK_LAYER_ETHERNET
expr_stmt|;
name|is_grh
operator|=
name|mlx4_ib_ah_grh_present
argument_list|(
name|ah
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_eth
condition|)
block|{
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|to_mdev
argument_list|(
name|ib_dev
argument_list|)
operator|->
name|dev
argument_list|)
condition|)
block|{
comment|/* When multi-function is enabled, the ib_core gid 			 * indexes don't necessarily match the hw ones, so 			 * we must use our own cache */
name|err
operator|=
name|mlx4_get_roce_gid_from_slave
argument_list|(
name|to_mdev
argument_list|(
name|ib_dev
argument_list|)
operator|->
name|dev
argument_list|,
name|be32_to_cpu
argument_list|(
name|ah
operator|->
name|av
operator|.
name|ib
operator|.
name|port_pd
argument_list|)
operator|>>
literal|24
argument_list|,
name|ah
operator|->
name|av
operator|.
name|ib
operator|.
name|gid_index
argument_list|,
operator|&
name|sgid
operator|.
name|raw
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
block|}
else|else
block|{
name|err
operator|=
name|ib_get_cached_gid
argument_list|(
name|ib_dev
argument_list|,
name|be32_to_cpu
argument_list|(
name|ah
operator|->
name|av
operator|.
name|ib
operator|.
name|port_pd
argument_list|)
operator|>>
literal|24
argument_list|,
name|ah
operator|->
name|av
operator|.
name|ib
operator|.
name|gid_index
argument_list|,
operator|&
name|sgid
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
block|}
name|vlan
operator|=
name|rdma_get_vlan_id
argument_list|(
operator|&
name|sgid
argument_list|)
expr_stmt|;
name|is_vlan
operator|=
name|vlan
operator|<
literal|0x1000
expr_stmt|;
block|}
name|ib_ud_header_init
argument_list|(
name|send_size
argument_list|,
operator|!
name|is_eth
argument_list|,
name|is_eth
argument_list|,
name|is_vlan
argument_list|,
name|is_grh
argument_list|,
literal|0
argument_list|,
operator|&
name|sqp
operator|->
name|ud_header
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_eth
condition|)
block|{
name|sqp
operator|->
name|ud_header
operator|.
name|lrh
operator|.
name|service_level
operator|=
name|be32_to_cpu
argument_list|(
name|ah
operator|->
name|av
operator|.
name|ib
operator|.
name|sl_tclass_flowlabel
argument_list|)
operator|>>
literal|28
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|lrh
operator|.
name|destination_lid
operator|=
name|ah
operator|->
name|av
operator|.
name|ib
operator|.
name|dlid
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|lrh
operator|.
name|source_lid
operator|=
name|cpu_to_be16
argument_list|(
name|ah
operator|->
name|av
operator|.
name|ib
operator|.
name|g_slid
operator|&
literal|0x7f
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_grh
condition|)
block|{
name|sqp
operator|->
name|ud_header
operator|.
name|grh
operator|.
name|traffic_class
operator|=
operator|(
name|be32_to_cpu
argument_list|(
name|ah
operator|->
name|av
operator|.
name|ib
operator|.
name|sl_tclass_flowlabel
argument_list|)
operator|>>
literal|20
operator|)
operator|&
literal|0xff
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|grh
operator|.
name|flow_label
operator|=
name|ah
operator|->
name|av
operator|.
name|ib
operator|.
name|sl_tclass_flowlabel
operator|&
name|cpu_to_be32
argument_list|(
literal|0xfffff
argument_list|)
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|grh
operator|.
name|hop_limit
operator|=
name|ah
operator|->
name|av
operator|.
name|ib
operator|.
name|hop_limit
expr_stmt|;
if|if
condition|(
name|is_eth
condition|)
name|memcpy
argument_list|(
name|sqp
operator|->
name|ud_header
operator|.
name|grh
operator|.
name|source_gid
operator|.
name|raw
argument_list|,
name|sgid
operator|.
name|raw
argument_list|,
literal|16
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|mlx4_is_mfunc
argument_list|(
name|to_mdev
argument_list|(
name|ib_dev
argument_list|)
operator|->
name|dev
argument_list|)
condition|)
block|{
comment|/* When multi-function is enabled, the ib_core gid 			 * indexes don't necessarily match the hw ones, so 			 * we must use our own cache */
name|sqp
operator|->
name|ud_header
operator|.
name|grh
operator|.
name|source_gid
operator|.
name|global
operator|.
name|subnet_prefix
operator|=
name|to_mdev
argument_list|(
name|ib_dev
argument_list|)
operator|->
name|sriov
operator|.
name|demux
index|[
name|sqp
operator|->
name|qp
operator|.
name|port
operator|-
literal|1
index|]
operator|.
name|subnet_prefix
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|grh
operator|.
name|source_gid
operator|.
name|global
operator|.
name|interface_id
operator|=
name|to_mdev
argument_list|(
name|ib_dev
argument_list|)
operator|->
name|sriov
operator|.
name|demux
index|[
name|sqp
operator|->
name|qp
operator|.
name|port
operator|-
literal|1
index|]
operator|.
name|guid_cache
index|[
name|ah
operator|->
name|av
operator|.
name|ib
operator|.
name|gid_index
index|]
expr_stmt|;
block|}
else|else
name|ib_get_cached_gid
argument_list|(
name|ib_dev
argument_list|,
name|be32_to_cpu
argument_list|(
name|ah
operator|->
name|av
operator|.
name|ib
operator|.
name|port_pd
argument_list|)
operator|>>
literal|24
argument_list|,
name|ah
operator|->
name|av
operator|.
name|ib
operator|.
name|gid_index
argument_list|,
operator|&
name|sqp
operator|->
name|ud_header
operator|.
name|grh
operator|.
name|source_gid
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|sqp
operator|->
name|ud_header
operator|.
name|grh
operator|.
name|destination_gid
operator|.
name|raw
argument_list|,
name|ah
operator|->
name|av
operator|.
name|ib
operator|.
name|dgid
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
name|mlx
operator|->
name|flags
operator|&=
name|cpu_to_be32
argument_list|(
name|MLX4_WQE_CTRL_CQ_UPDATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_eth
condition|)
block|{
name|mlx
operator|->
name|flags
operator||=
name|cpu_to_be32
argument_list|(
operator|(
operator|!
name|sqp
operator|->
name|qp
operator|.
name|ibqp
operator|.
name|qp_num
condition|?
name|MLX4_WQE_MLX_VL15
else|:
literal|0
operator|)
operator||
operator|(
name|sqp
operator|->
name|ud_header
operator|.
name|lrh
operator|.
name|destination_lid
operator|==
name|IB_LID_PERMISSIVE
condition|?
name|MLX4_WQE_MLX_SLR
else|:
literal|0
operator|)
operator||
operator|(
name|sqp
operator|->
name|ud_header
operator|.
name|lrh
operator|.
name|service_level
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ah
operator|->
name|av
operator|.
name|ib
operator|.
name|port_pd
operator|&
name|cpu_to_be32
argument_list|(
literal|0x80000000
argument_list|)
condition|)
name|mlx
operator|->
name|flags
operator||=
name|cpu_to_be32
argument_list|(
literal|0x1
argument_list|)
expr_stmt|;
comment|/* force loopback */
name|mlx
operator|->
name|rlid
operator|=
name|sqp
operator|->
name|ud_header
operator|.
name|lrh
operator|.
name|destination_lid
expr_stmt|;
block|}
switch|switch
condition|(
name|wr
operator|->
name|opcode
condition|)
block|{
case|case
name|IB_WR_SEND
case|:
name|sqp
operator|->
name|ud_header
operator|.
name|bth
operator|.
name|opcode
operator|=
name|IB_OPCODE_UD_SEND_ONLY
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|immediate_present
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IB_WR_SEND_WITH_IMM
case|:
name|sqp
operator|->
name|ud_header
operator|.
name|bth
operator|.
name|opcode
operator|=
name|IB_OPCODE_UD_SEND_ONLY_WITH_IMMEDIATE
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|immediate_present
operator|=
literal|1
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|immediate_data
operator|=
name|wr
operator|->
name|ex
operator|.
name|imm_data
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|is_eth
condition|)
block|{
name|u8
name|smac
index|[
literal|6
index|]
decl_stmt|;
name|struct
name|in6_addr
name|in6
decl_stmt|;
name|u16
name|pcp
init|=
operator|(
name|be32_to_cpu
argument_list|(
name|ah
operator|->
name|av
operator|.
name|ib
operator|.
name|sl_tclass_flowlabel
argument_list|)
operator|>>
literal|29
operator|)
operator|<<
literal|13
decl_stmt|;
name|mlx
operator|->
name|sched_prio
operator|=
name|cpu_to_be16
argument_list|(
name|pcp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sqp
operator|->
name|ud_header
operator|.
name|eth
operator|.
name|dmac_h
argument_list|,
name|ah
operator|->
name|av
operator|.
name|eth
operator|.
name|mac
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* FIXME: cache smac value? */
name|memcpy
argument_list|(
operator|&
name|ctrl
operator|->
name|srcrb_flags16
index|[
literal|0
index|]
argument_list|,
name|ah
operator|->
name|av
operator|.
name|eth
operator|.
name|mac
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ctrl
operator|->
name|imm
argument_list|,
name|ah
operator|->
name|av
operator|.
name|eth
operator|.
name|mac
operator|+
literal|2
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|in6
argument_list|,
name|sgid
operator|.
name|raw
argument_list|,
sizeof|sizeof
argument_list|(
name|in6
argument_list|)
argument_list|)
expr_stmt|;
name|rdma_get_ll_mac
argument_list|(
operator|&
name|in6
argument_list|,
name|smac
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sqp
operator|->
name|ud_header
operator|.
name|eth
operator|.
name|smac_h
argument_list|,
name|smac
argument_list|,
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|sqp
operator|->
name|ud_header
operator|.
name|eth
operator|.
name|smac_h
argument_list|,
name|sqp
operator|->
name|ud_header
operator|.
name|eth
operator|.
name|dmac_h
argument_list|,
literal|6
argument_list|)
condition|)
name|mlx
operator|->
name|flags
operator||=
name|cpu_to_be32
argument_list|(
name|MLX4_WQE_CTRL_FORCE_LOOPBACK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_vlan
condition|)
block|{
name|sqp
operator|->
name|ud_header
operator|.
name|eth
operator|.
name|type
operator|=
name|cpu_to_be16
argument_list|(
name|MLX4_IB_IBOE_ETHERTYPE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sqp
operator|->
name|ud_header
operator|.
name|vlan
operator|.
name|type
operator|=
name|cpu_to_be16
argument_list|(
name|MLX4_IB_IBOE_ETHERTYPE
argument_list|)
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|vlan
operator|.
name|tag
operator|=
name|cpu_to_be16
argument_list|(
name|vlan
operator||
name|pcp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sqp
operator|->
name|ud_header
operator|.
name|lrh
operator|.
name|virtual_lane
operator|=
operator|!
name|sqp
operator|->
name|qp
operator|.
name|ibqp
operator|.
name|qp_num
condition|?
literal|15
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|sqp
operator|->
name|ud_header
operator|.
name|lrh
operator|.
name|destination_lid
operator|==
name|IB_LID_PERMISSIVE
condition|)
name|sqp
operator|->
name|ud_header
operator|.
name|lrh
operator|.
name|source_lid
operator|=
name|IB_LID_PERMISSIVE
expr_stmt|;
block|}
name|sqp
operator|->
name|ud_header
operator|.
name|bth
operator|.
name|solicited_event
operator|=
operator|!
operator|!
operator|(
name|wr
operator|->
name|send_flags
operator|&
name|IB_SEND_SOLICITED
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|sqp
operator|->
name|qp
operator|.
name|ibqp
operator|.
name|qp_num
condition|)
name|ib_get_cached_pkey
argument_list|(
name|ib_dev
argument_list|,
name|sqp
operator|->
name|qp
operator|.
name|port
argument_list|,
name|sqp
operator|->
name|pkey_index
argument_list|,
operator|&
name|pkey
argument_list|)
expr_stmt|;
else|else
name|ib_get_cached_pkey
argument_list|(
name|ib_dev
argument_list|,
name|sqp
operator|->
name|qp
operator|.
name|port
argument_list|,
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|pkey_index
argument_list|,
operator|&
name|pkey
argument_list|)
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|bth
operator|.
name|pkey
operator|=
name|cpu_to_be16
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|bth
operator|.
name|destination_qpn
operator|=
name|cpu_to_be32
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|remote_qpn
argument_list|)
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|bth
operator|.
name|psn
operator|=
name|cpu_to_be32
argument_list|(
operator|(
name|sqp
operator|->
name|send_psn
operator|++
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|24
operator|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|deth
operator|.
name|qkey
operator|=
name|cpu_to_be32
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|remote_qkey
operator|&
literal|0x80000000
condition|?
name|sqp
operator|->
name|qkey
else|:
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|remote_qkey
argument_list|)
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|deth
operator|.
name|source_qpn
operator|=
name|cpu_to_be32
argument_list|(
name|sqp
operator|->
name|qp
operator|.
name|ibqp
operator|.
name|qp_num
argument_list|)
expr_stmt|;
name|header_size
operator|=
name|ib_ud_header_pack
argument_list|(
operator|&
name|sqp
operator|->
name|ud_header
argument_list|,
name|sqp
operator|->
name|header_buf
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
condition|)
block|{
name|pr_err
argument_list|(
literal|"built UD header of size %d:\n"
argument_list|,
name|header_size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|header_size
operator|/
literal|4
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|8
operator|==
literal|0
condition|)
name|pr_err
argument_list|(
literal|"  [%02x] "
argument_list|,
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
name|pr_cont
argument_list|(
literal|" %08x"
argument_list|,
name|be32_to_cpu
argument_list|(
operator|(
operator|(
name|__be32
operator|*
operator|)
name|sqp
operator|->
name|header_buf
operator|)
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
literal|8
operator|==
literal|0
condition|)
name|pr_cont
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|pr_err
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Inline data segments may not cross a 64 byte boundary.  If 	 * our UD header is bigger than the space available up to the 	 * next 64 byte boundary in the WQE, use two inline data 	 * segments to hold the UD header. 	 */
name|spc
operator|=
name|MLX4_INLINE_ALIGN
operator|-
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|inl
operator|+
literal|1
argument_list|)
operator|&
operator|(
name|MLX4_INLINE_ALIGN
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|header_size
operator|<=
name|spc
condition|)
block|{
name|inl
operator|->
name|byte_count
operator|=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|31
operator||
name|header_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|inl
operator|+
literal|1
argument_list|,
name|sqp
operator|->
name|header_buf
argument_list|,
name|header_size
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|inl
operator|->
name|byte_count
operator|=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|31
operator||
name|spc
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|inl
operator|+
literal|1
argument_list|,
name|sqp
operator|->
name|header_buf
argument_list|,
name|spc
argument_list|)
expr_stmt|;
name|inl
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|inl
operator|+
literal|1
operator|)
operator|+
name|spc
expr_stmt|;
name|memcpy
argument_list|(
name|inl
operator|+
literal|1
argument_list|,
name|sqp
operator|->
name|header_buf
operator|+
name|spc
argument_list|,
name|header_size
operator|-
name|spc
argument_list|)
expr_stmt|;
comment|/* 		 * Need a barrier here to make sure all the data is 		 * visible before the byte_count field is set. 		 * Otherwise the HCA prefetcher could grab the 64-byte 		 * chunk with this inline segment and get a valid (!= 		 * 0xffffffff) byte count but stale data, and end up 		 * generating a packet with bad headers. 		 * 		 * The first inline segment's byte_count field doesn't 		 * need a barrier, because it comes after a 		 * control/MLX segment and therefore is at an offset 		 * of 16 mod 64. 		 */
name|wmb
argument_list|()
expr_stmt|;
name|inl
operator|->
name|byte_count
operator|=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|31
operator||
operator|(
name|header_size
operator|-
name|spc
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|2
expr_stmt|;
block|}
operator|*
name|mlx_seg_len
operator|=
name|ALIGN
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_inline_seg
argument_list|)
operator|+
name|header_size
argument_list|,
literal|16
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mlx4_wq_overflow
parameter_list|(
name|struct
name|mlx4_ib_wq
modifier|*
name|wq
parameter_list|,
name|int
name|nreq
parameter_list|,
name|struct
name|ib_cq
modifier|*
name|ib_cq
parameter_list|)
block|{
name|unsigned
name|cur
decl_stmt|;
name|struct
name|mlx4_ib_cq
modifier|*
name|cq
decl_stmt|;
name|cur
operator|=
name|wq
operator|->
name|head
operator|-
name|wq
operator|->
name|tail
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|cur
operator|+
name|nreq
operator|<
name|wq
operator|->
name|max_post
argument_list|)
condition|)
return|return
literal|0
return|;
name|cq
operator|=
name|to_mcq
argument_list|(
name|ib_cq
argument_list|)
expr_stmt|;
name|spin_lock
argument_list|(
operator|&
name|cq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cur
operator|=
name|wq
operator|->
name|head
operator|-
name|wq
operator|->
name|tail
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|cq
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|cur
operator|+
name|nreq
operator|>=
name|wq
operator|->
name|max_post
return|;
block|}
end_function

begin_function
specifier|static
name|__be32
name|convert_access
parameter_list|(
name|int
name|acc
parameter_list|)
block|{
return|return
operator|(
name|acc
operator|&
name|IB_ACCESS_REMOTE_ATOMIC
condition|?
name|cpu_to_be32
argument_list|(
name|MLX4_WQE_FMR_PERM_ATOMIC
argument_list|)
else|:
literal|0
operator|)
operator||
operator|(
name|acc
operator|&
name|IB_ACCESS_REMOTE_WRITE
condition|?
name|cpu_to_be32
argument_list|(
name|MLX4_WQE_FMR_PERM_REMOTE_WRITE
argument_list|)
else|:
literal|0
operator|)
operator||
operator|(
name|acc
operator|&
name|IB_ACCESS_REMOTE_READ
condition|?
name|cpu_to_be32
argument_list|(
name|MLX4_WQE_FMR_PERM_REMOTE_READ
argument_list|)
else|:
literal|0
operator|)
operator||
operator|(
name|acc
operator|&
name|IB_ACCESS_LOCAL_WRITE
condition|?
name|cpu_to_be32
argument_list|(
name|MLX4_WQE_FMR_PERM_LOCAL_WRITE
argument_list|)
else|:
literal|0
operator|)
operator||
name|cpu_to_be32
argument_list|(
name|MLX4_WQE_FMR_PERM_LOCAL_READ
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_fmr_seg
parameter_list|(
name|struct
name|mlx4_wqe_fmr_seg
modifier|*
name|fseg
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|)
block|{
name|struct
name|mlx4_ib_fast_reg_page_list
modifier|*
name|mfrpl
init|=
name|to_mfrpl
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|fast_reg
operator|.
name|page_list
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wr
operator|->
name|wr
operator|.
name|fast_reg
operator|.
name|page_list_len
condition|;
operator|++
name|i
control|)
name|mfrpl
operator|->
name|mapped_page_list
index|[
name|i
index|]
operator|=
name|cpu_to_be64
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|fast_reg
operator|.
name|page_list
operator|->
name|page_list
index|[
name|i
index|]
operator||
name|MLX4_MTT_FLAG_PRESENT
argument_list|)
expr_stmt|;
name|fseg
operator|->
name|flags
operator|=
name|convert_access
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|fast_reg
operator|.
name|access_flags
argument_list|)
expr_stmt|;
name|fseg
operator|->
name|mem_key
operator|=
name|cpu_to_be32
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|fast_reg
operator|.
name|rkey
argument_list|)
expr_stmt|;
name|fseg
operator|->
name|buf_list
operator|=
name|cpu_to_be64
argument_list|(
name|mfrpl
operator|->
name|map
argument_list|)
expr_stmt|;
name|fseg
operator|->
name|start_addr
operator|=
name|cpu_to_be64
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|fast_reg
operator|.
name|iova_start
argument_list|)
expr_stmt|;
name|fseg
operator|->
name|reg_len
operator|=
name|cpu_to_be64
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|fast_reg
operator|.
name|length
argument_list|)
expr_stmt|;
name|fseg
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* XXX -- is this just for ZBVA? */
name|fseg
operator|->
name|page_size
operator|=
name|cpu_to_be32
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|fast_reg
operator|.
name|page_shift
argument_list|)
expr_stmt|;
name|fseg
operator|->
name|reserved
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|fseg
operator|->
name|reserved
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_local_inv_seg
parameter_list|(
name|struct
name|mlx4_wqe_local_inval_seg
modifier|*
name|iseg
parameter_list|,
name|u32
name|rkey
parameter_list|)
block|{
name|iseg
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|iseg
operator|->
name|mem_key
operator|=
name|cpu_to_be32
argument_list|(
name|rkey
argument_list|)
expr_stmt|;
name|iseg
operator|->
name|guest_id
operator|=
literal|0
expr_stmt|;
name|iseg
operator|->
name|pa
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__always_inline
name|void
name|set_raddr_seg
parameter_list|(
name|struct
name|mlx4_wqe_raddr_seg
modifier|*
name|rseg
parameter_list|,
name|u64
name|remote_addr
parameter_list|,
name|u32
name|rkey
parameter_list|)
block|{
name|rseg
operator|->
name|raddr
operator|=
name|cpu_to_be64
argument_list|(
name|remote_addr
argument_list|)
expr_stmt|;
name|rseg
operator|->
name|rkey
operator|=
name|cpu_to_be32
argument_list|(
name|rkey
argument_list|)
expr_stmt|;
name|rseg
operator|->
name|reserved
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_atomic_seg
parameter_list|(
name|struct
name|mlx4_wqe_atomic_seg
modifier|*
name|aseg
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|)
block|{
if|if
condition|(
name|wr
operator|->
name|opcode
operator|==
name|IB_WR_ATOMIC_CMP_AND_SWP
condition|)
block|{
name|aseg
operator|->
name|swap_add
operator|=
name|cpu_to_be64
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|atomic
operator|.
name|swap
argument_list|)
expr_stmt|;
name|aseg
operator|->
name|compare
operator|=
name|cpu_to_be64
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|atomic
operator|.
name|compare_add
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wr
operator|->
name|opcode
operator|==
name|IB_WR_MASKED_ATOMIC_FETCH_AND_ADD
condition|)
block|{
name|aseg
operator|->
name|swap_add
operator|=
name|cpu_to_be64
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|atomic
operator|.
name|compare_add
argument_list|)
expr_stmt|;
name|aseg
operator|->
name|compare
operator|=
name|cpu_to_be64
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|atomic
operator|.
name|compare_add_mask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aseg
operator|->
name|swap_add
operator|=
name|cpu_to_be64
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|atomic
operator|.
name|compare_add
argument_list|)
expr_stmt|;
name|aseg
operator|->
name|compare
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_masked_atomic_seg
parameter_list|(
name|struct
name|mlx4_wqe_masked_atomic_seg
modifier|*
name|aseg
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|)
block|{
name|aseg
operator|->
name|swap_add
operator|=
name|cpu_to_be64
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|atomic
operator|.
name|swap
argument_list|)
expr_stmt|;
name|aseg
operator|->
name|swap_add_mask
operator|=
name|cpu_to_be64
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|atomic
operator|.
name|swap_mask
argument_list|)
expr_stmt|;
name|aseg
operator|->
name|compare
operator|=
name|cpu_to_be64
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|atomic
operator|.
name|compare_add
argument_list|)
expr_stmt|;
name|aseg
operator|->
name|compare_mask
operator|=
name|cpu_to_be64
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|atomic
operator|.
name|compare_add_mask
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_datagram_seg
parameter_list|(
name|struct
name|mlx4_wqe_datagram_seg
modifier|*
name|dseg
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|)
block|{
name|memcpy
argument_list|(
name|dseg
operator|->
name|av
argument_list|,
operator|&
name|to_mah
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|ah
argument_list|)
operator|->
name|av
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_av
argument_list|)
argument_list|)
expr_stmt|;
name|dseg
operator|->
name|dqpn
operator|=
name|cpu_to_be32
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|remote_qpn
argument_list|)
expr_stmt|;
name|dseg
operator|->
name|qkey
operator|=
name|cpu_to_be32
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|remote_qkey
argument_list|)
expr_stmt|;
name|dseg
operator|->
name|vlan
operator|=
name|to_mah
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|ah
argument_list|)
operator|->
name|av
operator|.
name|eth
operator|.
name|vlan
expr_stmt|;
name|memcpy
argument_list|(
name|dseg
operator|->
name|mac
argument_list|,
name|to_mah
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|ah
argument_list|)
operator|->
name|av
operator|.
name|eth
operator|.
name|mac
argument_list|,
literal|6
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_tunnel_datagram_seg
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mlx4_wqe_datagram_seg
modifier|*
name|dseg
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|,
name|enum
name|ib_qp_type
name|qpt
parameter_list|)
block|{
name|union
name|mlx4_ext_av
modifier|*
name|av
init|=
operator|&
name|to_mah
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|ah
argument_list|)
operator|->
name|av
decl_stmt|;
name|struct
name|mlx4_av
name|sqp_av
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|port
init|=
operator|*
operator|(
operator|(
name|u8
operator|*
operator|)
operator|&
name|av
operator|->
name|ib
operator|.
name|port_pd
operator|)
operator|&
literal|0x3
decl_stmt|;
comment|/* force loopback */
name|sqp_av
operator|.
name|port_pd
operator|=
name|av
operator|->
name|ib
operator|.
name|port_pd
operator||
name|cpu_to_be32
argument_list|(
literal|0x80000000
argument_list|)
expr_stmt|;
name|sqp_av
operator|.
name|g_slid
operator|=
name|av
operator|->
name|ib
operator|.
name|g_slid
operator|&
literal|0x7f
expr_stmt|;
comment|/* no GRH */
name|sqp_av
operator|.
name|sl_tclass_flowlabel
operator|=
name|av
operator|->
name|ib
operator|.
name|sl_tclass_flowlabel
operator|&
name|cpu_to_be32
argument_list|(
literal|0xf0000000
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dseg
operator|->
name|av
argument_list|,
operator|&
name|sqp_av
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_av
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This function used only for sending on QP1 proxies */
name|dseg
operator|->
name|dqpn
operator|=
name|cpu_to_be32
argument_list|(
name|dev
operator|->
name|dev
operator|->
name|caps
operator|.
name|qp1_tunnel
index|[
name|port
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* Use QKEY from the QP context, which is set by master */
name|dseg
operator|->
name|qkey
operator|=
name|cpu_to_be32
argument_list|(
name|IB_QP_SET_QKEY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|build_tunnel_header
parameter_list|(
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|,
name|void
modifier|*
name|wqe
parameter_list|,
name|unsigned
modifier|*
name|mlx_seg_len
parameter_list|)
block|{
name|struct
name|mlx4_wqe_inline_seg
modifier|*
name|inl
init|=
name|wqe
decl_stmt|;
name|struct
name|mlx4_ib_tunnel_header
name|hdr
decl_stmt|;
name|struct
name|mlx4_ib_ah
modifier|*
name|ah
init|=
name|to_mah
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|ah
argument_list|)
decl_stmt|;
name|int
name|spc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|hdr
operator|.
name|av
argument_list|,
operator|&
name|ah
operator|->
name|av
argument_list|,
sizeof|sizeof
name|hdr
operator|.
name|av
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|remote_qpn
operator|=
name|cpu_to_be32
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|remote_qpn
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|pkey_index
operator|=
name|cpu_to_be16
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|pkey_index
argument_list|)
expr_stmt|;
name|hdr
operator|.
name|qkey
operator|=
name|cpu_to_be32
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|remote_qkey
argument_list|)
expr_stmt|;
name|spc
operator|=
name|MLX4_INLINE_ALIGN
operator|-
operator|(
call|(
name|unsigned
name|long
call|)
argument_list|(
name|inl
operator|+
literal|1
argument_list|)
operator|&
operator|(
name|MLX4_INLINE_ALIGN
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
operator|<=
name|spc
condition|)
block|{
name|memcpy
argument_list|(
name|inl
operator|+
literal|1
argument_list|,
operator|&
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|inl
operator|->
name|byte_count
operator|=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|31
operator||
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|inl
operator|+
literal|1
argument_list|,
operator|&
name|hdr
argument_list|,
name|spc
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|inl
operator|->
name|byte_count
operator|=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|31
operator||
name|spc
argument_list|)
expr_stmt|;
name|inl
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|inl
operator|+
literal|1
operator|)
operator|+
name|spc
expr_stmt|;
name|memcpy
argument_list|(
name|inl
operator|+
literal|1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|hdr
operator|+
name|spc
argument_list|,
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
operator|-
name|spc
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|inl
operator|->
name|byte_count
operator|=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|31
operator||
operator|(
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
operator|-
name|spc
operator|)
argument_list|)
expr_stmt|;
name|i
operator|=
literal|2
expr_stmt|;
block|}
operator|*
name|mlx_seg_len
operator|=
name|ALIGN
argument_list|(
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_inline_seg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|hdr
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_mlx_icrc_seg
parameter_list|(
name|void
modifier|*
name|dseg
parameter_list|)
block|{
name|u32
modifier|*
name|t
init|=
name|dseg
decl_stmt|;
name|struct
name|mlx4_wqe_inline_seg
modifier|*
name|iseg
init|=
name|dseg
decl_stmt|;
name|t
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Need a barrier here before writing the byte_count field to 	 * make sure that all the data is visible before the 	 * byte_count field is set.  Otherwise, if the segment begins 	 * a new cacheline, the HCA prefetcher could grab the 64-byte 	 * chunk and get a valid (!= * 0xffffffff) byte count but 	 * stale data, and end up sending the wrong data. 	 */
name|wmb
argument_list|()
expr_stmt|;
name|iseg
operator|->
name|byte_count
operator|=
name|cpu_to_be32
argument_list|(
operator|(
literal|1
operator|<<
literal|31
operator|)
operator||
literal|4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_data_seg
parameter_list|(
name|struct
name|mlx4_wqe_data_seg
modifier|*
name|dseg
parameter_list|,
name|struct
name|ib_sge
modifier|*
name|sg
parameter_list|)
block|{
name|dseg
operator|->
name|lkey
operator|=
name|cpu_to_be32
argument_list|(
name|sg
operator|->
name|lkey
argument_list|)
expr_stmt|;
name|dseg
operator|->
name|addr
operator|=
name|cpu_to_be64
argument_list|(
name|sg
operator|->
name|addr
argument_list|)
expr_stmt|;
comment|/* 	 * Need a barrier here before writing the byte_count field to 	 * make sure that all the data is visible before the 	 * byte_count field is set.  Otherwise, if the segment begins 	 * a new cacheline, the HCA prefetcher could grab the 64-byte 	 * chunk and get a valid (!= * 0xffffffff) byte count but 	 * stale data, and end up sending the wrong data. 	 */
name|wmb
argument_list|()
expr_stmt|;
name|dseg
operator|->
name|byte_count
operator|=
name|cpu_to_be32
argument_list|(
name|sg
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|__set_data_seg
parameter_list|(
name|struct
name|mlx4_wqe_data_seg
modifier|*
name|dseg
parameter_list|,
name|struct
name|ib_sge
modifier|*
name|sg
parameter_list|)
block|{
name|dseg
operator|->
name|byte_count
operator|=
name|cpu_to_be32
argument_list|(
name|sg
operator|->
name|length
argument_list|)
expr_stmt|;
name|dseg
operator|->
name|lkey
operator|=
name|cpu_to_be32
argument_list|(
name|sg
operator|->
name|lkey
argument_list|)
expr_stmt|;
name|dseg
operator|->
name|addr
operator|=
name|cpu_to_be64
argument_list|(
name|sg
operator|->
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|build_lso_seg
parameter_list|(
name|struct
name|mlx4_wqe_lso_seg
modifier|*
name|wqe
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|,
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|,
name|unsigned
modifier|*
name|lso_seg_len
parameter_list|,
name|__be32
modifier|*
name|lso_hdr_sz
parameter_list|,
name|__be32
modifier|*
name|blh
parameter_list|)
block|{
name|unsigned
name|halign
init|=
name|ALIGN
argument_list|(
sizeof|sizeof
expr|*
name|wqe
operator|+
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|hlen
argument_list|,
literal|16
argument_list|)
decl_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|halign
operator|>
name|MLX4_IB_CACHE_LINE_SIZE
argument_list|)
condition|)
operator|*
name|blh
operator|=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
operator|!
operator|(
name|qp
operator|->
name|flags
operator|&
name|MLX4_IB_QP_LSO
operator|)
operator|&&
name|wr
operator|->
name|num_sge
operator|>
name|qp
operator|->
name|sq
operator|.
name|max_gs
operator|-
operator|(
name|halign
operator|>>
literal|4
operator|)
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|memcpy
argument_list|(
name|wqe
operator|->
name|header
argument_list|,
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|header
argument_list|,
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|hlen
argument_list|)
expr_stmt|;
operator|*
name|lso_hdr_sz
operator|=
name|cpu_to_be32
argument_list|(
operator|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|mss
operator|-
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|hlen
operator|)
operator|<<
literal|16
operator||
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|hlen
argument_list|)
expr_stmt|;
operator|*
name|lso_seg_len
operator|=
name|halign
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|__be32
name|send_ieth
parameter_list|(
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|)
block|{
switch|switch
condition|(
name|wr
operator|->
name|opcode
condition|)
block|{
case|case
name|IB_WR_SEND_WITH_IMM
case|:
case|case
name|IB_WR_RDMA_WRITE_WITH_IMM
case|:
return|return
name|wr
operator|->
name|ex
operator|.
name|imm_data
return|;
case|case
name|IB_WR_SEND_WITH_INV
case|:
return|return
name|cpu_to_be32
argument_list|(
name|wr
operator|->
name|ex
operator|.
name|invalidate_rkey
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|add_zero_len_inline
parameter_list|(
name|void
modifier|*
name|wqe
parameter_list|)
block|{
name|struct
name|mlx4_wqe_inline_seg
modifier|*
name|inl
init|=
name|wqe
decl_stmt|;
name|memset
argument_list|(
name|wqe
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|inl
operator|->
name|byte_count
operator|=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|31
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|lay_inline_data
parameter_list|(
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|,
name|void
modifier|*
name|wqe
parameter_list|,
name|int
modifier|*
name|sz
parameter_list|)
block|{
name|struct
name|mlx4_wqe_inline_seg
modifier|*
name|seg
decl_stmt|;
name|void
modifier|*
name|addr
decl_stmt|;
name|int
name|len
decl_stmt|,
name|seg_len
decl_stmt|;
name|int
name|num_seg
decl_stmt|;
name|int
name|off
decl_stmt|,
name|to_copy
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|inl
init|=
literal|0
decl_stmt|;
name|seg
operator|=
name|wqe
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
expr|*
name|seg
expr_stmt|;
name|off
operator|=
operator|(
operator|(
name|unsigned
name|long
operator|)
name|wqe
operator|)
operator|&
call|(
name|unsigned
name|long
call|)
argument_list|(
name|MLX4_INLINE_ALIGN
operator|-
literal|1
argument_list|)
expr_stmt|;
name|num_seg
operator|=
literal|0
expr_stmt|;
name|seg_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wr
operator|->
name|num_sge
condition|;
operator|++
name|i
control|)
block|{
name|addr
operator|=
operator|(
name|void
operator|*
operator|)
call|(
name|unsigned
name|long
call|)
argument_list|(
name|wr
operator|->
name|sg_list
index|[
name|i
index|]
operator|.
name|addr
argument_list|)
expr_stmt|;
name|len
operator|=
name|wr
operator|->
name|sg_list
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
name|inl
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|inl
operator|>
name|qp
operator|->
name|max_inline_data
condition|)
block|{
name|inl
operator|=
literal|0
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
name|len
operator|>=
name|MLX4_INLINE_ALIGN
operator|-
name|off
condition|)
block|{
name|to_copy
operator|=
name|MLX4_INLINE_ALIGN
operator|-
name|off
expr_stmt|;
name|memcpy
argument_list|(
name|wqe
argument_list|,
name|addr
argument_list|,
name|to_copy
argument_list|)
expr_stmt|;
name|len
operator|-=
name|to_copy
expr_stmt|;
name|wqe
operator|+=
name|to_copy
expr_stmt|;
name|addr
operator|+=
name|to_copy
expr_stmt|;
name|seg_len
operator|+=
name|to_copy
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
comment|/* see comment below */
name|seg
operator|->
name|byte_count
operator|=
name|htonl
argument_list|(
name|MLX4_INLINE_SEG
operator||
name|seg_len
argument_list|)
expr_stmt|;
name|seg_len
operator|=
literal|0
expr_stmt|;
name|seg
operator|=
name|wqe
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
expr|*
name|seg
expr_stmt|;
name|off
operator|=
sizeof|sizeof
expr|*
name|seg
expr_stmt|;
operator|++
name|num_seg
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|wqe
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|wqe
operator|+=
name|len
expr_stmt|;
name|seg_len
operator|+=
name|len
expr_stmt|;
name|off
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|seg_len
condition|)
block|{
operator|++
name|num_seg
expr_stmt|;
comment|/* 		 * Need a barrier here to make sure 		 * all the data is visible before the 		 * byte_count field is set.  Otherwise 		 * the HCA prefetcher could grab the 		 * 64-byte chunk with this inline 		 * segment and get a valid (!= 		 * 0xffffffff) byte count but stale 		 * data, and end up sending the wrong 		 * data. 		 */
name|wmb
argument_list|()
expr_stmt|;
name|seg
operator|->
name|byte_count
operator|=
name|htonl
argument_list|(
name|MLX4_INLINE_SEG
operator||
name|seg_len
argument_list|)
expr_stmt|;
block|}
operator|*
name|sz
operator|=
operator|(
name|inl
operator|+
name|num_seg
operator|*
sizeof|sizeof
expr|*
name|seg
operator|+
literal|15
operator|)
operator|/
literal|16
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Avoid using memcpy() to copy to BlueFlame page, since memcpy()  * implementations may use move-string-buffer assembler instructions,  * which do not guarantee order of copying.  */
end_comment

begin_function
specifier|static
name|void
name|mlx4_bf_copy
parameter_list|(
name|unsigned
name|long
modifier|*
name|dst
parameter_list|,
name|unsigned
name|long
modifier|*
name|src
parameter_list|,
name|unsigned
name|bytecnt
parameter_list|)
block|{
name|__iowrite64_copy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|bytecnt
operator|/
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mlx4_ib_post_send
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|ibqp
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
modifier|*
name|bad_wr
parameter_list|)
block|{
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
init|=
name|to_mqp
argument_list|(
name|ibqp
argument_list|)
decl_stmt|;
name|void
modifier|*
name|wqe
decl_stmt|;
name|struct
name|mlx4_wqe_ctrl_seg
modifier|*
name|uninitialized_var
argument_list|(
name|ctrl
argument_list|)
decl_stmt|;
name|struct
name|mlx4_wqe_data_seg
modifier|*
name|dseg
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|nreq
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|unsigned
name|ind
decl_stmt|;
name|int
name|uninitialized_var
argument_list|(
name|stamp
argument_list|)
decl_stmt|;
name|int
name|uninitialized_var
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|unsigned
name|uninitialized_var
argument_list|(
name|seglen
argument_list|)
decl_stmt|;
name|__be32
name|dummy
decl_stmt|;
name|__be32
modifier|*
name|lso_wqe
decl_stmt|;
name|__be32
name|uninitialized_var
argument_list|(
name|lso_hdr_sz
argument_list|)
decl_stmt|;
name|__be32
name|blh
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|inl
init|=
literal|0
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|qp
operator|->
name|sq
operator|.
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ind
operator|=
name|qp
operator|->
name|sq_next_wqe
expr_stmt|;
for|for
control|(
name|nreq
operator|=
literal|0
init|;
name|wr
condition|;
operator|++
name|nreq
operator|,
name|wr
operator|=
name|wr
operator|->
name|next
control|)
block|{
name|lso_wqe
operator|=
operator|&
name|dummy
expr_stmt|;
name|blh
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mlx4_wq_overflow
argument_list|(
operator|&
name|qp
operator|->
name|sq
argument_list|,
name|nreq
argument_list|,
name|qp
operator|->
name|ibqp
operator|.
name|send_cq
argument_list|)
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
operator|*
name|bad_wr
operator|=
name|wr
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|wr
operator|->
name|num_sge
operator|>
name|qp
operator|->
name|sq
operator|.
name|max_gs
argument_list|)
condition|)
block|{
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
operator|*
name|bad_wr
operator|=
name|wr
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ctrl
operator|=
name|wqe
operator|=
name|get_send_wqe
argument_list|(
name|qp
argument_list|,
name|ind
operator|&
operator|(
name|qp
operator|->
name|sq
operator|.
name|wqe_cnt
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|u32
operator|*
operator|)
operator|(
operator|&
name|ctrl
operator|->
name|vlan_tag
operator|)
operator|)
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|sq
operator|.
name|wrid
index|[
operator|(
name|qp
operator|->
name|sq
operator|.
name|head
operator|+
name|nreq
operator|)
operator|&
operator|(
name|qp
operator|->
name|sq
operator|.
name|wqe_cnt
operator|-
literal|1
operator|)
index|]
operator|=
name|wr
operator|->
name|wr_id
expr_stmt|;
name|ctrl
operator|->
name|srcrb_flags
operator|=
operator|(
name|wr
operator|->
name|send_flags
operator|&
name|IB_SEND_SIGNALED
condition|?
name|cpu_to_be32
argument_list|(
name|MLX4_WQE_CTRL_CQ_UPDATE
argument_list|)
else|:
literal|0
operator|)
operator||
operator|(
name|wr
operator|->
name|send_flags
operator|&
name|IB_SEND_SOLICITED
condition|?
name|cpu_to_be32
argument_list|(
name|MLX4_WQE_CTRL_SOLICITED
argument_list|)
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|wr
operator|->
name|send_flags
operator|&
name|IB_SEND_IP_CSUM
operator|)
condition|?
name|cpu_to_be32
argument_list|(
name|MLX4_WQE_CTRL_IP_CSUM
operator||
name|MLX4_WQE_CTRL_TCP_UDP_CSUM
argument_list|)
else|:
literal|0
operator|)
operator||
name|qp
operator|->
name|sq_signal_bits
expr_stmt|;
name|ctrl
operator|->
name|imm
operator|=
name|send_ieth
argument_list|(
name|wr
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
expr|*
name|ctrl
expr_stmt|;
name|size
operator|=
sizeof|sizeof
expr|*
name|ctrl
operator|/
literal|16
expr_stmt|;
switch|switch
condition|(
name|qp
operator|->
name|mlx4_ib_qp_type
condition|)
block|{
case|case
name|MLX4_IB_QPT_RC
case|:
case|case
name|MLX4_IB_QPT_UC
case|:
switch|switch
condition|(
name|wr
operator|->
name|opcode
condition|)
block|{
case|case
name|IB_WR_ATOMIC_CMP_AND_SWP
case|:
case|case
name|IB_WR_ATOMIC_FETCH_AND_ADD
case|:
case|case
name|IB_WR_MASKED_ATOMIC_FETCH_AND_ADD
case|:
name|set_raddr_seg
argument_list|(
name|wqe
argument_list|,
name|wr
operator|->
name|wr
operator|.
name|atomic
operator|.
name|remote_addr
argument_list|,
name|wr
operator|->
name|wr
operator|.
name|atomic
operator|.
name|rkey
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_raddr_seg
argument_list|)
expr_stmt|;
name|set_atomic_seg
argument_list|(
name|wqe
argument_list|,
name|wr
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_atomic_seg
argument_list|)
expr_stmt|;
name|size
operator|+=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_raddr_seg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_atomic_seg
argument_list|)
operator|)
operator|/
literal|16
expr_stmt|;
break|break;
case|case
name|IB_WR_MASKED_ATOMIC_CMP_AND_SWP
case|:
name|set_raddr_seg
argument_list|(
name|wqe
argument_list|,
name|wr
operator|->
name|wr
operator|.
name|atomic
operator|.
name|remote_addr
argument_list|,
name|wr
operator|->
name|wr
operator|.
name|atomic
operator|.
name|rkey
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_raddr_seg
argument_list|)
expr_stmt|;
name|set_masked_atomic_seg
argument_list|(
name|wqe
argument_list|,
name|wr
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_masked_atomic_seg
argument_list|)
expr_stmt|;
name|size
operator|+=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_raddr_seg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_masked_atomic_seg
argument_list|)
operator|)
operator|/
literal|16
expr_stmt|;
break|break;
case|case
name|IB_WR_RDMA_READ
case|:
case|case
name|IB_WR_RDMA_WRITE
case|:
case|case
name|IB_WR_RDMA_WRITE_WITH_IMM
case|:
name|set_raddr_seg
argument_list|(
name|wqe
argument_list|,
name|wr
operator|->
name|wr
operator|.
name|rdma
operator|.
name|remote_addr
argument_list|,
name|wr
operator|->
name|wr
operator|.
name|rdma
operator|.
name|rkey
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_raddr_seg
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_raddr_seg
argument_list|)
operator|/
literal|16
expr_stmt|;
break|break;
case|case
name|IB_WR_LOCAL_INV
case|:
name|ctrl
operator|->
name|srcrb_flags
operator||=
name|cpu_to_be32
argument_list|(
name|MLX4_WQE_CTRL_STRONG_ORDER
argument_list|)
expr_stmt|;
name|set_local_inv_seg
argument_list|(
name|wqe
argument_list|,
name|wr
operator|->
name|ex
operator|.
name|invalidate_rkey
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_local_inval_seg
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_local_inval_seg
argument_list|)
operator|/
literal|16
expr_stmt|;
break|break;
case|case
name|IB_WR_FAST_REG_MR
case|:
name|ctrl
operator|->
name|srcrb_flags
operator||=
name|cpu_to_be32
argument_list|(
name|MLX4_WQE_CTRL_STRONG_ORDER
argument_list|)
expr_stmt|;
name|set_fmr_seg
argument_list|(
name|wqe
argument_list|,
name|wr
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_fmr_seg
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_fmr_seg
argument_list|)
operator|/
literal|16
expr_stmt|;
break|break;
default|default:
comment|/* No extra segments required for sends */
break|break;
block|}
break|break;
case|case
name|MLX4_IB_QPT_TUN_SMI_OWNER
case|:
name|err
operator|=
name|build_sriov_qp0_header
argument_list|(
name|to_msqp
argument_list|(
name|qp
argument_list|)
argument_list|,
name|wr
argument_list|,
name|ctrl
argument_list|,
operator|&
name|seglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|err
argument_list|)
condition|)
block|{
operator|*
name|bad_wr
operator|=
name|wr
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|wqe
operator|+=
name|seglen
expr_stmt|;
name|size
operator|+=
name|seglen
operator|/
literal|16
expr_stmt|;
break|break;
case|case
name|MLX4_IB_QPT_TUN_SMI
case|:
case|case
name|MLX4_IB_QPT_TUN_GSI
case|:
comment|/* this is a UD qp used in MAD responses to slaves. */
name|set_datagram_seg
argument_list|(
name|wqe
argument_list|,
name|wr
argument_list|)
expr_stmt|;
comment|/* set the forced-loopback bit in the data seg av */
operator|*
operator|(
name|__be32
operator|*
operator|)
name|wqe
operator||=
name|cpu_to_be32
argument_list|(
literal|0x80000000
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_datagram_seg
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_datagram_seg
argument_list|)
operator|/
literal|16
expr_stmt|;
break|break;
case|case
name|MLX4_IB_QPT_UD
case|:
name|set_datagram_seg
argument_list|(
name|wqe
argument_list|,
name|wr
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_datagram_seg
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_datagram_seg
argument_list|)
operator|/
literal|16
expr_stmt|;
if|if
condition|(
name|wr
operator|->
name|opcode
operator|==
name|IB_WR_LSO
condition|)
block|{
name|err
operator|=
name|build_lso_seg
argument_list|(
name|wqe
argument_list|,
name|wr
argument_list|,
name|qp
argument_list|,
operator|&
name|seglen
argument_list|,
operator|&
name|lso_hdr_sz
argument_list|,
operator|&
name|blh
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|err
argument_list|)
condition|)
block|{
operator|*
name|bad_wr
operator|=
name|wr
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|lso_wqe
operator|=
operator|(
name|__be32
operator|*
operator|)
name|wqe
expr_stmt|;
name|wqe
operator|+=
name|seglen
expr_stmt|;
name|size
operator|+=
name|seglen
operator|/
literal|16
expr_stmt|;
block|}
break|break;
case|case
name|MLX4_IB_QPT_PROXY_SMI_OWNER
case|:
if|if
condition|(
name|unlikely
argument_list|(
operator|!
name|mlx4_is_master
argument_list|(
name|to_mdev
argument_list|(
name|ibqp
operator|->
name|device
argument_list|)
operator|->
name|dev
argument_list|)
argument_list|)
condition|)
block|{
name|err
operator|=
operator|-
name|ENOSYS
expr_stmt|;
operator|*
name|bad_wr
operator|=
name|wr
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|err
operator|=
name|build_sriov_qp0_header
argument_list|(
name|to_msqp
argument_list|(
name|qp
argument_list|)
argument_list|,
name|wr
argument_list|,
name|ctrl
argument_list|,
operator|&
name|seglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|err
argument_list|)
condition|)
block|{
operator|*
name|bad_wr
operator|=
name|wr
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|wqe
operator|+=
name|seglen
expr_stmt|;
name|size
operator|+=
name|seglen
operator|/
literal|16
expr_stmt|;
comment|/* to start tunnel header on a cache-line boundary */
name|add_zero_len_inline
argument_list|(
name|wqe
argument_list|)
expr_stmt|;
name|wqe
operator|+=
literal|16
expr_stmt|;
name|size
operator|++
expr_stmt|;
name|build_tunnel_header
argument_list|(
name|wr
argument_list|,
name|wqe
argument_list|,
operator|&
name|seglen
argument_list|)
expr_stmt|;
name|wqe
operator|+=
name|seglen
expr_stmt|;
name|size
operator|+=
name|seglen
operator|/
literal|16
expr_stmt|;
break|break;
case|case
name|MLX4_IB_QPT_PROXY_SMI
case|:
comment|/* don't allow QP0 sends on guests */
name|err
operator|=
operator|-
name|ENOSYS
expr_stmt|;
operator|*
name|bad_wr
operator|=
name|wr
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|MLX4_IB_QPT_PROXY_GSI
case|:
comment|/* If we are tunneling special qps, this is a UD qp. 			 * In this case we first add a UD segment targeting 			 * the tunnel qp, and then add a header with address 			 * information */
name|set_tunnel_datagram_seg
argument_list|(
name|to_mdev
argument_list|(
name|ibqp
operator|->
name|device
argument_list|)
argument_list|,
name|wqe
argument_list|,
name|wr
argument_list|,
name|ibqp
operator|->
name|qp_type
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_datagram_seg
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_datagram_seg
argument_list|)
operator|/
literal|16
expr_stmt|;
name|build_tunnel_header
argument_list|(
name|wr
argument_list|,
name|wqe
argument_list|,
operator|&
name|seglen
argument_list|)
expr_stmt|;
name|wqe
operator|+=
name|seglen
expr_stmt|;
name|size
operator|+=
name|seglen
operator|/
literal|16
expr_stmt|;
break|break;
case|case
name|MLX4_IB_QPT_SMI
case|:
case|case
name|MLX4_IB_QPT_GSI
case|:
name|err
operator|=
name|build_mlx_header
argument_list|(
name|to_msqp
argument_list|(
name|qp
argument_list|)
argument_list|,
name|wr
argument_list|,
name|ctrl
argument_list|,
operator|&
name|seglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|err
argument_list|)
condition|)
block|{
operator|*
name|bad_wr
operator|=
name|wr
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|wqe
operator|+=
name|seglen
expr_stmt|;
name|size
operator|+=
name|seglen
operator|/
literal|16
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* 		 * Write data segments in reverse order, so as to 		 * overwrite cacheline stamp last within each 		 * cacheline.  This avoids issues with WQE 		 * prefetching. 		 */
name|dseg
operator|=
name|wqe
expr_stmt|;
name|dseg
operator|+=
name|wr
operator|->
name|num_sge
operator|-
literal|1
expr_stmt|;
comment|/* Add one more inline data segment for ICRC for MLX sends */
if|if
condition|(
name|unlikely
argument_list|(
name|qp
operator|->
name|mlx4_ib_qp_type
operator|==
name|MLX4_IB_QPT_SMI
operator|||
name|qp
operator|->
name|mlx4_ib_qp_type
operator|==
name|MLX4_IB_QPT_GSI
operator|||
name|qp
operator|->
name|mlx4_ib_qp_type
operator|&
operator|(
name|MLX4_IB_QPT_PROXY_SMI_OWNER
operator||
name|MLX4_IB_QPT_TUN_SMI_OWNER
operator|)
argument_list|)
condition|)
block|{
name|set_mlx_icrc_seg
argument_list|(
name|dseg
operator|+
literal|1
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_data_seg
argument_list|)
operator|/
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|wr
operator|->
name|send_flags
operator|&
name|IB_SEND_INLINE
operator|&&
name|wr
operator|->
name|num_sge
condition|)
block|{
name|int
name|sz
decl_stmt|;
name|err
operator|=
name|lay_inline_data
argument_list|(
name|qp
argument_list|,
name|wr
argument_list|,
name|wqe
argument_list|,
operator|&
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|inl
operator|=
literal|1
expr_stmt|;
name|size
operator|+=
name|sz
expr_stmt|;
block|}
block|}
else|else
block|{
name|size
operator|+=
name|wr
operator|->
name|num_sge
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_wqe_data_seg
argument_list|)
operator|/
literal|16
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|wr
operator|->
name|num_sge
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
operator|,
operator|--
name|dseg
control|)
name|set_data_seg
argument_list|(
name|dseg
argument_list|,
name|wr
operator|->
name|sg_list
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Possibly overwrite stamping in cacheline with LSO 		 * segment only after making sure all data segments 		 * are written. 		 */
name|wmb
argument_list|()
expr_stmt|;
operator|*
name|lso_wqe
operator|=
name|lso_hdr_sz
expr_stmt|;
name|ctrl
operator|->
name|fence_size
operator|=
operator|(
name|wr
operator|->
name|send_flags
operator|&
name|IB_SEND_FENCE
condition|?
name|MLX4_WQE_CTRL_FENCE
else|:
literal|0
operator|)
operator||
name|size
expr_stmt|;
comment|/* 		 * Make sure descriptor is fully written before 		 * setting ownership bit (because HW can start 		 * executing as soon as we do). 		 */
name|wmb
argument_list|()
expr_stmt|;
if|if
condition|(
name|wr
operator|->
name|opcode
operator|>=
name|ARRAY_SIZE
argument_list|(
name|mlx4_ib_opcode
argument_list|)
condition|)
block|{
operator|*
name|bad_wr
operator|=
name|wr
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ctrl
operator|->
name|owner_opcode
operator|=
name|mlx4_ib_opcode
index|[
name|wr
operator|->
name|opcode
index|]
operator||
operator|(
name|ind
operator|&
name|qp
operator|->
name|sq
operator|.
name|wqe_cnt
condition|?
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|31
argument_list|)
else|:
literal|0
operator|)
operator||
name|blh
expr_stmt|;
name|stamp
operator|=
name|ind
operator|+
name|qp
operator|->
name|sq_spare_wqes
expr_stmt|;
name|ind
operator|+=
name|DIV_ROUND_UP
argument_list|(
name|size
operator|*
literal|16
argument_list|,
literal|1U
operator|<<
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
argument_list|)
expr_stmt|;
comment|/* 		 * We can improve latency by not stamping the last 		 * send queue WQE until after ringing the doorbell, so 		 * only stamp here if there are still more WQEs to post. 		 * 		 * Same optimization applies to padding with NOP wqe 		 * in case of WQE shrinking (used to prevent wrap-around 		 * in the middle of WR). 		 */
if|if
condition|(
name|wr
operator|->
name|next
condition|)
block|{
name|stamp_send_wqe
argument_list|(
name|qp
argument_list|,
name|stamp
argument_list|,
name|size
operator|*
literal|16
argument_list|)
expr_stmt|;
name|ind
operator|=
name|pad_wraparound
argument_list|(
name|qp
argument_list|,
name|ind
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
if|if
condition|(
name|nreq
operator|==
literal|1
operator|&&
name|inl
operator|&&
name|size
operator|>
literal|1
operator|&&
name|size
operator|<
name|qp
operator|->
name|bf
operator|.
name|buf_size
operator|/
literal|16
condition|)
block|{
name|ctrl
operator|->
name|owner_opcode
operator||=
name|htonl
argument_list|(
operator|(
name|qp
operator|->
name|sq_next_wqe
operator|&
literal|0xffff
operator|)
operator|<<
literal|8
argument_list|)
expr_stmt|;
comment|/* We set above doorbell_qpn bits to 0 as part of vlan 		  * tag initialization, so |= should be correct. 		*/
operator|*
operator|(
name|u32
operator|*
operator|)
operator|(
operator|&
name|ctrl
operator|->
name|vlan_tag
operator|)
operator||=
name|qp
operator|->
name|doorbell_qpn
expr_stmt|;
comment|/* 		 * Make sure that descriptor is written to memory 		 * before writing to BlueFlame page. 		 */
name|wmb
argument_list|()
expr_stmt|;
operator|++
name|qp
operator|->
name|sq
operator|.
name|head
expr_stmt|;
name|mlx4_bf_copy
argument_list|(
name|qp
operator|->
name|bf
operator|.
name|reg
operator|+
name|qp
operator|->
name|bf
operator|.
name|offset
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|ctrl
argument_list|,
name|ALIGN
argument_list|(
name|size
operator|*
literal|16
argument_list|,
literal|64
argument_list|)
argument_list|)
expr_stmt|;
name|wc_wmb
argument_list|()
expr_stmt|;
name|qp
operator|->
name|bf
operator|.
name|offset
operator|^=
name|qp
operator|->
name|bf
operator|.
name|buf_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nreq
condition|)
block|{
name|qp
operator|->
name|sq
operator|.
name|head
operator|+=
name|nreq
expr_stmt|;
comment|/* 		 * Make sure that descriptors are written before 		 * doorbell record. 		 */
name|wmb
argument_list|()
expr_stmt|;
name|writel
argument_list|(
name|qp
operator|->
name|doorbell_qpn
argument_list|,
name|qp
operator|->
name|bf
operator|.
name|uar
operator|->
name|map
operator|+
name|MLX4_SEND_DOORBELL
argument_list|)
expr_stmt|;
comment|/* 		 * Make sure doorbells don't leak out of SQ spinlock 		 * and reach the HCA out of order. 		 */
name|mmiowb
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|likely
argument_list|(
name|nreq
argument_list|)
condition|)
block|{
name|stamp_send_wqe
argument_list|(
name|qp
argument_list|,
name|stamp
argument_list|,
name|size
operator|*
literal|16
argument_list|)
expr_stmt|;
name|ind
operator|=
name|pad_wraparound
argument_list|(
name|qp
argument_list|,
name|ind
argument_list|)
expr_stmt|;
name|qp
operator|->
name|sq_next_wqe
operator|=
name|ind
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|qp
operator|->
name|sq
operator|.
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mlx4_ib_post_recv
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|ibqp
parameter_list|,
name|struct
name|ib_recv_wr
modifier|*
name|wr
parameter_list|,
name|struct
name|ib_recv_wr
modifier|*
modifier|*
name|bad_wr
parameter_list|)
block|{
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
init|=
name|to_mqp
argument_list|(
name|ibqp
argument_list|)
decl_stmt|;
name|struct
name|mlx4_wqe_data_seg
modifier|*
name|scat
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|nreq
decl_stmt|;
name|int
name|ind
decl_stmt|;
name|int
name|max_gs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|max_gs
operator|=
name|qp
operator|->
name|rq
operator|.
name|max_gs
expr_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|qp
operator|->
name|rq
operator|.
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ind
operator|=
name|qp
operator|->
name|rq
operator|.
name|head
operator|&
operator|(
name|qp
operator|->
name|rq
operator|.
name|wqe_cnt
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|nreq
operator|=
literal|0
init|;
name|wr
condition|;
operator|++
name|nreq
operator|,
name|wr
operator|=
name|wr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|mlx4_wq_overflow
argument_list|(
operator|&
name|qp
operator|->
name|rq
argument_list|,
name|nreq
argument_list|,
name|qp
operator|->
name|ibqp
operator|.
name|recv_cq
argument_list|)
condition|)
block|{
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
operator|*
name|bad_wr
operator|=
name|wr
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|unlikely
argument_list|(
name|wr
operator|->
name|num_sge
operator|>
name|qp
operator|->
name|rq
operator|.
name|max_gs
argument_list|)
condition|)
block|{
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
operator|*
name|bad_wr
operator|=
name|wr
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|scat
operator|=
name|get_recv_wqe
argument_list|(
name|qp
argument_list|,
name|ind
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|mlx4_ib_qp_type
operator|&
operator|(
name|MLX4_IB_QPT_PROXY_SMI_OWNER
operator||
name|MLX4_IB_QPT_PROXY_SMI
operator||
name|MLX4_IB_QPT_PROXY_GSI
operator|)
condition|)
block|{
name|ib_dma_sync_single_for_device
argument_list|(
name|ibqp
operator|->
name|device
argument_list|,
name|qp
operator|->
name|sqp_proxy_rcv
index|[
name|ind
index|]
operator|.
name|map
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_ib_proxy_sqp_hdr
argument_list|)
argument_list|,
name|DMA_FROM_DEVICE
argument_list|)
expr_stmt|;
name|scat
operator|->
name|byte_count
operator|=
name|cpu_to_be32
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|mlx4_ib_proxy_sqp_hdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* use dma lkey from upper layer entry */
name|scat
operator|->
name|lkey
operator|=
name|cpu_to_be32
argument_list|(
name|wr
operator|->
name|sg_list
operator|->
name|lkey
argument_list|)
expr_stmt|;
name|scat
operator|->
name|addr
operator|=
name|cpu_to_be64
argument_list|(
name|qp
operator|->
name|sqp_proxy_rcv
index|[
name|ind
index|]
operator|.
name|map
argument_list|)
expr_stmt|;
name|scat
operator|++
expr_stmt|;
name|max_gs
operator|--
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wr
operator|->
name|num_sge
condition|;
operator|++
name|i
control|)
name|__set_data_seg
argument_list|(
name|scat
operator|+
name|i
argument_list|,
name|wr
operator|->
name|sg_list
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|max_gs
condition|)
block|{
name|scat
index|[
name|i
index|]
operator|.
name|byte_count
operator|=
literal|0
expr_stmt|;
name|scat
index|[
name|i
index|]
operator|.
name|lkey
operator|=
name|cpu_to_be32
argument_list|(
name|MLX4_INVALID_LKEY
argument_list|)
expr_stmt|;
name|scat
index|[
name|i
index|]
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
block|}
name|qp
operator|->
name|rq
operator|.
name|wrid
index|[
name|ind
index|]
operator|=
name|wr
operator|->
name|wr_id
expr_stmt|;
name|ind
operator|=
operator|(
name|ind
operator|+
literal|1
operator|)
operator|&
operator|(
name|qp
operator|->
name|rq
operator|.
name|wqe_cnt
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|likely
argument_list|(
name|nreq
argument_list|)
condition|)
block|{
name|qp
operator|->
name|rq
operator|.
name|head
operator|+=
name|nreq
expr_stmt|;
comment|/* 		 * Make sure that descriptors are written before 		 * doorbell record. 		 */
name|wmb
argument_list|()
expr_stmt|;
operator|*
name|qp
operator|->
name|db
operator|.
name|db
operator|=
name|cpu_to_be32
argument_list|(
name|qp
operator|->
name|rq
operator|.
name|head
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|qp
operator|->
name|rq
operator|.
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|enum
name|ib_qp_state
name|to_ib_qp_state
parameter_list|(
name|enum
name|mlx4_qp_state
name|mlx4_state
parameter_list|)
block|{
switch|switch
condition|(
name|mlx4_state
condition|)
block|{
case|case
name|MLX4_QP_STATE_RST
case|:
return|return
name|IB_QPS_RESET
return|;
case|case
name|MLX4_QP_STATE_INIT
case|:
return|return
name|IB_QPS_INIT
return|;
case|case
name|MLX4_QP_STATE_RTR
case|:
return|return
name|IB_QPS_RTR
return|;
case|case
name|MLX4_QP_STATE_RTS
case|:
return|return
name|IB_QPS_RTS
return|;
case|case
name|MLX4_QP_STATE_SQ_DRAINING
case|:
case|case
name|MLX4_QP_STATE_SQD
case|:
return|return
name|IB_QPS_SQD
return|;
case|case
name|MLX4_QP_STATE_SQER
case|:
return|return
name|IB_QPS_SQE
return|;
case|case
name|MLX4_QP_STATE_ERR
case|:
return|return
name|IB_QPS_ERR
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|enum
name|ib_mig_state
name|to_ib_mig_state
parameter_list|(
name|int
name|mlx4_mig_state
parameter_list|)
block|{
switch|switch
condition|(
name|mlx4_mig_state
condition|)
block|{
case|case
name|MLX4_QP_PM_ARMED
case|:
return|return
name|IB_MIG_ARMED
return|;
case|case
name|MLX4_QP_PM_REARM
case|:
return|return
name|IB_MIG_REARM
return|;
case|case
name|MLX4_QP_PM_MIGRATED
case|:
return|return
name|IB_MIG_MIGRATED
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|to_ib_qp_access_flags
parameter_list|(
name|int
name|mlx4_flags
parameter_list|)
block|{
name|int
name|ib_flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mlx4_flags
operator|&
name|MLX4_QP_BIT_RRE
condition|)
name|ib_flags
operator||=
name|IB_ACCESS_REMOTE_READ
expr_stmt|;
if|if
condition|(
name|mlx4_flags
operator|&
name|MLX4_QP_BIT_RWE
condition|)
name|ib_flags
operator||=
name|IB_ACCESS_REMOTE_WRITE
expr_stmt|;
if|if
condition|(
name|mlx4_flags
operator|&
name|MLX4_QP_BIT_RAE
condition|)
name|ib_flags
operator||=
name|IB_ACCESS_REMOTE_ATOMIC
expr_stmt|;
return|return
name|ib_flags
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|to_ib_ah_attr
parameter_list|(
name|struct
name|mlx4_ib_dev
modifier|*
name|ibdev
parameter_list|,
name|struct
name|ib_ah_attr
modifier|*
name|ib_ah_attr
parameter_list|,
name|struct
name|mlx4_qp_path
modifier|*
name|path
parameter_list|)
block|{
name|struct
name|mlx4_dev
modifier|*
name|dev
init|=
name|ibdev
operator|->
name|dev
decl_stmt|;
name|int
name|is_eth
decl_stmt|;
name|memset
argument_list|(
name|ib_ah_attr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|ib_ah_attr
argument_list|)
expr_stmt|;
name|ib_ah_attr
operator|->
name|port_num
operator|=
name|path
operator|->
name|sched_queue
operator|&
literal|0x40
condition|?
literal|2
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|ib_ah_attr
operator|->
name|port_num
operator|==
literal|0
operator|||
name|ib_ah_attr
operator|->
name|port_num
operator|>
name|dev
operator|->
name|caps
operator|.
name|num_ports
condition|)
return|return;
name|is_eth
operator|=
name|rdma_port_get_link_layer
argument_list|(
operator|&
name|ibdev
operator|->
name|ib_dev
argument_list|,
name|ib_ah_attr
operator|->
name|port_num
argument_list|)
operator|==
name|IB_LINK_LAYER_ETHERNET
expr_stmt|;
if|if
condition|(
name|is_eth
condition|)
name|ib_ah_attr
operator|->
name|sl
operator|=
operator|(
operator|(
name|path
operator|->
name|sched_queue
operator|>>
literal|3
operator|)
operator|&
literal|0x7
operator|)
operator||
operator|(
operator|(
name|path
operator|->
name|sched_queue
operator|&
literal|4
operator|)
operator|<<
literal|1
operator|)
expr_stmt|;
else|else
name|ib_ah_attr
operator|->
name|sl
operator|=
operator|(
name|path
operator|->
name|sched_queue
operator|>>
literal|2
operator|)
operator|&
literal|0xf
expr_stmt|;
name|ib_ah_attr
operator|->
name|dlid
operator|=
name|be16_to_cpu
argument_list|(
name|path
operator|->
name|rlid
argument_list|)
expr_stmt|;
name|ib_ah_attr
operator|->
name|src_path_bits
operator|=
name|path
operator|->
name|grh_mylmc
operator|&
literal|0x7f
expr_stmt|;
name|ib_ah_attr
operator|->
name|static_rate
operator|=
name|path
operator|->
name|static_rate
condition|?
name|path
operator|->
name|static_rate
operator|-
literal|5
else|:
literal|0
expr_stmt|;
name|ib_ah_attr
operator|->
name|ah_flags
operator|=
operator|(
name|path
operator|->
name|grh_mylmc
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
condition|?
name|IB_AH_GRH
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|ib_ah_attr
operator|->
name|ah_flags
condition|)
block|{
name|ib_ah_attr
operator|->
name|grh
operator|.
name|sgid_index
operator|=
name|path
operator|->
name|mgid_index
expr_stmt|;
name|ib_ah_attr
operator|->
name|grh
operator|.
name|hop_limit
operator|=
name|path
operator|->
name|hop_limit
expr_stmt|;
name|ib_ah_attr
operator|->
name|grh
operator|.
name|traffic_class
operator|=
operator|(
name|be32_to_cpu
argument_list|(
name|path
operator|->
name|tclass_flowlabel
argument_list|)
operator|>>
literal|20
operator|)
operator|&
literal|0xff
expr_stmt|;
name|ib_ah_attr
operator|->
name|grh
operator|.
name|flow_label
operator|=
name|be32_to_cpu
argument_list|(
name|path
operator|->
name|tclass_flowlabel
argument_list|)
operator|&
literal|0xfffff
expr_stmt|;
name|memcpy
argument_list|(
name|ib_ah_attr
operator|->
name|grh
operator|.
name|dgid
operator|.
name|raw
argument_list|,
name|path
operator|->
name|rgid
argument_list|,
sizeof|sizeof
name|ib_ah_attr
operator|->
name|grh
operator|.
name|dgid
operator|.
name|raw
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|mlx4_ib_query_qp
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|ibqp
parameter_list|,
name|struct
name|ib_qp_attr
modifier|*
name|qp_attr
parameter_list|,
name|int
name|qp_attr_mask
parameter_list|,
name|struct
name|ib_qp_init_attr
modifier|*
name|qp_init_attr
parameter_list|)
block|{
name|struct
name|mlx4_ib_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ibqp
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mlx4_ib_qp
modifier|*
name|qp
init|=
name|to_mqp
argument_list|(
name|ibqp
argument_list|)
decl_stmt|;
name|struct
name|mlx4_qp_context
name|context
decl_stmt|;
name|int
name|mlx4_state
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|qp
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|state
operator|==
name|IB_QPS_RESET
condition|)
block|{
name|qp_attr
operator|->
name|qp_state
operator|=
name|IB_QPS_RESET
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|err
operator|=
name|mlx4_qp_query
argument_list|(
name|dev
operator|->
name|dev
argument_list|,
operator|&
name|qp
operator|->
name|mqp
argument_list|,
operator|&
name|context
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mlx4_state
operator|=
name|be32_to_cpu
argument_list|(
name|context
operator|.
name|flags
argument_list|)
operator|>>
literal|28
expr_stmt|;
name|qp
operator|->
name|state
operator|=
name|to_ib_qp_state
argument_list|(
name|mlx4_state
argument_list|)
expr_stmt|;
name|qp_attr
operator|->
name|qp_state
operator|=
name|qp
operator|->
name|state
expr_stmt|;
name|qp_attr
operator|->
name|path_mtu
operator|=
name|context
operator|.
name|mtu_msgmax
operator|>>
literal|5
expr_stmt|;
name|qp_attr
operator|->
name|path_mig_state
operator|=
name|to_ib_mig_state
argument_list|(
operator|(
name|be32_to_cpu
argument_list|(
name|context
operator|.
name|flags
argument_list|)
operator|>>
literal|11
operator|)
operator|&
literal|0x3
argument_list|)
expr_stmt|;
name|qp_attr
operator|->
name|qkey
operator|=
name|be32_to_cpu
argument_list|(
name|context
operator|.
name|qkey
argument_list|)
expr_stmt|;
name|qp_attr
operator|->
name|rq_psn
operator|=
name|be32_to_cpu
argument_list|(
name|context
operator|.
name|rnr_nextrecvpsn
argument_list|)
operator|&
literal|0xffffff
expr_stmt|;
name|qp_attr
operator|->
name|sq_psn
operator|=
name|be32_to_cpu
argument_list|(
name|context
operator|.
name|next_send_psn
argument_list|)
operator|&
literal|0xffffff
expr_stmt|;
name|qp_attr
operator|->
name|dest_qp_num
operator|=
name|be32_to_cpu
argument_list|(
name|context
operator|.
name|remote_qpn
argument_list|)
operator|&
literal|0xffffff
expr_stmt|;
name|qp_attr
operator|->
name|qp_access_flags
operator|=
name|to_ib_qp_access_flags
argument_list|(
name|be32_to_cpu
argument_list|(
name|context
operator|.
name|params2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|ibqp
operator|.
name|qp_type
operator|==
name|IB_QPT_RC
operator|||
name|qp
operator|->
name|ibqp
operator|.
name|qp_type
operator|==
name|IB_QPT_UC
condition|)
block|{
name|to_ib_ah_attr
argument_list|(
name|dev
argument_list|,
operator|&
name|qp_attr
operator|->
name|ah_attr
argument_list|,
operator|&
name|context
operator|.
name|pri_path
argument_list|)
expr_stmt|;
name|to_ib_ah_attr
argument_list|(
name|dev
argument_list|,
operator|&
name|qp_attr
operator|->
name|alt_ah_attr
argument_list|,
operator|&
name|context
operator|.
name|alt_path
argument_list|)
expr_stmt|;
name|qp_attr
operator|->
name|alt_pkey_index
operator|=
name|context
operator|.
name|alt_path
operator|.
name|pkey_index
operator|&
literal|0x7f
expr_stmt|;
name|qp_attr
operator|->
name|alt_port_num
operator|=
name|qp_attr
operator|->
name|alt_ah_attr
operator|.
name|port_num
expr_stmt|;
block|}
name|qp_attr
operator|->
name|pkey_index
operator|=
name|context
operator|.
name|pri_path
operator|.
name|pkey_index
operator|&
literal|0x7f
expr_stmt|;
if|if
condition|(
name|qp_attr
operator|->
name|qp_state
operator|==
name|IB_QPS_INIT
condition|)
name|qp_attr
operator|->
name|port_num
operator|=
name|qp
operator|->
name|port
expr_stmt|;
else|else
name|qp_attr
operator|->
name|port_num
operator|=
name|context
operator|.
name|pri_path
operator|.
name|sched_queue
operator|&
literal|0x40
condition|?
literal|2
else|:
literal|1
expr_stmt|;
comment|/* qp_attr->en_sqd_async_notify is only applicable in modify qp */
name|qp_attr
operator|->
name|sq_draining
operator|=
name|mlx4_state
operator|==
name|MLX4_QP_STATE_SQ_DRAINING
expr_stmt|;
name|qp_attr
operator|->
name|max_rd_atomic
operator|=
literal|1
operator|<<
operator|(
operator|(
name|be32_to_cpu
argument_list|(
name|context
operator|.
name|params1
argument_list|)
operator|>>
literal|21
operator|)
operator|&
literal|0x7
operator|)
expr_stmt|;
name|qp_attr
operator|->
name|max_dest_rd_atomic
operator|=
literal|1
operator|<<
operator|(
operator|(
name|be32_to_cpu
argument_list|(
name|context
operator|.
name|params2
argument_list|)
operator|>>
literal|21
operator|)
operator|&
literal|0x7
operator|)
expr_stmt|;
name|qp_attr
operator|->
name|min_rnr_timer
operator|=
operator|(
name|be32_to_cpu
argument_list|(
name|context
operator|.
name|rnr_nextrecvpsn
argument_list|)
operator|>>
literal|24
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|qp_attr
operator|->
name|timeout
operator|=
name|context
operator|.
name|pri_path
operator|.
name|ackto
operator|>>
literal|3
expr_stmt|;
name|qp_attr
operator|->
name|retry_cnt
operator|=
operator|(
name|be32_to_cpu
argument_list|(
name|context
operator|.
name|params1
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0x7
expr_stmt|;
name|qp_attr
operator|->
name|rnr_retry
operator|=
operator|(
name|be32_to_cpu
argument_list|(
name|context
operator|.
name|params1
argument_list|)
operator|>>
literal|13
operator|)
operator|&
literal|0x7
expr_stmt|;
name|qp_attr
operator|->
name|alt_timeout
operator|=
name|context
operator|.
name|alt_path
operator|.
name|ackto
operator|>>
literal|3
expr_stmt|;
name|done
label|:
name|qp_attr
operator|->
name|cur_qp_state
operator|=
name|qp_attr
operator|->
name|qp_state
expr_stmt|;
name|qp_attr
operator|->
name|cap
operator|.
name|max_recv_wr
operator|=
name|qp
operator|->
name|rq
operator|.
name|wqe_cnt
expr_stmt|;
name|qp_attr
operator|->
name|cap
operator|.
name|max_recv_sge
operator|=
name|qp
operator|->
name|rq
operator|.
name|max_gs
expr_stmt|;
if|if
condition|(
operator|!
name|ibqp
operator|->
name|uobject
condition|)
block|{
name|qp_attr
operator|->
name|cap
operator|.
name|max_send_wr
operator|=
name|qp
operator|->
name|sq
operator|.
name|wqe_cnt
expr_stmt|;
name|qp_attr
operator|->
name|cap
operator|.
name|max_send_sge
operator|=
name|qp
operator|->
name|sq
operator|.
name|max_gs
expr_stmt|;
block|}
else|else
block|{
name|qp_attr
operator|->
name|cap
operator|.
name|max_send_wr
operator|=
literal|0
expr_stmt|;
name|qp_attr
operator|->
name|cap
operator|.
name|max_send_sge
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * We don't support inline sends for kernel QPs (yet), and we 	 * don't know what userspace's value should be. 	 */
name|qp_attr
operator|->
name|cap
operator|.
name|max_inline_data
operator|=
literal|0
expr_stmt|;
name|qp_init_attr
operator|->
name|cap
operator|=
name|qp_attr
operator|->
name|cap
expr_stmt|;
name|qp_init_attr
operator|->
name|create_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|flags
operator|&
name|MLX4_IB_QP_BLOCK_MULTICAST_LOOPBACK
condition|)
name|qp_init_attr
operator|->
name|create_flags
operator||=
name|IB_QP_CREATE_BLOCK_MULTICAST_LOOPBACK
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|flags
operator|&
name|MLX4_IB_QP_LSO
condition|)
name|qp_init_attr
operator|->
name|create_flags
operator||=
name|IB_QP_CREATE_IPOIB_UD_LSO
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|flags
operator|&
name|MLX4_IB_QP_NETIF
condition|)
name|qp_init_attr
operator|->
name|create_flags
operator||=
name|IB_QP_CREATE_NETIF_QP
expr_stmt|;
name|qp_init_attr
operator|->
name|sq_sig_type
operator|=
name|qp
operator|->
name|sq_signal_bits
operator|==
name|cpu_to_be32
argument_list|(
name|MLX4_WQE_CTRL_CQ_UPDATE
argument_list|)
condition|?
name|IB_SIGNAL_ALL_WR
else|:
name|IB_SIGNAL_REQ_WR
expr_stmt|;
name|qp_init_attr
operator|->
name|qpg_type
operator|=
name|ibqp
operator|->
name|qpg_type
expr_stmt|;
if|if
condition|(
name|ibqp
operator|->
name|qpg_type
operator|==
name|IB_QPG_PARENT
condition|)
name|qp_init_attr
operator|->
name|cap
operator|.
name|qpg_tss_mask_sz
operator|=
name|qp
operator|->
name|qpg_data
operator|->
name|qpg_tss_mask_sz
expr_stmt|;
else|else
name|qp_init_attr
operator|->
name|cap
operator|.
name|qpg_tss_mask_sz
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|mutex_unlock
argument_list|(
operator|&
name|qp
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

end_unit

