begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004 Topspin Communications.  All rights reserved.  * Copyright (c) 2005 Cisco Systems. All rights reserved.  * Copyright (c) 2005 Mellanox Technologies. All rights reserved.  * Copyright (c) 2004 Voltaire, Inc. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<linux/string.h>
end_include

begin_include
include|#
directive|include
file|<linux/slab.h>
end_include

begin_include
include|#
directive|include
file|<linux/sched.h>
end_include

begin_include
include|#
directive|include
file|<asm/io.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_verbs.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_cache.h>
end_include

begin_include
include|#
directive|include
file|<rdma/ib_pack.h>
end_include

begin_include
include|#
directive|include
file|"mthca_dev.h"
end_include

begin_include
include|#
directive|include
file|"mthca_cmd.h"
end_include

begin_include
include|#
directive|include
file|"mthca_memfree.h"
end_include

begin_include
include|#
directive|include
file|"mthca_wqe.h"
end_include

begin_enum
enum|enum
block|{
name|MTHCA_MAX_DIRECT_QP_SIZE
init|=
literal|4
operator|*
name|PAGE_SIZE
block|,
name|MTHCA_ACK_REQ_FREQ
init|=
literal|10
block|,
name|MTHCA_FLIGHT_LIMIT
init|=
literal|9
block|,
name|MTHCA_UD_HEADER_SIZE
init|=
literal|72
block|,
comment|/* largest UD header possible */
name|MTHCA_INLINE_HEADER_SIZE
init|=
literal|4
block|,
comment|/* data segment overhead for inline */
name|MTHCA_INLINE_CHUNK_SIZE
init|=
literal|16
comment|/* inline data segment chunk */
block|}
enum|;
end_enum

begin_enum
enum|enum
block|{
name|MTHCA_QP_STATE_RST
init|=
literal|0
block|,
name|MTHCA_QP_STATE_INIT
init|=
literal|1
block|,
name|MTHCA_QP_STATE_RTR
init|=
literal|2
block|,
name|MTHCA_QP_STATE_RTS
init|=
literal|3
block|,
name|MTHCA_QP_STATE_SQE
init|=
literal|4
block|,
name|MTHCA_QP_STATE_SQD
init|=
literal|5
block|,
name|MTHCA_QP_STATE_ERR
init|=
literal|6
block|,
name|MTHCA_QP_STATE_DRAINING
init|=
literal|7
block|}
enum|;
end_enum

begin_enum
enum|enum
block|{
name|MTHCA_QP_ST_RC
init|=
literal|0x0
block|,
name|MTHCA_QP_ST_UC
init|=
literal|0x1
block|,
name|MTHCA_QP_ST_RD
init|=
literal|0x2
block|,
name|MTHCA_QP_ST_UD
init|=
literal|0x3
block|,
name|MTHCA_QP_ST_MLX
init|=
literal|0x7
block|}
enum|;
end_enum

begin_enum
enum|enum
block|{
name|MTHCA_QP_PM_MIGRATED
init|=
literal|0x3
block|,
name|MTHCA_QP_PM_ARMED
init|=
literal|0x0
block|,
name|MTHCA_QP_PM_REARM
init|=
literal|0x1
block|}
enum|;
end_enum

begin_enum
enum|enum
block|{
comment|/* qp_context flags */
name|MTHCA_QP_BIT_DE
init|=
literal|1
operator|<<
literal|8
block|,
comment|/* params1 */
name|MTHCA_QP_BIT_SRE
init|=
literal|1
operator|<<
literal|15
block|,
name|MTHCA_QP_BIT_SWE
init|=
literal|1
operator|<<
literal|14
block|,
name|MTHCA_QP_BIT_SAE
init|=
literal|1
operator|<<
literal|13
block|,
name|MTHCA_QP_BIT_SIC
init|=
literal|1
operator|<<
literal|4
block|,
name|MTHCA_QP_BIT_SSC
init|=
literal|1
operator|<<
literal|3
block|,
comment|/* params2 */
name|MTHCA_QP_BIT_RRE
init|=
literal|1
operator|<<
literal|15
block|,
name|MTHCA_QP_BIT_RWE
init|=
literal|1
operator|<<
literal|14
block|,
name|MTHCA_QP_BIT_RAE
init|=
literal|1
operator|<<
literal|13
block|,
name|MTHCA_QP_BIT_RIC
init|=
literal|1
operator|<<
literal|4
block|,
name|MTHCA_QP_BIT_RSC
init|=
literal|1
operator|<<
literal|3
block|}
enum|;
end_enum

begin_enum
enum|enum
block|{
name|MTHCA_SEND_DOORBELL_FENCE
init|=
literal|1
operator|<<
literal|5
block|}
enum|;
end_enum

begin_struct
struct|struct
name|mthca_qp_path
block|{
name|__be32
name|port_pkey
decl_stmt|;
name|u8
name|rnr_retry
decl_stmt|;
name|u8
name|g_mylmc
decl_stmt|;
name|__be16
name|rlid
decl_stmt|;
name|u8
name|ackto
decl_stmt|;
name|u8
name|mgid_index
decl_stmt|;
name|u8
name|static_rate
decl_stmt|;
name|u8
name|hop_limit
decl_stmt|;
name|__be32
name|sl_tclass_flowlabel
decl_stmt|;
name|u8
name|rgid
index|[
literal|16
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_struct
struct|struct
name|mthca_qp_context
block|{
name|__be32
name|flags
decl_stmt|;
name|__be32
name|tavor_sched_queue
decl_stmt|;
comment|/* Reserved on Arbel */
name|u8
name|mtu_msgmax
decl_stmt|;
name|u8
name|rq_size_stride
decl_stmt|;
comment|/* Reserved on Tavor */
name|u8
name|sq_size_stride
decl_stmt|;
comment|/* Reserved on Tavor */
name|u8
name|rlkey_arbel_sched_queue
decl_stmt|;
comment|/* Reserved on Tavor */
name|__be32
name|usr_page
decl_stmt|;
name|__be32
name|local_qpn
decl_stmt|;
name|__be32
name|remote_qpn
decl_stmt|;
name|u32
name|reserved1
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|mthca_qp_path
name|pri_path
decl_stmt|;
name|struct
name|mthca_qp_path
name|alt_path
decl_stmt|;
name|__be32
name|rdd
decl_stmt|;
name|__be32
name|pd
decl_stmt|;
name|__be32
name|wqe_base
decl_stmt|;
name|__be32
name|wqe_lkey
decl_stmt|;
name|__be32
name|params1
decl_stmt|;
name|__be32
name|reserved2
decl_stmt|;
name|__be32
name|next_send_psn
decl_stmt|;
name|__be32
name|cqn_snd
decl_stmt|;
name|__be32
name|snd_wqe_base_l
decl_stmt|;
comment|/* Next send WQE on Tavor */
name|__be32
name|snd_db_index
decl_stmt|;
comment|/* (debugging only entries) */
name|__be32
name|last_acked_psn
decl_stmt|;
name|__be32
name|ssn
decl_stmt|;
name|__be32
name|params2
decl_stmt|;
name|__be32
name|rnr_nextrecvpsn
decl_stmt|;
name|__be32
name|ra_buff_indx
decl_stmt|;
name|__be32
name|cqn_rcv
decl_stmt|;
name|__be32
name|rcv_wqe_base_l
decl_stmt|;
comment|/* Next recv WQE on Tavor */
name|__be32
name|rcv_db_index
decl_stmt|;
comment|/* (debugging only entries) */
name|__be32
name|qkey
decl_stmt|;
name|__be32
name|srqn
decl_stmt|;
name|__be32
name|rmsn
decl_stmt|;
name|__be16
name|rq_wqe_counter
decl_stmt|;
comment|/* reserved on Tavor */
name|__be16
name|sq_wqe_counter
decl_stmt|;
comment|/* reserved on Tavor */
name|u32
name|reserved3
index|[
literal|18
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_struct
struct|struct
name|mthca_qp_param
block|{
name|__be32
name|opt_param_mask
decl_stmt|;
name|u32
name|reserved1
decl_stmt|;
name|struct
name|mthca_qp_context
name|context
decl_stmt|;
name|u32
name|reserved2
index|[
literal|62
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_enum
enum|enum
block|{
name|MTHCA_QP_OPTPAR_ALT_ADDR_PATH
init|=
literal|1
operator|<<
literal|0
block|,
name|MTHCA_QP_OPTPAR_RRE
init|=
literal|1
operator|<<
literal|1
block|,
name|MTHCA_QP_OPTPAR_RAE
init|=
literal|1
operator|<<
literal|2
block|,
name|MTHCA_QP_OPTPAR_RWE
init|=
literal|1
operator|<<
literal|3
block|,
name|MTHCA_QP_OPTPAR_PKEY_INDEX
init|=
literal|1
operator|<<
literal|4
block|,
name|MTHCA_QP_OPTPAR_Q_KEY
init|=
literal|1
operator|<<
literal|5
block|,
name|MTHCA_QP_OPTPAR_RNR_TIMEOUT
init|=
literal|1
operator|<<
literal|6
block|,
name|MTHCA_QP_OPTPAR_PRIMARY_ADDR_PATH
init|=
literal|1
operator|<<
literal|7
block|,
name|MTHCA_QP_OPTPAR_SRA_MAX
init|=
literal|1
operator|<<
literal|8
block|,
name|MTHCA_QP_OPTPAR_RRA_MAX
init|=
literal|1
operator|<<
literal|9
block|,
name|MTHCA_QP_OPTPAR_PM_STATE
init|=
literal|1
operator|<<
literal|10
block|,
name|MTHCA_QP_OPTPAR_PORT_NUM
init|=
literal|1
operator|<<
literal|11
block|,
name|MTHCA_QP_OPTPAR_RETRY_COUNT
init|=
literal|1
operator|<<
literal|12
block|,
name|MTHCA_QP_OPTPAR_ALT_RNR_RETRY
init|=
literal|1
operator|<<
literal|13
block|,
name|MTHCA_QP_OPTPAR_ACK_TIMEOUT
init|=
literal|1
operator|<<
literal|14
block|,
name|MTHCA_QP_OPTPAR_RNR_RETRY
init|=
literal|1
operator|<<
literal|15
block|,
name|MTHCA_QP_OPTPAR_SCHED_QUEUE
init|=
literal|1
operator|<<
literal|16
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
specifier|const
name|u8
name|mthca_opcode
index|[]
init|=
block|{
index|[
name|IB_WR_SEND
index|]
operator|=
name|MTHCA_OPCODE_SEND
block|,
index|[
name|IB_WR_SEND_WITH_IMM
index|]
operator|=
name|MTHCA_OPCODE_SEND_IMM
block|,
index|[
name|IB_WR_RDMA_WRITE
index|]
operator|=
name|MTHCA_OPCODE_RDMA_WRITE
block|,
index|[
name|IB_WR_RDMA_WRITE_WITH_IMM
index|]
operator|=
name|MTHCA_OPCODE_RDMA_WRITE_IMM
block|,
index|[
name|IB_WR_RDMA_READ
index|]
operator|=
name|MTHCA_OPCODE_RDMA_READ
block|,
index|[
name|IB_WR_ATOMIC_CMP_AND_SWP
index|]
operator|=
name|MTHCA_OPCODE_ATOMIC_CS
block|,
index|[
name|IB_WR_ATOMIC_FETCH_AND_ADD
index|]
operator|=
name|MTHCA_OPCODE_ATOMIC_FA
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|is_sqp
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_qp
modifier|*
name|qp
parameter_list|)
block|{
return|return
name|qp
operator|->
name|qpn
operator|>=
name|dev
operator|->
name|qp_table
operator|.
name|sqp_start
operator|&&
name|qp
operator|->
name|qpn
operator|<=
name|dev
operator|->
name|qp_table
operator|.
name|sqp_start
operator|+
literal|3
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|is_qp0
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_qp
modifier|*
name|qp
parameter_list|)
block|{
return|return
name|qp
operator|->
name|qpn
operator|>=
name|dev
operator|->
name|qp_table
operator|.
name|sqp_start
operator|&&
name|qp
operator|->
name|qpn
operator|<=
name|dev
operator|->
name|qp_table
operator|.
name|sqp_start
operator|+
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|get_recv_wqe
parameter_list|(
name|struct
name|mthca_qp
modifier|*
name|qp
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|qp
operator|->
name|is_direct
condition|)
return|return
name|qp
operator|->
name|queue
operator|.
name|direct
operator|.
name|buf
operator|+
operator|(
name|n
operator|<<
name|qp
operator|->
name|rq
operator|.
name|wqe_shift
operator|)
return|;
else|else
return|return
name|qp
operator|->
name|queue
operator|.
name|page_list
index|[
operator|(
name|n
operator|<<
name|qp
operator|->
name|rq
operator|.
name|wqe_shift
operator|)
operator|>>
name|PAGE_SHIFT
index|]
operator|.
name|buf
operator|+
operator|(
operator|(
name|n
operator|<<
name|qp
operator|->
name|rq
operator|.
name|wqe_shift
operator|)
operator|&
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|get_send_wqe
parameter_list|(
name|struct
name|mthca_qp
modifier|*
name|qp
parameter_list|,
name|int
name|n
parameter_list|)
block|{
if|if
condition|(
name|qp
operator|->
name|is_direct
condition|)
return|return
name|qp
operator|->
name|queue
operator|.
name|direct
operator|.
name|buf
operator|+
name|qp
operator|->
name|send_wqe_offset
operator|+
operator|(
name|n
operator|<<
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|)
return|;
else|else
return|return
name|qp
operator|->
name|queue
operator|.
name|page_list
index|[
operator|(
name|qp
operator|->
name|send_wqe_offset
operator|+
operator|(
name|n
operator|<<
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|)
operator|)
operator|>>
name|PAGE_SHIFT
index|]
operator|.
name|buf
operator|+
operator|(
operator|(
name|qp
operator|->
name|send_wqe_offset
operator|+
operator|(
name|n
operator|<<
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|)
operator|)
operator|&
operator|(
name|PAGE_SIZE
operator|-
literal|1
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mthca_wq_reset
parameter_list|(
name|struct
name|mthca_wq
modifier|*
name|wq
parameter_list|)
block|{
name|wq
operator|->
name|next_ind
operator|=
literal|0
expr_stmt|;
name|wq
operator|->
name|last_comp
operator|=
name|wq
operator|->
name|max
operator|-
literal|1
expr_stmt|;
name|wq
operator|->
name|head
operator|=
literal|0
expr_stmt|;
name|wq
operator|->
name|tail
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mthca_qp_event
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|qpn
parameter_list|,
name|enum
name|ib_event_type
name|event_type
parameter_list|)
block|{
name|struct
name|mthca_qp
modifier|*
name|qp
decl_stmt|;
name|struct
name|ib_event
name|event
decl_stmt|;
name|spin_lock
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|lock
argument_list|)
expr_stmt|;
name|qp
operator|=
name|mthca_array_get
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|qp
argument_list|,
name|qpn
operator|&
operator|(
name|dev
operator|->
name|limits
operator|.
name|num_qps
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
condition|)
operator|++
name|qp
operator|->
name|refcount
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qp
condition|)
block|{
name|mthca_warn
argument_list|(
name|dev
argument_list|,
literal|"Async event %d for bogus QP %08x\n"
argument_list|,
operator|(
name|int
operator|)
name|event_type
argument_list|,
name|qpn
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|event_type
operator|==
name|IB_EVENT_PATH_MIG
condition|)
name|qp
operator|->
name|port
operator|=
name|qp
operator|->
name|alt_port
expr_stmt|;
name|event
operator|.
name|device
operator|=
operator|&
name|dev
operator|->
name|ib_dev
expr_stmt|;
name|event
operator|.
name|event
operator|=
name|event_type
expr_stmt|;
name|event
operator|.
name|element
operator|.
name|qp
operator|=
operator|&
name|qp
operator|->
name|ibqp
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|ibqp
operator|.
name|event_handler
condition|)
name|qp
operator|->
name|ibqp
operator|.
name|event_handler
argument_list|(
operator|&
name|event
argument_list|,
name|qp
operator|->
name|ibqp
operator|.
name|qp_context
argument_list|)
expr_stmt|;
name|spin_lock
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|--
name|qp
operator|->
name|refcount
condition|)
name|wake_up
argument_list|(
operator|&
name|qp
operator|->
name|wait
argument_list|)
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|to_mthca_state
parameter_list|(
name|enum
name|ib_qp_state
name|ib_state
parameter_list|)
block|{
switch|switch
condition|(
name|ib_state
condition|)
block|{
case|case
name|IB_QPS_RESET
case|:
return|return
name|MTHCA_QP_STATE_RST
return|;
case|case
name|IB_QPS_INIT
case|:
return|return
name|MTHCA_QP_STATE_INIT
return|;
case|case
name|IB_QPS_RTR
case|:
return|return
name|MTHCA_QP_STATE_RTR
return|;
case|case
name|IB_QPS_RTS
case|:
return|return
name|MTHCA_QP_STATE_RTS
return|;
case|case
name|IB_QPS_SQD
case|:
return|return
name|MTHCA_QP_STATE_SQD
return|;
case|case
name|IB_QPS_SQE
case|:
return|return
name|MTHCA_QP_STATE_SQE
return|;
case|case
name|IB_QPS_ERR
case|:
return|return
name|MTHCA_QP_STATE_ERR
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_enum
enum|enum
block|{
name|RC
block|,
name|UC
block|,
name|UD
block|,
name|RD
block|,
name|RDEE
block|,
name|MLX
block|,
name|NUM_TRANS
block|}
enum|;
end_enum

begin_function
specifier|static
name|int
name|to_mthca_st
parameter_list|(
name|int
name|transport
parameter_list|)
block|{
switch|switch
condition|(
name|transport
condition|)
block|{
case|case
name|RC
case|:
return|return
name|MTHCA_QP_ST_RC
return|;
case|case
name|UC
case|:
return|return
name|MTHCA_QP_ST_UC
return|;
case|case
name|UD
case|:
return|return
name|MTHCA_QP_ST_UD
return|;
case|case
name|RD
case|:
return|return
name|MTHCA_QP_ST_RD
return|;
case|case
name|MLX
case|:
return|return
name|MTHCA_QP_ST_MLX
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|store_attrs
parameter_list|(
name|struct
name|mthca_sqp
modifier|*
name|sqp
parameter_list|,
specifier|const
name|struct
name|ib_qp_attr
modifier|*
name|attr
parameter_list|,
name|int
name|attr_mask
parameter_list|)
block|{
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_PKEY_INDEX
condition|)
name|sqp
operator|->
name|pkey_index
operator|=
name|attr
operator|->
name|pkey_index
expr_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_QKEY
condition|)
name|sqp
operator|->
name|qkey
operator|=
name|attr
operator|->
name|qkey
expr_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_SQ_PSN
condition|)
name|sqp
operator|->
name|send_psn
operator|=
name|attr
operator|->
name|sq_psn
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_port
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|u8
name|status
decl_stmt|;
name|struct
name|mthca_init_ib_param
name|param
decl_stmt|;
name|memset
argument_list|(
operator|&
name|param
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|param
argument_list|)
expr_stmt|;
name|param
operator|.
name|port_width
operator|=
name|dev
operator|->
name|limits
operator|.
name|port_width_cap
expr_stmt|;
name|param
operator|.
name|vl_cap
operator|=
name|dev
operator|->
name|limits
operator|.
name|vl_cap
expr_stmt|;
name|param
operator|.
name|mtu_cap
operator|=
name|dev
operator|->
name|limits
operator|.
name|mtu_cap
expr_stmt|;
name|param
operator|.
name|gid_cap
operator|=
name|dev
operator|->
name|limits
operator|.
name|gid_table_len
expr_stmt|;
name|param
operator|.
name|pkey_cap
operator|=
name|dev
operator|->
name|limits
operator|.
name|pkey_table_len
expr_stmt|;
name|err
operator|=
name|mthca_INIT_IB
argument_list|(
name|dev
argument_list|,
operator|&
name|param
argument_list|,
name|port
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mthca_warn
argument_list|(
name|dev
argument_list|,
literal|"INIT_IB failed, return code %d.\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|mthca_warn
argument_list|(
name|dev
argument_list|,
literal|"INIT_IB returned status %02x.\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__be32
name|get_hw_access_flags
parameter_list|(
name|struct
name|mthca_qp
modifier|*
name|qp
parameter_list|,
specifier|const
name|struct
name|ib_qp_attr
modifier|*
name|attr
parameter_list|,
name|int
name|attr_mask
parameter_list|)
block|{
name|u8
name|dest_rd_atomic
decl_stmt|;
name|u32
name|access_flags
decl_stmt|;
name|u32
name|hw_access_flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_MAX_DEST_RD_ATOMIC
condition|)
name|dest_rd_atomic
operator|=
name|attr
operator|->
name|max_dest_rd_atomic
expr_stmt|;
else|else
name|dest_rd_atomic
operator|=
name|qp
operator|->
name|resp_depth
expr_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_ACCESS_FLAGS
condition|)
name|access_flags
operator|=
name|attr
operator|->
name|qp_access_flags
expr_stmt|;
else|else
name|access_flags
operator|=
name|qp
operator|->
name|atomic_rd_en
expr_stmt|;
if|if
condition|(
operator|!
name|dest_rd_atomic
condition|)
name|access_flags
operator|&=
name|IB_ACCESS_REMOTE_WRITE
expr_stmt|;
if|if
condition|(
name|access_flags
operator|&
name|IB_ACCESS_REMOTE_READ
condition|)
name|hw_access_flags
operator||=
name|MTHCA_QP_BIT_RRE
expr_stmt|;
if|if
condition|(
name|access_flags
operator|&
name|IB_ACCESS_REMOTE_ATOMIC
condition|)
name|hw_access_flags
operator||=
name|MTHCA_QP_BIT_RAE
expr_stmt|;
if|if
condition|(
name|access_flags
operator|&
name|IB_ACCESS_REMOTE_WRITE
condition|)
name|hw_access_flags
operator||=
name|MTHCA_QP_BIT_RWE
expr_stmt|;
return|return
name|cpu_to_be32
argument_list|(
name|hw_access_flags
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|enum
name|ib_qp_state
name|to_ib_qp_state
parameter_list|(
name|int
name|mthca_state
parameter_list|)
block|{
switch|switch
condition|(
name|mthca_state
condition|)
block|{
case|case
name|MTHCA_QP_STATE_RST
case|:
return|return
name|IB_QPS_RESET
return|;
case|case
name|MTHCA_QP_STATE_INIT
case|:
return|return
name|IB_QPS_INIT
return|;
case|case
name|MTHCA_QP_STATE_RTR
case|:
return|return
name|IB_QPS_RTR
return|;
case|case
name|MTHCA_QP_STATE_RTS
case|:
return|return
name|IB_QPS_RTS
return|;
case|case
name|MTHCA_QP_STATE_DRAINING
case|:
case|case
name|MTHCA_QP_STATE_SQD
case|:
return|return
name|IB_QPS_SQD
return|;
case|case
name|MTHCA_QP_STATE_SQE
case|:
return|return
name|IB_QPS_SQE
return|;
case|case
name|MTHCA_QP_STATE_ERR
case|:
return|return
name|IB_QPS_ERR
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|enum
name|ib_mig_state
name|to_ib_mig_state
parameter_list|(
name|int
name|mthca_mig_state
parameter_list|)
block|{
switch|switch
condition|(
name|mthca_mig_state
condition|)
block|{
case|case
literal|0
case|:
return|return
name|IB_MIG_ARMED
return|;
case|case
literal|1
case|:
return|return
name|IB_MIG_REARM
return|;
case|case
literal|3
case|:
return|return
name|IB_MIG_MIGRATED
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|to_ib_qp_access_flags
parameter_list|(
name|int
name|mthca_flags
parameter_list|)
block|{
name|int
name|ib_flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mthca_flags
operator|&
name|MTHCA_QP_BIT_RRE
condition|)
name|ib_flags
operator||=
name|IB_ACCESS_REMOTE_READ
expr_stmt|;
if|if
condition|(
name|mthca_flags
operator|&
name|MTHCA_QP_BIT_RWE
condition|)
name|ib_flags
operator||=
name|IB_ACCESS_REMOTE_WRITE
expr_stmt|;
if|if
condition|(
name|mthca_flags
operator|&
name|MTHCA_QP_BIT_RAE
condition|)
name|ib_flags
operator||=
name|IB_ACCESS_REMOTE_ATOMIC
expr_stmt|;
return|return
name|ib_flags
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|to_ib_ah_attr
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|ib_ah_attr
modifier|*
name|ib_ah_attr
parameter_list|,
name|struct
name|mthca_qp_path
modifier|*
name|path
parameter_list|)
block|{
name|memset
argument_list|(
name|ib_ah_attr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|ib_ah_attr
argument_list|)
expr_stmt|;
name|ib_ah_attr
operator|->
name|port_num
operator|=
operator|(
name|be32_to_cpu
argument_list|(
name|path
operator|->
name|port_pkey
argument_list|)
operator|>>
literal|24
operator|)
operator|&
literal|0x3
expr_stmt|;
if|if
condition|(
name|ib_ah_attr
operator|->
name|port_num
operator|==
literal|0
operator|||
name|ib_ah_attr
operator|->
name|port_num
operator|>
name|dev
operator|->
name|limits
operator|.
name|num_ports
condition|)
return|return;
name|ib_ah_attr
operator|->
name|dlid
operator|=
name|be16_to_cpu
argument_list|(
name|path
operator|->
name|rlid
argument_list|)
expr_stmt|;
name|ib_ah_attr
operator|->
name|sl
operator|=
name|be32_to_cpu
argument_list|(
name|path
operator|->
name|sl_tclass_flowlabel
argument_list|)
operator|>>
literal|28
expr_stmt|;
name|ib_ah_attr
operator|->
name|src_path_bits
operator|=
name|path
operator|->
name|g_mylmc
operator|&
literal|0x7f
expr_stmt|;
name|ib_ah_attr
operator|->
name|static_rate
operator|=
name|mthca_rate_to_ib
argument_list|(
name|dev
argument_list|,
name|path
operator|->
name|static_rate
operator|&
literal|0xf
argument_list|,
name|ib_ah_attr
operator|->
name|port_num
argument_list|)
expr_stmt|;
name|ib_ah_attr
operator|->
name|ah_flags
operator|=
operator|(
name|path
operator|->
name|g_mylmc
operator|&
operator|(
literal|1
operator|<<
literal|7
operator|)
operator|)
condition|?
name|IB_AH_GRH
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|ib_ah_attr
operator|->
name|ah_flags
condition|)
block|{
name|ib_ah_attr
operator|->
name|grh
operator|.
name|sgid_index
operator|=
name|path
operator|->
name|mgid_index
operator|&
operator|(
name|dev
operator|->
name|limits
operator|.
name|gid_table_len
operator|-
literal|1
operator|)
expr_stmt|;
name|ib_ah_attr
operator|->
name|grh
operator|.
name|hop_limit
operator|=
name|path
operator|->
name|hop_limit
expr_stmt|;
name|ib_ah_attr
operator|->
name|grh
operator|.
name|traffic_class
operator|=
operator|(
name|be32_to_cpu
argument_list|(
name|path
operator|->
name|sl_tclass_flowlabel
argument_list|)
operator|>>
literal|20
operator|)
operator|&
literal|0xff
expr_stmt|;
name|ib_ah_attr
operator|->
name|grh
operator|.
name|flow_label
operator|=
name|be32_to_cpu
argument_list|(
name|path
operator|->
name|sl_tclass_flowlabel
argument_list|)
operator|&
literal|0xfffff
expr_stmt|;
name|memcpy
argument_list|(
name|ib_ah_attr
operator|->
name|grh
operator|.
name|dgid
operator|.
name|raw
argument_list|,
name|path
operator|->
name|rgid
argument_list|,
sizeof|sizeof
name|ib_ah_attr
operator|->
name|grh
operator|.
name|dgid
operator|.
name|raw
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|mthca_query_qp
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|ibqp
parameter_list|,
name|struct
name|ib_qp_attr
modifier|*
name|qp_attr
parameter_list|,
name|int
name|qp_attr_mask
parameter_list|,
name|struct
name|ib_qp_init_attr
modifier|*
name|qp_init_attr
parameter_list|)
block|{
name|struct
name|mthca_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ibqp
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mthca_qp
modifier|*
name|qp
init|=
name|to_mqp
argument_list|(
name|ibqp
argument_list|)
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|struct
name|mthca_mailbox
modifier|*
name|mailbox
init|=
name|NULL
decl_stmt|;
name|struct
name|mthca_qp_param
modifier|*
name|qp_param
decl_stmt|;
name|struct
name|mthca_qp_context
modifier|*
name|context
decl_stmt|;
name|int
name|mthca_state
decl_stmt|;
name|u8
name|status
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|qp
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|state
operator|==
name|IB_QPS_RESET
condition|)
block|{
name|qp_attr
operator|->
name|qp_state
operator|=
name|IB_QPS_RESET
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|mailbox
operator|=
name|mthca_alloc_mailbox
argument_list|(
name|dev
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
block|{
name|err
operator|=
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|err
operator|=
name|mthca_QUERY_QP
argument_list|(
name|dev
argument_list|,
name|qp
operator|->
name|qpn
argument_list|,
literal|0
argument_list|,
name|mailbox
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out_mailbox
goto|;
if|if
condition|(
name|status
condition|)
block|{
name|mthca_warn
argument_list|(
name|dev
argument_list|,
literal|"QUERY_QP returned status %02x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out_mailbox
goto|;
block|}
name|qp_param
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|context
operator|=
operator|&
name|qp_param
operator|->
name|context
expr_stmt|;
name|mthca_state
operator|=
name|be32_to_cpu
argument_list|(
name|context
operator|->
name|flags
argument_list|)
operator|>>
literal|28
expr_stmt|;
name|qp
operator|->
name|state
operator|=
name|to_ib_qp_state
argument_list|(
name|mthca_state
argument_list|)
expr_stmt|;
name|qp_attr
operator|->
name|qp_state
operator|=
name|qp
operator|->
name|state
expr_stmt|;
name|qp_attr
operator|->
name|path_mtu
operator|=
name|context
operator|->
name|mtu_msgmax
operator|>>
literal|5
expr_stmt|;
name|qp_attr
operator|->
name|path_mig_state
operator|=
name|to_ib_mig_state
argument_list|(
operator|(
name|be32_to_cpu
argument_list|(
name|context
operator|->
name|flags
argument_list|)
operator|>>
literal|11
operator|)
operator|&
literal|0x3
argument_list|)
expr_stmt|;
name|qp_attr
operator|->
name|qkey
operator|=
name|be32_to_cpu
argument_list|(
name|context
operator|->
name|qkey
argument_list|)
expr_stmt|;
name|qp_attr
operator|->
name|rq_psn
operator|=
name|be32_to_cpu
argument_list|(
name|context
operator|->
name|rnr_nextrecvpsn
argument_list|)
operator|&
literal|0xffffff
expr_stmt|;
name|qp_attr
operator|->
name|sq_psn
operator|=
name|be32_to_cpu
argument_list|(
name|context
operator|->
name|next_send_psn
argument_list|)
operator|&
literal|0xffffff
expr_stmt|;
name|qp_attr
operator|->
name|dest_qp_num
operator|=
name|be32_to_cpu
argument_list|(
name|context
operator|->
name|remote_qpn
argument_list|)
operator|&
literal|0xffffff
expr_stmt|;
name|qp_attr
operator|->
name|qp_access_flags
operator|=
name|to_ib_qp_access_flags
argument_list|(
name|be32_to_cpu
argument_list|(
name|context
operator|->
name|params2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|transport
operator|==
name|RC
operator|||
name|qp
operator|->
name|transport
operator|==
name|UC
condition|)
block|{
name|to_ib_ah_attr
argument_list|(
name|dev
argument_list|,
operator|&
name|qp_attr
operator|->
name|ah_attr
argument_list|,
operator|&
name|context
operator|->
name|pri_path
argument_list|)
expr_stmt|;
name|to_ib_ah_attr
argument_list|(
name|dev
argument_list|,
operator|&
name|qp_attr
operator|->
name|alt_ah_attr
argument_list|,
operator|&
name|context
operator|->
name|alt_path
argument_list|)
expr_stmt|;
name|qp_attr
operator|->
name|alt_pkey_index
operator|=
name|be32_to_cpu
argument_list|(
name|context
operator|->
name|alt_path
operator|.
name|port_pkey
argument_list|)
operator|&
literal|0x7f
expr_stmt|;
name|qp_attr
operator|->
name|alt_port_num
operator|=
name|qp_attr
operator|->
name|alt_ah_attr
operator|.
name|port_num
expr_stmt|;
block|}
name|qp_attr
operator|->
name|pkey_index
operator|=
name|be32_to_cpu
argument_list|(
name|context
operator|->
name|pri_path
operator|.
name|port_pkey
argument_list|)
operator|&
literal|0x7f
expr_stmt|;
name|qp_attr
operator|->
name|port_num
operator|=
operator|(
name|be32_to_cpu
argument_list|(
name|context
operator|->
name|pri_path
operator|.
name|port_pkey
argument_list|)
operator|>>
literal|24
operator|)
operator|&
literal|0x3
expr_stmt|;
comment|/* qp_attr->en_sqd_async_notify is only applicable in modify qp */
name|qp_attr
operator|->
name|sq_draining
operator|=
name|mthca_state
operator|==
name|MTHCA_QP_STATE_DRAINING
expr_stmt|;
name|qp_attr
operator|->
name|max_rd_atomic
operator|=
literal|1
operator|<<
operator|(
operator|(
name|be32_to_cpu
argument_list|(
name|context
operator|->
name|params1
argument_list|)
operator|>>
literal|21
operator|)
operator|&
literal|0x7
operator|)
expr_stmt|;
name|qp_attr
operator|->
name|max_dest_rd_atomic
operator|=
literal|1
operator|<<
operator|(
operator|(
name|be32_to_cpu
argument_list|(
name|context
operator|->
name|params2
argument_list|)
operator|>>
literal|21
operator|)
operator|&
literal|0x7
operator|)
expr_stmt|;
name|qp_attr
operator|->
name|min_rnr_timer
operator|=
operator|(
name|be32_to_cpu
argument_list|(
name|context
operator|->
name|rnr_nextrecvpsn
argument_list|)
operator|>>
literal|24
operator|)
operator|&
literal|0x1f
expr_stmt|;
name|qp_attr
operator|->
name|timeout
operator|=
name|context
operator|->
name|pri_path
operator|.
name|ackto
operator|>>
literal|3
expr_stmt|;
name|qp_attr
operator|->
name|retry_cnt
operator|=
operator|(
name|be32_to_cpu
argument_list|(
name|context
operator|->
name|params1
argument_list|)
operator|>>
literal|16
operator|)
operator|&
literal|0x7
expr_stmt|;
name|qp_attr
operator|->
name|rnr_retry
operator|=
name|context
operator|->
name|pri_path
operator|.
name|rnr_retry
operator|>>
literal|5
expr_stmt|;
name|qp_attr
operator|->
name|alt_timeout
operator|=
name|context
operator|->
name|alt_path
operator|.
name|ackto
operator|>>
literal|3
expr_stmt|;
name|done
label|:
name|qp_attr
operator|->
name|cur_qp_state
operator|=
name|qp_attr
operator|->
name|qp_state
expr_stmt|;
name|qp_attr
operator|->
name|cap
operator|.
name|max_send_wr
operator|=
name|qp
operator|->
name|sq
operator|.
name|max
expr_stmt|;
name|qp_attr
operator|->
name|cap
operator|.
name|max_recv_wr
operator|=
name|qp
operator|->
name|rq
operator|.
name|max
expr_stmt|;
name|qp_attr
operator|->
name|cap
operator|.
name|max_send_sge
operator|=
name|qp
operator|->
name|sq
operator|.
name|max_gs
expr_stmt|;
name|qp_attr
operator|->
name|cap
operator|.
name|max_recv_sge
operator|=
name|qp
operator|->
name|rq
operator|.
name|max_gs
expr_stmt|;
name|qp_attr
operator|->
name|cap
operator|.
name|max_inline_data
operator|=
name|qp
operator|->
name|max_inline_data
expr_stmt|;
name|qp_init_attr
operator|->
name|cap
operator|=
name|qp_attr
operator|->
name|cap
expr_stmt|;
name|out_mailbox
label|:
name|mthca_free_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
name|out
label|:
name|mutex_unlock
argument_list|(
operator|&
name|qp
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mthca_path_set
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
specifier|const
name|struct
name|ib_ah_attr
modifier|*
name|ah
parameter_list|,
name|struct
name|mthca_qp_path
modifier|*
name|path
parameter_list|,
name|u8
name|port
parameter_list|)
block|{
name|path
operator|->
name|g_mylmc
operator|=
name|ah
operator|->
name|src_path_bits
operator|&
literal|0x7f
expr_stmt|;
name|path
operator|->
name|rlid
operator|=
name|cpu_to_be16
argument_list|(
name|ah
operator|->
name|dlid
argument_list|)
expr_stmt|;
name|path
operator|->
name|static_rate
operator|=
name|mthca_get_rate
argument_list|(
name|dev
argument_list|,
name|ah
operator|->
name|static_rate
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|ah
operator|->
name|ah_flags
operator|&
name|IB_AH_GRH
condition|)
block|{
if|if
condition|(
name|ah
operator|->
name|grh
operator|.
name|sgid_index
operator|>=
name|dev
operator|->
name|limits
operator|.
name|gid_table_len
condition|)
block|{
name|mthca_dbg
argument_list|(
name|dev
argument_list|,
literal|"sgid_index (%u) too large. max is %d\n"
argument_list|,
name|ah
operator|->
name|grh
operator|.
name|sgid_index
argument_list|,
name|dev
operator|->
name|limits
operator|.
name|gid_table_len
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|path
operator|->
name|g_mylmc
operator||=
literal|1
operator|<<
literal|7
expr_stmt|;
name|path
operator|->
name|mgid_index
operator|=
name|ah
operator|->
name|grh
operator|.
name|sgid_index
expr_stmt|;
name|path
operator|->
name|hop_limit
operator|=
name|ah
operator|->
name|grh
operator|.
name|hop_limit
expr_stmt|;
name|path
operator|->
name|sl_tclass_flowlabel
operator|=
name|cpu_to_be32
argument_list|(
operator|(
name|ah
operator|->
name|sl
operator|<<
literal|28
operator|)
operator||
operator|(
name|ah
operator|->
name|grh
operator|.
name|traffic_class
operator|<<
literal|20
operator|)
operator||
operator|(
name|ah
operator|->
name|grh
operator|.
name|flow_label
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|path
operator|->
name|rgid
argument_list|,
name|ah
operator|->
name|grh
operator|.
name|dgid
operator|.
name|raw
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
name|path
operator|->
name|sl_tclass_flowlabel
operator|=
name|cpu_to_be32
argument_list|(
name|ah
operator|->
name|sl
operator|<<
literal|28
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__mthca_modify_qp
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|ibqp
parameter_list|,
specifier|const
name|struct
name|ib_qp_attr
modifier|*
name|attr
parameter_list|,
name|int
name|attr_mask
parameter_list|,
name|enum
name|ib_qp_state
name|cur_state
parameter_list|,
name|enum
name|ib_qp_state
name|new_state
parameter_list|)
block|{
name|struct
name|mthca_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ibqp
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mthca_qp
modifier|*
name|qp
init|=
name|to_mqp
argument_list|(
name|ibqp
argument_list|)
decl_stmt|;
name|struct
name|mthca_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|struct
name|mthca_qp_param
modifier|*
name|qp_param
decl_stmt|;
name|struct
name|mthca_qp_context
modifier|*
name|qp_context
decl_stmt|;
name|u32
name|sqd_event
init|=
literal|0
decl_stmt|;
name|u8
name|status
decl_stmt|;
name|int
name|err
init|=
operator|-
name|EINVAL
decl_stmt|;
name|mailbox
operator|=
name|mthca_alloc_mailbox
argument_list|(
name|dev
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
block|{
name|err
operator|=
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|qp_param
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|qp_context
operator|=
operator|&
name|qp_param
operator|->
name|context
expr_stmt|;
name|memset
argument_list|(
name|qp_param
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|qp_param
argument_list|)
expr_stmt|;
name|qp_context
operator|->
name|flags
operator|=
name|cpu_to_be32
argument_list|(
operator|(
name|to_mthca_state
argument_list|(
name|new_state
argument_list|)
operator|<<
literal|28
operator|)
operator||
operator|(
name|to_mthca_st
argument_list|(
name|qp
operator|->
name|transport
argument_list|)
operator|<<
literal|16
operator|)
argument_list|)
expr_stmt|;
name|qp_context
operator|->
name|flags
operator||=
name|cpu_to_be32
argument_list|(
name|MTHCA_QP_BIT_DE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|attr_mask
operator|&
name|IB_QP_PATH_MIG_STATE
operator|)
condition|)
name|qp_context
operator|->
name|flags
operator||=
name|cpu_to_be32
argument_list|(
name|MTHCA_QP_PM_MIGRATED
operator|<<
literal|11
argument_list|)
expr_stmt|;
else|else
block|{
name|qp_param
operator|->
name|opt_param_mask
operator||=
name|cpu_to_be32
argument_list|(
name|MTHCA_QP_OPTPAR_PM_STATE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|attr
operator|->
name|path_mig_state
condition|)
block|{
case|case
name|IB_MIG_MIGRATED
case|:
name|qp_context
operator|->
name|flags
operator||=
name|cpu_to_be32
argument_list|(
name|MTHCA_QP_PM_MIGRATED
operator|<<
literal|11
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_MIG_REARM
case|:
name|qp_context
operator|->
name|flags
operator||=
name|cpu_to_be32
argument_list|(
name|MTHCA_QP_PM_REARM
operator|<<
literal|11
argument_list|)
expr_stmt|;
break|break;
case|case
name|IB_MIG_ARMED
case|:
name|qp_context
operator|->
name|flags
operator||=
name|cpu_to_be32
argument_list|(
name|MTHCA_QP_PM_ARMED
operator|<<
literal|11
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* leave tavor_sched_queue as 0 */
if|if
condition|(
name|qp
operator|->
name|transport
operator|==
name|MLX
operator|||
name|qp
operator|->
name|transport
operator|==
name|UD
condition|)
name|qp_context
operator|->
name|mtu_msgmax
operator|=
operator|(
name|IB_MTU_2048
operator|<<
literal|5
operator|)
operator||
literal|11
expr_stmt|;
elseif|else
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_PATH_MTU
condition|)
block|{
if|if
condition|(
name|attr
operator|->
name|path_mtu
operator|<
name|IB_MTU_256
operator|||
name|attr
operator|->
name|path_mtu
operator|>
name|IB_MTU_2048
condition|)
block|{
name|mthca_dbg
argument_list|(
name|dev
argument_list|,
literal|"path MTU (%u) is invalid\n"
argument_list|,
name|attr
operator|->
name|path_mtu
argument_list|)
expr_stmt|;
goto|goto
name|out_mailbox
goto|;
block|}
name|qp_context
operator|->
name|mtu_msgmax
operator|=
operator|(
name|attr
operator|->
name|path_mtu
operator|<<
literal|5
operator|)
operator||
literal|31
expr_stmt|;
block|}
if|if
condition|(
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
block|{
if|if
condition|(
name|qp
operator|->
name|rq
operator|.
name|max
condition|)
name|qp_context
operator|->
name|rq_size_stride
operator|=
name|ilog2
argument_list|(
name|qp
operator|->
name|rq
operator|.
name|max
argument_list|)
operator|<<
literal|3
expr_stmt|;
name|qp_context
operator|->
name|rq_size_stride
operator||=
name|qp
operator|->
name|rq
operator|.
name|wqe_shift
operator|-
literal|4
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|sq
operator|.
name|max
condition|)
name|qp_context
operator|->
name|sq_size_stride
operator|=
name|ilog2
argument_list|(
name|qp
operator|->
name|sq
operator|.
name|max
argument_list|)
operator|<<
literal|3
expr_stmt|;
name|qp_context
operator|->
name|sq_size_stride
operator||=
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|-
literal|4
expr_stmt|;
block|}
comment|/* leave arbel_sched_queue as 0 */
if|if
condition|(
name|qp
operator|->
name|ibqp
operator|.
name|uobject
condition|)
name|qp_context
operator|->
name|usr_page
operator|=
name|cpu_to_be32
argument_list|(
name|to_mucontext
argument_list|(
name|qp
operator|->
name|ibqp
operator|.
name|uobject
operator|->
name|context
argument_list|)
operator|->
name|uar
operator|.
name|index
argument_list|)
expr_stmt|;
else|else
name|qp_context
operator|->
name|usr_page
operator|=
name|cpu_to_be32
argument_list|(
name|dev
operator|->
name|driver_uar
operator|.
name|index
argument_list|)
expr_stmt|;
name|qp_context
operator|->
name|local_qpn
operator|=
name|cpu_to_be32
argument_list|(
name|qp
operator|->
name|qpn
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_DEST_QPN
condition|)
block|{
name|qp_context
operator|->
name|remote_qpn
operator|=
name|cpu_to_be32
argument_list|(
name|attr
operator|->
name|dest_qp_num
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|transport
operator|==
name|MLX
condition|)
name|qp_context
operator|->
name|pri_path
operator|.
name|port_pkey
operator||=
name|cpu_to_be32
argument_list|(
name|qp
operator|->
name|port
operator|<<
literal|24
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_PORT
condition|)
block|{
name|qp_context
operator|->
name|pri_path
operator|.
name|port_pkey
operator||=
name|cpu_to_be32
argument_list|(
name|attr
operator|->
name|port_num
operator|<<
literal|24
argument_list|)
expr_stmt|;
name|qp_param
operator|->
name|opt_param_mask
operator||=
name|cpu_to_be32
argument_list|(
name|MTHCA_QP_OPTPAR_PORT_NUM
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_PKEY_INDEX
condition|)
block|{
name|qp_context
operator|->
name|pri_path
operator|.
name|port_pkey
operator||=
name|cpu_to_be32
argument_list|(
name|attr
operator|->
name|pkey_index
argument_list|)
expr_stmt|;
name|qp_param
operator|->
name|opt_param_mask
operator||=
name|cpu_to_be32
argument_list|(
name|MTHCA_QP_OPTPAR_PKEY_INDEX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_RNR_RETRY
condition|)
block|{
name|qp_context
operator|->
name|alt_path
operator|.
name|rnr_retry
operator|=
name|qp_context
operator|->
name|pri_path
operator|.
name|rnr_retry
operator|=
name|attr
operator|->
name|rnr_retry
operator|<<
literal|5
expr_stmt|;
name|qp_param
operator|->
name|opt_param_mask
operator||=
name|cpu_to_be32
argument_list|(
name|MTHCA_QP_OPTPAR_RNR_RETRY
operator||
name|MTHCA_QP_OPTPAR_ALT_RNR_RETRY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_AV
condition|)
block|{
if|if
condition|(
name|mthca_path_set
argument_list|(
name|dev
argument_list|,
operator|&
name|attr
operator|->
name|ah_attr
argument_list|,
operator|&
name|qp_context
operator|->
name|pri_path
argument_list|,
name|attr_mask
operator|&
name|IB_QP_PORT
condition|?
name|attr
operator|->
name|port_num
else|:
name|qp
operator|->
name|port
argument_list|)
condition|)
goto|goto
name|out_mailbox
goto|;
name|qp_param
operator|->
name|opt_param_mask
operator||=
name|cpu_to_be32
argument_list|(
name|MTHCA_QP_OPTPAR_PRIMARY_ADDR_PATH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ibqp
operator|->
name|qp_type
operator|==
name|IB_QPT_RC
operator|&&
name|cur_state
operator|==
name|IB_QPS_INIT
operator|&&
name|new_state
operator|==
name|IB_QPS_RTR
condition|)
block|{
name|u8
name|sched_queue
init|=
name|ibqp
operator|->
name|uobject
condition|?
literal|0x2
else|:
literal|0x1
decl_stmt|;
if|if
condition|(
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
name|qp_context
operator|->
name|rlkey_arbel_sched_queue
operator||=
name|sched_queue
expr_stmt|;
else|else
name|qp_context
operator|->
name|tavor_sched_queue
operator||=
name|cpu_to_be32
argument_list|(
name|sched_queue
argument_list|)
expr_stmt|;
name|qp_param
operator|->
name|opt_param_mask
operator||=
name|cpu_to_be32
argument_list|(
name|MTHCA_QP_OPTPAR_SCHED_QUEUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_TIMEOUT
condition|)
block|{
name|qp_context
operator|->
name|pri_path
operator|.
name|ackto
operator|=
name|attr
operator|->
name|timeout
operator|<<
literal|3
expr_stmt|;
name|qp_param
operator|->
name|opt_param_mask
operator||=
name|cpu_to_be32
argument_list|(
name|MTHCA_QP_OPTPAR_ACK_TIMEOUT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_ALT_PATH
condition|)
block|{
if|if
condition|(
name|attr
operator|->
name|alt_pkey_index
operator|>=
name|dev
operator|->
name|limits
operator|.
name|pkey_table_len
condition|)
block|{
name|mthca_dbg
argument_list|(
name|dev
argument_list|,
literal|"Alternate P_Key index (%u) too large. max is %d\n"
argument_list|,
name|attr
operator|->
name|alt_pkey_index
argument_list|,
name|dev
operator|->
name|limits
operator|.
name|pkey_table_len
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|out_mailbox
goto|;
block|}
if|if
condition|(
name|attr
operator|->
name|alt_port_num
operator|==
literal|0
operator|||
name|attr
operator|->
name|alt_port_num
operator|>
name|dev
operator|->
name|limits
operator|.
name|num_ports
condition|)
block|{
name|mthca_dbg
argument_list|(
name|dev
argument_list|,
literal|"Alternate port number (%u) is invalid\n"
argument_list|,
name|attr
operator|->
name|alt_port_num
argument_list|)
expr_stmt|;
goto|goto
name|out_mailbox
goto|;
block|}
if|if
condition|(
name|mthca_path_set
argument_list|(
name|dev
argument_list|,
operator|&
name|attr
operator|->
name|alt_ah_attr
argument_list|,
operator|&
name|qp_context
operator|->
name|alt_path
argument_list|,
name|attr
operator|->
name|alt_ah_attr
operator|.
name|port_num
argument_list|)
condition|)
goto|goto
name|out_mailbox
goto|;
name|qp_context
operator|->
name|alt_path
operator|.
name|port_pkey
operator||=
name|cpu_to_be32
argument_list|(
name|attr
operator|->
name|alt_pkey_index
operator||
name|attr
operator|->
name|alt_port_num
operator|<<
literal|24
argument_list|)
expr_stmt|;
name|qp_context
operator|->
name|alt_path
operator|.
name|ackto
operator|=
name|attr
operator|->
name|alt_timeout
operator|<<
literal|3
expr_stmt|;
name|qp_param
operator|->
name|opt_param_mask
operator||=
name|cpu_to_be32
argument_list|(
name|MTHCA_QP_OPTPAR_ALT_ADDR_PATH
argument_list|)
expr_stmt|;
block|}
comment|/* leave rdd as 0 */
name|qp_context
operator|->
name|pd
operator|=
name|cpu_to_be32
argument_list|(
name|to_mpd
argument_list|(
name|ibqp
operator|->
name|pd
argument_list|)
operator|->
name|pd_num
argument_list|)
expr_stmt|;
comment|/* leave wqe_base as 0 (we always create an MR based at 0 for WQs) */
name|qp_context
operator|->
name|wqe_lkey
operator|=
name|cpu_to_be32
argument_list|(
name|qp
operator|->
name|mr
operator|.
name|ibmr
operator|.
name|lkey
argument_list|)
expr_stmt|;
name|qp_context
operator|->
name|params1
operator|=
name|cpu_to_be32
argument_list|(
operator|(
name|MTHCA_ACK_REQ_FREQ
operator|<<
literal|28
operator|)
operator||
operator|(
name|MTHCA_FLIGHT_LIMIT
operator|<<
literal|24
operator|)
operator||
name|MTHCA_QP_BIT_SWE
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|sq_policy
operator|==
name|IB_SIGNAL_ALL_WR
condition|)
name|qp_context
operator|->
name|params1
operator||=
name|cpu_to_be32
argument_list|(
name|MTHCA_QP_BIT_SSC
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_RETRY_CNT
condition|)
block|{
name|qp_context
operator|->
name|params1
operator||=
name|cpu_to_be32
argument_list|(
name|attr
operator|->
name|retry_cnt
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|qp_param
operator|->
name|opt_param_mask
operator||=
name|cpu_to_be32
argument_list|(
name|MTHCA_QP_OPTPAR_RETRY_COUNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_MAX_QP_RD_ATOMIC
condition|)
block|{
if|if
condition|(
name|attr
operator|->
name|max_rd_atomic
condition|)
block|{
name|qp_context
operator|->
name|params1
operator||=
name|cpu_to_be32
argument_list|(
name|MTHCA_QP_BIT_SRE
operator||
name|MTHCA_QP_BIT_SAE
argument_list|)
expr_stmt|;
name|qp_context
operator|->
name|params1
operator||=
name|cpu_to_be32
argument_list|(
name|fls
argument_list|(
name|attr
operator|->
name|max_rd_atomic
operator|-
literal|1
argument_list|)
operator|<<
literal|21
argument_list|)
expr_stmt|;
block|}
name|qp_param
operator|->
name|opt_param_mask
operator||=
name|cpu_to_be32
argument_list|(
name|MTHCA_QP_OPTPAR_SRA_MAX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_SQ_PSN
condition|)
name|qp_context
operator|->
name|next_send_psn
operator|=
name|cpu_to_be32
argument_list|(
name|attr
operator|->
name|sq_psn
argument_list|)
expr_stmt|;
name|qp_context
operator|->
name|cqn_snd
operator|=
name|cpu_to_be32
argument_list|(
name|to_mcq
argument_list|(
name|ibqp
operator|->
name|send_cq
argument_list|)
operator|->
name|cqn
argument_list|)
expr_stmt|;
if|if
condition|(
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|qp_context
operator|->
name|snd_wqe_base_l
operator|=
name|cpu_to_be32
argument_list|(
name|qp
operator|->
name|send_wqe_offset
argument_list|)
expr_stmt|;
name|qp_context
operator|->
name|snd_db_index
operator|=
name|cpu_to_be32
argument_list|(
name|qp
operator|->
name|sq
operator|.
name|db_index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_MAX_DEST_RD_ATOMIC
condition|)
block|{
if|if
condition|(
name|attr
operator|->
name|max_dest_rd_atomic
condition|)
name|qp_context
operator|->
name|params2
operator||=
name|cpu_to_be32
argument_list|(
name|fls
argument_list|(
name|attr
operator|->
name|max_dest_rd_atomic
operator|-
literal|1
argument_list|)
operator|<<
literal|21
argument_list|)
expr_stmt|;
name|qp_param
operator|->
name|opt_param_mask
operator||=
name|cpu_to_be32
argument_list|(
name|MTHCA_QP_OPTPAR_RRA_MAX
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attr_mask
operator|&
operator|(
name|IB_QP_ACCESS_FLAGS
operator||
name|IB_QP_MAX_DEST_RD_ATOMIC
operator|)
condition|)
block|{
name|qp_context
operator|->
name|params2
operator||=
name|get_hw_access_flags
argument_list|(
name|qp
argument_list|,
name|attr
argument_list|,
name|attr_mask
argument_list|)
expr_stmt|;
name|qp_param
operator|->
name|opt_param_mask
operator||=
name|cpu_to_be32
argument_list|(
name|MTHCA_QP_OPTPAR_RWE
operator||
name|MTHCA_QP_OPTPAR_RRE
operator||
name|MTHCA_QP_OPTPAR_RAE
argument_list|)
expr_stmt|;
block|}
name|qp_context
operator|->
name|params2
operator||=
name|cpu_to_be32
argument_list|(
name|MTHCA_QP_BIT_RSC
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibqp
operator|->
name|srq
condition|)
name|qp_context
operator|->
name|params2
operator||=
name|cpu_to_be32
argument_list|(
name|MTHCA_QP_BIT_RIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_MIN_RNR_TIMER
condition|)
block|{
name|qp_context
operator|->
name|rnr_nextrecvpsn
operator||=
name|cpu_to_be32
argument_list|(
name|attr
operator|->
name|min_rnr_timer
operator|<<
literal|24
argument_list|)
expr_stmt|;
name|qp_param
operator|->
name|opt_param_mask
operator||=
name|cpu_to_be32
argument_list|(
name|MTHCA_QP_OPTPAR_RNR_TIMEOUT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_RQ_PSN
condition|)
name|qp_context
operator|->
name|rnr_nextrecvpsn
operator||=
name|cpu_to_be32
argument_list|(
name|attr
operator|->
name|rq_psn
argument_list|)
expr_stmt|;
name|qp_context
operator|->
name|ra_buff_indx
operator|=
name|cpu_to_be32
argument_list|(
name|dev
operator|->
name|qp_table
operator|.
name|rdb_base
operator|+
operator|(
operator|(
name|qp
operator|->
name|qpn
operator|&
operator|(
name|dev
operator|->
name|limits
operator|.
name|num_qps
operator|-
literal|1
operator|)
operator|)
operator|*
name|MTHCA_RDB_ENTRY_SIZE
operator|<<
name|dev
operator|->
name|qp_table
operator|.
name|rdb_shift
operator|)
argument_list|)
expr_stmt|;
name|qp_context
operator|->
name|cqn_rcv
operator|=
name|cpu_to_be32
argument_list|(
name|to_mcq
argument_list|(
name|ibqp
operator|->
name|recv_cq
argument_list|)
operator|->
name|cqn
argument_list|)
expr_stmt|;
if|if
condition|(
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
name|qp_context
operator|->
name|rcv_db_index
operator|=
name|cpu_to_be32
argument_list|(
name|qp
operator|->
name|rq
operator|.
name|db_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_QKEY
condition|)
block|{
name|qp_context
operator|->
name|qkey
operator|=
name|cpu_to_be32
argument_list|(
name|attr
operator|->
name|qkey
argument_list|)
expr_stmt|;
name|qp_param
operator|->
name|opt_param_mask
operator||=
name|cpu_to_be32
argument_list|(
name|MTHCA_QP_OPTPAR_Q_KEY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ibqp
operator|->
name|srq
condition|)
name|qp_context
operator|->
name|srqn
operator|=
name|cpu_to_be32
argument_list|(
literal|1
operator|<<
literal|24
operator||
name|to_msrq
argument_list|(
name|ibqp
operator|->
name|srq
argument_list|)
operator|->
name|srqn
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_state
operator|==
name|IB_QPS_RTS
operator|&&
name|new_state
operator|==
name|IB_QPS_SQD
operator|&&
name|attr_mask
operator|&
name|IB_QP_EN_SQD_ASYNC_NOTIFY
operator|&&
name|attr
operator|->
name|en_sqd_async_notify
condition|)
name|sqd_event
operator|=
literal|1
operator|<<
literal|31
expr_stmt|;
name|err
operator|=
name|mthca_MODIFY_QP
argument_list|(
name|dev
argument_list|,
name|cur_state
argument_list|,
name|new_state
argument_list|,
name|qp
operator|->
name|qpn
argument_list|,
literal|0
argument_list|,
name|mailbox
argument_list|,
name|sqd_event
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out_mailbox
goto|;
if|if
condition|(
name|status
condition|)
block|{
name|mthca_warn
argument_list|(
name|dev
argument_list|,
literal|"modify QP %d->%d returned status %02x.\n"
argument_list|,
name|cur_state
argument_list|,
name|new_state
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out_mailbox
goto|;
block|}
name|qp
operator|->
name|state
operator|=
name|new_state
expr_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_ACCESS_FLAGS
condition|)
name|qp
operator|->
name|atomic_rd_en
operator|=
name|attr
operator|->
name|qp_access_flags
expr_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_MAX_DEST_RD_ATOMIC
condition|)
name|qp
operator|->
name|resp_depth
operator|=
name|attr
operator|->
name|max_dest_rd_atomic
expr_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_PORT
condition|)
name|qp
operator|->
name|port
operator|=
name|attr
operator|->
name|port_num
expr_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_ALT_PATH
condition|)
name|qp
operator|->
name|alt_port
operator|=
name|attr
operator|->
name|alt_port_num
expr_stmt|;
if|if
condition|(
name|is_sqp
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|)
condition|)
name|store_attrs
argument_list|(
name|to_msqp
argument_list|(
name|qp
argument_list|)
argument_list|,
name|attr
argument_list|,
name|attr_mask
argument_list|)
expr_stmt|;
comment|/* 	 * If we moved QP0 to RTR, bring the IB link up; if we moved 	 * QP0 to RESET or ERROR, bring the link back down. 	 */
if|if
condition|(
name|is_qp0
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|)
condition|)
block|{
if|if
condition|(
name|cur_state
operator|!=
name|IB_QPS_RTR
operator|&&
name|new_state
operator|==
name|IB_QPS_RTR
condition|)
name|init_port
argument_list|(
name|dev
argument_list|,
name|qp
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_state
operator|!=
name|IB_QPS_RESET
operator|&&
name|cur_state
operator|!=
name|IB_QPS_ERR
operator|&&
operator|(
name|new_state
operator|==
name|IB_QPS_RESET
operator|||
name|new_state
operator|==
name|IB_QPS_ERR
operator|)
condition|)
name|mthca_CLOSE_IB
argument_list|(
name|dev
argument_list|,
name|qp
operator|->
name|port
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we moved a kernel QP to RESET, clean up all old CQ 	 * entries and reinitialize the QP. 	 */
if|if
condition|(
name|new_state
operator|==
name|IB_QPS_RESET
operator|&&
operator|!
name|qp
operator|->
name|ibqp
operator|.
name|uobject
condition|)
block|{
name|mthca_cq_clean
argument_list|(
name|dev
argument_list|,
name|to_mcq
argument_list|(
name|qp
operator|->
name|ibqp
operator|.
name|recv_cq
argument_list|)
argument_list|,
name|qp
operator|->
name|qpn
argument_list|,
name|qp
operator|->
name|ibqp
operator|.
name|srq
condition|?
name|to_msrq
argument_list|(
name|qp
operator|->
name|ibqp
operator|.
name|srq
argument_list|)
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|ibqp
operator|.
name|send_cq
operator|!=
name|qp
operator|->
name|ibqp
operator|.
name|recv_cq
condition|)
name|mthca_cq_clean
argument_list|(
name|dev
argument_list|,
name|to_mcq
argument_list|(
name|qp
operator|->
name|ibqp
operator|.
name|send_cq
argument_list|)
argument_list|,
name|qp
operator|->
name|qpn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mthca_wq_reset
argument_list|(
operator|&
name|qp
operator|->
name|sq
argument_list|)
expr_stmt|;
name|qp
operator|->
name|sq
operator|.
name|last
operator|=
name|get_send_wqe
argument_list|(
name|qp
argument_list|,
name|qp
operator|->
name|sq
operator|.
name|max
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mthca_wq_reset
argument_list|(
operator|&
name|qp
operator|->
name|rq
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rq
operator|.
name|last
operator|=
name|get_recv_wqe
argument_list|(
name|qp
argument_list|,
name|qp
operator|->
name|rq
operator|.
name|max
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
block|{
operator|*
name|qp
operator|->
name|sq
operator|.
name|db
operator|=
literal|0
expr_stmt|;
operator|*
name|qp
operator|->
name|rq
operator|.
name|db
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|out_mailbox
label|:
name|mthca_free_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mthca_modify_qp
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|ibqp
parameter_list|,
name|struct
name|ib_qp_attr
modifier|*
name|attr
parameter_list|,
name|int
name|attr_mask
parameter_list|,
name|struct
name|ib_udata
modifier|*
name|udata
parameter_list|)
block|{
name|struct
name|mthca_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ibqp
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mthca_qp
modifier|*
name|qp
init|=
name|to_mqp
argument_list|(
name|ibqp
argument_list|)
decl_stmt|;
name|enum
name|ib_qp_state
name|cur_state
decl_stmt|,
name|new_state
decl_stmt|;
name|int
name|err
init|=
operator|-
name|EINVAL
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|qp
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_CUR_STATE
condition|)
block|{
name|cur_state
operator|=
name|attr
operator|->
name|cur_qp_state
expr_stmt|;
block|}
else|else
block|{
name|spin_lock_irq
argument_list|(
operator|&
name|qp
operator|->
name|sq
operator|.
name|lock
argument_list|)
expr_stmt|;
name|spin_lock
argument_list|(
operator|&
name|qp
operator|->
name|rq
operator|.
name|lock
argument_list|)
expr_stmt|;
name|cur_state
operator|=
name|qp
operator|->
name|state
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|qp
operator|->
name|rq
operator|.
name|lock
argument_list|)
expr_stmt|;
name|spin_unlock_irq
argument_list|(
operator|&
name|qp
operator|->
name|sq
operator|.
name|lock
argument_list|)
expr_stmt|;
block|}
name|new_state
operator|=
name|attr_mask
operator|&
name|IB_QP_STATE
condition|?
name|attr
operator|->
name|qp_state
else|:
name|cur_state
expr_stmt|;
if|if
condition|(
operator|!
name|ib_modify_qp_is_ok
argument_list|(
name|cur_state
argument_list|,
name|new_state
argument_list|,
name|ibqp
operator|->
name|qp_type
argument_list|,
name|attr_mask
argument_list|)
condition|)
block|{
name|mthca_dbg
argument_list|(
name|dev
argument_list|,
literal|"Bad QP transition (transport %d) "
literal|"%d->%d with attr 0x%08x\n"
argument_list|,
name|qp
operator|->
name|transport
argument_list|,
name|cur_state
argument_list|,
name|new_state
argument_list|,
name|attr_mask
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|attr_mask
operator|&
name|IB_QP_PKEY_INDEX
operator|)
operator|&&
name|attr
operator|->
name|pkey_index
operator|>=
name|dev
operator|->
name|limits
operator|.
name|pkey_table_len
condition|)
block|{
name|mthca_dbg
argument_list|(
name|dev
argument_list|,
literal|"P_Key index (%u) too large. max is %d\n"
argument_list|,
name|attr
operator|->
name|pkey_index
argument_list|,
name|dev
operator|->
name|limits
operator|.
name|pkey_table_len
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|attr_mask
operator|&
name|IB_QP_PORT
operator|)
operator|&&
operator|(
name|attr
operator|->
name|port_num
operator|==
literal|0
operator|||
name|attr
operator|->
name|port_num
operator|>
name|dev
operator|->
name|limits
operator|.
name|num_ports
operator|)
condition|)
block|{
name|mthca_dbg
argument_list|(
name|dev
argument_list|,
literal|"Port number (%u) is invalid\n"
argument_list|,
name|attr
operator|->
name|port_num
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_MAX_QP_RD_ATOMIC
operator|&&
name|attr
operator|->
name|max_rd_atomic
operator|>
name|dev
operator|->
name|limits
operator|.
name|max_qp_init_rdma
condition|)
block|{
name|mthca_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max rdma_atomic as initiator %u too large (max is %d)\n"
argument_list|,
name|attr
operator|->
name|max_rd_atomic
argument_list|,
name|dev
operator|->
name|limits
operator|.
name|max_qp_init_rdma
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|attr_mask
operator|&
name|IB_QP_MAX_DEST_RD_ATOMIC
operator|&&
name|attr
operator|->
name|max_dest_rd_atomic
operator|>
literal|1
operator|<<
name|dev
operator|->
name|qp_table
operator|.
name|rdb_shift
condition|)
block|{
name|mthca_dbg
argument_list|(
name|dev
argument_list|,
literal|"Max rdma_atomic as responder %u too large (max %d)\n"
argument_list|,
name|attr
operator|->
name|max_dest_rd_atomic
argument_list|,
literal|1
operator|<<
name|dev
operator|->
name|qp_table
operator|.
name|rdb_shift
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|cur_state
operator|==
name|new_state
operator|&&
name|cur_state
operator|==
name|IB_QPS_RESET
condition|)
block|{
name|err
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|err
operator|=
name|__mthca_modify_qp
argument_list|(
name|ibqp
argument_list|,
name|attr
argument_list|,
name|attr_mask
argument_list|,
name|cur_state
argument_list|,
name|new_state
argument_list|)
expr_stmt|;
name|out
label|:
name|mutex_unlock
argument_list|(
operator|&
name|qp
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mthca_max_data_size
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_qp
modifier|*
name|qp
parameter_list|,
name|int
name|desc_sz
parameter_list|)
block|{
comment|/* 	 * Calculate the maximum size of WQE s/g segments, excluding 	 * the next segment and other non-data segments. 	 */
name|int
name|max_data_size
init|=
name|desc_sz
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_next_seg
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|qp
operator|->
name|transport
condition|)
block|{
case|case
name|MLX
case|:
name|max_data_size
operator|-=
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
expr_stmt|;
break|break;
case|case
name|UD
case|:
if|if
condition|(
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
name|max_data_size
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_arbel_ud_seg
argument_list|)
expr_stmt|;
else|else
name|max_data_size
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_tavor_ud_seg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|max_data_size
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_raddr_seg
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|max_data_size
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|mthca_max_inline_data
parameter_list|(
name|struct
name|mthca_pd
modifier|*
name|pd
parameter_list|,
name|int
name|max_data_size
parameter_list|)
block|{
comment|/* We don't support inline data for kernel QPs (yet). */
return|return
name|pd
operator|->
name|ibpd
operator|.
name|uobject
condition|?
name|max_data_size
operator|-
name|MTHCA_INLINE_HEADER_SIZE
else|:
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mthca_adjust_qp_caps
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|mthca_qp
modifier|*
name|qp
parameter_list|)
block|{
name|int
name|max_data_size
init|=
name|mthca_max_data_size
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
name|min
argument_list|(
name|dev
operator|->
name|limits
operator|.
name|max_desc_sz
argument_list|,
literal|1
operator|<<
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
argument_list|)
argument_list|)
decl_stmt|;
name|qp
operator|->
name|max_inline_data
operator|=
name|mthca_max_inline_data
argument_list|(
name|pd
argument_list|,
name|max_data_size
argument_list|)
expr_stmt|;
name|qp
operator|->
name|sq
operator|.
name|max_gs
operator|=
name|min_t
argument_list|(
name|int
argument_list|,
name|dev
operator|->
name|limits
operator|.
name|max_sg
argument_list|,
name|max_data_size
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rq
operator|.
name|max_gs
operator|=
name|min_t
argument_list|(
name|int
argument_list|,
name|dev
operator|->
name|limits
operator|.
name|max_sg
argument_list|,
operator|(
name|min
argument_list|(
name|dev
operator|->
name|limits
operator|.
name|max_desc_sz
argument_list|,
literal|1
operator|<<
name|qp
operator|->
name|rq
operator|.
name|wqe_shift
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_next_seg
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate and register buffer for WQEs.  qp->rq.max, sq.max,  * rq.max_gs and sq.max_gs must all be assigned.  * mthca_alloc_wqe_buf will calculate rq.wqe_shift and  * sq.wqe_shift (as well as send_wqe_offset, is_direct, and  * queue)  */
end_comment

begin_function
specifier|static
name|int
name|mthca_alloc_wqe_buf
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|mthca_qp
modifier|*
name|qp
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|int
name|err
init|=
operator|-
name|ENOMEM
decl_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_next_seg
argument_list|)
operator|+
name|qp
operator|->
name|rq
operator|.
name|max_gs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|dev
operator|->
name|limits
operator|.
name|max_desc_sz
condition|)
return|return
operator|-
name|EINVAL
return|;
for|for
control|(
name|qp
operator|->
name|rq
operator|.
name|wqe_shift
operator|=
literal|6
init|;
literal|1
operator|<<
name|qp
operator|->
name|rq
operator|.
name|wqe_shift
operator|<
name|size
condition|;
name|qp
operator|->
name|rq
operator|.
name|wqe_shift
operator|++
control|)
empty_stmt|;
comment|/* nothing */
name|size
operator|=
name|qp
operator|->
name|sq
operator|.
name|max_gs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|qp
operator|->
name|transport
condition|)
block|{
case|case
name|MLX
case|:
name|size
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
expr_stmt|;
break|break;
case|case
name|UD
case|:
name|size
operator|+=
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_arbel_ud_seg
argument_list|)
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_tavor_ud_seg
argument_list|)
expr_stmt|;
break|break;
case|case
name|UC
case|:
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_raddr_seg
argument_list|)
expr_stmt|;
break|break;
case|case
name|RC
case|:
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_raddr_seg
argument_list|)
expr_stmt|;
comment|/* 		 * An atomic op will require an atomic segment, a 		 * remote address segment and one scatter entry. 		 */
name|size
operator|=
name|max_t
argument_list|(
name|int
argument_list|,
name|size
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_atomic_seg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_raddr_seg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* Make sure that we have enough space for a bind request */
name|size
operator|=
name|max_t
argument_list|(
name|int
argument_list|,
name|size
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_bind_seg
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_next_seg
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|dev
operator|->
name|limits
operator|.
name|max_desc_sz
condition|)
return|return
operator|-
name|EINVAL
return|;
for|for
control|(
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|=
literal|6
init|;
literal|1
operator|<<
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|<
name|size
condition|;
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|++
control|)
empty_stmt|;
comment|/* nothing */
name|qp
operator|->
name|send_wqe_offset
operator|=
name|ALIGN
argument_list|(
name|qp
operator|->
name|rq
operator|.
name|max
operator|<<
name|qp
operator|->
name|rq
operator|.
name|wqe_shift
argument_list|,
literal|1
operator|<<
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a userspace QP, we don't actually have to 	 * allocate anything.  All we need is to calculate the WQE 	 * sizes and the send_wqe_offset, so we're done now. 	 */
if|if
condition|(
name|pd
operator|->
name|ibpd
operator|.
name|uobject
condition|)
return|return
literal|0
return|;
name|size
operator|=
name|PAGE_ALIGN
argument_list|(
name|qp
operator|->
name|send_wqe_offset
operator|+
operator|(
name|qp
operator|->
name|sq
operator|.
name|max
operator|<<
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|)
argument_list|)
expr_stmt|;
name|qp
operator|->
name|wrid
operator|=
name|kmalloc
argument_list|(
operator|(
name|qp
operator|->
name|rq
operator|.
name|max
operator|+
name|qp
operator|->
name|sq
operator|.
name|max
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qp
operator|->
name|wrid
condition|)
goto|goto
name|err_out
goto|;
name|err
operator|=
name|mthca_buf_alloc
argument_list|(
name|dev
argument_list|,
name|size
argument_list|,
name|MTHCA_MAX_DIRECT_QP_SIZE
argument_list|,
operator|&
name|qp
operator|->
name|queue
argument_list|,
operator|&
name|qp
operator|->
name|is_direct
argument_list|,
name|pd
argument_list|,
literal|0
argument_list|,
operator|&
name|qp
operator|->
name|mr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_out
goto|;
return|return
literal|0
return|;
name|err_out
label|:
name|kfree
argument_list|(
name|qp
operator|->
name|wrid
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mthca_free_wqe_buf
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_qp
modifier|*
name|qp
parameter_list|)
block|{
name|mthca_buf_free
argument_list|(
name|dev
argument_list|,
name|PAGE_ALIGN
argument_list|(
name|qp
operator|->
name|send_wqe_offset
operator|+
operator|(
name|qp
operator|->
name|sq
operator|.
name|max
operator|<<
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|)
argument_list|)
argument_list|,
operator|&
name|qp
operator|->
name|queue
argument_list|,
name|qp
operator|->
name|is_direct
argument_list|,
operator|&
name|qp
operator|->
name|mr
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|qp
operator|->
name|wrid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mthca_map_memfree
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_qp
modifier|*
name|qp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|ret
operator|=
name|mthca_table_get
argument_list|(
name|dev
argument_list|,
name|dev
operator|->
name|qp_table
operator|.
name|qp_table
argument_list|,
name|qp
operator|->
name|qpn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|mthca_table_get
argument_list|(
name|dev
argument_list|,
name|dev
operator|->
name|qp_table
operator|.
name|eqp_table
argument_list|,
name|qp
operator|->
name|qpn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err_qpc
goto|;
name|ret
operator|=
name|mthca_table_get
argument_list|(
name|dev
argument_list|,
name|dev
operator|->
name|qp_table
operator|.
name|rdb_table
argument_list|,
name|qp
operator|->
name|qpn
operator|<<
name|dev
operator|->
name|qp_table
operator|.
name|rdb_shift
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
goto|goto
name|err_eqpc
goto|;
block|}
return|return
literal|0
return|;
name|err_eqpc
label|:
name|mthca_table_put
argument_list|(
name|dev
argument_list|,
name|dev
operator|->
name|qp_table
operator|.
name|eqp_table
argument_list|,
name|qp
operator|->
name|qpn
argument_list|)
expr_stmt|;
name|err_qpc
label|:
name|mthca_table_put
argument_list|(
name|dev
argument_list|,
name|dev
operator|->
name|qp_table
operator|.
name|qp_table
argument_list|,
name|qp
operator|->
name|qpn
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mthca_unmap_memfree
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_qp
modifier|*
name|qp
parameter_list|)
block|{
name|mthca_table_put
argument_list|(
name|dev
argument_list|,
name|dev
operator|->
name|qp_table
operator|.
name|rdb_table
argument_list|,
name|qp
operator|->
name|qpn
operator|<<
name|dev
operator|->
name|qp_table
operator|.
name|rdb_shift
argument_list|)
expr_stmt|;
name|mthca_table_put
argument_list|(
name|dev
argument_list|,
name|dev
operator|->
name|qp_table
operator|.
name|eqp_table
argument_list|,
name|qp
operator|->
name|qpn
argument_list|)
expr_stmt|;
name|mthca_table_put
argument_list|(
name|dev
argument_list|,
name|dev
operator|->
name|qp_table
operator|.
name|qp_table
argument_list|,
name|qp
operator|->
name|qpn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mthca_alloc_memfree
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_qp
modifier|*
name|qp
parameter_list|)
block|{
if|if
condition|(
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|qp
operator|->
name|rq
operator|.
name|db_index
operator|=
name|mthca_alloc_db
argument_list|(
name|dev
argument_list|,
name|MTHCA_DB_TYPE_RQ
argument_list|,
name|qp
operator|->
name|qpn
argument_list|,
operator|&
name|qp
operator|->
name|rq
operator|.
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|rq
operator|.
name|db_index
operator|<
literal|0
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|qp
operator|->
name|sq
operator|.
name|db_index
operator|=
name|mthca_alloc_db
argument_list|(
name|dev
argument_list|,
name|MTHCA_DB_TYPE_SQ
argument_list|,
name|qp
operator|->
name|qpn
argument_list|,
operator|&
name|qp
operator|->
name|sq
operator|.
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|sq
operator|.
name|db_index
operator|<
literal|0
condition|)
block|{
name|mthca_free_db
argument_list|(
name|dev
argument_list|,
name|MTHCA_DB_TYPE_RQ
argument_list|,
name|qp
operator|->
name|rq
operator|.
name|db_index
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mthca_free_memfree
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_qp
modifier|*
name|qp
parameter_list|)
block|{
if|if
condition|(
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|mthca_free_db
argument_list|(
name|dev
argument_list|,
name|MTHCA_DB_TYPE_SQ
argument_list|,
name|qp
operator|->
name|sq
operator|.
name|db_index
argument_list|)
expr_stmt|;
name|mthca_free_db
argument_list|(
name|dev
argument_list|,
name|MTHCA_DB_TYPE_RQ
argument_list|,
name|qp
operator|->
name|rq
operator|.
name|db_index
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mthca_alloc_qp_common
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|mthca_cq
modifier|*
name|send_cq
parameter_list|,
name|struct
name|mthca_cq
modifier|*
name|recv_cq
parameter_list|,
name|enum
name|ib_sig_type
name|send_policy
parameter_list|,
name|struct
name|mthca_qp
modifier|*
name|qp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|mthca_next_seg
modifier|*
name|next
decl_stmt|;
name|qp
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|init_waitqueue_head
argument_list|(
operator|&
name|qp
operator|->
name|wait
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|qp
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|qp
operator|->
name|state
operator|=
name|IB_QPS_RESET
expr_stmt|;
name|qp
operator|->
name|atomic_rd_en
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|resp_depth
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|sq_policy
operator|=
name|send_policy
expr_stmt|;
name|mthca_wq_reset
argument_list|(
operator|&
name|qp
operator|->
name|sq
argument_list|)
expr_stmt|;
name|mthca_wq_reset
argument_list|(
operator|&
name|qp
operator|->
name|rq
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|qp
operator|->
name|sq
operator|.
name|lock
argument_list|)
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|qp
operator|->
name|rq
operator|.
name|lock
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mthca_map_memfree
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|mthca_alloc_wqe_buf
argument_list|(
name|dev
argument_list|,
name|pd
argument_list|,
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|mthca_unmap_memfree
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|mthca_adjust_qp_caps
argument_list|(
name|dev
argument_list|,
name|pd
argument_list|,
name|qp
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a userspace QP, we're done now.  The doorbells 	 * will be allocated and buffers will be initialized in 	 * userspace. 	 */
if|if
condition|(
name|pd
operator|->
name|ibpd
operator|.
name|uobject
condition|)
return|return
literal|0
return|;
name|ret
operator|=
name|mthca_alloc_memfree
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|mthca_free_wqe_buf
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|mthca_unmap_memfree
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
if|if
condition|(
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|struct
name|mthca_data_seg
modifier|*
name|scatter
decl_stmt|;
name|int
name|size
init|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_next_seg
argument_list|)
operator|+
name|qp
operator|->
name|rq
operator|.
name|max_gs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
operator|)
operator|/
literal|16
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp
operator|->
name|rq
operator|.
name|max
condition|;
operator|++
name|i
control|)
block|{
name|next
operator|=
name|get_recv_wqe
argument_list|(
name|qp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|next
operator|->
name|nda_op
operator|=
name|cpu_to_be32
argument_list|(
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
operator|(
name|qp
operator|->
name|rq
operator|.
name|max
operator|-
literal|1
operator|)
operator|)
operator|<<
name|qp
operator|->
name|rq
operator|.
name|wqe_shift
argument_list|)
expr_stmt|;
name|next
operator|->
name|ee_nds
operator|=
name|cpu_to_be32
argument_list|(
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|scatter
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|next
operator|+
literal|1
operator|)
init|;
operator|(
name|void
operator|*
operator|)
name|scatter
operator|<
operator|(
name|void
operator|*
operator|)
name|next
operator|+
operator|(
literal|1
operator|<<
name|qp
operator|->
name|rq
operator|.
name|wqe_shift
operator|)
condition|;
operator|++
name|scatter
control|)
name|scatter
operator|->
name|lkey
operator|=
name|cpu_to_be32
argument_list|(
name|MTHCA_INVAL_LKEY
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp
operator|->
name|sq
operator|.
name|max
condition|;
operator|++
name|i
control|)
block|{
name|next
operator|=
name|get_send_wqe
argument_list|(
name|qp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|next
operator|->
name|nda_op
operator|=
name|cpu_to_be32
argument_list|(
operator|(
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
operator|(
name|qp
operator|->
name|sq
operator|.
name|max
operator|-
literal|1
operator|)
operator|)
operator|<<
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|)
operator|+
name|qp
operator|->
name|send_wqe_offset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp
operator|->
name|rq
operator|.
name|max
condition|;
operator|++
name|i
control|)
block|{
name|next
operator|=
name|get_recv_wqe
argument_list|(
name|qp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|next
operator|->
name|nda_op
operator|=
name|htonl
argument_list|(
operator|(
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
name|qp
operator|->
name|rq
operator|.
name|max
operator|)
operator|<<
name|qp
operator|->
name|rq
operator|.
name|wqe_shift
operator|)
operator||
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|qp
operator|->
name|sq
operator|.
name|last
operator|=
name|get_send_wqe
argument_list|(
name|qp
argument_list|,
name|qp
operator|->
name|sq
operator|.
name|max
operator|-
literal|1
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rq
operator|.
name|last
operator|=
name|get_recv_wqe
argument_list|(
name|qp
argument_list|,
name|qp
operator|->
name|rq
operator|.
name|max
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mthca_set_qp_size
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|ib_qp_cap
modifier|*
name|cap
parameter_list|,
name|struct
name|mthca_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|mthca_qp
modifier|*
name|qp
parameter_list|)
block|{
name|int
name|max_data_size
init|=
name|mthca_max_data_size
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|,
name|dev
operator|->
name|limits
operator|.
name|max_desc_sz
argument_list|)
decl_stmt|;
name|u32
name|max_inline_data
decl_stmt|;
comment|/* Sanity check QP size before proceeding */
if|if
condition|(
name|cap
operator|->
name|max_send_wr
operator|>
name|dev
operator|->
name|limits
operator|.
name|max_wqes
operator|||
name|cap
operator|->
name|max_recv_wr
operator|>
name|dev
operator|->
name|limits
operator|.
name|max_wqes
operator|||
name|cap
operator|->
name|max_send_sge
operator|>
name|dev
operator|->
name|limits
operator|.
name|max_sg
operator|||
name|cap
operator|->
name|max_recv_sge
operator|>
name|dev
operator|->
name|limits
operator|.
name|max_sg
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|pd
operator|->
name|ibpd
operator|.
name|uobject
operator|&&
name|cap
operator|->
name|max_inline_data
operator|>
name|mthca_max_inline_data
argument_list|(
name|pd
argument_list|,
name|max_data_size
argument_list|)
condition|)
return|return
operator|-
name|EINVAL
return|;
name|max_inline_data
operator|=
name|pd
operator|->
name|ibpd
operator|.
name|uobject
condition|?
name|cap
operator|->
name|max_inline_data
else|:
literal|0
expr_stmt|;
comment|/* 	 * For MLX transport we need 2 extra send gather entries: 	 * one for the header and one for the checksum at the end 	 */
if|if
condition|(
name|qp
operator|->
name|transport
operator|==
name|MLX
operator|&&
name|cap
operator|->
name|max_send_sge
operator|+
literal|2
operator|>
name|dev
operator|->
name|limits
operator|.
name|max_sg
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|qp
operator|->
name|rq
operator|.
name|max
operator|=
name|cap
operator|->
name|max_recv_wr
condition|?
name|roundup_pow_of_two
argument_list|(
name|cap
operator|->
name|max_recv_wr
argument_list|)
else|:
literal|0
expr_stmt|;
name|qp
operator|->
name|sq
operator|.
name|max
operator|=
name|cap
operator|->
name|max_send_wr
condition|?
name|roundup_pow_of_two
argument_list|(
name|cap
operator|->
name|max_send_wr
argument_list|)
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
name|qp
operator|->
name|rq
operator|.
name|max
operator|=
name|cap
operator|->
name|max_recv_wr
expr_stmt|;
name|qp
operator|->
name|sq
operator|.
name|max
operator|=
name|cap
operator|->
name|max_send_wr
expr_stmt|;
block|}
name|qp
operator|->
name|rq
operator|.
name|max_gs
operator|=
name|cap
operator|->
name|max_recv_sge
expr_stmt|;
name|qp
operator|->
name|sq
operator|.
name|max_gs
operator|=
name|max_t
argument_list|(
name|int
argument_list|,
name|cap
operator|->
name|max_send_sge
argument_list|,
name|ALIGN
argument_list|(
name|max_inline_data
operator|+
name|MTHCA_INLINE_HEADER_SIZE
argument_list|,
name|MTHCA_INLINE_CHUNK_SIZE
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mthca_alloc_qp
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|mthca_cq
modifier|*
name|send_cq
parameter_list|,
name|struct
name|mthca_cq
modifier|*
name|recv_cq
parameter_list|,
name|enum
name|ib_qp_type
name|type
parameter_list|,
name|enum
name|ib_sig_type
name|send_policy
parameter_list|,
name|struct
name|ib_qp_cap
modifier|*
name|cap
parameter_list|,
name|struct
name|mthca_qp
modifier|*
name|qp
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|IB_QPT_RC
case|:
name|qp
operator|->
name|transport
operator|=
name|RC
expr_stmt|;
break|break;
case|case
name|IB_QPT_UC
case|:
name|qp
operator|->
name|transport
operator|=
name|UC
expr_stmt|;
break|break;
case|case
name|IB_QPT_UD
case|:
name|qp
operator|->
name|transport
operator|=
name|UD
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
name|err
operator|=
name|mthca_set_qp_size
argument_list|(
name|dev
argument_list|,
name|cap
argument_list|,
name|pd
argument_list|,
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|qp
operator|->
name|qpn
operator|=
name|mthca_alloc
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|qpn
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
name|ENOMEM
return|;
comment|/* initialize port to zero for error-catching. */
name|qp
operator|->
name|port
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|mthca_alloc_qp_common
argument_list|(
name|dev
argument_list|,
name|pd
argument_list|,
name|send_cq
argument_list|,
name|recv_cq
argument_list|,
name|send_policy
argument_list|,
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_free
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|alloc
argument_list|,
name|qp
operator|->
name|qpn
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|spin_lock_irq
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|lock
argument_list|)
expr_stmt|;
name|mthca_array_set
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|qp
argument_list|,
name|qp
operator|->
name|qpn
operator|&
operator|(
name|dev
operator|->
name|limits
operator|.
name|num_qps
operator|-
literal|1
operator|)
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|spin_unlock_irq
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mthca_lock_cqs
parameter_list|(
name|struct
name|mthca_cq
modifier|*
name|send_cq
parameter_list|,
name|struct
name|mthca_cq
modifier|*
name|recv_cq
parameter_list|)
block|{
if|if
condition|(
name|send_cq
operator|==
name|recv_cq
condition|)
name|spin_lock_irq
argument_list|(
operator|&
name|send_cq
operator|->
name|lock
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|send_cq
operator|->
name|cqn
operator|<
name|recv_cq
operator|->
name|cqn
condition|)
block|{
name|spin_lock_irq
argument_list|(
operator|&
name|send_cq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|spin_lock_nested
argument_list|(
operator|&
name|recv_cq
operator|->
name|lock
argument_list|,
name|SINGLE_DEPTH_NESTING
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|spin_lock_irq
argument_list|(
operator|&
name|recv_cq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|spin_lock_nested
argument_list|(
operator|&
name|send_cq
operator|->
name|lock
argument_list|,
name|SINGLE_DEPTH_NESTING
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mthca_unlock_cqs
parameter_list|(
name|struct
name|mthca_cq
modifier|*
name|send_cq
parameter_list|,
name|struct
name|mthca_cq
modifier|*
name|recv_cq
parameter_list|)
block|{
if|if
condition|(
name|send_cq
operator|==
name|recv_cq
condition|)
name|spin_unlock_irq
argument_list|(
operator|&
name|send_cq
operator|->
name|lock
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|send_cq
operator|->
name|cqn
operator|<
name|recv_cq
operator|->
name|cqn
condition|)
block|{
name|spin_unlock
argument_list|(
operator|&
name|recv_cq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|spin_unlock_irq
argument_list|(
operator|&
name|send_cq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|spin_unlock
argument_list|(
operator|&
name|send_cq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|spin_unlock_irq
argument_list|(
operator|&
name|recv_cq
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|mthca_alloc_sqp
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_pd
modifier|*
name|pd
parameter_list|,
name|struct
name|mthca_cq
modifier|*
name|send_cq
parameter_list|,
name|struct
name|mthca_cq
modifier|*
name|recv_cq
parameter_list|,
name|enum
name|ib_sig_type
name|send_policy
parameter_list|,
name|struct
name|ib_qp_cap
modifier|*
name|cap
parameter_list|,
name|int
name|qpn
parameter_list|,
name|int
name|port
parameter_list|,
name|struct
name|mthca_sqp
modifier|*
name|sqp
parameter_list|)
block|{
name|u32
name|mqpn
init|=
name|qpn
operator|*
literal|2
operator|+
name|dev
operator|->
name|qp_table
operator|.
name|sqp_start
operator|+
name|port
operator|-
literal|1
decl_stmt|;
name|int
name|err
decl_stmt|;
name|sqp
operator|->
name|qp
operator|.
name|transport
operator|=
name|MLX
expr_stmt|;
name|err
operator|=
name|mthca_set_qp_size
argument_list|(
name|dev
argument_list|,
name|cap
argument_list|,
name|pd
argument_list|,
operator|&
name|sqp
operator|->
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|sqp
operator|->
name|header_buf_size
operator|=
name|sqp
operator|->
name|qp
operator|.
name|sq
operator|.
name|max
operator|*
name|MTHCA_UD_HEADER_SIZE
expr_stmt|;
name|sqp
operator|->
name|header_buf
operator|=
name|dma_alloc_coherent
argument_list|(
operator|&
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|sqp
operator|->
name|header_buf_size
argument_list|,
operator|&
name|sqp
operator|->
name|header_dma
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sqp
operator|->
name|header_buf
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|spin_lock_irq
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mthca_array_get
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|qp
argument_list|,
name|mqpn
argument_list|)
condition|)
name|err
operator|=
operator|-
name|EBUSY
expr_stmt|;
else|else
name|mthca_array_set
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|qp
argument_list|,
name|mqpn
argument_list|,
name|sqp
argument_list|)
expr_stmt|;
name|spin_unlock_irq
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_out
goto|;
name|sqp
operator|->
name|qp
operator|.
name|port
operator|=
name|port
expr_stmt|;
name|sqp
operator|->
name|qp
operator|.
name|qpn
operator|=
name|mqpn
expr_stmt|;
name|sqp
operator|->
name|qp
operator|.
name|transport
operator|=
name|MLX
expr_stmt|;
name|err
operator|=
name|mthca_alloc_qp_common
argument_list|(
name|dev
argument_list|,
name|pd
argument_list|,
name|send_cq
argument_list|,
name|recv_cq
argument_list|,
name|send_policy
argument_list|,
operator|&
name|sqp
operator|->
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_out_free
goto|;
name|atomic_inc
argument_list|(
operator|&
name|pd
operator|->
name|sqp_count
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_out_free
label|:
comment|/* 	 * Lock CQs here, so that CQ polling code can do QP lookup 	 * without taking a lock. 	 */
name|mthca_lock_cqs
argument_list|(
name|send_cq
argument_list|,
name|recv_cq
argument_list|)
expr_stmt|;
name|spin_lock
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|lock
argument_list|)
expr_stmt|;
name|mthca_array_clear
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|qp
argument_list|,
name|mqpn
argument_list|)
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|lock
argument_list|)
expr_stmt|;
name|mthca_unlock_cqs
argument_list|(
name|send_cq
argument_list|,
name|recv_cq
argument_list|)
expr_stmt|;
name|err_out
label|:
name|dma_free_coherent
argument_list|(
operator|&
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|sqp
operator|->
name|header_buf_size
argument_list|,
name|sqp
operator|->
name|header_buf
argument_list|,
name|sqp
operator|->
name|header_dma
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|get_qp_refcount
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_qp
modifier|*
name|qp
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|spin_lock_irq
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|lock
argument_list|)
expr_stmt|;
name|c
operator|=
name|qp
operator|->
name|refcount
expr_stmt|;
name|spin_unlock_irq
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|lock
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_function
name|void
name|mthca_free_qp
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_qp
modifier|*
name|qp
parameter_list|)
block|{
name|u8
name|status
decl_stmt|;
name|struct
name|mthca_cq
modifier|*
name|send_cq
decl_stmt|;
name|struct
name|mthca_cq
modifier|*
name|recv_cq
decl_stmt|;
name|send_cq
operator|=
name|to_mcq
argument_list|(
name|qp
operator|->
name|ibqp
operator|.
name|send_cq
argument_list|)
expr_stmt|;
name|recv_cq
operator|=
name|to_mcq
argument_list|(
name|qp
operator|->
name|ibqp
operator|.
name|recv_cq
argument_list|)
expr_stmt|;
comment|/* 	 * Lock CQs here, so that CQ polling code can do QP lookup 	 * without taking a lock. 	 */
name|mthca_lock_cqs
argument_list|(
name|send_cq
argument_list|,
name|recv_cq
argument_list|)
expr_stmt|;
name|spin_lock
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|lock
argument_list|)
expr_stmt|;
name|mthca_array_clear
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|qp
argument_list|,
name|qp
operator|->
name|qpn
operator|&
operator|(
name|dev
operator|->
name|limits
operator|.
name|num_qps
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
operator|--
name|qp
operator|->
name|refcount
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|lock
argument_list|)
expr_stmt|;
name|mthca_unlock_cqs
argument_list|(
name|send_cq
argument_list|,
name|recv_cq
argument_list|)
expr_stmt|;
name|wait_event
argument_list|(
name|qp
operator|->
name|wait
argument_list|,
operator|!
name|get_qp_refcount
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|state
operator|!=
name|IB_QPS_RESET
condition|)
name|mthca_MODIFY_QP
argument_list|(
name|dev
argument_list|,
name|qp
operator|->
name|state
argument_list|,
name|IB_QPS_RESET
argument_list|,
name|qp
operator|->
name|qpn
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a userspace QP, the buffers, MR, CQs and so on 	 * will be cleaned up in userspace, so all we have to do is 	 * unref the mem-free tables and free the QPN in our table. 	 */
if|if
condition|(
operator|!
name|qp
operator|->
name|ibqp
operator|.
name|uobject
condition|)
block|{
name|mthca_cq_clean
argument_list|(
name|dev
argument_list|,
name|recv_cq
argument_list|,
name|qp
operator|->
name|qpn
argument_list|,
name|qp
operator|->
name|ibqp
operator|.
name|srq
condition|?
name|to_msrq
argument_list|(
name|qp
operator|->
name|ibqp
operator|.
name|srq
argument_list|)
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_cq
operator|!=
name|recv_cq
condition|)
name|mthca_cq_clean
argument_list|(
name|dev
argument_list|,
name|send_cq
argument_list|,
name|qp
operator|->
name|qpn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mthca_free_memfree
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|mthca_free_wqe_buf
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|)
expr_stmt|;
block|}
name|mthca_unmap_memfree
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_sqp
argument_list|(
name|dev
argument_list|,
name|qp
argument_list|)
condition|)
block|{
name|atomic_dec
argument_list|(
operator|&
operator|(
name|to_mpd
argument_list|(
name|qp
operator|->
name|ibqp
operator|.
name|pd
argument_list|)
operator|->
name|sqp_count
operator|)
argument_list|)
expr_stmt|;
name|dma_free_coherent
argument_list|(
operator|&
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|to_msqp
argument_list|(
name|qp
argument_list|)
operator|->
name|header_buf_size
argument_list|,
name|to_msqp
argument_list|(
name|qp
argument_list|)
operator|->
name|header_buf
argument_list|,
name|to_msqp
argument_list|(
name|qp
argument_list|)
operator|->
name|header_dma
argument_list|)
expr_stmt|;
block|}
else|else
name|mthca_free
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|alloc
argument_list|,
name|qp
operator|->
name|qpn
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create UD header for an MLX send and build a data segment for it */
end_comment

begin_function
specifier|static
name|int
name|build_mlx_header
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_sqp
modifier|*
name|sqp
parameter_list|,
name|int
name|ind
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|,
name|struct
name|mthca_mlx_seg
modifier|*
name|mlx
parameter_list|,
name|struct
name|mthca_data_seg
modifier|*
name|data
parameter_list|)
block|{
name|int
name|header_size
decl_stmt|;
name|int
name|err
decl_stmt|;
name|u16
name|pkey
decl_stmt|;
name|ib_ud_header_init
argument_list|(
literal|256
argument_list|,
comment|/* assume a MAD */
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mthca_ah_grh_present
argument_list|(
name|to_mah
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|ah
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|sqp
operator|->
name|ud_header
argument_list|)
expr_stmt|;
name|err
operator|=
name|mthca_read_ah
argument_list|(
name|dev
argument_list|,
name|to_mah
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|ah
argument_list|)
argument_list|,
operator|&
name|sqp
operator|->
name|ud_header
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|mlx
operator|->
name|flags
operator|&=
operator|~
name|cpu_to_be32
argument_list|(
name|MTHCA_NEXT_SOLICIT
operator||
literal|1
argument_list|)
expr_stmt|;
name|mlx
operator|->
name|flags
operator||=
name|cpu_to_be32
argument_list|(
operator|(
operator|!
name|sqp
operator|->
name|qp
operator|.
name|ibqp
operator|.
name|qp_num
condition|?
name|MTHCA_MLX_VL15
else|:
literal|0
operator|)
operator||
operator|(
name|sqp
operator|->
name|ud_header
operator|.
name|lrh
operator|.
name|destination_lid
operator|==
name|IB_LID_PERMISSIVE
condition|?
name|MTHCA_MLX_SLR
else|:
literal|0
operator|)
operator||
operator|(
name|sqp
operator|->
name|ud_header
operator|.
name|lrh
operator|.
name|service_level
operator|<<
literal|8
operator|)
argument_list|)
expr_stmt|;
name|mlx
operator|->
name|rlid
operator|=
name|sqp
operator|->
name|ud_header
operator|.
name|lrh
operator|.
name|destination_lid
expr_stmt|;
name|mlx
operator|->
name|vcrc
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|wr
operator|->
name|opcode
condition|)
block|{
case|case
name|IB_WR_SEND
case|:
name|sqp
operator|->
name|ud_header
operator|.
name|bth
operator|.
name|opcode
operator|=
name|IB_OPCODE_UD_SEND_ONLY
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|immediate_present
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|IB_WR_SEND_WITH_IMM
case|:
name|sqp
operator|->
name|ud_header
operator|.
name|bth
operator|.
name|opcode
operator|=
name|IB_OPCODE_UD_SEND_ONLY_WITH_IMMEDIATE
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|immediate_present
operator|=
literal|1
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|immediate_data
operator|=
name|wr
operator|->
name|ex
operator|.
name|imm_data
expr_stmt|;
break|break;
default|default:
return|return
operator|-
name|EINVAL
return|;
block|}
name|sqp
operator|->
name|ud_header
operator|.
name|lrh
operator|.
name|virtual_lane
operator|=
operator|!
name|sqp
operator|->
name|qp
operator|.
name|ibqp
operator|.
name|qp_num
condition|?
literal|15
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|sqp
operator|->
name|ud_header
operator|.
name|lrh
operator|.
name|destination_lid
operator|==
name|IB_LID_PERMISSIVE
condition|)
name|sqp
operator|->
name|ud_header
operator|.
name|lrh
operator|.
name|source_lid
operator|=
name|IB_LID_PERMISSIVE
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|bth
operator|.
name|solicited_event
operator|=
operator|!
operator|!
operator|(
name|wr
operator|->
name|send_flags
operator|&
name|IB_SEND_SOLICITED
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|sqp
operator|->
name|qp
operator|.
name|ibqp
operator|.
name|qp_num
condition|)
name|ib_get_cached_pkey
argument_list|(
operator|&
name|dev
operator|->
name|ib_dev
argument_list|,
name|sqp
operator|->
name|qp
operator|.
name|port
argument_list|,
name|sqp
operator|->
name|pkey_index
argument_list|,
operator|&
name|pkey
argument_list|)
expr_stmt|;
else|else
name|ib_get_cached_pkey
argument_list|(
operator|&
name|dev
operator|->
name|ib_dev
argument_list|,
name|sqp
operator|->
name|qp
operator|.
name|port
argument_list|,
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|pkey_index
argument_list|,
operator|&
name|pkey
argument_list|)
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|bth
operator|.
name|pkey
operator|=
name|cpu_to_be16
argument_list|(
name|pkey
argument_list|)
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|bth
operator|.
name|destination_qpn
operator|=
name|cpu_to_be32
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|remote_qpn
argument_list|)
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|bth
operator|.
name|psn
operator|=
name|cpu_to_be32
argument_list|(
operator|(
name|sqp
operator|->
name|send_psn
operator|++
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
literal|24
operator|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|deth
operator|.
name|qkey
operator|=
name|cpu_to_be32
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|remote_qkey
operator|&
literal|0x80000000
condition|?
name|sqp
operator|->
name|qkey
else|:
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|remote_qkey
argument_list|)
expr_stmt|;
name|sqp
operator|->
name|ud_header
operator|.
name|deth
operator|.
name|source_qpn
operator|=
name|cpu_to_be32
argument_list|(
name|sqp
operator|->
name|qp
operator|.
name|ibqp
operator|.
name|qp_num
argument_list|)
expr_stmt|;
name|header_size
operator|=
name|ib_ud_header_pack
argument_list|(
operator|&
name|sqp
operator|->
name|ud_header
argument_list|,
name|sqp
operator|->
name|header_buf
operator|+
name|ind
operator|*
name|MTHCA_UD_HEADER_SIZE
argument_list|)
expr_stmt|;
name|data
operator|->
name|byte_count
operator|=
name|cpu_to_be32
argument_list|(
name|header_size
argument_list|)
expr_stmt|;
name|data
operator|->
name|lkey
operator|=
name|cpu_to_be32
argument_list|(
name|to_mpd
argument_list|(
name|sqp
operator|->
name|qp
operator|.
name|ibqp
operator|.
name|pd
argument_list|)
operator|->
name|ntmr
operator|.
name|ibmr
operator|.
name|lkey
argument_list|)
expr_stmt|;
name|data
operator|->
name|addr
operator|=
name|cpu_to_be64
argument_list|(
name|sqp
operator|->
name|header_dma
operator|+
name|ind
operator|*
name|MTHCA_UD_HEADER_SIZE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|mthca_wq_overflow
parameter_list|(
name|struct
name|mthca_wq
modifier|*
name|wq
parameter_list|,
name|int
name|nreq
parameter_list|,
name|struct
name|ib_cq
modifier|*
name|ib_cq
parameter_list|)
block|{
name|unsigned
name|cur
decl_stmt|;
name|struct
name|mthca_cq
modifier|*
name|cq
decl_stmt|;
name|cur
operator|=
name|wq
operator|->
name|head
operator|-
name|wq
operator|->
name|tail
expr_stmt|;
if|if
condition|(
name|likely
argument_list|(
name|cur
operator|+
name|nreq
operator|<
name|wq
operator|->
name|max
argument_list|)
condition|)
return|return
literal|0
return|;
name|cq
operator|=
name|to_mcq
argument_list|(
name|ib_cq
argument_list|)
expr_stmt|;
name|spin_lock
argument_list|(
operator|&
name|cq
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cur
operator|=
name|wq
operator|->
name|head
operator|-
name|wq
operator|->
name|tail
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|cq
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|cur
operator|+
name|nreq
operator|>=
name|wq
operator|->
name|max
return|;
block|}
end_function

begin_function
specifier|static
name|__always_inline
name|void
name|set_raddr_seg
parameter_list|(
name|struct
name|mthca_raddr_seg
modifier|*
name|rseg
parameter_list|,
name|u64
name|remote_addr
parameter_list|,
name|u32
name|rkey
parameter_list|)
block|{
name|rseg
operator|->
name|raddr
operator|=
name|cpu_to_be64
argument_list|(
name|remote_addr
argument_list|)
expr_stmt|;
name|rseg
operator|->
name|rkey
operator|=
name|cpu_to_be32
argument_list|(
name|rkey
argument_list|)
expr_stmt|;
name|rseg
operator|->
name|reserved
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__always_inline
name|void
name|set_atomic_seg
parameter_list|(
name|struct
name|mthca_atomic_seg
modifier|*
name|aseg
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|)
block|{
if|if
condition|(
name|wr
operator|->
name|opcode
operator|==
name|IB_WR_ATOMIC_CMP_AND_SWP
condition|)
block|{
name|aseg
operator|->
name|swap_add
operator|=
name|cpu_to_be64
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|atomic
operator|.
name|swap
argument_list|)
expr_stmt|;
name|aseg
operator|->
name|compare
operator|=
name|cpu_to_be64
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|atomic
operator|.
name|compare_add
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aseg
operator|->
name|swap_add
operator|=
name|cpu_to_be64
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|atomic
operator|.
name|compare_add
argument_list|)
expr_stmt|;
name|aseg
operator|->
name|compare
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_tavor_ud_seg
parameter_list|(
name|struct
name|mthca_tavor_ud_seg
modifier|*
name|useg
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|)
block|{
name|useg
operator|->
name|lkey
operator|=
name|cpu_to_be32
argument_list|(
name|to_mah
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|ah
argument_list|)
operator|->
name|key
argument_list|)
expr_stmt|;
name|useg
operator|->
name|av_addr
operator|=
name|cpu_to_be64
argument_list|(
name|to_mah
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|ah
argument_list|)
operator|->
name|avdma
argument_list|)
expr_stmt|;
name|useg
operator|->
name|dqpn
operator|=
name|cpu_to_be32
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|remote_qpn
argument_list|)
expr_stmt|;
name|useg
operator|->
name|qkey
operator|=
name|cpu_to_be32
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|remote_qkey
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_arbel_ud_seg
parameter_list|(
name|struct
name|mthca_arbel_ud_seg
modifier|*
name|useg
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|)
block|{
name|memcpy
argument_list|(
name|useg
operator|->
name|av
argument_list|,
name|to_mah
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|ah
argument_list|)
operator|->
name|av
argument_list|,
name|MTHCA_AV_SIZE
argument_list|)
expr_stmt|;
name|useg
operator|->
name|dqpn
operator|=
name|cpu_to_be32
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|remote_qpn
argument_list|)
expr_stmt|;
name|useg
operator|->
name|qkey
operator|=
name|cpu_to_be32
argument_list|(
name|wr
operator|->
name|wr
operator|.
name|ud
operator|.
name|remote_qkey
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mthca_tavor_post_send
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|ibqp
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
modifier|*
name|bad_wr
parameter_list|)
block|{
name|struct
name|mthca_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ibqp
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mthca_qp
modifier|*
name|qp
init|=
name|to_mqp
argument_list|(
name|ibqp
argument_list|)
decl_stmt|;
name|void
modifier|*
name|wqe
decl_stmt|;
name|void
modifier|*
name|prev_wqe
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|nreq
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* 	 * f0 and size0 are only used if nreq != 0, and they will 	 * always be initialized the first time through the main loop 	 * before nreq is incremented.  So nreq cannot become non-zero 	 * without initializing f0 and size0, and they are in fact 	 * never used uninitialized. 	 */
name|int
name|uninitialized_var
argument_list|(
name|size0
argument_list|)
decl_stmt|;
name|u32
name|uninitialized_var
argument_list|(
name|f0
argument_list|)
decl_stmt|;
name|int
name|ind
decl_stmt|;
name|u8
name|op0
init|=
literal|0
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|qp
operator|->
name|sq
operator|.
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* XXX check that state is OK to post send */
name|ind
operator|=
name|qp
operator|->
name|sq
operator|.
name|next_ind
expr_stmt|;
for|for
control|(
name|nreq
operator|=
literal|0
init|;
name|wr
condition|;
operator|++
name|nreq
operator|,
name|wr
operator|=
name|wr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|mthca_wq_overflow
argument_list|(
operator|&
name|qp
operator|->
name|sq
argument_list|,
name|nreq
argument_list|,
name|qp
operator|->
name|ibqp
operator|.
name|send_cq
argument_list|)
condition|)
block|{
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"SQ %06x full (%u head, %u tail,"
literal|" %d max, %d nreq)\n"
argument_list|,
name|qp
operator|->
name|qpn
argument_list|,
name|qp
operator|->
name|sq
operator|.
name|head
argument_list|,
name|qp
operator|->
name|sq
operator|.
name|tail
argument_list|,
name|qp
operator|->
name|sq
operator|.
name|max
argument_list|,
name|nreq
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
operator|*
name|bad_wr
operator|=
name|wr
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|wqe
operator|=
name|get_send_wqe
argument_list|(
name|qp
argument_list|,
name|ind
argument_list|)
expr_stmt|;
name|prev_wqe
operator|=
name|qp
operator|->
name|sq
operator|.
name|last
expr_stmt|;
name|qp
operator|->
name|sq
operator|.
name|last
operator|=
name|wqe
expr_stmt|;
operator|(
operator|(
expr|struct
name|mthca_next_seg
operator|*
operator|)
name|wqe
operator|)
operator|->
name|nda_op
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
expr|struct
name|mthca_next_seg
operator|*
operator|)
name|wqe
operator|)
operator|->
name|ee_nds
operator|=
literal|0
expr_stmt|;
operator|(
operator|(
expr|struct
name|mthca_next_seg
operator|*
operator|)
name|wqe
operator|)
operator|->
name|flags
operator|=
operator|(
operator|(
name|wr
operator|->
name|send_flags
operator|&
name|IB_SEND_SIGNALED
operator|)
condition|?
name|cpu_to_be32
argument_list|(
name|MTHCA_NEXT_CQ_UPDATE
argument_list|)
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|wr
operator|->
name|send_flags
operator|&
name|IB_SEND_SOLICITED
operator|)
condition|?
name|cpu_to_be32
argument_list|(
name|MTHCA_NEXT_SOLICIT
argument_list|)
else|:
literal|0
operator|)
operator||
name|cpu_to_be32
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|->
name|opcode
operator|==
name|IB_WR_SEND_WITH_IMM
operator|||
name|wr
operator|->
name|opcode
operator|==
name|IB_WR_RDMA_WRITE_WITH_IMM
condition|)
operator|(
operator|(
expr|struct
name|mthca_next_seg
operator|*
operator|)
name|wqe
operator|)
operator|->
name|imm
operator|=
name|wr
operator|->
name|ex
operator|.
name|imm_data
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_next_seg
argument_list|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_next_seg
argument_list|)
operator|/
literal|16
expr_stmt|;
switch|switch
condition|(
name|qp
operator|->
name|transport
condition|)
block|{
case|case
name|RC
case|:
switch|switch
condition|(
name|wr
operator|->
name|opcode
condition|)
block|{
case|case
name|IB_WR_ATOMIC_CMP_AND_SWP
case|:
case|case
name|IB_WR_ATOMIC_FETCH_AND_ADD
case|:
name|set_raddr_seg
argument_list|(
name|wqe
argument_list|,
name|wr
operator|->
name|wr
operator|.
name|atomic
operator|.
name|remote_addr
argument_list|,
name|wr
operator|->
name|wr
operator|.
name|atomic
operator|.
name|rkey
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_raddr_seg
argument_list|)
expr_stmt|;
name|set_atomic_seg
argument_list|(
name|wqe
argument_list|,
name|wr
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_atomic_seg
argument_list|)
expr_stmt|;
name|size
operator|+=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_raddr_seg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_atomic_seg
argument_list|)
operator|)
operator|/
literal|16
expr_stmt|;
break|break;
case|case
name|IB_WR_RDMA_WRITE
case|:
case|case
name|IB_WR_RDMA_WRITE_WITH_IMM
case|:
case|case
name|IB_WR_RDMA_READ
case|:
name|set_raddr_seg
argument_list|(
name|wqe
argument_list|,
name|wr
operator|->
name|wr
operator|.
name|rdma
operator|.
name|remote_addr
argument_list|,
name|wr
operator|->
name|wr
operator|.
name|rdma
operator|.
name|rkey
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_raddr_seg
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_raddr_seg
argument_list|)
operator|/
literal|16
expr_stmt|;
break|break;
default|default:
comment|/* No extra segments required for sends */
break|break;
block|}
break|break;
case|case
name|UC
case|:
switch|switch
condition|(
name|wr
operator|->
name|opcode
condition|)
block|{
case|case
name|IB_WR_RDMA_WRITE
case|:
case|case
name|IB_WR_RDMA_WRITE_WITH_IMM
case|:
name|set_raddr_seg
argument_list|(
name|wqe
argument_list|,
name|wr
operator|->
name|wr
operator|.
name|rdma
operator|.
name|remote_addr
argument_list|,
name|wr
operator|->
name|wr
operator|.
name|rdma
operator|.
name|rkey
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_raddr_seg
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_raddr_seg
argument_list|)
operator|/
literal|16
expr_stmt|;
break|break;
default|default:
comment|/* No extra segments required for sends */
break|break;
block|}
break|break;
case|case
name|UD
case|:
name|set_tavor_ud_seg
argument_list|(
name|wqe
argument_list|,
name|wr
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_tavor_ud_seg
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_tavor_ud_seg
argument_list|)
operator|/
literal|16
expr_stmt|;
break|break;
case|case
name|MLX
case|:
name|err
operator|=
name|build_mlx_header
argument_list|(
name|dev
argument_list|,
name|to_msqp
argument_list|(
name|qp
argument_list|)
argument_list|,
name|ind
argument_list|,
name|wr
argument_list|,
name|wqe
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_next_seg
argument_list|)
argument_list|,
name|wqe
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
operator|*
name|bad_wr
operator|=
name|wr
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
operator|/
literal|16
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|wr
operator|->
name|num_sge
operator|>
name|qp
operator|->
name|sq
operator|.
name|max_gs
condition|)
block|{
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"too many gathers\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
operator|*
name|bad_wr
operator|=
name|wr
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wr
operator|->
name|num_sge
condition|;
operator|++
name|i
control|)
block|{
name|mthca_set_data_seg
argument_list|(
name|wqe
argument_list|,
name|wr
operator|->
name|sg_list
operator|+
name|i
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
operator|/
literal|16
expr_stmt|;
block|}
comment|/* Add one more inline data segment for ICRC */
if|if
condition|(
name|qp
operator|->
name|transport
operator|==
name|MLX
condition|)
block|{
operator|(
operator|(
expr|struct
name|mthca_data_seg
operator|*
operator|)
name|wqe
operator|)
operator|->
name|byte_count
operator|=
name|cpu_to_be32
argument_list|(
operator|(
literal|1
operator|<<
literal|31
operator|)
operator||
literal|4
argument_list|)
expr_stmt|;
operator|(
operator|(
name|u32
operator|*
operator|)
name|wqe
operator|)
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
operator|/
literal|16
expr_stmt|;
block|}
name|qp
operator|->
name|wrid
index|[
name|ind
index|]
operator|=
name|wr
operator|->
name|wr_id
expr_stmt|;
if|if
condition|(
name|wr
operator|->
name|opcode
operator|>=
name|ARRAY_SIZE
argument_list|(
name|mthca_opcode
argument_list|)
condition|)
block|{
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"opcode invalid\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
operator|*
name|bad_wr
operator|=
name|wr
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|(
operator|(
expr|struct
name|mthca_next_seg
operator|*
operator|)
name|prev_wqe
operator|)
operator|->
name|nda_op
operator|=
name|cpu_to_be32
argument_list|(
operator|(
operator|(
name|ind
operator|<<
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|)
operator|+
name|qp
operator|->
name|send_wqe_offset
operator|)
operator||
name|mthca_opcode
index|[
name|wr
operator|->
name|opcode
index|]
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
operator|(
operator|(
expr|struct
name|mthca_next_seg
operator|*
operator|)
name|prev_wqe
operator|)
operator|->
name|ee_nds
operator|=
name|cpu_to_be32
argument_list|(
operator|(
name|nreq
condition|?
literal|0
else|:
name|MTHCA_NEXT_DBD
operator|)
operator||
name|size
operator||
operator|(
operator|(
name|wr
operator|->
name|send_flags
operator|&
name|IB_SEND_FENCE
operator|)
condition|?
name|MTHCA_NEXT_FENCE
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nreq
condition|)
block|{
name|size0
operator|=
name|size
expr_stmt|;
name|op0
operator|=
name|mthca_opcode
index|[
name|wr
operator|->
name|opcode
index|]
expr_stmt|;
name|f0
operator|=
name|wr
operator|->
name|send_flags
operator|&
name|IB_SEND_FENCE
condition|?
name|MTHCA_SEND_DOORBELL_FENCE
else|:
literal|0
expr_stmt|;
block|}
operator|++
name|ind
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ind
operator|>=
name|qp
operator|->
name|sq
operator|.
name|max
argument_list|)
condition|)
name|ind
operator|-=
name|qp
operator|->
name|sq
operator|.
name|max
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|likely
argument_list|(
name|nreq
argument_list|)
condition|)
block|{
name|wmb
argument_list|()
expr_stmt|;
name|mthca_write64
argument_list|(
operator|(
operator|(
name|qp
operator|->
name|sq
operator|.
name|next_ind
operator|<<
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|)
operator|+
name|qp
operator|->
name|send_wqe_offset
operator|)
operator||
name|f0
operator||
name|op0
argument_list|,
operator|(
name|qp
operator|->
name|qpn
operator|<<
literal|8
operator|)
operator||
name|size0
argument_list|,
name|dev
operator|->
name|kar
operator|+
name|MTHCA_SEND_DOORBELL
argument_list|,
name|MTHCA_GET_DOORBELL_LOCK
argument_list|(
operator|&
name|dev
operator|->
name|doorbell_lock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Make sure doorbells don't leak out of SQ spinlock 		 * and reach the HCA out of order: 		 */
name|mmiowb
argument_list|()
expr_stmt|;
block|}
name|qp
operator|->
name|sq
operator|.
name|next_ind
operator|=
name|ind
expr_stmt|;
name|qp
operator|->
name|sq
operator|.
name|head
operator|+=
name|nreq
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|qp
operator|->
name|sq
operator|.
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mthca_tavor_post_receive
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|ibqp
parameter_list|,
name|struct
name|ib_recv_wr
modifier|*
name|wr
parameter_list|,
name|struct
name|ib_recv_wr
modifier|*
modifier|*
name|bad_wr
parameter_list|)
block|{
name|struct
name|mthca_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ibqp
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mthca_qp
modifier|*
name|qp
init|=
name|to_mqp
argument_list|(
name|ibqp
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|nreq
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* 	 * size0 is only used if nreq != 0, and it will always be 	 * initialized the first time through the main loop before 	 * nreq is incremented.  So nreq cannot become non-zero 	 * without initializing size0, and it is in fact never used 	 * uninitialized. 	 */
name|int
name|uninitialized_var
argument_list|(
name|size0
argument_list|)
decl_stmt|;
name|int
name|ind
decl_stmt|;
name|void
modifier|*
name|wqe
decl_stmt|;
name|void
modifier|*
name|prev_wqe
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|qp
operator|->
name|rq
operator|.
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* XXX check that state is OK to post receive */
name|ind
operator|=
name|qp
operator|->
name|rq
operator|.
name|next_ind
expr_stmt|;
for|for
control|(
name|nreq
operator|=
literal|0
init|;
name|wr
condition|;
name|wr
operator|=
name|wr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|mthca_wq_overflow
argument_list|(
operator|&
name|qp
operator|->
name|rq
argument_list|,
name|nreq
argument_list|,
name|qp
operator|->
name|ibqp
operator|.
name|recv_cq
argument_list|)
condition|)
block|{
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"RQ %06x full (%u head, %u tail,"
literal|" %d max, %d nreq)\n"
argument_list|,
name|qp
operator|->
name|qpn
argument_list|,
name|qp
operator|->
name|rq
operator|.
name|head
argument_list|,
name|qp
operator|->
name|rq
operator|.
name|tail
argument_list|,
name|qp
operator|->
name|rq
operator|.
name|max
argument_list|,
name|nreq
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
operator|*
name|bad_wr
operator|=
name|wr
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|wqe
operator|=
name|get_recv_wqe
argument_list|(
name|qp
argument_list|,
name|ind
argument_list|)
expr_stmt|;
name|prev_wqe
operator|=
name|qp
operator|->
name|rq
operator|.
name|last
expr_stmt|;
name|qp
operator|->
name|rq
operator|.
name|last
operator|=
name|wqe
expr_stmt|;
operator|(
operator|(
expr|struct
name|mthca_next_seg
operator|*
operator|)
name|wqe
operator|)
operator|->
name|ee_nds
operator|=
name|cpu_to_be32
argument_list|(
name|MTHCA_NEXT_DBD
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|mthca_next_seg
operator|*
operator|)
name|wqe
operator|)
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_next_seg
argument_list|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_next_seg
argument_list|)
operator|/
literal|16
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|wr
operator|->
name|num_sge
operator|>
name|qp
operator|->
name|rq
operator|.
name|max_gs
argument_list|)
condition|)
block|{
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
operator|*
name|bad_wr
operator|=
name|wr
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wr
operator|->
name|num_sge
condition|;
operator|++
name|i
control|)
block|{
name|mthca_set_data_seg
argument_list|(
name|wqe
argument_list|,
name|wr
operator|->
name|sg_list
operator|+
name|i
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
operator|/
literal|16
expr_stmt|;
block|}
name|qp
operator|->
name|wrid
index|[
name|ind
operator|+
name|qp
operator|->
name|sq
operator|.
name|max
index|]
operator|=
name|wr
operator|->
name|wr_id
expr_stmt|;
operator|(
operator|(
expr|struct
name|mthca_next_seg
operator|*
operator|)
name|prev_wqe
operator|)
operator|->
name|ee_nds
operator|=
name|cpu_to_be32
argument_list|(
name|MTHCA_NEXT_DBD
operator||
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nreq
condition|)
name|size0
operator|=
name|size
expr_stmt|;
operator|++
name|ind
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ind
operator|>=
name|qp
operator|->
name|rq
operator|.
name|max
argument_list|)
condition|)
name|ind
operator|-=
name|qp
operator|->
name|rq
operator|.
name|max
expr_stmt|;
operator|++
name|nreq
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|nreq
operator|==
name|MTHCA_TAVOR_MAX_WQES_PER_RECV_DB
argument_list|)
condition|)
block|{
name|nreq
operator|=
literal|0
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
name|mthca_write64
argument_list|(
operator|(
name|qp
operator|->
name|rq
operator|.
name|next_ind
operator|<<
name|qp
operator|->
name|rq
operator|.
name|wqe_shift
operator|)
operator||
name|size0
argument_list|,
name|qp
operator|->
name|qpn
operator|<<
literal|8
argument_list|,
name|dev
operator|->
name|kar
operator|+
name|MTHCA_RECEIVE_DOORBELL
argument_list|,
name|MTHCA_GET_DOORBELL_LOCK
argument_list|(
operator|&
name|dev
operator|->
name|doorbell_lock
argument_list|)
argument_list|)
expr_stmt|;
name|qp
operator|->
name|rq
operator|.
name|next_ind
operator|=
name|ind
expr_stmt|;
name|qp
operator|->
name|rq
operator|.
name|head
operator|+=
name|MTHCA_TAVOR_MAX_WQES_PER_RECV_DB
expr_stmt|;
block|}
block|}
name|out
label|:
if|if
condition|(
name|likely
argument_list|(
name|nreq
argument_list|)
condition|)
block|{
name|wmb
argument_list|()
expr_stmt|;
name|mthca_write64
argument_list|(
operator|(
name|qp
operator|->
name|rq
operator|.
name|next_ind
operator|<<
name|qp
operator|->
name|rq
operator|.
name|wqe_shift
operator|)
operator||
name|size0
argument_list|,
name|qp
operator|->
name|qpn
operator|<<
literal|8
operator||
name|nreq
argument_list|,
name|dev
operator|->
name|kar
operator|+
name|MTHCA_RECEIVE_DOORBELL
argument_list|,
name|MTHCA_GET_DOORBELL_LOCK
argument_list|(
operator|&
name|dev
operator|->
name|doorbell_lock
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|qp
operator|->
name|rq
operator|.
name|next_ind
operator|=
name|ind
expr_stmt|;
name|qp
operator|->
name|rq
operator|.
name|head
operator|+=
name|nreq
expr_stmt|;
comment|/* 	 * Make sure doorbells don't leak out of RQ spinlock and reach 	 * the HCA out of order: 	 */
name|mmiowb
argument_list|()
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|qp
operator|->
name|rq
operator|.
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mthca_arbel_post_send
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|ibqp
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
name|wr
parameter_list|,
name|struct
name|ib_send_wr
modifier|*
modifier|*
name|bad_wr
parameter_list|)
block|{
name|struct
name|mthca_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ibqp
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mthca_qp
modifier|*
name|qp
init|=
name|to_mqp
argument_list|(
name|ibqp
argument_list|)
decl_stmt|;
name|u32
name|dbhi
decl_stmt|;
name|void
modifier|*
name|wqe
decl_stmt|;
name|void
modifier|*
name|prev_wqe
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|nreq
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* 	 * f0 and size0 are only used if nreq != 0, and they will 	 * always be initialized the first time through the main loop 	 * before nreq is incremented.  So nreq cannot become non-zero 	 * without initializing f0 and size0, and they are in fact 	 * never used uninitialized. 	 */
name|int
name|uninitialized_var
argument_list|(
name|size0
argument_list|)
decl_stmt|;
name|u32
name|uninitialized_var
argument_list|(
name|f0
argument_list|)
decl_stmt|;
name|int
name|ind
decl_stmt|;
name|u8
name|op0
init|=
literal|0
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|qp
operator|->
name|sq
operator|.
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* XXX check that state is OK to post send */
name|ind
operator|=
name|qp
operator|->
name|sq
operator|.
name|head
operator|&
operator|(
name|qp
operator|->
name|sq
operator|.
name|max
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|nreq
operator|=
literal|0
init|;
name|wr
condition|;
operator|++
name|nreq
operator|,
name|wr
operator|=
name|wr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|unlikely
argument_list|(
name|nreq
operator|==
name|MTHCA_ARBEL_MAX_WQES_PER_SEND_DB
argument_list|)
condition|)
block|{
name|nreq
operator|=
literal|0
expr_stmt|;
name|dbhi
operator|=
operator|(
name|MTHCA_ARBEL_MAX_WQES_PER_SEND_DB
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|qp
operator|->
name|sq
operator|.
name|head
operator|&
literal|0xffff
operator|)
operator|<<
literal|8
operator|)
operator||
name|f0
operator||
name|op0
expr_stmt|;
name|qp
operator|->
name|sq
operator|.
name|head
operator|+=
name|MTHCA_ARBEL_MAX_WQES_PER_SEND_DB
expr_stmt|;
comment|/* 			 * Make sure that descriptors are written before 			 * doorbell record. 			 */
name|wmb
argument_list|()
expr_stmt|;
operator|*
name|qp
operator|->
name|sq
operator|.
name|db
operator|=
name|cpu_to_be32
argument_list|(
name|qp
operator|->
name|sq
operator|.
name|head
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* 			 * Make sure doorbell record is written before we 			 * write MMIO send doorbell. 			 */
name|wmb
argument_list|()
expr_stmt|;
name|mthca_write64
argument_list|(
name|dbhi
argument_list|,
operator|(
name|qp
operator|->
name|qpn
operator|<<
literal|8
operator|)
operator||
name|size0
argument_list|,
name|dev
operator|->
name|kar
operator|+
name|MTHCA_SEND_DOORBELL
argument_list|,
name|MTHCA_GET_DOORBELL_LOCK
argument_list|(
operator|&
name|dev
operator|->
name|doorbell_lock
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mthca_wq_overflow
argument_list|(
operator|&
name|qp
operator|->
name|sq
argument_list|,
name|nreq
argument_list|,
name|qp
operator|->
name|ibqp
operator|.
name|send_cq
argument_list|)
condition|)
block|{
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"SQ %06x full (%u head, %u tail,"
literal|" %d max, %d nreq)\n"
argument_list|,
name|qp
operator|->
name|qpn
argument_list|,
name|qp
operator|->
name|sq
operator|.
name|head
argument_list|,
name|qp
operator|->
name|sq
operator|.
name|tail
argument_list|,
name|qp
operator|->
name|sq
operator|.
name|max
argument_list|,
name|nreq
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
operator|*
name|bad_wr
operator|=
name|wr
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|wqe
operator|=
name|get_send_wqe
argument_list|(
name|qp
argument_list|,
name|ind
argument_list|)
expr_stmt|;
name|prev_wqe
operator|=
name|qp
operator|->
name|sq
operator|.
name|last
expr_stmt|;
name|qp
operator|->
name|sq
operator|.
name|last
operator|=
name|wqe
expr_stmt|;
operator|(
operator|(
expr|struct
name|mthca_next_seg
operator|*
operator|)
name|wqe
operator|)
operator|->
name|flags
operator|=
operator|(
operator|(
name|wr
operator|->
name|send_flags
operator|&
name|IB_SEND_SIGNALED
operator|)
condition|?
name|cpu_to_be32
argument_list|(
name|MTHCA_NEXT_CQ_UPDATE
argument_list|)
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|wr
operator|->
name|send_flags
operator|&
name|IB_SEND_SOLICITED
operator|)
condition|?
name|cpu_to_be32
argument_list|(
name|MTHCA_NEXT_SOLICIT
argument_list|)
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|wr
operator|->
name|send_flags
operator|&
name|IB_SEND_IP_CSUM
operator|)
condition|?
name|cpu_to_be32
argument_list|(
name|MTHCA_NEXT_IP_CSUM
operator||
name|MTHCA_NEXT_TCP_UDP_CSUM
argument_list|)
else|:
literal|0
operator|)
operator||
name|cpu_to_be32
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|wr
operator|->
name|opcode
operator|==
name|IB_WR_SEND_WITH_IMM
operator|||
name|wr
operator|->
name|opcode
operator|==
name|IB_WR_RDMA_WRITE_WITH_IMM
condition|)
operator|(
operator|(
expr|struct
name|mthca_next_seg
operator|*
operator|)
name|wqe
operator|)
operator|->
name|imm
operator|=
name|wr
operator|->
name|ex
operator|.
name|imm_data
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_next_seg
argument_list|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_next_seg
argument_list|)
operator|/
literal|16
expr_stmt|;
switch|switch
condition|(
name|qp
operator|->
name|transport
condition|)
block|{
case|case
name|RC
case|:
switch|switch
condition|(
name|wr
operator|->
name|opcode
condition|)
block|{
case|case
name|IB_WR_ATOMIC_CMP_AND_SWP
case|:
case|case
name|IB_WR_ATOMIC_FETCH_AND_ADD
case|:
name|set_raddr_seg
argument_list|(
name|wqe
argument_list|,
name|wr
operator|->
name|wr
operator|.
name|atomic
operator|.
name|remote_addr
argument_list|,
name|wr
operator|->
name|wr
operator|.
name|atomic
operator|.
name|rkey
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_raddr_seg
argument_list|)
expr_stmt|;
name|set_atomic_seg
argument_list|(
name|wqe
argument_list|,
name|wr
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_atomic_seg
argument_list|)
expr_stmt|;
name|size
operator|+=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_raddr_seg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_atomic_seg
argument_list|)
operator|)
operator|/
literal|16
expr_stmt|;
break|break;
case|case
name|IB_WR_RDMA_READ
case|:
case|case
name|IB_WR_RDMA_WRITE
case|:
case|case
name|IB_WR_RDMA_WRITE_WITH_IMM
case|:
name|set_raddr_seg
argument_list|(
name|wqe
argument_list|,
name|wr
operator|->
name|wr
operator|.
name|rdma
operator|.
name|remote_addr
argument_list|,
name|wr
operator|->
name|wr
operator|.
name|rdma
operator|.
name|rkey
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_raddr_seg
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_raddr_seg
argument_list|)
operator|/
literal|16
expr_stmt|;
break|break;
default|default:
comment|/* No extra segments required for sends */
break|break;
block|}
break|break;
case|case
name|UC
case|:
switch|switch
condition|(
name|wr
operator|->
name|opcode
condition|)
block|{
case|case
name|IB_WR_RDMA_WRITE
case|:
case|case
name|IB_WR_RDMA_WRITE_WITH_IMM
case|:
name|set_raddr_seg
argument_list|(
name|wqe
argument_list|,
name|wr
operator|->
name|wr
operator|.
name|rdma
operator|.
name|remote_addr
argument_list|,
name|wr
operator|->
name|wr
operator|.
name|rdma
operator|.
name|rkey
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_raddr_seg
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_raddr_seg
argument_list|)
operator|/
literal|16
expr_stmt|;
break|break;
default|default:
comment|/* No extra segments required for sends */
break|break;
block|}
break|break;
case|case
name|UD
case|:
name|set_arbel_ud_seg
argument_list|(
name|wqe
argument_list|,
name|wr
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_arbel_ud_seg
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_arbel_ud_seg
argument_list|)
operator|/
literal|16
expr_stmt|;
break|break;
case|case
name|MLX
case|:
name|err
operator|=
name|build_mlx_header
argument_list|(
name|dev
argument_list|,
name|to_msqp
argument_list|(
name|qp
argument_list|)
argument_list|,
name|ind
argument_list|,
name|wr
argument_list|,
name|wqe
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_next_seg
argument_list|)
argument_list|,
name|wqe
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
operator|*
name|bad_wr
operator|=
name|wr
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
operator|/
literal|16
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|wr
operator|->
name|num_sge
operator|>
name|qp
operator|->
name|sq
operator|.
name|max_gs
condition|)
block|{
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"too many gathers\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
operator|*
name|bad_wr
operator|=
name|wr
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wr
operator|->
name|num_sge
condition|;
operator|++
name|i
control|)
block|{
name|mthca_set_data_seg
argument_list|(
name|wqe
argument_list|,
name|wr
operator|->
name|sg_list
operator|+
name|i
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
operator|/
literal|16
expr_stmt|;
block|}
comment|/* Add one more inline data segment for ICRC */
if|if
condition|(
name|qp
operator|->
name|transport
operator|==
name|MLX
condition|)
block|{
operator|(
operator|(
expr|struct
name|mthca_data_seg
operator|*
operator|)
name|wqe
operator|)
operator|->
name|byte_count
operator|=
name|cpu_to_be32
argument_list|(
operator|(
literal|1
operator|<<
literal|31
operator|)
operator||
literal|4
argument_list|)
expr_stmt|;
operator|(
operator|(
name|u32
operator|*
operator|)
name|wqe
operator|)
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
operator|/
literal|16
expr_stmt|;
block|}
name|qp
operator|->
name|wrid
index|[
name|ind
index|]
operator|=
name|wr
operator|->
name|wr_id
expr_stmt|;
if|if
condition|(
name|wr
operator|->
name|opcode
operator|>=
name|ARRAY_SIZE
argument_list|(
name|mthca_opcode
argument_list|)
condition|)
block|{
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"opcode invalid\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
operator|*
name|bad_wr
operator|=
name|wr
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|(
operator|(
expr|struct
name|mthca_next_seg
operator|*
operator|)
name|prev_wqe
operator|)
operator|->
name|nda_op
operator|=
name|cpu_to_be32
argument_list|(
operator|(
operator|(
name|ind
operator|<<
name|qp
operator|->
name|sq
operator|.
name|wqe_shift
operator|)
operator|+
name|qp
operator|->
name|send_wqe_offset
operator|)
operator||
name|mthca_opcode
index|[
name|wr
operator|->
name|opcode
index|]
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
operator|(
operator|(
expr|struct
name|mthca_next_seg
operator|*
operator|)
name|prev_wqe
operator|)
operator|->
name|ee_nds
operator|=
name|cpu_to_be32
argument_list|(
name|MTHCA_NEXT_DBD
operator||
name|size
operator||
operator|(
operator|(
name|wr
operator|->
name|send_flags
operator|&
name|IB_SEND_FENCE
operator|)
condition|?
name|MTHCA_NEXT_FENCE
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nreq
condition|)
block|{
name|size0
operator|=
name|size
expr_stmt|;
name|op0
operator|=
name|mthca_opcode
index|[
name|wr
operator|->
name|opcode
index|]
expr_stmt|;
name|f0
operator|=
name|wr
operator|->
name|send_flags
operator|&
name|IB_SEND_FENCE
condition|?
name|MTHCA_SEND_DOORBELL_FENCE
else|:
literal|0
expr_stmt|;
block|}
operator|++
name|ind
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ind
operator|>=
name|qp
operator|->
name|sq
operator|.
name|max
argument_list|)
condition|)
name|ind
operator|-=
name|qp
operator|->
name|sq
operator|.
name|max
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|likely
argument_list|(
name|nreq
argument_list|)
condition|)
block|{
name|dbhi
operator|=
operator|(
name|nreq
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|qp
operator|->
name|sq
operator|.
name|head
operator|&
literal|0xffff
operator|)
operator|<<
literal|8
operator|)
operator||
name|f0
operator||
name|op0
expr_stmt|;
name|qp
operator|->
name|sq
operator|.
name|head
operator|+=
name|nreq
expr_stmt|;
comment|/* 		 * Make sure that descriptors are written before 		 * doorbell record. 		 */
name|wmb
argument_list|()
expr_stmt|;
operator|*
name|qp
operator|->
name|sq
operator|.
name|db
operator|=
name|cpu_to_be32
argument_list|(
name|qp
operator|->
name|sq
operator|.
name|head
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
comment|/* 		 * Make sure doorbell record is written before we 		 * write MMIO send doorbell. 		 */
name|wmb
argument_list|()
expr_stmt|;
name|mthca_write64
argument_list|(
name|dbhi
argument_list|,
operator|(
name|qp
operator|->
name|qpn
operator|<<
literal|8
operator|)
operator||
name|size0
argument_list|,
name|dev
operator|->
name|kar
operator|+
name|MTHCA_SEND_DOORBELL
argument_list|,
name|MTHCA_GET_DOORBELL_LOCK
argument_list|(
operator|&
name|dev
operator|->
name|doorbell_lock
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Make sure doorbells don't leak out of SQ spinlock and reach 	 * the HCA out of order: 	 */
name|mmiowb
argument_list|()
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|qp
operator|->
name|sq
operator|.
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mthca_arbel_post_receive
parameter_list|(
name|struct
name|ib_qp
modifier|*
name|ibqp
parameter_list|,
name|struct
name|ib_recv_wr
modifier|*
name|wr
parameter_list|,
name|struct
name|ib_recv_wr
modifier|*
modifier|*
name|bad_wr
parameter_list|)
block|{
name|struct
name|mthca_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ibqp
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mthca_qp
modifier|*
name|qp
init|=
name|to_mqp
argument_list|(
name|ibqp
argument_list|)
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|int
name|nreq
decl_stmt|;
name|int
name|ind
decl_stmt|;
name|int
name|i
decl_stmt|;
name|void
modifier|*
name|wqe
decl_stmt|;
name|spin_lock_irqsave
argument_list|(
operator|&
name|qp
operator|->
name|rq
operator|.
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* XXX check that state is OK to post receive */
name|ind
operator|=
name|qp
operator|->
name|rq
operator|.
name|head
operator|&
operator|(
name|qp
operator|->
name|rq
operator|.
name|max
operator|-
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|nreq
operator|=
literal|0
init|;
name|wr
condition|;
operator|++
name|nreq
operator|,
name|wr
operator|=
name|wr
operator|->
name|next
control|)
block|{
if|if
condition|(
name|mthca_wq_overflow
argument_list|(
operator|&
name|qp
operator|->
name|rq
argument_list|,
name|nreq
argument_list|,
name|qp
operator|->
name|ibqp
operator|.
name|recv_cq
argument_list|)
condition|)
block|{
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"RQ %06x full (%u head, %u tail,"
literal|" %d max, %d nreq)\n"
argument_list|,
name|qp
operator|->
name|qpn
argument_list|,
name|qp
operator|->
name|rq
operator|.
name|head
argument_list|,
name|qp
operator|->
name|rq
operator|.
name|tail
argument_list|,
name|qp
operator|->
name|rq
operator|.
name|max
argument_list|,
name|nreq
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
operator|*
name|bad_wr
operator|=
name|wr
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|wqe
operator|=
name|get_recv_wqe
argument_list|(
name|qp
argument_list|,
name|ind
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|mthca_next_seg
operator|*
operator|)
name|wqe
operator|)
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_next_seg
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|wr
operator|->
name|num_sge
operator|>
name|qp
operator|->
name|rq
operator|.
name|max_gs
argument_list|)
condition|)
block|{
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
operator|*
name|bad_wr
operator|=
name|wr
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|wr
operator|->
name|num_sge
condition|;
operator|++
name|i
control|)
block|{
name|mthca_set_data_seg
argument_list|(
name|wqe
argument_list|,
name|wr
operator|->
name|sg_list
operator|+
name|i
argument_list|)
expr_stmt|;
name|wqe
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|qp
operator|->
name|rq
operator|.
name|max_gs
condition|)
name|mthca_set_data_seg_inval
argument_list|(
name|wqe
argument_list|)
expr_stmt|;
name|qp
operator|->
name|wrid
index|[
name|ind
operator|+
name|qp
operator|->
name|sq
operator|.
name|max
index|]
operator|=
name|wr
operator|->
name|wr_id
expr_stmt|;
operator|++
name|ind
expr_stmt|;
if|if
condition|(
name|unlikely
argument_list|(
name|ind
operator|>=
name|qp
operator|->
name|rq
operator|.
name|max
argument_list|)
condition|)
name|ind
operator|-=
name|qp
operator|->
name|rq
operator|.
name|max
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|likely
argument_list|(
name|nreq
argument_list|)
condition|)
block|{
name|qp
operator|->
name|rq
operator|.
name|head
operator|+=
name|nreq
expr_stmt|;
comment|/* 		 * Make sure that descriptors are written before 		 * doorbell record. 		 */
name|wmb
argument_list|()
expr_stmt|;
operator|*
name|qp
operator|->
name|rq
operator|.
name|db
operator|=
name|cpu_to_be32
argument_list|(
name|qp
operator|->
name|rq
operator|.
name|head
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
block|}
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|qp
operator|->
name|rq
operator|.
name|lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|void
name|mthca_free_err_wqe
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_qp
modifier|*
name|qp
parameter_list|,
name|int
name|is_send
parameter_list|,
name|int
name|index
parameter_list|,
name|int
modifier|*
name|dbd
parameter_list|,
name|__be32
modifier|*
name|new_wqe
parameter_list|)
block|{
name|struct
name|mthca_next_seg
modifier|*
name|next
decl_stmt|;
comment|/* 	 * For SRQs, all receive WQEs generate a CQE, so we're always 	 * at the end of the doorbell chain. 	 */
if|if
condition|(
name|qp
operator|->
name|ibqp
operator|.
name|srq
operator|&&
operator|!
name|is_send
condition|)
block|{
operator|*
name|new_wqe
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is_send
condition|)
name|next
operator|=
name|get_send_wqe
argument_list|(
name|qp
argument_list|,
name|index
argument_list|)
expr_stmt|;
else|else
name|next
operator|=
name|get_recv_wqe
argument_list|(
name|qp
argument_list|,
name|index
argument_list|)
expr_stmt|;
operator|*
name|dbd
operator|=
operator|!
operator|!
operator|(
name|next
operator|->
name|ee_nds
operator|&
name|cpu_to_be32
argument_list|(
name|MTHCA_NEXT_DBD
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|ee_nds
operator|&
name|cpu_to_be32
argument_list|(
literal|0x3f
argument_list|)
condition|)
operator|*
name|new_wqe
operator|=
operator|(
name|next
operator|->
name|nda_op
operator|&
name|cpu_to_be32
argument_list|(
operator|~
literal|0x3f
argument_list|)
operator|)
operator||
operator|(
name|next
operator|->
name|ee_nds
operator|&
name|cpu_to_be32
argument_list|(
literal|0x3f
argument_list|)
operator|)
expr_stmt|;
else|else
operator|*
name|new_wqe
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mthca_init_qp_table
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|u8
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * We reserve 2 extra QPs per port for the special QPs.  The 	 * special QP for port 1 has to be even, so round up. 	 */
name|dev
operator|->
name|qp_table
operator|.
name|sqp_start
operator|=
operator|(
name|dev
operator|->
name|limits
operator|.
name|reserved_qps
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1UL
expr_stmt|;
name|err
operator|=
name|mthca_alloc_init
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|alloc
argument_list|,
name|dev
operator|->
name|limits
operator|.
name|num_qps
argument_list|,
operator|(
literal|1
operator|<<
literal|24
operator|)
operator|-
literal|1
argument_list|,
name|dev
operator|->
name|qp_table
operator|.
name|sqp_start
operator|+
name|MTHCA_MAX_PORTS
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|err
operator|=
name|mthca_array_init
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|qp
argument_list|,
name|dev
operator|->
name|limits
operator|.
name|num_qps
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_alloc_cleanup
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|alloc
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
block|{
name|err
operator|=
name|mthca_CONF_SPECIAL_QP
argument_list|(
name|dev
argument_list|,
name|i
condition|?
name|IB_QPT_GSI
else|:
name|IB_QPT_SMI
argument_list|,
name|dev
operator|->
name|qp_table
operator|.
name|sqp_start
operator|+
name|i
operator|*
literal|2
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_out
goto|;
if|if
condition|(
name|status
condition|)
block|{
name|mthca_warn
argument_list|(
name|dev
argument_list|,
literal|"CONF_SPECIAL_QP returned "
literal|"status %02x, aborting.\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
block|}
return|return
literal|0
return|;
name|err_out
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
name|mthca_CONF_SPECIAL_QP
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|mthca_array_cleanup
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|qp
argument_list|,
name|dev
operator|->
name|limits
operator|.
name|num_qps
argument_list|)
expr_stmt|;
name|mthca_alloc_cleanup
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|alloc
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|void
name|mthca_cleanup_qp_table
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u8
name|status
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
name|mthca_CONF_SPECIAL_QP
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|mthca_array_cleanup
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|qp
argument_list|,
name|dev
operator|->
name|limits
operator|.
name|num_qps
argument_list|)
expr_stmt|;
name|mthca_alloc_cleanup
argument_list|(
operator|&
name|dev
operator|->
name|qp_table
operator|.
name|alloc
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

