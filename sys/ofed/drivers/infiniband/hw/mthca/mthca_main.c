begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.  * Copyright (c) 2005 Sun Microsystems, Inc. All rights reserved.  * Copyright (c) 2005 Mellanox Technologies. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_define
define|#
directive|define
name|LINUXKPI_PARAM_PREFIX
value|mthca_
end_define

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/errno.h>
end_include

begin_include
include|#
directive|include
file|<linux/pci.h>
end_include

begin_include
include|#
directive|include
file|<linux/interrupt.h>
end_include

begin_include
include|#
directive|include
file|"mthca_dev.h"
end_include

begin_include
include|#
directive|include
file|"mthca_config_reg.h"
end_include

begin_include
include|#
directive|include
file|"mthca_cmd.h"
end_include

begin_include
include|#
directive|include
file|"mthca_profile.h"
end_include

begin_include
include|#
directive|include
file|"mthca_memfree.h"
end_include

begin_include
include|#
directive|include
file|"mthca_wqe.h"
end_include

begin_expr_stmt
name|MODULE_AUTHOR
argument_list|(
literal|"Roland Dreier"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DESCRIPTION
argument_list|(
literal|"Mellanox InfiniBand HCA low-level driver"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_LICENSE
argument_list|(
literal|"Dual BSD/GPL"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|DRV_VERSION
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_INFINIBAND_MTHCA_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|mthca_debug_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|debug_level
argument_list|,
name|mthca_debug_level
argument_list|,
name|int
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|debug_level
argument_list|,
literal|"Enable debug tracing if> 0"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_INFINIBAND_MTHCA_DEBUG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_PCI_MSI
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|msi_x
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param
argument_list|(
name|msi_x
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|msi_x
argument_list|,
literal|"attempt to use MSI-X if nonzero"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* CONFIG_PCI_MSI */
end_comment

begin_define
define|#
directive|define
name|msi_x
value|(0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CONFIG_PCI_MSI */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tune_pci
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param
argument_list|(
name|tune_pci
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|tune_pci
argument_list|,
literal|"increase PCI burst from the default set by BIOS if nonzero"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DEFINE_MUTEX
argument_list|(
name|mthca_device_mutex
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|MTHCA_DEFAULT_NUM_QP
value|(1<< 16)
end_define

begin_define
define|#
directive|define
name|MTHCA_DEFAULT_RDB_PER_QP
value|(1<< 2)
end_define

begin_define
define|#
directive|define
name|MTHCA_DEFAULT_NUM_CQ
value|(1<< 16)
end_define

begin_define
define|#
directive|define
name|MTHCA_DEFAULT_NUM_MCG
value|(1<< 13)
end_define

begin_define
define|#
directive|define
name|MTHCA_DEFAULT_NUM_MPT
value|(1<< 17)
end_define

begin_define
define|#
directive|define
name|MTHCA_DEFAULT_NUM_MTT
value|(1<< 20)
end_define

begin_define
define|#
directive|define
name|MTHCA_DEFAULT_NUM_UDAV
value|(1<< 15)
end_define

begin_define
define|#
directive|define
name|MTHCA_DEFAULT_NUM_RESERVED_MTTS
value|(1<< 18)
end_define

begin_define
define|#
directive|define
name|MTHCA_DEFAULT_NUM_UARC_SIZE
value|(1<< 18)
end_define

begin_decl_stmt
specifier|static
name|struct
name|mthca_profile
name|hca_profile
init|=
block|{
operator|.
name|num_qp
operator|=
name|MTHCA_DEFAULT_NUM_QP
block|,
operator|.
name|rdb_per_qp
operator|=
name|MTHCA_DEFAULT_RDB_PER_QP
block|,
operator|.
name|num_cq
operator|=
name|MTHCA_DEFAULT_NUM_CQ
block|,
operator|.
name|num_mcg
operator|=
name|MTHCA_DEFAULT_NUM_MCG
block|,
operator|.
name|num_mpt
operator|=
name|MTHCA_DEFAULT_NUM_MPT
block|,
operator|.
name|num_mtt
operator|=
name|MTHCA_DEFAULT_NUM_MTT
block|,
operator|.
name|num_udav
operator|=
name|MTHCA_DEFAULT_NUM_UDAV
block|,
comment|/* Tavor only */
operator|.
name|fmr_reserved_mtts
operator|=
name|MTHCA_DEFAULT_NUM_RESERVED_MTTS
block|,
comment|/* Tavor only */
operator|.
name|uarc_size
operator|=
name|MTHCA_DEFAULT_NUM_UARC_SIZE
block|,
comment|/* Arbel only */
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|num_qp
argument_list|,
name|hca_profile
operator|.
name|num_qp
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|num_qp
argument_list|,
literal|"maximum number of QPs per HCA"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|rdb_per_qp
argument_list|,
name|hca_profile
operator|.
name|rdb_per_qp
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|rdb_per_qp
argument_list|,
literal|"number of RDB buffers per QP"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|num_cq
argument_list|,
name|hca_profile
operator|.
name|num_cq
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|num_cq
argument_list|,
literal|"maximum number of CQs per HCA"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|num_mcg
argument_list|,
name|hca_profile
operator|.
name|num_mcg
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|num_mcg
argument_list|,
literal|"maximum number of multicast groups per HCA"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|num_mpt
argument_list|,
name|hca_profile
operator|.
name|num_mpt
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|num_mpt
argument_list|,
literal|"maximum number of memory protection table entries per HCA"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|num_mtt
argument_list|,
name|hca_profile
operator|.
name|num_mtt
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|num_mtt
argument_list|,
literal|"maximum number of memory translation table segments per HCA"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|num_udav
argument_list|,
name|hca_profile
operator|.
name|num_udav
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|num_udav
argument_list|,
literal|"maximum number of UD address vectors per HCA"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|fmr_reserved_mtts
argument_list|,
name|hca_profile
operator|.
name|fmr_reserved_mtts
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|fmr_reserved_mtts
argument_list|,
literal|"number of memory translation table segments reserved for FMR"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|log_mtts_per_seg
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|log_mtts_per_seg
argument_list|,
name|log_mtts_per_seg
argument_list|,
name|int
argument_list|,
literal|0444
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|log_mtts_per_seg
argument_list|,
literal|"Log2 number of MTT entries per segment (1-5)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|char
name|mthca_version
index|[]
name|__devinitdata
init|=
name|DRV_NAME
literal|": Mellanox InfiniBand HCA driver v"
name|DRV_VERSION
literal|" ("
name|DRV_RELDATE
literal|")\n"
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|mthca_tune_pci
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|mdev
parameter_list|)
block|{
if|if
condition|(
operator|!
name|tune_pci
condition|)
return|return
literal|0
return|;
comment|/* First try to max out Read Byte Count */
if|if
condition|(
name|pci_find_capability
argument_list|(
name|mdev
operator|->
name|pdev
argument_list|,
name|PCI_CAP_ID_PCIX
argument_list|)
condition|)
block|{
if|if
condition|(
name|pcix_set_mmrbc
argument_list|(
name|mdev
operator|->
name|pdev
argument_list|,
name|pcix_get_max_mmrbc
argument_list|(
name|mdev
operator|->
name|pdev
argument_list|)
argument_list|)
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"Couldn't set PCI-X max read count, "
literal|"aborting.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|mdev
operator|->
name|mthca_flags
operator|&
name|MTHCA_FLAG_PCIE
operator|)
condition|)
name|mthca_info
argument_list|(
name|mdev
argument_list|,
literal|"No PCI-X capability, not setting RBC.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pci_find_capability
argument_list|(
name|mdev
operator|->
name|pdev
argument_list|,
name|PCI_CAP_ID_EXP
argument_list|)
condition|)
block|{
if|if
condition|(
name|pcie_set_readrq
argument_list|(
name|mdev
operator|->
name|pdev
argument_list|,
literal|4096
argument_list|)
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"Couldn't write PCI Express read request, "
literal|"aborting.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|mdev
operator|->
name|mthca_flags
operator|&
name|MTHCA_FLAG_PCIE
condition|)
name|mthca_info
argument_list|(
name|mdev
argument_list|,
literal|"No PCI Express capability, "
literal|"not setting Max Read Request Size.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mthca_dev_lim
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|mdev
parameter_list|,
name|struct
name|mthca_dev_lim
modifier|*
name|dev_lim
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|u8
name|status
decl_stmt|;
name|mdev
operator|->
name|limits
operator|.
name|mtt_seg_size
operator|=
operator|(
literal|1
operator|<<
name|log_mtts_per_seg
operator|)
operator|*
literal|8
expr_stmt|;
name|err
operator|=
name|mthca_QUERY_DEV_LIM
argument_list|(
name|mdev
argument_list|,
name|dev_lim
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"QUERY_DEV_LIM command failed, aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|status
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"QUERY_DEV_LIM returned status 0x%02x, "
literal|"aborting.\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|dev_lim
operator|->
name|min_page_sz
operator|>
name|PAGE_SIZE
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"HCA minimum page size of %d bigger than "
literal|"kernel PAGE_SIZE of %d, aborting.\n"
argument_list|,
name|dev_lim
operator|->
name|min_page_sz
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
if|if
condition|(
name|dev_lim
operator|->
name|num_ports
operator|>
name|MTHCA_MAX_PORTS
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"HCA has %d ports, but we only support %d, "
literal|"aborting.\n"
argument_list|,
name|dev_lim
operator|->
name|num_ports
argument_list|,
name|MTHCA_MAX_PORTS
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
if|if
condition|(
name|dev_lim
operator|->
name|uar_size
operator|>
name|pci_resource_len
argument_list|(
name|mdev
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"HCA reported UAR size of 0x%x bigger than "
literal|"PCI resource 2 size of 0x%llx, aborting.\n"
argument_list|,
name|dev_lim
operator|->
name|uar_size
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|pci_resource_len
argument_list|(
name|mdev
operator|->
name|pdev
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
name|mdev
operator|->
name|limits
operator|.
name|num_ports
operator|=
name|dev_lim
operator|->
name|num_ports
expr_stmt|;
name|mdev
operator|->
name|limits
operator|.
name|vl_cap
operator|=
name|dev_lim
operator|->
name|max_vl
expr_stmt|;
name|mdev
operator|->
name|limits
operator|.
name|mtu_cap
operator|=
name|dev_lim
operator|->
name|max_mtu
expr_stmt|;
name|mdev
operator|->
name|limits
operator|.
name|gid_table_len
operator|=
name|dev_lim
operator|->
name|max_gids
expr_stmt|;
name|mdev
operator|->
name|limits
operator|.
name|pkey_table_len
operator|=
name|dev_lim
operator|->
name|max_pkeys
expr_stmt|;
name|mdev
operator|->
name|limits
operator|.
name|local_ca_ack_delay
operator|=
name|dev_lim
operator|->
name|local_ca_ack_delay
expr_stmt|;
comment|/* 	 * Need to allow for worst case send WQE overhead and check 	 * whether max_desc_sz imposes a lower limit than max_sg; UD 	 * send has the biggest overhead. 	 */
name|mdev
operator|->
name|limits
operator|.
name|max_sg
operator|=
name|min_t
argument_list|(
name|int
argument_list|,
name|dev_lim
operator|->
name|max_sg
argument_list|,
operator|(
name|dev_lim
operator|->
name|max_desc_sz
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_next_seg
argument_list|)
operator|-
operator|(
name|mthca_is_memfree
argument_list|(
name|mdev
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_arbel_ud_seg
argument_list|)
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_tavor_ud_seg
argument_list|)
operator|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_data_seg
argument_list|)
argument_list|)
expr_stmt|;
name|mdev
operator|->
name|limits
operator|.
name|max_wqes
operator|=
name|dev_lim
operator|->
name|max_qp_sz
expr_stmt|;
name|mdev
operator|->
name|limits
operator|.
name|max_qp_init_rdma
operator|=
name|dev_lim
operator|->
name|max_requester_per_qp
expr_stmt|;
name|mdev
operator|->
name|limits
operator|.
name|reserved_qps
operator|=
name|dev_lim
operator|->
name|reserved_qps
expr_stmt|;
name|mdev
operator|->
name|limits
operator|.
name|max_srq_wqes
operator|=
name|dev_lim
operator|->
name|max_srq_sz
expr_stmt|;
name|mdev
operator|->
name|limits
operator|.
name|reserved_srqs
operator|=
name|dev_lim
operator|->
name|reserved_srqs
expr_stmt|;
name|mdev
operator|->
name|limits
operator|.
name|reserved_eecs
operator|=
name|dev_lim
operator|->
name|reserved_eecs
expr_stmt|;
name|mdev
operator|->
name|limits
operator|.
name|max_desc_sz
operator|=
name|dev_lim
operator|->
name|max_desc_sz
expr_stmt|;
name|mdev
operator|->
name|limits
operator|.
name|max_srq_sge
operator|=
name|mthca_max_srq_sge
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
comment|/* 	 * Subtract 1 from the limit because we need to allocate a 	 * spare CQE so the HCA HW can tell the difference between an 	 * empty CQ and a full CQ. 	 */
name|mdev
operator|->
name|limits
operator|.
name|max_cqes
operator|=
name|dev_lim
operator|->
name|max_cq_sz
operator|-
literal|1
expr_stmt|;
name|mdev
operator|->
name|limits
operator|.
name|reserved_cqs
operator|=
name|dev_lim
operator|->
name|reserved_cqs
expr_stmt|;
name|mdev
operator|->
name|limits
operator|.
name|reserved_eqs
operator|=
name|dev_lim
operator|->
name|reserved_eqs
expr_stmt|;
name|mdev
operator|->
name|limits
operator|.
name|reserved_mtts
operator|=
name|dev_lim
operator|->
name|reserved_mtts
expr_stmt|;
name|mdev
operator|->
name|limits
operator|.
name|reserved_mrws
operator|=
name|dev_lim
operator|->
name|reserved_mrws
expr_stmt|;
name|mdev
operator|->
name|limits
operator|.
name|reserved_uars
operator|=
name|dev_lim
operator|->
name|reserved_uars
expr_stmt|;
name|mdev
operator|->
name|limits
operator|.
name|reserved_pds
operator|=
name|dev_lim
operator|->
name|reserved_pds
expr_stmt|;
name|mdev
operator|->
name|limits
operator|.
name|port_width_cap
operator|=
name|dev_lim
operator|->
name|max_port_width
expr_stmt|;
name|mdev
operator|->
name|limits
operator|.
name|page_size_cap
operator|=
operator|~
call|(
name|u32
call|)
argument_list|(
name|dev_lim
operator|->
name|min_page_sz
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mdev
operator|->
name|limits
operator|.
name|flags
operator|=
name|dev_lim
operator|->
name|flags
expr_stmt|;
comment|/* 	 * For old FW that doesn't return static rate support, use a 	 * value of 0x3 (only static rate values of 0 or 1 are handled), 	 * except on Sinai, where even old FW can handle static rate 	 * values of 2 and 3. 	 */
if|if
condition|(
name|dev_lim
operator|->
name|stat_rate_support
condition|)
name|mdev
operator|->
name|limits
operator|.
name|stat_rate_support
operator|=
name|dev_lim
operator|->
name|stat_rate_support
expr_stmt|;
elseif|else
if|if
condition|(
name|mdev
operator|->
name|mthca_flags
operator|&
name|MTHCA_FLAG_SINAI_OPT
condition|)
name|mdev
operator|->
name|limits
operator|.
name|stat_rate_support
operator|=
literal|0xf
expr_stmt|;
else|else
name|mdev
operator|->
name|limits
operator|.
name|stat_rate_support
operator|=
literal|0x3
expr_stmt|;
comment|/* IB_DEVICE_RESIZE_MAX_WR not supported by driver. 	   May be doable since hardware supports it for SRQ.  	   IB_DEVICE_N_NOTIFY_CQ is supported by hardware but not by driver.  	   IB_DEVICE_SRQ_RESIZE is supported by hardware but SRQ is not 	   supported by driver. */
name|mdev
operator|->
name|device_cap_flags
operator|=
name|IB_DEVICE_CHANGE_PHY_PORT
operator||
name|IB_DEVICE_PORT_ACTIVE_EVENT
operator||
name|IB_DEVICE_SYS_IMAGE_GUID
operator||
name|IB_DEVICE_RC_RNR_NAK_GEN
expr_stmt|;
if|if
condition|(
name|dev_lim
operator|->
name|flags
operator|&
name|DEV_LIM_FLAG_BAD_PKEY_CNTR
condition|)
name|mdev
operator|->
name|device_cap_flags
operator||=
name|IB_DEVICE_BAD_PKEY_CNTR
expr_stmt|;
if|if
condition|(
name|dev_lim
operator|->
name|flags
operator|&
name|DEV_LIM_FLAG_BAD_QKEY_CNTR
condition|)
name|mdev
operator|->
name|device_cap_flags
operator||=
name|IB_DEVICE_BAD_QKEY_CNTR
expr_stmt|;
if|if
condition|(
name|dev_lim
operator|->
name|flags
operator|&
name|DEV_LIM_FLAG_RAW_MULTI
condition|)
name|mdev
operator|->
name|device_cap_flags
operator||=
name|IB_DEVICE_RAW_MULTI
expr_stmt|;
if|if
condition|(
name|dev_lim
operator|->
name|flags
operator|&
name|DEV_LIM_FLAG_AUTO_PATH_MIG
condition|)
name|mdev
operator|->
name|device_cap_flags
operator||=
name|IB_DEVICE_AUTO_PATH_MIG
expr_stmt|;
if|if
condition|(
name|dev_lim
operator|->
name|flags
operator|&
name|DEV_LIM_FLAG_UD_AV_PORT_ENFORCE
condition|)
name|mdev
operator|->
name|device_cap_flags
operator||=
name|IB_DEVICE_UD_AV_PORT_ENFORCE
expr_stmt|;
if|if
condition|(
name|dev_lim
operator|->
name|flags
operator|&
name|DEV_LIM_FLAG_SRQ
condition|)
name|mdev
operator|->
name|mthca_flags
operator||=
name|MTHCA_FLAG_SRQ
expr_stmt|;
if|if
condition|(
name|mthca_is_memfree
argument_list|(
name|mdev
argument_list|)
condition|)
if|if
condition|(
name|dev_lim
operator|->
name|flags
operator|&
name|DEV_LIM_FLAG_IPOIB_CSUM
condition|)
name|mdev
operator|->
name|device_cap_flags
operator||=
name|IB_DEVICE_UD_IP_CSUM
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mthca_init_tavor
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|mdev
parameter_list|)
block|{
name|s64
name|size
decl_stmt|;
name|u8
name|status
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|mthca_dev_lim
name|dev_lim
decl_stmt|;
name|struct
name|mthca_profile
name|profile
decl_stmt|;
name|struct
name|mthca_init_hca_param
name|init_hca
decl_stmt|;
name|err
operator|=
name|mthca_SYS_EN
argument_list|(
name|mdev
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"SYS_EN command failed, aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|status
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"SYS_EN returned status 0x%02x, "
literal|"aborting.\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|err
operator|=
name|mthca_QUERY_FW
argument_list|(
name|mdev
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"QUERY_FW command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_disable
goto|;
block|}
if|if
condition|(
name|status
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"QUERY_FW returned status 0x%02x, "
literal|"aborting.\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_disable
goto|;
block|}
name|err
operator|=
name|mthca_QUERY_DDR
argument_list|(
name|mdev
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"QUERY_DDR command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_disable
goto|;
block|}
if|if
condition|(
name|status
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"QUERY_DDR returned status 0x%02x, "
literal|"aborting.\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_disable
goto|;
block|}
name|err
operator|=
name|mthca_dev_lim
argument_list|(
name|mdev
argument_list|,
operator|&
name|dev_lim
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"QUERY_DEV_LIM command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_disable
goto|;
block|}
name|profile
operator|=
name|hca_profile
expr_stmt|;
name|profile
operator|.
name|num_uar
operator|=
name|dev_lim
operator|.
name|uar_size
operator|/
name|PAGE_SIZE
expr_stmt|;
name|profile
operator|.
name|uarc_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mdev
operator|->
name|mthca_flags
operator|&
name|MTHCA_FLAG_SRQ
condition|)
name|profile
operator|.
name|num_srq
operator|=
name|dev_lim
operator|.
name|max_srqs
expr_stmt|;
name|size
operator|=
name|mthca_make_profile
argument_list|(
name|mdev
argument_list|,
operator|&
name|profile
argument_list|,
operator|&
name|dev_lim
argument_list|,
operator|&
name|init_hca
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
block|{
name|err
operator|=
name|size
expr_stmt|;
goto|goto
name|err_disable
goto|;
block|}
name|err
operator|=
name|mthca_INIT_HCA
argument_list|(
name|mdev
argument_list|,
operator|&
name|init_hca
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"INIT_HCA command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_disable
goto|;
block|}
if|if
condition|(
name|status
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"INIT_HCA returned status 0x%02x, "
literal|"aborting.\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_disable
goto|;
block|}
return|return
literal|0
return|;
name|err_disable
label|:
name|mthca_SYS_DIS
argument_list|(
name|mdev
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mthca_load_fw
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|mdev
parameter_list|)
block|{
name|u8
name|status
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* FIXME: use HCA-attached memory for FW if present */
name|mdev
operator|->
name|fw
operator|.
name|arbel
operator|.
name|fw_icm
operator|=
name|mthca_alloc_icm
argument_list|(
name|mdev
argument_list|,
name|mdev
operator|->
name|fw
operator|.
name|arbel
operator|.
name|fw_pages
argument_list|,
name|GFP_HIGHUSER
operator||
name|__GFP_NOWARN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mdev
operator|->
name|fw
operator|.
name|arbel
operator|.
name|fw_icm
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"Couldn't allocate FW area, aborting.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|err
operator|=
name|mthca_MAP_FA
argument_list|(
name|mdev
argument_list|,
name|mdev
operator|->
name|fw
operator|.
name|arbel
operator|.
name|fw_icm
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"MAP_FA command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free
goto|;
block|}
if|if
condition|(
name|status
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"MAP_FA returned status 0x%02x, aborting.\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_free
goto|;
block|}
name|err
operator|=
name|mthca_RUN_FW
argument_list|(
name|mdev
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"RUN_FW command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_fa
goto|;
block|}
if|if
condition|(
name|status
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"RUN_FW returned status 0x%02x, aborting.\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_unmap_fa
goto|;
block|}
return|return
literal|0
return|;
name|err_unmap_fa
label|:
name|mthca_UNMAP_FA
argument_list|(
name|mdev
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|err_free
label|:
name|mthca_free_icm
argument_list|(
name|mdev
argument_list|,
name|mdev
operator|->
name|fw
operator|.
name|arbel
operator|.
name|fw_icm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mthca_init_icm
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|mdev
parameter_list|,
name|struct
name|mthca_dev_lim
modifier|*
name|dev_lim
parameter_list|,
name|struct
name|mthca_init_hca_param
modifier|*
name|init_hca
parameter_list|,
name|u64
name|icm_size
parameter_list|)
block|{
name|u64
name|aux_pages
decl_stmt|;
name|u8
name|status
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|mthca_SET_ICM_SIZE
argument_list|(
name|mdev
argument_list|,
name|icm_size
argument_list|,
operator|&
name|aux_pages
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"SET_ICM_SIZE command failed, aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|status
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"SET_ICM_SIZE returned status 0x%02x, "
literal|"aborting.\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|mthca_dbg
argument_list|(
name|mdev
argument_list|,
literal|"%lld KB of HCA context requires %lld KB aux memory.\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|icm_size
operator|>>
literal|10
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|aux_pages
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|mdev
operator|->
name|fw
operator|.
name|arbel
operator|.
name|aux_icm
operator|=
name|mthca_alloc_icm
argument_list|(
name|mdev
argument_list|,
name|aux_pages
argument_list|,
name|GFP_HIGHUSER
operator||
name|__GFP_NOWARN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mdev
operator|->
name|fw
operator|.
name|arbel
operator|.
name|aux_icm
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"Couldn't allocate aux memory, aborting.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
name|err
operator|=
name|mthca_MAP_ICM_AUX
argument_list|(
name|mdev
argument_list|,
name|mdev
operator|->
name|fw
operator|.
name|arbel
operator|.
name|aux_icm
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"MAP_ICM_AUX command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free_aux
goto|;
block|}
if|if
condition|(
name|status
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"MAP_ICM_AUX returned status 0x%02x, aborting.\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_free_aux
goto|;
block|}
name|err
operator|=
name|mthca_map_eq_icm
argument_list|(
name|mdev
argument_list|,
name|init_hca
operator|->
name|eqc_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"Failed to map EQ context memory, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_unmap_aux
goto|;
block|}
comment|/* CPU writes to non-reserved MTTs, while HCA might DMA to reserved mtts */
name|mdev
operator|->
name|limits
operator|.
name|reserved_mtts
operator|=
name|ALIGN
argument_list|(
name|mdev
operator|->
name|limits
operator|.
name|reserved_mtts
operator|*
name|mdev
operator|->
name|limits
operator|.
name|mtt_seg_size
argument_list|,
name|dma_get_cache_alignment
argument_list|()
argument_list|)
operator|/
name|mdev
operator|->
name|limits
operator|.
name|mtt_seg_size
expr_stmt|;
name|mdev
operator|->
name|mr_table
operator|.
name|mtt_table
operator|=
name|mthca_alloc_icm_table
argument_list|(
name|mdev
argument_list|,
name|init_hca
operator|->
name|mtt_base
argument_list|,
name|mdev
operator|->
name|limits
operator|.
name|mtt_seg_size
argument_list|,
name|mdev
operator|->
name|limits
operator|.
name|num_mtt_segs
argument_list|,
name|mdev
operator|->
name|limits
operator|.
name|reserved_mtts
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mdev
operator|->
name|mr_table
operator|.
name|mtt_table
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"Failed to map MTT context memory, aborting.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_unmap_eq
goto|;
block|}
name|mdev
operator|->
name|mr_table
operator|.
name|mpt_table
operator|=
name|mthca_alloc_icm_table
argument_list|(
name|mdev
argument_list|,
name|init_hca
operator|->
name|mpt_base
argument_list|,
name|dev_lim
operator|->
name|mpt_entry_sz
argument_list|,
name|mdev
operator|->
name|limits
operator|.
name|num_mpts
argument_list|,
name|mdev
operator|->
name|limits
operator|.
name|reserved_mrws
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mdev
operator|->
name|mr_table
operator|.
name|mpt_table
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"Failed to map MPT context memory, aborting.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_unmap_mtt
goto|;
block|}
name|mdev
operator|->
name|qp_table
operator|.
name|qp_table
operator|=
name|mthca_alloc_icm_table
argument_list|(
name|mdev
argument_list|,
name|init_hca
operator|->
name|qpc_base
argument_list|,
name|dev_lim
operator|->
name|qpc_entry_sz
argument_list|,
name|mdev
operator|->
name|limits
operator|.
name|num_qps
argument_list|,
name|mdev
operator|->
name|limits
operator|.
name|reserved_qps
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mdev
operator|->
name|qp_table
operator|.
name|qp_table
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"Failed to map QP context memory, aborting.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_unmap_mpt
goto|;
block|}
name|mdev
operator|->
name|qp_table
operator|.
name|eqp_table
operator|=
name|mthca_alloc_icm_table
argument_list|(
name|mdev
argument_list|,
name|init_hca
operator|->
name|eqpc_base
argument_list|,
name|dev_lim
operator|->
name|eqpc_entry_sz
argument_list|,
name|mdev
operator|->
name|limits
operator|.
name|num_qps
argument_list|,
name|mdev
operator|->
name|limits
operator|.
name|reserved_qps
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mdev
operator|->
name|qp_table
operator|.
name|eqp_table
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"Failed to map EQP context memory, aborting.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_unmap_qp
goto|;
block|}
name|mdev
operator|->
name|qp_table
operator|.
name|rdb_table
operator|=
name|mthca_alloc_icm_table
argument_list|(
name|mdev
argument_list|,
name|init_hca
operator|->
name|rdb_base
argument_list|,
name|MTHCA_RDB_ENTRY_SIZE
argument_list|,
name|mdev
operator|->
name|limits
operator|.
name|num_qps
operator|<<
name|mdev
operator|->
name|qp_table
operator|.
name|rdb_shift
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mdev
operator|->
name|qp_table
operator|.
name|rdb_table
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"Failed to map RDB context memory, aborting\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_unmap_eqp
goto|;
block|}
name|mdev
operator|->
name|cq_table
operator|.
name|table
operator|=
name|mthca_alloc_icm_table
argument_list|(
name|mdev
argument_list|,
name|init_hca
operator|->
name|cqc_base
argument_list|,
name|dev_lim
operator|->
name|cqc_entry_sz
argument_list|,
name|mdev
operator|->
name|limits
operator|.
name|num_cqs
argument_list|,
name|mdev
operator|->
name|limits
operator|.
name|reserved_cqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mdev
operator|->
name|cq_table
operator|.
name|table
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"Failed to map CQ context memory, aborting.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_unmap_rdb
goto|;
block|}
if|if
condition|(
name|mdev
operator|->
name|mthca_flags
operator|&
name|MTHCA_FLAG_SRQ
condition|)
block|{
name|mdev
operator|->
name|srq_table
operator|.
name|table
operator|=
name|mthca_alloc_icm_table
argument_list|(
name|mdev
argument_list|,
name|init_hca
operator|->
name|srqc_base
argument_list|,
name|dev_lim
operator|->
name|srq_entry_sz
argument_list|,
name|mdev
operator|->
name|limits
operator|.
name|num_srqs
argument_list|,
name|mdev
operator|->
name|limits
operator|.
name|reserved_srqs
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mdev
operator|->
name|srq_table
operator|.
name|table
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"Failed to map SRQ context memory, "
literal|"aborting.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_unmap_cq
goto|;
block|}
block|}
comment|/* 	 * It's not strictly required, but for simplicity just map the 	 * whole multicast group table now.  The table isn't very big 	 * and it's a lot easier than trying to track ref counts. 	 */
name|mdev
operator|->
name|mcg_table
operator|.
name|table
operator|=
name|mthca_alloc_icm_table
argument_list|(
name|mdev
argument_list|,
name|init_hca
operator|->
name|mc_base
argument_list|,
name|MTHCA_MGM_ENTRY_SIZE
argument_list|,
name|mdev
operator|->
name|limits
operator|.
name|num_mgms
operator|+
name|mdev
operator|->
name|limits
operator|.
name|num_amgms
argument_list|,
name|mdev
operator|->
name|limits
operator|.
name|num_mgms
operator|+
name|mdev
operator|->
name|limits
operator|.
name|num_amgms
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mdev
operator|->
name|mcg_table
operator|.
name|table
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"Failed to map MCG context memory, aborting.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_unmap_srq
goto|;
block|}
return|return
literal|0
return|;
name|err_unmap_srq
label|:
if|if
condition|(
name|mdev
operator|->
name|mthca_flags
operator|&
name|MTHCA_FLAG_SRQ
condition|)
name|mthca_free_icm_table
argument_list|(
name|mdev
argument_list|,
name|mdev
operator|->
name|srq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|err_unmap_cq
label|:
name|mthca_free_icm_table
argument_list|(
name|mdev
argument_list|,
name|mdev
operator|->
name|cq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|err_unmap_rdb
label|:
name|mthca_free_icm_table
argument_list|(
name|mdev
argument_list|,
name|mdev
operator|->
name|qp_table
operator|.
name|rdb_table
argument_list|)
expr_stmt|;
name|err_unmap_eqp
label|:
name|mthca_free_icm_table
argument_list|(
name|mdev
argument_list|,
name|mdev
operator|->
name|qp_table
operator|.
name|eqp_table
argument_list|)
expr_stmt|;
name|err_unmap_qp
label|:
name|mthca_free_icm_table
argument_list|(
name|mdev
argument_list|,
name|mdev
operator|->
name|qp_table
operator|.
name|qp_table
argument_list|)
expr_stmt|;
name|err_unmap_mpt
label|:
name|mthca_free_icm_table
argument_list|(
name|mdev
argument_list|,
name|mdev
operator|->
name|mr_table
operator|.
name|mpt_table
argument_list|)
expr_stmt|;
name|err_unmap_mtt
label|:
name|mthca_free_icm_table
argument_list|(
name|mdev
argument_list|,
name|mdev
operator|->
name|mr_table
operator|.
name|mtt_table
argument_list|)
expr_stmt|;
name|err_unmap_eq
label|:
name|mthca_unmap_eq_icm
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|err_unmap_aux
label|:
name|mthca_UNMAP_ICM_AUX
argument_list|(
name|mdev
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|err_free_aux
label|:
name|mthca_free_icm
argument_list|(
name|mdev
argument_list|,
name|mdev
operator|->
name|fw
operator|.
name|arbel
operator|.
name|aux_icm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mthca_free_icms
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|mdev
parameter_list|)
block|{
name|u8
name|status
decl_stmt|;
name|mthca_free_icm_table
argument_list|(
name|mdev
argument_list|,
name|mdev
operator|->
name|mcg_table
operator|.
name|table
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdev
operator|->
name|mthca_flags
operator|&
name|MTHCA_FLAG_SRQ
condition|)
name|mthca_free_icm_table
argument_list|(
name|mdev
argument_list|,
name|mdev
operator|->
name|srq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|mthca_free_icm_table
argument_list|(
name|mdev
argument_list|,
name|mdev
operator|->
name|cq_table
operator|.
name|table
argument_list|)
expr_stmt|;
name|mthca_free_icm_table
argument_list|(
name|mdev
argument_list|,
name|mdev
operator|->
name|qp_table
operator|.
name|rdb_table
argument_list|)
expr_stmt|;
name|mthca_free_icm_table
argument_list|(
name|mdev
argument_list|,
name|mdev
operator|->
name|qp_table
operator|.
name|eqp_table
argument_list|)
expr_stmt|;
name|mthca_free_icm_table
argument_list|(
name|mdev
argument_list|,
name|mdev
operator|->
name|qp_table
operator|.
name|qp_table
argument_list|)
expr_stmt|;
name|mthca_free_icm_table
argument_list|(
name|mdev
argument_list|,
name|mdev
operator|->
name|mr_table
operator|.
name|mpt_table
argument_list|)
expr_stmt|;
name|mthca_free_icm_table
argument_list|(
name|mdev
argument_list|,
name|mdev
operator|->
name|mr_table
operator|.
name|mtt_table
argument_list|)
expr_stmt|;
name|mthca_unmap_eq_icm
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mthca_UNMAP_ICM_AUX
argument_list|(
name|mdev
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|mthca_free_icm
argument_list|(
name|mdev
argument_list|,
name|mdev
operator|->
name|fw
operator|.
name|arbel
operator|.
name|aux_icm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mthca_init_arbel
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|mdev
parameter_list|)
block|{
name|struct
name|mthca_dev_lim
name|dev_lim
decl_stmt|;
name|struct
name|mthca_profile
name|profile
decl_stmt|;
name|struct
name|mthca_init_hca_param
name|init_hca
decl_stmt|;
name|s64
name|icm_size
decl_stmt|;
name|u8
name|status
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|mthca_QUERY_FW
argument_list|(
name|mdev
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"QUERY_FW command failed, aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|status
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"QUERY_FW returned status 0x%02x, "
literal|"aborting.\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|err
operator|=
name|mthca_ENABLE_LAM
argument_list|(
name|mdev
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"ENABLE_LAM command failed, aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|status
operator|==
name|MTHCA_CMD_STAT_LAM_NOT_PRE
condition|)
block|{
name|mthca_dbg
argument_list|(
name|mdev
argument_list|,
literal|"No HCA-attached memory (running in MemFree mode)\n"
argument_list|)
expr_stmt|;
name|mdev
operator|->
name|mthca_flags
operator||=
name|MTHCA_FLAG_NO_LAM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"ENABLE_LAM returned status 0x%02x, "
literal|"aborting.\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
return|return
operator|-
name|EINVAL
return|;
block|}
name|err
operator|=
name|mthca_load_fw
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"Failed to start FW, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_disable
goto|;
block|}
name|err
operator|=
name|mthca_dev_lim
argument_list|(
name|mdev
argument_list|,
operator|&
name|dev_lim
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"QUERY_DEV_LIM command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_stop_fw
goto|;
block|}
name|profile
operator|=
name|hca_profile
expr_stmt|;
name|profile
operator|.
name|num_uar
operator|=
name|dev_lim
operator|.
name|uar_size
operator|/
name|PAGE_SIZE
expr_stmt|;
name|profile
operator|.
name|num_udav
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mdev
operator|->
name|mthca_flags
operator|&
name|MTHCA_FLAG_SRQ
condition|)
name|profile
operator|.
name|num_srq
operator|=
name|dev_lim
operator|.
name|max_srqs
expr_stmt|;
name|icm_size
operator|=
name|mthca_make_profile
argument_list|(
name|mdev
argument_list|,
operator|&
name|profile
argument_list|,
operator|&
name|dev_lim
argument_list|,
operator|&
name|init_hca
argument_list|)
expr_stmt|;
if|if
condition|(
name|icm_size
operator|<
literal|0
condition|)
block|{
name|err
operator|=
name|icm_size
expr_stmt|;
goto|goto
name|err_stop_fw
goto|;
block|}
name|err
operator|=
name|mthca_init_icm
argument_list|(
name|mdev
argument_list|,
operator|&
name|dev_lim
argument_list|,
operator|&
name|init_hca
argument_list|,
name|icm_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_stop_fw
goto|;
name|err
operator|=
name|mthca_INIT_HCA
argument_list|(
name|mdev
argument_list|,
operator|&
name|init_hca
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"INIT_HCA command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free_icm
goto|;
block|}
if|if
condition|(
name|status
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"INIT_HCA returned status 0x%02x, "
literal|"aborting.\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_free_icm
goto|;
block|}
return|return
literal|0
return|;
name|err_free_icm
label|:
name|mthca_free_icms
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|err_stop_fw
label|:
name|mthca_UNMAP_FA
argument_list|(
name|mdev
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|mthca_free_icm
argument_list|(
name|mdev
argument_list|,
name|mdev
operator|->
name|fw
operator|.
name|arbel
operator|.
name|fw_icm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err_disable
label|:
if|if
condition|(
operator|!
operator|(
name|mdev
operator|->
name|mthca_flags
operator|&
name|MTHCA_FLAG_NO_LAM
operator|)
condition|)
name|mthca_DISABLE_LAM
argument_list|(
name|mdev
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mthca_close_hca
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|mdev
parameter_list|)
block|{
name|u8
name|status
decl_stmt|;
name|mthca_CLOSE_HCA
argument_list|(
name|mdev
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|mthca_is_memfree
argument_list|(
name|mdev
argument_list|)
condition|)
block|{
name|mthca_free_icms
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mthca_UNMAP_FA
argument_list|(
name|mdev
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|mthca_free_icm
argument_list|(
name|mdev
argument_list|,
name|mdev
operator|->
name|fw
operator|.
name|arbel
operator|.
name|fw_icm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mdev
operator|->
name|mthca_flags
operator|&
name|MTHCA_FLAG_NO_LAM
operator|)
condition|)
name|mthca_DISABLE_LAM
argument_list|(
name|mdev
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
else|else
name|mthca_SYS_DIS
argument_list|(
name|mdev
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mthca_init_hca
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|mdev
parameter_list|)
block|{
name|u8
name|status
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|mthca_adapter
name|adapter
decl_stmt|;
if|if
condition|(
name|mthca_is_memfree
argument_list|(
name|mdev
argument_list|)
condition|)
name|err
operator|=
name|mthca_init_arbel
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|mthca_init_tavor
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
name|err
operator|=
name|mthca_QUERY_ADAPTER
argument_list|(
name|mdev
argument_list|,
operator|&
name|adapter
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"QUERY_ADAPTER command failed, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_close
goto|;
block|}
if|if
condition|(
name|status
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"QUERY_ADAPTER returned status 0x%02x, "
literal|"aborting.\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_close
goto|;
block|}
name|mdev
operator|->
name|eq_table
operator|.
name|inta_pin
operator|=
name|adapter
operator|.
name|inta_pin
expr_stmt|;
if|if
condition|(
operator|!
name|mthca_is_memfree
argument_list|(
name|mdev
argument_list|)
condition|)
name|mdev
operator|->
name|rev_id
operator|=
name|adapter
operator|.
name|revision_id
expr_stmt|;
name|memcpy
argument_list|(
name|mdev
operator|->
name|board_id
argument_list|,
name|adapter
operator|.
name|board_id
argument_list|,
sizeof|sizeof
name|mdev
operator|->
name|board_id
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_close
label|:
name|mthca_close_hca
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mthca_setup_hca
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|u8
name|status
decl_stmt|;
name|MTHCA_INIT_DOORBELL_LOCK
argument_list|(
operator|&
name|dev
operator|->
name|doorbell_lock
argument_list|)
expr_stmt|;
name|err
operator|=
name|mthca_init_uar_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"user access region table, aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|mthca_uar_alloc
argument_list|(
name|dev
argument_list|,
operator|&
name|dev
operator|->
name|driver_uar
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to allocate driver access region, "
literal|"aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_uar_table_free
goto|;
block|}
name|dev
operator|->
name|kar
operator|=
name|ioremap
argument_list|(
name|dev
operator|->
name|driver_uar
operator|.
name|pfn
operator|<<
name|PAGE_SHIFT
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|kar
condition|)
block|{
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"Couldn't map kernel access region, "
literal|"aborting.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_uar_free
goto|;
block|}
name|err
operator|=
name|mthca_init_pd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"protection domain table, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_kar_unmap
goto|;
block|}
name|err
operator|=
name|mthca_init_mr_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"memory region table, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_pd_table_free
goto|;
block|}
name|err
operator|=
name|mthca_pd_alloc
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|,
operator|&
name|dev
operator|->
name|driver_pd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to create driver PD, "
literal|"aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_mr_table_free
goto|;
block|}
name|err
operator|=
name|mthca_init_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"event queue table, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_pd_free
goto|;
block|}
name|err
operator|=
name|mthca_cmd_use_events
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to switch to event-driven "
literal|"firmware commands, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_eq_table_free
goto|;
block|}
name|err
operator|=
name|mthca_NOP
argument_list|(
name|dev
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|status
condition|)
block|{
if|if
condition|(
name|dev
operator|->
name|mthca_flags
operator|&
name|MTHCA_FLAG_MSI_X
condition|)
block|{
name|mthca_warn
argument_list|(
name|dev
argument_list|,
literal|"NOP command failed to generate interrupt "
literal|"(IRQ %d).\n"
argument_list|,
name|dev
operator|->
name|eq_table
operator|.
name|eq
index|[
name|MTHCA_EQ_CMD
index|]
operator|.
name|msi_x_vector
argument_list|)
expr_stmt|;
name|mthca_warn
argument_list|(
name|dev
argument_list|,
literal|"Trying again with MSI-X disabled.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"NOP command failed to generate interrupt "
literal|"(IRQ %d), aborting.\n"
argument_list|,
name|dev
operator|->
name|pdev
operator|->
name|irq
argument_list|)
expr_stmt|;
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"BIOS or ACPI interrupt routing problem?\n"
argument_list|)
expr_stmt|;
block|}
goto|goto
name|err_cmd_poll
goto|;
block|}
name|mthca_dbg
argument_list|(
name|dev
argument_list|,
literal|"NOP command IRQ test passed\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|mthca_init_cq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"completion queue table, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_cmd_poll
goto|;
block|}
name|err
operator|=
name|mthca_init_srq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"shared receive queue table, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_cq_table_free
goto|;
block|}
name|err
operator|=
name|mthca_init_qp_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"queue pair table, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_srq_table_free
goto|;
block|}
name|err
operator|=
name|mthca_init_av_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"address vector table, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_qp_table_free
goto|;
block|}
name|err
operator|=
name|mthca_init_mcg_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"Failed to initialize "
literal|"multicast group table, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_av_table_free
goto|;
block|}
return|return
literal|0
return|;
name|err_av_table_free
label|:
name|mthca_cleanup_av_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_qp_table_free
label|:
name|mthca_cleanup_qp_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_srq_table_free
label|:
name|mthca_cleanup_srq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_cq_table_free
label|:
name|mthca_cleanup_cq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_cmd_poll
label|:
name|mthca_cmd_use_polling
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_eq_table_free
label|:
name|mthca_cleanup_eq_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_pd_free
label|:
name|mthca_pd_free
argument_list|(
name|dev
argument_list|,
operator|&
name|dev
operator|->
name|driver_pd
argument_list|)
expr_stmt|;
name|err_mr_table_free
label|:
name|mthca_cleanup_mr_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_pd_table_free
label|:
name|mthca_cleanup_pd_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|err_kar_unmap
label|:
name|iounmap
argument_list|(
name|dev
operator|->
name|kar
argument_list|)
expr_stmt|;
name|err_uar_free
label|:
name|mthca_uar_free
argument_list|(
name|dev
argument_list|,
operator|&
name|dev
operator|->
name|driver_uar
argument_list|)
expr_stmt|;
name|err_uar_table_free
label|:
name|mthca_cleanup_uar_table
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mthca_enable_msi_x
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|mdev
parameter_list|)
block|{
name|struct
name|msix_entry
name|entries
index|[
literal|3
index|]
decl_stmt|;
name|int
name|err
decl_stmt|;
name|entries
index|[
literal|0
index|]
operator|.
name|entry
operator|=
literal|0
expr_stmt|;
name|entries
index|[
literal|1
index|]
operator|.
name|entry
operator|=
literal|1
expr_stmt|;
name|entries
index|[
literal|2
index|]
operator|.
name|entry
operator|=
literal|2
expr_stmt|;
name|err
operator|=
name|pci_enable_msix
argument_list|(
name|mdev
operator|->
name|pdev
argument_list|,
name|entries
argument_list|,
name|ARRAY_SIZE
argument_list|(
name|entries
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|>
literal|0
condition|)
name|mthca_info
argument_list|(
name|mdev
argument_list|,
literal|"Only %d MSI-X vectors available, "
literal|"not using MSI-X\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|mdev
operator|->
name|eq_table
operator|.
name|eq
index|[
name|MTHCA_EQ_COMP
index|]
operator|.
name|msi_x_vector
operator|=
name|entries
index|[
literal|0
index|]
operator|.
name|vector
expr_stmt|;
name|mdev
operator|->
name|eq_table
operator|.
name|eq
index|[
name|MTHCA_EQ_ASYNC
index|]
operator|.
name|msi_x_vector
operator|=
name|entries
index|[
literal|1
index|]
operator|.
name|vector
expr_stmt|;
name|mdev
operator|->
name|eq_table
operator|.
name|eq
index|[
name|MTHCA_EQ_CMD
index|]
operator|.
name|msi_x_vector
operator|=
name|entries
index|[
literal|2
index|]
operator|.
name|vector
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Types of supported HCA */
end_comment

begin_enum
enum|enum
block|{
name|TAVOR
block|,
comment|/* MT23108                        */
name|ARBEL_COMPAT
block|,
comment|/* MT25208 in Tavor compat mode   */
name|ARBEL_NATIVE
block|,
comment|/* MT25208 with extended features */
name|SINAI
comment|/* MT25204 */
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|MTHCA_FW_VER
parameter_list|(
name|major
parameter_list|,
name|minor
parameter_list|,
name|subminor
parameter_list|)
define|\
value|(((u64) (major)<< 32) | ((u64) (minor)<< 16) | (u64) (subminor))
end_define

begin_struct
specifier|static
struct|struct
block|{
name|u64
name|latest_fw
decl_stmt|;
name|u32
name|flags
decl_stmt|;
block|}
name|mthca_hca_table
index|[]
init|=
block|{
index|[
name|TAVOR
index|]
operator|=
block|{
operator|.
name|latest_fw
operator|=
name|MTHCA_FW_VER
argument_list|(
literal|3
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
block|,
operator|.
name|flags
operator|=
literal|0
block|}
block|,
index|[
name|ARBEL_COMPAT
index|]
operator|=
block|{
operator|.
name|latest_fw
operator|=
name|MTHCA_FW_VER
argument_list|(
literal|4
argument_list|,
literal|8
argument_list|,
literal|200
argument_list|)
block|,
operator|.
name|flags
operator|=
name|MTHCA_FLAG_PCIE
block|}
block|,
index|[
name|ARBEL_NATIVE
index|]
operator|=
block|{
operator|.
name|latest_fw
operator|=
name|MTHCA_FW_VER
argument_list|(
literal|5
argument_list|,
literal|3
argument_list|,
literal|0
argument_list|)
block|,
operator|.
name|flags
operator|=
name|MTHCA_FLAG_MEMFREE
operator||
name|MTHCA_FLAG_PCIE
block|}
block|,
index|[
name|SINAI
index|]
operator|=
block|{
operator|.
name|latest_fw
operator|=
name|MTHCA_FW_VER
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
block|,
operator|.
name|flags
operator|=
name|MTHCA_FLAG_MEMFREE
operator||
name|MTHCA_FLAG_PCIE
operator||
name|MTHCA_FLAG_SINAI_OPT
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|__mthca_init_one
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|int
name|hca_type
parameter_list|)
block|{
name|int
name|ddr_hidden
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|mthca_dev
modifier|*
name|mdev
decl_stmt|;
name|printk
argument_list|(
argument|KERN_INFO PFX
literal|"Initializing %s\n"
argument_list|,
argument|pci_name(pdev)
argument_list|)
empty_stmt|;
name|err
operator|=
name|pci_enable_device
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Cannot enable PCI device, "
literal|"aborting.\n"
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* 	 * Check for BARs.  We expect 0: 1MB, 2: 8MB, 4: DDR (may not 	 * be present) 	 */
if|if
condition|(
operator|!
operator|(
name|pci_resource_flags
argument_list|(
name|pdev
argument_list|,
literal|0
argument_list|)
operator|&
name|IORESOURCE_MEM
operator|)
operator|||
name|pci_resource_len
argument_list|(
name|pdev
argument_list|,
literal|0
argument_list|)
operator|!=
literal|1
operator|<<
literal|20
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Missing DCS, aborting.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|err_disable_pdev
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|pci_resource_flags
argument_list|(
name|pdev
argument_list|,
literal|2
argument_list|)
operator|&
name|IORESOURCE_MEM
operator|)
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Missing UAR, aborting.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENODEV
expr_stmt|;
goto|goto
name|err_disable_pdev
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|pci_resource_flags
argument_list|(
name|pdev
argument_list|,
literal|4
argument_list|)
operator|&
name|IORESOURCE_MEM
operator|)
condition|)
name|ddr_hidden
operator|=
literal|1
expr_stmt|;
name|err
operator|=
name|pci_request_regions
argument_list|(
name|pdev
argument_list|,
name|DRV_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Cannot obtain PCI resources, "
literal|"aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_disable_pdev
goto|;
block|}
name|pci_set_master
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|err
operator|=
name|pci_set_dma_mask
argument_list|(
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|64
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_warn
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Warning: couldn't set 64-bit PCI DMA mask.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|pci_set_dma_mask
argument_list|(
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Can't set PCI DMA mask, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free_res
goto|;
block|}
block|}
name|err
operator|=
name|pci_set_consistent_dma_mask
argument_list|(
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|64
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_warn
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Warning: couldn't set 64-bit "
literal|"consistent PCI DMA mask.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|pci_set_consistent_dma_mask
argument_list|(
name|pdev
argument_list|,
name|DMA_BIT_MASK
argument_list|(
literal|32
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Can't set consistent PCI DMA mask, "
literal|"aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free_res
goto|;
block|}
block|}
name|mdev
operator|=
operator|(
expr|struct
name|mthca_dev
operator|*
operator|)
name|ib_alloc_device
argument_list|(
sizeof|sizeof
expr|*
name|mdev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mdev
condition|)
block|{
name|dev_err
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
literal|"Device struct alloc failed, "
literal|"aborting.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_free_res
goto|;
block|}
name|mdev
operator|->
name|pdev
operator|=
name|pdev
expr_stmt|;
name|mdev
operator|->
name|mthca_flags
operator|=
name|mthca_hca_table
index|[
name|hca_type
index|]
operator|.
name|flags
expr_stmt|;
if|if
condition|(
name|ddr_hidden
condition|)
name|mdev
operator|->
name|mthca_flags
operator||=
name|MTHCA_FLAG_DDR_HIDDEN
expr_stmt|;
comment|/* 	 * Now reset the HCA before we touch the PCI capabilities or 	 * attempt a firmware command, since a boot ROM may have left 	 * the HCA in an undefined state. 	 */
name|err
operator|=
name|mthca_reset
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"Failed to reset HCA, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free_dev
goto|;
block|}
if|if
condition|(
name|mthca_cmd_init
argument_list|(
name|mdev
argument_list|)
condition|)
block|{
name|mthca_err
argument_list|(
name|mdev
argument_list|,
literal|"Failed to init command interface, aborting.\n"
argument_list|)
expr_stmt|;
goto|goto
name|err_free_dev
goto|;
block|}
name|err
operator|=
name|mthca_tune_pci
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_cmd
goto|;
name|err
operator|=
name|mthca_init_hca
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_cmd
goto|;
if|if
condition|(
name|mdev
operator|->
name|fw_ver
operator|<
name|mthca_hca_table
index|[
name|hca_type
index|]
operator|.
name|latest_fw
condition|)
block|{
name|mthca_warn
argument_list|(
name|mdev
argument_list|,
literal|"HCA FW version %d.%d.%03d is old (%d.%d.%03d is current).\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|mdev
operator|->
name|fw_ver
operator|>>
literal|32
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|mdev
operator|->
name|fw_ver
operator|>>
literal|16
argument_list|)
operator|&
literal|0xffff
argument_list|,
call|(
name|int
call|)
argument_list|(
name|mdev
operator|->
name|fw_ver
operator|&
literal|0xffff
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|mthca_hca_table
index|[
name|hca_type
index|]
operator|.
name|latest_fw
operator|>>
literal|32
argument_list|)
argument_list|,
call|(
name|int
call|)
argument_list|(
name|mthca_hca_table
index|[
name|hca_type
index|]
operator|.
name|latest_fw
operator|>>
literal|16
argument_list|)
operator|&
literal|0xffff
argument_list|,
call|(
name|int
call|)
argument_list|(
name|mthca_hca_table
index|[
name|hca_type
index|]
operator|.
name|latest_fw
operator|&
literal|0xffff
argument_list|)
argument_list|)
expr_stmt|;
name|mthca_warn
argument_list|(
name|mdev
argument_list|,
literal|"If you have problems, try updating your HCA FW.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msi_x
operator|&&
operator|!
name|mthca_enable_msi_x
argument_list|(
name|mdev
argument_list|)
condition|)
name|mdev
operator|->
name|mthca_flags
operator||=
name|MTHCA_FLAG_MSI_X
expr_stmt|;
name|err
operator|=
name|mthca_setup_hca
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
operator|-
name|EBUSY
operator|&&
operator|(
name|mdev
operator|->
name|mthca_flags
operator|&
name|MTHCA_FLAG_MSI_X
operator|)
condition|)
block|{
if|if
condition|(
name|mdev
operator|->
name|mthca_flags
operator|&
name|MTHCA_FLAG_MSI_X
condition|)
name|pci_disable_msix
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|mdev
operator|->
name|mthca_flags
operator|&=
operator|~
name|MTHCA_FLAG_MSI_X
expr_stmt|;
name|err
operator|=
name|mthca_setup_hca
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
goto|goto
name|err_close
goto|;
name|err
operator|=
name|mthca_register_device
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_cleanup
goto|;
name|err
operator|=
name|mthca_create_agents
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_unregister
goto|;
name|pci_set_drvdata
argument_list|(
name|pdev
argument_list|,
name|mdev
argument_list|)
expr_stmt|;
name|mdev
operator|->
name|hca_type
operator|=
name|hca_type
expr_stmt|;
name|mdev
operator|->
name|active
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
name|err_unregister
label|:
name|mthca_unregister_device
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|err_cleanup
label|:
name|mthca_cleanup_mcg_table
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mthca_cleanup_av_table
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mthca_cleanup_qp_table
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mthca_cleanup_srq_table
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mthca_cleanup_cq_table
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mthca_cmd_use_polling
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mthca_cleanup_eq_table
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mthca_pd_free
argument_list|(
name|mdev
argument_list|,
operator|&
name|mdev
operator|->
name|driver_pd
argument_list|)
expr_stmt|;
name|mthca_cleanup_mr_table
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mthca_cleanup_pd_table
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mthca_cleanup_uar_table
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|err_close
label|:
if|if
condition|(
name|mdev
operator|->
name|mthca_flags
operator|&
name|MTHCA_FLAG_MSI_X
condition|)
name|pci_disable_msix
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|mthca_close_hca
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|err_cmd
label|:
name|mthca_cmd_cleanup
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|err_free_dev
label|:
name|ib_dealloc_device
argument_list|(
operator|&
name|mdev
operator|->
name|ib_dev
argument_list|)
expr_stmt|;
name|err_free_res
label|:
name|pci_release_regions
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|err_disable_pdev
label|:
name|pci_disable_device
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|pci_set_drvdata
argument_list|(
name|pdev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__mthca_remove_one
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|struct
name|mthca_dev
modifier|*
name|mdev
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|u8
name|status
decl_stmt|;
name|int
name|p
decl_stmt|;
if|if
condition|(
name|mdev
condition|)
block|{
name|mthca_free_agents
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mthca_unregister_device
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
literal|1
init|;
name|p
operator|<=
name|mdev
operator|->
name|limits
operator|.
name|num_ports
condition|;
operator|++
name|p
control|)
name|mthca_CLOSE_IB
argument_list|(
name|mdev
argument_list|,
name|p
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|mthca_cleanup_mcg_table
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mthca_cleanup_av_table
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mthca_cleanup_qp_table
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mthca_cleanup_srq_table
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mthca_cleanup_cq_table
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mthca_cmd_use_polling
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mthca_cleanup_eq_table
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mthca_pd_free
argument_list|(
name|mdev
argument_list|,
operator|&
name|mdev
operator|->
name|driver_pd
argument_list|)
expr_stmt|;
name|mthca_cleanup_mr_table
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mthca_cleanup_pd_table
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|iounmap
argument_list|(
name|mdev
operator|->
name|kar
argument_list|)
expr_stmt|;
name|mthca_uar_free
argument_list|(
name|mdev
argument_list|,
operator|&
name|mdev
operator|->
name|driver_uar
argument_list|)
expr_stmt|;
name|mthca_cleanup_uar_table
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mthca_close_hca
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
name|mthca_cmd_cleanup
argument_list|(
name|mdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdev
operator|->
name|mthca_flags
operator|&
name|MTHCA_FLAG_MSI_X
condition|)
name|pci_disable_msix
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|ib_dealloc_device
argument_list|(
operator|&
name|mdev
operator|->
name|ib_dev
argument_list|)
expr_stmt|;
name|pci_release_regions
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|pci_disable_device
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|pci_set_drvdata
argument_list|(
name|pdev
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|__mthca_restart_one
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|struct
name|mthca_dev
modifier|*
name|mdev
decl_stmt|;
name|int
name|hca_type
decl_stmt|;
name|mdev
operator|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mdev
condition|)
return|return
operator|-
name|ENODEV
return|;
name|hca_type
operator|=
name|mdev
operator|->
name|hca_type
expr_stmt|;
name|__mthca_remove_one
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
return|return
name|__mthca_init_one
argument_list|(
name|pdev
argument_list|,
name|hca_type
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__devinit
name|mthca_init_one
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
specifier|const
name|struct
name|pci_device_id
modifier|*
name|id
parameter_list|)
block|{
specifier|static
name|int
name|mthca_version_printed
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|mthca_device_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mthca_version_printed
condition|)
block|{
name|printk
argument_list|(
name|KERN_INFO
literal|"%s"
argument_list|,
name|mthca_version
argument_list|)
expr_stmt|;
operator|++
name|mthca_version_printed
expr_stmt|;
block|}
if|if
condition|(
name|id
operator|->
name|driver_data
operator|>=
name|ARRAY_SIZE
argument_list|(
name|mthca_hca_table
argument_list|)
condition|)
block|{
name|printk
argument_list|(
argument|KERN_ERR PFX
literal|"%s has invalid driver data %jx\n"
argument_list|,
argument|pci_name(pdev)
argument_list|,
argument|(uintmax_t)id->driver_data
argument_list|)
empty_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|mthca_device_mutex
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENODEV
return|;
block|}
name|ret
operator|=
name|__mthca_init_one
argument_list|(
name|pdev
argument_list|,
name|id
operator|->
name|driver_data
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|mthca_device_mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__devexit
name|mthca_remove_one
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|mutex_lock
argument_list|(
operator|&
name|mthca_device_mutex
argument_list|)
expr_stmt|;
name|__mthca_remove_one
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|mthca_device_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|pci_device_id
name|mthca_pci_table
index|[]
init|=
block|{
block|{
name|PCI_DEVICE
argument_list|(
name|PCI_VENDOR_ID_MELLANOX
argument_list|,
name|PCI_DEVICE_ID_MELLANOX_TAVOR
argument_list|)
block|,
operator|.
name|driver_data
operator|=
name|TAVOR
block|}
block|,
block|{
name|PCI_DEVICE
argument_list|(
name|PCI_VENDOR_ID_TOPSPIN
argument_list|,
name|PCI_DEVICE_ID_MELLANOX_TAVOR
argument_list|)
block|,
operator|.
name|driver_data
operator|=
name|TAVOR
block|}
block|,
block|{
name|PCI_DEVICE
argument_list|(
name|PCI_VENDOR_ID_MELLANOX
argument_list|,
name|PCI_DEVICE_ID_MELLANOX_ARBEL_COMPAT
argument_list|)
block|,
operator|.
name|driver_data
operator|=
name|ARBEL_COMPAT
block|}
block|,
block|{
name|PCI_DEVICE
argument_list|(
name|PCI_VENDOR_ID_TOPSPIN
argument_list|,
name|PCI_DEVICE_ID_MELLANOX_ARBEL_COMPAT
argument_list|)
block|,
operator|.
name|driver_data
operator|=
name|ARBEL_COMPAT
block|}
block|,
block|{
name|PCI_DEVICE
argument_list|(
name|PCI_VENDOR_ID_MELLANOX
argument_list|,
name|PCI_DEVICE_ID_MELLANOX_ARBEL
argument_list|)
block|,
operator|.
name|driver_data
operator|=
name|ARBEL_NATIVE
block|}
block|,
block|{
name|PCI_DEVICE
argument_list|(
name|PCI_VENDOR_ID_TOPSPIN
argument_list|,
name|PCI_DEVICE_ID_MELLANOX_ARBEL
argument_list|)
block|,
operator|.
name|driver_data
operator|=
name|ARBEL_NATIVE
block|}
block|,
block|{
name|PCI_DEVICE
argument_list|(
name|PCI_VENDOR_ID_MELLANOX
argument_list|,
name|PCI_DEVICE_ID_MELLANOX_SINAI
argument_list|)
block|,
operator|.
name|driver_data
operator|=
name|SINAI
block|}
block|,
block|{
name|PCI_DEVICE
argument_list|(
name|PCI_VENDOR_ID_TOPSPIN
argument_list|,
name|PCI_DEVICE_ID_MELLANOX_SINAI
argument_list|)
block|,
operator|.
name|driver_data
operator|=
name|SINAI
block|}
block|,
block|{
name|PCI_DEVICE
argument_list|(
name|PCI_VENDOR_ID_MELLANOX
argument_list|,
name|PCI_DEVICE_ID_MELLANOX_SINAI_OLD
argument_list|)
block|,
operator|.
name|driver_data
operator|=
name|SINAI
block|}
block|,
block|{
name|PCI_DEVICE
argument_list|(
name|PCI_VENDOR_ID_TOPSPIN
argument_list|,
name|PCI_DEVICE_ID_MELLANOX_SINAI_OLD
argument_list|)
block|,
operator|.
name|driver_data
operator|=
name|SINAI
block|}
block|,
block|{
literal|0
block|, }
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MODULE_DEVICE_TABLE
argument_list|(
name|pci
argument_list|,
name|mthca_pci_table
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|pci_driver
name|mthca_driver
init|=
block|{
operator|.
name|name
operator|=
name|DRV_NAME
block|,
operator|.
name|id_table
operator|=
name|mthca_pci_table
block|,
operator|.
name|probe
operator|=
name|mthca_init_one
block|,
operator|.
name|remove
operator|=
name|__devexit_p
argument_list|(
argument|mthca_remove_one
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|__init
name|__mthca_check_profile_val
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|pval
parameter_list|,
name|int
name|pval_default
parameter_list|)
block|{
comment|/* value must be positive and power of 2 */
name|int
name|old_pval
init|=
operator|*
name|pval
decl_stmt|;
if|if
condition|(
name|old_pval
operator|<=
literal|0
condition|)
operator|*
name|pval
operator|=
name|pval_default
expr_stmt|;
else|else
operator|*
name|pval
operator|=
name|roundup_pow_of_two
argument_list|(
name|old_pval
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_pval
operator|!=
operator|*
name|pval
condition|)
block|{
name|printk
argument_list|(
argument|KERN_WARNING PFX
literal|"Invalid value %d for %s in module parameter.\n"
argument_list|,
argument|old_pval
argument_list|,
argument|name
argument_list|)
empty_stmt|;
name|printk
argument_list|(
argument|KERN_WARNING PFX
literal|"Corrected %s to %d.\n"
argument_list|,
argument|name
argument_list|,
argument|*pval
argument_list|)
empty_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|mthca_check_profile_val
parameter_list|(
name|name
parameter_list|,
define|default)				\ 	__mthca_check_profile_val(#name,&hca_profile.name, default)
end_define

begin_function
specifier|static
name|void
name|__init
name|mthca_validate_profile
parameter_list|(
name|void
parameter_list|)
block|{
name|mthca_check_profile_val
argument_list|(
name|num_qp
argument_list|,
name|MTHCA_DEFAULT_NUM_QP
argument_list|)
expr_stmt|;
name|mthca_check_profile_val
argument_list|(
name|rdb_per_qp
argument_list|,
name|MTHCA_DEFAULT_RDB_PER_QP
argument_list|)
expr_stmt|;
name|mthca_check_profile_val
argument_list|(
name|num_cq
argument_list|,
name|MTHCA_DEFAULT_NUM_CQ
argument_list|)
expr_stmt|;
name|mthca_check_profile_val
argument_list|(
name|num_mcg
argument_list|,
name|MTHCA_DEFAULT_NUM_MCG
argument_list|)
expr_stmt|;
name|mthca_check_profile_val
argument_list|(
name|num_mpt
argument_list|,
name|MTHCA_DEFAULT_NUM_MPT
argument_list|)
expr_stmt|;
name|mthca_check_profile_val
argument_list|(
name|num_mtt
argument_list|,
name|MTHCA_DEFAULT_NUM_MTT
argument_list|)
expr_stmt|;
name|mthca_check_profile_val
argument_list|(
name|num_udav
argument_list|,
name|MTHCA_DEFAULT_NUM_UDAV
argument_list|)
expr_stmt|;
name|mthca_check_profile_val
argument_list|(
name|fmr_reserved_mtts
argument_list|,
name|MTHCA_DEFAULT_NUM_RESERVED_MTTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|hca_profile
operator|.
name|fmr_reserved_mtts
operator|>=
name|hca_profile
operator|.
name|num_mtt
condition|)
block|{
name|printk
argument_list|(
argument|KERN_WARNING PFX
literal|"Invalid fmr_reserved_mtts module parameter %d.\n"
argument_list|,
argument|hca_profile.fmr_reserved_mtts
argument_list|)
empty_stmt|;
name|printk
argument_list|(
argument|KERN_WARNING PFX
literal|"(Must be smaller than num_mtt %d)\n"
argument_list|,
argument|hca_profile.num_mtt
argument_list|)
empty_stmt|;
name|hca_profile
operator|.
name|fmr_reserved_mtts
operator|=
name|hca_profile
operator|.
name|num_mtt
operator|/
literal|2
expr_stmt|;
name|printk
argument_list|(
argument|KERN_WARNING PFX
literal|"Corrected fmr_reserved_mtts to %d.\n"
argument_list|,
argument|hca_profile.fmr_reserved_mtts
argument_list|)
empty_stmt|;
block|}
if|if
condition|(
name|log_mtts_per_seg
operator|==
literal|0
condition|)
name|log_mtts_per_seg
operator|=
name|ilog2
argument_list|(
name|MTHCA_MTT_SEG_SIZE
operator|/
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|log_mtts_per_seg
operator|<
literal|1
operator|)
operator|||
operator|(
name|log_mtts_per_seg
operator|>
literal|5
operator|)
condition|)
block|{
name|printk
argument_list|(
argument|KERN_WARNING PFX
literal|"bad log_mtts_per_seg (%d). Using default - %d\n"
argument_list|,
argument|log_mtts_per_seg
argument_list|,
argument|ilog2(MTHCA_MTT_SEG_SIZE /
literal|8
argument|)
argument_list|)
empty_stmt|;
name|log_mtts_per_seg
operator|=
name|ilog2
argument_list|(
name|MTHCA_MTT_SEG_SIZE
operator|/
literal|8
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|__init
name|mthca_init
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|mthca_validate_profile
argument_list|()
expr_stmt|;
name|ret
operator|=
name|mthca_catas_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
name|ret
operator|=
name|pci_register_driver
argument_list|(
operator|&
name|mthca_driver
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|mthca_catas_cleanup
argument_list|()
expr_stmt|;
return|return
name|ret
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__exit
name|mthca_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|pci_unregister_driver
argument_list|(
operator|&
name|mthca_driver
argument_list|)
expr_stmt|;
name|mthca_catas_cleanup
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|module_init_order
argument_list|(
name|mthca_init
argument_list|,
name|SI_ORDER_MIDDLE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|module_exit
argument_list|(
name|mthca_cleanup
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

