begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004 Topspin Communications.  All rights reserved.  * Copyright (c) 2005 Mellanox Technologies. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<linux/slab.h>
end_include

begin_include
include|#
directive|include
file|<linux/errno.h>
end_include

begin_include
include|#
directive|include
file|"mthca_dev.h"
end_include

begin_include
include|#
directive|include
file|"mthca_cmd.h"
end_include

begin_include
include|#
directive|include
file|"mthca_memfree.h"
end_include

begin_struct
struct|struct
name|mthca_mtt
block|{
name|struct
name|mthca_buddy
modifier|*
name|buddy
decl_stmt|;
name|int
name|order
decl_stmt|;
name|u32
name|first_seg
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Must be packed because mtt_seg is 64 bits but only aligned to 32 bits.  */
end_comment

begin_struct
struct|struct
name|mthca_mpt_entry
block|{
name|__be32
name|flags
decl_stmt|;
name|__be32
name|page_size
decl_stmt|;
name|__be32
name|key
decl_stmt|;
name|__be32
name|pd
decl_stmt|;
name|__be64
name|start
decl_stmt|;
name|__be64
name|length
decl_stmt|;
name|__be32
name|lkey
decl_stmt|;
name|__be32
name|window_count
decl_stmt|;
name|__be32
name|window_count_limit
decl_stmt|;
name|__be64
name|mtt_seg
decl_stmt|;
name|__be32
name|mtt_sz
decl_stmt|;
comment|/* Arbel only */
name|u32
name|reserved
index|[
literal|2
index|]
decl_stmt|;
block|}
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
struct|;
end_struct

begin_define
define|#
directive|define
name|MTHCA_MPT_FLAG_SW_OWNS
value|(0xfUL<< 28)
end_define

begin_define
define|#
directive|define
name|MTHCA_MPT_FLAG_MIO
value|(1<< 17)
end_define

begin_define
define|#
directive|define
name|MTHCA_MPT_FLAG_BIND_ENABLE
value|(1<< 15)
end_define

begin_define
define|#
directive|define
name|MTHCA_MPT_FLAG_PHYSICAL
value|(1<<  9)
end_define

begin_define
define|#
directive|define
name|MTHCA_MPT_FLAG_REGION
value|(1<<  8)
end_define

begin_define
define|#
directive|define
name|MTHCA_MTT_FLAG_PRESENT
value|1
end_define

begin_define
define|#
directive|define
name|MTHCA_MPT_STATUS_SW
value|0xF0
end_define

begin_define
define|#
directive|define
name|MTHCA_MPT_STATUS_HW
value|0x00
end_define

begin_define
define|#
directive|define
name|SINAI_FMR_KEY_INC
value|0x1000000
end_define

begin_comment
comment|/*  * Buddy allocator for MTT segments (currently not very efficient  * since it doesn't keep a free list and just searches linearly  * through the bitmaps)  */
end_comment

begin_function
specifier|static
name|u32
name|mthca_buddy_alloc
parameter_list|(
name|struct
name|mthca_buddy
modifier|*
name|buddy
parameter_list|,
name|int
name|order
parameter_list|)
block|{
name|int
name|o
decl_stmt|;
name|int
name|m
decl_stmt|;
name|u32
name|seg
decl_stmt|;
name|spin_lock
argument_list|(
operator|&
name|buddy
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|o
operator|=
name|order
init|;
name|o
operator|<=
name|buddy
operator|->
name|max_order
condition|;
operator|++
name|o
control|)
if|if
condition|(
name|buddy
operator|->
name|num_free
index|[
name|o
index|]
condition|)
block|{
name|m
operator|=
literal|1
operator|<<
operator|(
name|buddy
operator|->
name|max_order
operator|-
name|o
operator|)
expr_stmt|;
name|seg
operator|=
name|find_first_bit
argument_list|(
name|buddy
operator|->
name|bits
index|[
name|o
index|]
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|seg
operator|<
name|m
condition|)
goto|goto
name|found
goto|;
block|}
name|spin_unlock
argument_list|(
operator|&
name|buddy
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
name|found
label|:
name|clear_bit
argument_list|(
name|seg
argument_list|,
name|buddy
operator|->
name|bits
index|[
name|o
index|]
argument_list|)
expr_stmt|;
operator|--
name|buddy
operator|->
name|num_free
index|[
name|o
index|]
expr_stmt|;
while|while
condition|(
name|o
operator|>
name|order
condition|)
block|{
operator|--
name|o
expr_stmt|;
name|seg
operator|<<=
literal|1
expr_stmt|;
name|set_bit
argument_list|(
name|seg
operator|^
literal|1
argument_list|,
name|buddy
operator|->
name|bits
index|[
name|o
index|]
argument_list|)
expr_stmt|;
operator|++
name|buddy
operator|->
name|num_free
index|[
name|o
index|]
expr_stmt|;
block|}
name|spin_unlock
argument_list|(
operator|&
name|buddy
operator|->
name|lock
argument_list|)
expr_stmt|;
name|seg
operator|<<=
name|order
expr_stmt|;
return|return
name|seg
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mthca_buddy_free
parameter_list|(
name|struct
name|mthca_buddy
modifier|*
name|buddy
parameter_list|,
name|u32
name|seg
parameter_list|,
name|int
name|order
parameter_list|)
block|{
name|seg
operator|>>=
name|order
expr_stmt|;
name|spin_lock
argument_list|(
operator|&
name|buddy
operator|->
name|lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|test_bit
argument_list|(
name|seg
operator|^
literal|1
argument_list|,
name|buddy
operator|->
name|bits
index|[
name|order
index|]
argument_list|)
condition|)
block|{
name|clear_bit
argument_list|(
name|seg
operator|^
literal|1
argument_list|,
name|buddy
operator|->
name|bits
index|[
name|order
index|]
argument_list|)
expr_stmt|;
operator|--
name|buddy
operator|->
name|num_free
index|[
name|order
index|]
expr_stmt|;
name|seg
operator|>>=
literal|1
expr_stmt|;
operator|++
name|order
expr_stmt|;
block|}
name|set_bit
argument_list|(
name|seg
argument_list|,
name|buddy
operator|->
name|bits
index|[
name|order
index|]
argument_list|)
expr_stmt|;
operator|++
name|buddy
operator|->
name|num_free
index|[
name|order
index|]
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|buddy
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mthca_buddy_init
parameter_list|(
name|struct
name|mthca_buddy
modifier|*
name|buddy
parameter_list|,
name|int
name|max_order
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|buddy
operator|->
name|max_order
operator|=
name|max_order
expr_stmt|;
name|spin_lock_init
argument_list|(
operator|&
name|buddy
operator|->
name|lock
argument_list|)
expr_stmt|;
name|buddy
operator|->
name|bits
operator|=
name|kzalloc
argument_list|(
operator|(
name|buddy
operator|->
name|max_order
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|long
operator|*
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
name|buddy
operator|->
name|num_free
operator|=
name|kzalloc
argument_list|(
operator|(
name|buddy
operator|->
name|max_order
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
operator|*
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buddy
operator|->
name|bits
operator|||
operator|!
name|buddy
operator|->
name|num_free
condition|)
goto|goto
name|err_out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|buddy
operator|->
name|max_order
condition|;
operator|++
name|i
control|)
block|{
name|s
operator|=
name|BITS_TO_LONGS
argument_list|(
literal|1
operator|<<
operator|(
name|buddy
operator|->
name|max_order
operator|-
name|i
operator|)
argument_list|)
expr_stmt|;
name|buddy
operator|->
name|bits
index|[
name|i
index|]
operator|=
name|kmalloc
argument_list|(
name|s
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buddy
operator|->
name|bits
index|[
name|i
index|]
condition|)
goto|goto
name|err_out_free
goto|;
name|bitmap_zero
argument_list|(
name|buddy
operator|->
name|bits
index|[
name|i
index|]
argument_list|,
literal|1
operator|<<
operator|(
name|buddy
operator|->
name|max_order
operator|-
name|i
operator|)
argument_list|)
expr_stmt|;
block|}
name|set_bit
argument_list|(
literal|0
argument_list|,
name|buddy
operator|->
name|bits
index|[
name|buddy
operator|->
name|max_order
index|]
argument_list|)
expr_stmt|;
name|buddy
operator|->
name|num_free
index|[
name|buddy
operator|->
name|max_order
index|]
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
name|err_out_free
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|buddy
operator|->
name|max_order
condition|;
operator|++
name|i
control|)
name|kfree
argument_list|(
name|buddy
operator|->
name|bits
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|err_out
label|:
name|kfree
argument_list|(
name|buddy
operator|->
name|bits
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|buddy
operator|->
name|num_free
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mthca_buddy_cleanup
parameter_list|(
name|struct
name|mthca_buddy
modifier|*
name|buddy
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|buddy
operator|->
name|max_order
condition|;
operator|++
name|i
control|)
name|kfree
argument_list|(
name|buddy
operator|->
name|bits
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|buddy
operator|->
name|bits
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|buddy
operator|->
name|num_free
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u32
name|mthca_alloc_mtt_range
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|int
name|order
parameter_list|,
name|struct
name|mthca_buddy
modifier|*
name|buddy
parameter_list|)
block|{
name|u32
name|seg
init|=
name|mthca_buddy_alloc
argument_list|(
name|buddy
argument_list|,
name|order
argument_list|)
decl_stmt|;
if|if
condition|(
name|seg
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
if|if
condition|(
name|mthca_table_get_range
argument_list|(
name|dev
argument_list|,
name|dev
operator|->
name|mr_table
operator|.
name|mtt_table
argument_list|,
name|seg
argument_list|,
name|seg
operator|+
operator|(
literal|1
operator|<<
name|order
operator|)
operator|-
literal|1
argument_list|)
condition|)
block|{
name|mthca_buddy_free
argument_list|(
name|buddy
argument_list|,
name|seg
argument_list|,
name|order
argument_list|)
expr_stmt|;
name|seg
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|seg
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mthca_mtt
modifier|*
name|__mthca_alloc_mtt
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|int
name|size
parameter_list|,
name|struct
name|mthca_buddy
modifier|*
name|buddy
parameter_list|)
block|{
name|struct
name|mthca_mtt
modifier|*
name|mtt
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|EINVAL
argument_list|)
return|;
name|mtt
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|mtt
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mtt
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|mtt
operator|->
name|buddy
operator|=
name|buddy
expr_stmt|;
name|mtt
operator|->
name|order
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dev
operator|->
name|limits
operator|.
name|mtt_seg_size
operator|/
literal|8
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|<<=
literal|1
control|)
operator|++
name|mtt
operator|->
name|order
expr_stmt|;
name|mtt
operator|->
name|first_seg
operator|=
name|mthca_alloc_mtt_range
argument_list|(
name|dev
argument_list|,
name|mtt
operator|->
name|order
argument_list|,
name|buddy
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtt
operator|->
name|first_seg
operator|==
operator|-
literal|1
condition|)
block|{
name|kfree
argument_list|(
name|mtt
argument_list|)
expr_stmt|;
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
block|}
return|return
name|mtt
return|;
block|}
end_function

begin_function
name|struct
name|mthca_mtt
modifier|*
name|mthca_alloc_mtt
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|int
name|size
parameter_list|)
block|{
return|return
name|__mthca_alloc_mtt
argument_list|(
name|dev
argument_list|,
name|size
argument_list|,
operator|&
name|dev
operator|->
name|mr_table
operator|.
name|mtt_buddy
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|mthca_free_mtt
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_mtt
modifier|*
name|mtt
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mtt
condition|)
return|return;
name|mthca_buddy_free
argument_list|(
name|mtt
operator|->
name|buddy
argument_list|,
name|mtt
operator|->
name|first_seg
argument_list|,
name|mtt
operator|->
name|order
argument_list|)
expr_stmt|;
name|mthca_table_put_range
argument_list|(
name|dev
argument_list|,
name|dev
operator|->
name|mr_table
operator|.
name|mtt_table
argument_list|,
name|mtt
operator|->
name|first_seg
argument_list|,
name|mtt
operator|->
name|first_seg
operator|+
operator|(
literal|1
operator|<<
name|mtt
operator|->
name|order
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|mtt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|__mthca_write_mtt
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_mtt
modifier|*
name|mtt
parameter_list|,
name|int
name|start_index
parameter_list|,
name|u64
modifier|*
name|buffer_list
parameter_list|,
name|int
name|list_len
parameter_list|)
block|{
name|struct
name|mthca_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|__be64
modifier|*
name|mtt_entry
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|u8
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mailbox
operator|=
name|mthca_alloc_mailbox
argument_list|(
name|dev
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
return|;
name|mtt_entry
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
while|while
condition|(
name|list_len
operator|>
literal|0
condition|)
block|{
name|mtt_entry
index|[
literal|0
index|]
operator|=
name|cpu_to_be64
argument_list|(
name|dev
operator|->
name|mr_table
operator|.
name|mtt_base
operator|+
name|mtt
operator|->
name|first_seg
operator|*
name|dev
operator|->
name|limits
operator|.
name|mtt_seg_size
operator|+
name|start_index
operator|*
literal|8
argument_list|)
expr_stmt|;
name|mtt_entry
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list_len
operator|&&
name|i
operator|<
name|MTHCA_MAILBOX_SIZE
operator|/
literal|8
operator|-
literal|2
condition|;
operator|++
name|i
control|)
name|mtt_entry
index|[
name|i
operator|+
literal|2
index|]
operator|=
name|cpu_to_be64
argument_list|(
name|buffer_list
index|[
name|i
index|]
operator||
name|MTHCA_MTT_FLAG_PRESENT
argument_list|)
expr_stmt|;
comment|/* 		 * If we have an odd number of entries to write, add 		 * one more dummy entry for firmware efficiency. 		 */
if|if
condition|(
name|i
operator|&
literal|1
condition|)
name|mtt_entry
index|[
name|i
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|mthca_WRITE_MTT
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|,
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
operator|~
literal|1
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_warn
argument_list|(
name|dev
argument_list|,
literal|"WRITE_MTT failed (%d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|status
condition|)
block|{
name|mthca_warn
argument_list|(
name|dev
argument_list|,
literal|"WRITE_MTT returned status 0x%02x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|list_len
operator|-=
name|i
expr_stmt|;
name|start_index
operator|+=
name|i
expr_stmt|;
name|buffer_list
operator|+=
name|i
expr_stmt|;
block|}
name|out
label|:
name|mthca_free_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mthca_write_mtt_size
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|mr_table
operator|.
name|fmr_mtt_buddy
operator|!=
operator|&
name|dev
operator|->
name|mr_table
operator|.
name|mtt_buddy
operator|||
operator|!
operator|(
name|dev
operator|->
name|mthca_flags
operator|&
name|MTHCA_FLAG_FMR
operator|)
condition|)
comment|/* 		 * Be friendly to WRITE_MTT command 		 * and leave two empty slots for the 		 * index and reserved fields of the 		 * mailbox. 		 */
return|return
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
operator|-
literal|2
return|;
comment|/* For Arbel, all MTTs must fit in the same page. */
return|return
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|?
operator|(
name|PAGE_SIZE
operator|/
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
operator|)
else|:
literal|0x7ffffff
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mthca_tavor_write_mtt_seg
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_mtt
modifier|*
name|mtt
parameter_list|,
name|int
name|start_index
parameter_list|,
name|u64
modifier|*
name|buffer_list
parameter_list|,
name|int
name|list_len
parameter_list|)
block|{
name|u64
name|__iomem
modifier|*
name|mtts
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mtts
operator|=
name|dev
operator|->
name|mr_table
operator|.
name|tavor_fmr
operator|.
name|mtt_base
operator|+
name|mtt
operator|->
name|first_seg
operator|*
name|dev
operator|->
name|limits
operator|.
name|mtt_seg_size
operator|+
name|start_index
operator|*
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list_len
condition|;
operator|++
name|i
control|)
name|mthca_write64_raw
argument_list|(
name|cpu_to_be64
argument_list|(
name|buffer_list
index|[
name|i
index|]
operator||
name|MTHCA_MTT_FLAG_PRESENT
argument_list|)
argument_list|,
name|mtts
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mthca_arbel_write_mtt_seg
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_mtt
modifier|*
name|mtt
parameter_list|,
name|int
name|start_index
parameter_list|,
name|u64
modifier|*
name|buffer_list
parameter_list|,
name|int
name|list_len
parameter_list|)
block|{
name|__be64
modifier|*
name|mtts
decl_stmt|;
name|dma_addr_t
name|dma_handle
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|s
init|=
name|start_index
operator|*
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
decl_stmt|;
comment|/* For Arbel, all MTTs must fit in the same page. */
name|BUG_ON
argument_list|(
name|s
operator|/
name|PAGE_SIZE
operator|!=
operator|(
name|s
operator|+
name|list_len
operator|*
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
operator|-
literal|1
operator|)
operator|/
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* Require full segments */
name|BUG_ON
argument_list|(
name|s
operator|%
name|dev
operator|->
name|limits
operator|.
name|mtt_seg_size
argument_list|)
expr_stmt|;
name|mtts
operator|=
name|mthca_table_find
argument_list|(
name|dev
operator|->
name|mr_table
operator|.
name|mtt_table
argument_list|,
name|mtt
operator|->
name|first_seg
operator|+
name|s
operator|/
name|dev
operator|->
name|limits
operator|.
name|mtt_seg_size
argument_list|,
operator|&
name|dma_handle
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
operator|!
name|mtts
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list_len
condition|;
operator|++
name|i
control|)
name|mtts
index|[
name|i
index|]
operator|=
name|cpu_to_be64
argument_list|(
name|buffer_list
index|[
name|i
index|]
operator||
name|MTHCA_MTT_FLAG_PRESENT
argument_list|)
expr_stmt|;
name|dma_sync_single
argument_list|(
operator|&
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|dma_handle
argument_list|,
name|list_len
operator|*
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
argument_list|,
name|DMA_TO_DEVICE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mthca_write_mtt
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_mtt
modifier|*
name|mtt
parameter_list|,
name|int
name|start_index
parameter_list|,
name|u64
modifier|*
name|buffer_list
parameter_list|,
name|int
name|list_len
parameter_list|)
block|{
name|int
name|size
init|=
name|mthca_write_mtt_size
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|int
name|chunk
decl_stmt|;
if|if
condition|(
name|dev
operator|->
name|mr_table
operator|.
name|fmr_mtt_buddy
operator|!=
operator|&
name|dev
operator|->
name|mr_table
operator|.
name|mtt_buddy
operator|||
operator|!
operator|(
name|dev
operator|->
name|mthca_flags
operator|&
name|MTHCA_FLAG_FMR
operator|)
condition|)
return|return
name|__mthca_write_mtt
argument_list|(
name|dev
argument_list|,
name|mtt
argument_list|,
name|start_index
argument_list|,
name|buffer_list
argument_list|,
name|list_len
argument_list|)
return|;
while|while
condition|(
name|list_len
operator|>
literal|0
condition|)
block|{
name|chunk
operator|=
name|min
argument_list|(
name|size
argument_list|,
name|list_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
name|mthca_arbel_write_mtt_seg
argument_list|(
name|dev
argument_list|,
name|mtt
argument_list|,
name|start_index
argument_list|,
name|buffer_list
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
else|else
name|mthca_tavor_write_mtt_seg
argument_list|(
name|dev
argument_list|,
name|mtt
argument_list|,
name|start_index
argument_list|,
name|buffer_list
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|list_len
operator|-=
name|chunk
expr_stmt|;
name|start_index
operator|+=
name|chunk
expr_stmt|;
name|buffer_list
operator|+=
name|chunk
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u32
name|tavor_hw_index_to_key
parameter_list|(
name|u32
name|ind
parameter_list|)
block|{
return|return
name|ind
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u32
name|tavor_key_to_hw_index
parameter_list|(
name|u32
name|key
parameter_list|)
block|{
return|return
name|key
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u32
name|arbel_hw_index_to_key
parameter_list|(
name|u32
name|ind
parameter_list|)
block|{
return|return
operator|(
name|ind
operator|>>
literal|24
operator|)
operator||
operator|(
name|ind
operator|<<
literal|8
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u32
name|arbel_key_to_hw_index
parameter_list|(
name|u32
name|key
parameter_list|)
block|{
return|return
operator|(
name|key
operator|<<
literal|24
operator|)
operator||
operator|(
name|key
operator|>>
literal|8
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u32
name|hw_index_to_key
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|ind
parameter_list|)
block|{
if|if
condition|(
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|arbel_hw_index_to_key
argument_list|(
name|ind
argument_list|)
return|;
else|else
return|return
name|tavor_hw_index_to_key
argument_list|(
name|ind
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u32
name|key_to_hw_index
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|key
parameter_list|)
block|{
if|if
condition|(
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|arbel_key_to_hw_index
argument_list|(
name|key
argument_list|)
return|;
else|else
return|return
name|tavor_key_to_hw_index
argument_list|(
name|key
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u32
name|adjust_key
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|key
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|->
name|mthca_flags
operator|&
name|MTHCA_FLAG_SINAI_OPT
condition|)
return|return
operator|(
operator|(
name|key
operator|<<
literal|20
operator|)
operator|&
literal|0x800000
operator|)
operator||
operator|(
name|key
operator|&
literal|0x7fffff
operator|)
return|;
else|else
return|return
name|key
return|;
block|}
end_function

begin_function
name|int
name|mthca_mr_alloc
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|pd
parameter_list|,
name|int
name|buffer_size_shift
parameter_list|,
name|u64
name|iova
parameter_list|,
name|u64
name|total_size
parameter_list|,
name|u32
name|access
parameter_list|,
name|struct
name|mthca_mr
modifier|*
name|mr
parameter_list|)
block|{
name|struct
name|mthca_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|struct
name|mthca_mpt_entry
modifier|*
name|mpt_entry
decl_stmt|;
name|u32
name|key
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|err
decl_stmt|;
name|u8
name|status
decl_stmt|;
name|WARN_ON
argument_list|(
name|buffer_size_shift
operator|>=
literal|32
argument_list|)
expr_stmt|;
name|key
operator|=
name|mthca_alloc
argument_list|(
operator|&
name|dev
operator|->
name|mr_table
operator|.
name|mpt_alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|key
operator|=
name|adjust_key
argument_list|(
name|dev
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|mr
operator|->
name|ibmr
operator|.
name|rkey
operator|=
name|mr
operator|->
name|ibmr
operator|.
name|lkey
operator|=
name|hw_index_to_key
argument_list|(
name|dev
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|err
operator|=
name|mthca_table_get
argument_list|(
name|dev
argument_list|,
name|dev
operator|->
name|mr_table
operator|.
name|mpt_table
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_out_mpt_free
goto|;
block|}
name|mailbox
operator|=
name|mthca_alloc_mailbox
argument_list|(
name|dev
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
block|{
name|err
operator|=
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
expr_stmt|;
goto|goto
name|err_out_table
goto|;
block|}
name|mpt_entry
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|mpt_entry
operator|->
name|flags
operator|=
name|cpu_to_be32
argument_list|(
name|MTHCA_MPT_FLAG_SW_OWNS
operator||
name|MTHCA_MPT_FLAG_MIO
operator||
name|MTHCA_MPT_FLAG_REGION
operator||
name|access
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mr
operator|->
name|mtt
condition|)
name|mpt_entry
operator|->
name|flags
operator||=
name|cpu_to_be32
argument_list|(
name|MTHCA_MPT_FLAG_PHYSICAL
argument_list|)
expr_stmt|;
name|mpt_entry
operator|->
name|page_size
operator|=
name|cpu_to_be32
argument_list|(
name|buffer_size_shift
operator|-
literal|12
argument_list|)
expr_stmt|;
name|mpt_entry
operator|->
name|key
operator|=
name|cpu_to_be32
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|mpt_entry
operator|->
name|pd
operator|=
name|cpu_to_be32
argument_list|(
name|pd
argument_list|)
expr_stmt|;
name|mpt_entry
operator|->
name|start
operator|=
name|cpu_to_be64
argument_list|(
name|iova
argument_list|)
expr_stmt|;
name|mpt_entry
operator|->
name|length
operator|=
name|cpu_to_be64
argument_list|(
name|total_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mpt_entry
operator|->
name|lkey
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|mpt_entry
operator|-
name|offsetof
argument_list|(
expr|struct
name|mthca_mpt_entry
argument_list|,
name|lkey
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mr
operator|->
name|mtt
condition|)
name|mpt_entry
operator|->
name|mtt_seg
operator|=
name|cpu_to_be64
argument_list|(
name|dev
operator|->
name|mr_table
operator|.
name|mtt_base
operator|+
name|mr
operator|->
name|mtt
operator|->
name|first_seg
operator|*
name|dev
operator|->
name|limits
operator|.
name|mtt_seg_size
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
condition|)
block|{
name|mthca_dbg
argument_list|(
name|dev
argument_list|,
literal|"Dumping MPT entry %08x:\n"
argument_list|,
name|mr
operator|->
name|ibmr
operator|.
name|lkey
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_mpt_entry
argument_list|)
operator|/
literal|4
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|4
operator|==
literal|0
condition|)
name|printk
argument_list|(
literal|"[%02x] "
argument_list|,
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|" %08x"
argument_list|,
name|be32_to_cpu
argument_list|(
operator|(
operator|(
name|__be32
operator|*
operator|)
name|mpt_entry
operator|)
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
literal|4
operator|==
literal|0
condition|)
name|printk
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|err
operator|=
name|mthca_SW2HW_MPT
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|,
name|key
operator|&
operator|(
name|dev
operator|->
name|limits
operator|.
name|num_mpts
operator|-
literal|1
operator|)
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_warn
argument_list|(
name|dev
argument_list|,
literal|"SW2HW_MPT failed (%d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_out_mailbox
goto|;
block|}
elseif|else
if|if
condition|(
name|status
condition|)
block|{
name|mthca_warn
argument_list|(
name|dev
argument_list|,
literal|"SW2HW_MPT returned status 0x%02x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_out_mailbox
goto|;
block|}
name|mthca_free_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
name|err
return|;
name|err_out_mailbox
label|:
name|mthca_free_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
name|err_out_table
label|:
name|mthca_table_put
argument_list|(
name|dev
argument_list|,
name|dev
operator|->
name|mr_table
operator|.
name|mpt_table
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|err_out_mpt_free
label|:
name|mthca_free
argument_list|(
operator|&
name|dev
operator|->
name|mr_table
operator|.
name|mpt_alloc
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mthca_mr_alloc_notrans
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|pd
parameter_list|,
name|u32
name|access
parameter_list|,
name|struct
name|mthca_mr
modifier|*
name|mr
parameter_list|)
block|{
name|mr
operator|->
name|mtt
operator|=
name|NULL
expr_stmt|;
return|return
name|mthca_mr_alloc
argument_list|(
name|dev
argument_list|,
name|pd
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|,
operator|~
literal|0ULL
argument_list|,
name|access
argument_list|,
name|mr
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|mthca_mr_alloc_phys
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|pd
parameter_list|,
name|u64
modifier|*
name|buffer_list
parameter_list|,
name|int
name|buffer_size_shift
parameter_list|,
name|int
name|list_len
parameter_list|,
name|u64
name|iova
parameter_list|,
name|u64
name|total_size
parameter_list|,
name|u32
name|access
parameter_list|,
name|struct
name|mthca_mr
modifier|*
name|mr
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|mr
operator|->
name|mtt
operator|=
name|mthca_alloc_mtt
argument_list|(
name|dev
argument_list|,
name|list_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mr
operator|->
name|mtt
argument_list|)
condition|)
return|return
name|PTR_ERR
argument_list|(
name|mr
operator|->
name|mtt
argument_list|)
return|;
name|err
operator|=
name|mthca_write_mtt
argument_list|(
name|dev
argument_list|,
name|mr
operator|->
name|mtt
argument_list|,
literal|0
argument_list|,
name|buffer_list
argument_list|,
name|list_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_free_mtt
argument_list|(
name|dev
argument_list|,
name|mr
operator|->
name|mtt
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
name|err
operator|=
name|mthca_mr_alloc
argument_list|(
name|dev
argument_list|,
name|pd
argument_list|,
name|buffer_size_shift
argument_list|,
name|iova
argument_list|,
name|total_size
argument_list|,
name|access
argument_list|,
name|mr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mthca_free_mtt
argument_list|(
name|dev
argument_list|,
name|mr
operator|->
name|mtt
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Free mr or fmr */
end_comment

begin_function
specifier|static
name|void
name|mthca_free_region
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|lkey
parameter_list|)
block|{
name|mthca_table_put
argument_list|(
name|dev
argument_list|,
name|dev
operator|->
name|mr_table
operator|.
name|mpt_table
argument_list|,
name|key_to_hw_index
argument_list|(
name|dev
argument_list|,
name|lkey
argument_list|)
argument_list|)
expr_stmt|;
name|mthca_free
argument_list|(
operator|&
name|dev
operator|->
name|mr_table
operator|.
name|mpt_alloc
argument_list|,
name|key_to_hw_index
argument_list|(
name|dev
argument_list|,
name|lkey
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mthca_free_mr
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_mr
modifier|*
name|mr
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|u8
name|status
decl_stmt|;
name|err
operator|=
name|mthca_HW2SW_MPT
argument_list|(
name|dev
argument_list|,
name|NULL
argument_list|,
name|key_to_hw_index
argument_list|(
name|dev
argument_list|,
name|mr
operator|->
name|ibmr
operator|.
name|lkey
argument_list|)
operator|&
operator|(
name|dev
operator|->
name|limits
operator|.
name|num_mpts
operator|-
literal|1
operator|)
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|mthca_warn
argument_list|(
name|dev
argument_list|,
literal|"HW2SW_MPT failed (%d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|status
condition|)
name|mthca_warn
argument_list|(
name|dev
argument_list|,
literal|"HW2SW_MPT returned status 0x%02x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|mthca_free_region
argument_list|(
name|dev
argument_list|,
name|mr
operator|->
name|ibmr
operator|.
name|lkey
argument_list|)
expr_stmt|;
name|mthca_free_mtt
argument_list|(
name|dev
argument_list|,
name|mr
operator|->
name|mtt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mthca_fmr_alloc
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|u32
name|pd
parameter_list|,
name|u32
name|access
parameter_list|,
name|struct
name|mthca_fmr
modifier|*
name|mr
parameter_list|)
block|{
name|struct
name|mthca_mpt_entry
modifier|*
name|mpt_entry
decl_stmt|;
name|struct
name|mthca_mailbox
modifier|*
name|mailbox
decl_stmt|;
name|u64
name|mtt_seg
decl_stmt|;
name|u32
name|key
decl_stmt|,
name|idx
decl_stmt|;
name|u8
name|status
decl_stmt|;
name|int
name|list_len
init|=
name|mr
operator|->
name|attr
operator|.
name|max_pages
decl_stmt|;
name|int
name|err
init|=
operator|-
name|ENOMEM
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|mr
operator|->
name|attr
operator|.
name|page_shift
operator|<
literal|12
operator|||
name|mr
operator|->
name|attr
operator|.
name|page_shift
operator|>=
literal|32
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* For Arbel, all MTTs must fit in the same page. */
if|if
condition|(
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
operator|&&
name|mr
operator|->
name|attr
operator|.
name|max_pages
operator|*
sizeof|sizeof
expr|*
name|mr
operator|->
name|mem
operator|.
name|arbel
operator|.
name|mtts
operator|>
name|PAGE_SIZE
condition|)
return|return
operator|-
name|EINVAL
return|;
name|mr
operator|->
name|maps
operator|=
literal|0
expr_stmt|;
name|key
operator|=
name|mthca_alloc
argument_list|(
operator|&
name|dev
operator|->
name|mr_table
operator|.
name|mpt_alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|key
operator|=
name|adjust_key
argument_list|(
name|dev
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|idx
operator|=
name|key
operator|&
operator|(
name|dev
operator|->
name|limits
operator|.
name|num_mpts
operator|-
literal|1
operator|)
expr_stmt|;
name|mr
operator|->
name|ibmr
operator|.
name|rkey
operator|=
name|mr
operator|->
name|ibmr
operator|.
name|lkey
operator|=
name|hw_index_to_key
argument_list|(
name|dev
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|err
operator|=
name|mthca_table_get
argument_list|(
name|dev
argument_list|,
name|dev
operator|->
name|mr_table
operator|.
name|mpt_table
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_out_mpt_free
goto|;
name|mr
operator|->
name|mem
operator|.
name|arbel
operator|.
name|mpt
operator|=
name|mthca_table_find
argument_list|(
name|dev
operator|->
name|mr_table
operator|.
name|mpt_table
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
operator|!
name|mr
operator|->
name|mem
operator|.
name|arbel
operator|.
name|mpt
argument_list|)
expr_stmt|;
block|}
else|else
name|mr
operator|->
name|mem
operator|.
name|tavor
operator|.
name|mpt
operator|=
name|dev
operator|->
name|mr_table
operator|.
name|tavor_fmr
operator|.
name|mpt_base
operator|+
sizeof|sizeof
expr|*
operator|(
name|mr
operator|->
name|mem
operator|.
name|tavor
operator|.
name|mpt
operator|)
operator|*
name|idx
expr_stmt|;
name|mr
operator|->
name|mtt
operator|=
name|__mthca_alloc_mtt
argument_list|(
name|dev
argument_list|,
name|list_len
argument_list|,
name|dev
operator|->
name|mr_table
operator|.
name|fmr_mtt_buddy
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mr
operator|->
name|mtt
argument_list|)
condition|)
block|{
name|err
operator|=
name|PTR_ERR
argument_list|(
name|mr
operator|->
name|mtt
argument_list|)
expr_stmt|;
goto|goto
name|err_out_table
goto|;
block|}
name|mtt_seg
operator|=
name|mr
operator|->
name|mtt
operator|->
name|first_seg
operator|*
name|dev
operator|->
name|limits
operator|.
name|mtt_seg_size
expr_stmt|;
if|if
condition|(
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
block|{
name|mr
operator|->
name|mem
operator|.
name|arbel
operator|.
name|mtts
operator|=
name|mthca_table_find
argument_list|(
name|dev
operator|->
name|mr_table
operator|.
name|mtt_table
argument_list|,
name|mr
operator|->
name|mtt
operator|->
name|first_seg
argument_list|,
operator|&
name|mr
operator|->
name|mem
operator|.
name|arbel
operator|.
name|dma_handle
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
operator|!
name|mr
operator|->
name|mem
operator|.
name|arbel
operator|.
name|mtts
argument_list|)
expr_stmt|;
block|}
else|else
name|mr
operator|->
name|mem
operator|.
name|tavor
operator|.
name|mtts
operator|=
name|dev
operator|->
name|mr_table
operator|.
name|tavor_fmr
operator|.
name|mtt_base
operator|+
name|mtt_seg
expr_stmt|;
name|mailbox
operator|=
name|mthca_alloc_mailbox
argument_list|(
name|dev
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_ERR
argument_list|(
name|mailbox
argument_list|)
condition|)
block|{
name|err
operator|=
name|PTR_ERR
argument_list|(
name|mailbox
argument_list|)
expr_stmt|;
goto|goto
name|err_out_free_mtt
goto|;
block|}
name|mpt_entry
operator|=
name|mailbox
operator|->
name|buf
expr_stmt|;
name|mpt_entry
operator|->
name|flags
operator|=
name|cpu_to_be32
argument_list|(
name|MTHCA_MPT_FLAG_SW_OWNS
operator||
name|MTHCA_MPT_FLAG_MIO
operator||
name|MTHCA_MPT_FLAG_REGION
operator||
name|access
argument_list|)
expr_stmt|;
name|mpt_entry
operator|->
name|page_size
operator|=
name|cpu_to_be32
argument_list|(
name|mr
operator|->
name|attr
operator|.
name|page_shift
operator|-
literal|12
argument_list|)
expr_stmt|;
name|mpt_entry
operator|->
name|key
operator|=
name|cpu_to_be32
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|mpt_entry
operator|->
name|pd
operator|=
name|cpu_to_be32
argument_list|(
name|pd
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mpt_entry
operator|->
name|start
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|mpt_entry
operator|-
name|offsetof
argument_list|(
expr|struct
name|mthca_mpt_entry
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|mpt_entry
operator|->
name|mtt_seg
operator|=
name|cpu_to_be64
argument_list|(
name|dev
operator|->
name|mr_table
operator|.
name|mtt_base
operator|+
name|mtt_seg
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
condition|)
block|{
name|mthca_dbg
argument_list|(
name|dev
argument_list|,
literal|"Dumping MPT entry %08x:\n"
argument_list|,
name|mr
operator|->
name|ibmr
operator|.
name|lkey
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_mpt_entry
argument_list|)
operator|/
literal|4
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|%
literal|4
operator|==
literal|0
condition|)
name|printk
argument_list|(
literal|"[%02x] "
argument_list|,
name|i
operator|*
literal|4
argument_list|)
expr_stmt|;
name|printk
argument_list|(
literal|" %08x"
argument_list|,
name|be32_to_cpu
argument_list|(
operator|(
operator|(
name|__be32
operator|*
operator|)
name|mpt_entry
operator|)
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
literal|4
operator|==
literal|0
condition|)
name|printk
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|err
operator|=
name|mthca_SW2HW_MPT
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|,
name|key
operator|&
operator|(
name|dev
operator|->
name|limits
operator|.
name|num_mpts
operator|-
literal|1
operator|)
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mthca_warn
argument_list|(
name|dev
argument_list|,
literal|"SW2HW_MPT failed (%d)\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|err_out_mailbox_free
goto|;
block|}
if|if
condition|(
name|status
condition|)
block|{
name|mthca_warn
argument_list|(
name|dev
argument_list|,
literal|"SW2HW_MPT returned status 0x%02x\n"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_out_mailbox_free
goto|;
block|}
name|mthca_free_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|err_out_mailbox_free
label|:
name|mthca_free_mailbox
argument_list|(
name|dev
argument_list|,
name|mailbox
argument_list|)
expr_stmt|;
name|err_out_free_mtt
label|:
name|mthca_free_mtt
argument_list|(
name|dev
argument_list|,
name|mr
operator|->
name|mtt
argument_list|)
expr_stmt|;
name|err_out_table
label|:
name|mthca_table_put
argument_list|(
name|dev
argument_list|,
name|dev
operator|->
name|mr_table
operator|.
name|mpt_table
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|err_out_mpt_free
label|:
name|mthca_free
argument_list|(
operator|&
name|dev
operator|->
name|mr_table
operator|.
name|mpt_alloc
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|mthca_free_fmr
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_fmr
modifier|*
name|fmr
parameter_list|)
block|{
if|if
condition|(
name|fmr
operator|->
name|maps
condition|)
return|return
operator|-
name|EBUSY
return|;
name|mthca_free_region
argument_list|(
name|dev
argument_list|,
name|fmr
operator|->
name|ibmr
operator|.
name|lkey
argument_list|)
expr_stmt|;
name|mthca_free_mtt
argument_list|(
name|dev
argument_list|,
name|fmr
operator|->
name|mtt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|mthca_check_fmr
parameter_list|(
name|struct
name|mthca_fmr
modifier|*
name|fmr
parameter_list|,
name|u64
modifier|*
name|page_list
parameter_list|,
name|int
name|list_len
parameter_list|,
name|u64
name|iova
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|page_mask
decl_stmt|;
if|if
condition|(
name|list_len
operator|>
name|fmr
operator|->
name|attr
operator|.
name|max_pages
condition|)
return|return
operator|-
name|EINVAL
return|;
name|page_mask
operator|=
operator|(
literal|1
operator|<<
name|fmr
operator|->
name|attr
operator|.
name|page_shift
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* We are getting page lists, so va must be page aligned. */
if|if
condition|(
name|iova
operator|&
name|page_mask
condition|)
return|return
operator|-
name|EINVAL
return|;
comment|/* Trust the user not to pass misaligned data in page_list */
if|if
condition|(
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list_len
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|page_list
index|[
name|i
index|]
operator|&
operator|~
name|page_mask
condition|)
return|return
operator|-
name|EINVAL
return|;
block|}
if|if
condition|(
name|fmr
operator|->
name|maps
operator|>=
name|fmr
operator|->
name|attr
operator|.
name|max_maps
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mthca_tavor_map_phys_fmr
parameter_list|(
name|struct
name|ib_fmr
modifier|*
name|ibfmr
parameter_list|,
name|u64
modifier|*
name|page_list
parameter_list|,
name|int
name|list_len
parameter_list|,
name|u64
name|iova
parameter_list|)
block|{
name|struct
name|mthca_fmr
modifier|*
name|fmr
init|=
name|to_mfmr
argument_list|(
name|ibfmr
argument_list|)
decl_stmt|;
name|struct
name|mthca_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ibfmr
operator|->
name|device
argument_list|)
decl_stmt|;
name|struct
name|mthca_mpt_entry
name|mpt_entry
decl_stmt|;
name|u32
name|key
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
name|err
operator|=
name|mthca_check_fmr
argument_list|(
name|fmr
argument_list|,
name|page_list
argument_list|,
name|list_len
argument_list|,
name|iova
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
operator|++
name|fmr
operator|->
name|maps
expr_stmt|;
name|key
operator|=
name|tavor_key_to_hw_index
argument_list|(
name|fmr
operator|->
name|ibmr
operator|.
name|lkey
argument_list|)
expr_stmt|;
name|key
operator|+=
name|dev
operator|->
name|limits
operator|.
name|num_mpts
expr_stmt|;
name|fmr
operator|->
name|ibmr
operator|.
name|lkey
operator|=
name|fmr
operator|->
name|ibmr
operator|.
name|rkey
operator|=
name|tavor_hw_index_to_key
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|writeb
argument_list|(
name|MTHCA_MPT_STATUS_SW
argument_list|,
name|fmr
operator|->
name|mem
operator|.
name|tavor
operator|.
name|mpt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list_len
condition|;
operator|++
name|i
control|)
block|{
name|__be64
name|mtt_entry
init|=
name|cpu_to_be64
argument_list|(
name|page_list
index|[
name|i
index|]
operator||
name|MTHCA_MTT_FLAG_PRESENT
argument_list|)
decl_stmt|;
name|mthca_write64_raw
argument_list|(
name|mtt_entry
argument_list|,
name|fmr
operator|->
name|mem
operator|.
name|tavor
operator|.
name|mtts
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|mpt_entry
operator|.
name|lkey
operator|=
name|cpu_to_be32
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|mpt_entry
operator|.
name|length
operator|=
name|cpu_to_be64
argument_list|(
name|list_len
operator|*
operator|(
literal|1ull
operator|<<
name|fmr
operator|->
name|attr
operator|.
name|page_shift
operator|)
argument_list|)
expr_stmt|;
name|mpt_entry
operator|.
name|start
operator|=
name|cpu_to_be64
argument_list|(
name|iova
argument_list|)
expr_stmt|;
name|__raw_writel
argument_list|(
operator|(
name|__force
name|u32
operator|)
name|mpt_entry
operator|.
name|lkey
argument_list|,
operator|&
name|fmr
operator|->
name|mem
operator|.
name|tavor
operator|.
name|mpt
operator|->
name|key
argument_list|)
expr_stmt|;
name|memcpy_toio
argument_list|(
operator|&
name|fmr
operator|->
name|mem
operator|.
name|tavor
operator|.
name|mpt
operator|->
name|start
argument_list|,
operator|&
name|mpt_entry
operator|.
name|start
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|mthca_mpt_entry
argument_list|,
name|window_count
argument_list|)
operator|-
name|offsetof
argument_list|(
expr|struct
name|mthca_mpt_entry
argument_list|,
name|start
argument_list|)
argument_list|)
expr_stmt|;
name|writeb
argument_list|(
name|MTHCA_MPT_STATUS_HW
argument_list|,
name|fmr
operator|->
name|mem
operator|.
name|tavor
operator|.
name|mpt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|mthca_arbel_map_phys_fmr
parameter_list|(
name|struct
name|ib_fmr
modifier|*
name|ibfmr
parameter_list|,
name|u64
modifier|*
name|page_list
parameter_list|,
name|int
name|list_len
parameter_list|,
name|u64
name|iova
parameter_list|)
block|{
name|struct
name|mthca_fmr
modifier|*
name|fmr
init|=
name|to_mfmr
argument_list|(
name|ibfmr
argument_list|)
decl_stmt|;
name|struct
name|mthca_dev
modifier|*
name|dev
init|=
name|to_mdev
argument_list|(
name|ibfmr
operator|->
name|device
argument_list|)
decl_stmt|;
name|u32
name|key
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
name|err
operator|=
name|mthca_check_fmr
argument_list|(
name|fmr
argument_list|,
name|page_list
argument_list|,
name|list_len
argument_list|,
name|iova
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
operator|++
name|fmr
operator|->
name|maps
expr_stmt|;
name|key
operator|=
name|arbel_key_to_hw_index
argument_list|(
name|fmr
operator|->
name|ibmr
operator|.
name|lkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|mthca_flags
operator|&
name|MTHCA_FLAG_SINAI_OPT
condition|)
name|key
operator|+=
name|SINAI_FMR_KEY_INC
expr_stmt|;
else|else
name|key
operator|+=
name|dev
operator|->
name|limits
operator|.
name|num_mpts
expr_stmt|;
name|fmr
operator|->
name|ibmr
operator|.
name|lkey
operator|=
name|fmr
operator|->
name|ibmr
operator|.
name|rkey
operator|=
name|arbel_hw_index_to_key
argument_list|(
name|key
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u8
operator|*
operator|)
name|fmr
operator|->
name|mem
operator|.
name|arbel
operator|.
name|mpt
operator|=
name|MTHCA_MPT_STATUS_SW
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list_len
condition|;
operator|++
name|i
control|)
name|fmr
operator|->
name|mem
operator|.
name|arbel
operator|.
name|mtts
index|[
name|i
index|]
operator|=
name|cpu_to_be64
argument_list|(
name|page_list
index|[
name|i
index|]
operator||
name|MTHCA_MTT_FLAG_PRESENT
argument_list|)
expr_stmt|;
name|dma_sync_single
argument_list|(
operator|&
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|fmr
operator|->
name|mem
operator|.
name|arbel
operator|.
name|dma_handle
argument_list|,
name|list_len
operator|*
sizeof|sizeof
argument_list|(
name|u64
argument_list|)
argument_list|,
name|DMA_TO_DEVICE
argument_list|)
expr_stmt|;
name|fmr
operator|->
name|mem
operator|.
name|arbel
operator|.
name|mpt
operator|->
name|key
operator|=
name|cpu_to_be32
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|fmr
operator|->
name|mem
operator|.
name|arbel
operator|.
name|mpt
operator|->
name|lkey
operator|=
name|cpu_to_be32
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|fmr
operator|->
name|mem
operator|.
name|arbel
operator|.
name|mpt
operator|->
name|length
operator|=
name|cpu_to_be64
argument_list|(
name|list_len
operator|*
operator|(
literal|1ull
operator|<<
name|fmr
operator|->
name|attr
operator|.
name|page_shift
operator|)
argument_list|)
expr_stmt|;
name|fmr
operator|->
name|mem
operator|.
name|arbel
operator|.
name|mpt
operator|->
name|start
operator|=
name|cpu_to_be64
argument_list|(
name|iova
argument_list|)
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
operator|*
operator|(
name|u8
operator|*
operator|)
name|fmr
operator|->
name|mem
operator|.
name|arbel
operator|.
name|mpt
operator|=
name|MTHCA_MPT_STATUS_HW
expr_stmt|;
name|wmb
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|mthca_tavor_fmr_unmap
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_fmr
modifier|*
name|fmr
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fmr
operator|->
name|maps
condition|)
return|return;
name|fmr
operator|->
name|maps
operator|=
literal|0
expr_stmt|;
name|writeb
argument_list|(
name|MTHCA_MPT_STATUS_SW
argument_list|,
name|fmr
operator|->
name|mem
operator|.
name|tavor
operator|.
name|mpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mthca_arbel_fmr_unmap
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_fmr
modifier|*
name|fmr
parameter_list|)
block|{
if|if
condition|(
operator|!
name|fmr
operator|->
name|maps
condition|)
return|return;
name|fmr
operator|->
name|maps
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|u8
operator|*
operator|)
name|fmr
operator|->
name|mem
operator|.
name|arbel
operator|.
name|mpt
operator|=
name|MTHCA_MPT_STATUS_SW
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mthca_init_mr_table
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|)
block|{
name|unsigned
name|long
name|addr
decl_stmt|;
name|int
name|mpts
decl_stmt|,
name|mtts
decl_stmt|,
name|err
decl_stmt|,
name|i
decl_stmt|;
name|err
operator|=
name|mthca_alloc_init
argument_list|(
operator|&
name|dev
operator|->
name|mr_table
operator|.
name|mpt_alloc
argument_list|,
name|dev
operator|->
name|limits
operator|.
name|num_mpts
argument_list|,
operator|~
literal|0
argument_list|,
name|dev
operator|->
name|limits
operator|.
name|reserved_mrws
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
if|if
condition|(
operator|!
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|dev
operator|->
name|mthca_flags
operator|&
name|MTHCA_FLAG_DDR_HIDDEN
operator|)
condition|)
name|dev
operator|->
name|limits
operator|.
name|fmr_reserved_mtts
operator|=
literal|0
expr_stmt|;
else|else
name|dev
operator|->
name|mthca_flags
operator||=
name|MTHCA_FLAG_FMR
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|mthca_flags
operator|&
name|MTHCA_FLAG_SINAI_OPT
condition|)
name|mthca_dbg
argument_list|(
name|dev
argument_list|,
literal|"Memory key throughput optimization activated.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
name|mthca_buddy_init
argument_list|(
operator|&
name|dev
operator|->
name|mr_table
operator|.
name|mtt_buddy
argument_list|,
name|fls
argument_list|(
name|dev
operator|->
name|limits
operator|.
name|num_mtt_segs
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_mtt_buddy
goto|;
name|dev
operator|->
name|mr_table
operator|.
name|tavor_fmr
operator|.
name|mpt_base
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|mr_table
operator|.
name|tavor_fmr
operator|.
name|mtt_base
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|limits
operator|.
name|fmr_reserved_mtts
condition|)
block|{
name|i
operator|=
name|fls
argument_list|(
name|dev
operator|->
name|limits
operator|.
name|fmr_reserved_mtts
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>=
literal|31
condition|)
block|{
name|mthca_warn
argument_list|(
name|dev
argument_list|,
literal|"Unable to reserve 2^31 FMR MTTs.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|err_fmr_mpt
goto|;
block|}
name|mpts
operator|=
name|mtts
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
else|else
block|{
name|mtts
operator|=
name|dev
operator|->
name|limits
operator|.
name|num_mtt_segs
expr_stmt|;
name|mpts
operator|=
name|dev
operator|->
name|limits
operator|.
name|num_mpts
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
operator|&&
operator|(
name|dev
operator|->
name|mthca_flags
operator|&
name|MTHCA_FLAG_FMR
operator|)
condition|)
block|{
name|addr
operator|=
name|pci_resource_start
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|4
argument_list|)
operator|+
operator|(
operator|(
name|pci_resource_len
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|4
argument_list|)
operator|-
literal|1
operator|)
operator|&
name|dev
operator|->
name|mr_table
operator|.
name|mpt_base
operator|)
expr_stmt|;
name|dev
operator|->
name|mr_table
operator|.
name|tavor_fmr
operator|.
name|mpt_base
operator|=
name|ioremap
argument_list|(
name|addr
argument_list|,
name|mpts
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|mthca_mpt_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|mr_table
operator|.
name|tavor_fmr
operator|.
name|mpt_base
condition|)
block|{
name|mthca_warn
argument_list|(
name|dev
argument_list|,
literal|"MPT ioremap for FMR failed.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_fmr_mpt
goto|;
block|}
name|addr
operator|=
name|pci_resource_start
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|4
argument_list|)
operator|+
operator|(
operator|(
name|pci_resource_len
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|4
argument_list|)
operator|-
literal|1
operator|)
operator|&
name|dev
operator|->
name|mr_table
operator|.
name|mtt_base
operator|)
expr_stmt|;
name|dev
operator|->
name|mr_table
operator|.
name|tavor_fmr
operator|.
name|mtt_base
operator|=
name|ioremap
argument_list|(
name|addr
argument_list|,
name|mtts
operator|*
name|dev
operator|->
name|limits
operator|.
name|mtt_seg_size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|mr_table
operator|.
name|tavor_fmr
operator|.
name|mtt_base
condition|)
block|{
name|mthca_warn
argument_list|(
name|dev
argument_list|,
literal|"MTT ioremap for FMR failed.\n"
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_fmr_mtt
goto|;
block|}
block|}
if|if
condition|(
name|dev
operator|->
name|limits
operator|.
name|fmr_reserved_mtts
condition|)
block|{
name|err
operator|=
name|mthca_buddy_init
argument_list|(
operator|&
name|dev
operator|->
name|mr_table
operator|.
name|tavor_fmr
operator|.
name|mtt_buddy
argument_list|,
name|fls
argument_list|(
name|mtts
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_fmr_mtt_buddy
goto|;
comment|/* Prevent regular MRs from using FMR keys */
name|err
operator|=
name|mthca_buddy_alloc
argument_list|(
operator|&
name|dev
operator|->
name|mr_table
operator|.
name|mtt_buddy
argument_list|,
name|fls
argument_list|(
name|mtts
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|err_reserve_fmr
goto|;
name|dev
operator|->
name|mr_table
operator|.
name|fmr_mtt_buddy
operator|=
operator|&
name|dev
operator|->
name|mr_table
operator|.
name|tavor_fmr
operator|.
name|mtt_buddy
expr_stmt|;
block|}
else|else
name|dev
operator|->
name|mr_table
operator|.
name|fmr_mtt_buddy
operator|=
operator|&
name|dev
operator|->
name|mr_table
operator|.
name|mtt_buddy
expr_stmt|;
comment|/* FMR table is always the first, take reserved MTTs out of there */
if|if
condition|(
name|dev
operator|->
name|limits
operator|.
name|reserved_mtts
condition|)
block|{
name|i
operator|=
name|fls
argument_list|(
name|dev
operator|->
name|limits
operator|.
name|reserved_mtts
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mthca_alloc_mtt_range
argument_list|(
name|dev
argument_list|,
name|i
argument_list|,
name|dev
operator|->
name|mr_table
operator|.
name|fmr_mtt_buddy
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|mthca_warn
argument_list|(
name|dev
argument_list|,
literal|"MTT table of order %d is too small.\n"
argument_list|,
name|dev
operator|->
name|mr_table
operator|.
name|fmr_mtt_buddy
operator|->
name|max_order
argument_list|)
expr_stmt|;
name|err
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|err_reserve_mtts
goto|;
block|}
block|}
return|return
literal|0
return|;
name|err_reserve_mtts
label|:
name|err_reserve_fmr
label|:
if|if
condition|(
name|dev
operator|->
name|limits
operator|.
name|fmr_reserved_mtts
condition|)
name|mthca_buddy_cleanup
argument_list|(
operator|&
name|dev
operator|->
name|mr_table
operator|.
name|tavor_fmr
operator|.
name|mtt_buddy
argument_list|)
expr_stmt|;
name|err_fmr_mtt_buddy
label|:
if|if
condition|(
name|dev
operator|->
name|mr_table
operator|.
name|tavor_fmr
operator|.
name|mtt_base
condition|)
name|iounmap
argument_list|(
name|dev
operator|->
name|mr_table
operator|.
name|tavor_fmr
operator|.
name|mtt_base
argument_list|)
expr_stmt|;
name|err_fmr_mtt
label|:
if|if
condition|(
name|dev
operator|->
name|mr_table
operator|.
name|tavor_fmr
operator|.
name|mpt_base
condition|)
name|iounmap
argument_list|(
name|dev
operator|->
name|mr_table
operator|.
name|tavor_fmr
operator|.
name|mpt_base
argument_list|)
expr_stmt|;
name|err_fmr_mpt
label|:
name|mthca_buddy_cleanup
argument_list|(
operator|&
name|dev
operator|->
name|mr_table
operator|.
name|mtt_buddy
argument_list|)
expr_stmt|;
name|err_mtt_buddy
label|:
name|mthca_alloc_cleanup
argument_list|(
operator|&
name|dev
operator|->
name|mr_table
operator|.
name|mpt_alloc
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|void
name|mthca_cleanup_mr_table
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|)
block|{
comment|/* XXX check if any MRs are still allocated? */
if|if
condition|(
name|dev
operator|->
name|limits
operator|.
name|fmr_reserved_mtts
condition|)
name|mthca_buddy_cleanup
argument_list|(
operator|&
name|dev
operator|->
name|mr_table
operator|.
name|tavor_fmr
operator|.
name|mtt_buddy
argument_list|)
expr_stmt|;
name|mthca_buddy_cleanup
argument_list|(
operator|&
name|dev
operator|->
name|mr_table
operator|.
name|mtt_buddy
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|mr_table
operator|.
name|tavor_fmr
operator|.
name|mtt_base
condition|)
name|iounmap
argument_list|(
name|dev
operator|->
name|mr_table
operator|.
name|tavor_fmr
operator|.
name|mtt_base
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|mr_table
operator|.
name|tavor_fmr
operator|.
name|mpt_base
condition|)
name|iounmap
argument_list|(
name|dev
operator|->
name|mr_table
operator|.
name|tavor_fmr
operator|.
name|mpt_base
argument_list|)
expr_stmt|;
name|mthca_alloc_cleanup
argument_list|(
operator|&
name|dev
operator|->
name|mr_table
operator|.
name|mpt_alloc
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

