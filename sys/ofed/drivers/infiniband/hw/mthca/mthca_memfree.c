begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.  * Copyright (c) 2005 Cisco Systems.  All rights reserved.  * Copyright (c) 2005 Mellanox Technologies. All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<linux/mm.h>
end_include

begin_include
include|#
directive|include
file|<linux/scatterlist.h>
end_include

begin_include
include|#
directive|include
file|<linux/sched.h>
end_include

begin_include
include|#
directive|include
file|<asm/page.h>
end_include

begin_include
include|#
directive|include
file|"mthca_memfree.h"
end_include

begin_include
include|#
directive|include
file|"mthca_dev.h"
end_include

begin_include
include|#
directive|include
file|"mthca_cmd.h"
end_include

begin_comment
comment|/*  * We allocate in as big chunks as we can, up to a maximum of 256 KB  * per chunk.  */
end_comment

begin_enum
enum|enum
block|{
name|MTHCA_ICM_ALLOC_SIZE
init|=
literal|1
operator|<<
literal|18
block|,
name|MTHCA_TABLE_CHUNK_SIZE
init|=
literal|1
operator|<<
literal|18
block|}
enum|;
end_enum

begin_struct
struct|struct
name|mthca_user_db_table
block|{
name|struct
name|mutex
name|mutex
decl_stmt|;
struct|struct
block|{
name|u64
name|uvirt
decl_stmt|;
name|struct
name|scatterlist
name|mem
decl_stmt|;
name|int
name|refcount
decl_stmt|;
block|}
name|page
index|[
literal|0
index|]
struct|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|mthca_free_icm_pages
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_icm_chunk
modifier|*
name|chunk
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|chunk
operator|->
name|nsg
operator|>
literal|0
condition|)
name|pci_unmap_sg
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|chunk
operator|->
name|mem
argument_list|,
name|chunk
operator|->
name|npages
argument_list|,
name|PCI_DMA_BIDIRECTIONAL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chunk
operator|->
name|npages
condition|;
operator|++
name|i
control|)
name|__free_pages
argument_list|(
name|sg_page
argument_list|(
operator|&
name|chunk
operator|->
name|mem
index|[
name|i
index|]
argument_list|)
argument_list|,
name|get_order
argument_list|(
name|chunk
operator|->
name|mem
index|[
name|i
index|]
operator|.
name|length
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mthca_free_icm_coherent
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_icm_chunk
modifier|*
name|chunk
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chunk
operator|->
name|npages
condition|;
operator|++
name|i
control|)
block|{
name|dma_free_coherent
argument_list|(
operator|&
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|chunk
operator|->
name|mem
index|[
name|i
index|]
operator|.
name|length
argument_list|,
name|lowmem_page_address
argument_list|(
name|sg_page
argument_list|(
operator|&
name|chunk
operator|->
name|mem
index|[
name|i
index|]
argument_list|)
argument_list|)
argument_list|,
name|sg_dma_address
argument_list|(
operator|&
name|chunk
operator|->
name|mem
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|mthca_free_icm
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_icm
modifier|*
name|icm
parameter_list|,
name|int
name|coherent
parameter_list|)
block|{
name|struct
name|mthca_icm_chunk
modifier|*
name|chunk
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
if|if
condition|(
operator|!
name|icm
condition|)
return|return;
name|list_for_each_entry_safe
argument_list|(
argument|chunk
argument_list|,
argument|tmp
argument_list|,
argument|&icm->chunk_list
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|coherent
condition|)
name|mthca_free_icm_coherent
argument_list|(
name|dev
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
else|else
name|mthca_free_icm_pages
argument_list|(
name|dev
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|chunk
argument_list|)
expr_stmt|;
block|}
name|kfree
argument_list|(
name|icm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|mthca_alloc_icm_pages
parameter_list|(
name|struct
name|scatterlist
modifier|*
name|mem
parameter_list|,
name|int
name|order
parameter_list|,
name|gfp_t
name|gfp_mask
parameter_list|)
block|{
name|struct
name|page
modifier|*
name|page
decl_stmt|;
comment|/* 	 * Use __GFP_ZERO because buggy firmware assumes ICM pages are 	 * cleared, and subtle failures are seen if they aren't. 	 */
name|page
operator|=
name|alloc_pages
argument_list|(
name|gfp_mask
operator||
name|__GFP_ZERO
argument_list|,
name|order
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|page
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|sg_set_page
argument_list|(
name|mem
argument_list|,
name|page
argument_list|,
name|PAGE_SIZE
operator|<<
name|order
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mthca_alloc_icm_coherent
parameter_list|(
name|struct
name|device
modifier|*
name|dev
parameter_list|,
name|struct
name|scatterlist
modifier|*
name|mem
parameter_list|,
name|int
name|order
parameter_list|,
name|gfp_t
name|gfp_mask
parameter_list|)
block|{
name|void
modifier|*
name|buf
init|=
name|dma_alloc_coherent
argument_list|(
name|dev
argument_list|,
name|PAGE_SIZE
operator|<<
name|order
argument_list|,
operator|&
name|sg_dma_address
argument_list|(
name|mem
argument_list|)
argument_list|,
name|gfp_mask
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|sg_set_buf
argument_list|(
name|mem
argument_list|,
name|buf
argument_list|,
name|PAGE_SIZE
operator|<<
name|order
argument_list|)
expr_stmt|;
name|BUG_ON
argument_list|(
name|mem
operator|->
name|offset
argument_list|)
expr_stmt|;
name|sg_dma_len
argument_list|(
name|mem
argument_list|)
operator|=
name|PAGE_SIZE
operator|<<
name|order
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|struct
name|mthca_icm
modifier|*
name|mthca_alloc_icm
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|int
name|npages
parameter_list|,
name|gfp_t
name|gfp_mask
parameter_list|,
name|int
name|coherent
parameter_list|)
block|{
name|struct
name|mthca_icm
modifier|*
name|icm
decl_stmt|;
name|struct
name|mthca_icm_chunk
modifier|*
name|chunk
init|=
name|NULL
decl_stmt|;
name|int
name|cur_order
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* We use sg_set_buf for coherent allocs, which assumes low memory */
name|BUG_ON
argument_list|(
name|coherent
operator|&&
operator|(
name|gfp_mask
operator|&
name|__GFP_HIGHMEM
operator|)
argument_list|)
expr_stmt|;
name|icm
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|icm
argument_list|,
name|gfp_mask
operator|&
operator|~
operator|(
name|__GFP_HIGHMEM
operator||
name|__GFP_NOWARN
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|icm
condition|)
return|return
name|icm
return|;
name|icm
operator|->
name|refcount
operator|=
literal|0
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|icm
operator|->
name|chunk_list
argument_list|)
expr_stmt|;
name|cur_order
operator|=
name|get_order
argument_list|(
name|MTHCA_ICM_ALLOC_SIZE
argument_list|)
expr_stmt|;
while|while
condition|(
name|npages
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|chunk
condition|)
block|{
name|chunk
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|chunk
argument_list|,
name|gfp_mask
operator|&
operator|~
operator|(
name|__GFP_HIGHMEM
operator||
name|__GFP_NOWARN
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chunk
condition|)
goto|goto
name|fail
goto|;
name|sg_init_table
argument_list|(
name|chunk
operator|->
name|mem
argument_list|,
name|MTHCA_ICM_CHUNK_LEN
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|npages
operator|=
literal|0
expr_stmt|;
name|chunk
operator|->
name|nsg
operator|=
literal|0
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|chunk
operator|->
name|list
argument_list|,
operator|&
name|icm
operator|->
name|chunk_list
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
operator|<<
name|cur_order
operator|>
name|npages
condition|)
operator|--
name|cur_order
expr_stmt|;
if|if
condition|(
name|coherent
condition|)
name|ret
operator|=
name|mthca_alloc_icm_coherent
argument_list|(
operator|&
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
operator|&
name|chunk
operator|->
name|mem
index|[
name|chunk
operator|->
name|npages
index|]
argument_list|,
name|cur_order
argument_list|,
name|gfp_mask
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|mthca_alloc_icm_pages
argument_list|(
operator|&
name|chunk
operator|->
name|mem
index|[
name|chunk
operator|->
name|npages
index|]
argument_list|,
name|cur_order
argument_list|,
name|gfp_mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
block|{
operator|++
name|chunk
operator|->
name|npages
expr_stmt|;
if|if
condition|(
name|coherent
condition|)
operator|++
name|chunk
operator|->
name|nsg
expr_stmt|;
elseif|else
if|if
condition|(
name|chunk
operator|->
name|npages
operator|==
name|MTHCA_ICM_CHUNK_LEN
condition|)
block|{
name|chunk
operator|->
name|nsg
operator|=
name|pci_map_sg
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|chunk
operator|->
name|mem
argument_list|,
name|chunk
operator|->
name|npages
argument_list|,
name|PCI_DMA_BIDIRECTIONAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|->
name|nsg
operator|<=
literal|0
condition|)
goto|goto
name|fail
goto|;
block|}
if|if
condition|(
name|chunk
operator|->
name|npages
operator|==
name|MTHCA_ICM_CHUNK_LEN
condition|)
name|chunk
operator|=
name|NULL
expr_stmt|;
name|npages
operator|-=
literal|1
operator|<<
name|cur_order
expr_stmt|;
block|}
else|else
block|{
operator|--
name|cur_order
expr_stmt|;
if|if
condition|(
name|cur_order
operator|<
literal|0
condition|)
goto|goto
name|fail
goto|;
block|}
block|}
if|if
condition|(
operator|!
name|coherent
operator|&&
name|chunk
condition|)
block|{
name|chunk
operator|->
name|nsg
operator|=
name|pci_map_sg
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
name|chunk
operator|->
name|mem
argument_list|,
name|chunk
operator|->
name|npages
argument_list|,
name|PCI_DMA_BIDIRECTIONAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|->
name|nsg
operator|<=
literal|0
condition|)
goto|goto
name|fail
goto|;
block|}
return|return
name|icm
return|;
name|fail
label|:
name|mthca_free_icm
argument_list|(
name|dev
argument_list|,
name|icm
argument_list|,
name|coherent
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|mthca_table_get
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_icm_table
modifier|*
name|table
parameter_list|,
name|int
name|obj
parameter_list|)
block|{
name|int
name|i
init|=
operator|(
name|obj
operator|&
operator|(
name|table
operator|->
name|num_obj
operator|-
literal|1
operator|)
operator|)
operator|*
name|table
operator|->
name|obj_size
operator|/
name|MTHCA_TABLE_CHUNK_SIZE
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|u8
name|status
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|table
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|icm
index|[
name|i
index|]
condition|)
block|{
operator|++
name|table
operator|->
name|icm
index|[
name|i
index|]
operator|->
name|refcount
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|table
operator|->
name|icm
index|[
name|i
index|]
operator|=
name|mthca_alloc_icm
argument_list|(
name|dev
argument_list|,
name|MTHCA_TABLE_CHUNK_SIZE
operator|>>
name|PAGE_SHIFT
argument_list|,
operator|(
name|table
operator|->
name|lowmem
condition|?
name|GFP_KERNEL
else|:
name|GFP_HIGHUSER
operator|)
operator||
name|__GFP_NOWARN
argument_list|,
name|table
operator|->
name|coherent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|->
name|icm
index|[
name|i
index|]
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|mthca_MAP_ICM
argument_list|(
name|dev
argument_list|,
name|table
operator|->
name|icm
index|[
name|i
index|]
argument_list|,
name|table
operator|->
name|virt
operator|+
name|i
operator|*
name|MTHCA_TABLE_CHUNK_SIZE
argument_list|,
operator|&
name|status
argument_list|)
operator|||
name|status
condition|)
block|{
name|mthca_free_icm
argument_list|(
name|dev
argument_list|,
name|table
operator|->
name|icm
index|[
name|i
index|]
argument_list|,
name|table
operator|->
name|coherent
argument_list|)
expr_stmt|;
name|table
operator|->
name|icm
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|++
name|table
operator|->
name|icm
index|[
name|i
index|]
operator|->
name|refcount
expr_stmt|;
name|out
label|:
name|mutex_unlock
argument_list|(
operator|&
name|table
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|mthca_table_put
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_icm_table
modifier|*
name|table
parameter_list|,
name|int
name|obj
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u8
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
name|i
operator|=
operator|(
name|obj
operator|&
operator|(
name|table
operator|->
name|num_obj
operator|-
literal|1
operator|)
operator|)
operator|*
name|table
operator|->
name|obj_size
operator|/
name|MTHCA_TABLE_CHUNK_SIZE
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|table
operator|->
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|table
operator|->
name|icm
index|[
name|i
index|]
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
name|mthca_UNMAP_ICM
argument_list|(
name|dev
argument_list|,
name|table
operator|->
name|virt
operator|+
name|i
operator|*
name|MTHCA_TABLE_CHUNK_SIZE
argument_list|,
name|MTHCA_TABLE_CHUNK_SIZE
operator|/
name|MTHCA_ICM_PAGE_SIZE
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|mthca_free_icm
argument_list|(
name|dev
argument_list|,
name|table
operator|->
name|icm
index|[
name|i
index|]
argument_list|,
name|table
operator|->
name|coherent
argument_list|)
expr_stmt|;
name|table
operator|->
name|icm
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|mutex_unlock
argument_list|(
operator|&
name|table
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|mthca_table_find
parameter_list|(
name|struct
name|mthca_icm_table
modifier|*
name|table
parameter_list|,
name|int
name|obj
parameter_list|,
name|dma_addr_t
modifier|*
name|dma_handle
parameter_list|)
block|{
name|int
name|idx
decl_stmt|,
name|offset
decl_stmt|,
name|dma_offset
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|mthca_icm_chunk
modifier|*
name|chunk
decl_stmt|;
name|struct
name|mthca_icm
modifier|*
name|icm
decl_stmt|;
name|struct
name|page
modifier|*
name|page
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|table
operator|->
name|lowmem
condition|)
return|return
name|NULL
return|;
name|mutex_lock
argument_list|(
operator|&
name|table
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|idx
operator|=
operator|(
name|obj
operator|&
operator|(
name|table
operator|->
name|num_obj
operator|-
literal|1
operator|)
operator|)
operator|*
name|table
operator|->
name|obj_size
expr_stmt|;
name|icm
operator|=
name|table
operator|->
name|icm
index|[
name|idx
operator|/
name|MTHCA_TABLE_CHUNK_SIZE
index|]
expr_stmt|;
name|dma_offset
operator|=
name|offset
operator|=
name|idx
operator|%
name|MTHCA_TABLE_CHUNK_SIZE
expr_stmt|;
if|if
condition|(
operator|!
name|icm
condition|)
goto|goto
name|out
goto|;
name|list_for_each_entry
argument_list|(
argument|chunk
argument_list|,
argument|&icm->chunk_list
argument_list|,
argument|list
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|chunk
operator|->
name|npages
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|dma_handle
operator|&&
name|dma_offset
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|sg_dma_len
argument_list|(
operator|&
name|chunk
operator|->
name|mem
index|[
name|i
index|]
argument_list|)
operator|>
name|dma_offset
condition|)
operator|*
name|dma_handle
operator|=
name|sg_dma_address
argument_list|(
operator|&
name|chunk
operator|->
name|mem
index|[
name|i
index|]
argument_list|)
operator|+
name|dma_offset
expr_stmt|;
name|dma_offset
operator|-=
name|sg_dma_len
argument_list|(
operator|&
name|chunk
operator|->
name|mem
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* DMA mapping can merge pages but not split them, 			 * so if we found the page, dma_handle has already 			 * been assigned to. */
if|if
condition|(
name|chunk
operator|->
name|mem
index|[
name|i
index|]
operator|.
name|length
operator|>
name|offset
condition|)
block|{
name|page
operator|=
name|sg_page
argument_list|(
operator|&
name|chunk
operator|->
name|mem
index|[
name|i
index|]
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|offset
operator|-=
name|chunk
operator|->
name|mem
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
block|}
block|}
name|out
label|:
name|mutex_unlock
argument_list|(
operator|&
name|table
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
name|page
condition|?
name|lowmem_page_address
argument_list|(
name|page
argument_list|)
operator|+
name|offset
else|:
name|NULL
return|;
block|}
end_function

begin_function
name|int
name|mthca_table_get_range
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_icm_table
modifier|*
name|table
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|int
name|inc
init|=
name|MTHCA_TABLE_CHUNK_SIZE
operator|/
name|table
operator|->
name|obj_size
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<=
name|end
condition|;
name|i
operator|+=
name|inc
control|)
block|{
name|err
operator|=
name|mthca_table_get
argument_list|(
name|dev
argument_list|,
name|table
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|fail
goto|;
block|}
return|return
literal|0
return|;
name|fail
label|:
while|while
condition|(
name|i
operator|>
name|start
condition|)
block|{
name|i
operator|-=
name|inc
expr_stmt|;
name|mthca_table_put
argument_list|(
name|dev
argument_list|,
name|table
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
name|void
name|mthca_table_put_range
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_icm_table
modifier|*
name|table
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<=
name|end
condition|;
name|i
operator|+=
name|MTHCA_TABLE_CHUNK_SIZE
operator|/
name|table
operator|->
name|obj_size
control|)
name|mthca_table_put
argument_list|(
name|dev
argument_list|,
name|table
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|mthca_icm_table
modifier|*
name|mthca_alloc_icm_table
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|u64
name|virt
parameter_list|,
name|int
name|obj_size
parameter_list|,
name|int
name|nobj
parameter_list|,
name|int
name|reserved
parameter_list|,
name|int
name|use_lowmem
parameter_list|,
name|int
name|use_coherent
parameter_list|)
block|{
name|struct
name|mthca_icm_table
modifier|*
name|table
decl_stmt|;
name|int
name|obj_per_chunk
decl_stmt|;
name|int
name|num_icm
decl_stmt|;
name|unsigned
name|chunk_size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|u8
name|status
decl_stmt|;
name|obj_per_chunk
operator|=
name|MTHCA_TABLE_CHUNK_SIZE
operator|/
name|obj_size
expr_stmt|;
name|num_icm
operator|=
name|DIV_ROUND_UP
argument_list|(
name|nobj
argument_list|,
name|obj_per_chunk
argument_list|)
expr_stmt|;
name|table
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|table
operator|+
name|num_icm
operator|*
sizeof|sizeof
expr|*
name|table
operator|->
name|icm
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
condition|)
return|return
name|NULL
return|;
name|table
operator|->
name|virt
operator|=
name|virt
expr_stmt|;
name|table
operator|->
name|num_icm
operator|=
name|num_icm
expr_stmt|;
name|table
operator|->
name|num_obj
operator|=
name|nobj
expr_stmt|;
name|table
operator|->
name|obj_size
operator|=
name|obj_size
expr_stmt|;
name|table
operator|->
name|lowmem
operator|=
name|use_lowmem
expr_stmt|;
name|table
operator|->
name|coherent
operator|=
name|use_coherent
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|table
operator|->
name|mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_icm
condition|;
operator|++
name|i
control|)
name|table
operator|->
name|icm
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|*
name|MTHCA_TABLE_CHUNK_SIZE
operator|<
name|reserved
operator|*
name|obj_size
condition|;
operator|++
name|i
control|)
block|{
name|chunk_size
operator|=
name|MTHCA_TABLE_CHUNK_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
name|MTHCA_TABLE_CHUNK_SIZE
operator|>
name|nobj
operator|*
name|obj_size
condition|)
name|chunk_size
operator|=
name|nobj
operator|*
name|obj_size
operator|-
name|i
operator|*
name|MTHCA_TABLE_CHUNK_SIZE
expr_stmt|;
name|table
operator|->
name|icm
index|[
name|i
index|]
operator|=
name|mthca_alloc_icm
argument_list|(
name|dev
argument_list|,
name|chunk_size
operator|>>
name|PAGE_SHIFT
argument_list|,
operator|(
name|use_lowmem
condition|?
name|GFP_KERNEL
else|:
name|GFP_HIGHUSER
operator|)
operator||
name|__GFP_NOWARN
argument_list|,
name|use_coherent
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|table
operator|->
name|icm
index|[
name|i
index|]
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|mthca_MAP_ICM
argument_list|(
name|dev
argument_list|,
name|table
operator|->
name|icm
index|[
name|i
index|]
argument_list|,
name|virt
operator|+
name|i
operator|*
name|MTHCA_TABLE_CHUNK_SIZE
argument_list|,
operator|&
name|status
argument_list|)
operator|||
name|status
condition|)
block|{
name|mthca_free_icm
argument_list|(
name|dev
argument_list|,
name|table
operator|->
name|icm
index|[
name|i
index|]
argument_list|,
name|table
operator|->
name|coherent
argument_list|)
expr_stmt|;
name|table
operator|->
name|icm
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 		 * Add a reference to this ICM chunk so that it never 		 * gets freed (since it contains reserved firmware objects). 		 */
operator|++
name|table
operator|->
name|icm
index|[
name|i
index|]
operator|->
name|refcount
expr_stmt|;
block|}
return|return
name|table
return|;
name|err
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_icm
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|table
operator|->
name|icm
index|[
name|i
index|]
condition|)
block|{
name|mthca_UNMAP_ICM
argument_list|(
name|dev
argument_list|,
name|virt
operator|+
name|i
operator|*
name|MTHCA_TABLE_CHUNK_SIZE
argument_list|,
name|MTHCA_TABLE_CHUNK_SIZE
operator|/
name|MTHCA_ICM_PAGE_SIZE
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|mthca_free_icm
argument_list|(
name|dev
argument_list|,
name|table
operator|->
name|icm
index|[
name|i
index|]
argument_list|,
name|table
operator|->
name|coherent
argument_list|)
expr_stmt|;
block|}
name|kfree
argument_list|(
name|table
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|mthca_free_icm_table
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_icm_table
modifier|*
name|table
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u8
name|status
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|num_icm
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|table
operator|->
name|icm
index|[
name|i
index|]
condition|)
block|{
name|mthca_UNMAP_ICM
argument_list|(
name|dev
argument_list|,
name|table
operator|->
name|virt
operator|+
name|i
operator|*
name|MTHCA_TABLE_CHUNK_SIZE
argument_list|,
name|MTHCA_TABLE_CHUNK_SIZE
operator|/
name|MTHCA_ICM_PAGE_SIZE
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|mthca_free_icm
argument_list|(
name|dev
argument_list|,
name|table
operator|->
name|icm
index|[
name|i
index|]
argument_list|,
name|table
operator|->
name|coherent
argument_list|)
expr_stmt|;
block|}
name|kfree
argument_list|(
name|table
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u64
name|mthca_uarc_virt
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_uar
modifier|*
name|uar
parameter_list|,
name|int
name|page
parameter_list|)
block|{
return|return
name|dev
operator|->
name|uar_table
operator|.
name|uarc_base
operator|+
name|uar
operator|->
name|index
operator|*
name|dev
operator|->
name|uar_table
operator|.
name|uarc_size
operator|+
name|page
operator|*
name|MTHCA_ICM_PAGE_SIZE
return|;
block|}
end_function

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/resourcevar.h>
end_include

begin_function
name|int
name|mthca_map_user_db
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_uar
modifier|*
name|uar
parameter_list|,
name|struct
name|mthca_user_db_table
modifier|*
name|db_tab
parameter_list|,
name|int
name|index
parameter_list|,
name|u64
name|uaddr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__linux__
name|struct
name|page
modifier|*
name|pages
index|[
literal|1
index|]
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|u8
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>
name|dev
operator|->
name|uar_table
operator|.
name|uarc_size
operator|/
literal|8
condition|)
return|return
operator|-
name|EINVAL
return|;
name|mutex_lock
argument_list|(
operator|&
name|db_tab
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|i
operator|=
name|index
operator|/
name|MTHCA_DB_REC_PER_PAGE
expr_stmt|;
if|if
condition|(
operator|(
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|refcount
operator|>=
name|MTHCA_DB_REC_PER_PAGE
operator|)
operator|||
operator|(
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|uvirt
operator|&&
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|uvirt
operator|!=
name|uaddr
operator|)
operator|||
operator|(
name|uaddr
operator|&
literal|4095
operator|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|refcount
condition|)
block|{
operator|++
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|refcount
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|get_user_pages
argument_list|(
name|current
argument_list|,
name|current
operator|->
name|mm
argument_list|,
name|uaddr
operator|&
name|PAGE_MASK
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|pages
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
goto|goto
name|out
goto|;
name|sg_set_page
argument_list|(
operator|&
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|mem
argument_list|,
name|pages
index|[
literal|0
index|]
argument_list|,
name|MTHCA_ICM_PAGE_SIZE
argument_list|,
name|uaddr
operator|&
operator|~
name|PAGE_MASK
argument_list|)
expr_stmt|;
name|ret
operator|=
name|pci_map_sg
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
operator|&
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|mem
argument_list|,
literal|1
argument_list|,
name|PCI_DMA_TODEVICE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|put_page
argument_list|(
name|pages
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|mthca_MAP_ICM_page
argument_list|(
name|dev
argument_list|,
name|sg_dma_address
argument_list|(
operator|&
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|mem
argument_list|)
argument_list|,
name|mthca_uarc_virt
argument_list|(
name|dev
argument_list|,
name|uar
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|&&
name|status
condition|)
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|pci_unmap_sg
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
operator|&
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|mem
argument_list|,
literal|1
argument_list|,
name|PCI_DMA_TODEVICE
argument_list|)
expr_stmt|;
name|put_page
argument_list|(
name|sg_page
argument_list|(
operator|&
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|mem
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|uvirt
operator|=
name|uaddr
expr_stmt|;
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|refcount
operator|=
literal|1
expr_stmt|;
name|out
label|:
name|mutex_unlock
argument_list|(
operator|&
name|db_tab
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
else|#
directive|else
name|struct
name|proc
modifier|*
name|proc
decl_stmt|;
name|vm_offset_t
name|start
decl_stmt|;
name|vm_paddr_t
name|paddr
decl_stmt|;
name|pmap_t
name|pmap
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|u8
name|status
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|index
operator|<
literal|0
operator|||
name|index
operator|>
name|dev
operator|->
name|uar_table
operator|.
name|uarc_size
operator|/
literal|8
condition|)
return|return
operator|-
name|EINVAL
return|;
name|mutex_lock
argument_list|(
operator|&
name|db_tab
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|i
operator|=
name|index
operator|/
name|MTHCA_DB_REC_PER_PAGE
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|refcount
operator|>=
name|MTHCA_DB_REC_PER_PAGE
operator|)
operator|||
operator|(
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|uvirt
operator|&&
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|uvirt
operator|!=
name|uaddr
operator|)
operator|||
operator|(
name|uaddr
operator|&
literal|4095
operator|)
condition|)
block|{
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|refcount
condition|)
block|{
operator|++
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|refcount
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|proc
operator|=
name|curproc
expr_stmt|;
name|pmap
operator|=
name|vm_map_pmap
argument_list|(
operator|&
name|proc
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptoa
argument_list|(
name|pmap_wired_count
argument_list|(
name|pmap
argument_list|)
operator|+
literal|1
argument_list|)
operator|>
name|lim_cur
argument_list|(
name|proc
argument_list|,
name|RLIMIT_MEMLOCK
argument_list|)
condition|)
block|{
name|PROC_UNLOCK
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|PROC_UNLOCK
argument_list|(
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|.
name|v_wire_count
operator|+
literal|1
operator|>
name|vm_page_max_wired
condition|)
block|{
name|ret
operator|=
operator|-
name|EAGAIN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|start
operator|=
name|uaddr
operator|&
name|PAGE_MASK
expr_stmt|;
name|ret
operator|=
name|vm_map_wire
argument_list|(
operator|&
name|proc
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|start
argument_list|,
name|start
operator|+
name|PAGE_SIZE
argument_list|,
name|VM_MAP_WIRE_USER
operator||
name|VM_MAP_WIRE_NOHOLES
operator||
name|VM_MAP_WIRE_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|KERN_SUCCESS
condition|)
block|{
name|start
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|paddr
operator|=
name|pmap_extract
argument_list|(
name|pmap
argument_list|,
name|uaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|paddr
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
name|EFAULT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|paddr
argument_list|)
expr_stmt|;
name|sg_set_page
argument_list|(
operator|&
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|mem
argument_list|,
name|m
argument_list|,
name|MTHCA_ICM_PAGE_SIZE
argument_list|,
name|uaddr
operator|&
operator|~
name|PAGE_MASK
argument_list|)
expr_stmt|;
name|ret
operator|=
name|pci_map_sg
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
operator|&
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|mem
argument_list|,
literal|1
argument_list|,
name|PCI_DMA_TODEVICE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
goto|goto
name|out
goto|;
name|ret
operator|=
name|mthca_MAP_ICM_page
argument_list|(
name|dev
argument_list|,
name|sg_dma_address
argument_list|(
operator|&
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|mem
argument_list|)
argument_list|,
name|mthca_uarc_virt
argument_list|(
name|dev
argument_list|,
name|uar
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|&&
name|status
condition|)
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|pci_unmap_sg
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
operator|&
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|mem
argument_list|,
literal|1
argument_list|,
name|PCI_DMA_TODEVICE
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|uvirt
operator|=
name|uaddr
expr_stmt|;
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|refcount
operator|=
literal|1
expr_stmt|;
name|out
label|:
if|if
condition|(
name|ret
operator|<
literal|0
operator|&&
name|start
condition|)
name|vm_map_unwire
argument_list|(
operator|&
name|curthread
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|start
argument_list|,
name|start
operator|+
name|PAGE_SIZE
argument_list|,
name|VM_MAP_WIRE_USER
operator||
name|VM_MAP_WIRE_NOHOLES
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|db_tab
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|mthca_unmap_user_db
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_uar
modifier|*
name|uar
parameter_list|,
name|struct
name|mthca_user_db_table
modifier|*
name|db_tab
parameter_list|,
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
operator|!
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
comment|/* 	 * To make our bookkeeping simpler, we don't unmap DB 	 * pages until we clean up the whole db table. 	 */
name|mutex_lock
argument_list|(
operator|&
name|db_tab
operator|->
name|mutex
argument_list|)
expr_stmt|;
operator|--
name|db_tab
operator|->
name|page
index|[
name|index
operator|/
name|MTHCA_DB_REC_PER_PAGE
index|]
operator|.
name|refcount
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|db_tab
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|mthca_user_db_table
modifier|*
name|mthca_init_user_db_tab
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|mthca_user_db_table
modifier|*
name|db_tab
decl_stmt|;
name|int
name|npages
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|NULL
return|;
name|npages
operator|=
name|dev
operator|->
name|uar_table
operator|.
name|uarc_size
operator|/
name|MTHCA_ICM_PAGE_SIZE
expr_stmt|;
name|db_tab
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|db_tab
operator|+
name|npages
operator|*
sizeof|sizeof
expr|*
name|db_tab
operator|->
name|page
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|db_tab
condition|)
return|return
name|ERR_PTR
argument_list|(
operator|-
name|ENOMEM
argument_list|)
return|;
name|mutex_init
argument_list|(
operator|&
name|db_tab
operator|->
name|mutex
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npages
condition|;
operator|++
name|i
control|)
block|{
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|refcount
operator|=
literal|0
expr_stmt|;
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|uvirt
operator|=
literal|0
expr_stmt|;
name|sg_init_table
argument_list|(
operator|&
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|mem
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|db_tab
return|;
block|}
end_function

begin_function
name|void
name|mthca_cleanup_user_db_tab
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|mthca_uar
modifier|*
name|uar
parameter_list|,
name|struct
name|mthca_user_db_table
modifier|*
name|db_tab
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u8
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|uar_table
operator|.
name|uarc_size
operator|/
name|MTHCA_ICM_PAGE_SIZE
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|uvirt
condition|)
block|{
name|mthca_UNMAP_ICM
argument_list|(
name|dev
argument_list|,
name|mthca_uarc_virt
argument_list|(
name|dev
argument_list|,
name|uar
argument_list|,
name|i
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|pci_unmap_sg
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
operator|&
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|mem
argument_list|,
literal|1
argument_list|,
name|PCI_DMA_TODEVICE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__linux__
name|put_page
argument_list|(
name|sg_page
argument_list|(
operator|&
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|mem
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|vm_offset_t
name|start
decl_stmt|;
name|start
operator|=
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|uvirt
operator|&
name|PAGE_MASK
expr_stmt|;
name|vm_map_unwire
argument_list|(
operator|&
name|curthread
operator|->
name|td_proc
operator|->
name|p_vmspace
operator|->
name|vm_map
argument_list|,
name|start
argument_list|,
name|start
operator|+
name|PAGE_SIZE
argument_list|,
name|VM_MAP_WIRE_USER
operator||
name|VM_MAP_WIRE_NOHOLES
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|kfree
argument_list|(
name|db_tab
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mthca_alloc_db
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|enum
name|mthca_db_type
name|type
parameter_list|,
name|u32
name|qn
parameter_list|,
name|__be32
modifier|*
modifier|*
name|db
parameter_list|)
block|{
name|int
name|group
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|dir
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|mthca_db_page
modifier|*
name|page
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|u8
name|status
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|dev
operator|->
name|db_tab
operator|->
name|mutex
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MTHCA_DB_TYPE_CQ_ARM
case|:
case|case
name|MTHCA_DB_TYPE_SQ
case|:
name|group
operator|=
literal|0
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
name|end
operator|=
name|dev
operator|->
name|db_tab
operator|->
name|max_group1
expr_stmt|;
name|dir
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|MTHCA_DB_TYPE_CQ_SET_CI
case|:
case|case
name|MTHCA_DB_TYPE_RQ
case|:
case|case
name|MTHCA_DB_TYPE_SRQ
case|:
name|group
operator|=
literal|1
expr_stmt|;
name|start
operator|=
name|dev
operator|->
name|db_tab
operator|->
name|npages
operator|-
literal|1
expr_stmt|;
name|end
operator|=
name|dev
operator|->
name|db_tab
operator|->
name|min_group2
expr_stmt|;
name|dir
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|!=
name|end
condition|;
name|i
operator|+=
name|dir
control|)
if|if
condition|(
name|dev
operator|->
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|db_rec
operator|&&
operator|!
name|bitmap_full
argument_list|(
name|dev
operator|->
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|used
argument_list|,
name|MTHCA_DB_REC_PER_PAGE
argument_list|)
condition|)
block|{
name|page
operator|=
name|dev
operator|->
name|db_tab
operator|->
name|page
operator|+
name|i
expr_stmt|;
goto|goto
name|found
goto|;
block|}
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|!=
name|end
condition|;
name|i
operator|+=
name|dir
control|)
if|if
condition|(
operator|!
name|dev
operator|->
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|db_rec
condition|)
block|{
name|page
operator|=
name|dev
operator|->
name|db_tab
operator|->
name|page
operator|+
name|i
expr_stmt|;
goto|goto
name|alloc
goto|;
block|}
if|if
condition|(
name|dev
operator|->
name|db_tab
operator|->
name|max_group1
operator|>=
name|dev
operator|->
name|db_tab
operator|->
name|min_group2
operator|-
literal|1
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|group
operator|==
literal|0
condition|)
operator|++
name|dev
operator|->
name|db_tab
operator|->
name|max_group1
expr_stmt|;
else|else
operator|--
name|dev
operator|->
name|db_tab
operator|->
name|min_group2
expr_stmt|;
name|page
operator|=
name|dev
operator|->
name|db_tab
operator|->
name|page
operator|+
name|end
expr_stmt|;
name|alloc
label|:
name|page
operator|->
name|db_rec
operator|=
name|dma_alloc_coherent
argument_list|(
operator|&
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|MTHCA_ICM_PAGE_SIZE
argument_list|,
operator|&
name|page
operator|->
name|mapping
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|page
operator|->
name|db_rec
condition|)
block|{
name|ret
operator|=
operator|-
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|memset
argument_list|(
name|page
operator|->
name|db_rec
argument_list|,
literal|0
argument_list|,
name|MTHCA_ICM_PAGE_SIZE
argument_list|)
expr_stmt|;
name|ret
operator|=
name|mthca_MAP_ICM_page
argument_list|(
name|dev
argument_list|,
name|page
operator|->
name|mapping
argument_list|,
name|mthca_uarc_virt
argument_list|(
name|dev
argument_list|,
operator|&
name|dev
operator|->
name|driver_uar
argument_list|,
name|i
argument_list|)
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
operator|&&
name|status
condition|)
name|ret
operator|=
operator|-
name|EINVAL
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|dma_free_coherent
argument_list|(
operator|&
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|MTHCA_ICM_PAGE_SIZE
argument_list|,
name|page
operator|->
name|db_rec
argument_list|,
name|page
operator|->
name|mapping
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|bitmap_zero
argument_list|(
name|page
operator|->
name|used
argument_list|,
name|MTHCA_DB_REC_PER_PAGE
argument_list|)
expr_stmt|;
name|found
label|:
name|j
operator|=
name|find_first_zero_bit
argument_list|(
name|page
operator|->
name|used
argument_list|,
name|MTHCA_DB_REC_PER_PAGE
argument_list|)
expr_stmt|;
name|set_bit
argument_list|(
name|j
argument_list|,
name|page
operator|->
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|group
operator|==
literal|1
condition|)
name|j
operator|=
name|MTHCA_DB_REC_PER_PAGE
operator|-
literal|1
operator|-
name|j
expr_stmt|;
name|ret
operator|=
name|i
operator|*
name|MTHCA_DB_REC_PER_PAGE
operator|+
name|j
expr_stmt|;
name|page
operator|->
name|db_rec
index|[
name|j
index|]
operator|=
name|cpu_to_be64
argument_list|(
operator|(
name|qn
operator|<<
literal|8
operator|)
operator||
operator|(
name|type
operator|<<
literal|5
operator|)
argument_list|)
expr_stmt|;
operator|*
name|db
operator|=
operator|(
name|__be32
operator|*
operator|)
operator|&
name|page
operator|->
name|db_rec
index|[
name|j
index|]
expr_stmt|;
name|out
label|:
name|mutex_unlock
argument_list|(
operator|&
name|dev
operator|->
name|db_tab
operator|->
name|mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
name|void
name|mthca_free_db
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|db_index
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|mthca_db_page
modifier|*
name|page
decl_stmt|;
name|u8
name|status
decl_stmt|;
name|i
operator|=
name|db_index
operator|/
name|MTHCA_DB_REC_PER_PAGE
expr_stmt|;
name|j
operator|=
name|db_index
operator|%
name|MTHCA_DB_REC_PER_PAGE
expr_stmt|;
name|page
operator|=
name|dev
operator|->
name|db_tab
operator|->
name|page
operator|+
name|i
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|dev
operator|->
name|db_tab
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|page
operator|->
name|db_rec
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|dev
operator|->
name|db_tab
operator|->
name|min_group2
condition|)
name|j
operator|=
name|MTHCA_DB_REC_PER_PAGE
operator|-
literal|1
operator|-
name|j
expr_stmt|;
name|clear_bit
argument_list|(
name|j
argument_list|,
name|page
operator|->
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|bitmap_empty
argument_list|(
name|page
operator|->
name|used
argument_list|,
name|MTHCA_DB_REC_PER_PAGE
argument_list|)
operator|&&
name|i
operator|>=
name|dev
operator|->
name|db_tab
operator|->
name|max_group1
operator|-
literal|1
condition|)
block|{
name|mthca_UNMAP_ICM
argument_list|(
name|dev
argument_list|,
name|mthca_uarc_virt
argument_list|(
name|dev
argument_list|,
operator|&
name|dev
operator|->
name|driver_uar
argument_list|,
name|i
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|dma_free_coherent
argument_list|(
operator|&
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|MTHCA_ICM_PAGE_SIZE
argument_list|,
name|page
operator|->
name|db_rec
argument_list|,
name|page
operator|->
name|mapping
argument_list|)
expr_stmt|;
name|page
operator|->
name|db_rec
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|dev
operator|->
name|db_tab
operator|->
name|max_group1
condition|)
block|{
operator|--
name|dev
operator|->
name|db_tab
operator|->
name|max_group1
expr_stmt|;
comment|/* XXX may be able to unmap more pages now */
block|}
if|if
condition|(
name|i
operator|==
name|dev
operator|->
name|db_tab
operator|->
name|min_group2
condition|)
operator|++
name|dev
operator|->
name|db_tab
operator|->
name|min_group2
expr_stmt|;
block|}
name|mutex_unlock
argument_list|(
operator|&
name|dev
operator|->
name|db_tab
operator|->
name|mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|mthca_init_db_tab
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
return|return
literal|0
return|;
name|dev
operator|->
name|db_tab
operator|=
name|kmalloc
argument_list|(
sizeof|sizeof
expr|*
name|dev
operator|->
name|db_tab
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|db_tab
condition|)
return|return
operator|-
name|ENOMEM
return|;
name|mutex_init
argument_list|(
operator|&
name|dev
operator|->
name|db_tab
operator|->
name|mutex
argument_list|)
expr_stmt|;
name|dev
operator|->
name|db_tab
operator|->
name|npages
operator|=
name|dev
operator|->
name|uar_table
operator|.
name|uarc_size
operator|/
name|MTHCA_ICM_PAGE_SIZE
expr_stmt|;
name|dev
operator|->
name|db_tab
operator|->
name|max_group1
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|db_tab
operator|->
name|min_group2
operator|=
name|dev
operator|->
name|db_tab
operator|->
name|npages
operator|-
literal|1
expr_stmt|;
name|dev
operator|->
name|db_tab
operator|->
name|page
operator|=
name|kmalloc
argument_list|(
name|dev
operator|->
name|db_tab
operator|->
name|npages
operator|*
sizeof|sizeof
expr|*
name|dev
operator|->
name|db_tab
operator|->
name|page
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|db_tab
operator|->
name|page
condition|)
block|{
name|kfree
argument_list|(
name|dev
operator|->
name|db_tab
argument_list|)
expr_stmt|;
return|return
operator|-
name|ENOMEM
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|db_tab
operator|->
name|npages
condition|;
operator|++
name|i
control|)
name|dev
operator|->
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|db_rec
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|mthca_cleanup_db_tab
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|u8
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|mthca_is_memfree
argument_list|(
name|dev
argument_list|)
condition|)
return|return;
comment|/* 	 * Because we don't always free our UARC pages when they 	 * become empty to make mthca_free_db() simpler we need to 	 * make a sweep through the doorbell pages and free any 	 * leftover pages now. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|db_tab
operator|->
name|npages
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|dev
operator|->
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|db_rec
condition|)
continue|continue;
if|if
condition|(
operator|!
name|bitmap_empty
argument_list|(
name|dev
operator|->
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|used
argument_list|,
name|MTHCA_DB_REC_PER_PAGE
argument_list|)
condition|)
name|mthca_warn
argument_list|(
name|dev
argument_list|,
literal|"Kernel UARC page %d not empty\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mthca_UNMAP_ICM
argument_list|(
name|dev
argument_list|,
name|mthca_uarc_virt
argument_list|(
name|dev
argument_list|,
operator|&
name|dev
operator|->
name|driver_uar
argument_list|,
name|i
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|dma_free_coherent
argument_list|(
operator|&
name|dev
operator|->
name|pdev
operator|->
name|dev
argument_list|,
name|MTHCA_ICM_PAGE_SIZE
argument_list|,
name|dev
operator|->
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|db_rec
argument_list|,
name|dev
operator|->
name|db_tab
operator|->
name|page
index|[
name|i
index|]
operator|.
name|mapping
argument_list|)
expr_stmt|;
block|}
name|kfree
argument_list|(
name|dev
operator|->
name|db_tab
operator|->
name|page
argument_list|)
expr_stmt|;
name|kfree
argument_list|(
name|dev
operator|->
name|db_tab
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

