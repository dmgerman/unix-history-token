begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2005 Cisco Systems.  All rights reserved.  *  * This software is available to you under a choice of one of two  * licenses.  You may choose to be licensed under the terms of the GNU  * General Public License (GPL) Version 2, available from the file  * COPYING in the main directory of this source tree, or the  * OpenIB.org BSD license below:  *  *     Redistribution and use in source and binary forms, with or  *     without modification, are permitted provided that the following  *     conditions are met:  *  *      - Redistributions of source code must retain the above  *        copyright notice, this list of conditions and the following  *        disclaimer.  *  *      - Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials  *        provided with the distribution.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS  * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN  * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN  * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<linux/jiffies.h>
end_include

begin_include
include|#
directive|include
file|<linux/timer.h>
end_include

begin_include
include|#
directive|include
file|<linux/workqueue.h>
end_include

begin_include
include|#
directive|include
file|"mthca_dev.h"
end_include

begin_enum
enum|enum
block|{
name|MTHCA_CATAS_TYPE_INTERNAL
init|=
literal|0
block|,
name|MTHCA_CATAS_TYPE_UPLINK
init|=
literal|3
block|,
name|MTHCA_CATAS_TYPE_DDR
init|=
literal|4
block|,
name|MTHCA_CATAS_TYPE_PARITY
init|=
literal|5
block|, }
enum|;
end_enum

begin_define
define|#
directive|define
name|MTHCA_CATAS_POLL_INTERVAL
value|(5 * HZ)
end_define

begin_expr_stmt
specifier|static
name|DEFINE_SPINLOCK
argument_list|(
name|catas_lock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
name|catas_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|workqueue_struct
modifier|*
name|catas_wq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|work_struct
name|catas_work
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|catas_reset_disable
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|module_param_named
argument_list|(
name|catas_reset_disable
argument_list|,
name|catas_reset_disable
argument_list|,
name|int
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_PARM_DESC
argument_list|(
name|catas_reset_disable
argument_list|,
literal|"disable reset on catastrophic event if nonzero"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|catas_reset
parameter_list|(
name|struct
name|work_struct
modifier|*
name|work
parameter_list|)
block|{
name|struct
name|mthca_dev
modifier|*
name|dev
decl_stmt|,
modifier|*
name|tmpdev
decl_stmt|;
name|LIST_HEAD
argument_list|(
name|tlist
argument_list|)
expr_stmt|;
name|int
name|ret
decl_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|mthca_device_mutex
argument_list|)
expr_stmt|;
name|spin_lock_irq
argument_list|(
operator|&
name|catas_lock
argument_list|)
expr_stmt|;
name|list_splice_init
argument_list|(
operator|&
name|catas_list
argument_list|,
operator|&
name|tlist
argument_list|)
expr_stmt|;
name|spin_unlock_irq
argument_list|(
operator|&
name|catas_lock
argument_list|)
expr_stmt|;
name|list_for_each_entry_safe
argument_list|(
argument|dev
argument_list|,
argument|tmpdev
argument_list|,
argument|&tlist
argument_list|,
argument|catas_err.list
argument_list|)
block|{
name|struct
name|pci_dev
modifier|*
name|pdev
init|=
name|dev
operator|->
name|pdev
decl_stmt|;
name|ret
operator|=
name|__mthca_restart_one
argument_list|(
name|dev
operator|->
name|pdev
argument_list|)
expr_stmt|;
comment|/* 'dev' now is not valid */
if|if
condition|(
name|ret
condition|)
name|printk
argument_list|(
name|KERN_ERR
literal|"mthca %s: Reset failed (%d)\n"
argument_list|,
name|pci_name
argument_list|(
name|pdev
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
else|else
block|{
name|struct
name|mthca_dev
modifier|*
name|d
init|=
name|pci_get_drvdata
argument_list|(
name|pdev
argument_list|)
decl_stmt|;
name|mthca_dbg
argument_list|(
name|d
argument_list|,
literal|"Reset succeeded\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_unlock
argument_list|(
operator|&
name|mthca_device_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|handle_catas
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|)
block|{
name|struct
name|ib_event
name|event
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
name|int
name|i
decl_stmt|;
name|event
operator|.
name|device
operator|=
operator|&
name|dev
operator|->
name|ib_dev
expr_stmt|;
name|event
operator|.
name|event
operator|=
name|IB_EVENT_DEVICE_FATAL
expr_stmt|;
name|event
operator|.
name|element
operator|.
name|port_num
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|ib_dispatch_event
argument_list|(
operator|&
name|event
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|swab32
argument_list|(
name|readl
argument_list|(
name|dev
operator|->
name|catas_err
operator|.
name|map
argument_list|)
argument_list|)
operator|>>
literal|24
condition|)
block|{
case|case
name|MTHCA_CATAS_TYPE_INTERNAL
case|:
name|type
operator|=
literal|"internal error"
expr_stmt|;
break|break;
case|case
name|MTHCA_CATAS_TYPE_UPLINK
case|:
name|type
operator|=
literal|"uplink bus error"
expr_stmt|;
break|break;
case|case
name|MTHCA_CATAS_TYPE_DDR
case|:
name|type
operator|=
literal|"DDR data error"
expr_stmt|;
break|break;
case|case
name|MTHCA_CATAS_TYPE_PARITY
case|:
name|type
operator|=
literal|"internal parity error"
expr_stmt|;
break|break;
default|default:
name|type
operator|=
literal|"unknown error"
expr_stmt|;
break|break;
block|}
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"Catastrophic error detected: %s\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|catas_err
operator|.
name|size
condition|;
operator|++
name|i
control|)
name|mthca_err
argument_list|(
name|dev
argument_list|,
literal|"  buf[%02x]: %08x\n"
argument_list|,
name|i
argument_list|,
name|swab32
argument_list|(
name|readl
argument_list|(
name|dev
operator|->
name|catas_err
operator|.
name|map
operator|+
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|catas_reset_disable
condition|)
return|return;
name|spin_lock_irqsave
argument_list|(
operator|&
name|catas_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|list_add
argument_list|(
operator|&
name|dev
operator|->
name|catas_err
operator|.
name|list
argument_list|,
operator|&
name|catas_list
argument_list|)
expr_stmt|;
name|queue_work
argument_list|(
name|catas_wq
argument_list|,
operator|&
name|catas_work
argument_list|)
expr_stmt|;
name|spin_unlock_irqrestore
argument_list|(
operator|&
name|catas_lock
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|poll_catas
parameter_list|(
name|unsigned
name|long
name|dev_ptr
parameter_list|)
block|{
name|struct
name|mthca_dev
modifier|*
name|dev
init|=
operator|(
expr|struct
name|mthca_dev
operator|*
operator|)
name|dev_ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dev
operator|->
name|catas_err
operator|.
name|size
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|readl
argument_list|(
name|dev
operator|->
name|catas_err
operator|.
name|map
operator|+
name|i
argument_list|)
condition|)
block|{
name|handle_catas
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return;
block|}
name|mod_timer
argument_list|(
operator|&
name|dev
operator|->
name|catas_err
operator|.
name|timer
argument_list|,
name|round_jiffies
argument_list|(
name|jiffies
operator|+
name|MTHCA_CATAS_POLL_INTERVAL
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mthca_start_catas_poll
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|)
block|{
name|unsigned
name|long
name|addr
decl_stmt|;
name|init_timer
argument_list|(
operator|&
name|dev
operator|->
name|catas_err
operator|.
name|timer
argument_list|)
expr_stmt|;
name|dev
operator|->
name|catas_err
operator|.
name|map
operator|=
name|NULL
expr_stmt|;
name|addr
operator|=
name|pci_resource_start
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|0
argument_list|)
operator|+
operator|(
operator|(
name|pci_resource_len
argument_list|(
name|dev
operator|->
name|pdev
argument_list|,
literal|0
argument_list|)
operator|-
literal|1
operator|)
operator|&
name|dev
operator|->
name|catas_err
operator|.
name|addr
operator|)
expr_stmt|;
name|dev
operator|->
name|catas_err
operator|.
name|map
operator|=
name|ioremap
argument_list|(
name|addr
argument_list|,
name|dev
operator|->
name|catas_err
operator|.
name|size
operator|*
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dev
operator|->
name|catas_err
operator|.
name|map
condition|)
block|{
name|mthca_warn
argument_list|(
name|dev
argument_list|,
literal|"couldn't map catastrophic error region "
literal|"at 0x%lx/0x%x\n"
argument_list|,
name|addr
argument_list|,
name|dev
operator|->
name|catas_err
operator|.
name|size
operator|*
literal|4
argument_list|)
expr_stmt|;
return|return;
block|}
name|dev
operator|->
name|catas_err
operator|.
name|timer
operator|.
name|data
operator|=
operator|(
name|unsigned
name|long
operator|)
name|dev
expr_stmt|;
name|dev
operator|->
name|catas_err
operator|.
name|timer
operator|.
name|function
operator|=
name|poll_catas
expr_stmt|;
name|dev
operator|->
name|catas_err
operator|.
name|timer
operator|.
name|expires
operator|=
name|jiffies
operator|+
name|MTHCA_CATAS_POLL_INTERVAL
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|dev
operator|->
name|catas_err
operator|.
name|list
argument_list|)
expr_stmt|;
name|add_timer
argument_list|(
operator|&
name|dev
operator|->
name|catas_err
operator|.
name|timer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mthca_stop_catas_poll
parameter_list|(
name|struct
name|mthca_dev
modifier|*
name|dev
parameter_list|)
block|{
name|del_timer_sync
argument_list|(
operator|&
name|dev
operator|->
name|catas_err
operator|.
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|->
name|catas_err
operator|.
name|map
condition|)
name|iounmap
argument_list|(
name|dev
operator|->
name|catas_err
operator|.
name|map
argument_list|)
expr_stmt|;
name|spin_lock_irq
argument_list|(
operator|&
name|catas_lock
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|dev
operator|->
name|catas_err
operator|.
name|list
argument_list|)
expr_stmt|;
name|spin_unlock_irq
argument_list|(
operator|&
name|catas_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|__init
name|mthca_catas_init
parameter_list|(
name|void
parameter_list|)
block|{
name|INIT_WORK
argument_list|(
operator|&
name|catas_work
argument_list|,
name|catas_reset
argument_list|)
expr_stmt|;
name|catas_wq
operator|=
name|create_singlethread_workqueue
argument_list|(
literal|"mthcacatas"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|catas_wq
condition|)
return|return
operator|-
name|ENOMEM
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|mthca_catas_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|destroy_workqueue
argument_list|(
name|catas_wq
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

