begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010 Isilon Systems, Inc.  * Copyright (c) 2010 iX Systems, Inc.  * Copyright (c) 2010 Panasas, Inc.  * Copyright (c) 2013-2016 Mellanox Technologies, Ltd.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_LINUX_PCI_H_
end_ifndef

begin_define
define|#
directive|define
name|_LINUX_PCI_H_
end_define

begin_define
define|#
directive|define
name|CONFIG_PCI_MSI
end_define

begin_include
include|#
directive|include
file|<linux/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pci_private.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<linux/list.h>
end_include

begin_include
include|#
directive|include
file|<linux/dmapool.h>
end_include

begin_include
include|#
directive|include
file|<linux/dma-mapping.h>
end_include

begin_include
include|#
directive|include
file|<linux/compiler.h>
end_include

begin_include
include|#
directive|include
file|<linux/errno.h>
end_include

begin_include
include|#
directive|include
file|<asm/atomic.h>
end_include

begin_include
include|#
directive|include
file|<linux/device.h>
end_include

begin_struct
struct|struct
name|pci_device_id
block|{
name|uint32_t
name|vendor
decl_stmt|;
name|uint32_t
name|device
decl_stmt|;
name|uint32_t
name|subvendor
decl_stmt|;
name|uint32_t
name|subdevice
decl_stmt|;
name|uint32_t
name|class_mask
decl_stmt|;
name|uintptr_t
name|driver_data
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MODULE_DEVICE_TABLE
parameter_list|(
name|bus
parameter_list|,
name|table
parameter_list|)
end_define

begin_define
define|#
directive|define
name|PCI_ANY_ID
value|(-1)
end_define

begin_define
define|#
directive|define
name|PCI_VENDOR_ID_MELLANOX
value|0x15b3
end_define

begin_define
define|#
directive|define
name|PCI_VENDOR_ID_TOPSPIN
value|0x1867
end_define

begin_define
define|#
directive|define
name|PCI_DEVICE_ID_MELLANOX_TAVOR
value|0x5a44
end_define

begin_define
define|#
directive|define
name|PCI_DEVICE_ID_MELLANOX_TAVOR_BRIDGE
value|0x5a46
end_define

begin_define
define|#
directive|define
name|PCI_DEVICE_ID_MELLANOX_ARBEL_COMPAT
value|0x6278
end_define

begin_define
define|#
directive|define
name|PCI_DEVICE_ID_MELLANOX_ARBEL
value|0x6282
end_define

begin_define
define|#
directive|define
name|PCI_DEVICE_ID_MELLANOX_SINAI_OLD
value|0x5e8c
end_define

begin_define
define|#
directive|define
name|PCI_DEVICE_ID_MELLANOX_SINAI
value|0x6274
end_define

begin_define
define|#
directive|define
name|PCI_DEVFN
parameter_list|(
name|slot
parameter_list|,
name|func
parameter_list|)
value|((((slot)& 0x1f)<< 3) | ((func)& 0x07))
end_define

begin_define
define|#
directive|define
name|PCI_SLOT
parameter_list|(
name|devfn
parameter_list|)
value|(((devfn)>> 3)& 0x1f)
end_define

begin_define
define|#
directive|define
name|PCI_FUNC
parameter_list|(
name|devfn
parameter_list|)
value|((devfn)& 0x07)
end_define

begin_define
define|#
directive|define
name|PCI_VDEVICE
parameter_list|(
name|_vendor
parameter_list|,
name|_device
parameter_list|)
define|\
value|.vendor = PCI_VENDOR_ID_##_vendor, .device = (_device),	\ 	    .subvendor = PCI_ANY_ID, .subdevice = PCI_ANY_ID
end_define

begin_define
define|#
directive|define
name|PCI_DEVICE
parameter_list|(
name|_vendor
parameter_list|,
name|_device
parameter_list|)
define|\
value|.vendor = (_vendor), .device = (_device),			\ 	    .subvendor = PCI_ANY_ID, .subdevice = PCI_ANY_ID
end_define

begin_define
define|#
directive|define
name|to_pci_dev
parameter_list|(
name|n
parameter_list|)
value|container_of(n, struct pci_dev, dev)
end_define

begin_define
define|#
directive|define
name|PCI_VENDOR_ID
value|PCIR_DEVVENDOR
end_define

begin_define
define|#
directive|define
name|PCI_COMMAND
value|PCIR_COMMAND
end_define

begin_define
define|#
directive|define
name|PCI_EXP_DEVCTL
value|PCIER_DEVICE_CTL
end_define

begin_comment
comment|/* Device Control */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_LNKCTL
value|PCIER_LINK_CTL
end_define

begin_comment
comment|/* Link Control */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_FLAGS_TYPE
value|PCIEM_FLAGS_TYPE
end_define

begin_comment
comment|/* Device/Port type */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_DEVCAP
value|PCIER_DEVICE_CAP
end_define

begin_comment
comment|/* Device capabilities */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_DEVSTA
value|PCIER_DEVICE_STA
end_define

begin_comment
comment|/* Device Status */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_LNKCAP
value|PCIER_LINK_CAP
end_define

begin_comment
comment|/* Link Capabilities */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_LNKSTA
value|PCIER_LINK_STA
end_define

begin_comment
comment|/* Link Status */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_SLTCAP
value|PCIER_SLOT_CAP
end_define

begin_comment
comment|/* Slot Capabilities */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_SLTCTL
value|PCIER_SLOT_CTL
end_define

begin_comment
comment|/* Slot Control */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_SLTSTA
value|PCIER_SLOT_STA
end_define

begin_comment
comment|/* Slot Status */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_RTCTL
value|PCIER_ROOT_CTL
end_define

begin_comment
comment|/* Root Control */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_RTCAP
value|PCIER_ROOT_CAP
end_define

begin_comment
comment|/* Root Capabilities */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_RTSTA
value|PCIER_ROOT_STA
end_define

begin_comment
comment|/* Root Status */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_DEVCAP2
value|PCIER_DEVICE_CAP2
end_define

begin_comment
comment|/* Device Capabilities 2 */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_DEVCTL2
value|PCIER_DEVICE_CTL2
end_define

begin_comment
comment|/* Device Control 2 */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_LNKCAP2
value|PCIER_LINK_CAP2
end_define

begin_comment
comment|/* Link Capabilities 2 */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_LNKCTL2
value|PCIER_LINK_CTL2
end_define

begin_comment
comment|/* Link Control 2 */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_LNKSTA2
value|PCIER_LINK_STA2
end_define

begin_comment
comment|/* Link Status 2 */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_FLAGS
value|PCIER_FLAGS
end_define

begin_comment
comment|/* Capabilities register */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_FLAGS_VERS
value|PCIEM_FLAGS_VERSION
end_define

begin_comment
comment|/* Capability version */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_TYPE_ROOT_PORT
value|PCIEM_TYPE_ROOT_PORT
end_define

begin_comment
comment|/* Root Port */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_TYPE_ENDPOINT
value|PCIEM_TYPE_ENDPOINT
end_define

begin_comment
comment|/* Express Endpoint */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_TYPE_LEG_END
value|PCIEM_TYPE_LEGACY_ENDPOINT
end_define

begin_comment
comment|/* Legacy Endpoint */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_TYPE_DOWNSTREAM
value|PCIEM_TYPE_DOWNSTREAM_PORT
end_define

begin_comment
comment|/* Downstream Port */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_FLAGS_SLOT
value|PCIEM_FLAGS_SLOT
end_define

begin_comment
comment|/* Slot implemented */
end_comment

begin_define
define|#
directive|define
name|PCI_EXP_TYPE_RC_EC
value|PCIEM_TYPE_ROOT_EC
end_define

begin_comment
comment|/* Root Complex Event Collector */
end_comment

begin_define
define|#
directive|define
name|IORESOURCE_MEM
value|(1<< SYS_RES_MEMORY)
end_define

begin_define
define|#
directive|define
name|IORESOURCE_IO
value|(1<< SYS_RES_IOPORT)
end_define

begin_define
define|#
directive|define
name|IORESOURCE_IRQ
value|(1<< SYS_RES_IRQ)
end_define

begin_struct_decl
struct_decl|struct
name|pci_dev
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|pci_driver
block|{
name|struct
name|list_head
name|links
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|struct
name|pci_device_id
modifier|*
name|id_table
decl_stmt|;
name|int
function_decl|(
modifier|*
name|probe
function_decl|)
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|dev
parameter_list|,
specifier|const
name|struct
name|pci_device_id
modifier|*
name|id
parameter_list|)
function_decl|;
name|void
function_decl|(
modifier|*
name|remove
function_decl|)
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|dev
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|suspend
function_decl|)
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|dev
parameter_list|,
name|pm_message_t
name|state
parameter_list|)
function_decl|;
comment|/* Device suspended */
name|int
function_decl|(
modifier|*
name|resume
function_decl|)
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|dev
parameter_list|)
function_decl|;
comment|/* Device woken up */
name|driver_t
name|driver
decl_stmt|;
name|devclass_t
name|bsdclass
decl_stmt|;
specifier|const
name|struct
name|pci_error_handlers
modifier|*
name|err_handler
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|struct
name|list_head
name|pci_drivers
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|list_head
name|pci_devices
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|spinlock_t
name|pci_lock
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|__devexit_p
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_struct
struct|struct
name|pci_dev
block|{
name|struct
name|device
name|dev
decl_stmt|;
name|struct
name|list_head
name|links
decl_stmt|;
name|struct
name|pci_driver
modifier|*
name|pdrv
decl_stmt|;
name|uint64_t
name|dma_mask
decl_stmt|;
name|uint16_t
name|device
decl_stmt|;
name|uint16_t
name|vendor
decl_stmt|;
name|unsigned
name|int
name|irq
decl_stmt|;
name|unsigned
name|int
name|devfn
decl_stmt|;
name|u8
name|revision
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|struct
name|resource_list_entry
modifier|*
name|_pci_get_rle
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|)
block|{
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|struct
name|resource_list
modifier|*
name|rl
decl_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|pdev
operator|->
name|dev
operator|.
name|bsddev
argument_list|)
expr_stmt|;
name|rl
operator|=
operator|&
name|dinfo
operator|->
name|resources
expr_stmt|;
return|return
name|resource_list_find
argument_list|(
name|rl
argument_list|,
name|type
argument_list|,
name|rid
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|resource_list_entry
modifier|*
name|_pci_get_bar
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|int
name|bar
parameter_list|)
block|{
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|bar
operator|=
name|PCIR_BAR
argument_list|(
name|bar
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rle
operator|=
name|_pci_get_rle
argument_list|(
name|pdev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|bar
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|rle
operator|=
name|_pci_get_rle
argument_list|(
name|pdev
argument_list|,
name|SYS_RES_IOPORT
argument_list|,
name|bar
argument_list|)
expr_stmt|;
return|return
operator|(
name|rle
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|struct
name|device
modifier|*
name|_pci_find_irq_dev
parameter_list|(
name|unsigned
name|int
name|irq
parameter_list|)
block|{
name|struct
name|pci_dev
modifier|*
name|pdev
decl_stmt|;
name|spin_lock
argument_list|(
operator|&
name|pci_lock
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|pdev
argument_list|,
argument|&pci_devices
argument_list|,
argument|links
argument_list|)
block|{
if|if
condition|(
name|irq
operator|==
name|pdev
operator|->
name|dev
operator|.
name|irq
condition|)
break|break;
if|if
condition|(
name|irq
operator|>=
name|pdev
operator|->
name|dev
operator|.
name|msix
operator|&&
name|irq
operator|<
name|pdev
operator|->
name|dev
operator|.
name|msix_max
condition|)
break|break;
block|}
name|spin_unlock
argument_list|(
operator|&
name|pci_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdev
condition|)
return|return
operator|&
name|pdev
operator|->
name|dev
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|pci_resource_start
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|int
name|bar
parameter_list|)
block|{
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
if|if
condition|(
operator|(
name|rle
operator|=
name|_pci_get_bar
argument_list|(
name|pdev
argument_list|,
name|bar
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
name|rle
operator|->
name|start
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|long
name|pci_resource_len
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|int
name|bar
parameter_list|)
block|{
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
if|if
condition|(
operator|(
name|rle
operator|=
name|_pci_get_bar
argument_list|(
name|pdev
argument_list|,
name|bar
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
name|rle
operator|->
name|count
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|pci_resource_type
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|int
name|bar
parameter_list|)
block|{
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
if|if
condition|(
operator|(
name|rle
operator|=
name|_pci_get_bar
argument_list|(
name|pdev
argument_list|,
name|bar
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|rle
operator|->
name|type
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * All drivers just seem to want to inspect the type not flags.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|pci_resource_flags
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|int
name|bar
parameter_list|)
block|{
name|int
name|type
decl_stmt|;
name|type
operator|=
name|pci_resource_type
argument_list|(
name|pdev
argument_list|,
name|bar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|<<
name|type
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|pci_name
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|d
parameter_list|)
block|{
return|return
name|device_get_desc
argument_list|(
name|d
operator|->
name|dev
operator|.
name|bsddev
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|pci_get_drvdata
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
return|return
name|dev_get_drvdata
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|pci_set_drvdata
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|dev_set_drvdata
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|pci_enable_device
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|pci_enable_io
argument_list|(
name|pdev
operator|->
name|dev
operator|.
name|bsddev
argument_list|,
name|SYS_RES_IOPORT
argument_list|)
expr_stmt|;
name|pci_enable_io
argument_list|(
name|pdev
operator|->
name|dev
operator|.
name|bsddev
argument_list|,
name|SYS_RES_MEMORY
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|pci_disable_device
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
specifier|inline
name|int
name|pci_set_master
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|pci_enable_busmaster
argument_list|(
name|pdev
operator|->
name|dev
operator|.
name|bsddev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|pci_clear_master
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|pci_disable_busmaster
argument_list|(
name|pdev
operator|->
name|dev
operator|.
name|bsddev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|pci_request_region
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|int
name|bar
parameter_list|,
specifier|const
name|char
modifier|*
name|res_name
parameter_list|)
block|{
name|int
name|rid
decl_stmt|;
name|int
name|type
decl_stmt|;
name|type
operator|=
name|pci_resource_type
argument_list|(
name|pdev
argument_list|,
name|bar
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
name|ENODEV
operator|)
return|;
name|rid
operator|=
name|PCIR_BAR
argument_list|(
name|bar
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_alloc_resource_any
argument_list|(
name|pdev
operator|->
name|dev
operator|.
name|bsddev
argument_list|,
name|type
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|EINVAL
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|pci_release_region
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|int
name|bar
parameter_list|)
block|{
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
if|if
condition|(
operator|(
name|rle
operator|=
name|_pci_get_bar
argument_list|(
name|pdev
argument_list|,
name|bar
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|bus_release_resource
argument_list|(
name|pdev
operator|->
name|dev
operator|.
name|bsddev
argument_list|,
name|rle
operator|->
name|type
argument_list|,
name|rle
operator|->
name|rid
argument_list|,
name|rle
operator|->
name|res
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|pci_release_regions
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|PCIR_MAX_BAR_0
condition|;
name|i
operator|++
control|)
name|pci_release_region
argument_list|(
name|pdev
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|pci_request_regions
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
specifier|const
name|char
modifier|*
name|res_name
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|PCIR_MAX_BAR_0
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|pci_request_region
argument_list|(
name|pdev
argument_list|,
name|i
argument_list|,
name|res_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
operator|-
name|ENODEV
condition|)
block|{
name|pci_release_regions
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|pci_disable_msix
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
name|pci_release_msi
argument_list|(
name|pdev
operator|->
name|dev
operator|.
name|bsddev
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|PCI_CAP_ID_EXP
value|PCIY_EXPRESS
end_define

begin_define
define|#
directive|define
name|PCI_CAP_ID_PCIX
value|PCIY_PCIX
end_define

begin_function
specifier|static
specifier|inline
name|int
name|pci_find_capability
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|int
name|capid
parameter_list|)
block|{
name|int
name|reg
decl_stmt|;
if|if
condition|(
name|pci_find_cap
argument_list|(
name|pdev
operator|->
name|dev
operator|.
name|bsddev
argument_list|,
name|capid
argument_list|,
operator|&
name|reg
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|reg
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * pci_pcie_cap - get the saved PCIe capability offset  * @dev: PCI device  *  * PCIe capability offset is calculated at PCI device initialization  * time and saved in the data structure. This function returns saved  * PCIe capability offset. Using this instead of pci_find_capability()  * reduces unnecessary search in the PCI configuration space. If you  * need to calculate PCIe capability offset from raw device for some  * reasons, please use pci_find_capability() instead.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|pci_pcie_cap
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|dev
parameter_list|)
block|{
return|return
name|pci_find_capability
argument_list|(
name|dev
argument_list|,
name|PCI_CAP_ID_EXP
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|pci_read_config_byte
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|int
name|where
parameter_list|,
name|u8
modifier|*
name|val
parameter_list|)
block|{
operator|*
name|val
operator|=
operator|(
name|u8
operator|)
name|pci_read_config
argument_list|(
name|pdev
operator|->
name|dev
operator|.
name|bsddev
argument_list|,
name|where
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|pci_read_config_word
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|int
name|where
parameter_list|,
name|u16
modifier|*
name|val
parameter_list|)
block|{
operator|*
name|val
operator|=
operator|(
name|u16
operator|)
name|pci_read_config
argument_list|(
name|pdev
operator|->
name|dev
operator|.
name|bsddev
argument_list|,
name|where
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|pci_read_config_dword
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|int
name|where
parameter_list|,
name|u32
modifier|*
name|val
parameter_list|)
block|{
operator|*
name|val
operator|=
operator|(
name|u32
operator|)
name|pci_read_config
argument_list|(
name|pdev
operator|->
name|dev
operator|.
name|bsddev
argument_list|,
name|where
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|pci_write_config_byte
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|int
name|where
parameter_list|,
name|u8
name|val
parameter_list|)
block|{
name|pci_write_config
argument_list|(
name|pdev
operator|->
name|dev
operator|.
name|bsddev
argument_list|,
name|where
argument_list|,
name|val
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|pci_write_config_word
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|int
name|where
parameter_list|,
name|u16
name|val
parameter_list|)
block|{
name|pci_write_config
argument_list|(
name|pdev
operator|->
name|dev
operator|.
name|bsddev
argument_list|,
name|where
argument_list|,
name|val
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|pci_write_config_dword
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|int
name|where
parameter_list|,
name|u32
name|val
parameter_list|)
block|{
name|pci_write_config
argument_list|(
name|pdev
operator|->
name|dev
operator|.
name|bsddev
argument_list|,
name|where
argument_list|,
name|val
argument_list|,
literal|4
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|pci_driver
modifier|*
name|linux_pci_find
parameter_list|(
name|device_t
name|dev
parameter_list|,
specifier|const
name|struct
name|pci_device_id
modifier|*
modifier|*
name|idp
parameter_list|)
block|{
specifier|const
name|struct
name|pci_device_id
modifier|*
name|id
decl_stmt|;
name|struct
name|pci_driver
modifier|*
name|pdrv
decl_stmt|;
name|uint16_t
name|vendor
decl_stmt|;
name|uint16_t
name|device
decl_stmt|;
name|vendor
operator|=
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|device
operator|=
name|pci_get_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|spin_lock
argument_list|(
operator|&
name|pci_lock
argument_list|)
expr_stmt|;
name|list_for_each_entry
argument_list|(
argument|pdrv
argument_list|,
argument|&pci_drivers
argument_list|,
argument|links
argument_list|)
block|{
for|for
control|(
name|id
operator|=
name|pdrv
operator|->
name|id_table
init|;
name|id
operator|->
name|vendor
operator|!=
literal|0
condition|;
name|id
operator|++
control|)
block|{
if|if
condition|(
name|vendor
operator|==
name|id
operator|->
name|vendor
operator|&&
name|device
operator|==
name|id
operator|->
name|device
condition|)
block|{
operator|*
name|idp
operator|=
name|id
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|pci_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|pdrv
operator|)
return|;
block|}
block|}
block|}
name|spin_unlock
argument_list|(
operator|&
name|pci_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|linux_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|struct
name|pci_device_id
modifier|*
name|id
decl_stmt|;
name|struct
name|pci_driver
modifier|*
name|pdrv
decl_stmt|;
if|if
condition|(
operator|(
name|pdrv
operator|=
name|linux_pci_find
argument_list|(
name|dev
argument_list|,
operator|&
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|device_get_driver
argument_list|(
name|dev
argument_list|)
operator|!=
operator|&
name|pdrv
operator|->
name|driver
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
name|pdrv
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|linux_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|struct
name|pci_dev
modifier|*
name|pdev
decl_stmt|;
name|struct
name|pci_driver
modifier|*
name|pdrv
decl_stmt|;
specifier|const
name|struct
name|pci_device_id
modifier|*
name|id
decl_stmt|;
name|int
name|error
decl_stmt|;
name|pdrv
operator|=
name|linux_pci_find
argument_list|(
name|dev
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
name|pdev
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|pdev
operator|->
name|dev
operator|.
name|parent
operator|=
operator|&
name|linux_rootdev
expr_stmt|;
name|pdev
operator|->
name|dev
operator|.
name|bsddev
operator|=
name|dev
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|pdev
operator|->
name|dev
operator|.
name|irqents
argument_list|)
expr_stmt|;
name|pdev
operator|->
name|device
operator|=
name|id
operator|->
name|device
expr_stmt|;
name|pdev
operator|->
name|vendor
operator|=
name|id
operator|->
name|vendor
expr_stmt|;
name|pdev
operator|->
name|dev
operator|.
name|dma_mask
operator|=
operator|&
name|pdev
operator|->
name|dma_mask
expr_stmt|;
name|pdev
operator|->
name|pdrv
operator|=
name|pdrv
expr_stmt|;
name|kobject_init
argument_list|(
operator|&
name|pdev
operator|->
name|dev
operator|.
name|kobj
argument_list|,
operator|&
name|dev_ktype
argument_list|)
expr_stmt|;
name|kobject_set_name
argument_list|(
operator|&
name|pdev
operator|->
name|dev
operator|.
name|kobj
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|kobject_add
argument_list|(
operator|&
name|pdev
operator|->
name|dev
operator|.
name|kobj
argument_list|,
operator|&
name|linux_rootdev
operator|.
name|kobj
argument_list|,
name|kobject_name
argument_list|(
operator|&
name|pdev
operator|->
name|dev
operator|.
name|kobj
argument_list|)
argument_list|)
expr_stmt|;
name|rle
operator|=
name|_pci_get_rle
argument_list|(
name|pdev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rle
condition|)
name|pdev
operator|->
name|dev
operator|.
name|irq
operator|=
name|rle
operator|->
name|start
expr_stmt|;
else|else
name|pdev
operator|->
name|dev
operator|.
name|irq
operator|=
literal|0
expr_stmt|;
name|pdev
operator|->
name|irq
operator|=
name|pdev
operator|->
name|dev
operator|.
name|irq
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|spin_lock
argument_list|(
operator|&
name|pci_lock
argument_list|)
expr_stmt|;
name|list_add
argument_list|(
operator|&
name|pdev
operator|->
name|links
argument_list|,
operator|&
name|pci_devices
argument_list|)
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|pci_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|pdrv
operator|->
name|probe
argument_list|(
name|pdev
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|spin_lock
argument_list|(
operator|&
name|pci_lock
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|pdev
operator|->
name|links
argument_list|)
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|pci_lock
argument_list|)
expr_stmt|;
name|put_device
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|linux_pci_detach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|pci_dev
modifier|*
name|pdev
decl_stmt|;
name|pdev
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|pdev
operator|->
name|pdrv
operator|->
name|remove
argument_list|(
name|pdev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|spin_lock
argument_list|(
operator|&
name|pci_lock
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|pdev
operator|->
name|links
argument_list|)
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|pci_lock
argument_list|)
expr_stmt|;
name|put_device
argument_list|(
operator|&
name|pdev
operator|->
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|device_method_t
name|pci_methods
index|[]
init|=
block|{
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|linux_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|linux_pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|linux_pci_detach
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|int
name|pci_register_driver
parameter_list|(
name|struct
name|pci_driver
modifier|*
name|pdrv
parameter_list|)
block|{
name|devclass_t
name|bus
decl_stmt|;
name|int
name|error
decl_stmt|;
name|spin_lock
argument_list|(
operator|&
name|pci_lock
argument_list|)
expr_stmt|;
name|list_add
argument_list|(
operator|&
name|pdrv
operator|->
name|links
argument_list|,
operator|&
name|pci_drivers
argument_list|)
expr_stmt|;
name|spin_unlock
argument_list|(
operator|&
name|pci_lock
argument_list|)
expr_stmt|;
name|bus
operator|=
name|devclass_find
argument_list|(
literal|"pci"
argument_list|)
expr_stmt|;
name|pdrv
operator|->
name|driver
operator|.
name|name
operator|=
name|pdrv
operator|->
name|name
expr_stmt|;
name|pdrv
operator|->
name|driver
operator|.
name|methods
operator|=
name|pci_methods
expr_stmt|;
name|pdrv
operator|->
name|driver
operator|.
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|pci_dev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|error
operator|=
name|devclass_add_driver
argument_list|(
name|bus
argument_list|,
operator|&
name|pdrv
operator|->
name|driver
argument_list|,
name|BUS_PASS_DEFAULT
argument_list|,
operator|&
name|pdrv
operator|->
name|bsdclass
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
operator|-
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|pci_unregister_driver
parameter_list|(
name|struct
name|pci_driver
modifier|*
name|pdrv
parameter_list|)
block|{
name|devclass_t
name|bus
decl_stmt|;
name|list_del
argument_list|(
operator|&
name|pdrv
operator|->
name|links
argument_list|)
expr_stmt|;
name|bus
operator|=
name|devclass_find
argument_list|(
literal|"pci"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
name|devclass_delete_driver
argument_list|(
name|bus
argument_list|,
operator|&
name|pdrv
operator|->
name|driver
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|Giant
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|msix_entry
block|{
name|int
name|entry
decl_stmt|;
name|int
name|vector
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Enable msix, positive errors indicate actual number of available  * vectors.  Negative errors are failures.  *  * NB: define added to prevent this definition of pci_enable_msix from  * clashing with the native FreeBSD version.  */
end_comment

begin_define
define|#
directive|define
name|pci_enable_msix
value|linux_pci_enable_msix
end_define

begin_function
specifier|static
specifier|inline
name|int
name|pci_enable_msix
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|,
name|struct
name|msix_entry
modifier|*
name|entries
parameter_list|,
name|int
name|nreq
parameter_list|)
block|{
name|struct
name|resource_list_entry
modifier|*
name|rle
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|avail
decl_stmt|;
name|int
name|i
decl_stmt|;
name|avail
operator|=
name|pci_msix_count
argument_list|(
name|pdev
operator|->
name|dev
operator|.
name|bsddev
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail
operator|<
name|nreq
condition|)
block|{
if|if
condition|(
name|avail
operator|==
literal|0
condition|)
return|return
operator|-
name|EINVAL
return|;
return|return
name|avail
return|;
block|}
name|avail
operator|=
name|nreq
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
operator|-
name|pci_alloc_msix
argument_list|(
name|pdev
operator|->
name|dev
operator|.
name|bsddev
argument_list|,
operator|&
name|avail
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* 	 * Handle case where "pci_alloc_msix()" may allocate less 	 * interrupts than available and return with no error: 	 */
if|if
condition|(
name|avail
operator|<
name|nreq
condition|)
block|{
name|pci_release_msi
argument_list|(
name|pdev
operator|->
name|dev
operator|.
name|bsddev
argument_list|)
expr_stmt|;
return|return
name|avail
return|;
block|}
name|rle
operator|=
name|_pci_get_rle
argument_list|(
name|pdev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|pdev
operator|->
name|dev
operator|.
name|msix
operator|=
name|rle
operator|->
name|start
expr_stmt|;
name|pdev
operator|->
name|dev
operator|.
name|msix_max
operator|=
name|rle
operator|->
name|start
operator|+
name|avail
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nreq
condition|;
name|i
operator|++
control|)
name|entries
index|[
name|i
index|]
operator|.
name|vector
operator|=
name|pdev
operator|->
name|dev
operator|.
name|msix
operator|+
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|pci_enable_msix_range
value|linux_pci_enable_msix_range
end_define

begin_function
specifier|static
specifier|inline
name|int
name|pci_enable_msix_range
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|dev
parameter_list|,
name|struct
name|msix_entry
modifier|*
name|entries
parameter_list|,
name|int
name|minvec
parameter_list|,
name|int
name|maxvec
parameter_list|)
block|{
name|int
name|nvec
init|=
name|maxvec
decl_stmt|;
name|int
name|rc
decl_stmt|;
if|if
condition|(
name|maxvec
operator|<
name|minvec
condition|)
return|return
operator|(
operator|-
name|ERANGE
operator|)
return|;
do|do
block|{
name|rc
operator|=
name|pci_enable_msix
argument_list|(
name|dev
argument_list|,
name|entries
argument_list|,
name|nvec
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|rc
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|rc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|rc
operator|<
name|minvec
condition|)
return|return
operator|(
operator|-
name|ENOSPC
operator|)
return|;
name|nvec
operator|=
name|rc
expr_stmt|;
block|}
block|}
do|while
condition|(
name|rc
condition|)
do|;
return|return
operator|(
name|nvec
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|pci_channel_offline
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|pdev
parameter_list|)
block|{
return|return
name|false
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|pci_enable_sriov
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|dev
parameter_list|,
name|int
name|nr_virtfn
parameter_list|)
block|{
return|return
operator|-
name|ENODEV
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|pci_disable_sriov
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|dev
parameter_list|)
block|{ }
end_function

begin_comment
comment|/**  * DEFINE_PCI_DEVICE_TABLE - macro used to describe a pci device table  * @_table: device table name  *  * This macro is used to create a struct pci_device_id array (a device table)  * in a generic manner.  */
end_comment

begin_define
define|#
directive|define
name|DEFINE_PCI_DEVICE_TABLE
parameter_list|(
name|_table
parameter_list|)
define|\
value|const struct pci_device_id _table[] __devinitdata
end_define

begin_comment
comment|/* XXX This should not be necessary. */
end_comment

begin_define
define|#
directive|define
name|pcix_set_mmrbc
parameter_list|(
name|d
parameter_list|,
name|v
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|pcix_get_max_mmrbc
parameter_list|(
name|d
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|pcie_set_readrq
parameter_list|(
name|d
parameter_list|,
name|v
parameter_list|)
value|0
end_define

begin_define
define|#
directive|define
name|PCI_DMA_BIDIRECTIONAL
value|0
end_define

begin_define
define|#
directive|define
name|PCI_DMA_TODEVICE
value|1
end_define

begin_define
define|#
directive|define
name|PCI_DMA_FROMDEVICE
value|2
end_define

begin_define
define|#
directive|define
name|PCI_DMA_NONE
value|3
end_define

begin_define
define|#
directive|define
name|pci_pool
value|dma_pool
end_define

begin_define
define|#
directive|define
name|pci_pool_destroy
value|dma_pool_destroy
end_define

begin_define
define|#
directive|define
name|pci_pool_alloc
value|dma_pool_alloc
end_define

begin_define
define|#
directive|define
name|pci_pool_free
value|dma_pool_free
end_define

begin_define
define|#
directive|define
name|pci_pool_create
parameter_list|(
name|_name
parameter_list|,
name|_pdev
parameter_list|,
name|_size
parameter_list|,
name|_align
parameter_list|,
name|_alloc
parameter_list|)
define|\
value|dma_pool_create(_name,&(_pdev)->dev, _size, _align, _alloc)
end_define

begin_define
define|#
directive|define
name|pci_free_consistent
parameter_list|(
name|_hwdev
parameter_list|,
name|_size
parameter_list|,
name|_vaddr
parameter_list|,
name|_dma_handle
parameter_list|)
define|\
value|dma_free_coherent((_hwdev) == NULL ? NULL :&(_hwdev)->dev,	\ 		_size, _vaddr, _dma_handle)
end_define

begin_define
define|#
directive|define
name|pci_map_sg
parameter_list|(
name|_hwdev
parameter_list|,
name|_sg
parameter_list|,
name|_nents
parameter_list|,
name|_dir
parameter_list|)
define|\
value|dma_map_sg((_hwdev) == NULL ? NULL :&(_hwdev->dev),	\ 		_sg, _nents, (enum dma_data_direction)_dir)
end_define

begin_define
define|#
directive|define
name|pci_map_single
parameter_list|(
name|_hwdev
parameter_list|,
name|_ptr
parameter_list|,
name|_size
parameter_list|,
name|_dir
parameter_list|)
define|\
value|dma_map_single((_hwdev) == NULL ? NULL :&(_hwdev->dev),	\ 		(_ptr), (_size), (enum dma_data_direction)_dir)
end_define

begin_define
define|#
directive|define
name|pci_unmap_single
parameter_list|(
name|_hwdev
parameter_list|,
name|_addr
parameter_list|,
name|_size
parameter_list|,
name|_dir
parameter_list|)
define|\
value|dma_unmap_single((_hwdev) == NULL ? NULL :&(_hwdev)->dev,	\ 		_addr, _size, (enum dma_data_direction)_dir)
end_define

begin_define
define|#
directive|define
name|pci_unmap_sg
parameter_list|(
name|_hwdev
parameter_list|,
name|_sg
parameter_list|,
name|_nents
parameter_list|,
name|_dir
parameter_list|)
define|\
value|dma_unmap_sg((_hwdev) == NULL ? NULL :&(_hwdev)->dev,	\ 		_sg, _nents, (enum dma_data_direction)_dir)
end_define

begin_define
define|#
directive|define
name|pci_map_page
parameter_list|(
name|_hwdev
parameter_list|,
name|_page
parameter_list|,
name|_offset
parameter_list|,
name|_size
parameter_list|,
name|_dir
parameter_list|)
define|\
value|dma_map_page((_hwdev) == NULL ? NULL :&(_hwdev)->dev, _page,\ 		_offset, _size, (enum dma_data_direction)_dir)
end_define

begin_define
define|#
directive|define
name|pci_unmap_page
parameter_list|(
name|_hwdev
parameter_list|,
name|_dma_address
parameter_list|,
name|_size
parameter_list|,
name|_dir
parameter_list|)
define|\
value|dma_unmap_page((_hwdev) == NULL ? NULL :&(_hwdev)->dev,	\ 		_dma_address, _size, (enum dma_data_direction)_dir)
end_define

begin_define
define|#
directive|define
name|pci_set_dma_mask
parameter_list|(
name|_pdev
parameter_list|,
name|mask
parameter_list|)
value|dma_set_mask(&(_pdev)->dev, (mask))
end_define

begin_define
define|#
directive|define
name|pci_dma_mapping_error
parameter_list|(
name|_pdev
parameter_list|,
name|_dma_addr
parameter_list|)
define|\
value|dma_mapping_error(&(_pdev)->dev, _dma_addr)
end_define

begin_define
define|#
directive|define
name|pci_set_consistent_dma_mask
parameter_list|(
name|_pdev
parameter_list|,
name|_mask
parameter_list|)
define|\
value|dma_set_coherent_mask(&(_pdev)->dev, (_mask))
end_define

begin_define
define|#
directive|define
name|DECLARE_PCI_UNMAP_ADDR
parameter_list|(
name|x
parameter_list|)
value|DEFINE_DMA_UNMAP_ADDR(x);
end_define

begin_define
define|#
directive|define
name|DECLARE_PCI_UNMAP_LEN
parameter_list|(
name|x
parameter_list|)
value|DEFINE_DMA_UNMAP_LEN(x);
end_define

begin_define
define|#
directive|define
name|pci_unmap_addr
value|dma_unmap_addr
end_define

begin_define
define|#
directive|define
name|pci_unmap_addr_set
value|dma_unmap_addr_set
end_define

begin_define
define|#
directive|define
name|pci_unmap_len
value|dma_unmap_len
end_define

begin_define
define|#
directive|define
name|pci_unmap_len_set
value|dma_unmap_len_set
end_define

begin_typedef
typedef|typedef
name|unsigned
name|int
name|__bitwise
name|pci_channel_state_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|unsigned
name|int
name|__bitwise
name|pci_ers_result_t
typedef|;
end_typedef

begin_enum
enum|enum
name|pci_channel_state
block|{
comment|/* I/O channel is in normal state */
name|pci_channel_io_normal
init|=
operator|(
name|__force
name|pci_channel_state_t
operator|)
literal|1
block|,
comment|/* I/O to channel is blocked */
name|pci_channel_io_frozen
init|=
operator|(
name|__force
name|pci_channel_state_t
operator|)
literal|2
block|,
comment|/* PCI card is dead */
name|pci_channel_io_perm_failure
init|=
operator|(
name|__force
name|pci_channel_state_t
operator|)
literal|3
block|, }
enum|;
end_enum

begin_enum
enum|enum
name|pci_ers_result
block|{
comment|/* no result/none/not supported in device driver */
name|PCI_ERS_RESULT_NONE
init|=
operator|(
name|__force
name|pci_ers_result_t
operator|)
literal|1
block|,
comment|/* Device driver can recover without slot reset */
name|PCI_ERS_RESULT_CAN_RECOVER
init|=
operator|(
name|__force
name|pci_ers_result_t
operator|)
literal|2
block|,
comment|/* Device driver wants slot to be reset. */
name|PCI_ERS_RESULT_NEED_RESET
init|=
operator|(
name|__force
name|pci_ers_result_t
operator|)
literal|3
block|,
comment|/* Device has completely failed, is unrecoverable */
name|PCI_ERS_RESULT_DISCONNECT
init|=
operator|(
name|__force
name|pci_ers_result_t
operator|)
literal|4
block|,
comment|/* Device driver is fully recovered and operational */
name|PCI_ERS_RESULT_RECOVERED
init|=
operator|(
name|__force
name|pci_ers_result_t
operator|)
literal|5
block|, }
enum|;
end_enum

begin_comment
comment|/* PCI bus error event callbacks */
end_comment

begin_struct
struct|struct
name|pci_error_handlers
block|{
comment|/* PCI bus error detected on this device */
name|pci_ers_result_t
function_decl|(
modifier|*
name|error_detected
function_decl|)
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|dev
parameter_list|,
name|enum
name|pci_channel_state
name|error
parameter_list|)
function_decl|;
comment|/* MMIO has been re-enabled, but not DMA */
name|pci_ers_result_t
function_decl|(
modifier|*
name|mmio_enabled
function_decl|)
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|dev
parameter_list|)
function_decl|;
comment|/* PCI Express link has been reset */
name|pci_ers_result_t
function_decl|(
modifier|*
name|link_reset
function_decl|)
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|dev
parameter_list|)
function_decl|;
comment|/* PCI slot has been reset */
name|pci_ers_result_t
function_decl|(
modifier|*
name|slot_reset
function_decl|)
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|dev
parameter_list|)
function_decl|;
comment|/* Device driver may resume normal operations */
name|void
function_decl|(
modifier|*
name|resume
function_decl|)
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|dev
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_comment
comment|/* freeBSD does not support SRIOV - yet */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|pci_dev
modifier|*
name|pci_physfn
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|dev
parameter_list|)
block|{
return|return
name|dev
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|pci_is_pcie
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|dev
parameter_list|)
block|{
return|return
operator|!
operator|!
name|pci_pcie_cap
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u16
name|pcie_flags_reg
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|pos
decl_stmt|;
name|u16
name|reg16
decl_stmt|;
name|pos
operator|=
name|pci_find_capability
argument_list|(
name|dev
argument_list|,
name|PCI_CAP_ID_EXP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pos
condition|)
return|return
literal|0
return|;
name|pci_read_config_word
argument_list|(
name|dev
argument_list|,
name|pos
operator|+
name|PCI_EXP_FLAGS
argument_list|,
operator|&
name|reg16
argument_list|)
expr_stmt|;
return|return
name|reg16
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|pci_pcie_type
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|dev
parameter_list|)
block|{
return|return
operator|(
name|pcie_flags_reg
argument_list|(
name|dev
argument_list|)
operator|&
name|PCI_EXP_FLAGS_TYPE
operator|)
operator|>>
literal|4
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|pcie_cap_version
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|dev
parameter_list|)
block|{
return|return
name|pcie_flags_reg
argument_list|(
name|dev
argument_list|)
operator|&
name|PCI_EXP_FLAGS_VERS
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|pcie_cap_has_lnkctl
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|type
init|=
name|pci_pcie_type
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
name|pcie_cap_version
argument_list|(
name|dev
argument_list|)
operator|>
literal|1
operator|||
name|type
operator|==
name|PCI_EXP_TYPE_ROOT_PORT
operator|||
name|type
operator|==
name|PCI_EXP_TYPE_ENDPOINT
operator|||
name|type
operator|==
name|PCI_EXP_TYPE_LEG_END
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|pcie_cap_has_devctl
parameter_list|(
specifier|const
name|struct
name|pci_dev
modifier|*
name|dev
parameter_list|)
block|{
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|pcie_cap_has_sltctl
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|type
init|=
name|pci_pcie_type
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
name|pcie_cap_version
argument_list|(
name|dev
argument_list|)
operator|>
literal|1
operator|||
name|type
operator|==
name|PCI_EXP_TYPE_ROOT_PORT
operator|||
operator|(
name|type
operator|==
name|PCI_EXP_TYPE_DOWNSTREAM
operator|&&
name|pcie_flags_reg
argument_list|(
name|dev
argument_list|)
operator|&
name|PCI_EXP_FLAGS_SLOT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|bool
name|pcie_cap_has_rtctl
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|type
init|=
name|pci_pcie_type
argument_list|(
name|dev
argument_list|)
decl_stmt|;
return|return
name|pcie_cap_version
argument_list|(
name|dev
argument_list|)
operator|>
literal|1
operator|||
name|type
operator|==
name|PCI_EXP_TYPE_ROOT_PORT
operator|||
name|type
operator|==
name|PCI_EXP_TYPE_RC_EC
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|pcie_capability_reg_implemented
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|dev
parameter_list|,
name|int
name|pos
parameter_list|)
block|{
if|if
condition|(
operator|!
name|pci_is_pcie
argument_list|(
name|dev
argument_list|)
condition|)
return|return
name|false
return|;
switch|switch
condition|(
name|pos
condition|)
block|{
case|case
name|PCI_EXP_FLAGS_TYPE
case|:
return|return
name|true
return|;
case|case
name|PCI_EXP_DEVCAP
case|:
case|case
name|PCI_EXP_DEVCTL
case|:
case|case
name|PCI_EXP_DEVSTA
case|:
return|return
name|pcie_cap_has_devctl
argument_list|(
name|dev
argument_list|)
return|;
case|case
name|PCI_EXP_LNKCAP
case|:
case|case
name|PCI_EXP_LNKCTL
case|:
case|case
name|PCI_EXP_LNKSTA
case|:
return|return
name|pcie_cap_has_lnkctl
argument_list|(
name|dev
argument_list|)
return|;
case|case
name|PCI_EXP_SLTCAP
case|:
case|case
name|PCI_EXP_SLTCTL
case|:
case|case
name|PCI_EXP_SLTSTA
case|:
return|return
name|pcie_cap_has_sltctl
argument_list|(
name|dev
argument_list|)
return|;
case|case
name|PCI_EXP_RTCTL
case|:
case|case
name|PCI_EXP_RTCAP
case|:
case|case
name|PCI_EXP_RTSTA
case|:
return|return
name|pcie_cap_has_rtctl
argument_list|(
name|dev
argument_list|)
return|;
case|case
name|PCI_EXP_DEVCAP2
case|:
case|case
name|PCI_EXP_DEVCTL2
case|:
case|case
name|PCI_EXP_LNKCAP2
case|:
case|case
name|PCI_EXP_LNKCTL2
case|:
case|case
name|PCI_EXP_LNKSTA2
case|:
return|return
name|pcie_cap_version
argument_list|(
name|dev
argument_list|)
operator|>
literal|1
return|;
default|default:
return|return
name|false
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|pcie_capability_write_word
parameter_list|(
name|struct
name|pci_dev
modifier|*
name|dev
parameter_list|,
name|int
name|pos
parameter_list|,
name|u16
name|val
parameter_list|)
block|{
if|if
condition|(
name|pos
operator|&
literal|1
condition|)
return|return
operator|-
name|EINVAL
return|;
if|if
condition|(
operator|!
name|pcie_capability_reg_implemented
argument_list|(
name|dev
argument_list|,
name|pos
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
name|pci_write_config_word
argument_list|(
name|dev
argument_list|,
name|pci_pcie_cap
argument_list|(
name|dev
argument_list|)
operator|+
name|pos
argument_list|,
name|val
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _LINUX_PCI_H_ */
end_comment

end_unit

